Business Analytic Request,Ground Truth Code,Generated Code by Base Model,Explanation by Base Model,Generated Code by Finetuned Model,Explanation by Finetuned Model,Model that got it right
What was the average order value in Q1 of 2023?,"import pandas as pd

# SQL query to get the total value of orders and the count of unique orders in Q1 of 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AvgOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Create a final dataframe to show the result
final_df = pd.DataFrame({'AvgOrderValue': [result_df['AvgOrderValue'].iloc[0]]})

# Display the result to the user
show_to_user(final_df)","import pandas as pd

# Define the SQL query to calculate the average order value in Q1 of 2023
sql_query = '''
SELECT
    AVG(SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))) AS AverageOrderValue
FROM
    orders
JOIN
    [Order Details]
ON
    orders.OrderID = [Order Details].OrderID
WHERE
    orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-04-01'
GROUP BY
    orders.OrderID
'''  

# Execute the SQL query and retrieve the data
average_order_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_order_value_df)","The input Python code contains an error in the SQL query. The use of AVG(SUM(...)) is incorrect for calculating the average order value. Instead, the SUM should be divided by the COUNT of distinct orders as done in the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the total sales in Q1 of 2023
sql_total_sales_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the SQL query
total_sales_df = execute_sql_query(sql_total_sales_query)

# Get the total sales value
total_sales = total_sales_df.iloc[0]['total_sales']

# Define the SQL query to get the total orders in Q1 of 2023
sql_total_orders_query = '''
SELECT COUNT(DISTINCT [Order Details].OrderID) AS total_orders 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the SQL query
total_orders_df = execute_sql_query(sql_total_orders_query)

# Get the total orders value
total_orders = total_orders_df.iloc[0]['total_orders']

# Calculate the average order value in Q1 of 2023
avg_order_value = total_sales / total_orders
result_df = pd.DataFrame({'avg_order_value_q1_2023': [avg_order_value]})

# Display the result to the user
show_to_user(result_df)","The given code implementation correctly calculates the average order value in Q1 of 2023 by retrieving total sales and unique order counts separately and then computing the average, which meets the business analytic request and aligns with the reference implementation.",Finetuned
Which products have the lowest units in stock?,"import pandas as pd
import plotly.express as px

# SQL Query to get products with the lowest units in stock
sql_query = 'SELECT ProductID, ProductName, UnitsInStock FROM products ORDER BY UnitsInStock ASC LIMIT 1;'

# Execute the SQL query to get the data
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)
","import pandas as pd

# SQL query to find products with the lowest units in stock
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0
ORDER BY UnitsInStock ASC
LIMIT 10;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code does not strictly match the business analytic request. The business request asks for products with the lowest units in stock, and the reference implementation on retrieves a single product with the lowest units in stock. Instead, the input code retrieves the 10 products with the lowest units in stock. This expands the scope beyond what was requested.","import pandas as pd

# Define the SQL query to get products with the lowest units in stock
sql_query = ""SELECT ProductName, UnitsInStock FROM products ORDER BY UnitsInStock ASC LIMIT 10;""

# Execute the SQL query to get the data
products_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(products_df)",The Input Python code retrieves the 10 products with the lowest units in stock instead of just the single product with the lowest units in stock as specified in the Business Analytic Request.,None
Which customers placed the highest number of orders last year? Include a data visualization to compare the number of orders placed by these customers.,"
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY CustomerID 
ORDER BY OrderCount DESC
'''

# Execute the SQL query to retrieve data
customer_orders_df = execute_sql_query(sql_query)

# Check if the dataframe has the required columns
if 'CustomerID' in customer_orders_df.columns and 'OrderCount' in customer_orders_df.columns:
    # Generate a plotly bar chart for data visualization
    fig = px.bar(customer_orders_df, x='CustomerID', y='OrderCount', title='Number of Orders by Customer Last Year', labels={'CustomerID':'Customer ID', 'OrderCount':'Order Count'}, text_auto=True)
    
    # Show the visualization to the user
    show_to_user(fig)
else:
    show_to_user(customer_orders_df)
","import pandas as pd
import plotly.express as px

# SQL query to retrieve the customer orders for the last year
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate >= DATE_FORMAT(NOW() - INTERVAL 1 YEAR, '%Y-01-01') 
GROUP BY CustomerID 
ORDER BY OrderCount DESC;
'''  

# Execute the SQL query and get the data
customer_orders = execute_sql_query(sql_query)

# Show the top customers by Order Count
show_to_user(customer_orders)

# Create a bar chart to visualize the number of orders by these customers
graph = px.bar(customer_orders,
               x='CustomerID',
               y='OrderCount',
               title='Highest Number of Orders Placed by Customers Last Year',
               labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'},
               color='OrderCount')

show_to_user(graph)","The input code incorrectly calculates the date range for the last year (it includes part of the current year). It uses 'OrderDate >= DATE_FORMAT(NOW() - INTERVAL 1 YEAR, '%Y-01-01')' which starts from January 1st of the previous year instead of considering the entire previous year correctly. The correct condition should be 'WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1' to ensure it limits records to only last year.","import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT c.CustomerID, COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY c.CustomerID 
ORDER BY OrderCount DESC
'''

# Step 2: Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Step 3: Use plotly to create a bar chart visualization
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Number of Orders Placed by Customers Last Year', labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'})

# Step 4: Display the visualization to the user
show_to_user(fig)","The input Python code correctly follows the constraint of using the execute_sql_query function to retrieve the data and the show_to_user function to display the results. It also effectively retrieves the necessary information about the number of orders placed by customers last year and visualizes it using a plotly bar chart. The main differences between the reference implementation and the input code, such as table joins and column references, do not affect the correctness or output of the code.",Finetuned
Calculate the total revenue generated by each product. Use a bar chart to illustrate the revenue generated by each product.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName;
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the revenue generated by each product
fig = px.bar(result_df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product', labels={'ProductName': 'Product Name', 'TotalRevenue': 'Total Revenue'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue generated by each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
'''  

# Execute the SQL query and retrieve the data in a pandas dataframe
data = execute_sql_query(sql_query)

# Create a bar chart to illustrate the revenue generated by each product
fig = px.bar(data, x='ProductName', y='TotalRevenue', title='Total Revenue by Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

# Show the chart to the user
show_to_user(fig)","The provided code correctly follows the business analytic request. It calculates the total revenue generated by each product, including discounts, groups the results by ProductName, and utilizes a bar chart to visualize the results. The differences from the reference implementation, such as the inclusion of the discount factor and the use of primary key ProductID in the GROUP BY clause, are valid. The Python environment constraints are also adhered to.","import plotly.express as px

# SQL Query to calculate the total revenue generated by each product
sql_query = '''
SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue
FROM [Order Details]
GROUP BY ProductID;
'''

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Check if the DataFrame has the expected columns
if 'ProductID' in df.columns and 'TotalRevenue' in df.columns:
    # Create a bar chart using Plotly
    fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue Generated by Each Product', labels={'ProductID':'Product ID', 'TotalRevenue':'Total Revenue'})
    
    # Show the plot to the user
    show_to_user(fig)
else:
    print('Unexpected columns in the dataframe. Expected ""ProductID"" and ""TotalRevenue"".')
","The input code does not join the [Order Details] and products tables in the SQL query, so it cannot fetch the product names. The grouping is done by ProductID, not by ProductName, which doesn't meet the specified requirement.",Base
Which customers are from the United States?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT CustomerID FROM orders WHERE ShipCountry = 'USA'""

# Execute the query to get the dataframe
customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_df)","import pandas as pd

# SQL query to select customers from the United States
sql_query = """"""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE ShipCountry = 'United States'
""""""

# Execute the SQL query and retrieve the data
us_customers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(us_customers_df)",The input code correctly retrieves the CustomerID of customers from the orders table where the ShipCountry is 'United States' and displays the result. The logic matches the business analytic request and the environment constraints specified.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT * FROM customers WHERE Country = 'USA';""

# Execute the SQL query to get the data
customers_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(customers_df)
","The provided code correctly retrieves and displays customers from the United States by querying the 'customers' table where the Country is 'USA'. This aligns with the business analytic request, and the use of the 'execute_sql_query' and 'show_to_user' utility functions is appropriate.",both
List the products that are being sold at a discount (UnitPrice in orders < UnitPrice in products).,"import pandas as pd
import plotly.express as px

# Define the SQL query based on the given business request
sql_query = '''
SELECT p.ProductName 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
WHERE od.UnitPrice < p.UnitPrice;
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the resulting data to the user
show_to_user(result_df)","import pandas as pd

# SQL query to get the products sold at a discount
sql_query = '''
SELECT p.ProductID, p.ProductName, p.UnitPrice AS OriginalPrice, od.UnitPrice AS DiscountedPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.UnitPrice < p.UnitPrice
'''  

# Execute the SQL query to retrieve the data
products_on_discount = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(products_on_discount)","The input Python code correctly retrieves and displays the products sold at a discount by comparing the UnitPrice in the 'Order Details' table to that in the 'products' table. The code uses the appropriate SQL query and matches the business analytic request, though it provides additional columns (ProductID, OriginalPrice, DiscountedPrice) which can be useful.","import pandas as pd
import plotly.express as px

# SQL Query to find products sold at a discount
sql_query = """"""
SELECT p.ProductName 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
WHERE od.UnitPrice < p.UnitPrice;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)

# Optional: Visualization - count of products sold at a discount
count_df = result_df.value_counts().reset_index(name='Count').rename(columns={'index': 'ProductName'})
fig = px.bar(count_df, x='ProductName', y='Count', title='Number of Discounted Products Sold')

# Show the visualization graph to the user
show_to_user(fig)","The input Python code correctly performs the required business analytics task by identifying products sold at a discount. It includes the specified SQL query, utilizes the provided utility functions to execute the query and display the results, and adds an optional visualization component to show the count of discounted products, which is an acceptable enhancement.",both
Which employees generated the highest sales revenue in April 2023? Provide a visualization to compare the sales revenue generated by these employees.,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the data
sql_query = '''
SELECT employees.FirstName, employees.LastName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC
'''

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Concatenate first name and last name to create a full name column
sales_data['EmployeeName'] = sales_data['FirstName'] + ' ' + sales_data['LastName']

# Create the bar chart visualization using Plotly
fig = px.bar(sales_data, x='EmployeeName', y='total_sales', title='Total Sales Revenue by Employee in April 2023', labels={'total_sales': 'Total Sales Revenue', 'EmployeeName': 'Employee Name'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to get employee sales in April 2023
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN employees e ON o.EmployeeID = e.EmployeeID
WHERE o.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
LIMIT 10
""""""

# Step 2: Execute the SQL query
employee_sales_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart using plotly
fig = px.bar(employee_sales_df, x='EmployeeName', y='TotalSales',
             title='Top Employees by Sales Revenue in April 2023',
             labels={'TotalSales': 'Sales Revenue', 'EmployeeName': 'Employee Name'},
             color='TotalSales')

# Step 4: Show the figure to the user
show_to_user(fig)","The input code correctly defines and executes the SQL query to retrieve the total sales revenue generated by employees in April 2023. It then creates a bar chart using Plotly to visualize the data, meeting the specified business request. The overall structure and logical flow match the reference implementation and the added 'LIMIT 10' clause is a reasonable enhancement to display the top 10 employees.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details]
JOIN orders ON orders.OrderID = [Order Details].OrderID 
JOIN employees ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID 
ORDER BY employee_sales DESC
'''

# Execute the SQL query to fetch the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(sales_data, x='EmployeeID', y='employee_sales', title='Sales Revenue Generated by Employees in April 2023', labels={'employee_sales': 'Sales Revenue ($)', 'EmployeeID': 'Employee ID'})

# Show the visualization to the user
show_to_user(fig)
","The code doesn't fully comply with the business request. The code fetches employee sales data correctly but does not include employee names, which are necessary for the requested visualization.",Base
What is the average order value handled by each employee? Use a bar chart to compare the average order value handled by each employee.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT employees.EmployeeID, AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderValue 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
'''

# Execute SQL Query to retrieve data
employee_order_data = execute_sql_query(sql_query)

# Create a bar chart for average order value handled by each employee
fig = px.bar(employee_order_data, x='EmployeeID', y='AvgOrderValue', title='Average Order Value Handled by Each Employee')

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get average order value by each employee
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
'''

# Execute the SQL query
average_order_value_df = execute_sql_query(sql_query)

# Creating a bar chart to visualize average order value per employee
fig = px.bar(
    average_order_value_df,
    x='FirstName',
    y='AverageOrderValue',
    color='LastName',
    title='Average Order Value Handled by Each Employee',
    labels={'AverageOrderValue': 'Average Order Value', 'FirstName': 'Employee First Name'}
)

# Show the figure to the user
show_to_user(fig)","The input Python code correctly implements the business analytic request by querying the average order value handled by each employee, creating a relevant bar chart, and displaying it. The code makes only slight modifications, like including the first and last names of employees for better labeling, which does not affect the correctness of the solution.","To address the request of calculating and visualizing the average order value handled by each employee, we will proceed through the following steps:

1. **Define the SQL query** to fetch the required data.
2. **Execute the SQL query** using the provided utility function `execute_sql_query`.
3. **Process the data** to extract necessary information for visualization.
4. **Generate a bar chart** using the `plotly.express` library to compare the average order value handled by each employee.
5. **Use the utility function `show_to_user`** to display the result to the user.

Hereâ€™s the Python code that implements the above steps:

```python
import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = '''
SELECT e.EmployeeID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Verify the data
print(result_df.head())

# Create a bar chart for average order value handled by each employee
fig = px.bar(result_df, x='EmployeeID', y='AverageOrderValue', 
             title='Average Order Value Handled by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'AverageOrderValue': 'Average Order Value ($)'})

# Display the bar chart
show_to_user(fig)
```

### Explanation of the Code
- **SQL Query**: The SQL query joins the `employees`, `orders`, and `[Order Details]` tables to compute the average order value for each employee. 
- **Execute SQL Query**: We execute the SQL query to get a pandas dataframe containing the relevant data.
- **Create Bar Chart**: We use the `plotly.express` library to create a bar chart, specifying the x-axis as `EmployeeID` and the y-axis as `AverageOrderValue`. Additionally, titles and labels are provided for clarity.
- **Show to User**: Finally, we use the provided utility function to display the visualization to the user.

### Important Note
Before running the above code, ensure that the necessary libraries (`pandas`, `plotly`) are installed in your environment, and the utility functions `execute_sql_query` and `show_to_user` are accessible.",The provided Python code meets the prescribed requirements. Both the SQL query and data processing steps are correct and align with the reference implementation. The final visualization using Plotly and the display with 'show_to_user' are also accurate as per the business analytic request.,both
Find the total revenue generated by each product. Use a bar chart to illustrate the revenue generated by each product.,"import pandas as pd
import plotly.express as px

# Define and execute the SQL query
sql_query = 'SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue FROM [Order Details] GROUP BY ProductID;'
df = execute_sql_query(sql_query)

# Generate the bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product', labels={'ProductID': 'Product ID', 'TotalRevenue': 'Total Revenue'})

# Display the chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to find total revenue generated by each product
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""  

# Execute the SQL query
revenue_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(revenue_df, x='ProductName', y='TotalRevenue', title='Total Revenue Generated by Each Product')

# Display the chart to the user
show_to_user(fig)","The provided code correctly calculates the total revenue generated by each product and displays it using a bar chart. The code executes an SQL query to aggregate the revenue per product, including discounts, and then uses Plotly to generate the bar chart, which satisfies the business analytic request and the environment constraints.","# Import necessary libraries
import plotly.express as px

# SQL query to get the total revenue generated by each product
sql_query = """"""
SELECT p.ProductID, SUM(od.UnitPrice * od.Quantity) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID;
""""""

# Execute SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Create a bar chart using plotly express
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Display the chart to the user
show_to_user(fig)","The input code correctly constructs the SQL query to retrieve total revenue per product, executes the query with the provided function, and then creates and displays a bar chart using Plotly. It follows the given environment constraints and meets the business analytic request.",both
Calculate the inventory turnover ratio for each month. Create a line graph to show the inventory turnover ratio trend over the months.,"import pandas as pd
import plotly.express as px

# SQL query to calculate the inventory turnover ratio for each month
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) as InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
'''

# Execute the SQL query to retrieve data
inventory_turnover_df = execute_sql_query(sql_query)

# Ensure that the Month column is interpreted as a date
inventory_turnover_df['Month'] = pd.to_datetime(inventory_turnover_df['Month'], format='%Y-%m')

# Sort the dataframe by 'Month'
inventory_turnover_df = inventory_turnover_df.sort_values(by='Month')

# Create the line graph using plotly
fig = px.line(inventory_turnover_df, x='Month', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio Trend Over Months')

# Display the line graph to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate Inventory Turnover Ratio
sql_query = '''
SELECT  
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,  
    SUM(order_details.Quantity * order_details.UnitPrice) AS CostOfGoodsSold,  
    AVG(products.UnitsInStock) AS AverageInventory,  
    (SUM(order_details.Quantity * order_details.UnitPrice) / AVG(products.UnitsInStock)) AS InventoryTurnoverRatio  
FROM  
    products  
JOIN  
    [Order Details] AS order_details ON products.ProductID = order_details.ProductID  
JOIN  
    orders ON order_details.OrderID = orders.OrderID  
WHERE  
    orders.OrderDate IS NOT NULL  
GROUP BY  
    Month  
ORDER BY  
    Month;
'''

# Execute the SQL query
inventory_turnover_df = execute_sql_query(sql_query)

# Create the line graph for Inventory Turnover Ratio
fig = px.line(inventory_turnover_df, x='Month', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio Trend', labels={'InventoryTurnoverRatio':'Inventory Turnover Ratio', 'Month':'Month'})

# Show the result to user
show_to_user(fig)","The input Python code correctly queries the necessary data, calculates the inventory turnover ratio, sorts by month, and visualizes the data using a line graph, which satisfies the business analytic request. The structure of the SQL query and the data processing steps closely follow the reference implementation.","To calculate the inventory turnover ratio and create a line graph based on the provided SQL query, follow these steps:

1. Run the SQL query to retrieve the data.
2. Process the retrieved data to ensure it's in the correct format, if necessary.
3. Use Matplotlib to create and display the line graph.

Here's the complete code for the task:

```python
import pandas as pd
import plotly.express as px

# SQL query to calculate Inventory Turnover Ratio
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY Month 
ORDER BY Month""""""  # Added ORDER BY Month to ensure chronological x-axis

# Execute the SQL query to retrieve data
inventory_data = execute_sql_query(sql_query)

# Convert the 'Month' column to datetime format for better plotting
inventory_data['Month'] = pd.to_datetime(inventory_data['Month'], format='%Y-%m')

# Create a line graph using plotly
fig = px.line(inventory_data, x='Month', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio by Month', labels={'Month':'Month', 'InventoryTurnoverRatio':'Inventory Turnover Ratio'})

# Display the plot to the user
show_to_user(fig)
```

### Overview of the Code
- The SQL query retrieves the Inventory Turnover Ratio for each month grouped by month.
- After executing the SQL query and getting the resulting DataFrame, the 'Month' column is converted to a datetime format to ensure correct chronological ordering when plotted.
- Finally, a line graph is created using Plotly and displayed to the user with the `show_to_user()` function.","The input code correctly calculates the inventory turnover ratio and creates a line graph using Plotly, matching the intent and output of the reference implementation. It retrieves data using the provided SQL query, processes the data appropriately, and visualizes it as required.",both
What is the performance of products based on sales and inventory levels for each month in 2022? Use a combined bar and line chart to illustrate sales and inventory levels.,"import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# Define the SQL query
sql_query = '''
SELECT products.ProductID, MONTH(orders.OrderDate) AS order_month, 
       SUM([Order Details].Quantity) AS product_performance 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, order_month
'''

# Execute the query and get a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Aggregate sales performance per month
monthly_sales = sales_data.groupby('order_month').agg({'product_performance': 'sum'}).reset_index()

# Assuming we have a way to get inventory levels per month
# This part of the data is not provided by the SQL query and needs to be fetched separately
# For the purpose of this example, we will create a placeholder dataframe for inventory levels
inventory_levels = pd.DataFrame({
    'order_month': range(1, 13),
    'inventory_level': [1000, 850, 900, 950, 1100, 1050, 1150, 1200, 750, 800, 950, 1000]
})

# Combine sales and inventory data
combined_data = pd.merge(monthly_sales, inventory_levels, on='order_month')

# Create the combined bar and line chart
fig = go.Figure()

# Add bar chart for sales performance
fig.add_trace(go.Bar(
    x=combined_data['order_month'],
    y=combined_data['product_performance'],
    name='Product Performance',
    marker_color='indigo'
))

# Add line chart for inventory levels
fig.add_trace(go.Scatter(
    x=combined_data['order_month'],
    y=combined_data['inventory_level'],
    name='Inventory Level',
    mode='lines+markers',
    marker_color='gold'
))

# Customize layout
fig.update_layout(
    title='Monthly Product Performance and Inventory Levels for 2022',
    xaxis=dict(title='Month'),
    yaxis=dict(title='Quantity'),
    barmode='group'
)

# Show the plot to the user
show_to_user(fig)
","import pandas as pd
import plotly.graph_objects as go

# SQL queries to get sales and inventory data for each month in 2022
sales_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY 
    month
ORDER BY 
    month
""""""

inventory_query = """"""
SELECT 
    DATE_FORMAT(products.ReorderLevel, '%Y-%m') AS month,
    SUM(products.UnitsInStock) AS total_inventory
FROM 
    products
GROUP BY 
    month
ORDER BY 
    month
""""""

# Execute SQL queries
sales_data = execute_sql_query(sales_query)
inventory_data = execute_sql_query(inventory_query)

# Merge the data on month
performance_data = pd.merge(sales_data, inventory_data, on='month', how='outer')
performance_data.columns = ['month', 'total_sales', 'total_inventory']

# Create combined bar and line chart
fig = go.Figure()

# Add total sales as bar chart
fig.add_trace(go.Bar(
    x=performance_data['month'],
    y=performance_data['total_sales'],
    name='Total Sales',
    marker_color='blue'
))

# Add total inventory as line chart
fig.add_trace(go.Scatter(
    x=performance_data['month'],
    y=performance_data['total_inventory'],
    name='Total Inventory',
    mode='lines+markers',
    line=dict(color='orange', width=4)
))

# Update layout
fig.update_layout(
    title='Product Performance Analysis (2022)',
    xaxis_title='Month',
    yaxis_title='Amount',
    barmode='group'
)

# Show result to the user
show_to_user(fig)","The input Python code does not correctly match the business analytic request. While it does use SQL queries to gather sales and inventory data and plots them in a combined bar and line chart, it has a critical issue: the inventory data query uses 'products.ReorderLevel' to derive month data, which does not make sense in context. Additionally, 'products.UnitsInStock' is aggregated without considering monthly changes, causing inaccurate monthly inventory levels. The reference implementation assumes static or external predefined monthly inventory data, which might be more appropriate depending on the actual dataset structure. Minor cosmetic differences (e.g., colors) also exist, but the major issue is correctly matching inventory levels per month.","Here's a detailed implementation of the given requirement using Plotly for visualization, assuming the SQL query will return the correct data as described.

### Python Code

```python
import pandas as pd
import plotly.graph_objects as go

# SQL query to fetch sales and inventory levels for each month in 2022
sql_query = '''
SELECT DATENAME(month, o.OrderDate) AS month_name, p.ProductID, 
       SUM(od.Quantity) AS total_quantity, 
       AVG(p.UnitsInStock) AS avg_inventory 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY DATENAME(month, o.OrderDate), p.ProductID
''' 

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Convert month names to a categorical type to ensure proper sorting
months_order = [""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""]
products_df['month_name'] = pd.Categorical(products_df['month_name'], categories=months_order, ordered=True)

# Create a combined bar and line chart using Plotly
fig = go.Figure()

# Create bar chart for total_quantity
for product_id in products_df['ProductID'].unique():
    product_data = products_df[products_df['ProductID'] == product_id]
    fig.add_trace(go.Bar(
        x=product_data['month_name'], 
        y=product_data['total_quantity'], 
        name=f'Product {product_id} - Sales', 
        showlegend=True
    ))

# Create line chart for avg_inventory
# Note: Ensure to aggregate avg_inventory for the line chart appropriately
avg_inventory_df = products_df.groupby('month_name', as_index=False).agg({'avg_inventory': 'mean'})
fig.add_trace(go.Scatter(
    x=avg_inventory_df['month_name'], 
    y=avg_inventory_df['avg_inventory'], 
    mode='lines+markers', 
    name='Average Inventory', 
    showlegend=True
))

# Update layout to provide a title and legends
fig.update_layout(
    title='Product Performance Based on Sales and Inventory Levels (2022)',
    xaxis_title='Month',
    yaxis_title='Quantity',
    legend_title='Products'
)

# Show the plot to the user
show_to_user(fig)
```

### Explanation
1. **Data Retrieval**: Execute the SQL query to get the data.
2. **Data Processing**: Ensure the months are ordered correctly for better visualization.
3. **Data Visualization**: 
   - Use a combined bar and line chart to depict both sales (bar chart) and average inventory (line chart) levels.
   - Added separate traces for each product's sales data and a single trace for average inventory.
4. **Display the Result**: Use the `show_to_user` utility to present the final chart. 

Make sure to have the required libraries installed in your environment.","The provided implementation does not correctly address the business analytic request. It aggregates sales data per product rather than per month, leading to segmented bar charts by product instead of a combined monthly view. Also, it computes average inventory for each product but does not align with the requested monthly total inventory level data.",None
What is the total sales revenue generated by each customer? Provide a visualization to compare the sales revenue generated by each customer.,"import pandas as pd
import plotly.express as px

# SQL query to get the total sales revenue generated by each customer
sql_query = '''
SELECT CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY CustomerID 
ORDER BY TotalSales DESC;
'''

# Execute the SQL query and retrieve the data in a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Visualize the sales revenue generated by each customer using a bar chart
fig = px.bar(sales_data, x='CustomerID', y='TotalSales', title='Total Sales Revenue by Customer', labels={'CustomerID':'Customer ID', 'TotalSales':'Total Sales Revenue'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue generated by each customer
sql_query = '''
SELECT 
    o.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.CustomerID
'''

# Execute the SQL query and get the result as a DataFrame
customer_sales = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(customer_sales, x='CustomerID', y='TotalSales',
             title='Total Sales Revenue by Customer',
             labels={'TotalSales': 'Total Sales', 'CustomerID': 'Customer ID'},
             color='TotalSales',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the results to the user
show_to_user(fig)","The given Python code implementation correctly tracks the total sales revenue generated by each customer and provides a visualization using Plotly. It follows the Python environment constraints by using the execute_sql_query function to get the data and show_to_user function to display the graph. While there are minor differences in details such as the use of a color gradient in the bar chart, these do not affect the correctness of the solution.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT customers.CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID
'''

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Ensure the columns are correctly named for plotting
df.columns = ['CustomerID', 'total_sales']

# Create a bar chart to visualize total sales by each customer
fig = px.bar(df, x='CustomerID', y='total_sales', title='Total Sales Revenue by Each Customer', labels={'CustomerID': 'Customer ID', 'total_sales': 'Total Sales Revenue'})

# Display the visualization to the user
show_to_user(fig)",The input Python code correctly implements the business analytic request by calculating the total sales revenue generated by each customer and visualizing it using a bar chart. It follows the specified Python environment constraints and the generated output aligns well with the reference implementation.,both
Which employee has processed the most orders for customers in the USA?,"import pandas as pd
import plotly.express as px

# Define the SQL query from the given request
sql_query = '''
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShipCountry = 'USA' 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","import pandas as pd

# SQL query to fetch employee order processing data for customers in the USA
the_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShipCountry = 'USA'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OrderCount DESC
LIMIT 1;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(the_query)

# Display the result to the user
show_to_user(data)","The input Python code correctly implements the SQL query needed to identify which employee has processed the most orders for customers in the USA. It appropriately uses the provided functions 'execute_sql_query' to execute the SQL query and 'show_to_user' to display the result. Although the variable names and some formatting differ slightly, the essential logic and operations are consistent with the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the employee who processed the most orders for customers in the USA
sql_query = '''
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE customers.Country = 'USA' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY OrderCount DESC limit 1
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","The input code incorrectly joins the 'customers' table for obtaining the 'Country' as the ship country, instead of directly using 'orders.ShipCountry' as in the business analytic request and reference implementation. The business request specifically asks for the employee who processed the most orders for USA customers based on the 'ShipCountry' in the 'orders' table, not the 'Country' in the 'customers' table.",Base
Which product had the highest sales quantity in the last month? Use a bar chart to show the sales quantities of products.,"import plotly.express as px
import pandas as pd

# SQL query to get product sales quantities for the last month
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalQuantity DESC;
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Check if any data is returned
if not sales_data.empty:
    # Generate a bar chart using plotly
    fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Sales Quantities of Products in the Last Month')
    
    # Show the bar chart to the user
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Message': ['No sales data available for the last month']}))","import pandas as pd
import plotly.express as px

# Define the SQL query to get the sales quantities of products for the last month
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID
    FROM orders
    WHERE OrderDate >= DATEADD(month, -1, GETDATE())
)
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
""""""

# Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Get the product with the highest sales quantity
highest_sales_product = sales_data.iloc[0]

# Create a bar chart to show the sales quantities of products
fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Sales Quantities of Products in the Last Month')

# Show the result to the user
show_to_user(fig)

# Output the product with the highest sales quantity
highest_sales_product","The provided Input Python Code can correctly retrieve sales data of products for the last month, identify the product with the highest sales quantity, and generate a bar chart using Plotly. It follows the environment constraints and matches the requirements of the business analytic request.","import plotly.express as px
import pandas as pd

# SQL query to get the sales quantities of products in the last month
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE MONTH(o.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(o.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) 
GROUP BY p.ProductName 
ORDER BY TotalQuantity DESC;
'''

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Plot the sales quantities as a bar chart
fig = px.bar(sales_data, x='ProductName', y='TotalQuantity')

# Show the plot to the user
show_to_user(fig)
","The input code correctly implements the business analytic request by querying the sales data for the last month, generating a bar chart of the sales quantities of products, and showing the chart to the user. It adheres to the given Python environment constraints and matches the reference implementation in functionality, including the SQL query for last month's data and the appropriate use of the provided utility functions.",both
"For each employee, what is the average number of orders handled per month in 2023? Use a line graph to show the average number of orders handled each month.","import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = '''
SELECT employees.EmployeeID, AVG(order_count) AS avg_orders_per_month
FROM (SELECT employees.EmployeeID, COUNT(orders.OrderID) AS order_count, 
             MONTH(orders.OrderDate) AS order_month
      FROM employees
      LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID
      GROUP BY employees.EmployeeID, MONTH(orders.OrderDate)) AS temp
GROUP BY employees.EmployeeID
'''

# Execute the SQL query and get the data
employee_avg_orders_df = execute_sql_query(sql_query)

# Extracting month and average orders data for plotting
# Correct the aggregation part as we need month-wise average
avg_orders_per_month_df = employee_avg_orders_df.groupby('order_month')['avg_orders_per_month'].mean().reset_index()

# Creating the line plot with Plotly
fig = px.line(avg_orders_per_month_df, x='order_month', y='avg_orders_per_month',
              title='Average Number of Orders Handled Per Month in 2023',
              labels={'order_month':'Month', 'avg_orders_per_month':'Average Orders Per Month'})

# Show the visualized plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total orders handled by each employee per month for the year 2023
sql_query = """"""
SELECT
    employees.EmployeeID,
    MONTH(orders.OrderDate) AS month,
    COUNT(orders.OrderID) AS order_count
FROM
    orders
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE
    YEAR(orders.OrderDate) = 2023
GROUP BY
    employees.EmployeeID,
    MONTH(orders.OrderDate)
""""""

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Pivot the data to have months as columns and calculate the average orders per month for each employee
pivot_data = order_data.pivot_table(index='EmployeeID', columns='month', values='order_count', fill_value=0)

# Calculate the average number of orders handled per month for each employee
average_orders_per_employee = pivot_data.mean(axis=1).reset_index()
average_orders_per_employee.columns = ['EmployeeID', 'AvgOrdersPerMonth']

# Create a line graph to visualize the average number of orders handled each month
fig = px.line(average_orders_per_employee, x='EmployeeID', y='AvgOrdersPerMonth', title='Average Number of Orders Handled Per Month in 2023')

# Show the plot to the user
show_to_user(fig)","The user's code incorrectly creates the pivot table and calculates the average number of orders per employee across all months, instead of calculating the average number of orders per month across all employees. Furthermore, the line graph visualizes the average orders per month for each employee instead of the average orders per month across all employees.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) / 12 AS AvgOrdersPerMonth
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY EmployeeID;
'''

# Execute the SQL query and get the results
employee_orders_df = execute_sql_query(sql_query)

# Separate the EmployeeID and AvgOrdersPerMonth for visualization by month
long_format_df = employee_orders_df.melt(id_vars=[""EmployeeID""], var_name=""Metric"", value_name=""Value"")
month_format_df = employee_orders_df.copy()  # This is already in a suitable format

# Create a line graph using Plotly
fig = px.line(month_format_df, x='EmployeeID', y='AvgOrdersPerMonth', title='Average Orders Handled Per Month in 2023 by Employee', labels={'AvgOrdersPerMonth': 'Average Orders Per Month'})

# Show the plot to the user
show_to_user(fig)","The provided code does not calculate the average orders per month per employee correctly. It divides the count of orders by 12, assuming each employee has orders in each month of 2023, which is not accurate. It needs to calculate the average for each month separately and then aggregate them. Also, the output visualization is plotting against EmployeeID which is incorrect. The graph should plot average orders per month aggregated across all employees, by month.",None
How many discontinued products are still in stock?,"import pandas as pd

# Define SQL query
sql_query = ""SELECT COUNT(*) AS DiscontinuedInStock FROM products WHERE Discontinued = 1 AND UnitsInStock > 0;""

# Execute SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Extract count value from the dataframe to display it properly
discontinued_in_stock = result_df['DiscontinuedInStock'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'DiscontinuedInStock': [discontinued_in_stock]}))","import pandas as pd

# SQL query to retrieve count of discontinued products still in stock
sql_query = '''
SELECT COUNT(*) AS DiscontinuedInStock
FROM products
WHERE Discontinued = 1 AND UnitsInStock > 0
'''  

# Execute the query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code correctly formulates the SQL query to count discontinued products that are still in stock. It then executes this query and displays the result using the provided utility functions, fulfilling the business analytic request.","import pandas as pd
import plotly.express as px

def main():
    # SQL Query to get the total units in stock of discontinued products
    sql_query = 'SELECT SUM(UnitsInStock) AS TotalUnits FROM products WHERE Discontinued = 1;'
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    total_units = df.iloc[0]['TotalUnits']
    
    # Convert total units to DataFrame for display purposes
    result_df = pd.DataFrame({'TotalUnits': [total_units]})
    
    # Display result to user
    show_to_user(result_df)

# Call the main function
main()","The input Python code calculates the total units in stock of discontinued products rather than counting the number of discontinued products that are still in stock. The SQL query should count the rows where 'Discontinued' is 1 and 'UnitsInStock' is greater than 0, similar to the SQL query in the reference implementation.",Base
Determine the most frequently used shipping method. Include a pie chart to show the distribution of shipping methods.,"import plotly.express as px

# SQL query to get the most frequently used shipping method
sql_query = 'SELECT ShipVia, COUNT(OrderID) AS UseCount FROM orders GROUP BY ShipVia ORDER BY UseCount DESC LIMIT 1;'

# Execute the SQL query
most_freq_shipping_df = execute_sql_query(sql_query)

# SQL query to get the distribution of all shipping methods
sql_query_distribution = 'SELECT ShipVia, COUNT(OrderID) AS UseCount FROM orders GROUP BY ShipVia;'

# Execute the SQL query
shipping_distribution_df = execute_sql_query(sql_query_distribution)

# Create a pie chart to show the distribution of shipping methods
fig = px.pie(shipping_distribution_df, names='ShipVia', values='UseCount', title='Distribution of Shipping Methods')

# Display the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve shipping methods from the orders table
sql_query = ""SELECT ShipVia FROM orders""

# Execute the SQL query and store the results in a DataFrame
df = execute_sql_query(sql_query)

# Count the frequency of each shipping method
shipping_counts = df['ShipVia'].value_counts().reset_index()
shipping_counts.columns = ['ShippingMethod', 'Frequency']

# Determine the most frequently used shipping method
most_frequent_method = shipping_counts.loc[shipping_counts['Frequency'].idxmax()]

# Create a pie chart for the distribution of shipping methods
fig = px.pie(shipping_counts, names='ShippingMethod', values='Frequency', title='Distribution of Shipping Methods')

# Show the results to the user
distribution_info = pd.DataFrame([most_frequent_method]).set_index('ShippingMethod')
show_to_user(distribution_info)
show_to_user(fig)","The provided implementation correctly counts the frequency of each shipping method, identifies the most frequently used shipping method, and creates a pie chart displaying the distribution of shipping methods. It also meets all Python environment constraints specified and effectively displays the results to the user using the show_to_user function for both the data and the visualization.","import pandas as pd
import plotly.express as px

# SQL query to get the shipping method frequency
sql_query = 'SELECT ShipVia, COUNT(OrderID) AS NumberOfOrders FROM orders GROUP BY ShipVia ORDER BY NumberOfOrders DESC;'

# Execute the SQL query
frequency_df = execute_sql_query(sql_query)

# Display the most frequently used shipping method
most_frequent_shipping_method = frequency_df.iloc[0]
show_to_user(pd.DataFrame([most_frequent_shipping_method]))

# Create a pie chart to show the distribution of shipping methods
fig = px.pie(frequency_df, names='ShipVia', values='NumberOfOrders', title='Distribution of Shipping Methods')

# Show the pie chart to the user
show_to_user(fig)",The input code correctly executes the SQL query to determine the frequency of each shipping method and retrieves the most frequently used shipping method. It then creates a pie chart to show the distribution of shipping methods. This approach matches the intended functionality described in the business analytic request and follows the provided Python environment constraints.,both
Which products have not been ordered in the last three months?,"import pandas as pd
import plotly.express as px

# SQL query to get products not ordered in the last three months
sql_query = '''
SELECT ProductName 
FROM products 
WHERE ProductID NOT IN (
    SELECT DISTINCT ProductID 
    FROM [Order Details] 
    WHERE OrderID IN (
        SELECT OrderID 
        FROM orders 
        WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
    )
);'''

# Execute the SQL query
products_not_ordered = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_not_ordered)","
import pandas as pd
from datetime import datetime, timedelta

# Calculate the date 3 months ago from today
three_months_ago = datetime.now() - timedelta(days=90)
three_months_ago_str = three_months_ago.strftime('%Y-%m-%d')

# SQL query to find products that have not been ordered in the last three months
sql_query = f""""""
SELECT p.ProductID, p.ProductName 
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.OrderID IS NULL OR od.OrderID NOT IN (
    SELECT OrderID FROM [Order Details] od2 
    JOIN orders o ON od2.OrderID = o.OrderID 
    WHERE o.OrderDate >= '{three_months_ago_str}'
)
""""""

# Execute the SQL query to get the products not ordered in the last three months
data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(data)
","The input code correctly identifies products that have not been ordered in the last three months. It uses the appropriate SQL query to ensure that products not in recent orders are selected, and it adheres to the given constraints by using the execute_sql_query and show_to_user functions correctly.","import pandas as pd
from datetime import datetime, timedelta
import plotly.express as px

# SQL query to find products that have not been ordered in the last three months
sql_query = '''
SELECT p.ProductID, p.ProductName 
FROM products p 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.ProductID IS NULL OR od.OrderDate < DATE_SUB(CURDATE(), INTERVAL 3 MONTH);
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Check for any NaN values in the ProductID, ProductName columns and drop those rows if any
if df['ProductID'].isnull().any() or df['ProductName'].isnull().any():
    df = df.dropna(subset=['ProductID', 'ProductName'])

# Display the DataFrame to the user
show_to_user(df)
","The input code to evaluate is not correct because it doesn't properly check for orders from the last three months. Specifically, the condition `od.OrderDate < DATE_SUB(CURDATE(), INTERVAL 3 MONTH)` should be replaced with a subquery similar to the reference implementation to ensure it properly fetches products not ordered in the last three months.",Base
What is the average Inventory Turnover Ratio for each month? Use a line graph to show the monthly average Inventory Turnover Ratio.,"import pandas as pd
import plotly.express as px

# Define the SQL query
query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
'''

# Execute the SQL query to get the data
data = execute_sql_query(query)

# Check if the data is retrieved correctly and not empty
def validate_data(data):
    if data.empty or not {'Month', 'InventoryTurnoverRatio'}.issubset(data.columns):
        raise ValueError('Invalid data retrieved from SQL query')

validate_data(data)

# Generate the line graph using plotly
fig = px.line(data, x='Month', y='InventoryTurnoverRatio', 
              title='Monthly Average Inventory Turnover Ratio', 
              labels={'Month': 'Month', 'InventoryTurnoverRatio': 'Average Inventory Turnover Ratio'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate the Inventory Turnover Ratio grouped by month
sql_query = '''
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio
FROM
    products
JOIN
    [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY
    Month
ORDER BY
    Month
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Visualize the average Inventory Turnover Ratio using a line graph
fig = px.line(result_df, x='Month', y='InventoryTurnoverRatio', title='Average Inventory Turnover Ratio by Month')
show_to_user(fig)","The given Python code does not appropriately join the orders table which is required to access the OrderDate field in the SQL query. Additionally, there is no validation to check if the data has been correctly retrieved from the SQL query.","import pandas as pd
import plotly.express as px

# Construct the SQL query
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID  
GROUP BY month;
'''

# Execute the SQL query
inventory_turnover_df = execute_sql_query(sql_query)

# Ensure 'month' is treated as a string type for proper sorting
inventory_turnover_df['month'] = inventory_turnover_df['month'].astype(str)

# Re-sort the dataframe by 'month' to ensure correct chronological order
inventory_turnover_df.sort_values('month', inplace=True)

# Create the line graph using plotly
fig = px.line(inventory_turnover_df, x='month', y='InventoryTurnoverRatio', title='Monthly Average Inventory Turnover Ratio', labels={'month': 'Month', 'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

# Display the graph to the user
show_to_user(fig)","The provided code performs the necessary steps to achieve the business analytic request. It queries the required data from the database, processes it with appropriate data type conversions, and visualizes the monthly average Inventory Turnover Ratio using a line graph with plotly. The key actions of querying, validating, sorting, and plotting matched the reference implementation correctly.",Finetuned
List the top 5 employees with the highest salaries.,"import pandas as pd

# Define the SQL query to fetch the required data
sql_query = 'SELECT EmployeeID, FirstName, LastName, Salary FROM employees ORDER BY Salary DESC LIMIT 5;'

# Execute the SQL query
employee_df = execute_sql_query(sql_query)

# Display the retrieved data to the user
show_to_user(employee_df)","import pandas as pd

# SQL query to retrieve the top 5 employees with the highest salaries
sql_query = """"""
SELECT EmployeeID, FirstName, LastName, Salary 
FROM employees 
ORDER BY Salary DESC 
LIMIT 5
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly follows the business analytic request to list the top 5 employees with the highest salaries. It executes the appropriate SQL query to retrieve the needed data and uses the provided utility functions `execute_sql_query` and `show_to_user` to retrieve and display the data, similar to the reference implementation.","import pandas as pd
import plotly.express as px

# Function to execute the SQL query and retrieve data
def get_top_employees_by_salary():
    # SQL query to get top 5 employees by salary
    sql_query = '''
    SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary
    FROM employees e
    ORDER BY e.Salary DESC
    LIMIT 5;
    '''
    
    # Execute the SQL query
    try:
        df_employees = execute_sql_query(sql_query)
    except Exception as e:
        show_to_user(f'Error executing query: {e}')
        return
    
    # Display the DataFrame to the user
    show_to_user(df_employees)

    # Optional: Visualization using plotly
    fig = px.bar(df_employees, x='EmployeeID', y='Salary', 
                 title='Top 5 Employees by Salary',
                 labels={'EmployeeID': 'Employee ID', 'Salary': 'Salary'},
                 text='Salary')
    fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
    fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
    
    # Show plotly figure to the user
    show_to_user(fig)

# Call the function to execute
get_top_employees_by_salary()","The input code correctly executes an SQL query to fetch the top 5 employees by salary, handles potential exceptions, and shows the result to the user. It also optionally provides a visualization using Plotly, which is beyond the given requirements but still valid as it does not violate any constraints or requirements.",both
What's the average discount applied to products?,"import pandas as pd
import plotly.express as px

# SQL Query to get the average discount
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];'

# Execute the query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user using the provided utility function
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the average discount applied to products
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
""""""

# Execute the SQL query and retrieve the data into a pandas dataframe
average_discount_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_discount_df)","The input Python code correctly follows the Python environment constraints and achieves the same result as the reference implementation. It formulates the correct SQL query to calculate the average discount, uses the 'execute_sql_query' function to run the query, and finally uses the 'show_to_user' function to display the result.","import pandas as pd
import plotly.express as px

# SQL query to retrieve average discount
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];'

# Execute the query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Extract the average discount value from the dataframe
average_discount = df.iloc[0]['AverageDiscount']

# Display the result to the user
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))",The input Python code correctly retrieves the average discount from the database using the 'execute_sql_query' function and appropriately processes the result to display to the user using the 'show_to_user' function. It meets the business request and matches the reference implementation's functionality.,both
Calculate the total sales revenue generated each month and visualize it to show trends over time.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales revenue generated each month
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY Month;
""""""

# Execute the SQL query and retrieve the data as a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Ensure the Month column is treated as datetime
sales_data['Month'] = pd.to_datetime(sales_data['Month'], format='%Y-%m')

# Sort the dataframe by Month to ensure the line plot will be correctly ordered
sales_data = sales_data.sort_values(by='Month')

# Visualize the data to show trends over time
fig = px.line(sales_data, x='Month', y='MonthlySales', title='Monthly Sales Revenue Trend', labels={'Month': 'Month', 'MonthlySales': 'Sales Revenue'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate Total Sales Revenue generated each month
sql_query = '''
SELECT  
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,  
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales  
FROM orders  
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID  
GROUP BY Month  
ORDER BY Month;  
'''  

# Execute the SQL query  
monthly_sales_df = execute_sql_query(sql_query)  

# Visualize the total sales revenue by month  
fig = px.line(monthly_sales_df, x='Month', y='TotalSales', title='Monthly Sales Revenue Trends',  
              labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})  
show_to_user(fig) 
","The input Python code correctly follows the specified business analytic request by calculating the total sales revenue generated each month and visualizing it. It also adheres to the given Python environment constraints by using the provided utility functions 'execute_sql_query' and 'show_to_user'. The main steps in the code, including the SQL query, data conversion, sorting, and visualization, are consistent with the reference implementation and fulfill the business request requirements.","To accomplish the task of calculating monthly total sales revenue and visualizing the trends over time, we can follow these steps:

1. Write the SQL query to extract the monthly sales data.
2. Execute the SQL query to retrieve the data.
3. Use a visualization library (like Matplotlib or Seaborn) to plot the data.

Hereâ€™s how you can implement this in Python:

```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the total sales revenue each month
sql_query = '''
SELECT DATE_FORMAT(SO.OrderDate, '%Y-%m') AS Month, 
       SUM(SOD.UnitPrice * SOD.Quantity * (1 - SOD.Discount)) AS TotalSales 
FROM orders SO 
JOIN [Order Details] SOD ON SO.OrderID = SOD.OrderID 
WHERE SO.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY Month 
ORDER BY Month
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Convert the 'Month' column to datetime type
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Sort the dataframe by 'Month' to ensure proper chronological order
sales_data = sales_data.sort_values('Month')

# Visualize the sales trends over the specified period
fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales Revenue by Month', labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})

# Show the plot to the user
show_to_user(fig)
```

### Explanation of the Code:
- The SQL query retrieves the month and the respective total sales for that month from the database. It sums the product of unit price and quantity, adjusted for any discounts.
- The `execute_sql_query` function runs the SQL query and yields a DataFrame (`sales_data`) containing the results.
- The 'Month' column is converted to a datetime type to enable proper chronological sorting.
- We sort the DataFrame by 'Month' to ensure the line plot reflects the true sequence of months.
- `plotly.express` is used to create a line plot (`fig`), displaying the trends in total sales revenue over the months.
- Finally, `show_to_user` is called to display the plot.

### Assumptions:
- The `execute_sql_query` and `show_to_user` functions are predefined and work as expected.
- The input SQL query format is assumed to work with the SQL dialect of the `MDDX` database, particularly with regard to date formatting. Adjustments may be necessary based on the actual SQL dialect.","The input Python code correctly implements the specified business analytic request. It follows the Python environment constraints by using execute_sql_query to fetch data and show_to_user to display the plot. The SQL query, data manipulation, and visualization steps align with the reference implementation to calculate monthly total sales revenue and visualize the trends over time.",both
What percentage of orders were shipped after the required date each month? Visualize the percentage to identify any patterns or trends.,"import plotly.express as px

# SQL query to get the percentage of orders shipped after the required date each month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) / COUNT(OrderID) AS LateDeliveryRate 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# Ensure the 'Month' column is sorted
orders_df['Month'] = pd.to_datetime(orders_df['Month'], format='%Y-%m')
orders_df = orders_df.sort_values('Month')
orders_df['Month'] = orders_df['Month'].dt.strftime('%Y-%m')

# Create a line plot to visualize the percentage of late deliveries over time
fig = px.line(orders_df, x='Month', y='LateDeliveryRate', title='Percentage of Orders Shipped After Required Date Each Month')

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the order data needed for analysis
sql_query = '''
SELECT DATE_TRUNC('month', OrderDate) AS Month,
       COUNT(OrderID) AS TotalOrders,
       COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) AS LateShipments
FROM orders
GROUP BY Month
ORDER BY Month;
'''

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Calculate the percentage of late shipments
orders_df['PercentageLate'] = (orders_df['LateShipments'] / orders_df['TotalOrders']) * 100

# Create a line plot to visualize the percentage of late shipments over time
fig = px.line(orders_df, x='Month', y='PercentageLate', title='Percentage of Late Shipments Over Time', labels={'PercentageLate': 'Percentage of Late Shipments (%)'} )

# Show the visualization to the user
show_to_user(fig)",The input Python code correctly calculates the percentage of late shipments for each month and visualizes the trend using a line plot. It adheres to the Python environment constraints by using the provided utility functions execute_sql_query and show_to_user. The calculation of the late shipment percentage is accurate and matches the business analytic request.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       (SUM(CASE WHEN orders.ShippedDate > orders.RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(orders.OrderID) * 100) AS OnTimeDeliveryRate
FROM orders
GROUP BY month;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Sort the DataFrame by month for better visualization
orders_df.sort_values('month', inplace=True)

# Generate a line plot for the OnTimeDeliveryRate
fig = px.line(orders_df, x='month', y='OnTimeDeliveryRate', title='On-Time Delivery Rate Over Months', labels={'month': 'Month', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'})

# Show the plot
show_to_user(fig)","The executed SQL query in the input code is calculating OnTimeDeliveryRate instead of LateDeliveryRate, reversing the intended measurement. The provided SQL should calculate the percentage of orders shipped after the required date each month (LateDeliveryRate) similarly to the reference implementation.",Base
Which shipping method was used most frequently? Visualize the frequency to illustrate the distribution.,"import plotly.express as px
import pandas as pd

# SQL Query to fetch shipping method usage counts
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount 
FROM orders 
GROUP BY ShipVia 
ORDER BY UsageCount DESC
""""""

# Execute SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Generate the bar plot using plotly
fig = px.bar(df, x='ShipVia', y='UsageCount', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'UsageCount': 'Usage Count'})

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the shipping method frequency
sql_query = '''
SELECT ShipVia, COUNT(*) as Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
'''

# Execute the query and load the data into a DataFrame
shipping_data = execute_sql_query(sql_query)

# Visualize the frequency of shipping methods
fig = px.bar(shipping_data, x='ShipVia', y='Frequency', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'Frequency': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly retrieves the shipping method frequency using the provided SQL query, generates a bar plot using Plotly, and displays it to the user using the necessary utility functions.","import plotly.express as px
import pandas as pd

# SQL query to find the frequency of each shipping method
sql_query = 'SELECT ShipVia, COUNT(OrderID) AS UseCount FROM orders GROUP BY ShipVia;'

# Execute the SQL query and retrieve the data
ship_usage_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty before plotting
if not ship_usage_df.empty:
    # Visualize the frequency of each shipping method
    fig = px.bar(ship_usage_df, x='ShipVia', y='UseCount', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'UseCount': 'Usage Count'})
    
    # Display the plot
    show_to_user(fig)
else:
    print('No data available for visualization.')","The provided implementation correctly executes an SQL query to fetch the frequency of each shipping method, checks for a non-empty dataframe, and uses Plotly to visualize the frequency distribution. The key components: querying the database, checking the dataframe, creating a Plotly bar chart, and displaying the chart are all correctly implemented according to the specified business analytic request and Python environment constraints.",both
What is the customer retention rate from January 2022 to January 2023? Visualize the retention rate over time.,"import pandas as pd
import plotly.express as px

def calculate_customer_retention():
    # SQL query to get the number of unique customers before January 2022
    sql_query_old_customers = '''
    SELECT CustomerID, MIN(OrderDate) AS FirstOrderDate 
    FROM orders 
    GROUP BY CustomerID
    HAVING MIN(OrderDate) < '2022-01-01'
    '''
    old_customers_df = execute_sql_query(sql_query_old_customers)

    # SQL query to get the number of unique customers from January 2022 to January 2023
    sql_query_new_orders = '''
    SELECT CustomerID, MIN(OrderDate) AS FirstOrderDate 
    FROM orders 
    GROUP BY CustomerID
    ''
    new_orders_df = execute_sql_query(sql_query_new_orders)

    # Filter new customers who have at least one order after '2022-01-01' and before '2023-01-01'
    new_orders_df = new_orders_df[new_orders_df['FirstOrderDate'] >= '2022-01-01']
    new_orders_df = new_orders_df[new_orders_df['FirstOrderDate'] <= '2023-01-01']

    # Find old customers who have placed orders during the new period
    retained_customers_df = pd.merge(new_orders_df, old_customers_df, on='CustomerID', how='inner')

    # Calculate customer retention rate
    if len(old_customers_df) > 0:
        retention_rate = len(retained_customers_df) / len(old_customers_df)
    else:
        retention_rate = 0

    # Create a DataFrame for visualization
    retention_data = {
        'Date': ['2023-01-01'],
        'Retention Rate': [retention_rate]
    }
    retention_df = pd.DataFrame(retention_data)

    # Visualize the retention rate
    fig = px.line(retention_df, x='Date', y='Retention Rate', title='Customer Retention Rate from January 2022 to January 2023')
    show_to_user(fig)

# Calculate and show customer retention rate
calculate_customer_retention()","import pandas as pd
import plotly.express as px

# SQL query to calculate the customer retention rate from January 2022 to January 2023
def get_customer_retention_rate():
    sql_query = '''
    WITH CustomersBefore AS (
        SELECT COUNT(DISTINCT CustomerID) AS total_customers_before
        FROM orders
        WHERE OrderDate < '2022-01-01'
    ),
    ReturningCustomers AS (
        SELECT COUNT(DISTINCT CustomerID) AS returning_customers
        FROM orders
        WHERE OrderDate BETWEEN '2022-01-01' AND '2023-01-31'
    )
    SELECT    
        (SELECT returning_customers FROM ReturningCustomers) * 1.0 /
        (SELECT total_customers_before FROM CustomersBefore) AS retention_rate
    '''
    return execute_sql_query(sql_query)

# Retrieve the retention rate data
retention_rate_data = get_customer_retention_rate()

# Visualizing the retention rate over time by creating a timeline
def visualize_retention_rate():
    retention_rate = retention_rate_data['retention_rate'].values[0]  # Extracting the retention rate
    months = pd.date_range(start='2022-01-01', end='2023-01-31', freq='M').strftime('%Y-%m').tolist()
    retention_rates = [None] * len(months)  # Placeholder for all months
    retention_rates[-1] = retention_rate  # Assign the rate at the last period

    # Create a DataFrame for plotting
    retention_df = pd.DataFrame({'Month': months, 'Retention Rate': retention_rates})
    fig = px.line(retention_df, x='Month', y='Retention Rate', title='Customer Retention Rate from January 2022 to January 2023')
    show_to_user(fig)

# Execute the visualization function
visualize_retention_rate()","The input code implementation does not correctly calculate the retention rate over time. It only calculates the retention rate once for the entire period from January 2022 to January 2023. Additionally, the visualization creates a timeline with only a single retention rate value at the end, instead of visualizing the retention rate over different time periods as requested.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the number of distinct customers per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, COUNT(DISTINCT CustomerID) AS CustomerCount 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2023-01-31' 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the query and retrieve the data
monthly_customer_data = execute_sql_query(sql_query)

# Convert the 'Month' column to datetime for better plotting
monthly_customer_data['Month'] = pd.to_datetime(monthly_customer_data['Month'])

# Calculate the retention rate
# Retention rate = (Number of customers in January 2023) / (Number of customers who ordered in January 2022)
jan_2022_customers = monthly_customer_data[monthly_customer_data['Month'] == '2022-01']['CustomerCount'].iloc[0]
jan_2023_customers = monthly_customer_data[monthly_customer_data['Month'] == '2023-01']['CustomerCount'].iloc[0]
retention_rate = jan_2023_customers / jan_2022_customers * 100

# Print out the retention rate
print(f'Customer Retention Rate (Jan 2022 - Jan 2023): {retention_rate:.2f}%')

# Visualize the customer retention rate over time
fig = px.line(monthly_customer_data, x='Month', y='CustomerCount', title='Customer Retention Rate Over Time')
fig.update_xaxes(type='category')  # Keep the x-axis as categorical to avoid unwanted auto-scaling

# Show the plot to the user
show_to_user(fig)
","The input code calculates the customer count for each month and the retention rate between January 2022 to January 2023 as the ratio between the number of customers in January 2023 and January 2022. However, it does not follow the correct logic to calculate the retention rate which involves identifying customers who continued to be customers from one period to another. The reference implementation correctly identifies old customers and checks if they have placed new orders in the specified period to calculate retention rate.",None
What is the average order value for the year 2021?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AverageOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(orders.OrderDate) = 2021;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Process the result to get the average order value
average_order_value = result_df['AverageOrderValue'].iloc[0] if not result_df.empty and 'AverageOrderValue' in result_df else None

# Display the result to the user
result_to_display = pd.DataFrame({'Year': [2021], 'Average Order Value': [average_order_value]})
show_to_user(result_to_display)","import pandas as pd

# Define the SQL query to calculate the average order value for the year 2021
sql_query = """"""
SELECT
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM
    orders o
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
WHERE
    YEAR(o.OrderDate) = 2021
""""""

# Execute the SQL query and retrieve the data
average_order_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_order_value_df)","The input code does not process the result to get the average order value before displaying it to the user. It directly shows the entire dataframe returned by the SQL query, whereas the reference code extracts the specific value and formats it in a user-friendly manner.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = 2021;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average order value from the result
average_order_value = result_df['AverageOrderValue'].iloc[0]

# Display the result
show_to_user(pd.DataFrame({'AverageOrderValue': [average_order_value]}))
",The input code does not fully follow the Python environment constraint and may lead to potential errors. Specifically: 1. The input code does not check if 'AverageOrderValue' exists and if 'result_df' is not empty before accessing it. 2. The final displayed result in the input code has a different format compared to the reference implementation.,None
Identify the top 3 products with the most number of orders and visualize their order counts.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) AS NumberOfOrders 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY NumberOfOrders DESC 
LIMIT 3;
'''

# Execute the query to get the data
product_order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 products with the most orders
fig = px.bar(product_order_data, x='ProductName', y='NumberOfOrders', 
             title='Top 3 Products with the Most Number of Orders', 
             labels={'ProductName': 'Product Name', 'NumberOfOrders': 'Number of Orders'})

# Display the visualization
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve product order counts
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS OrderCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY OrderCount DESC
LIMIT 3;
'''  

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Visualize the order counts
fig = px.bar(top_products_df, x='ProductName', y='OrderCount', title='Top 3 Products by Order Count',
             labels={'ProductName': 'Product Name', 'OrderCount': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)","The input code calculates the 'OrderCount' using the SUM of quantities in orders, which may differ from counting unique OrderIDs as in the reference implementation. The business request specifically asked for the number of orders, not the quantity of items ordered.","import pandas as pd
import plotly.express as px

# SQL query to get the top 3 products with the most number of orders
sql_query = """"""
SELECT ProductID, COUNT(OrderID) AS OrderCount
FROM [Order Details]
GROUP BY ProductID
ORDER BY OrderCount DESC
LIMIT 3;
""""""

# Execute the query to retrieve the data
df = execute_sql_query(sql_query)

# Visualize the order counts of the top 3 products
fig = px.bar(df, x='ProductID', y='OrderCount', title='Top 3 Products with Most Orders', labels={'ProductID': 'Product ID', 'OrderCount': 'Order Count'})

# Display the visualization to the user
show_to_user(fig)","While the input code correctly identifies the top 3 products with the most orders and visualizes their order counts, it does not fully align with the business analytic request and the reference implementation. The key issue is that the input code only selects ProductID and not ProductName, which is necessary for a meaningful visualization. Additionally, the SQL grouping and ordering are accurately performed, but the resultant visualization would be more informative with product names rather than product IDs.",None
What are the average monthly sales generated by each region? Use visualization to compare the sales across regions.,"import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = '''
SELECT territories.RegionID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT DATE_TRUNC('month', orders.OrderDate)) AS avg_monthly_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
GROUP BY territories.RegionID
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if dataframe is empty
if df.empty:
    raise ValueError('The query returned an empty dataframe. Please check the SQL query and the database.')

# Create a bar chart to visualize the average monthly sales by region
fig = px.bar(df, x='RegionID', y='avg_monthly_sales', title='Average Monthly Sales by Region', labels={'RegionID': 'Region ID', 'avg_monthly_sales': 'Average Monthly Sales'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total monthly sales by region
sql_query = '''
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    orders.ShipRegion AS region,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    month, region
ORDER BY 
    month, region
'''

# Execute the SQL query
monthly_sales_by_region = execute_sql_query(sql_query)

# Calculate average monthly sales by region
average_sales = monthly_sales_by_region.groupby('region').agg({'total_sales': 'mean'}).reset_index()

# Create a line plot for visualization
fig = px.line(average_sales, x='region', y='total_sales', title='Average Monthly Sales by Region', labels={'total_sales': 'Average Sales', 'region': 'Region'})

# Show the result to the user
show_to_user(fig)","The input code does not produce a bar chart as required by the business analytic request, instead it produces a line chart. Additionally, the SQL query groups the data by month and region, while the request specifically asks for average monthly sales by region. This means the input code does not correctly aggregate the data by region alone before calculating the average monthly sales.","
import pandas as pd
import plotly.express as px

# SQL query to get average monthly sales by region
sql_query = '''
SELECT Region, 
    AVG(Sales) AS AverageMonthlySales 
FROM 
(SELECT region, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Sales, 
    YEAR(orders.OrderDate) AS Year, 
    MONTH(orders.OrderDate) AS Month 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY region, YEAR(orders.OrderDate), MONTH(orders.OrderDate)
) AS MonthlySales
GROUP BY Region;
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Visualization using plotly
fig = px.bar(sales_data, x='Region', y='AverageMonthlySales', 
             title='Average Monthly Sales by Region',
             labels={'Region': 'Region', 'AverageMonthlySales': 'Average Monthly Sales'})

# Show the plot to the user
show_to_user(fig)
","The input Python code correctly follows the business analytic request to calculate the average monthly sales by region and visualize it. It uses a valid SQL query to aggregate sales per month per region, computes monthly averages, and then visualizes the data using a Plotly bar chart. Although there are minor differences from the reference implementation, such as the additional joins and customer table, these differences do not affect the correctness of the result.",Finetuned
Find the order with the highest discount applied.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT OrderID, Discount FROM [Order Details] ORDER BY Discount DESC LIMIT 1;'

# Execute the SQL query to retrieve the data
order_data = execute_sql_query(sql_query)

# Display the data analysis result
show_to_user(order_data)","import pandas as pd

# SQL query to find the order with the highest discount applied
sql_query = '''
SELECT od.OrderID, SUM(od.Discount) as TotalDiscount
FROM [Order Details] od
GROUP BY od.OrderID
ORDER BY TotalDiscount DESC
LIMIT 1;
'''

# Execute the SQL query to get the order with the highest discount
highest_discount_order = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(highest_discount_order)","The input Python code correctly executes an SQL query to find the order with the highest discount. It uses GROUP BY and SUM to aggregate the discounts for each order, orders the results by the total discount in descending order, and limits the result to a single entry. The code then displays the result using the provided utility function, adhering to the business request and meeting the environment constraints.","import pandas as pd

# Function to execute SQL query
sql_query = 'SELECT OrderID, MAX(Discount) AS HighestDiscount FROM [Order Details] GROUP BY OrderID ORDER BY HighestDiscount DESC LIMIT 1;'

# Execute SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user using the provided utility function
show_to_user(result_df)
","The input Python code restructures the SQL query to GROUP BY OrderID and calculates the maximum discount for each order, then orders them by the highest discount. However, the original request and reference implementation simply needed the order with the highest single discount, not grouped by different orders. The reference implementation directly fetches the order with the highest discount. Thus, the input code is more complex than necessary and does not match the reference example.",Base
Calculate the monthly total sales revenue over the last year and visualize it to show trends and patterns.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT MONTH(o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY MONTH(o.OrderDate) 
ORDER BY Month;
'''

# Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Convert Month Number to Month Name
sales_data['Month'] = sales_data['Month'].apply(lambda x: pd.to_datetime(f'2023-{x}-01').strftime('%B'))

# Plot the data using plotly
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Total Sales Revenue Over the Last Year', labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate the total sales revenue over the last year
sql_query = '''
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
GROUP BY 
    Month
ORDER BY 
    Month;
'''

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Visualize the monthly total sales revenue
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Total Sales Revenue Over the Last Year', labels={'TotalSales': 'Total Sales', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly calculates and visualizes the monthly total sales revenue over the last year. It meets the business analytic request by generating a plotly line chart displaying the total sales revenue for each month over the past year. It retrieves data using the specified SQL query, processes it correctly, and the visualization is created and displayed as required.","import pandas as pd
import plotly.express as px

# SQL query to fetch monthly sales data over the last year
sql_query = '''
SELECT DATE_FORMAT(Orders.OrderDate, '%Y-%m') AS Month, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS MonthlySales
FROM [Order Details]
JOIN Orders ON [Order Details].OrderID = Orders.OrderID
WHERE Orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH)
GROUP BY DATE_FORMAT(Orders.OrderDate, '%Y-%m')
ORDER BY Month;
'''

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Visualization using plotly
fig = px.line(monthly_sales_df, x='Month', y='MonthlySales', title='Monthly Total Sales Revenue Over the Last Year', labels={'Month': 'Month', 'MonthlySales': 'Total Sales Revenue'})

# Show the plot to the user
show_to_user(fig)",The provided input code correctly follows the business analytic request and Python environment constraints. It retrieves the monthly total sales revenue over the last year using an appropriate SQL query and then visualizes it with Plotly. The approach is slightly different but achieves the same outcome as the reference implementation.,both
How many units are currently in stock for each product?,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = 'SELECT ProductName, UnitsInStock FROM products;'

# Execute the query to get the data
products_df = execute_sql_query(sql_query)

# Display the data to user
show_to_user(products_df)","import pandas as pd

# SQL query to get the number of units in stock for each product
sql_query = """"""
SELECT ProductName, UnitsInStock 
FROM products 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
WHERE Discontinued = 0
""""""  

# Execute the SQL query using the provided function
stock_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(stock_data)","The provided code adds unnecessary complexity by joining the products and suppliers tables and filtering discontinued products. This is not required according to the business analytic request, which simply asks for the number of units in stock for each product. Additionally, the reference implementation directly retrieves the needed data without additional conditions or joins.","import pandas as pd
import plotly.express as px

def query_and_visualize_stock():
    # Define the SQL query to fetch product names and their stock levels
    sql_query = 'SELECT ProductID, ProductName, UnitsInStock FROM products;'

    # Execute the SQL query using the provided utility function
    products_df = execute_sql_query(sql_query)

    # Display the dataframe to the user
    show_to_user(products_df)

    # Plot the data using plotly
    fig = px.bar(products_df, x='ProductName', y='UnitsInStock', title='Current Stock Levels for Each Product', labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units In Stock'})

    # Show the plot to the user
    show_to_user(fig)

# Execute the function to perform the task
query_and_visualize_stock()","The input code is not correct because it includes additional columns (ProductID) that were not requested. Additionally, it attempts to create and display a plot, which was not part of the specified business analytic request.",None
List employees who have birthdays in the current month.,"import pandas as pd
from datetime import datetime

# Utility functions
# In the actual environment, these functions will be already provided.
# Here we define dummy versions to avoid execution errors during code generation.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function definition
    return pd.DataFrame()

def show_to_user(data):
    # Dummy function definition
    print(data)

# Get the current month
current_month = datetime.now().month

# SQL query to get employees with birthdays in the current month
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
WHERE MONTH(e.BirthDate) = {current_month};
""""""

# Execute the query and get the result as a pandas DataFrame
employees_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_df)","from datetime import datetime

# Get the current month
current_month = datetime.now().month

# SQL query to retrieve employees with birthdays in the current month
sql_query = """"""
SELECT FirstName, LastName, BirthDate
FROM employees
WHERE MONTH(BirthDate) = {};
"""""".format(current_month)

# Execute the SQL query
employees_with_birthdays = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(employees_with_birthdays)","The input Python code correctly lists employees who have birthdays in the current month using the provided utility functions. It constructs an appropriate SQL query, executes it, obtains the result as a pandas DataFrame, and displays the DataFrame using the provided 'show_to_user' function. The code adheres to the environment constraints and achieves the desired output.","import pandas as pd
import datetime

# SQL query to fetch employee names with birthdays in the current month
sql_query = ""SELECT FirstName, LastName FROM employees WHERE MONTH(BirthDate) = MONTH(CURRENT_DATE);""

# Execute the SQL query
employees_df = execute_sql_query(sql_query)

# Optionally format the names
if not employees_df.empty:
    employees_df['FullName'] = employees_df['FirstName'] + ' ' + employees_df['LastName']
    result_df = employees_df[['FullName']]
else:
    result_df = employees_df  # Retain the structure, even if empty

# Display the result to the user
show_to_user(result_df)","The provided code uses 'datetime' instead of 'from datetime import datetime'. Additionally, the SQL query in the input code uses 'CURRENT_DATE' instead of calculating the current month using Python's datetime module. Finally, the input code changes the structure of the result dataframe by adding a 'FullName' column, which is not required by the reference implementation.",Base
What is the total sales revenue for each product? Visualize the revenue to compare product performances.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT P.ProductID, SUM(OD.Quantity * OD.UnitPrice) AS TotalSalesRevenue 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY P.ProductID;'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Generate a bar chart to visualize the total sales revenue per product
fig = px.bar(sales_data, x='ProductID', y='TotalSalesRevenue', title='Total Sales Revenue per Product', labels={'ProductID':'Product ID', 'TotalSalesRevenue':'Total Sales Revenue'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalRevenue DESC;
'''

# Execute the SQL query and retrieve the data
revenue_df = execute_sql_query(sql_query)

# Visualize the revenue to compare product performances
fig = px.bar(
    revenue_df,
    x='ProductName',
    y='TotalRevenue',
    title='Total Sales Revenue for Each Product',
    labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'},
    text='TotalRevenue'
)

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly calculates the total sales revenue for each product, taking into account discounts, and visualizes the result using a bar chart. It accurately executes the SQL query to retrieve the necessary data and displays it using Plotly as required. The result should closely match the output produced by the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT products.ProductID, SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSalesRevenue FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID GROUP BY products.ProductID;""

# Execute the query
sales_data = execute_sql_query(sql_query)

# Visualization using plotly
fig = px.bar(sales_data, x='ProductID', y='TotalSalesRevenue', title='Total Sales Revenue per Product', labels={'ProductID': 'Product ID', 'TotalSalesRevenue': 'Total Sales Revenue ($)'})

# Display the result
show_to_user(fig)","The input Python code correctly addresses the business analytic request by querying the total sales revenue for each product and visualizing the data using a bar chart. The code uses the utility functions 'execute_sql_query' to execute the SQL query and 'show_to_user' to display the plotly figure, adhering to the Python environment constraints.",both
Who is the highest paid employee and what is their total sales?,"import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query
sql_query = '''
SELECT e.EmployeeID, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY e.Salary DESC
LIMIT 1;
'''

# Step 2: Execute the SQL query using execute_sql_query function
result_df = execute_sql_query(sql_query)

# Step 3: Add readability by renaming the columns
result_df.columns = ['EmployeeID', 'Salary', 'TotalSales']

# Step 4: Display the result using show_to_user function
show_to_user(result_df)
","import pandas as pd

# SQL query to retrieve the highest paid employee and their total sales
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Salary
ORDER BY e.Salary DESC
LIMIT 1;
'''

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code retrieves the highest paid employee and their total sales correctly. The query accurately selects and joins the necessary tables, groups by relevant columns including employee information, orders by salary in descending order and limits to the top result. It falls within the constraints provided, and uses the required utility functions to execute the query and display the result.","import pandas as pd
import plotly.express as px

# SQL Query to fetch highest paid employee and their total sales
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Salary 
ORDER BY e.Salary DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly follows the business analytic request by retrieving the highest paid employee and their total sales. It uses an SQL query to fetch the required data and executes this query via the execute_sql_query function. Finally, it displays the result using the show_to_user function. The minor difference in selecting additional columns (FirstName and LastName) is acceptable as it provides more detailed information without affecting the correctness of the output.",both
What is the average discount given for each supplier's products? Visualize the discounts to compare between suppliers.,"import plotly.express as px

# SQL query to get the average discount for each supplier's products
sql_query = '''
SELECT p.SupplierID, AVG(od.Discount) AS AvgDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discounts for each supplier
fig = px.bar(result_df, x='SupplierID', y='AvgDiscount',
             labels={'SupplierID': 'Supplier ID', 'AvgDiscount': 'Average Discount'},
             title='Average Discount Given for Each Supplier')

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get average discount by supplier
sql_query = '''
SELECT p.SupplierID, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
'''  

# Execute the SQL query and retrieve the data
average_discounts = execute_sql_query(sql_query)

# Visualizing the average discounts per supplier
fig = px.bar(average_discounts, x='SupplierID', y='AverageDiscount',
             title='Average Discount per Supplier',
             labels={'AverageDiscount': 'Average Discount', 'SupplierID': 'Supplier ID'},
             color='AverageDiscount',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly executes the SQL query to retrieve the average discount for each supplier's products and visualizes the results using a bar chart in Plotly. While the color and color_continuous_scale arguments differ from the reference implementation, they are valid enhancements and do not affect the correctness of the code. The output will still correctly visualize the discounts to compare between suppliers.","import pandas as pd
import plotly.express as px

# SQL query to get average discount for each supplier's products
sql_query = '''
SELECT suppliers.CompanyName, AVG([Order Details].Discount) AS AverageDiscount
FROM suppliers
INNER JOIN products ON suppliers.SupplierID = products.SupplierID
INNER JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY suppliers.CompanyName;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Correct the column names to match the result dataframe
result_df.columns = ['CompanyName', 'AverageDiscount']

# Create a bar chart using plotly
fig = px.bar(result_df, x='CompanyName', y='AverageDiscount', title='Average Discount Given for Each Supplier', labels={'CompanyName': 'Supplier', 'AverageDiscount': 'Average Discount'})

# Show the generated plot to the user
show_to_user(fig)","The 'Input Python Code To Evaluate' correctly retrieves the average discount for each supplier's products and visualizes it. The SQL query is accurate in joining the relevant tables and aggregating the data. The column names are adjusted appropriately, and the plotting using Plotly is performed correctly, meeting the specified criteria.",both
Calculate the total sales revenue generated in the last month.,"import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue generated in the last month
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd
from datetime import datetime, timedelta

# Calculate the first day of the last month and the last day of the last month
last_month_start = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1)
last_month_end = (datetime.now().replace(day=1) - timedelta(days=1))

# SQL query to calculate total sales revenue
sql_query = f""""""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '{last_month_start.strftime('%Y-%m-%d')}'
AND orders.OrderDate < '{last_month_end.strftime('%Y-%m-%d')}';
""""""

# Execute the query and get the result as a dataframe
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The evaluated Python code correctly calculates the total sales revenue generated in the last month. It establishes the date range for the last month correctly and constructs the SQL query accordingly. The query joins the orders and order details tables, calculates the revenue, and filters by the appropriate date range. The `execute_sql_query` function is used to run the query, and the result is displayed to the user using the `show_to_user` function. The logic and implementation match the requirements outlined in the business analytic request and the reference implementation, albeit with slight variations in date range handling, producing equivalent results.","import pandas as pd
from datetime import datetime, timedelta

# Step 1: Determine the date range for the last month
end_date = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1)
start_date = end_date - timedelta(days=30)

# Step 2: Write the SQL query
sql_query = f""""""
    SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
    FROM orders
    INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
    WHERE OrderDate >= '{start_date.strftime('%Y-%m-%d')}'
    AND OrderDate < '{end_date.strftime('%Y-%m-%d')}';""""""

# Step 3: Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Step 4: Display the result to the user
show_to_user(sales_data[['TotalSales']])
","The input code has an error in the date range calculation. The `start_date` should be the 1st of the previous month, and the `end_date` should be the 1st of the current month to ensure the entire last month is covered.",Base
What is the total sales per employee for each month? Use visualization to compare performance across months.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, strftime('%Y-%m', o.OrderDate) as OrderMonth, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, OrderMonth;
'''

# Execute the SQL query and retrieve the data into a DataFrame
df = execute_sql_query(sql_query)

# Convert 'OrderMonth' to datetime for better plotting
df['OrderMonth'] = pd.to_datetime(df['OrderMonth'], format='%Y-%m')

# Use plotly to create a line plot
fig = px.line(df, x='OrderMonth', y='TotalSales', color='EmployeeID', markers=True,
              title='Total Sales per Employee for Each Month',
              labels={'OrderMonth': 'Order Month', 'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales per employee for each month
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, OrderMonth
ORDER BY OrderMonth, TotalSales DESC;
'''

# Execute the SQL query and get the dataframe
sales_data = execute_sql_query(sql_query)

# Visualize the total sales per employee for each month
fig = px.line(sales_data, x='OrderMonth', y='TotalSales', color='EmployeeID', 
              title='Total Sales Per Employee by Month', 
              labels={'TotalSales': 'Total Sales', 'OrderMonth': 'Month'}, 
              hover_name='EmployeeID', 
              line_group='EmployeeID')

# Show the visualization to the user
show_to_user(fig)","The provided Python code correctly executes an SQL query to calculate total sales per employee for each month, and visualizes the results using plotly. The minor differences, such as inclusion of first and last names of employees and ordering the results by month and total sales, do not impact the correctness of the implementation in regards to the business analytic request.","Hereâ€™s how you can implement the business analysis and visualization based on the provided SQL query.

1. Execute the SQL Query to retrieve the data.
2. Process the resulting DataFrame to calculate the total sales per employee for each month.
3. Create a visualization to compare the performance across months.

Here's the complete Python code to achieve the above:

```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the provided SQL query to retrieve the data.
df = execute_sql_query(""""""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales, 
       DATE_FORMAT(o.OrderDate, '%Y-%m') AS SaleMonth 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, SaleMonth;
"""""")

# Step 2: We assume the SQL query gives us data in the required format
# Since the query already groups by SaleMonth, we directly assign df

# Step 3: Visualize the total sales per employee for each month
fig = px.bar(df, x='SaleMonth', y='TotalSales', color='EmployeeID', 
             title='Total Sales per Employee for Each Month', 
             labels={'TotalSales': 'Total Sales', 'SaleMonth': 'Month'})

# Show the visualization to the user
show_to_user(fig)
```

### Explanation:
- **SQL Query:** The SQL query aggregates sales data by employee and by sale month.
- **Data Retrieval and Processing:** The `execute_sql_query` function is used to execute the SQL query, which returns the data in pandas DataFrame format. No additional processing is needed since the SQL output is already grouped and aggregated as required.
- **Visualization:** The `plotly.express.bar` function creates a stacked bar chart to visualize total sales per employee for each month. 
- **Display:** The `show_to_user` function displays the final plot. 

### Notes:
- Ensure that the SQL query matches the database schema.
- The resulting `SaleMonth` should be in correct chronological order. Consider converting it to a datetime object if further analysis is needed.","The input code has a key issue: it's using DATE_FORMAT instead of strftime in the SQL query, which is incorrect given the Python environment context specified. Additionally, it's using a bar chart instead of a line chart for the visualization.",Base
How does the total number of units sold compare between discontinued and active products? Visualize the comparison for better understanding.,"import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT products.Discontinued, SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.Discontinued
'''

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Ensure the column types are correct
result_df['Discontinued'] = result_df['Discontinued'].astype(bool)
result_df['TotalUnitsSold'] = result_df['TotalUnitsSold'].astype(int)

# Visualize the comparison using Plotly
fig = px.bar(result_df, x='Discontinued', y='TotalUnitsSold', title='Total Units Sold: Discontinued vs Active Products', labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'}, barmode='group')

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch total units sold for discontinued and active products
sql_query = '''
SELECT 
    p.Discontinued,
    SUM(od.Quantity) AS TotalUnitsSold
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.Discontinued
'''

# Execute SQL query and get result as a dataframe
units_sold_df = execute_sql_query(sql_query)

# Map the Discontinued field to a more readable form
units_sold_df['ProductStatus'] = units_sold_df['Discontinued'].map({0: 'Active', 1: 'Discontinued'})

# Create a bar plot for visualization
fig = px.bar(units_sold_df, x='ProductStatus', y='TotalUnitsSold',
             title='Total Units Sold: Active vs Discontinued Products',
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductStatus': 'Product Status'},
             color='ProductStatus',
             color_discrete_map={'Active': 'green', 'Discontinued': 'red'})

# Show the figure to the user
show_to_user(fig)","The provided Python code implementation accurately fulfills the business analytic request. It fetches total units sold for discontinued and active products using a SQL query, correctly maps the 'Discontinued' field to a more readable form, and creates a bar plot using Plotly to visualize the data comparison. The result is then displayed to the user via the show_to_user function. While there are minor differences in the approach (such as mapping 'Discontinued' to 'ProductStatus'), these differences do not affect the correctness or integrity of the code.","import pandas as pd
import plotly.express as px

# SQL query to compare total units sold between discontinued and active products
product_analysis_sql = '''
SELECT 
    p.Discontinued, 
    SUM(od.Quantity) AS TotalUnitsSold 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    p.Discontinued;
'''

# Execute the SQL query
product_analysis_df = execute_sql_query(product_analysis_sql)

# Visualization of the comparison
fig = px.bar(product_analysis_df, x='Discontinued', y='TotalUnitsSold',
             title='Total Units Sold: Active vs Discontinued Products',
             labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'})

# Display the visualization
show_to_user(fig)",The input Python code correctly implements the specified business analytic request. It executes an SQL query to retrieve the necessary data and then visualizes the comparison of total units sold between discontinued and active products using Plotly. The code follows the Python environment constraints by using the provided utility functions execute_sql_query and show_to_user. The essential steps and logic match the reference implementation even though the variable names and some minor formatting aspects are different.,both
Count the total number of orders placed by each customer.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT CustomerID, COUNT(*) AS total_orders FROM orders GROUP BY CustomerID;'

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(orders_df)

# Optional: Visualize the result using a bar chart
fig = px.bar(orders_df, x='CustomerID', y='total_orders', title='Total Orders by Customer')
show_to_user(fig)","import pandas as pd

# SQL query to count the total number of orders placed by each customer
sql_query = '''
SELECT customers.CustomerID, COUNT(orders.OrderID) AS TotalOrders
FROM customers
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID
'''

# Execute the SQL query and retrieve the data
customer_orders = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(customer_orders)","The provided code correctly executes a SQL query to count the number of orders placed by each customer, groups by CustomerID, and then shows the results to the user. While it uses a LEFT JOIN instead of a direct selection from the 'orders' table, it still achieves the intended result. The core functionality is correct and meets the business analytic request.","import pandas as pd
import plotly.express as px

# SQL query to get the total number of orders placed by each customer
sql_query = 'SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID;'

# Execute the SQL query and get the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Display the DataFrame to the user
show_to_user(df)

# Optional: create a visualization of the order counts
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Total Number of Orders by Each Customer')
show_to_user(fig)","The input Python code correctly follows the business analytic request to count the total number of orders placed by each customer, and it roughly matches the output of the reference implementation. The SQL query, execution, and visualization steps are properly implemented with appropriate utility functions.",both
Identify the product categories with the lowest total sales revenue. Use visualization to highlight categories with low performance.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.CategoryID 
ORDER BY TotalRevenue ASC
LIMIT 5
'''

# Execute the SQL query to retrieve the data
categories_revenue_df = execute_sql_query(sql_query)

# Create a bar chart to highlight categories with low performance
fig = px.bar(categories_revenue_df, x='CategoryID', y='TotalRevenue', title='Categories with Lowest Total Sales Revenue', labels={'CategoryID':'Category ID', 'TotalRevenue':'Total Revenue'})

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL Query to get total sales revenue by product category
sql_query = '''
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM [Order Details] AS od
JOIN products AS p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
ORDER BY TotalSales ASC
'''

# Execute the query
category_sales = execute_sql_query(sql_query)

# Load category names for better visualization
category_names_query = '''
SELECT CategoryID, CategoryName FROM categories
'''  # Assuming there's a 'categories' table
category_names = execute_sql_query(category_names_query)

# Merge to get the category names with sales data
category_sales = category_sales.merge(category_names, on='CategoryID', how='left')

# Visualization using Plotly
fig = px.bar(category_sales, x='CategoryName', y='TotalSales',
             title='Product Categories with Lowest Total Sales Revenue',
             labels={'TotalSales': 'Total Sales Revenue', 'CategoryName': 'Product Category'},
             color='TotalSales',
             color_continuous_scale='reds')

# Show the visualization to the user
show_to_user(fig)",The provided Python code correctly follows the requirements of the business analytic request. It retrieves the total sales revenue for each product category and merges it with the category names for better visualization. It then uses Plotly to create a bar chart that highlights the low-performing categories. The code adheres to the Python environment constraints by using the execute_sql_query function to retrieve data and the show_to_user function to display the visualization.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
  p.CategoryID, 
  SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.CategoryID 
ORDER BY TotalRevenue ASC;
""""""

# Execute the SQL query to get the data
categories_sales = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(categories_sales, x='CategoryID', y='TotalRevenue', title='Product Categories with Lowest Total Sales Revenue', labels={'CategoryID':'Product Category', 'TotalRevenue':'Total Revenue ($)'})

# Given that we need to highlight low-performance categories, we can add a horizontal line at some threshold if needed
# e.g., adding a line for average total revenue (this step is optional)

# fig.add_shape(type='line', x0=-0.5, y0=average_total_revenue, x1=len(categories_sales)-0.5, y1=average_total_revenue, line_color='red', name='Average Total Revenue')

# Show the figure to the user
show_to_user(fig)","The provided code correctly follows the requirements and environment constraints, performs the necessary SQL query to retrieve the data, sorts by total revenue in ascending order, and visualizes the lowest performing categories using a plotly bar chart.",both
Find the product categories with the highest average unit price.,"import pandas as pd
import plotly.express as px

# The SQL query to retrieve the required data
sql_query = '''
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice 
FROM products 
GROUP BY CategoryID 
ORDER BY AverageUnitPrice DESC;'''

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(df)

# Ensure df is not empty before plotting to prevent errors
if not df.empty:
    # Optionally, create a plotly figure for visualization
    fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Product Categories with Highest Average Unit Price')

    # Display the plot to the user
    show_to_user(fig)","import pandas as pd

# SQL query to find the product categories with the highest average unit price
sql_query = '''
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
ORDER BY AverageUnitPrice DESC
'''

# Execute the SQL query and retrieve the results
result_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(result_df)","The input code is correct in retrieving and displaying the data, but it lacks an optional visualization step using Plotly, which was included in the reference implementation. Adding a Plotly visualization would make the input code match the reference implementation more closely.","import pandas as pd
import plotly.express as px

# SQL query to find product categories with the highest average unit price
sql_query = '''SELECT CategoryID, AVG(UnitPrice) as AverageUnitPrice FROM products GROUP BY CategoryID ORDER BY AverageUnitPrice DESC;'''

# Execute the SQL query
categories_avg_price_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(categories_avg_price_df)

# Visualization using plotly
fig = px.bar(categories_avg_price_df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Product Category', labels={'CategoryID': 'Product Category', 'AverageUnitPrice': 'Average Unit Price'})

# Show the plot to the user
show_to_user(fig)","The input code correctly follows the given business analytic request, which is to find the product categories with the highest average unit price. It uses the provided utility functions to execute an SQL query and display the results. Additionally, it ensures that the data is visualized using a Plotly bar plot, which aligns with the reference implementation. The only difference lies in some code styling and additional labeling in the Plotly visualization, which does not affect the correctness of the code.",Finetuned
How many orders included products with a discount of more than 10%?,"import pandas as pd

# SQL query to count orders with a discount of more than 10%
sql_query = '''
SELECT COUNT(*) as order_count
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0.1;
'''

# Execute the SQL query to get the desired data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to find the number of orders with products having a discount greater than 10%
sql_query = """"""
SELECT COUNT(DISTINCT o.OrderID) AS OrderCount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount > 0.1
""""""

# Execute the SQL query and store the result in a dataframe
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code correctly counts the number of distinct orders where the discount is greater than 10%, matching the business analytic request. The SQL query and the functions 'execute_sql_query' and 'show_to_user' are used correctly.","import pandas as pd
import plotly.express as px

# SQL query to get the number of orders with a discount greater than 10%
sql_query = 'SELECT COUNT(DISTINCT OrderID) AS OrdersWithHighDiscount FROM [Order Details] WHERE Discount > 0.1;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly identifies the number of distinct orders that included products with a discount greater than 10% by using a SQL query to count distinct OrderID where the discount is greater than 0.1. The SQL query is executed using the execute_sql_query function and the result is displayed using show_to_user, adhering to the provided constraints.",both
What is the performance ranking of products based on sales quantity?,"import pandas as pd
import plotly.express as px

# Define the SQL query to get the performance ranking of products based on sales quantity
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalQuantity DESC;
'''

# Execute the SQL query and get the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Visualize the result using plotly
fig = px.bar(result_df, x='ProductName', y='TotalQuantity', title='Performance Ranking of Products Based on Sales Quantity', labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity Sold'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd

# Query to get performance ranking of products based on sales quantity
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) as TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC;
'''  

# Execute the SQL query and retrieve the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The provided code correctly retrieves the performance ranking of products based on sales quantity and displays the result in a dataframe. However, it omits the visualization part present in the reference implementation, which uses Plotly to create a bar chart to visualize the ranking. To match the reference implementation, the code should include the visualization step using Plotly before displaying the result.","import pandas as pd
import plotly.express as px

# SQL query to get the performance ranking of products based on sales quantity
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) as TotalSoldQuantity, 
RANK() OVER (ORDER BY SUM(od.Quantity) DESC) as SalesRank 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
'''

# Execute the SQL query
products_performance = execute_sql_query(sql_query)

# Display the pandas dataframe to the user
show_to_user(products_performance)

# Optionally, create a visualization using plotly
fig = px.bar(products_performance, x='ProductName', y='TotalSoldQuantity', 
             color='SalesRank', title='Product Performance Ranking Based on Sales Quantity', 
             labels={'TotalSoldQuantity':'Total Sold Quantity', 'ProductName':'Product Name'})

# Show the plotly visualization to the user
show_to_user(fig)
","The input Python code correctly fulfills the business analytic request. It retrieves the performance ranking of products based on sales quantity and also provides a visualization. The main difference between the input and reference implementation is the addition of the RANK() window function in the SQL query for ranking, which is a valid enhancement. Both codes execute a SQL query, store the result in a pandas dataframe, and use Plotly for visualization. Therefore, the input code is correct and meets the specified requirements.",Finetuned
List the orders grouped by required dates and their total freight costs.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT RequiredDate, SUM(Freight) AS TotalFreightCost
FROM orders
GROUP BY RequiredDate;
'''

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Display the data
show_to_user(orders_df)

# Create a new column with formatted RequiredDate for better visualization
date_format = '%Y-%m-%d'
orders_df['FormattedDate'] = pd.to_datetime(orders_df['RequiredDate']).dt.strftime(date_format)

# Visualize the data using plotly
fig = px.bar(orders_df, x='FormattedDate', y='TotalFreightCost', title='Total Freight Cost by Required Date')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd

# SQL query to group orders by required dates and their total freight costs
sql_query = '''
SELECT RequiredDate, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY RequiredDate
ORDER BY RequiredDate;
'''  

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The input Python code correctly follows the SQL query part but it misses the part of data formatting and visualization using plotly compared to the reference implementation. It should also include steps to format dates and visualize total freight cost using plotly.,"import pandas as pd
import plotly.express as px

# SQL Query to fetch orders grouped by required dates and their total freight costs
sql_query = 'SELECT RequiredDate, SUM(Freight) AS TotalFreightCost FROM orders GROUP BY RequiredDate;'

# Execute the SQL query to retrieve the data
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)

# Create a line plot to visualize the total freight cost over required dates
fig = px.line(orders_df, x='RequiredDate', y='TotalFreightCost', title='Total Freight Cost by Required Date')

# Display the plot to the user
show_to_user(fig)","The given input Python code meets the requirements: it executes the correct SQL query to fetch orders grouped by required dates and their total freight costs, displays the dataframe, and visualizes the results using plotly. The use of a line plot instead of a bar plot is a minor difference and does not affect the correctness of the implementation.",Finetuned
Calculate the month-over-month growth rate of total sales for December 2023 and visualize the trend.,"import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = '''
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
       (SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) - LAG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) OVER (ORDER BY DATE_FORMAT(o.OrderDate, '%Y-%m'))) / LAG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) OVER (ORDER BY DATE_FORMAT(o.OrderDate, '%Y-%m')) AS MoM_GrowthRate 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') IN ('2023-11', '2023-12')
GROUP BY DATE_FORMAT(o.OrderDate, '%Y-%m')
ORDER BY DATE_FORMAT(o.OrderDate, '%Y-%m');
'''

# Execute SQL query
sales_data = execute_sql_query(sql_query)

# Ensure dataframe is not empty
if sales_data.empty:
    raise ValueError('The query returned no results.')

# Extract the month-over-month growth rate from the sales_data
mom_growth_rate_november = sales_data['MoM_GrowthRate'].iloc[0]
mom_growth_rate_december = sales_data['MoM_GrowthRate'].iloc[1]

# Preparing data for visualization
trend_data = pd.DataFrame({
    'Month': ['2023-11', '2023-12'],
    'MoM_GrowthRate': [mom_growth_rate_november, mom_growth_rate_december]
})

# Plot the trend
fig = px.line(trend_data, x='Month', y='MoM_GrowthRate', title='Month-over-Month Growth Rate of Total Sales', labels={'MoM_GrowthRate': 'MoM Growth Rate'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales per month
sql_query = '''
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    OrderDate < '2024-01-01'  -- Only include months up to December 2023
GROUP BY 
    Month
ORDER BY 
    Month;
'''

# Execute the SQL query and store the dataframe
sales_data = execute_sql_query(sql_query)

# Calculate month-over-month growth rate
distribution = sales_data.set_index('Month')['TotalSales']
distribution = distribution.pct_change() * 100  # Percentage change

# Convert the series back to a DataFrame for visualization
momo_growth = distribution.reset_index().rename(columns={0: 'MoM_Growth'})

# Create a line plot for the month-over-month growth rate
fig = px.line(momo_growth, x='Month', y='MoM_Growth', title='Month-over-Month Growth Rate of Total Sales',
              labels={'MoM_Growth': 'MoM Growth Rate (%)', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)","The input code has a few discrepancies compared to the reference implementation. Specifically, it does not directly match the conditions set out in the business analytic request, which specifies calculating the MoM growth rate for December 2023, while the input code includes months up to December 2023 without explicitly selecting November and December. The input code uses `pct_change()` which correctly calculates MoM growth but doesn't directly ensure that December's growth from November is isolated and explicitly presented as requested.","To achieve the stated goal of calculating and visualizing the month-over-month growth rate of total sales for December 2023, we should break down the process into digestible steps. The provided Python function `execute_sql_query` is used to execute SQL queries with the MDDX database, while `show_to_user` is used for displaying the results. 

### Breakdown of the Solution
1. **SQL Query**: The first task is to create a SQL query that retrieves total sales for December 2023.
2. **Month-Over-Month Calculation**: The second task is to calculate the previous month's total sales, which would be November 2023. We'll use the same SQL query but adjust the date to November.
3. **Growth Rate Calculation**: Finally, we will calculate the month-over-month growth rate using the formula:

   \[
   \text{Growth Rate} = \left( \frac{\text{December Sales} - \text{November Sales}}{\text{November Sales}} \right) \times 100
   \]

4. **Visualization**: For the growth rate visualization, we can use `matplotlib` or `plotly`.

### Proposed Python Code
Here's the Python code that implements the outlined procedure.

```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve total sales for December 2022
sql_query_december = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-12-01' AND '2023-12-31';
""""""

# SQL Query to retrieve total sales for November 2022
sql_query_november = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-11-01' AND '2023-11-30';
""""""

# Execute the queries
df_december = execute_sql_query(sql_query_december)
df_november = execute_sql_query(sql_query_november)

# Calculate the Month-over-Month Growth Rate
if not df_november.empty and not df_december.empty:
    november_sales = df_november['TotalSales'][0]
    december_sales = df_december['TotalSales'][0]
    growth_rate = ((december_sales - november_sales) / november_sales) * 100

    # Create a DataFrame for visualization
    data = {
        'Month': ['November 2023', 'December 2023'],
        'TotalSales': [november_sales, december_sales],
        'GrowthRate': [None, growth_rate]  # Growth rate is only applicable for December
    }
    df_visualisation = pd.DataFrame(data)

    # Visualize the data
    fig = px.line(df_visualisation, x='Month', y='TotalSales', title='Month-over-Month Growth Rate of Total Sales', markers=True)
    fig.add_scatter(y=[None, growth_rate], mode='markers', marker=dict(color='red', size=10), name='Growth Rate')

    # Show the visualization to the user
    show_to_user(fig)

else:
    print(""Sales data for November or December is missing."")
```

### Explanation of the Code
1. **Database Access**: SQL queries are executed to get sales data for November and December.
2. **Data Calculation**: The month-over-month growth rate is computed.
3. **Data Visualization**: The computed values are visualized using a line chart created with `plotly` and displayed to the user.

### Important Note
- Ensure that the imports for `pandas`, `plotly`, and other dependencies are available in the execution environment.
- The code assumes the SQL query returns a dataframe with a column `TotalSales` containing the sales amount.","The input code has a few discrepancies compared to the reference implementation: (1) It calculates month-over-month sales growth by running two separate SQL queries instead of using window functions as shown in the reference code, which yields the growth rate in a single query. (2) It tries to visualize both total sales and growth rate in a line chart, which is misleading; only the growth rate should be visualized according to the business request. (3) The code does not throw an error if the sales data is empty.",None
How does the average unit price of products vary across categories? Provide a visualization to compare the categories.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT products.CategoryID, AVG(products.UnitPrice) AS AverageUnitPrice FROM products GROUP BY products.CategoryID;'

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Create a bar chart to compare the average unit price across categories
fig = px.bar(result_df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price Across Categories', 
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'},
             template='plotly_white')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average unit price per category
sql_query = '''
SELECT p.CategoryID, AVG(od.UnitPrice) AS AverageUnitPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
'''

# Execute the SQL query and get the result in a pandas DataFrame
average_prices = execute_sql_query(sql_query)

# Visualize the average unit price across categories
fig = px.bar(average_prices, x='CategoryID', y='AverageUnitPrice',
             title='Average Unit Price of Products by Category',
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'},
             color='AverageUnitPrice')

# Show the plot to the user
show_to_user(fig)","The input code joins the 'products' table with the 'Order Details' table, thereby using unit prices from the 'Order Details' table instead of the 'products' table. This changes the business logic as the request specifically mentions analyzing the unit price directly from the 'products' table.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""SELECT c.CategoryName, AVG(p.UnitPrice) as AverageUnitPrice 
FROM products p 
JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryName;""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit price across categories
fig = px.bar(df, x='CategoryName', y='AverageUnitPrice', title='Average Unit Price by Category')

# Display the plot
show_to_user(fig)","The provided Python code fulfills the business analytic request to visualize the average unit price of products across categories. The code correctly executes an SQL query to fetch the required data, groups it by CategoryName, and computes the average unit price. Additionally, it generates a bar chart to visualize the data using Plotly and displays the visualization using the `show_to_user` function, meeting the specified requirements and constraints.",Finetuned
What is the most common shipping city for the current year?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if result is empty
if not result_df.empty:
    most_common_city = result_df.iloc[0]['ShipCity']
    order_count = result_df.iloc[0]['OrderCount']
    
    # Display the result
    show_to_user(result_df)
else:
    print(""No data available for the current year."")","import pandas as pd

# SQL query to retrieve the most common shipping city for the current year
sql_query = '''
SELECT ShipCity, COUNT(*) as Count
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURDATE())
GROUP BY ShipCity
ORDER BY Count DESC
LIMIT 1;
'''

# Execute the SQL query
most_common_city_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(most_common_city_df)","The input code correctly queries the database for the most common shipping city for the current year, orders the result by count, limits to one result, and displays the result to the user. It meets the specified business analytic request and follows the Python environment constraints.","import pandas as pd
import plotly.express as px


def get_most_common_shipping_city(current_year):
    # Construct the SQL query
    sql_query = f""""""
    SELECT ShipCity, COUNT(*) AS NumberOfOrders
    FROM orders
    WHERE OrderDate BETWEEN '{current_year}-01-01' AND '{current_year}-12-31'
    GROUP BY ShipCity
    ORDER BY NumberOfOrders DESC
    LIMIT 1;
    """"""
    
    # Execute the SQL query to retrieve data
    result_df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(result_df)

# Example Usage
get_most_common_shipping_city(2023)","The input code correctly constructs and executes the SQL query to find the most common shipping city and displays the result. However, it does not check if the result is empty before attempting to display it. The reference implementation includes a check for an empty result set to avoid displaying incorrect or misleading information.",Base
How many products have a reorder level of zero?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS ZeroReorderProducts FROM products WHERE ReorderLevel = 0""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to count products with a reorder level of zero
sql_query = """"""
SELECT COUNT(*) AS ProductsWithReorderLevelZero
FROM products
WHERE ReorderLevel = 0;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly follows the given business analytic request. It counts the number of products with a reorder level of zero using an appropriate SQL query, then executes it and displays the result using the provided utility functions. The approach is consistent with the reference implementation, even though the variable names and formatting of the SQL query slightly differ.","import pandas as pd

# SQL query to count products with a reorder level of zero
sql_query = ""SELECT COUNT(*) AS products_with_zero_reorder_level FROM products WHERE ReorderLevel = 0;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The input Python code is correct as it matches the business analytic request, adheres to the Python environment constraint, and provides the answer to the question. It uses the correct SQL query to count the number of products with a reorder level of zero, executes it, and displays the result to the user using the utility functions provided.",both
What is the total revenue generated by each product? Provide a visualization to compare the revenue per product.,"import pandas as pd
import plotly.express as px

# Function to execute SQL query
sql_query = """"""
SELECT p.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
INNER JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID;
""""""

data_frame = execute_sql_query(sql_query)

# Ensure the data frame column names match the SQL query
if 'ProductID' not in data_frame.columns or 'TotalRevenue' not in data_frame.columns:
    raise ValueError('Unexpected dataframe structure')

# Create a plotly bar chart to compare revenue per product
df = pd.DataFrame(data_frame)
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue per Product', labels={'ProductID':'Product ID', 'TotalRevenue':'Total Revenue'})

# Show the plotly figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue generated by each product
sql_query = '''
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalRevenue DESC;
'''

# Execute the SQL query and retrieve data as a dataframe
revenue_df = execute_sql_query(sql_query)

# Visualization of Total Revenue per Product using Plotly
fig = px.bar(revenue_df, x='ProductName', y='TotalRevenue', title='Total Revenue Generated by Each Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'},
             color='TotalRevenue')

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly addresses the business analytic request by calculating total revenue for each product and creating a visualization to compare the revenue per product. Despite small differences, it follows the constraints and the logic is sound, providing the necessary output.","import pandas as pd
import plotly.express as px

# SQL query to fetch total revenue generated by each product
sql_query = '''
SELECT p.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the result_df has the expected columns
if 'ProductID' not in result_df.columns or 'TotalRevenue' not in result_df.columns:
    raise ValueError(""The result dataframe does not have the expected columns: ProductID, TotalRevenue"")

# Visualization using plotly
fig = px.bar(result_df, x='ProductID', y='TotalRevenue', title='Total Revenue per Product', labels={'ProductID': 'Product ID', 'TotalRevenue': 'Total Revenue'})

# Display the plot
show_to_user(fig)","The input code correctly follows the business analytic request and Python environment constraints. It executes the SQL query to fetch total revenue for each product, checks the structure of the resulting dataframe, and creates a Plotly bar chart to compare the revenue per product. The functionality and output should match the reference implementation.",both
"Find the total quantity sold for each product, excluding discontinued products.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalQuantitySold 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE products.Discontinued = 0 
GROUP BY products.ProductID, products.ProductName;
''' 

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result dataframe to user
show_to_user(result_df)

# Create a bar chart to visualize the total quantity sold for each product
fig = px.bar(result_df, x='ProductName', y='TotalQuantitySold', title='Total Quantity Sold for Each Product', labels={'ProductName': 'Product Name', 'TotalQuantitySold': 'Total Quantity Sold'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd

# SQL query to find the total quantity sold for each product, excluding discontinued products
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductID, p.ProductName
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(result_df)","The input code correctly implements the SQL query to find the total quantity sold for each product, excluding discontinued products and correctly displays the result using the 'show_to_user' function. However, it lacks the portion that visualizes the result using plotly, as shown in the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE p.Discontinued = 0 
GROUP BY p.ProductName, p.ProductID;'''  # Don't forget to include ProductID in GROUP BY

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Ensure correct data types if necessary
results_df['TotalQuantitySold'] = results_df['TotalQuantitySold'].astype(int)

# Display the results to the user
show_to_user(results_df)

# Create a bar chart for visualization
fig = px.bar(results_df, x='ProductName', y='TotalQuantitySold', title='Total Quantity Sold for Each Product (Excluding Discontinued Products)', labels={'ProductName': 'Product Name', 'TotalQuantitySold': 'Total Quantity Sold'})

# Show the plot to the user
show_to_user(fig)","The input Python code correctly executes the SQL query to retrieve the total quantity sold for each product excluding discontinued products. It then displays the data using plotly's bar chart, matching the business analytic request and the reference implementation. The inclusion of ProductID in the GROUP BY clause is also correctly handled.",Finetuned
Determine the average discount applied across all products.,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details]'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the result is displayed
show_to_user(result_df)","import pandas as pd

# Query to get all discounts from the Order Details table
sql_query = """"""
SELECT AVG(Discount) as AverageDiscount
FROM [Order Details]
""""""

# Execute the SQL query and store the result in a dataframe
discount_data = execute_sql_query(sql_query)

# Display the average discount to the user using the provided utility function
show_to_user(discount_data)","The input code correctly calculates the average discount from the 'Order Details' table and uses the appropriate utility functions 'execute_sql_query' to execute the SQL query and 'show_to_user' to display the result, meeting the requirements of the business analytics request.","import pandas as pd

# SQL query to determine the average discount across all products
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];'

# Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Extract the average discount value from the dataframe
average_discount = df['AverageDiscount'].iloc[0]

# Create a dataframe to show the average discount value
result_df = pd.DataFrame({'AverageDiscount': [average_discount]})

# Display the result to the user
show_to_user(result_df)",The input code correctly performs the task of determining the average discount applied across all products. It retrieves the data using the execute_sql_query function and extracts the average discount value. It then constructs a DataFrame with this value and displays it using the show_to_user function. The code roughly matches the reference implementation and adheres to the specified constraints.,both
How many orders were placed each month in the last year? Visualize the monthly order counts.,"import pandas as pd
import plotly.express as px

# SQL query to get the monthly order counts
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query and get the result in a pandas dataframe
order_counts_df = execute_sql_query(sql_query)

# Create a line plot to visualize the monthly order counts
fig = px.line(order_counts_df, x='Month', y='OrderCount', title='Monthly Order Counts in the Last Year', labels={'Month': 'Month', 'OrderCount': 'Order Count'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the monthly order counts for the last year
sql_query = '''
SELECT
    DATE_TRUNC('month', OrderDate) AS month,
    COUNT(OrderID) AS order_count
FROM
    orders
WHERE
    OrderDate >= NOW() - INTERVAL '1 YEAR'
GROUP BY
    month
ORDER BY
    month;
'''

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Visualize the monthly order counts
fig = px.line(order_data, x='month', y='order_count', title='Monthly Orders in the Last Year', labels={'month': 'Month', 'order_count': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly retrieves the monthly order counts for the last year using an SQL query and visualizes it using a Plotly line chart. The code matches the reference implementation in terms of functionality, adhering to the provided Python environment constraints and business request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT YEAR(OrderDate) AS Year, MONTH(OrderDate) AS Month, COUNT(OrderID) AS OrderCount FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY YEAR(OrderDate), MONTH(OrderDate);""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Ensure Month is treated as an integer for correct sorting
order_data['Month'] = order_data['Month'].astype(int)

# Sort the data by Year and Month
order_data = order_data.sort_values(by=['Year', 'Month'])

# Create the plot
fig = px.line(order_data, x='Month', y='OrderCount', title='Monthly Order Counts in the Last Year', labels={'OrderCount': 'Order Count', 'Month': 'Month'})

# Display the plot
show_to_user(fig)

# Display the raw data for verification
show_to_user(order_data)","The given Python code correctly retrieves the monthly order counts for the past year, sorts the data, and visualizes it using a line plot. It follows the required environment constraints and effectively produces output similar to the reference implementation.",both
"List the count of products in each category, supplied by supplier.","import pandas as pd
import plotly.express as px

# SQL query to get the count of products in each category supplied by supplier
sql_query = '''
SELECT s.SupplierID, s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID, s.CompanyName, p.CategoryID;''' 

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, if you want a visualization, you can use plotly to create a bar chart
fig = px.bar(result_df, x='CompanyName', y='ProductCount', color='CategoryID', 
             title='Product Count by Supplier and Category', labels={
                 'CompanyName': 'Supplier',
                 'ProductCount': 'Number of Products',
                 'CategoryID': 'Category ID'
             })

# Show the visualization to the user
show_to_user(fig)","import pandas as pd

# SQL query to count products in each category, supplied by each supplier
sql_query = '''
SELECT s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName, p.CategoryID
ORDER BY s.CompanyName, p.CategoryID;
'''  

# Execute the SQL query and retrieve the data in a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code correctly retrieves the count of products in each category supplied by each supplier. It uses a SQL query to aggregate product counts grouped by supplier and category, executes the query to get a pandas DataFrame, and displays the result to the user using the provided utility functions. Despite the reference implementation including an optional plotly visualization, the main requirements of the business analytic request are met.","import pandas as pd
import plotly.express as px

def list_product_count_per_category_per_supplier():
    # Define the SQL query
    sql_query = '''
    SELECT c.CategoryID, s.SupplierID, COUNT(p.ProductID) as ProductCount 
    FROM products p 
    JOIN categories c ON p.CategoryID = c.CategoryID 
    JOIN suppliers s ON p.SupplierID = s.SupplierID 
    GROUP BY c.CategoryID, s.SupplierID;
    '''
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Ensure proper data types
    df['CategoryID'] = df['CategoryID'].astype(str)
    df['SupplierID'] = df['SupplierID'].astype(str)
    df['ProductCount'] = df['ProductCount'].astype(int)
    
    # Display the data analysis result to the user
    show_to_user(df)
    
    # Optionally, you can visualize the data analysis result using plotly
    fig = px.bar(df, x='CategoryID', y='ProductCount', color='SupplierID',
                 title='Count of Products in Each Category, Supplied by Supplier',
                 labels={'ProductCount': 'Product Count', 'CategoryID': 'Category', 'SupplierID': 'Supplier'})
    
    show_to_user(fig)

# Call the function to perform the analysis and visualization
list_product_count_per_category_per_supplier()
}","The input Python code correctly follows the Python environment constraint and addresses the business analytic request by providing the count of products in each category, supplied by supplier. The SQL query joins the relevant tables, groups by category and supplier, and counts the products as needed. It also ensures proper data types, displays the result to the user, and optionally provides a Plotly visualization for better understanding, similar to the reference implementation.",both
What is the average order fulfillment time for March 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageFulfillmentTime 
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-03-31';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the average order fulfillment time for March 2023
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= '2023-03-01' AND OrderDate < '2023-04-01' AND ShippedDate IS NOT NULL
""""""

# Execute the SQL query and retrieve the data
fulfillment_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(fulfillment_data)",The input Python code correctly calculates the average order fulfillment time for March 2023 using an SQL query. It correctly handles the date range and checks for non-null ShippedDate values. The utility functions 'execute_sql_query' and 'show_to_user' are used appropriately to execute the query and display the result.,"import pandas as pd
from datetime import datetime

# Define the SQL query
sql_query = '''
SELECT AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgFulfillmentTime 
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-03-31';
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Assuming the result_df contains a column 'AvgFulfillmentTime'
avg_fulfillment_time = result_df.loc[0, 'AvgFulfillmentTime']

# Display the result to the user
show_to_user(pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]}))","The input Python code correctly follows the Python environment constraint, retrieves the average fulfillment time for March 2023 using a SQL query, and properly displays the result to the user. The logic and data handling are consistent with the reference implementation.",both
Identify the top 3 suppliers based on the total sales value of their products. Visualize the sales value comparison.,"
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT SupplierID, SUM([Order Details].UnitPrice * Quantity) AS TotalSalesValue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY SupplierID 
ORDER BY TotalSalesValue DESC 
LIMIT 3;'''

# Execute SQL query to get the data
supplier_sales_df = execute_sql_query(sql_query)

# Create a bar chart for sales value comparison
fig = px.bar(supplier_sales_df, x='SupplierID', y='TotalSalesValue', title='Top 3 Suppliers based on Total Sales Value', labels={'SupplierID': 'Supplier ID', 'TotalSalesValue': 'Total Sales Value'})

# Show the plot to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales value for each supplier
sql_query = '''
SELECT p.SupplierID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.SupplierID
ORDER BY TotalSales DESC
LIMIT 3;
'''

# Execute the SQL query and retrieve data
top_suppliers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales value comparison
fig = px.bar(top_suppliers_df, x='SupplierID', y='TotalSales', 
             title='Top 3 Suppliers by Total Sales Value', 
             labels={'SupplierID': 'Supplier ID', 'TotalSales': 'Total Sales Value'}, 
             color='TotalSales')

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly retrieves the top 3 suppliers based on the total sales value of their products using an SQL query, generates a bar chart using Plotly for visualization, and displays this chart to the user. It matches the functionality required by the business analytic request and the methods used in the reference implementation.","import plotly.express as px

def execute_sql_query(sql_query: str):
    # Placeholder for the actual database query execution function
    pass

def show_to_user(data):
    # Placeholder for the actual visualization showing function
    pass

# SQL query to identify the top 3 suppliers based on total sales value
sql_query = '''
SELECT s.SupplierID, SUM(od.Quantity * od.UnitPrice) AS TotalSalesValue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID
ORDER BY TotalSalesValue DESC
LIMIT 3;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Creating the bar chart using plotly
fig = px.bar(result_df, x='SupplierID', y='TotalSalesValue', title='Top 3 Suppliers by Total Sales Value', labels={'SupplierID': 'Supplier ID', 'TotalSalesValue': 'Total Sales Value'})

# Display the visualization to user
show_to_user(fig)","The input code performs the correct operations to meet the business analytic request. It correctly constructs and executes the SQL query to identify the top 3 suppliers based on total sales value, and it visualizes the sales value comparison using a bar chart with Plotly. The code aligns with the provided Python environment constraints and produces an appropriate output similar to the reference implementation.",both
List all products that need reordering.,"import pandas as pd

# Business Analytic Request: List all products that need reordering
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;'

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(products_df)","import pandas as pd

# SQL query to find products that need reordering
sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0
'''

# Execute the SQL query
reorder_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(reorder_products_df)","The input Python code correctly follows the business analytic request to list all products that need reordering. It includes the necessary SQL query with conditions on 'UnitsInStock' and 'ReorderLevel', and applies an additional condition to exclude discontinued products. This query is executed using the 'execute_sql_query' function, and the result is displayed using the 'show_to_user' function. The additional filter for discontinued products does not violate the request and provides more accurate results.","import pandas as pd
import plotly.express as px

def list_products_needing_reorder():
    # Define the SQL query
    sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;'
    
    # Execute the SQL query to fetch data
    products_df = execute_sql_query(sql_query)
    
    # Display the data to the user
    show_to_user(products_df)

# Calling the function to execute the above logic
list_products_needing_reorder()",The input Python code correctly lists the products that need reordering by executing an SQL query to fetch products where UnitsInStock is less than ReorderLevel. The results are then displayed to the user using the show_to_user function. The slight difference in the SQL query (ProductID included) does not affect the correctness regarding the Business Analytic Request.,both
What is the average order fulfillment time by month for 2023? Provide a visualization to show the monthly average fulfillment times.,"import pandas as pd
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the month column is treated as a datetime object
# This will allow plotly to sort the x-axis correctly by month
# Convert month column to datetime
df['month'] = pd.to_datetime(df['month'], format='%Y-%m')

# Sort the DataFrame by month to ensure correct plotting order
df = df.sort_values('month')

# Create a line plot of the average fulfillment time by month
fig = px.line(df, x='month', y='avg_fulfillment_time', title='Average Order Fulfillment Time by Month for 2023', labels={'month': 'Month', 'avg_fulfillment_time': 'Average Fulfillment Time (Days)'})

# Show the resulting plot to the user
show_to_user(fig)
}","import pandas as pd
import plotly.express as px

# SQL query to retrieve average order fulfillment time by month for the year 2023
sql_query = """"""
SELECT
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_fulfillment_time
FROM
    orders
WHERE
    YEAR(orders.OrderDate) = 2023
GROUP BY
    month
ORDER BY
    month
""""""

# Execute SQL query and retrieve data
fulfillment_time_df = execute_sql_query(sql_query)

# Create a line plot for average order fulfillment time by month
fig = px.line(fulfillment_time_df, x='month', y='average_fulfillment_time', title='Average Order Fulfillment Time by Month in 2023', labels={'average_fulfillment_time': 'Average Fulfillment Time (Days)', 'month': 'Month'})

# Show the visualization to the user
show_to_user(fig)","The input Python code meets the business analytic request, adheres to the specified Python environment constraints, and correctly performs the data analysis and visualization. It retrieves the average fulfillment time per month for 2023, processes the data appropriately, and generates a plotly line chart for visualization which is then shown to the user.","
# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
        AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY month 
ORDER BY month
""""""

# Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# Ensure the 'month' column is sorted correctly as datetime
orders_df['month'] = pd.to_datetime(orders_df['month'], format='%Y-%m')

# Generate the line plot for average order fulfillment time by month
fig = px.line(orders_df, x='month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time by Month in 2023',
              labels={'month': 'Month', 'avg_fulfillment_time': 'Average Fulfillment Time (Days)'})

# Show the plot to the user
show_to_user(fig)
","The provided code correctly follows the business request by calculating the average order fulfillment time for each month in 2023, sorting the months properly, and producing a visualization via plotly. It conforms to the Python environment constraints and roughly matches the reference implementation.",both
Which products have less than 10 units in stock?,"import pandas as pd
import plotly.express as px

# SQL query to find products with less than 10 units in stock
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query and retrieve the data as a pandas dataframe
# Utilize the provided utility function `execute_sql_query` to fetch the data
data = execute_sql_query(sql_query)

# Ensure that the dataframe is indeed fetched successfully
display(data)

# Display the data to the user
show_to_user(data)

# Optional: Create a bar chart to visualize the products and their stock levels
fig = px.bar(data, x='ProductName', y='UnitsInStock', title='Products with Less Than 10 Units in Stock', labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units In Stock'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd

# SQL query to fetch products with less than 10 units in stock
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
WHERE UnitsInStock < 10
""""""

# Execute the SQL query
products_below_threshold = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(products_below_threshold)","The input Python code correctly executes the SQL query to fetch products with less than 10 units in stock using the provided utility function `execute_sql_query`. The results are also correctly shown to the user using the `show_to_user` function. Although it does not include the optional plotly visualization, the code meets the primary business analytic request.","import pandas as pd

# Define the SQL query to find products with less than 10 units in stock
sql_query = 'SELECT ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10;'

# Execute the SQL query and get the result as a pandas dataframe
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)",The input code correctly executes the SQL query to retrieve products with less than 10 units in stock and displays the result using the `show_to_user` function. It meets the outlined constraints and sufficiently answers the business analytic request. Optional visualization with plotly is not necessary for correctness.,both
Which employee processed the most orders?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT EmployeeID, COUNT(OrderID) AS TotalOrders FROM orders GROUP BY EmployeeID ORDER BY TotalOrders DESC LIMIT 1;""

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Query to count orders processed by each employee
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) as OrderCount 
FROM orders 
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
'''  

# Execute the SQL query and retrieve data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The given Python code correctly follows the Python environment constraints and accurately answers the business analytic request. It uses the SQL query to count and order the number of orders processed by each employee, retrieves the data using the provided execute_sql_query function, and displays the result using the show_to_user function. It matches the reference implementation in functionality, although it formats the SQL query string slightly differently.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
INNER JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(result_df.head(1))

# Optionally, visualize the order counts of all employees
fig = px.bar(result_df, x='EmployeeID', y='OrderCount', title='Orders Processed by Employees', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})
show_to_user(fig)",The input Python code correctly identifies the employee who processed the most orders by using a descending order count and limiting the results to the top one. It also includes a visualization that provides additional insights.,both
Identify the customer with the most late shipments.,"import pandas as pd
import plotly.express as px

# SQL query to identify the customer with the most late shipments
sql_query = '''
SELECT c.CustomerID, COUNT(o.OrderID) AS LateOrderCount 
FROM customers c JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.RequiredDate < o.ShippedDate 
GROUP BY c.CustomerID 
ORDER BY LateOrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","import pandas as pd

# Query to identify the customers with the most late shipments
sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS LateShipments
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY c.CustomerID, c.CompanyName
ORDER BY LateShipments DESC
LIMIT 1;
""""""

# Execute the SQL query
late_shipments_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(late_shipments_df)","The input code correctly identifies the customer with the most late shipments by executing a SQL query. It adheres to the constraint of using the provided utility functions execute_sql_query and show_to_user. The query structure is valid and retrieves the correct information, including CustomerID and CompanyName, while considering the condition for late shipments (ShippedDate > RequiredDate). The order of operations and the output limit ensure that only the customer with the most late shipments is displayed.","import pandas as pd
import plotly.express as px

# Step 1: Identify the customer with the most late shipments
# Query to find customer with most late shipments
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS LateShipments 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY CustomerID 
ORDER BY LateShipments DESC 
LIMIT 1;
'''

# Step 2: Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Step 3: Display the resulting data to the user
show_to_user(result_df)","The input Python code correctly follows the outlined steps to address the business analytic request. It constructs an SQL query to identify the customer with the most late shipments, executes this query using execute_sql_query to obtain a pandas DataFrame, and then uses show_to_user to display the result. Both the input and the reference code achieve the same goal and output the required result correctly.",both
Find the orders placed in the last 30 days and their total freight cost.,"import pandas as pd
import plotly.express as px

# Execute the SQL Query to get the orders placed in the last 30 days
df_orders = execute_sql_query(""SELECT o.OrderID, o.OrderDate, o.ShippedDate, o.Freight FROM orders o WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 30 DAY);"")

# Display the dataframe to the user
show_to_user(df_orders)

# Calculate the total freight cost
total_freight = df_orders['Freight'].sum()

# Display the total freight cost to the user
show_to_user(pd.DataFrame({'TotalFreight': [total_freight]}))","import pandas as pd
from datetime import datetime, timedelta

# Calculate the date for 30 days ago from today
date_30_days_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')

# SQL query to find orders placed in the last 30 days along with their total freight cost
sql_query = f""""""
SELECT OrderID, OrderDate, Freight
FROM orders
WHERE OrderDate >= '{date_30_days_ago}'
""""""

# Execute the query and retrieve data
orders_data = execute_sql_query(sql_query)

# Show the result to user
show_to_user(orders_data)","The input code correctly retrieves and displays orders placed in the last 30 days, but it does not calculate and display the total freight cost. This is a key part of the business analytic request.","import pandas as pd
import datetime

# SQL query to get the required data
sql_query = ""SELECT OrderID, Freight FROM orders WHERE OrderDate >= GETDATE() - INTERVAL '30 DAYS';""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Calculate the total freight cost from the resulting dataframe
# Extract the total freight cost with sum()
total_freight_cost = df_orders['Freight'].sum()

# Prepare result to show - first show the orders then the total freight cost
data_to_display = df_orders.copy()  # Copy the original dataframe for display
data_to_display.loc[len(data_to_display)] = ['Total Freight Cost', total_freight_cost]

# Display the result to the user
show_to_user(data_to_display)","The input Python code correctly fulfills the business analytic request by retrieving the orders placed in the last 30 days and calculating their total freight cost. It uses the 'execute_sql_query' function to get the relevant data and 'show_to_user' to display the results. The SQL query has a slight discrepancy in syntax (GETDATE() - INTERVAL '30 DAYS' instead of DATE_SUB(CURDATE(), INTERVAL 30 DAY)), but assuming the environment handles this correctly, the logic and structure align well with the request.",Finetuned
Determine the number of discontinued products.,"import pandas as pd

# SQL query to determine the number of discontinued products
sql_query = ""SELECT COUNT(*) AS DiscontinuedProducts FROM products WHERE Discontinued = 1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to count the number of discontinued products
sql_query = """"""
SELECT COUNT(*) AS DiscontinuedProductsCount
FROM products
WHERE Discontinued = 1
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly follows the business analytic request, which is to determine the number of discontinued products. It constructs the appropriate SQL query, executes it using the 'execute_sql_query' function, and displays the results using the 'show_to_user' function. The implementation closely matches the reference code in functionality, though variable names are slightly different.","import pandas as pd

# Define the SQL query to get the count of discontinued products
sql_query = 'SELECT COUNT(*) AS NumberOfDiscontinuedProducts FROM products WHERE Discontinued = 1;'

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Display the result using the provided function; assuming the result_df has one row and one column
show_to_user(result_df.iloc[0, 0])","The input Python code has a critical flaw in how it displays the result. Instead of showing the dataframe, it tries to display a single value from the dataframe using `result_df.iloc[0, 0]`. This will not match the reference implementation which intends to display the entire dataframe.",Base
What is the average shipping cost per order per month? Include a visualization to compare shipping costs across different months.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as a datetime type for proper plotting and sorting
orders_df['Month'] = pd.to_datetime(orders_df['Month'], format='%Y-%m')

# Sort the dataframe by 'Month' to ensure the plot is ordered chronologically
orders_df = orders_df.sort_values(by='Month')

# Create the line plot using plotly
fig = px.line(orders_df, x='Month', y='AvgShippingCost', title='Average Shipping Cost Per Order Per Month', labels={'Month': 'Month', 'AvgShippingCost': 'Average Shipping Cost'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average shipping cost per order per month
sql_query = '''
SELECT
    DATE_TRUNC('month', OrderDate) AS Month,
    AVG(Freight) AS AverageShippingCost
FROM
    orders
GROUP BY
    Month
ORDER BY
    Month
'''  

# Execute the SQL query and retrieve data
avg_shipping_cost_df = execute_sql_query(sql_query)

# Create a line plot to visualize average shipping costs across different months
fig = px.line(avg_shipping_cost_df, x='Month', y='AverageShippingCost',
              title='Average Shipping Cost per Order per Month',
              labels={'Month': 'Month', 'AverageShippingCost': 'Average Shipping Cost'} )

# Display the result to the user
show_to_user(fig)","The input code correctly calculates the average shipping cost per order per month and visualizes it using a line plot. It uses DATE_TRUNC to group dates by month in a way suitable for SQL databases that support this function. The code uses the provided utility functions execute_sql_query and show_to_user to execute the query and display the visualization correctly. The column names and labels are correct and match the business analytic request. The output structure, although not identical, achieves the required functionality.","import pandas as pd
import plotly.express as px

# SQL query to fetch the average shipping cost per order per month
sql_query = ""SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AverageShippingCost FROM orders GROUP BY Month;""

# Execute the SQL query using the utility function
shipping_cost_df = execute_sql_query(sql_query)

# Ensure that the 'Month' column is treated as a datetime type for proper sorting
shipping_cost_df['Month'] = pd.to_datetime(shipping_cost_df['Month'], format='%Y-%m')

# Sort the dataframe by 'Month' to ensure correct chronological order
shipping_cost_df.sort_values('Month', inplace=True)

# Visualization using plotly
fig = px.line(shipping_cost_df, x='Month', y='AverageShippingCost', title='Average Shipping Cost per Order per Month', labels={'Month': 'Month', 'AverageShippingCost': 'Average Shipping Cost'}, markers=True)

# Display the resulting plot to the user
show_to_user(fig)","The input Python code matches the business analytic request, follows the given Python environment constraints, and produces a similar output to the reference implementation. It correctly calculates the average shipping cost per month and uses plotly for visualization.",both
Find out how many orders each employee managed in a specific date range. Provide a bar chart to visualize the distribution of orders among employees.,"import pandas as pd
import plotly.express as px

# Define the specific date range
start_date = '2023-01-01'
end_date = '2023-12-31'

# Craft the SQL query
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY e.EmployeeID;""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of orders among employees
fig = px.bar(data, x='EmployeeID', y='OrderCount', title='Number of Orders Managed by Each Employee', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})

# Show the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the date range for the analysis
date_start = 'YYYY-MM-DD'  # Replace with start date
date_end = 'YYYY-MM-DD'    # Replace with end date

# SQL query to get the count of orders managed by each employee in the specified date range
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees AS e
LEFT JOIN orders AS o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{date_start}' AND '{date_end}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""  

# Execute the SQL query and get the results as a DataFrame
employee_orders_df = execute_sql_query(sql_query)

# Display the DataFrame to the user
show_to_user(employee_orders_df)

# Create a bar chart to visualize the distribution of orders among employees
fig = px.bar(employee_orders_df, x='LastName', y='OrderCount',
             title='Distribution of Orders Among Employees',
             labels={'LastName': 'Employee Last Name', 'OrderCount': 'Number of Orders'},
             color='OrderCount')

# Show the plotly figure to the user
show_to_user(fig)","The input code has a placeholder for date ranges ('YYYY-MM-DD') instead of actual dates, which will result in an invalid SQL query. Additionally, the SQL query includes extra fields (FirstName, LastName) that are not necessary according to the reference implementation. The LEFT JOIN might also include employees without any orders in the count, which isn't the case in the reference implementation.","import plotly.express as px
import pandas as pd

# Define the date range
start_date = '2023-09-01'
end_date = '2023-09-30'

# SQL Query
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}' 
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

# Execute the SQL query and retrieve the data
employee_order_data = execute_sql_query(sql_query)

# Create a new column 'FullName' combining first and last name
employee_order_data['FullName'] = employee_order_data['FirstName'] + ' ' + employee_order_data['LastName']

# Create the bar chart using plotly
fig = px.bar(employee_order_data, x='FullName', y='OrderCount', title='Order Counts by Employee', labels={'FullName': 'Employee', 'OrderCount': 'Number of Orders'})

# Show the bar chart to the user
show_to_user(fig)
","The input Python code meets the requirements of the business analytic request by calculating the orders managed by each employee within a specific date range and visualizing the data in a bar chart. It uses the provided utility functions to execute the SQL query and display the plot. Although it includes additional columns for the employee's first and last names and combines them into a full name for a more descriptive x-axis, this does not alter the correctness of the code.",Finetuned
Which products have been discontinued?,"import pandas as pd
import plotly.express as px

# Define the SQL query to fetch discontinued products
sql_query = 'SELECT ProductName FROM products WHERE Discontinued = 1;'

# Execute the SQL query using the provided utility function
discontinued_products_df = execute_sql_query(sql_query)

# Display the result to the user using the provided utility function
show_to_user(discontinued_products_df)","import pandas as pd

# SQL query to retrieve discontinued products
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE Discontinued = 1
""""""

# Execute the SQL query using the provided utility function
discontinued_products = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discontinued_products)","The input Python code is correct as it accurately retrieves the discontinued products from the database using the given SQL query and displays the result to the user. The main difference is that it includes ProductID in the SQL query, but this does not affect the correctness of answering which products have been discontinued.","import pandas as pd

# Function to fetch discontinued products
def get_discontinued_products():
    # SQL query to get discontinued products
    sql_query = ""SELECT ProductID, ProductName FROM products WHERE Discontinued = 1;""
    # Execute the query and fetch the data
    discontinued_products = execute_sql_query(sql_query)
    # Display the data to the user
    show_to_user(discontinued_products)

# Call the function to see result
get_discontinued_products()","The input Python code correctly fetches discontinued products from the database using the provided SQL query. The results are displayed to the user using the utility function show_to_user. While the input code retrieves ProductID in addition to ProductName, it still satisfies the business analytic request of identifying which products have been discontinued.",both
What is the monthly inventory turnover ratio? Visualize the inventory turnover ratio over time using a line chart.,"import pandas as pd
import plotly.express as px

# SQL query to get the monthly inventory turnover ratio
df = execute_sql_query(""SELECT DATEPART(month, OrderDate) AS Month, SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS InventoryTurnoverRatio FROM [Order Details] OD JOIN products P ON OD.ProductID = P.ProductID GROUP BY DATEPART(month, OrderDate);"")

# Ensure the 'Month' column is in the correct order (1 to 12)
df['Month'] = df['Month'].astype(int)
df = df.sort_values(by='Month')

# Visualize the inventory turnover ratio over time using a line chart
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio', labels={'Month': 'Month', 'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

# Display the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate the monthly inventory turnover ratio
sql_query = """"""
SELECT
    DATE_TRUNC('month', o.created_at) AS month,
    SUM(od.Quantity * od.UnitPrice) AS cost_of_goods_sold,
    AVG(p.UnitsInStock) AS average_inventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS inventory_turnover_ratio
FROM
    [Order Details] od
JOIN
    products p ON od.ProductID = p.ProductID
JOIN
    orders o ON od.OrderID = o.OrderID
GROUP BY
    month
ORDER BY
    month
""""""

# Execute SQL query
inventory_turnover_df = execute_sql_query(sql_query)

# Plotting the inventory turnover ratio over time
fig = px.line(inventory_turnover_df, x='month', y='inventory_turnover_ratio',
              title='Monthly Inventory Turnover Ratio',
              labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio', 'month': 'Month'})

# Show the figure to the user
show_to_user(fig)","The input code correctly calculates the monthly inventory turnover ratio and visualizes it with a line chart. It follows the specified Python environment constraints and fulfills the business analytic request, although the SQL syntax and minor details differ from the reference implementation.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
SUM([Order Details].Quantity * [Order Details].UnitPrice) /
(AVG(products.UnitsInStock) * AVG(products.UnitPrice)) AS InventoryTurnoverRatio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY Month
ORDER BY Month
'''

# Execute the SQL query
inventory_turnover_df = execute_sql_query(sql_query)

# Fix date parsing to sort correctly
inventory_turnover_df['Month'] = pd.to_datetime(inventory_turnover_df['Month']).dt.to_period('M')
inventory_turnover_df.sort_values('Month', inplace=True)
inventory_turnover_df['Month'] = inventory_turnover_df['Month'].astype(str)

# Create the line chart using plotly
fig = px.line(inventory_turnover_df, x='Month', y='InventoryTurnoverRatio', 
              title='Monthly Inventory Turnover Ratio', labels={'Month': 'Month', 'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

# Show the visualization to the user
show_to_user(fig)
","The input code correctly calculates the monthly inventory turnover ratio and visualizes it using a line chart. It uses the provided 'execute_sql_query' and 'show_to_user' functions, adheres to the Python environment constraints, and ensures the 'Month' column is properly sorted for accurate visualization.",both
Which products are associated with the highest total order quantities? Use a bar chart to illustrate products with the highest order quantities.,"import plotly.express as px

# SQL Query to retrieve the data
dataset_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrderedQuantity 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalOrderedQuantity DESC;
'''

# Execute the SQL query using the provided function
df = execute_sql_query(dataset_query)

# Create a bar chart using plotly.express
fig = px.bar(df, x='ProductName', y='TotalOrderedQuantity', title='Products with the Highest Total Order Quantities', labels={'ProductName': 'Product Name', 'TotalOrderedQuantity': 'Total Ordered Quantity'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total order quantities for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
'''

# Execute the SQL query and retrieve the data
product_quantities_df = execute_sql_query(sql_query)

# Create a bar chart to visualize products with the highest order quantities
fig = px.bar(product_quantities_df, x='ProductName', y='TotalQuantity', title='Products with Highest Total Order Quantities',
             labels={'TotalQuantity': 'Total Order Quantity', 'ProductName': 'Product Name'},
             color='TotalQuantity',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the visualization to the user
show_to_user(fig)","The input Python code meets the business analytic request by querying for products with the highest total order quantities, correctly aggregates the data using a SQL query, and uses Plotly to create a bar chart. It uses the utility functions 'execute_sql_query' to get the data and 'show_to_user' to display the chart, as specified in the environment constraints.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalOrderQuantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID 
ORDER BY TotalOrderQuantity DESC;
'''

# Execute the query and retrieve the data into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='TotalOrderQuantity', title='Products with the Highest Total Order Quantities')

# Display the bar chart to the user
show_to_user(fig)","The input code does not include the 'ProductName' in the SQL query, which is required to label the bars in the chart properly. The reference implementation includes both 'ProductName' and 'ProductID' in the GROUP BY clause and selects 'ProductName' to be used in the x-axis of the bar chart. The input code only uses 'ProductID', which may not be as informative for users.",Base
What are the names of products that are currently discontinued?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT ProductName FROM products WHERE Discontinued = 1;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to select names of discontinued products
sql_query = """"""
SELECT ProductName
FROM products
WHERE Discontinued = 1
""""""

# Execute the SQL query and retrieve data
discontinued_products_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(discontinued_products_df)",The input Python code correctly fetches the names of products that are currently discontinued by executing a SQL query to select products where the 'Discontinued' field is set to 1. The result is returned as a pandas DataFrame and then displayed to the user using the specified utility functions.,"import pandas as pd

# Execute the SQL query to get the names of discontinued products.
df_discontinued = execute_sql_query(""SELECT ProductName FROM products WHERE Discontinued = 1;"")

# Display the result using the show_to_user function.
show_to_user(df_discontinued)","The input Python code executes an SQL query to retrieve the names of the products that are currently discontinued and displays the result using the show_to_user function. This matches the requirement and reference implementation, following the provided constraints and correctly addressing the analytic request.",both
What is the total freight cost for all orders made in the year 2022?,"import pandas as pd
import plotly.express as px

def get_total_freight_cost_for_2022():
    sql_query = """"""
    SELECT SUM(Freight) AS TotalFreightCost 
    FROM orders 
    WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
    """"""
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Display the result to the user as a table
    show_to_user(df)
    
    # Additional: Display the result as a simple print statement
    total_cost = df['TotalFreightCost'][0] if not df.empty else 0
    print(f'Total Freight Cost for 2022: {total_cost}')

# Call the function to execute the process
get_total_freight_cost_for_2022()","sql_query = """"""
SELECT SUM(Freight) as TotalFreight
FROM orders
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

df_total_freight = execute_sql_query(sql_query)

show_to_user(df_total_freight)","The provided input code correctly calculates the total freight cost for orders made in the year 2022 using an SQL query, executes the query, and calls the show_to_user function to display the result. It adheres to the specified business analytic request and the Python environment constraint.","import pandas as pd
import plotly.express as px

# SQL query to find total freight cost for orders made in 2022
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
""""""

# Execute the SQL query and fetch the data
result_df = execute_sql_query(sql_query)

# Extract the total freight cost from the result dataframe
TotalFreightCost = result_df.loc[0, 'TotalFreightCost']

# Convert the result to a dataframe for display purposes
display_df = pd.DataFrame({'TotalFreightCost': [TotalFreightCost]})

# Display the result to the user
show_to_user(display_df)
","The provided Python code correctly executes an SQL query to retrieve the total freight cost for orders made in the year 2022 and displays the result to the user. It follows the required Python environment constraints, as it uses execute_sql_query to fetch data and show_to_user to display the result. It matches the functionality of the reference implementation, even though the order of some operations is slightly different.",both
What is the total sales revenue generated in each month? Present the results with a bar chart to show monthly revenue.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query string
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY month;
'''

# Execute the SQL query to get the result in a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(sales_data, x='month', y='TotalSales', title='Monthly Sales Revenue')

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales revenue per month
sql_query = '''
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
INNER JOIN 
    [Order Details]
ON 
    orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
''' 

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(monthly_sales_df, x='Month', y='TotalSales', title='Total Sales Revenue per Month', labels={'TotalSales': 'Total Sales ($)', 'Month': 'Month'})

# Display the bar chart
show_to_user(fig)","The input Python code correctly follows the Python environment constraints, executes the SQL query to retrieve monthly sales revenue, and displays a bar chart using Plotly. The code logic aligns with the reference implementation and fulfills the business analytic request.","import plotly.express as px

# Step 1: Write the SQL query to retrieve the required data
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY month;
""""""

# Step 2: Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Step 3: Create a bar chart to visualize monthly sales revenue
fig = px.bar(sales_data, x='month', y='total_sales', title='Monthly Sales Revenue', labels={'total_sales': 'Total Sales', 'month': 'Month'})

# Step 4: Display the bar chart to user
show_to_user(fig)","The input Python code correctly follows the business analytic request and matches the reference implementation. The SQL query correctly calculates the total sales revenue for each month and groups the results by month. The resulting data is visualized using a bar chart created with Plotly, and the chart is displayed using the show_to_user function. The code adheres to the specified environment constraints of using execute_sql_query and show_to_user functions.",both
Find the CustomerID and the total number of orders for each customer who has ordered more than 10 times.,"
import pandas as pd
import plotly.express as px

# Define the SQL query to get CustomerID and order count for customers with more than 10 orders
sql_query = '''
SELECT customers.CustomerID, COUNT(orders.OrderID) AS order_count 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
GROUP BY customers.CustomerID 
HAVING COUNT(orders.OrderID) > 10
'''

# Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the resulting dataframe has the required columns
if 'CustomerID' in df.columns and 'order_count' in df.columns:
    # Display the resulting dataframe to the user
    show_to_user(df)

    # Optionally, create a visualization using plotly (e.g., a bar chart)
    fig = px.bar(df, x='CustomerID', y='order_count', title='Customers with More Than 10 Orders',
                 labels={'CustomerID': 'Customer ID', 'order_count': 'Total Number of Orders'})

    # Display the visualization to the user
    show_to_user(fig)
else:
    show_to_user('The SQL query did not return the expected columns.')
","sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10
'''

result_df = execute_sql_query(sql_query)

show_to_user(result_df)","The input Python code accomplishes the task correctly. It retrieves the CustomerID and the count of orders for each customer who has ordered more than 10 times using the correct SQL query. The resulting dataframe is then displayed using the 'show_to_user' function. While it lacks the additional visualization part using plotly, the core requirement of fetching and displaying the relevant data is met.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID, COUNT(*) AS TotalOrders 
FROM orders 
GROUP BY CustomerID 
HAVING COUNT(*) > 10;
""""""

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, create a bar plot to visualize the total orders per customer
fig = px.bar(result_df, x='CustomerID', y='TotalOrders', title='Total Orders per Customer (More than 10 orders)', labels={'CustomerID': 'Customer ID', 'TotalOrders': 'Total Orders'})

# Display the plot
show_to_user(fig)","The input Python code correctly implements the business analytic request by executing an SQL query to find CustomerID and the total number of orders for each customer who has ordered more than 10 times. It then displays the result and creates a bar plot using plotly, which matches the functionality described in the reference implementation.",both
How many orders were shipped over a week late in August 2023?,"import pandas as pd

# Construct the SQL query
sql_query = '''
SELECT COUNT(OrderID) AS LateOrders 
FROM orders 
WHERE DATEDIFF(ShippedDate, RequiredDate) > 7 
AND OrderDate BETWEEN '2023-08-01' AND '2023-08-31';
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to get the count of orders shipped over a week late in August 2023
sql_query = """"""
SELECT COUNT(*) AS LateOrders
FROM orders
WHERE ShippedDate > RequiredDate + INTERVAL 7 DAY
  AND ShippedDate >= '2023-08-01'
  AND ShippedDate < '2023-09-01'
""""""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(late_orders_df)",The input code correctly constructs and executes an SQL query to find the count of orders shipped over a week late in August 2023. The logic in the input code using 'ShippedDate > RequiredDate + INTERVAL 7 DAY' and the date range for August 2023 is appropriate. It also properly utilizes the utility functions 'execute_sql_query' and 'show_to_user'.,"import pandas as pd

# Define the SQL query
sql_query = '''
SELECT COUNT(*) AS OrdersOverWeekLate 
FROM orders 
WHERE DATEDIFF(orders.ShippedDate, orders.RequiredDate) > 7 
AND orders.OrderDate BETWEEN '2023-08-01' AND '2023-08-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to user
show_to_user(result_df)","The input Python code correctly constructs the SQL query to count the number of orders that were shipped over a week late in August 2023. The SQL query checks for orders with a shipping delay of more than 7 days and with order dates between '2023-08-01' and '2023-08-31'. The code then executes the query using the 'execute_sql_query' function and displays the result using the 'show_to_user' function, complying with the provided utility functions and environment constraints.",both
Which employee achieved the highest sales in 2022? Use a bar chart to display employees and their respective sales figures.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT o.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY o.EmployeeID 
ORDER BY TotalSales DESC
""""""

# Execute SQL Query
sales_df = execute_sql_query(sql_query)

# Generate Bar Chart
fig = px.bar(sales_df, x='EmployeeID', y='TotalSales', title='Employee Sales in 2022', 
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales'}, 
             text='TotalSales')

# Show bar chart to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch total sales per employee for the year 2022
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN `[Order Details]` od ON o.OrderID = od.OrderID
JOIN employees e ON o.EmployeeID = e.EmployeeID
WHERE o.OrderDate >= '2022-01-01' AND o.OrderDate <= '2022-12-31'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
''' 

# Execute the SQL query and store the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Identify the employee with the highest sales
highest_sales_employee = sales_data.iloc[0]

# Create a bar chart for total sales by employee
fig = px.bar(sales_data, x='FirstName', y='TotalSales', title='Total Sales by Employee in 2022',
             labels={'FirstName': 'Employee', 'TotalSales': 'Sales Amount'},
             text='TotalSales')

# Show the plot to the user
show_to_user(fig)

# Return the employee who achieved the highest sales
highest_sales_employee","The provided code correctly implements the business analytics request. It fetches the total sales per employee for the year 2022, identifies the employee with the highest sales, and creates a bar chart of total sales by employee using Plotly. The logic of the SQL query and the way it creates the bar chart match the requirements. Additionally, it returns the employee who achieved the highest sales, which is an added feature.","import plotly.express as px
import pandas as pd

# SQL query to find total sales for each employee in 2022
sql_query = '''
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 1;'''

# Execute the SQL query and retrieve data
df_top_sales = execute_sql_query(sql_query)

# If you want to get all employees and their respective sales
sql_query_all = '''
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC;'''


# Execute the SQL query and retrieve data for all employees
df_all_sales = execute_sql_query(sql_query_all)

# Create a bar chart for all employees and their respective sales figures
fig = px.bar(df_all_sales, x='EmployeeID', y='TotalSales', title='Employee Sales in 2022', labels={'TotalSales':'Total Sales', 'EmployeeID':'Employee ID'})

# Show the chart to the user
show_to_user(fig)

# Additionally, display the top sales employee for verification
show_to_user(df_top_sales)","The provided Python code does implement the business analytic request, but it includes an unnecessary query that fetches only the top sales employee. The main task is to display a bar chart of all employees and their respective sales figures in 2022. The reference implementation does this correctly with a single query and doesn't query just the top sales employee. Removing the part that fetches only the top sales employee would make it congruent with the business requirement.",Base
What are the top 5 best-selling products? Present the data using a bar chart.,"import plotly.express as px

# Define the SQL query
df = execute_sql_query('SELECT p.ProductName, SUM(od.Quantity) AS TotalSales FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY p.ProductName ORDER BY TotalSales DESC LIMIT 5;')

# Create bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalSales', title='Top 5 Best-Selling Products', labels={'ProductName':'Product Name', 'TotalSales':'Total Sales'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the top 5 best-selling products
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 5;
'''

# Execute the SQL query
best_selling_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(best_selling_products_df, x='ProductName', y='TotalQuantity',
             title='Top 5 Best-Selling Products',
             labels={'TotalQuantity': 'Total Quantity Sold', 'ProductName': 'Product Name'})

# Show the chart to the user
show_to_user(fig)","The provided code correctly retrieves the top 5 best-selling products by executing a SQL query. It then uses Plotly to create a bar chart, which is displayed using the show_to_user function. The functionality and output closely match the reference implementation.","import plotly.express as px

# Function to get the top 5 best-selling products
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalQuantity DESC 
LIMIT 5;
""""""

# Execute the SQL query and retrieve the data
best_selling_products = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(best_selling_products, x='ProductName', y='TotalQuantity',
             title='Top 5 Best-Selling Products', labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity Sold'})

# Display the bar chart to the user
show_to_user(fig)","The input code correctly follows the specified Python environment constraints, executes the SQL query to get the top 5 best-selling products by summing their quantities, and uses Plotly to create a bar chart to visualize the data. The bar chart is then displayed using the show_to_user function. The functionality and output match the reference implementation.",both
Which products have a discount applied in more than 10 orders? Include a visualization to highlight these products.,"import pandas as pd
import plotly.express as px

# Define the SQL query to fetch data
sql_query = """"""
SELECT p.ProductName, COUNT(*) AS OrderCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0.0 
GROUP BY p.ProductName 
HAVING COUNT(*) > 10;  # Correct the HAVING clause
""""""

# Execute the query and retrieve the data
data = execute_sql_query(sql_query)

# Generate a bar chart visualization by using Plotly
fig = px.bar(data, x='ProductName', y='OrderCount', title='Products with Discount Applied in More Than 10 Orders', labels={'ProductName': 'Product Name', 'OrderCount': 'Order Count'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: SQL query to find products with discount applied in more than 10 orders
sql_query = '''
SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) AS DiscountedOrderCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
GROUP BY p.ProductID, p.ProductName
HAVING COUNT(od.OrderID) > 10
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Step 2: Visualizing the results
if not result_df.empty:
    fig = px.bar(result_df, x='ProductName', y='DiscountedOrderCount', title='Products with Discounts in More than 10 Orders')
    show_to_user(fig)
else:
    print('No products found with discounts applied in more than 10 orders.')",The provided code correctly implements the business logic to identify products with discounts in more than 10 orders. It executes an SQL query that appropriately selects and groups the products based on discount occurrences exceeding 10 and visualizes the result using Plotly. The code follows the given Python environment constraints by using `execute_sql_query` to fetch data and `show_to_user` to display the result.,"import pandas as pd
import plotly.express as px

# SQL query to fetch products with discount applied in more than 10 orders
sql_query = '''
SELECT ProductID, COUNT(*) AS DiscountedOrders
FROM [Order Details]
WHERE Discount > 0
GROUP BY ProductID
HAVING COUNT(*) > 10;
'''

# Execute the SQL query using the provided utility function
discounted_products_df = execute_sql_query(sql_query)

# Ensure the dataframe is sorted by the number of discounted orders
discounted_products_df = discounted_products_df.sort_values(by='DiscountedOrders', ascending=False)

# Generate a bar plot to visualize products with discounts in more than 10 orders
fig = px.bar(discounted_products_df, x='ProductID', y='DiscountedOrders', title='Products with Discount Applied in More than 10 Orders',
             labels={'ProductID': 'Product ID', 'DiscountedOrders': 'Number of Discounted Orders'})

# Show the visualization to the user
show_to_user(fig)","The input code is incorrect because it does not include the ProductName in the query result, which is essential for the visualization as stated in the business analytic request.",Base
What is the average order value for June 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query to get the average order value for June 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to calculate the Average Order Value for June 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
'''  

# Execute the query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly follows the given business analytic request and matches the logic of the reference implementation. It defines the SQL query to calculate the average order value for June 2023, executes the query using the provided execute_sql_query function, and displays the result using the show_to_user function. The SQL query, data retrieval, and display steps are consistent with the reference implementation.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
'''

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, plot the result using plotly
fig = px.bar(result_df, x=result_df.index, y='AverageOrderValue', title='Average Order Value for June 2023')
show_to_user(fig)
",The input Python code is correct. It successfully follows the Python environment constraints by using the provided utility functions `execute_sql_query` to execute the SQL query and `show_to_user` to display the result. It calculates the average order value for June 2023 and visualizes the result using plotly.,both
What is the average value of orders placed in January 2023?,"
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31' 
'''

# Execute the query and get the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
","from datetime import datetime

# Define the SQL query to calculate the average order value for January 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query to retrieve the data
average_order_value_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_order_value_df)","The input Python code correctly defines the SQL query to calculate the average order value for January 2023, executes the query using the execute_sql_query function, and displays the result using the show_to_user function. The code follows the Python environment constraints and matches the logic of the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to get the average order value for January 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS average_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Check if the result contains expected column
if 'average_order_value' in result_df.columns:
    # Display the result to the user
    show_to_user(result_df[['average_order_value']])  # Show the average order value
else:
    print(""Unexpected result: The column 'average_order_value' is not present in the data."")",The input Python code correctly implements the logic to calculate the average value of orders placed in January 2023. It executes the SQL query to retrieve the average order value and then checks if the result contains the expected column before displaying it. It properly uses the utility functions as per the environment constraints.,both
"List the customers along with their total spent amounts, ordered by highest to lowest total spent. Provide a sorted bar chart for better illustration.","import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent 
             FROM customers c 
             JOIN orders o ON c.CustomerID = o.CustomerID 
             JOIN [Order Details] od ON o.OrderID = od.OrderID 
             GROUP BY c.CustomerID 
             ORDER BY TotalSpent DESC;'''

# Execute the SQL query and get the dataframe
customer_spending_df = execute_sql_query(sql_query)

# Create and show the bar chart
fig = px.bar(customer_spending_df, x='CustomerID', y='TotalSpent', title='Total Spent by Customers',
             labels={'CustomerID':'Customer ID', 'TotalSpent':'Total Spent'},
             text='TotalSpent')
fig.update_layout(xaxis={'categoryorder':'total descending'}, yaxis_title='Total Spent', xaxis_title='Customer ID')

# Display the total spent values within the bars
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total spent amounts by customers
sql_query = '''
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalSpent DESC
'''

# Execute the SQL query and retrieve the data
customer_spending_df = execute_sql_query(sql_query)

# Prepare the bar chart
fig = px.bar(customer_spending_df, x='CompanyName', y='TotalSpent',
             title='Total Spent by Customers',
             labels={'TotalSpent': 'Total Spent', 'CompanyName': 'Customer Company'},
             color='TotalSpent',
             text='TotalSpent',
             template='plotly')

# Show the bar chart to the user
show_to_user(fig)","The input Python code adheres to the business analytic request by listing customers along with their total spent amounts, sorted from highest to lowest. It also generates a sorted bar chart using Plotly. The addition of 'CompanyName' to the query and chart adds more information, which can be beneficial. The code follows the provided Python environment constraints and is functionally equivalent to the reference implementation.","To fulfill the request, we will execute several steps.

1. **Retrieve Customer Spending Data**: First, we will run the SQL query to get the customers and their total spent amounts.

2. **Generate Sorted Bar Chart**: We will sort the data by total spent in descending order and create a bar chart using Plotly.

3. **Display the Chart**: Finally, we will use the `show` function to display the bar chart.

Here is the complete Python code to achieve this:

```python
import plotly.express as px
import pandas as pd

# 1. Execute SQL query to retrieve data
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSpent 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID 
ORDER BY TotalSpent DESC;
""""""
customer_data = execute_sql_query(sql_query)  # Assumes this function returns a pandas dataframe

# 2. Generate a sorted bar chart using Plotly for better illustration
fig = px.bar(customer_data, x='CustomerID', y='TotalSpent', title='Total Spent by Customers', labels={'CustomerID':'Customer ID', 'TotalSpent':'Total Spent Amount'}, text='TotalSpent')
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
fig.update_layout(xaxis_title='Customer ID', yaxis_title='Total Spent Amount', xaxis={'categoryorder':'total descending'})

# 3. Display the chart to the user
show(fig)  # Assumes this function can take the figure object directly
```

### Explanation of Code Components:

1. **SQL Query Execution**: 
   - The `execute_sql_query` function retrieves the data as a pandas DataFrame.
   - The SQL query provides the customer IDs along with their total spent amounts.

2. **Data Visualization**:
   - We use `plotly.express` to create a bar chart and annotate the bars with the total spent values.
   - The bar chart X-axis is formatted to ensure bars are sorted by the amount spent in descending order.

3. **Displaying the Result**:
   - Finally, we call `show(fig)` to present the bar chart to the user.","The input Python code correctly accomplishes the business analytic request by retrieving customer spending data, generating a sorted bar chart using Plotly, and displaying the chart using the appropriate utility function (`show`). The code adheres to the defined Python environment constraints, effectively matches the output of the reference implementation, and ensures the results are shown to the user.",both
What is the average order value for Q1 2023?,"import pandas as pd
import plotly.express as px

# SQL query to calculate the average order value for Q1 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Extracting avg_order_value from the dataframe
avg_order_value = result_df['avg_order_value'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'avg_order_value': [avg_order_value]}))
","import pandas as pd

# Define the SQL query to calculate the average order value for Q1 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'""""""

# Execute the SQL query and get the results in a pandas DataFrame
df_avg_order_value = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_avg_order_value)","The input Python code correctly calculates the average order value for Q1 2023 using an appropriate SQL query. It then executes this query using the provided 'execute_sql_query' function and displays the result using 'show_to_user', consistent with the Python environment constraints.","import pandas as pd
import plotly.express as px

# SQL query to retrieve necessary data
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the query and get results
df = execute_sql_query(sql_query)

# Extract the average order value
avg_order_value = df.iloc[0]['avg_order_value']

# Convert the result to a pandas dataframe for better visualization
result_df = pd.DataFrame({'avg_order_value': [avg_order_value]})

# Display the result to the user
show_to_user(result_df)
","The input Python code correctly follows the business analytic request and the given Python environment constraints. It forms the SQL query to calculate the average order value for Q1 2023, executes the query using the provided utility function, extracts the result and displays it utilizing the show_to_user function. The code also properly adheres to the basic logic and methodology of the reference implementation, making it accurate in delivering the expected outcome.",both
List orders where the shipping cost was above average.,"import pandas as pd
import plotly.express as px

# Execute the SQL query to get the orders where the shipping cost is above average
sql_query = '''
SELECT * FROM orders WHERE Freight > (SELECT AVG(Freight) FROM orders);
'''

# Fetch the data using the execute_sql_query function
orders_above_average_freight = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_above_average_freight)","import pandas as pd

# Step 1: Calculate the average shipping cost
avg_shipping_cost_query = 'SELECT AVG(Freight) as avg_freight FROM orders'
avg_shipping_cost_df = execute_sql_query(avg_shipping_cost_query)
avg_shipping_cost = avg_shipping_cost_df['avg_freight'][0]

# Step 2: List orders where the shipping cost was above average
above_average_orders_query = f'SELECT * FROM orders WHERE Freight > {avg_shipping_cost}'
above_average_orders_df = execute_sql_query(above_average_orders_query)

# Step 3: Show the results to the user
show_to_user(above_average_orders_df)",The input Python code correctly calculates the average shipping cost and uses it to fetch orders where the shipping cost is above the average. It then displays the results to the user. This matches the business request and the reference implementation.,"import pandas as pd

# Define SQL queries
avg_shipping_cost_query = 'SELECT AVG(Freight) AS AvgFreight FROM orders'
above_avg_shipping_cost_query = '''SELECT * FROM orders 
                                      WHERE Freight > (SELECT AVG(Freight) FROM orders)'''

# Execute the SQL queries
avg_shipping_cost_df = execute_sql_query(avg_shipping_cost_query)
orders_above_avg_shipping_cost_df = execute_sql_query(above_avg_shipping_cost_query)

# Since we need to ensure the avg_shipping_cost_query returns a single value, we can get that value directly
avg_freight = avg_shipping_cost_df['AvgFreight'].iloc[0]

# Display the data to the user
show_to_user(orders_above_avg_shipping_cost_df)
",The given input Python code correctly follows the business analytic request to list orders where the shipping cost was above average. It matches the reference implementation's logic of fetching and displaying the orders where Freight is greater than the average Freight.,both
What is the average freight cost for orders shipped to Europe?,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve data
sql_query = """"""
SELECT AVG(Freight) AS AverageFreightCost FROM orders WHERE ShipCountry IN ('Austria', 'Belgium', 'Denmark', 'Finland', 'France', 'Germany', 'Greece', 'Ireland', 'Italy', 'Netherlands', 'Norway', 'Poland', 'Portugal', 'Spain', 'Sweden', 'Switzerland', 'United Kingdom');
""""""

# Execute the SQL query and retrieve data
average_freight_df = execute_sql_query(sql_query)

# Since the result is a single value, we can print it or show it as dataframe
show_to_user(average_freight_df)","import pandas as pd

# SQL query to calculate the average freight cost for orders shipped to Europe
sql_query = """"""
SELECT AVG(Freight) AS average_freight_cost
FROM orders
WHERE ShipCountry IN ('Germany', 'France', 'Italy', 'Spain', 'United Kingdom', 'Netherlands', 'Belgium', 'Sweden', 'Austria', 'Switzerland', 'Norway', 'Denmark', 'Finland', 'Ireland', 'Poland', 'Portugal', 'Czech Republic', 'Hungary', 'Greece', 'Romania')
""""""

# Execute the SQL query and retrieve the results
average_freight_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(average_freight_df)","The input Python code correctly calculates the average freight cost for orders shipped to Europe by selecting the appropriate European countries in the SQL query. The SQL query is executed, and the result is displayed to the user, which meets the requirements of the specified business analytic request.","import pandas as pd

# SQL query to fetch the average freight cost for orders shipped to Europe
sql_query = ""SELECT AVG(Freight) AS AverageFreight FROM orders WHERE ShipRegion IN ('France', 'Germany', 'Italy', 'Spain', 'Netherlands', 'Poland', 'Belgium', 'United Kingdom', 'Sweden', 'Austria', 'Finland', 'Luxembourg', 'Denmark', 'Portugal', 'Ireland', 'Czech Republic', 'Greece', 'Hungary', 'Norway', 'Slovakia', 'Slovenia', 'Estonia', 'Lithuania', 'Latvia', 'Cyprus', 'Malta')""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the average freight cost to the user
show_to_user(df)","The input Python code is using 'ShipRegion' instead of 'ShipCountry' which may lead to incorrect results depending on the database schema. Additionally, the list of European countries in the SQL query is not consistent with the list in the reference implementation. Countries like 'Czech Republic', 'Hungary', 'Slovakia', 'Slovenia', 'Estonia', 'Lithuania', 'Latvia', 'Cyprus', and 'Malta' are included in the input code but absent in the reference code, and 'Switzerland' and 'Norway' are missing in the input code. The reference implementation's country list should be used to match the expected output better.",Base
"What is the average salary of employees by title, and can you visualize the distribution of salaries across different titles?","import plotly.express as px
import pandas as pd

# Execute the SQL query to get average salary by title
sql_query = 'SELECT Title, AVG(Salary) AS AvgSalary FROM employees GROUP BY Title;'
df_avg_salary = execute_sql_query(sql_query)

# Visualize the distribution of salaries across different titles
fig = px.bar(df_avg_salary, x='Title', y='AvgSalary', title='Average Salary by Title')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average salary by title
sql_query = '''
SELECT Title, AVG(Salary) as AverageSalary
FROM employees
GROUP BY Title
'''  

# Execute the SQL query and retrieve the data
average_salary_df = execute_sql_query(sql_query)

# Show the average salary to the user
show_to_user(average_salary_df)

# Visualize the distribution of salaries across different titles
# SQL query to get individual salaries by title for distribution visualization
sql_query_distribution = '''
SELECT Title, Salary
FROM employees
'''  

# Execute the SQL query for distribution
salary_distribution_df = execute_sql_query(sql_query_distribution)

# Create a box plot to visualize the distribution of salaries
fig = px.box(salary_distribution_df, x='Title', y='Salary', title='Salary Distribution by Title')

# Show the visualization to the user
show_to_user(fig)",The provided code correctly calculates the average salary by title and visualizes the salary distribution across different titles. It follows the same business logic as the reference implementation and adheres to the Python environment constraints by using the execute_sql_query and show_to_user functions.,"import plotly.express as px

# SQL query to get average salary by title
sql_query = '''
SELECT Title, AVG(Salary) AS AvgSalary 
FROM employees
GROUP BY Title;
'''

# Execute the SQL query and get the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Display the table with average salaries by title
show_to_user(df)

# Visualization of the distribution of salaries across different titles
fig = px.bar(df, x='Title', y='AvgSalary', title='Average Salary by Title', labels={'Title': 'Job Title', 'AvgSalary': 'Average Salary'})

# Display the plot
show_to_user(fig)","The input code correctly implements the requested business analytic task. It executes the SQL query to get the average salary by title, stores the results in a pandas DataFrame, visualizes the average salary by title using a bar plot with Plotly, and finally displays both the DataFrame and the plot using the show_to_user function. All required functionalities are addressed, and the code matches the general intent and output of the reference implementation.",both
What is the total number of orders for each product and can this be visualized to highlight the most and least ordered products?,"import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(od.OrderID) AS OrderCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query and retrieve data
products_order_count_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total number of orders for each product
fig = px.bar(
    products_order_count_df,
    x='ProductName',
    y='OrderCount',
    title='Total Number of Orders for Each Product',
    labels={'ProductName': 'Product Name', 'OrderCount': 'Order Count'},
    template='plotly_dark'
)

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to get total number of orders for each product
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrders
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalOrders DESC
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the dataframe to user
show_to_user(orders_df)

# Create a bar chart to visualize the total orders by product
fig = px.bar(orders_df, x='ProductName', y='TotalOrders', title='Total Orders for Each Product', labels={'TotalOrders': 'Number of Orders', 'ProductName': 'Product Name'})

# Show the figure to the user
show_to_user(fig)","The input Python code calculates 'SUM(od.Quantity)' instead of 'COUNT(od.OrderID)' for total orders, which does not match the business request for counting the number of orders. Additionally, 'TotalOrders' in the input code should be renamed to 'OrderCount' to align with the business requirement.","
import plotly.express as px

def fetch_and_visualize_data():
    # Define the SQL query
    sql_query = '''SELECT o.sku, COUNT(*) AS order_count FROM orders o GROUP BY o.sku'''
    
    # Execute the SQL query to retrieve data
    product_orders_df = execute_sql_query(sql_query)
    
    # Create a bar chart visualization with Plotly
    fig = px.bar(product_orders_df, x='sku', y='order_count', 
                 title='Total Number of Orders for Each Product',
                 labels={'sku': 'Product SKU', 'order_count': 'Order Count'})
    
    # Display the visualization to the user
    show_to_user(fig)

# Fetch and visualize the data
fetch_and_visualize_data()
","The provided code correctly executes an SQL query to determine the total number of orders for each product SKU. It then creates and displays a bar chart visualization of the data using Plotly, consistent with the business analytic request. The main difference between the input code and the reference implementation is the use of 'sku' instead of 'ProductName' and 'orders' instead of 'products' and 'Order Details,' which respecting different schemas and table structures is still valid. The overall logic and functionality remain correct and fulfills the given request.",Finetuned
List the top 5 products with the highest unit price.,"
import plotly.express as px

# Define the SQL query
top_products_query = """"""
SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;
""""""

# Execute the SQL query to retrieve data
top_products_df = execute_sql_query(top_products_query)

# Display the data to the user
show_to_user(top_products_df)

# Optionally, visualize the data using a plotly bar chart
fig = px.bar(top_products_df, x='ProductName', y='UnitPrice', title='Top 5 Products by Unit Price', labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price'})
show_to_user(fig)
","import pandas as pd

# SQL query to retrieve products sorted by unit price in descending order
sql_query = '''
SELECT ProductID, ProductName, UnitPrice
FROM products
ORDER BY UnitPrice DESC
LIMIT 5
'''  

# Execute the SQL query and retrieve the data
top_products_df = execute_sql_query(sql_query)

# Display the top 5 products to the user
show_to_user(top_products_df)",The input code does not include visualization using plotly as per the reference implementation. It correctly retrieves and displays the top 5 products by unit price but is missing the plotly bar chart visualization.,"
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductID, ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;'

# Execute the SQL query and retrieve the data
products_df = execute_sql_query(sql_query)

# Check if the dataframe has any data
if not products_df.empty:
    # Display the dataframe to the user
    show_to_user(products_df)
    
    # Create a bar chart visualization
    fig = px.bar(products_df, x='ProductName', y='UnitPrice', title='Top 5 Products with Highest Unit Price', labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price ($)'})
    
    # Display the plotly figure
    show_to_user(fig)
else:
    show_to_user(""No products found"")

","The input Python code accurately retrieves the top 5 products with the highest unit price and displays both the raw data and a bar chart using Plotly. The implementation closely matches the reference code in terms of functionality and output, adhering to the given Python environment constraints.",Finetuned
Calculate the total freight cost for each shipping company in 2023 and visualize the costs to compare between companies.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY shippers.CompanyName
'''

# Execute the SQL query
freight_data_df = execute_sql_query(sql_query)

# Generate the bar plot using plotly
fig = px.bar(freight_data_df, x='CompanyName', y='total_freight_cost', 
             title='Total Freight Cost by Shipping Company in 2023', 
             labels={'CompanyName': 'Shipping Company', 'total_freight_cost': 'Total Freight Cost'}, 
             text='total_freight_cost')

# Update layout to improve visualization
fig.update_layout(xaxis_title='Shipping Company', yaxis_title='Total Freight Cost')
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total freight cost for each shipping company in 2023
sql_query = '''
SELECT s.CompanyName, SUM(o.Freight) AS total_freight_cost
FROM orders o
JOIN shippers s ON o.ShipVia = s.ShipperID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY s.CompanyName
'''

# Execute the query and get the results in a DataFrame
freight_cost_df = execute_sql_query(sql_query)

# Visualize the total freight costs using Plotly
fig = px.bar(freight_cost_df, x='CompanyName', y='total_freight_cost',
             title='Total Freight Cost by Shipping Company in 2023',
             labels={'total_freight_cost': 'Total Freight Cost', 'CompanyName': 'Shipping Company'})

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly executes the SQL query to calculate the total freight cost for each shipping company in 2023, and it visualizes the results using Plotly. The implementation follows the Python environment constraints and will yield the correct output.","Certainly! Below is a step-by-step implementation of a Python code to achieve your request using Plotly for visualization.

1. **Retrieve the Data:** We need to execute the SQL query to retrieve the total freight cost for each shipping company in 2023.
2. **Data Processing:** Convert the shipped date to a suitable format if necessary.
3. **Visualization:** Create a bar chart to compare the freight costs between shipping companies using Plotly.

Hereâ€™s the complete code:

```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the total freight cost for each shipping company in 2023
sql_query = '''
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY shippers.CompanyName
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the filtering is correct (optional)
# df['OrderDate'] = pd.to_datetime(df['OrderDate'])

# Sort the DataFrame for better visualization
df = df.sort_values(by='total_freight', ascending=False)

# Visualize the data using Plotly
fig = px.bar(df, x='CompanyName', y='total_freight', title='Total Freight Cost for Each Shipping Company in 2023')

# Show the plot to the user
show_to_user(fig)
```

### Explanation of the Code:
1. **SQL Query:** The query fetches the company name and total freight cost for each shipping company within the specified date range of the year 2023.
2. **Data Retrieval:** The `execute_sql_query` function is called with the SQL query to get the required data in a pandas DataFrame.
3. **Data Sorting:** The DataFrame is sorted in descending order based on total freight cost to prioritize visualization clarity.
4. **Data Visualization:** A bar chart is created using Plotly for a clearer comparison of costs between companies.
5. **Display Result:** The `show_to_user` function is invoked to present the chart to the user.

This code will effectively meet your request to calculate and visualize the total freight costs for each shipping company in 2023.","The provided code implementation correctly retrieves the total freight cost for each shipping company in 2023 and visualizes it using a Plotly bar chart. It follows the given constraints, uses the `execute_sql_query` function to get the data, and then visualizes it with `show_to_user`. The only minor difference is in sorting the DataFrame before plotting, which is acceptable.",both
What is the percentage of orders that were shipped within 3 days of being placed?,"import pandas as pd
import plotly.express as px

# Define the SQL query to get the count of orders shipped within 3 days and the total count of orders
datediff_query = '''
SELECT 
    COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 3 THEN 1 END) AS ShippedWithinThreeDays,
    COUNT(*) AS TotalOrders
FROM orders;
'''

# Execute the SQL query and retrieve the results into a dataframe
df = execute_sql_query(datediff_query)

# Calculate the percentage of orders shipped within 3 days
percentage_within_three_days = (df['ShippedWithinThreeDays'][0] / df['TotalOrders'][0]) * 100

# Create a dataframe to hold the result
result_df = pd.DataFrame({'Metric': ['Orders Shipped Within 3 Days'], 'Percentage': [percentage_within_three_days]})

# Create a bar plot to visualize the percentage
fig = px.bar(result_df, x='Metric', y='Percentage', title='Percentage of Orders Shipped Within 3 Days')

# Display the result to the user
show_to_user(fig)
","import pandas as pd

# SQL query to calculate the percentage of orders shipped within 3 days
sql_query = """"""
SELECT 
    COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 3 THEN 1 END) AS ShippedWithin3Days,
    COUNT(OrderID) AS TotalOrders
FROM
    orders
""""""

# Execute the SQL query and retrieve the results
results = execute_sql_query(sql_query)

# Calculate the percentage
if results['TotalOrders'][0] > 0:
    percentage_shipped_within_3_days = (results['ShippedWithin3Days'][0] / results['TotalOrders'][0]) * 100
else:
    percentage_shipped_within_3_days = 0

# Create a DataFrame for the output
output_df = pd.DataFrame({
    'Percentage of Orders Shipped Within 3 Days': [percentage_shipped_within_3_days]
})

# Show the result to the user
show_to_user(output_df)","The input Python code correctly calculates the percentage of orders shipped within 3 days of being placed. It uses the execute_sql_query function to fetch data, correctly handles division-by-zero cases, and displays the result using the show_to_user function as per the constraints.","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the required data
sql_query = 'SELECT OrderDate, ShippedDate FROM orders;'

# Execute the SQL query and get the result in a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Convert OrderDate and ShippedDate to datetime
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])
orders_df['ShippedDate'] = pd.to_datetime(orders_df['ShippedDate'])

# Calculate the difference in days
orders_df['DifferenceInDays'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days

# Calculate the percentage of orders shipped within 3 days
percentage_within_3_days = (orders_df[orders_df['DifferenceInDays'] <= 3].shape[0] / orders_df.shape[0]) * 100

# Create a dataframe to visualize the result
percentage_df = pd.DataFrame({'PercentageWithin3Days': [percentage_within_3_days]})

# Show the result to the user
show_to_user(percentage_df)","The provided code implementation accurately retrieves the necessary data, processes it to find the difference in days between OrderDate and ShippedDate, and computes the percentage of orders shipped within three days. Additionally, it displays the result using the given utility function. Though it uses a different approach compared to the reference code, it produces the correct output.",both
Which products have been ordered with a discount?,"import pandas as pd
import plotly.express as px

# SQL query to find products that have been ordered with a discount
sql_query = '''
SELECT DISTINCT p.ProductName 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0;
'''

# Execute the SQL query to get the data
product_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(product_df)
","import pandas as pd

# SQL query to find products that have been ordered with a discount
sql_query = '''
SELECT DISTINCT p.ProductID, p.ProductName, od.Discount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
'''  

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)",The input Python code is incorrect because it retrieves additional columns (ProductID and Discount) that are not required by the business analytic request. The request specifically asks for the product names of those that have been ordered with a discount.,"import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to find products that have been ordered with a discount.
sql_query = """"""
SELECT DISTINCT [Order Details].ProductID 
FROM [Order Details] 
WHERE Discount > 0;
""""""

# Step 2: Execute the SQL query using the provided utility function execute_sql_query.
result_df = execute_sql_query(sql_query)

# Step 3: Display the results to the user using the provided utility function show_to_user.
show_to_user(result_df)","The input code identifies products ordered with a discount but only retrieves the ProductID instead of ProductName. To match the business analytic request and the reference code, the query should join the products table to get the ProductName.",None
"What is the total number of orders shipped via each shipping method per month, and can you illustrate the monthly trends with a visualization?","
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, ShipVia, COUNT(OrderID) AS OrdersShipped
FROM orders
GROUP BY Month, ShipVia;
""""""

# Execute the SQL query and get the data in a pandas dataframe
data = execute_sql_query(sql_query)

# Create a line plot to illustrate monthly trends of orders shipped via each shipping method
fig = px.line(data, x='Month', y='OrdersShipped', color='ShipVia', title='Monthly Trends of Orders Shipped via Each Shipping Method')

# Show the visualization to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL Query to get total orders shipped via each shipping method per month
sql_query = '''
SELECT
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    ShipVia,
    COUNT(OrderID) AS TotalOrders
FROM
    orders
WHERE
    ShippedDate IS NOT NULL
GROUP BY
    Month, ShipVia
ORDER BY
    Month;
'''  

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Visualize the results using Plotly
fig = px.line(orders_data,
              x='Month',
              y='TotalOrders',
              color='ShipVia',
              title='Total Orders Shipped per Shipping Method per Month',
              labels={'TotalOrders': 'Total Orders', 'Month': 'Month'})

# Display the visualization to the user
show_to_user(fig)","The provided Python code follows the required business analytic request and matches the functional requirements of the reference implementation. It correctly retrieves the total number of orders shipped via each shipping method per month from the database, and it visualizes the monthly trends using a line plot created with Plotly. The minor differences in variable names and additional sorting do not affect its correctness and are acceptable variations.","
import plotly.express as px

# SQL Query to fetch the data
sql_query = '''
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
    ShipVia, 
    COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY OrderMonth, ShipVia;
'''

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Ensure OrderMonth is treated as a datetime object
orders_df['OrderMonth'] = pd.to_datetime(orders_df['OrderMonth'], format='%Y-%m')

# Create a line plot to illustrate the monthly trends
fig = px.line(orders_df, x='OrderMonth', y='OrderCount', color='ShipVia',
              title='Monthly Trends of Orders Shipped via Each Shipping Method',
              labels={
                  'OrderMonth': 'Month',
                  'OrderCount': 'Number of Orders',
                  'ShipVia': 'Shipping Method'
              })

# Display the plot to the user
show_to_user(fig)
","The given input Python code fulfills the business analytic request to retrieve and visualize the total number of orders shipped via each shipping method per month. It uses the same logic and functions as the reference implementation: executing the SQL query to get the data in a dataframe, converting the date format, and creating a line plot using Plotly, with appropriate labeling and title. The extra step of ensuring 'OrderMonth' is treated as a datetime object improves data handling for visualization.",both
Find the total number of products supplied by each supplier and visualize it to show which suppliers contribute the most products.,"import plotly.express as px

# Execute the SQL query
sql_query = 'SELECT SupplierID, COUNT(ProductID) AS TotalProducts FROM products GROUP BY SupplierID;'
dataframe = execute_sql_query(sql_query)

# Create a bar chart to visualize the data
fig = px.bar(dataframe, x='SupplierID', y='TotalProducts', title='Total Products Supplied by Each Supplier')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to find the total number of products supplied by each supplier
sql_query = '''
SELECT suppliers.CompanyName, COUNT(products.ProductID) AS TotalProducts
FROM suppliers
LEFT JOIN products ON suppliers.SupplierID = products.SupplierID
GROUP BY suppliers.CompanyName
ORDER BY TotalProducts DESC;
'''  

# Execute SQL query and retrieve data
supplier_product_counts = execute_sql_query(sql_query)

# Visualize the results using Plotly
fig = px.bar(supplier_product_counts, x='CompanyName', y='TotalProducts',
             title='Total Number of Products Supplied by Each Supplier',
             labels={'TotalProducts': 'Total Products', 'CompanyName': 'Supplier Name'},
             text='TotalProducts')

# Show the plot to the user
show_to_user(fig)","The provided input Python code correctly retrieves the total number of products supplied by each supplier by executing an SQL query, and visualizes the data using a Plotly bar chart. It adheres to the Python environment constraints and fulfills the business analytic request as per the specified requirements.","import pandas as pd
import plotly.express as px

# SQL query to fetch the total number of products supplied by each supplier
sql_query = 'SELECT SupplierID, COUNT(ProductID) AS NumProducts FROM products GROUP BY SupplierID;'

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Ensure the dataframe is sorted by NumProducts in descending order
supplier_data = supplier_data.sort_values(by='NumProducts', ascending=False)

# Create a bar chart to visualize the number of products supplied by each supplier
fig = px.bar(supplier_data, x='SupplierID', y='NumProducts', title='Total Number of Products Supplied by Each Supplier')

# Update layout for better readability
fig.update_layout(xaxis_title='Supplier ID', yaxis_title='Number of Products Supplied')
fig.update_xaxes(type='category')  # Ensure x-axis represents categories correctly

# Display the figure to the user
show_to_user(fig)
","The input code provided correctly fetches the total number of products supplied by each supplier using the SQL query and 'execute_sql_query' function. It then sorts the DataFrame by the number of products and uses Plotly to create and display a bar chart visualizing the data. The modifications to the chart layout ensure better readability. Overall, the functionality and output align with the business analytic request and the reference implementation.",both
Which products need to be reordered?,"import pandas as pd
import plotly.express as px

# SQL query to retrieve products that need to be reordered
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query using the provided utility function
products_to_reorder_df = execute_sql_query(sql_query)

# Display the products that need to be reordered to the user
df_display = products_to_reorder_df
show_to_user(df_display)","import pandas as pd

# Define the SQL query to find products that need to be reordered
sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0
'''

# Execute the SQL query and retrieve the data into a dataframe
reorder_products_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(reorder_products_df)","The input code correctly retrieves products that need to be reordered by querying products with UnitsInStock less than or equal to ReorderLevel and not discontinued. The results are then displayed to the user, which meets the requirements of the business analytic request.","import pandas as pd
import plotly.express as px

# SQL query to find products that need to be reordered
sql_query = 'SELECT products.ProductName FROM products WHERE products.UnitsInStock < products.ReorderLevel;' 

# Execute the SQL query
products_below_reorder_level = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_below_reorder_level)","The input Python code correctly implements the logic to determine which products need to be reordered. The SQL query selects products where UnitsInStock is less than ReorderLevel, which will capture products that need replenishing. The essential operations to execute the SQL query and display the result to the user align with the reference implementation and the constraints provided.",both
Which products have the highest total sales volume in quantity and can you visualize the distribution to highlight the top sellers?,"import plotly.express as px
import pandas as pd

# SQL Query to fetch required data
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalSalesQuantity DESC;
'''

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Display the retrieved data (if needed to show tabular data to user)
show_to_user(sales_data)

# Visualization of the distribution to highlight the top sellers
fig = px.bar(sales_data, x='ProductName', y='TotalSalesQuantity', title='Top Selling Products by Quantity', labels={'ProductName': 'Product Name', 'TotalSalesQuantity': 'Total Sales Quantity'})

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL Query to get total sales volume for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSalesVolume
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSalesVolume DESC
'''

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Visualize the distribution of total sales volume to highlight the top sellers
fig = px.bar(sales_data, x='ProductName', y='TotalSalesVolume', title='Total Sales Volume by Product',
             labels={'TotalSalesVolume': 'Sales Volume', 'ProductName': 'Product Name'},
             color='TotalSalesVolume', color_continuous_scale=px.colors.sequential.Viridis)

# Show the figure to the user
show_to_user(fig)","The input code accurately retrieves the total sales volume for each product and visualizes the distribution using a bar chart, clearly highlighting the top sellers. It follows the Python environment constraints and achieves the same analytic goal as the reference implementation, although the code and visualization styles are slightly different.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductID, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN products p ON p.ProductID = od.ProductID 
GROUP BY p.ProductID 
ORDER BY TotalQuantity DESC;
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Ensure the DataFrame columns are correctly accessed
# Assuming execute_sql_query returns a pandas DataFrame with columns ProductID and TotalQuantity

# Plot the distribution of total sales volume in quantity
fig = px.bar(sales_data, x='ProductID', y='TotalQuantity', title='Total Sales Volume per Product', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity Sold'})

# Show the plot to the user
show_to_user(fig)","The input code evaluates the 'ProductID' instead of 'ProductName', which does not directly convey the product names. The business request specifically asks for the highest total sales volume in quantity for products, which is better understood when 'ProductName' is used. The input code should retrieve 'ProductName' and not 'ProductID'.",Base
"How many orders were placed and fulfilled in each month of 2023, and can you illustrate the monthly trends with a visualization?","import plotly.express as px
import pandas as pd

# SQL Query from the business analytic request
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       COUNT(orders.OrderID) AS orders_placed, 
       COUNT(CASE WHEN orders.ShippedDate IS NOT NULL THEN 1 END) AS orders_fulfilled 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month 
ORDER BY month
'''

# Execute the SQL query and retrieve data in a pandas dataframe
df = execute_sql_query(sql_query)

# Verify the dataframe content
print(df.head())

# Correct the column names to match the query output
df.columns = ['month', 'orders_placed', 'orders_fulfilled']

# Create a line plot to show monthly trends for orders placed and fulfilled
fig = px.line(df, x='month', y=['orders_placed', 'orders_fulfilled'], 
              labels={'value': 'Count', 'variable': 'Order Status'}, 
              title='Monthly Trends for Orders Placed and Fulfilled in 2023')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the number of orders placed and fulfilled each month in 2023
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
    COUNT(OrderID) AS total_orders, 
    COUNT(CASE WHEN ShippedDate IS NOT NULL THEN 1 END) AS fulfilled_orders 
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY 
    month 
ORDER BY 
    month
""""""

# Execute the SQL query to get the data
order_data = execute_sql_query(sql_query)

# Visualizing the trends in a line plot
fig = px.line(order_data, x='month', y=['total_orders', 'fulfilled_orders'], 
              labels={'value': 'Number of Orders', 'month': 'Month', 'variable': 'Order Status'}, 
              title='Monthly Orders Placed and Fulfilled in 2023')

# Show the visualization to the user
show_to_user(fig)","The input code correctly follows the specifications provided. It uses an appropriate SQL query to retrieve the number of orders placed and fulfilled each month in 2023 and uses Plotly to visualize the results. The column names 'total_orders' and 'fulfilled_orders' in the query output correspond to 'orders_placed' and 'orders_fulfilled' in the reference code, which does not affect the correctness. The visualization parameters and structure also match the requirements and are correctly displayed using the show_to_user function.","
import plotly.express as px

# SQL Query
sql_query = """"""SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, COUNT(OrderID) AS orders_count FROM orders WHERE YEAR(OrderDate) = 2023 GROUP BY month ORDER BY month;""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Generate the plot
fig = px.line(orders_df, x='month', y='orders_count', title='Monthly Orders Count for 2023', labels={'month': 'Month', 'orders_count': 'Number of Orders'})

# Show the plot to the user
show_to_user(fig)
","The provided code does not count the 'orders_fulfilled' which is a crucial part of the business analytic request. It only counts the 'orders_placed'. Furthermore, the SQL query in the provided code does not filter based on the 'ShippedDate' to determine orders that were fulfilled.",Base
What was the total sales revenue generated in the year 2023?,"
import pandas as pd

# SQL query to get total sales revenue for the year 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Extract the total sales value
if not sales_data.empty:
    total_sales = sales_data['total_sales'][0]
else:
    total_sales = 0

# Create a DataFrame to display the result
df_total_sales = pd.DataFrame({'Year': [2023], 'Total Sales Revenue': [total_sales]})

# Display the total sales revenue to the user
show_to_user(df_total_sales)
","sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'""""""
total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)","The provided implementation does not correctly extract the total sales value for 2023 from the result of the SQL query. It directly uses the output of the `execute_sql_query` function without checking if the result is empty or extracting the specific 'total_sales' value. Additionally, it lacks the creation of a DataFrame to properly display the result in a user-friendly format like the reference implementation does.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the total sales revenue for the year 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE YEAR(orders.OrderDate) = 2023;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty or null
if not df.empty:
    # Extract the total sales value
    total_sales = df['total_sales'].iloc[0]
    total_sales_df = pd.DataFrame({'Total Sales Revenue in 2023': [total_sales]})
else:
    total_sales_df = pd.DataFrame({'Total Sales Revenue in 2023': [0]})

# Display the result to the user
show_to_user(total_sales_df)","The provided code correctly executes the SQL query to calculate the total sales revenue for the year 2023, checks for an empty DataFrame, and displays the result using the show_to_user function. It adheres to the Python environment constraints and meets the business analytic request.",Finetuned
Which supplier supplies the highest number of different products?,"import pandas as pd
import plotly.express as px

# Define the SQL query to find the supplier with the highest number of different products
sql_query = '''
SELECT SupplierID, COUNT(DISTINCT ProductID) AS ProductCount 
FROM products 
GROUP BY SupplierID 
ORDER BY ProductCount DESC 
LIMIT 1;
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Query to count the number of different products supplied by each supplier
sql_query = '''
SELECT suppliers.SupplierID, suppliers.CompanyName, COUNT(DISTINCT products.ProductID) AS ProductCount
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY ProductCount DESC
LIMIT 1
'''

# Execute the SQL query and retrieve the result
result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result)","The provided input Python code correctly executes a SQL query to find the supplier who supplies the highest number of different products. It returns a similar result to the reference implementation, retrieving the supplier's ID, name, and count of distinct products supplied. The query is executed correctly, the result is returned as a pandas DataFrame, and the result is displayed to the user using the show_to_user function.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''SELECT s.SupplierID, COUNT(DISTINCT p.ProductID) AS ProductCount 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID 
ORDER BY ProductCount DESC 
LIMIT 1;'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly defines and executes an SQL query that joins the suppliers and products tables, counts the number of distinct products per supplier, and retrieves the supplier with the highest count. The output is displayed using the provided show_to_user function. The query logic and final result in the input code are consistent with the reference implementation, ensuring the business analytic request is met.",both
What is the average shipping cost per order for 2023?,"
import pandas as pd
import plotly.express as px

# Given utility functions
# def execute_sql_query(sql_query: str) -> pd.DataFrame:
#     # Function to execute an SQL query and return a pandas DataFrame
#     pass

# def show_to_user(data):
#     # Function to display data analysis and visualization results
#     pass

# Define the SQL query
sql_query = '''
SELECT AVG(orders.Freight) AS shipping_cost_per_order
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query and retrieve the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","import pandas as pd

# SQL query to calculate the average shipping cost per order for the year 2023
sql_query = """"""
SELECT AVG(orders.Freight) AS average_shipping_cost_per_order 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
average_shipping_cost_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_shipping_cost_df)","The given Python code follows the specified Python environment constraints and the business analytic request. It correctly calculates the average shipping cost per order for the year 2023 by executing an appropriate SQL query and displays the result using the show_to_user function. The code aligns with the reference implementation, even though the variable names are slightly different.","import pandas as pd

# Define the SQL query to get the average shipping cost per order for 2023
sql_query = """"""
SELECT AVG(Freight) AS average_shipping_cost 
FROM orders 
WHERE YEAR(OrderDate) = 2023;
""""""

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The input Python code correctly implements the business analytic request to calculate the average shipping cost per order for 2023. It uses the correct SQL query to select the average freight cost for orders placed in 2023 and appropriately uses the provided utility functions 'execute_sql_query' to run the query and 'show_to_user' to display the result.,both
What is the total value of orders shipped in the first quarter of 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
    SELECT QUARTER(o.OrderDate) AS OrderQuarter, 
           SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue 
    FROM orders o 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    WHERE YEAR(o.OrderDate) = 2023 
    GROUP BY OrderQuarter;
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Filter to only include the first quarter
result_df = result_df[result_df['OrderQuarter'] == 1]

# Display the results to the user
show_to_user(result_df)

# Optionally, visualize the total value by quarter
fig = px.bar(result_df, x='OrderQuarter', y='TotalValue', title='Total Value of Orders Shipped in First Quarter of 2023')
show_to_user(fig)
","import pandas as pd

# Define the SQL query to calculate the total value of orders shipped in the first quarter of 2023
sql_query = '''
SELECT SUM(ol.UnitPrice * ol.Quantity * (1 - ol.Discount)) AS TotalValue
FROM `orders` o
JOIN `[Order Details]` ol ON o.OrderID = ol.OrderID
WHERE o.ShippedDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the SQL query and retrieve the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The input code correctly sums the total value of orders shipped in the first quarter of 2023 using an appropriate SQL query and shows the result. It aligns with the requested business analytic and follows the given environment constraints.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query to get the total value of orders shipped in the first quarter of 2023
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue
FROM orders o
JOIN `Order Details` od ON o.OrderID = od.OrderID
WHERE o.ShippedDate BETWEEN '2023-01-01' AND '2023-03-31';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total order value from the result
total_order_value = result_df['TotalOrderValue'].iloc[0]

# Create a DataFrame to display the total order value
total_order_value_df = pd.DataFrame({'TotalOrderValue': [total_order_value]})

# Display the result to the user
show_to_user(total_order_value_df)

# Optionally, visualize the total order value
fig = px.bar(total_order_value_df, y='TotalOrderValue', title='Total Order Value for Q1 2023', labels={'TotalOrderValue':'Value ($)'})
show_to_user(fig)","The input code and reference code are addressing slightly different queries. The reference code calculates the total order value specifically for each quarter and then filters to the first quarter, while the input code directly filters orders by shipping date for the first quarter. Additionally, the reference code utilizes the 'OrderDate' for the year filter while the input code uses 'ShippedDate', which could lead to different results. Moreover, the input code does not group by quarters which is necessary according to business request.",Base
What is the Customer Retention Rate for the last 6 months?,"import pandas as pd

# SQL query to get the number of distinct customers in the last 6 months
customers_last_6_months_query = '''
SELECT COUNT(DISTINCT orders.CustomerID) AS CustomerCount 
FROM orders 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 6 MONTH) AND CURDATE()'''

# SQL query to get the number of distinct customers before the last 6 months
customers_before_6_months_query = '''
SELECT COUNT(DISTINCT orders.CustomerID) AS CustomerCount 
FROM orders 
WHERE orders.OrderDate < DATE_SUB(CURDATE(), INTERVAL 6 MONTH)'''

# Execute the SQL queries
last_6_months_df = execute_sql_query(customers_last_6_months_query)
before_6_months_df = execute_sql_query(customers_before_6_months_query)

# Extract the customer counts
customer_count_last_6_months = last_6_months_df.iloc[0]['CustomerCount']
customer_count_before_6_months = before_6_months_df.iloc[0]['CustomerCount']

# Calculate the Customer Retention Rate
if customer_count_before_6_months != 0:
    customer_retention_rate = customer_count_last_6_months / customer_count_before_6_months
else:
    customer_retention_rate = 0  # To handle division by zero

# Create a DataFrame to show the result
result_df = pd.DataFrame({'CustomerRetentionRate': [customer_retention_rate]})

# Display the result
show_to_user(result_df)","import pandas as pd

# Define the date range for the last 6 months
end_date = pd.to_datetime('today').normalize()
start_date = end_date - pd.DateOffset(months=6)

# SQL query to calculate Customer Retention Rate
sql_query = f""""""
SELECT 
    (SELECT COUNT(DISTINCT CustomerID) 
     FROM orders 
     WHERE OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}') / 
    (SELECT COUNT(DISTINCT CustomerID) 
     FROM orders 
     WHERE OrderDate < '{start_date.date()}') AS Customer_Retention_Rate
""""""

# Execute the SQL query
retention_rate_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(retention_rate_df)",The provided implementation calculates the Customer Retention Rate correctly using a single SQL query and the Python utility functions as per the given environment constraints. The logic to calculate the Customer Retention Rate and the SQL structure are appropriate and will yield the correct result.,"import pandas as pd
import plotly.express as px

# SQL Query to get the number of unique customers who have ordered in the last 6 months
query_last_6_months = '''
SELECT COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH);
'''

# Execute the query to get the number of unique customers in the last 6 months
customers_last_6_months_df = execute_sql_query(query_last_6_months)
customers_last_6_months = customers_last_6_months_df['UniqueCustomers'].iloc[0]

# SQL Query to get the number of unique customers who ordered before the last 6 months
query_before_6_months = '''
SELECT COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM orders
WHERE OrderDate < DATE_SUB(CURDATE(), INTERVAL 6 MONTH);
'''

# Execute the query to get the number of unique customers before the last 6 months
customers_before_6_months_df = execute_sql_query(query_before_6_months)
customers_before_6_months = customers_before_6_months_df['UniqueCustomers'].iloc[0]

# Calculate the customer retention rate
if customers_before_6_months > 0:  # Ensure we don't divide by zero
    customer_retention_rate = (customers_last_6_months / customers_before_6_months) * 100
else:
    customer_retention_rate = 0

# Create a DataFrame to display the result
retention_df = pd.DataFrame({'CustomerRetentionRate': [customer_retention_rate]})

# Show the result to the user
show_to_user(retention_df)","The provided code correctly implements the logic to calculate the Customer Retention Rate for the last 6 months. It executes the necessary SQL queries, calculates the retention rate, and displays it using the provided 'show_to_user' utility function. The main difference from the reference code is the additional step of multiplying the retention rate by 100 to express it as a percentage, which is a sensible and often-used practice.",both
What is the most common job title among the employees?,"import pandas as pd
import plotly.express as px

# SQL query to find the most common job title among employees
sql_query = '''
SELECT Title, COUNT(*) AS TitleCount 
FROM employees 
GROUP BY Title 
ORDER BY TitleCount DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to select the most common job title
sql_query = '''
SELECT Title, COUNT(*) as Count
FROM employees
GROUP BY Title
ORDER BY Count DESC
LIMIT 1
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to user
show_to_user(result_df)","The provided Python code correctly implements the business analytic request. It uses an SQL query to find the most common job title among employees by selecting, counting, grouping, ordering, and limiting the results to the top entry, which matches the reference implementation. The result is then displayed using the show_to_user function. The code adheres to the Python environment constraints and achieves the requested analytical outcome.","import pandas as pd
import plotly.express as px

# SQL query to get the most common job title
sql_query = ""SELECT JobTitle, COUNT(*) AS JobCount FROM employees GROUP BY JobTitle ORDER BY JobCount DESC LIMIT 1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly follows the business analytic request and Python environment constraints. It executes an SQL query to find the most common job title and displays the result to the user. The SQL query effectively selects the job title with the highest count, and the use of execute_sql_query and show_to_user functions is consistent with the requirements.",both
Find the difference in days between the hire date and the birthdate of employees.,"import pandas as pd
import plotly.express as px

# SQL query to fetch EmployeeID, HireDate, and BirthDate
sql_query = ""SELECT EmployeeID, HireDate, BirthDate FROM employees;""

dataframe = execute_sql_query(sql_query)

# Calculating the difference in days between HireDate and BirthDate
# First, convert the columns to datetime
if not pd.api.types.is_datetime64_any_dtype(dataframe['HireDate']):
    dataframe['HireDate'] = pd.to_datetime(dataframe['HireDate'])

if not pd.api.types.is_datetime64_any_dtype(dataframe['BirthDate']):
    dataframe['BirthDate'] = pd.to_datetime(dataframe['BirthDate'])

# Calculate the difference in days
dataframe['DaysDifference'] = (dataframe['HireDate'] - dataframe['BirthDate']).dt.days

# Select only EmployeeID and DaysDifference for the final result
result_df = dataframe[['EmployeeID', 'DaysDifference']]

# Display the result to the user
show_to_user(result_df)","import pandas as pd
from datetime import datetime

# SQL query to retrieve necessary data from employees table
sql_query = """"""
SELECT EmployeeID, BirthDate, HireDate
FROM employees
""""""

# Execute SQL query and get the data in a pandas DataFrame
employees_df = execute_sql_query(sql_query)

# Calculate the difference in days between HireDate and BirthDate
employees_df['BirthDate'] = pd.to_datetime(employees_df['BirthDate'])
employees_df['HireDate'] = pd.to_datetime(employees_df['HireDate'])

# Create a new column for the difference in days
employees_df['DifferenceInDays'] = (employees_df['HireDate'] - employees_df['BirthDate']).dt.days

# Show the resulting DataFrame to the user
show_to_user(employees_df[['EmployeeID', 'DifferenceInDays']])","The input code correctly follows the necessary steps of the business analytic request: executing the SQL query, converting the data to datetime format, calculating the difference in days between HireDate and BirthDate, and displaying the result to the user. The code also adheres to the given Python environment constraints.","
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, DATEDIFF(e.HireDate, e.BirthDate) AS AgeDiffInDays
FROM employees e;
'''

# Execute the query using the provided utility function
employee_data = execute_sql_query(sql_query)

# Display the results using the show_to_user utility function
show_to_user(employee_data)
","The input code directly uses the SQL function DATEDIFF to calculate the difference in days between HireDate and BirthDate. This approach is different from the reference implementation which calculates the difference within the Python environment using pandas after converting date columns to datetime format. Additionally, the input code does not handle transformations or checks for datetime formats explicitly.",Base
How many products are discontinued?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(*) AS discontinued_products FROM products WHERE products.Discontinued = 1'

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to count the number of discontinued products
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE Discontinued = 1""  

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)  

# Display the result to the user
show_to_user(result_df)","The provided Python code correctly uses the SQL query to count the number of discontinued products, stores the result in a DataFrame, and displays the result to the user using the designated functions. The query logic and structure are consistent with the reference implementation.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(*) AS DiscontinuedCount FROM products WHERE Discontinued = 1;'

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code is correct as it follows the Python environment constraints, correctly counts the number of discontinued products, and the output is displayed to the user similarly to the reference implementation.",both
List all orders that took more than 10 days to fulfill in 2021.,"import pandas as pd
import plotly.express as px

# SQL query to get orders from 2021 that took more than 10 days to fulfill
sql_query = '''
SELECT OrderID 
FROM orders 
WHERE YEAR(OrderDate) = 2021 
AND DATEDIFF(ShippedDate, OrderDate) > 10;
'''

# Execute the SQL query
order_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_df)","import pandas as pd

# SQL query to retrieve orders that took more than 10 days to fulfill in 2021
sql_query = """"""
SELECT OrderID, OrderDate, ShippedDate, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE DATEDIFF(ShippedDate, OrderDate) > 10
AND YEAR(OrderDate) = 2021
""""""

# Execute the SQL query and store the result in a DataFrame
orders_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_data)","The input Python code retrieves orders from 2021 that took more than 10 days to fulfill, correctly matching the business analytic request. The SQL query is correctly structured to retrieve these orders, and the data is displayed to the user.","import pandas as pd

# Define the SQL query to fetch the required data
sql_query = """"""
SELECT * FROM orders 
WHERE DATE_PART('day', ShippedDate::timestamp - OrderDate::timestamp) > 10 
AND DATE_PART('year', OrderDate::timestamp) = 2021
""""""

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)","The input code has a discrepancy in how it fetches data and the columns retrieved. The input code selects all columns with 'SELECT *' while the reference code only selects 'OrderID' with 'SELECT OrderID'. Additionally, the SQL syntax used in the input code is slightly different (DATE_PART) compared to the reference implementation's DATEDIFF.",Base
What was the total sales revenue generated each month in the year 2022? Please include a line chart or bar graph to visualize the monthly sales revenue.,"
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales revenue generated each month in the year 2022
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(OrderDate) = 2022 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query using the provided utility function
sales_data_df = execute_sql_query(sql_query)

# Generate a bar graph to visualize the monthly sales revenue
fig = px.bar(sales_data_df, x='Month', y='TotalSales', title='Monthly Sales Revenue for 2022', labels={'Month': 'Month', 'TotalSales': 'Total Sales Revenue'})

# Display the figure to the user using the provided utility function
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue each month in the year 2022
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    YEAR(orders.OrderDate) = 2022 
GROUP BY 
    Month 
ORDER BY 
    Month; 
""""""

# Execute the SQL query and store the result in a DataFrame
monthly_sales_df = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly sales revenue
fig = px.line(monthly_sales_df, x='Month', y='Total_Sales', title='Total Sales Revenue per Month in 2022', labels={'Total_Sales': 'Total Sales Revenue', 'Month': 'Month'})

# Show the figure to the user
show_to_user(fig)","The provided Python code correctly fetches the total sales revenue generated each month in the year 2022, and it creates a line chart to visualize the monthly sales revenue using the Plotly library. The main difference from the reference implementation is the use of a line chart instead of a bar graph, but this still effectively fulfills the business analytic request. Other than that, the use of utility functions 'execute_sql_query' and 'show_to_user' follows the specified Python environment constraints.","import plotly.express as px

# Define the SQL query
provide_sql_query('''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = 2022 
GROUP BY Month 
ORDER BY Month
''') 

# Since the SQL query will output the result into a pandas dataframe, we can directly use that
# Assume the dataframe is available as a global variable named 'df'

# Ensure the 'Month' column is treated as datetime for proper plotting
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart to visualize the monthly sales revenue
fig = px.line(df, x='Month', y='TotalSales', title='Monthly Sales Revenue for 2022')

# Display the result to the user
show_to_user(fig)","The input code does not utilize the execute_sql_query function to retrieve the actual data. Instead, it relies on a global variable 'df' which is not defined in the provided code. Additionally, there is a potential discrepancy in ensuring the 'Month' column is meant for plotting as a datetime object, which is not required for the business analytic request.",Base
What was the total sales revenue for the month of January 2023?,"import pandas as pd
import plotly.express as px

def get_total_sales_revenue():
    # SQL query to calculate the total sales revenue for January 2023
    sql_query = """"""
    SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
    FROM orders o
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-01';
    """"""

    # Execute the SQL query
    result_df = execute_sql_query(sql_query)

    # Check if the result_df has the data, as SUM could return None if there are no matching records
    if not result_df.empty:
        total_sales = result_df.iloc[0]['TotalSales']
    else:
        total_sales = 0

    # Create a DataFrame to display the result
    display_df = pd.DataFrame({'TotalSales': [total_sales]})

    # Display the results
    show_to_user(display_df)

# Invoke the function to get and display the total sales revenue
get_total_sales_revenue()","import pandas as pd

# Define the SQL query to calculate total sales revenue for January 2023
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
'''  

# Execute the SQL query using the provided utility function
total_sales_df = execute_sql_query(sql_query)

# Show the total sales revenue to the user
show_to_user(total_sales_df)","The provided code calculates the total sales revenue for January 2023 and displays it correctly. The SQL query is accurate, the execution function is called properly, and the result is displayed using the show_to_user function. It meets the requirements based on the given constraints and achieves the same purpose as the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to fetch total sales revenue for January 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optional: Visualization if there are multiple data points
if result_df.shape[0] > 1:
    fig = px.bar(result_df, x='OrderDate', y='TotalSales', title='Total Sales Revenue for January 2023', labels={'OrderDate': 'Date', 'TotalSales': 'Sales Revenue'})
    show_to_user(fig)
","The evaluated code doesn't calculate the total sales revenue in a comparable manner to the reference code. The reference code selects specific columns, joins them, and filters dates, then sums the values to get a total which is then checked for None and displayed. The evaluated code directly fetches results and displays them without computing a specific total or checking for None values, which might lead to incorrect handling of potential empty results. Visualization step is unnecessary for this request since the display of total sales is sufficient.",Base
"What is the average order value for orders placed between January 1, 2023, and December 31, 2023?","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
'''

# Execute the SQL query and get the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate average order value
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
''' 

# Execute the SQL query and get the result in a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The given input Python code correctly calculates the average order value for orders placed between January 1, 2023, and December 31, 2023. It matches the reference implementation in terms of logic and usage of the utility functions execute_sql_query and show_to_user. The SQL query and its execution, as well as the result display, are performed correctly.","import pandas as pd

# Define the SQL query to calculate the average order value
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS avg_order_value
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average order value from the result
avg_order_value = result_df['avg_order_value'].iloc[0]

# Convert the result to a DataFrame for display purposes
avg_order_value_df = pd.DataFrame({'Average Order Value': [avg_order_value]})

# Display the average order value to the user
show_to_user(avg_order_value_df)","The input Python code correctly calculates the average order value for orders placed between January 1, 2023, and December 31, 2023. It aligns with the reference implementation, complies with the specified Python environment constraints, and produces the correct output formatted using pandas and display functions provided.",both
Which city has received the highest number of orders? Please include a bar graph to visualize the number of orders by city.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''SELECT ShipCity, COUNT(OrderID) as TotalOrders FROM orders GROUP BY ShipCity ORDER BY TotalOrders DESC'''

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Create a bar graph of the number of orders by city
fig = px.bar(orders_df, x='ShipCity', y='TotalOrders', title='Number of Orders by City')

# Show the bar graph to the user
show_to_user(fig)

# Find the city with the highest number of orders
city_with_highest_orders_df = orders_df.head(1)

# Show the city with the highest number of orders to the user
show_to_user(city_with_highest_orders_df)","import pandas as pd
import plotly.express as px

# SQL query to get the number of orders by city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
""""""

# Execute the SQL query and get the data
orders_by_city = execute_sql_query(sql_query)

# Identify the city with the highest number of orders
highest_orders_city = orders_by_city.iloc[0]

# Create a bar graph to visualize the number of orders by city
fig = px.bar(orders_by_city, x='ShipCity', y='OrderCount', title='Number of Orders by City')

# Display the bar graph to the user
show_to_user(fig)

# Display the city with the highest number of orders to the user
show_to_user(highest_orders_city)",The given Python code correctly follows the business analytic request to identify the city with the highest number of orders and visualizes the number of orders by city using a bar graph in Plotly. It also adheres to the provided Python environment constraints by using execute_sql_query to retrieve data and show_to_user to display the results. The structure and logic are consistent with the reference implementation.,"import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the actual database query function
    pass

def show_to_user(data):
    # Placeholder for the actual show function
    pass

# The given SQL query
sql_query = '''
SELECT ShipCity, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC
'''
# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Find the city with the highest number of orders
highest_orders_city = orders_df.head(1)

# Print the city with the highest number of orders
print(f""City with the highest number of orders: {highest_orders_city['ShipCity'].values[0]}"")

# Create a bar graph to visualize the number of orders by city
fig = px.bar(orders_df, x='ShipCity', y='NumberOfOrders',
             title='Number of Orders by City',
             labels={'ShipCity': 'City', 'NumberOfOrders': 'Number of Orders'})

# Show the plot to the user
show_to_user(fig)","The input Python code correctly executes the SQL query to retrieve the number of orders by city, identifies the city with the highest number of orders, prints this information, and generates a bar graph visualizing the data. The code follows the given Python environment constraints and aligns with the provided business analytic request and reference implementation.",both
Which product category has the highest total sales in 2023? Please include a bar graph or pie chart to visualize the sales by product category.,"import plotly.express as px
import pandas as pd

# SQL Query to get the total sales by product category for the year 2023
sql_query = '''
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName 
ORDER BY total_sales DESC
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Visualize the sales data using a bar graph
fig = px.bar(sales_data, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023', labels={'CategoryName': 'Product Category', 'total_sales': 'Total Sales'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales grouped by product category for the year 2023
sql_query = '''
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName
ORDER BY total_sales DESC
'''

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Visualizing the sales data using a bar chart
fig = px.bar(sales_data, x='CategoryName', y='total_sales', 
             title='Total Sales by Product Category in 2023', 
             labels={'total_sales':'Total Sales', 'CategoryName':'Product Category'})

# Show the visualization to the user
show_to_user(fig)",The input Python code correctly follows the environment constraints and answers the business analytic request by querying the total sales by product category for the year 2023. It then visualizes the results using a Plotly bar chart exactly as specified.,"import plotly.express as px

# Define the SQL query to get the total sales by product category for the year 2023
sql_query = '''SELECT categories.CategoryName, SUM([Order Details].UnitPrice * [Order Details].Quantity) AS total_sales 
               FROM [Order Details] 
               JOIN products ON [Order Details].ProductID = products.ProductID 
               JOIN categories ON products.CategoryID = categories.CategoryID 
               JOIN orders ON [Order Details].OrderID = orders.OrderID 
               WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
               GROUP BY categories.CategoryName 
               ORDER BY total_sales DESC'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if there are any results
if not result_df.empty:
    # Find the product category with the highest total sales
    highest_sales_category = result_df.head(1)
    
    # Visualize the total sales by product category using a bar graph
    fig = px.bar(result_df, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023', 
                 labels={'CategoryName': 'Product Category', 'total_sales': 'Total Sales (USD)'})

    # Display the bar graph to the user
    show_to_user(fig)
else:
    # If no sales data is found, show an appropriate message to the user
    show_to_user(""No sales data found for the year 2023."")","The input code does not correctly handle discounts. In the reference code, the total sales are calculated considering the discount applied, while the input code ignores this aspect and only multiplies unit price by quantity, potentially leading to an overestimation of total sales.",Base
What is the average reorder level across all products?,"import pandas as pd
import plotly.express as px

# Define SQL query to get the average reorder level
sql_query = 'SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products;'

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the average reorder level across all products
sql_query = 'SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products'

# Execute SQL query and retrieve the results
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The provided implementation correctly constructs and executes the SQL query to calculate the average reorder level across all products. It then displays the result to the user. The structure and logic of the implementation match the reference code closely and adhere to the given Python environment constraints.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG(ReorderLevel) AS AvgReorderLevel FROM products;'

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The provided code correctly executes the SQL query to calculate the average reorder level and displays the result to the user. The query and function usage align with the reference implementation and the business analytic request.,both
What is the total inventory value of products currently in stock?,"import pandas as pd
# SQL Query to get the total inventory value
sql_query = 'SELECT SUM(UnitsInStock * UnitPrice) AS TotalInventoryValue FROM products;'

# Execute the SQL query
inventory_df = execute_sql_query(sql_query)

total_inventory_value = inventory_df['TotalInventoryValue'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'Total Inventory Value': [total_inventory_value]}))","import pandas as pd

# Query to calculate total inventory value
sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query
inventory_value_df = execute_sql_query(sql_query)

# Show the total inventory value to the user
show_to_user(inventory_value_df)","The input code includes a WHERE clause filtering out discontinued products, which is not in the reference implementation. This might alter the total inventory value if discontinued products exist with stock.","import pandas as pd
import plotly.express as px

# SQL query to get the total inventory value of products currently in stock
sql_query = 'SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue FROM products;'

# Execute the query and retrieve the data
try:
    result_df = execute_sql_query(sql_query)
except Exception as e:
    show_to_user(f'Error executing SQL query: {e}')
    raise

# Display the total inventory value to the user
try:
    show_to_user(result_df.iloc[0]['TotalInventoryValue'])
except Exception as e:
    show_to_user(f'Error displaying the result: {e}')
    raise",The input code correctly executes the SQL query to retrieve the total inventory value and displays it to the user. The exception handling for both the SQL execution and the result display adds robustness. The code follows the Python environment constraints and matches the intended functionality of the reference implementation.,Finetuned
Find the average quantity of products ordered per order.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the average quantity of products ordered per order
sql_query = '''
SELECT AVG(order_details.Quantity) AS AverageQuantity
FROM [Order Details] AS order_details
JOIN orders AS o ON order_details.OrderID = o.OrderID
'''

# Execute the SQL query to get the data
average_quantity_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_quantity_df)",The code implementation involves an unnecessary JOIN operation with the 'orders' table which is not needed. The reference code works with only the 'Order Details' table to calculate the average quantity. The JOIN operation does not match the initial business analytic request which only specified calculating the average quantity of products ordered per order.,"import pandas as pd

# Define the SQL query to find the average quantity of products ordered per order
sql_query = 'SELECT AVG(Quantity) AS avg_quantity_per_order FROM [Order Details];'

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Since the result is a single value ( average quantity), we need to get that value from the dataframe
avg_quantity_per_order = result_df.iloc[0]['avg_quantity_per_order']

# Create a dataframe to display the average quantity per order in a user-friendly format
avg_quantity_df = pd.DataFrame({'Average Quantity Per Order': [avg_quantity_per_order]})

# Display the average quantity to the user
show_to_user(avg_quantity_df)
",The given code correctly follows the specified Python environment constraints and provides an accurate solution to the business analytic request. The SQL query is correctly formulated to find the average quantity of products ordered per order. The result is then extracted and reformatted into a user-friendly dataframe before being displayed to the user using the provided utility function.,Finetuned
What is the percentage of orders shipped within the same country as the customer?,"import pandas as pd
import plotly.express as px

# SQL query to get the percentage of orders shipped within the same country as the customer
sql_query = '''
    SELECT (COUNT(*) / (SELECT COUNT(*) from orders) * 100) as percent_same_country 
    FROM orders o
    JOIN customers c ON o.CustomerID = c.CustomerID 
    WHERE o.ShipCountry = c.Country;
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the percentage of same country shipments
show_to_user(result_df)

# Additionally, manually construct a DataFrame for the plotly visualization
visualization_df = pd.DataFrame({'percent_same_country': [result_df.iloc[0]['percent_same_country']]})
# Since the index naturally starts at 0, we'll use that as the x-axis.
visualization_df.index = ['Percentage']  # Give a meaningful label for the x-axis

# Visualize the result as a bar plot (for demonstration purposes)
fig = px.bar(visualization_df, x=visualization_df.index, y='percent_same_country', title='Percentage of Orders Shipped Within the Same Country')
show_to_user(fig)","import pandas as pd

# SQL query to retrieve necessary data
sql_query = '''
SELECT customers.Country, COUNT(orders.OrderID) AS TotalOrders,
       COUNT(CASE WHEN customers.Country = orders.ShipCountry THEN 1 END) AS ShippedInSameCountry
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.Country
'''  

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Calculate the percentage of orders shipped within the same country as the customer
orders_data['PercentageShippedInSameCountry'] = (orders_data['ShippedInSameCountry'] / orders_data['TotalOrders']) * 100

# Select the relevant columns to display to the user
result = orders_data[['Country', 'PercentageShippedInSameCountry']]

# Show the result to the user
show_to_user(result)","The provided code does not compute the overall percentage of orders shipped within the same country as the customer. Instead, it calculates this percentage per country. The business analytic request asked for the overall percentage.","import pandas as pd

# Function to execute SQL query
df_orders = execute_sql_query(""SELECT * FROM orders;"")

# Calculate orders with the same ship country
same_country_shipment = df_orders[df_orders['ShipCountry'] == df_orders['Country']]

# Compute percentage of such orders
percentage_same_country = (len(same_country_shipment) / len(df_orders)) * 100

# Prepare the result as a DataFrame for display
result_df = pd.DataFrame({'Percentage Same Country Shipments': [percentage_same_country]})

# Displaying the result
show_to_user(result_df)","The input code incorrectly assumes that the 'ShipCountry' and 'Country' columns both exist in the 'orders' table, whereas the 'Country' column should be from the 'customers' table. The input code does not correctly join the 'orders' and 'customers' tables to ensure accurate calculation of orders shipped within the same country as the customer.",None
List all employees who were hired this year.,"import pandas as pd
import datetime as dt
from util_functions import execute_sql_query, show_to_user

# SQL query to get all employees hired this year
current_year = dt.datetime.now().year
sql_query = f'SELECT * FROM employees WHERE YEAR(HireDate) = {current_year};'

# Execute the SQL query and fetch the results into a DataFrame
employees_hired_this_year = execute_sql_query(sql_query)

# Display the resulting DataFrame to the user
show_to_user(employees_hired_this_year)","import pandas as pd

# Calculate the current year
current_year = pd.to_datetime('now').year

# SQL query to list all employees who were hired this year
sql_query = f""""""
SELECT EmployeeID, FirstName, LastName, HireDate
FROM employees
WHERE YEAR(HireDate) = {current_year}
""""""

# Execute the SQL query and retrieve data
hired_this_year_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(hired_this_year_df)","The input Python code correctly calculates the current year, constructs an appropriate SQL query to list employees hired this year, executes the query using the execute_sql_query function, and displays the result using the show_to_user function. The differences between the input and reference implementations are minor and do not affect functionality.","import pandas as pd

# Define the SQL query
sql_query = ""SELECT * FROM employees WHERE YEAR(HireDate) = YEAR(CURDATE());""

# Execute the SQL query to get the result as a pandas dataframe
employees_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(employees_df)",The input code correctly defines and executes a SQL query to retrieve all employees hired this year and displays the resulting DataFrame using the provided utility functions. It closely matches the reference implementation.,both
What is the total revenue generated each year? Please include a bar graph or line chart to visualize the yearly revenue.,"import plotly.express as px

# SQL query to fetch the total revenue generated each year
sql_query = '''
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS YearlyRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Year 
ORDER BY Year;
'''

# Execute the SQL query and retrieve the data
revenue_df = execute_sql_query(sql_query)

# Make sure the data types are correct for plotting
revenue_df['Year'] = revenue_df['Year'].astype(int)
revenue_df['YearlyRevenue'] = revenue_df['YearlyRevenue'].astype(float)

# Create a bar chart using plotly express
fig = px.bar(revenue_df, x='Year', y='YearlyRevenue', title='Total Revenue Generated Each Year', labels={'Year': 'Year', 'YearlyRevenue': 'Total Revenue'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch total revenue generated each year
sql_query = '''
SELECT 
    YEAR(o.OrderDate) AS Year,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    YEAR(o.OrderDate)
ORDER BY 
    Year
'''  

# Execute the SQL query and get the data in a pandas dataframe
revenue_data = execute_sql_query(sql_query)

# Create a line chart to visualize the yearly revenue
fig = px.line(revenue_data, x='Year', y='TotalRevenue', title='Total Revenue Generated Each Year')
show_to_user(fig)","The input code meets the requirements of the business analytic request, as it correctly retrieves and summarizes the total revenue generated each year from the database using an SQL query, which is in line with the reference implementation. The data is then plotted using a plotly line chart, and shown to the user, fulfilling the requirement of visualizing the yearly revenue. The implemented code adheres to the given Python environment constraints.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT strftime('%Y', o.OrderDate) AS Year, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM orders o 
JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
GROUP BY Year;
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Check if the column 'Year' is treated as string
if df['Year'].dtype != 'object':
    df['Year'] = df['Year'].astype('object')

# Sort the dataframe by 'Year'
df = df.sort_values(by='Year')

# Create a bar chart to visualize the yearly revenue
fig = px.bar(df, x='Year', y='TotalRevenue', title='Total Revenue Generated Each Year', labels={'TotalRevenue': 'Total Revenue', 'Year': 'Year'})

# Show the graph to the user
show_to_user(fig)
","The provided Python code correctly executes the SQL query to extract total yearly revenue and generates a bar chart using Plotly. It adheres to the required functions (`execute_sql_query` and `show_to_user`), manipulates data types appropriately, and sorts the data by year. Therefore, it meets the business analytic requirements and produces correct, expected output.",both
Find the total quantity ordered for each product. Please include a bar graph to visualize the total quantity ordered by product.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductID, SUM(Quantity) AS total_quantity FROM [Order Details] GROUP BY ProductID;'

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Convert ProductID to string for better bar graph visualization
result_df['ProductID'] = result_df['ProductID'].astype(str)

# Create a bar graph using plotly
fig = px.bar(result_df, x='ProductID', y='total_quantity', title='Total Quantity Ordered by Product', labels={'ProductID': 'Product ID', 'total_quantity': 'Total Quantity Ordered'})

# Display the bar graph to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to find total quantity ordered for each product
sql_query = '''
SELECT OrderDetails.ProductID, SUM(OrderDetails.Quantity) AS TotalQuantity
FROM [Order Details] AS OrderDetails
GROUP BY OrderDetails.ProductID
'''

# Execute the SQL query
product_quantities = execute_sql_query(sql_query)

# Create a bar graph to visualize total quantity ordered by product
fig = px.bar(product_quantities, x='ProductID', y='TotalQuantity',
             title='Total Quantity Ordered by Product',
             labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity Ordered'})

# Show the result to the user
show_to_user(fig)","The provided input Python code correctly implements the business analytic request by executing an SQL query that retrieves the total quantity ordered for each product. It then visualizes the resulting data using a bar graph with Plotly, and displays the graph to the user using the provided utility function. The input code adheres to the specified Python environment constraints and effectively answers the business analytic request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID GROUP BY products.ProductName;'

# Execute the SQL query and retrieve the data into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar graph to visualize the total quantity ordered by product
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Total Quantity Ordered by Product', labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity Ordered'})

# Show the bar graph to the user
show_to_user(fig)","The provided code correctly performs the required task by querying the necessary data, creating the appropriate bar graph, and displaying it to the user. It also follows the specified Python environment constraints.",both
How many orders have been placed by customers in Germany in the year 2023?,"import pandas as pd

# Define the SQL query
sql_query = '''
SELECT COUNT(o.OrderID) as OrderCount
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
WHERE c.Country = 'Germany'
AND o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Since the result is a single value count, we can extract the value for display
order_count = result_df['OrderCount'].iloc[0]

# Display the result
show_to_user(order_count)","import pandas as pd

# Define the SQL query to count orders from Germany in 2023
sql_query = """"""
SELECT COUNT(orders.OrderID) AS orders_count
FROM orders 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE customers.Country = 'Germany' 
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31';
""""""

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)",The input Python code does not extract the order count from the result DataFrame before passing it to show_to_user. It should extract the count as a scalar value before showing it to the user.,"import pandas as pd
import plotly.express as px

# SQL query to get the number of orders placed by customers in Germany in 2023
sql_query = '''
SELECT COUNT(OrderID) AS NumberOfOrders 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
AND ShipCountry = 'Germany';'''

# Execute the SQL query using the provided utility function
orders_df = execute_sql_query(sql_query)

# It would be a single row and single column, we can directly access the value
number_of_orders = orders_df.iloc[0, 0]

# Displaying the result to the user
result_df = pd.DataFrame({'NumberOfOrders': [number_of_orders]})
show_to_user(result_df)","The input code uses 'ShipCountry' instead of 'Country' in the WHERE clause, which is incorrect based on the reference SQL query that checks against the 'Country' in the customers table. The code also uses YEAR(OrderDate) instead of BETWEEN '2023-01-01' AND '2023-12-31' to filter the order dates, which may be acceptable depending on the database engine but is not the same as the reference. Additionally, the final result is displayed as a DataFrame instead of a single count value, which deviates from the reference implementation's approach.",None
Calculate the average age of employees.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT AVG((CURRENT_DATE - BirthDate) / 365.25) AS AvgAge FROM employees;""

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Extract the average age from the result
avg_age = result_df.loc[0, 'AvgAge']

# Prepare the data for visualization
visualization_df = pd.DataFrame({'Metric': ['Average Age'], 'Value': [avg_age]})

# Create a bar chart using plotly
fig = px.bar(visualization_df, x='Metric', y='Value', title='Average Age of Employees')

# Display the result to the user
show_to_user(fig)","import pandas as pd

# SQL query to calculate the average age of employees
sql_query = """"""
SELECT AVG(YEAR(CURDATE()) - YEAR(BirthDate)) AS AverageAge
FROM employees;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
average_age_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_age_df)","The input code calculates an approximate average age by subtracting the birth year from the current year, which can lead to errors unless it's the user's birthday, as it doesn't account for months and days. The reference code accounts for fractional years by dividing the difference in days by 365.25.","import pandas as pd

# SQL query to calculate the average age
sql_query = '''
SELECT AVG(DATEDIFF(CURRENT_DATE, BirthDate) / 365.25) AS AverageAge 
FROM employees;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the average age from the dataframe
average_age = df['AverageAge'][0]

# Display the result to the user
user_output_df = pd.DataFrame({'AverageAge': [average_age]})
show_to_user(user_output_df)","The input Python code correctly calculates the average age of employees by executing an appropriate SQL query. It then extracts the result and formats it into a Pandas DataFrame. Finally, it displays the result using the show_to_user function. Although the visualization aspect (using plotly) from the reference implementation is omitted, the primary task to calculate and display the average age is correctly fulfilled as per the business analytic request.",Finetuned
What is the total discount given on orders placed in 2022?,"import pandas as pd
import plotly.express as px

# SQL query from the business request
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS total_discount 
FROM orders 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(orders.OrderDate) = 2022
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Assuming the result_df has a column called 'total_discount'
total_discount = result_df['total_discount'].iloc[0]

# Prepare the data to show to user
show_df = pd.DataFrame({'Total Discount': [total_discount]})

# Visualize the result using plotly
fig = px.bar(show_df, x=['Total Discount'], y=show_df['Total Discount'], title='Total Discount Given on Orders Placed in 2022')

# Show the result to the user
show_to_user(fig)
","import pandas as pd

# SQL query to fetch the total discount given on orders placed in 2022
sql_query = '''
SELECT SUM([Order Details].Discount) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
''' 

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code is not calculating the total discount correctly. The 'SUM([Order Details].Discount)' query only sums the discount percentages, whereas the correct calculation should be 'SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount)' as done in the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount 
FROM [Order Details] 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
""""""

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Since the result is a single scalar value in the first row and first column,
# we can directly extract that value and display it to the user

# Extract the total discount value
if result_df.empty or result_df.iloc[0, 0] is None:
    total_discount = 0
else:
    total_discount = result_df.iloc[0, 0]

# Create a DataFrame to store and show the result
result_summary_df = pd.DataFrame({'TotalDiscount': [total_discount]})
show_to_user(result_summary_df)",The input code successfully executes the SQL query to compute the total discount given on orders placed in 2022. It matches the reference implementation in functionality by joining the 'orders' and 'Order Details' tables and calculating the total discount for the specified date range. The result is then displayed to the user. The use of BETWEEN '2022-01-01' AND '2022-12-31' is functionally equivalent to using YEAR(orders.OrderDate) = 2022 to filter the year. The final output is shown to the user using the utility function 'show_to_user'.,Finetuned
Which customer region had the highest average order fulfillment time in the past month? Please include a bar graph to visualize the average fulfillment time by region.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = '''
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE OrderDate >= CURDATE() - INTERVAL 1 MONTH
GROUP BY ShipRegion
ORDER BY AvgFulfillmentTime DESC;
'''

# Execute the SQL query and get the results in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Generate the bar graph using plotly
fig = px.bar(result_df, x='ShipRegion', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Region in the Past Month')

# Show the bar graph to the user
show_to_user(fig)

# Corrected code to properly retrieve and display the region with the highest average fulfillment time
highest_avg_fulfillment_time_region = result_df[['ShipRegion', 'AvgFulfillmentTime']].iloc[0]

# Show the region with the highest average fulfillment time to the user
show_to_user(highest_avg_fulfillment_time_region)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the order fulfillment time by region for the past month
date_range_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= DATE_FORMAT(NOW() - INTERVAL 1 MONTH, '%Y-%m-%d')
GROUP BY ShipRegion
""""""

# Execute the SQL query to get the data
fulfillment_data = execute_sql_query(date_range_query)

# Identify the region with the highest average order fulfillment time
highest_region = fulfillment_data.loc[fulfillment_data['AverageFulfillmentTime'].idxmax()]

# Prepare bar graph to visualize the average fulfillment time by region
fig = px.bar(fulfillment_data, x='ShipRegion', y='AverageFulfillmentTime',
             title='Average Order Fulfillment Time by Region',
             labels={'ShipRegion': 'Region', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'}
)

# Show the graph and highest region info to the user
show_to_user(fig)

# Display the region with the highest average fulfillment time
highest_region_info = pd.DataFrame([highest_region])
show_to_user(highest_region_info)","The input Python code correctly implements the required business analytic request. It retrieves data about order fulfillment times by region for the past month using the provided SQL query function (`execute_sql_query`), calculates the region with the highest average fulfillment time, and visualizes the data using plotly. Additionally, the code appropriately displays the results to the user using the provided `show_to_user` function. The execution flow, logic, and the final outcome match the goal of the task.","## Imports
```python
import pandas as pd
import plotly.express as px
```

## SQL Query
The SQL query aligns well with the requirement. Let's refine it and execute it using the provided utility function.
```sql
SELECT customers.Region, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM orders 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE orders.OrderDate >= CURDATE() - INTERVAL 1 MONTH 
GROUP BY customers.Region
ORDER BY avg_fulfillment_time DESC;
```

## Execute SQL Query
```python
sql_query = """"""
SELECT customers.Region, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM orders 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE orders.OrderDate >= CURDATE() - INTERVAL 1 MONTH 
GROUP BY customers.Region
ORDER BY avg_fulfillment_time DESC;
""""""

# Fetch data using the utility function
region_fulfillment_df = execute_sql_query(sql_query)
```

## Generate Bar Graph
```python
# Create a bar graph using plotly
fig = px.bar(region_fulfillment_df, 
             x='Region', 
             y='avg_fulfillment_time', 
             title='Average Order Fulfillment Time by Region in the Past Month',
             labels={'avg_fulfillment_time': 'Average Fulfillment Time (days)', 'Region': 'Customer Region'})
```

## Display the Plot
```python
# Display the plot using the provided utility function
show_to_user(fig)
```","The input Python code uses the correct SQL query to fetch the required data, which joins the orders and customers tables to get the region information. The SQL query is correctly formatted to calculate the average fulfillment time and properly filters the data for the past month. The code also generates a bar graph using Plotly and displays the result using the show_to_user function. The code meets the requirements as outlined in the business request.",both
What is the average price per unit of all products?,"import pandas as pd

# SQL Query to get the average price per unit of all products
sql_query = 'SELECT AVG(UnitPrice) AS AveragePrice FROM products;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the AveragePrice value and create a new dataframe to format the result
average_price = result_df['AveragePrice'][0]
formatted_result_df = pd.DataFrame({'AveragePrice': [average_price]})

# Display the result to the user
show_to_user(formatted_result_df)","import pandas as pd

# SQL query to calculate the average price per unit of all products
sql_query = """"""
SELECT AVG(UnitPrice) AS AveragePricePerUnit
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query to get the average price per unit
data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(data)","The input Python code to evaluate includes a condition WHERE Discontinued = 0, which filters out the products that are discontinued. This differs from the reference implementation which considers all products without any such filter.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(UnitPrice) AS AveragePricePerUnit FROM products;'

# Execute the SQL query and retrieve the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the average price per unit to the user
show_to_user(result_df.iloc[0]['AveragePricePerUnit'])","The input code correctly calculates and retrieves the average price per unit of all products using the SQL query and extracts the result. However, it does not format the result in a DataFrame before displaying to the user. The output should be a DataFrame to maintain a consistent format as hinted by the reference implementation.",None
Find the average order value for each customer.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CustomerID, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) as average_order_value 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
'''

# Execute the SQL query and retrieve data in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, you can visualize the average order value per customer using a bar chart
fig = px.bar(result_df, x='CustomerID', y='average_order_value', title='Average Order Value per Customer')
show_to_user(fig)","import pandas as pd

# Define the SQL query to calculate the average order value for each customer
sql_query = '''
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM 
    customers AS c
JOIN 
    orders AS o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
'''

# Execute the SQL query and retrieve the data
average_order_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_order_value_df)","The input Python code correctly calculates the average order value for each customer using the given SQL query, executes the query, retrieves the result as a pandas DataFrame, and displays it using show_to_user function. It also follows the Python environment constraints and addresses the business analytic request, though it optionally includes the CompanyName in the output.","import pandas as pd
import plotly.express as px

# SQL query to find the average order value for each customer
sql_query = '''
SELECT c.CustomerID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AvgOrderValue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID;
'''

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optional: Visualization of the average order value for each customer
fig = px.bar(result_df, x='CustomerID', y='AvgOrderValue', title='Average Order Value for Each Customer', labels={'CustomerID': 'Customer ID', 'AvgOrderValue': 'Average Order Value'})

# Show the visualization
show_to_user(fig)","The input Python code correctly implements the task of finding the average order value for each customer. It constructs the correct SQL query, executes it using the provided utility function 'execute_sql_query', displays the result with 'show_to_user'. Additionally, it provides a visualization of the results using plotly, which is displayed correctly with 'show_to_user'. This matches the functionality of the reference implementation.",both
What is the on-time delivery rate for the month of April 2023? Please include a bar graph or line chart to visualize the on-time delivery rate.,"import plotly.express as px
import pandas as pd

# SQL query to get the on-time delivery rate for April 2023
sql_query = '''SELECT COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30''' 

# Execute the SQL query
df = execute_sql_query(sql_query)

# Verify if the query result is not empty
if not df.empty:
    # Extract the on-time delivery rate
    on_time_delivery_rate = df['on_time_delivery_rate'][0]
    on_time_delivery_rate_df = pd.DataFrame({'Date': ['April 2023'], 'On-time Delivery Rate': [on_time_delivery_rate]})

    # Create a bar chart to visualize the on-time delivery rate
    fig = px.bar(on_time_delivery_rate_df, x='Date', y='On-time Delivery Rate', title='On-time Delivery Rate for April 2023')

    # Show the result to the user
    show_to_user(fig)
else:
    print('No data available for the specified period.')","import pandas as pd
import plotly.express as px

def calculate_on_time_delivery_rate(month, year):
    start_date = f'{year}-{month}-01'
    end_date = f'{year}-{month}-30'
    sql_query = f""""""SELECT COUNT(OrderID) AS total_orders,
                      COUNT(OrderID) FILTER (WHERE ShippedDate <= RequiredDate) AS on_time_orders
                   FROM orders
                   WHERE OrderDate BETWEEN '{start_date}' AND '{end_date}'""""""
    result = execute_sql_query(sql_query)

    total_orders = result['total_orders'].values[0]
    on_time_orders = result['on_time_orders'].values[0]

    if total_orders == 0:
        on_time_delivery_rate = 0
    else:
        on_time_delivery_rate = (on_time_orders / total_orders) * 100

    return on_time_delivery_rate

def visualize_delivery_rate(rate, month, year):
    month_name = pd.to_datetime(f'{year}-{month}-01').strftime('%B')
    fig = px.bar(x=[month_name], y=[rate], labels={'x': 'Month', 'y': 'On-time Delivery Rate (%)'},
                 title=f'On-time Delivery Rate for {month_name} {year}')
    show_to_user(fig)

# Calculate and visualize the on-time delivery rate for April 2023
on_time_rate = calculate_on_time_delivery_rate(4, 2023)
visualize_delivery_rate(on_time_rate, 4, 2023)","The input Python code correctly calculates the on-time delivery rate for April 2023 and visualizes it using a bar chart. It follows the specified utility functions execute_sql_query and show_to_user, adheres to the given environment constraints, and provides the correct output as requested by the business analytic task.","To calculate the on-time delivery rate for April 2023 and visualize it using a bar graph, follow the steps outlined below in Python.

First, we will execute the SQL query to retrieve the number of on-time deliveries and the total orders for April 2023. Next, we will compute the on-time delivery rate and then create a bar chart to visualize this rate.

Here is the complete Python code to achieve this:

```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT COUNT(*) AS TotalOnTimeDeliveries 
FROM orders o 
WHERE o.ShippedDate <= o.RequiredDate 
AND o.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
'''

# Step 2: Fetch the number of on-time deliveries
on_time_deliveries_df = execute_sql_query(sql_query)
total_on_time_deliveries = on_time_deliveries_df['TotalOnTimeDeliveries'][0]

# Step 3: Get total orders for April 2023
sql_query_total = '''
SELECT COUNT(*) AS TotalOrders 
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
'''

total_orders_df = execute_sql_query(sql_query_total)
total_orders = total_orders_df['TotalOrders'][0]

# Step 4: Calculate on-time delivery rate
if total_orders > 0:
    on_time_delivery_rate = (total_on_time_deliveries / total_orders) * 100
else:
    on_time_delivery_rate = 0

on_time_delivery_rate_df = pd.DataFrame({'Metric': ['On-Time Delivery Rate'], 'Rate (%)': [on_time_delivery_rate]})

# Step 5: Generate the bar chart
fig = px.bar(on_time_delivery_rate_df, x='Metric', y='Rate (%)', title='On-Time Delivery Rate for April 2023')

# Step 6: Display the chart to the user
show_to_user(fig)
```

### Explanation:
- The SQL queries fetch the total on-time deliveries and total orders for April 2023.
- We calculate the on-time delivery rate and create a dataframe to store the metric.
- Using `plotly.express`, we create a bar chart visualizing the delivery rate.
- Finally, the chart is displayed to the user using a helper function.

### Assumptions:
- `execute_sql_query` is a predefined function that executes the SQL query and returns a pandas dataframe.
- `show_to_user` is a predefined function that displays the provided plotly figure to the user.","The input Python code correctly calculates the on-time delivery rate for April 2023 by executing SQL queries to get the total on-time deliveries and total orders. The on-time delivery rate is calculated and visualized using a bar chart in plotly, which is displayed to the user. The code follows the given Python environment constraints and can provide the required output.",both
What is the on-time delivery rate for each month in 2023? Include a line chart visualization for better illustration.,"import pandas as pd
import plotly.express as px

# SQL query to get on-time delivery rate for each month in 2023
date_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE NULL END) * 1.0 / COUNT(*) AS on_time_delivery_rate 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY month;
""""""

# Execute the SQL query against the database and get the result as a DataFrame
data_frame = execute_sql_query(date_query)

# Ensure the month column is ordered correctly
data_frame['month'] = pd.to_datetime(data_frame['month'], format='%Y-%m')
data_frame = data_frame.sort_values('month')

# Create a line chart visualization using plotly
fig = px.line(data_frame, x='month', y='on_time_delivery_rate', title='On-time Delivery Rate for Each Month in 2023')
fig.update_xaxes(tickformat=""%Y-%m"")

# Show the line chart to the user
show_to_user(fig)

# Additionally, show the data table to the user
show_to_user(data_frame)","import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rates per month in 2023
sql_query = '''
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM
    orders
WHERE
    YEAR(OrderDate) = 2023
GROUP BY
    Month
ORDER BY
    Month;
'''

# Execute SQL query to get the data
on_time_delivery_data = execute_sql_query(sql_query)

# Calculate the on-time delivery rate
on_time_delivery_data['OnTimeRate'] = (on_time_delivery_data['OnTimeDeliveries'] / on_time_delivery_data['TotalOrders']) * 100

# Create a line chart for visualization
fig = px.line(on_time_delivery_data, x='Month', y='OnTimeRate', title='On-Time Delivery Rate per Month in 2023', labels={'OnTimeRate': 'On-Time Delivery Rate (%)', 'Month': 'Month'})

# Show the result to the user
show_to_user(fig)","The input code meets the requirements as it correctly calculates the on-time delivery rate for each month in 2023, generates a corresponding line chart using Plotly, and displays the result using the provided utility functions. The approach and output align well with the reference implementation, and it conforms to the provided Python environment constraints.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(*)) * 100 AS OnTimeDeliveryRate 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY month;
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Ensure the 'month' column is treated as a datetime type for proper sorting
orders_df['month'] = pd.to_datetime(orders_df['month'], format='%Y-%m')

# Create a line chart using plotly
fig = px.line(orders_df, x='month', y='OnTimeDeliveryRate', title='On-Time Delivery Rate for Each Month in 2023', labels={'month': 'Month', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'})

# Display the figure to the user
show_to_user(fig)
","The provided Python code follows all the constraints and accurately answers the business request. It executes a SQL query to get the on-time delivery rate for each month in 2023, processes the result into a pandas DataFrame, ensures proper datetime ordering and creates a line chart using plotly to visualize the on-time delivery rate by month. The necessary functions 'execute_sql_query' and 'show_to_user' are used correctly.",both
What is the total number of units on order for each product in 2022? Include a bar chart visualization to better illustrate the results.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, SUM(products.UnitsOnOrder) AS units_on_order
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
'''

# Execute the SQL query and get the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Create the bar chart using plotly express
fig = px.bar(df, x='ProductID', y='units_on_order', title='Total Units on Order for Each Product in 2022', labels={'ProductID': 'Product ID', 'units_on_order': 'Units On Order'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total number of units on order for each product in 2022
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalUnitsOnOrder 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(result_df, x='ProductID', y='TotalUnitsOnOrder',
             title='Total Units on Order for Each Product in 2022',
             labels={'TotalUnitsOnOrder': 'Total Units on Order', 'ProductID': 'Product ID'})

# Show the result to the user
show_to_user(fig)","The input code uses SUM([Order Details].Quantity) to calculate the total units on order, which is different from the reference code which uses SUM(products.UnitsOnOrder). This might produce different results as the fields being summed are different.","```python
import pandas as pd
import plotly.express as px

# SQL query to aggregate the total units on order for each product in 2022
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_units_on_order
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductName;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the total units on order for each product in 2022
fig = px.bar(df, x='ProductName', y='total_units_on_order', title='Total Units on Order for Each Product in 2022')

# Display the bar chart to the user
show_to_user(fig)
```","The input code nearly achieves the business analytic request but deviates in a critical manner; it aggregates the `Quantity` from `[Order Details]`, representing units ordered, rather than the intended `UnitsOnOrder` field from `products`. This divergence targets ordered quantities over inventory units, thus misaligning with requesting business totals and impacting result authenticity post-deployment.",None
What are the names and prices of products that have less than 20 units in stock?,"import pandas as pd

# Define the SQL query to retrieve the required data
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the data to the user using the provided utility function
show_to_user(result_df)","import pandas as pd

# Define the SQL query to retrieve products with less than 20 units in stock
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""  

# Execute the SQL query and store the result in a DataFrame
products_low_stock = execute_sql_query(sql_query)  

# Display the result to the user
show_to_user(products_low_stock)","The input Python code correctly forms the SQL query, executes it using the provided utility function execute_sql_query, and displays the result using the provided utility function show_to_user. The code meets the business analytic request and adheres to the specified Python environment constraints.","
import pandas as pd
import plotly.express as px

# Function to execute the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""
products_df = execute_sql_query(sql_query)

# Display the resulting data to the user
show_to_user(products_df)
","The provided implementation aligns with the given business analytic request. It correctly executes the SQL query to retrieve the names and prices of products with less than 20 units in stock and displays the results using the appropriate utility function. The use of plotly is not required in this context, so the removal does not affect the correctness.",both
Calculate the total quantity of products sold per product category. Use a bar chart to visualize the quantities per category.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CategoryID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY CategoryID
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='CategoryID', y='TotalQuantity', title='Total Quantity of Products Sold per Category', labels={'CategoryID': 'Product Category', 'TotalQuantity': 'Total Quantity Sold'})

# Display the result
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total quantity of products sold per product category
sql_query = '''
SELECT p.CategoryName, SUM(od.Quantity) as TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryName
'''  

# Execute SQL query and retrieve data
category_sales = execute_sql_query(sql_query)

# Create a bar chart to visualize the total quantity sold per category
fig = px.bar(category_sales, x='CategoryName', y='TotalQuantity', title='Total Quantity of Products Sold per Category')

# Show the visualization to the user
show_to_user(fig)","The provided Input Python Code correctly executes the required SQL query to calculate the total quantity of products sold per category. It uses a JOIN between the 'Order Details' and 'products' tables, groups by category, and then sums the quantities. It also visualizes the result using a bar chart with plotly and displays it to the user, which matches the requested business analytic task.","
import plotly.express as px
import pandas as pd

# SQL query to calculate total quantity of products sold per product category
sql_query = '''SELECT c.CategoryID, SUM(od.Quantity) AS TotalQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryID''' 

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities per category
fig = px.bar(result_df, x='CategoryID', y='TotalQuantity', title='Total Quantity of Products Sold per Product Category', labels={'CategoryID':'Product Category', 'TotalQuantity':'Total Quantity'})

# Show the chart
show_to_user(fig)
","The provided Python code correctly executes the SQL query to calculate the total quantity of products sold per product category, and then uses Plotly to create a bar chart that visualizes the quantities per category. It adheres to the environment constraints by using the given utility functions 'execute_sql_query' and 'show_to_user'.",both
List all orders that were shipped to Germany.,"import pandas as pd
import plotly.express as px

# SQL query to list all orders shipped to Germany
sql_query = ""SELECT * FROM orders WHERE ShipCountry = 'Germany';""

# Execute the query and retrieve the data as a pandas dataframe
# Ensure execute_sql_query function is properly used to retrieve the data
try:
    df_orders_germany = execute_sql_query(sql_query)
except Exception as e:
    raise RuntimeError('Error executing SQL query') from e

# Display the retrieved data to the user
show_to_user(df_orders_germany)","import pandas as pd

# Define the SQL query to list all orders that were shipped to Germany
sql_query = """"""
SELECT * 
FROM orders
WHERE ShipCountry = 'Germany'
""""""

# Execute the SQL query and retrieve the data
orders_shipped_to_germany = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_shipped_to_germany)",The input Python code correctly executes the SQL query to list all orders shipped to Germany and displays the retrieved data to the user. It aligns with the specified business analytic request and roughly matches the functionality of the reference implementation.,"import pandas as pd

# SQL query to fetch orders shipped to Germany
sql_query = ""SELECT * FROM orders WHERE ShipCountry = 'Germany';""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the resulting DataFrame to the user
show_to_user(orders_df)

# Assuming the execute_sql_query and show_to_user functions are predefined and provided by the environment.
","The input code correctly fetches orders shipped to Germany using the SQL query and displays the resulting DataFrame. It aligns with the business analytic request, adheres to the given Python environment constraints, and matches the functionality of the reference implementation. There is appropriate usage of execute_sql_query and show_to_user functions.",both
Who are the top 3 employees based on total sales generated? Include a bar chart visualization for better illustration.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result dataframe to the user
show_to_user(result_df)

# Create bar chart visualization
fig = px.bar(result_df, x='EmployeeID', y='TotalSales', title='Top 3 Employees Based on Total Sales Generated')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales per employee
sql_query = '''
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC
LIMIT 3
'''  

# Execute the SQL query and retrieve the data
top_employees_df = execute_sql_query(sql_query)

# Create a bar chart visualization for the top 3 employees based on total sales
fig = px.bar(top_employees_df, x='EmployeeName', y='TotalSales', 
             title='Top 3 Employees Based on Total Sales', 
             labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee Name'})

# Show the data and visualization to user
show_to_user(fig)","The input Python code fulfills the business analytic request by correctly executing the SQL query to find the top 3 employees based on total sales, including their full names. It then visualizes the result using a Plotly bar chart. The code uses the necessary utility functions to execute the SQL query and display the results, adhering to the required Python environment constraints.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ''' 
SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3 
'''

# Execute the SQL query
employee_sales_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(employee_sales_df, x='EmployeeID', y='TotalSales', title='Top 3 Employees Based on Total Sales Generated', labels={'EmployeeID':'Employee ID', 'TotalSales':'Total Sales'})

# Display the chart to the user
show_to_user(fig)",The provided Python code correctly follows the business requirement of identifying and visualizing the top 3 employees based on total sales generated. It aligns with the reference implementation in terms of functionality and structure. It uses the specified utility functions and Plotly for visualization as required.,both
What are the total sales for each product? Use a bar chart to visualize the total sales per product.,"import plotly.express as px

# SQL query to get total sales for each product
sql_query = '''
SELECT products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName;
'''

# Execute SQL query to retrieve data
df = execute_sql_query(sql_query)

# Create bar chart using plotly
fig = px.bar(df, x='ProductName', y='TotalSales', title='Total Sales per Product', 
             labels={'ProductName': 'Product Name', 'TotalSales': 'Total Sales'}, 
             height=600)

# Show the bar chart to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales per product
sql_query = '''
SELECT  p.ProductID,  p.ProductName,  SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY  p.ProductID,  p.ProductName
ORDER BY TotalSales DESC
'''  

# Execute query and retrieve data
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Total Sales per Product', labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)",The input Python code correctly retrieves total sales for each product from the database and creates a bar chart using Plotly to visualize the data. It follows the given Python environment constraint by using the execute_sql_query function to get the data and show_to_user function to display the chart. The code structure and logic are appropriate for the given business analytic request.,"import plotly.express as px
import pandas as pd

# SQL Query to get total sales for each product
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalSales 
FROM products 
JOIN [Order Details] 
ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Ensure the column names match what we expect
sales_data.columns = ['ProductID', 'TotalSales']

# Create a bar chart using plotly
fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Total Sales per Product', labels={'ProductID':'Product ID', 'TotalSales':'Total Sales'})

# Show the plot to the user
show_to_user(fig)","The input code calculates TotalSales as the sum of the Quantity sold for each ProductID, not taking into account the UnitPrice and Discount like the reference implementation. Additionally, it incorrectly groups by ProductID instead of ProductName, which affects the readability and the desired output.",Base
List the orders that have not been shipped within the required date.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT orders.OrderID, orders.RequiredDate, orders.ShippedDate
FROM orders
WHERE orders.ShippedDate IS NULL OR orders.ShippedDate > orders.RequiredDate;
'''

# Execute the SQL query and store the result in a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)",import pandas as pd\n\n# SQL query to retrieve orders that have not been shipped within the required date\nsql_query = '''\nSELECT * FROM orders \nWHERE ShippedDate IS NULL OR ShippedDate > RequiredDate\n'''\n\n# Execute the SQL query and retrieve the data\norders_not_shipped_on_time = execute_sql_query(sql_query)\n\n# Display the result to the user\nshow_to_user(orders_not_shipped_on_time),The input code correctly retrieves the orders that have not been shipped within the required date using a SQL query matching the one specified in the reference code. It also executes the SQL query with the execute_sql_query function and displays the result using the show_to_user function as required.,"import pandas as pd
import plotly.express as px

# Define the SQL query
def get_delayed_orders():
    sql_query = ""SELECT * FROM orders WHERE ShippedDate > RequiredDate;""
    
    # Execute the SQL query and retrieve data
    df_delayed_orders = execute_sql_query(sql_query)
    
    # Display the data to the user
    show_to_user(df_delayed_orders)
    
    # Optionally, create a visualization to better understand delays
    fig = px.histogram(df_delayed_orders, x='OrderID', title='Delayed Orders')
    show_to_user(fig)

# Call the function to execute the logic
get_delayed_orders()

","The Input Python Code does not handle the case where 'ShippedDate' is NULL. The Business Analytic Request wants to list orders not shipped within the required date, which includes shipped orders after the 'RequiredDate' and orders that have not been shipped at all. The input implementation only filters for orders where 'ShippedDate' is greater than 'RequiredDate' and misses orders where 'ShippedDate' is NULL.",Base
How many products have been discontinued?,"import pandas as pd

# SQL query to get the count of discontinued products
sql_query = 'SELECT COUNT(*) AS discontinued_count FROM products WHERE products.Discontinued = 1'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to user
show_to_user(result_df)","sql_query = """"""
SELECT COUNT(*) AS discontinued_products_count
FROM products
WHERE Discontinued = 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)",The input Python code is correct and aligns with the business analytic request and reference implementation. It retrieves the count of discontinued products using a SQL query and leverages the provided utility functions to display the result.,"import pandas as pd

# Define the SQL query to count discontinued products
sql_query = 'SELECT COUNT(*) AS DiscontinuedCount FROM products WHERE Discontinued = 1;'

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Extract the count of discontinued products from the dataframe
discontinued_count = result_df['DiscontinuedCount'].values[0]

# Convert the count to a pandas DataFrame for display purposes
result_display_df = pd.DataFrame({'DiscontinuedCount': [discontinued_count]})

# Display the result to the user
show_to_user(result_display_df)","The input code correctly follows the Python environment constraint, executes the SQL query to count discontinued products, processes the result into a DataFrame, and uses the provided show_to_user function to display the result. Though it's more elaborate than the reference code, it achieves the same result.",both
What are the total units ordered for each supplier? Include a bar chart to illustrate the data better.,"import pandas as pd
import plotly.express as px

# SQL query to get total units ordered for each supplier
sql_query = '''
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Generate bar chart to illustrate the data
fig = px.bar(result_df, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered for Each Supplier', labels={'SupplierID': 'Supplier ID', 'TotalUnitsOrdered': 'Total Units Ordered'})

# Display the bar chart to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total units ordered for each supplier
sql_query = '''
SELECT p.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.SupplierID
'''

# Execute the SQL query and get the result in a pandas DataFrame
supplier_units_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(supplier_units_df, x='SupplierID', y='TotalUnitsOrdered',
             title='Total Units Ordered for Each Supplier',
             labels={'SupplierID': 'Supplier ID', 'TotalUnitsOrdered': 'Total Units Ordered'})

# Show the result to the user
show_to_user(fig)","The provided code meets the requirements of the business analytic request. It executes an SQL query to get the total units ordered for each supplier and visualizes the data using a bar chart created with Plotly. The SQL query retrieves the correct columns and aggregates the data correctly, and the final bar chart is labeled and displayed correctly to the user using the show_to_user function.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT S.SupplierID, SUM(OD.Quantity) AS TotalUnitsOrdered 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
JOIN suppliers S ON P.SupplierID = S.SupplierID 
GROUP BY S.SupplierID 
ORDER BY TotalUnitsOrdered DESC;
'''

# Execute the SQL query and retrieve the result into a pandas dataframe
data = execute_sql_query(sql_query)

# Create a bar chart to illustrate the data
fig = px.bar(data, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered for Each Supplier', labels={'SupplierID':'Supplier ID', 'TotalUnitsOrdered':'Total Units Ordered'})

# Show the bar chart to the user
show_to_user(fig)","The input Python code correctly executes the SQL query to obtain the total units ordered for each supplier and generates a bar chart to illustrate the data. The SQL logic, data retrieval, and chart generation functionalities are consistent with the reference implementation and the given business request.",both
Identify the orders that were placed but never shipped in 2022.,"import pandas as pd
import plotly.express as px

# Define the SQL query to identify orders placed but never shipped in 2022
sql_query = """"""
SELECT OrderID 
FROM orders 
WHERE ShippedDate IS NULL 
AND DATE_FORMAT(OrderDate, '%Y') = '2022'""""""

# Execute the SQL query to retrieve the data
orders_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(orders_df)
","sql_query = """"""
SELECT * 
FROM orders 
WHERE YEAR(OrderDate) = 2022 
AND ShippedDate IS NULL;
""""""

# Execute the SQL query to get the orders placed but never shipped in 2022
orders_not_shipped_2022 = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_not_shipped_2022)","The input Python code correctly identifies orders placed but never shipped in 2022. It uses an SQL query to filter for orders where the 'OrderDate' is in 2022 and 'ShippedDate' is NULL, retrieves this data using the 'execute_sql_query' function, and displays it to the user with the 'show_to_user' function. The main difference is that the input code selects all columns ('*') instead of just 'OrderID', but this still satisfies the business request.","import pandas as pd

def identify_unshipped_orders_2022():
    # SQL query to identify unshipped orders in 2022
    sql_query = """"""
    SELECT o.OrderID 
    FROM orders o 
    WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
    AND o.ShippedDate IS NULL;
    """"""
    
    # Execute the SQL query
    unshipped_orders_df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(unshipped_orders_df)

# Call the function to run the analysis and show the result
identify_unshipped_orders_2022()","The input Python code correctly identifies orders placed in 2022 but never shipped. It uses a SQL query that checks if the OrderDate is between '2022-01-01' and '2022-12-31' and if ShippedDate is NULL, which matches the intent of the business analytic request. The code then executes this query and displays the result using the provided utility functions.",both
What is the total revenue generated by each customer? Use a bar chart to visualize the revenue per customer.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID;'''

# Execute SQL query and retrieve the data
customer_revenue_df = execute_sql_query(sql_query)

# Plot the bar chart
fig = px.bar(customer_revenue_df, x='CustomerID', y='TotalRevenue', title='Total Revenue per Customer', labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue ($)'})

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total revenue generated by each customer  
sql_query = '''  
SELECT  
    c.CustomerID,  
    c.CompanyName,  
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue  
FROM  
    customers c  
JOIN  
    orders o ON c.CustomerID = o.CustomerID  
JOIN  
    [Order Details] od ON o.OrderID = od.OrderID  
GROUP BY  
    c.CustomerID, c.CompanyName  
'''  

# Execute the SQL query and retrieve the data  
revenue_df = execute_sql_query(sql_query)  

# Create a bar chart to visualize total revenue per customer  
fig = px.bar(revenue_df, x='CompanyName', y='TotalRevenue',  
             title='Total Revenue Generated by Each Customer',  
             labels={'CompanyName': 'Customer', 'TotalRevenue': 'Total Revenue'},  
             text='TotalRevenue')  

# Show the resulting visualization to the user  
show_to_user(fig)  
","The input Python code correctly queries the database for total revenue per customer, aggregates it, and visualizes the results using a bar chart. It uses the provided utility functions 'execute_sql_query' and 'show_to_user'. The SQL query and the logic align with the reference implementation and the business analytic request. The only difference is the inclusion of 'CompanyName' for a more user-friendly visualization, which is an acceptable enhancement.","To accomplish the task of retrieving the total revenue generated by each customer and visualizing it using a bar chart, I will write the Python code based on the given specifications.

Let's break down the solution:

1. Execute the SQL query to get the total revenue per customer.
2. Convert the result into a pandas DataFrame.
3. Use matplotlib to create a bar chart for visualization.

Here's the step-by-step Python code:

```python
import pandas as pd
import plotly.express as px

# SQL query to get the total revenue per customer
sql_query = '''
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;'''

# Execute the SQL query
data = execute_sql_query(sql_query)

# Visualize the revenue per customer using a bar chart
fig = px.bar(data, x='CustomerID', y='TotalRevenue', title='Total Revenue per Customer', labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue'})

# Display the plot to the user
show_to_user(fig)
```

### Breakdown:
- **execute_sql_query(sql_query)**: This function is used to run the SQL query and get the data in a pandas DataFrame format.
- **px.bar(...)**: Plotly Express is used to create an interactive bar chart. It allows zooming, and hovering over bars gives more details.
- **show_to_user(fig)**: This is used to render the figure for the user to view.

Make sure you have Plotly installed in your environment; if not, you can install it via pip:
```bash
pip install plotly
```",The input Python code closely matches the reference implementation. It correctly uses the execute_sql_query function to retrieve data from the SQL database and uses Plotly Express to create a bar chart. The show_to_user function is then correctly used to display the resulting figure. The code adheres to the given business analytic request and Python environment constraints.,both
What is the total sales revenue generated in the month of January 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query and get the result dataframe
df = execute_sql_query(sql_query)

# Check if df has data before displaying
if not df.empty:
    # Display the total sales revenue to the user
    show_to_user(df)
else:
    show_to_user(pd.DataFrame({'TotalSales': [0]}))
","import pandas as pd

# Define the SQL query to calculate total sales revenue for January 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01' """"""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The given Python code correctly follows the business analytic request and Python environment constraint. The SQL query calculates the total sales revenue for January 2023, and the results are displayed using the `show_to_user` function similar to the reference implementation. The slight difference in date range does not impact the correctness as both effectively cover January 2023.","import pandas as pd
import plotly.express as px

# SQL query to get the total sales revenue for the month of January 2023
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';
'''

# Execute the SQL query
try:
    sales_df = execute_sql_query(sql_query)
    # Display the result to the user
    show_to_user(sales_df)
except Exception as e:
    print(f'Error occurred: {e}')","The input code correctly follows the business analytic request to calculate the total sales revenue generated in January 2023. It uses the provided utility functions `execute_sql_query` to run the query and `show_to_user` to display the result. The SQL query logic is accurate and corresponds to the given dates and calculation requirements. Additionally, the code properly handles exceptions during the SQL execution.",both
What is the total quantity of each product sold? Include a bar chart to better illustrate the results.,"
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(result_df, x='ProductID', y='TotalQuantity', title='Total Quantity of Each Product Sold', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})

# Display the result to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to get total quantity of each product sold
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) as TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

# Execute the SQL query and retrieve the data
product_sales_df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the results
fig = px.bar(product_sales_df, x='ProductName', y='TotalQuantity', title='Total Quantity of Each Product Sold',
             labels={'TotalQuantity': 'Total Quantity Sold', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)",The input code correctly follows the given business analytic request to calculate the total quantity of each product sold. It also includes a bar chart to visualize the results and appropriately uses the execute_sql_query and show_to_user utility functions as defined in the Python environment constraints.,"import pandas as pd
import plotly.express as px

# Define the SQL query
total_quantity_sql = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName;
'''

# Execute the SQL query and retrieve the data
data = execute_sql_query(total_quantity_sql)

# Create a bar chart using plotly
fig = px.bar(data, x='ProductName', y='TotalQuantitySold', title='Total Quantity of Each Product Sold', labels={'ProductName': 'Product Name', 'TotalQuantitySold': 'Total Quantity Sold'})

# Display the bar chart to the user
show_to_user(fig)","The input code correctly executes the SQL query to retrieve the total quantity of each product sold, visualizes the results using a bar chart with plotly, and displays the chart using the show_to_user function. It matches the intent of the business analytic request and the reference implementation.",both
What are the top 5 customers by order value? Visualize this using a bar chart.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalOrderValue 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5;''' 

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(result_df, x='CustomerID', y='TotalOrderValue', title='Top 5 Customers by Order Value', labels={'CustomerID':'Customer ID', 'TotalOrderValue':'Total Order Value'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total order value per customer
sql_query = '''
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue
FROM customers AS c
JOIN orders AS o ON c.CustomerID = o.CustomerID
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalOrderValue DESC
LIMIT 5
'''

# Execute the SQL query and retrieve the data
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_customers_df, x='CompanyName', y='TotalOrderValue',
             title='Top 5 Customers by Order Value',
             labels={'TotalOrderValue':'Total Order Value', 'CompanyName':'Customer Name'})

# Show visualization to the user
show_to_user(fig)","The provided input code correctly follows the business analytic request to find the top 5 customers by order value and visualizes the result using a bar chart. Additionally, the use of CompanyName in the chart's x-axis improves the readability of the bar chart. It adheres to the provided Python environment constraints by using the provided utility functions, execute_sql_query and show_to_user.","import pandas as pd
import plotly.express as px

# Step 1: Define SQL query to get the top 5 customers by order value
sql_query = '''
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5;
'''

# Step 2: Execute the SQL query using the provided utility function
orders_df = execute_sql_query(sql_query)

# Step 3: Create bar chart using Plotly Express
fig = px.bar(orders_df, x='CustomerID', y='TotalOrderValue', title='Top 5 Customers by Order Value', labels={'CustomerID': 'Customer ID', 'TotalOrderValue': 'Total Order Value'})

# Step 4: Display the result to the user
show_to_user(fig)","The input Python code correctly defines a SQL query to retrieve the top 5 customers by order value, executes the query using the provided utility function, and visualizes the results using a Plotly bar chart. The implementation matches the reference closely and adheres to the provided constraints.",both
How many products are in each category? Include a pie chart to better illustrate the products per category.,"import plotly.express as px

# SQL Query
sql_query = 'SELECT CategoryID, COUNT(ProductID) AS ProductCount FROM products GROUP BY CategoryID;'

# Execute the SQL query to retrieve data
products_per_category_df = execute_sql_query(sql_query)

# Create a pie chart to illustrate the products per category
fig = px.pie(products_per_category_df, names='CategoryID', values='ProductCount', title='Products per Category')

# Show the pie chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count products in each category
sql_query = '''
SELECT CategoryID, COUNT(*) as ProductCount
FROM products
WHERE Discontinued = 0
GROUP BY CategoryID
'''  

# Execute the SQL query and get the result in a dataframe
product_counts_df = execute_sql_query(sql_query)

# Create a pie chart to illustrate the product counts per category
fig = px.pie(product_counts_df, names='CategoryID', values='ProductCount', title='Products per Category')

# Show the data and the pie chart to the user
show_to_user(product_counts_df)
show_to_user(fig)","The input Python code correctly satisfies the business analytic request which is to find the number of products in each category and visualize it in a pie chart. It meets the Python environment constraints by using the provided utility functions execute_sql_query and show_to_user, and the output will be similar to the reference implementation.","import plotly.express as px

# Define the SQL query
sql_query = ""SELECT CategoryID, COUNT(*) as ProductCount FROM products GROUP BY CategoryID;""

# Execute the SQL query to obtain the data
product_counts = execute_sql_query(sql_query)

# Generate a pie chart to visualize the products per category
fig = px.pie(product_counts, names='CategoryID', values='ProductCount', title='Products per Category')

# Display the pie chart to the user
show_to_user(fig)","The input Python code correctly follows the Python environment constraints, executes the required SQL query, and generates a pie chart to visualize the products per category. The SQL query, dataframe manipulation, and plotting steps are consistent with the reference implementation.",both
Identify the employees who report to each manager.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT Manager.LastName AS ManagerLastName, Manager.FirstName AS ManagerFirstName, 
       Subordinate.LastName AS EmployeeLastName, Subordinate.FirstName AS EmployeeFirstName 
FROM employees AS Subordinate 
JOIN employees AS Manager ON Subordinate.ReportsTo = Manager.EmployeeID;
'''

# Execute the SQL query
employee_manager_df = execute_sql_query(sql_query)

# Check the result
print(employee_manager_df.head())  # Optional: To display the top rows of the dataframe

# Show the result to the user
show_to_user(employee_manager_df)","import pandas as pd

# SQL query to identify employees who report to each manager
sql_query = '''
SELECT e1.FirstName AS ManagerFirstName, e1.LastName AS ManagerLastName, e2.FirstName AS EmployeeFirstName, e2.LastName AS EmployeeLastName
FROM employees e1
LEFT JOIN employees e2 ON e1.EmployeeID = e2.ReportsTo
WHERE e1.Title LIKE '%Manager%';
'''  

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)","The input Python code uses a LEFT JOIN and filters managers based on their title containing 'Manager'. This assumes the title explicitly includes 'Manager', which might not be the case for all managers. Additionally, the LEFT JOIN is unnecessary since the goal is to find direct reports to each manager, where an INNER JOIN is more appropriate. The reference implementation correctly joins the employees table on ReportsTo field without assumptions on the title.","import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to get the managers and employees data
sql_query = '''
SELECT m.EmployeeID AS ManagerID, e.EmployeeID AS EmployeeID
FROM employees e
JOIN employees m ON e.ReportsTo = m.EmployeeID;
'''
data = execute_sql_query(sql_query)

# Step 2: Visualize the data
fig = px.sunburst(data, path=['ManagerID', 'EmployeeID'], title='Employee Reporting Structure')

# Step 3: Display the visualization to the user
show_to_user(fig)

# Additionally, let's display the raw data as a DataFrame
show_to_user(data)","The input Python code correctly identifies the relationship between employees and managers, but it doesn't provide the same level of detail as the reference implementation. Instead of listing full names, it only returns EmployeeID and ManagerID. Additionally, the visual structure using a sunburst plot, although a good attempt at visualization, might be too complex for identifying specific employees reporting to each manager compared to the dataframe provided in the reference implementation.",None
Which employee generated the most sales in the last year? Include a bar chart visualization to better illustrate this.,"import pandas as pd
import plotly.express as px

# SQL query to find the employee who generated the most sales in the last year.
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = YEAR(CURDATE())
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the SQL query and get the result into a pandas dataframe.
df = execute_sql_query(sql_query)

# Validate if the dataframe is not empty
if df.empty:
    raise ValueError('The query returned no results. Please check the data or query.')

# Bar chart visualization of the employee with the highest sales.
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Employee with the Most Sales in the Last Year')

# Display the bar chart visualization to the user.
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales generated by each employee in the last year
sql_query = '''
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
''' 

# Execute the SQL query and get the data into a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Identify the employee with the most sales
top_employee = sales_data.iloc[0]

# Prepare data for bar chart visualization
fig = px.bar(sales_data, x='EmployeeName', y='TotalSales', title='Employee Sales in the Last Year',
             labels={'TotalSales': 'Sales Amount', 'EmployeeName': 'Employee'},
             text='TotalSales')

# Show the bar chart to the user
show_to_user(fig) 

# Print information about the top employee
print(f'The employee who generated the most sales in the last year is {top_employee.EmployeeName} with ${top_employee.TotalSales:.2f} in sales.')","The input Python code correctly retrieves the employee with the most sales over the last year and creates a bar chart visualization. While the SQL query is slightly different, both versions correctly calculate total sales and order them by the highest amount. The input code additionally includes employee names, which is acceptable. It prints the top employee's information and displays a labeled bar chart, fully addressing the business analytic request.","import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW()
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY TotalSales DESC
'''  # Use correct SQL syntax

# Execute the SQL query
employee_sales_df = execute_sql_query(sql_query)

# Extract the top employee (assuming you want the single top performer)
top_employee_sales_df = employee_sales_df.head(1)

# Visualization
fig = px.bar(employee_sales_df, 
             x='EmployeeID', 
             y='TotalSales', 
             hover_data=['FirstName', 'LastName'], 
             title='Top Employee Sales in the Last Year', 
             labels={'TotalSales':'Total Sales ($)', 'EmployeeID':'Employee ID'})

# Display the result
show_to_user(fig)

# Additionally, show the top employee sales data
show_to_user(top_employee_sales_df)","The provided Python code correctly addresses the business analytic request. It correctly retrieves the employee who generated the most sales in the last year and presents it along with a bar chart visualization. The SQL query is well-formed and retrieves necessary data, including employee details, and the visualization part appropriately displays the results using plotly. The additional display of the top employeeâ€™s data also aligns with the business request.",both
Which products need to be reordered soon?,"import pandas as pd
import plotly.express as px

def get_products_to_reorder():
    sql_query = ''' 
    SELECT products.ProductName 
    FROM products 
    WHERE products.UnitsInStock <= products.ReorderLevel;
    '''
    
    # Execute the SQL query to retrieve the data
    df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(df)
    
    # Check if the dataframe is not empty before plotting
    if not df.empty:
        # Optionally, we can also visualize the number of products to be reordered
        fig = px.bar(df, x='ProductName', title='Products to Reorder')
        show_to_user(fig)

# Call the function to execute the process
get_products_to_reorder()","import pandas as pd

# SQL query to find products that need to be reordered soon
sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;
'''

# Execute the query and retrieve the data
products_to_reorder = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(products_to_reorder)","The provided code correctly follows the requirements outlined in the business analytic request. It generates an SQL query to select products that need to be reordered (with UnitsInStock less than or equal to ReorderLevel and not Discontinued) and then executes the query using the execute_sql_query function. The resulting data is displayed using the show_to_user function. While it does not include the optional step to visualize data as a bar chart, it still meets the primary requirement of identifying and displaying products that need to be reordered soon.","import pandas as pd

# SQL query to find products that need to be reordered soon
sql_query = ""SELECT ProductID FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query
reorder_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(reorder_products_df)","The input code correctly executes the SQL query to find products that need to be reordered, and it displays the result using the show_to_user function. However, it incorrectly selects 'ProductID' instead of 'ProductName' and does not include the optional plotly visualization that is part of the reference implementation. To adhere to both displaying the results and providing the visualization, it would need to be updated.",Base
How many orders did each employee handle in the first quarter of this year? Include a bar chart for better illustration.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID;
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(result_df, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Each Employee in Q1 2023', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to count orders handled by each employee in Q1 of this year
sql_query = '''
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OrderCount
FROM employees
LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE orders.OrderDate >= '2023-01-01' AND orders.OrderDate <= '2023-03-31'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
'''  

# Execute the SQL query and store the result in a DataFrame
employee_orders = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(employee_orders, x='FirstName', y='OrderCount', color='LastName', title='Orders Handled by Employees in Q1 2023',
             labels={'FirstName': 'Employee First Name', 'OrderCount': 'Number of Orders'})

# Show the result to the user
show_to_user(fig)","The provided Python code correctly follows the instructions and generates the required data and visualization. It uses an appropriate SQL query to retrieve the number of orders handled by each employee in the first quarter of the year and creates a bar chart using Plotly to illustrate the distribution. Although it slightly differs from the reference implementation by including additional fields (FirstName and LastName) and using them in the Plotly chart, it ultimately fulfills the business analytic request accurately and meets the Python environment constraints.","import pandas as pd
import plotly.express as px

# SQL Query to get the number of orders each employee handled in the first quarter
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS Q1_Orders 
FROM orders o 
JOIN employees e ON o.EmployeeID = e.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID
'''

# Execute the SQL query and fetch the data
orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_df, x='EmployeeID', y='Q1_Orders', title='Employee Orders in Q1 2023')

# Show the bar chart to the user
show_to_user(fig)","The input code correctly fetches the number of orders handled by each employee in the first quarter of the year, aggregates this data by employee ID, and displays it using a bar chart. It follows the Python environment constraints and provides the required business analytic results.",both
"What is the total sales for each product category this year, and can you provide a bar chart to visualize the results?","import pandas as pd
import plotly.express as px

# SQL query to get total sales for each product category this year
sql_query = '''
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY categories.CategoryName
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(sales_data, x='CategoryName', y='TotalSales', title='Total Sales for Each Product Category This Year', labels={'CategoryName': 'Product Category', 'TotalSales': 'Total Sales'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define SQL query to get total sales for each product category this year
sql_query = """"""
SELECT 
    p.CategoryID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    YEAR(o.OrderDate) = YEAR(CURDATE())
GROUP BY 
    p.CategoryID
""""""

# Execute the SQL query and retrieve data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales for each product category
fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Total Sales for Each Product Category This Year',
             labels={'CategoryID': 'Product Category', 'TotalSales': 'Total Sales'},
             color='TotalSales',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the visualization to the user
show_to_user(fig)","The input code does not retrieve the category names, only the category IDs. The business analytic request and the reference code both require the category names to be displayed on the bar chart. The input code should join on the 'categories' table to get the 'CategoryName' and adjust the SQL query accordingly.","import pandas as pd
import plotly.express as px

# SQL query to get total sales for each product category this year
sql_query = '''
SELECT p.CategoryID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) 
GROUP BY p.CategoryID
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Rename columns for clarity
df.columns = ['CategoryID', 'TotalSales']

# Create a bar chart using plotly
fig = px.bar(df, x='CategoryID', y='TotalSales', title='Total Sales for Each Product Category This Year', labels={'CategoryID':'Product Category', 'TotalSales':'Total Sales'})

# Display the result to the user
show_to_user(fig)","The input code does not retrieve or use category names, which are required for the business request. The reference implementation uses category names (CategoryName) instead of category IDs (CategoryID), and the output bar chart labels need to reflect the product categories by name, not ID. Additionally, the input code does not perform a join with the categories table to get the category names.",None
"Find the total freight cost for all orders shipped via each shipping method in 2022, and create a pie chart to illustrate the distribution.","import plotly.express as px

# Define the SQL query
sql_query = '''
    SELECT ShipVia, SUM(Freight) AS TotalFreight
    FROM orders
    WHERE YEAR(OrderDate) = 2022
    GROUP BY ShipVia;
'''

# Execute the SQL query to get the data
freight_data = execute_sql_query(sql_query)

# Check if the resulting dataframe is empty
if freight_data.empty:
    raise ValueError('No freight data found for the year 2022')

# Create a pie chart using plotly express
fig = px.pie(freight_data, values='TotalFreight', names='ShipVia', title='Total Freight Cost by Shipping Method in 2022')

# Display the pie chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total freight costs by shipping method for orders shipped in 2022
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
WHERE YEAR(OrderDate) = 2022
GROUP BY ShipVia
""""""

# Execute SQL query and retrieve the data into a DataFrame
freight_data = execute_sql_query(sql_query)

# Create a pie chart to visualize the distribution of total freight cost
fig = px.pie(freight_data, names='ShipVia', values='TotalFreight', title='Total Freight Cost Distribution by Shipping Method in 2022')

# Display the pie chart to the user
show_to_user(fig)","The input Python code correctly follows the business analytic request and matches the output of the reference implementation. It retrieves the required data using the correct SQL query, processes it into a DataFrame, and creates a pie chart to visualize the distribution of total freight cost by shipping method for orders shipped in 2022. The utility functions execute_sql_query and show_to_user are appropriately used, and the resulting pie chart is displayed to the user.","import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY ShipVia
""""""

# Execute the SQL query
freight_data = execute_sql_query(sql_query)

# Ensure the DataFrame has the right columns
if 'ShipVia' not in freight_data.columns or 'TotalFreight' not in freight_data.columns:
    raise ValueError('The resultant DataFrame does not contain the required columns.')

# Create a pie chart using plotly
fig = px.pie(freight_data, names='ShipVia', values='TotalFreight', title='Total Freight Cost by Shipping Method in 2022')

# Display the pie chart to the user
show_to_user(fig)","The input Python code correctly implements the SQL query to retrieve the total freight cost for each shipping method in 2022. It ensures the resulting dataframe has the required columns, creates a pie chart using plotly express, and displays the chart to the user. The differences between the input and reference code are minor and do not affect the correctness of the code.",both
What are the five cities with the highest total sales? Can you provide a bar chart to visualize this information?,"import plotly.express as px

# Define the SQL Query
sql_query = '''
SELECT ShipCity, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY ShipCity
ORDER BY TotalSales DESC
LIMIT 5;
'''

# Execute the SQL query to get the dataframe
sales_df = execute_sql_query(sql_query)

# Create the bar chart using Plotly Express
fig = px.bar(sales_df, x='ShipCity', y='TotalSales', title='Top 5 Cities with Highest Total Sales', labels={'ShipCity':'City', 'TotalSales':'Total Sales'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales by city
sql_query = '''
SELECT o.ShipCity, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN employees e ON o.EmployeeID = e.EmployeeID
GROUP BY o.ShipCity
ORDER BY TotalSales DESC
LIMIT 5;
'''  

# Execute the SQL query
city_sales = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(city_sales, x='ShipCity', y='TotalSales', title='Top 5 Cities with Highest Total Sales', labels={'ShipCity': 'City', 'TotalSales': 'Total Sales'})

# Show the chart to the user
show_to_user(fig)","The given input Python code correctly queries the database for the top five cities with the highest total sales, creates a bar chart using Plotly Express, and displays the chart to the user. The implementation follows the provided utility function constraints and closely matches the reference implementation.","import plotly.express as px

# SQL query to find the five cities with the highest total sales
sql_query = '''
SELECT c.City, SUM(o.Total) AS TotalSales
FROM customers c
INNER JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.City
ORDER BY TotalSales DESC
LIMIT 5;
'''

# Execute the query and retrieve the results
results_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(results_df, x='City', y='TotalSales', title='Top 5 Cities with Highest Total Sales', labels={'City': 'City', 'TotalSales': 'Total Sales'})

# Display the bar chart to the user
show_to_user(fig)
","The input code correctly addresses the business analytic request by querying the top five cities with the highest total sales. It uses a SQL query to retrieve the required data, processes it into a DataFrame, and then creates a bar chart using Plotly Express. The generated visualization matches the expectation, and the semantics of the SQL query are appropriate for the task.",both
"Calculate the total number of units ordered for each product category, and represent this data using a bar chart.","
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
INNER JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryID;
'''

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(results_df, x='CategoryID', y='TotalUnitsOrdered', 
             title='Total Units Ordered per Product Category', 
             labels={'CategoryID': 'Product Category', 'TotalUnitsOrdered': 'Total Units Ordered'})

# Display the bar chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to calculate total units ordered for each product category
sql_query = '''
SELECT p.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
'''

# Execute the SQL query
units_ordered_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(units_ordered_df, x='CategoryID', y='TotalUnitsOrdered',
             title='Total Units Ordered for Each Product Category',
             labels={'CategoryID': 'Product Category ID', 'TotalUnitsOrdered': 'Total Units Ordered'})

# Show the result to the user
show_to_user(fig)","The input code is not grouping by CategoryID from the categories table. The reference implementation joins the categories table, ensuring accuracy.","import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CategoryName, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN categories c ON p.CategoryID = c.CategoryID  -- Added join for category table
GROUP BY c.CategoryName;
'''

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Generate the bar chart using plotly
fig = px.bar(data, x='CategoryName', y='TotalUnitsOrdered', title='Total Units Ordered per Product Category', labels={'CategoryName':'Product Category', 'TotalUnitsOrdered':'Total Units Ordered'})

# Show the bar chart to the user
show_to_user(fig)","The input code correctly calculates the total number of units ordered for each product category and visualizes it using a bar chart. It uses the same logic of joining the relevant tables and summing the quantity as the reference code, but groups by CategoryName instead of CategoryID. The code follows the Python environment constraints and the business analytic request, albeit with a different grouping column.",Finetuned
What is the monthly trend of order placements for the current year? Please include a line graph to illustrate the trend.,"import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT MONTH(OrderDate) AS Month, COUNT(*) AS NumberOfOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY MONTH(OrderDate);
'''

# Execute the SQL query and get the data
order_data = execute_sql_query(sql_query)

# Ensure the Month column is treated as integer for correct sorting
order_data['Month'] = order_data['Month'].astype(int)

# Sort the data by Month to ensure the line graph is in chronological order
order_data = order_data.sort_values(by='Month')

# Create the line graph using plotly
fig = px.line(order_data, x='Month', y='NumberOfOrders', title='Monthly Trend of Order Placements for the Current Year')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve monthly order count for the current year
sql_query = '''
SELECT  
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,  
    COUNT(OrderID) AS OrderCount  
FROM orders  
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE)  
GROUP BY OrderMonth  
ORDER BY OrderMonth;  
''' 

# Execute the SQL query and load the data into a DataFrame
data = execute_sql_query(sql_query)

# Generate a line graph to illustrate the monthly trend of order placements
fig = px.line(data, x='OrderMonth', y='OrderCount', title='Monthly Trend of Order Placements for Current Year', markers=True)

# Show the visual to the user
show_to_user(fig)","The input code meets the business analytic request. It correctly retrieves the monthly order data for the current year, groups it by month, and presents it in a line graph using Plotly. The code matches the reference implementation in terms of functionality, despite minor differences in SQL query formatting and column naming.","import pandas as pd
import plotly.express as px

# Define the SQL query based on the business request
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY Month 
ORDER BY Month;
'''

# Execute the SQL query to retrieve the data
order_data = execute_sql_query(sql_query)

# Ensure 'Month' column is treated as datetime type for proper sorting and plotting
order_data['Month'] = pd.to_datetime(order_data['Month'] + '-01')

# Create the line graph for the monthly trend
fig = px.line(order_data, x='Month', y='OrderCount', title='Monthly Trend of Order Placements for the Current Year', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})

# Display the result to the user
show_to_user(fig)","The given input code correctly retrieves and processes the necessary data to illustrate the monthly trend of order placements for the current year using a line graph, meeting the business analytic request. While the approach to formatting the 'Month' column differs slightly between the reference and input implementations, both effectively achieve the same goal and follow the constraints provided.",both
How long has each employee been working at the company?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT employees.EmployeeID, DATEDIFF(CURDATE(), employees.HireDate) AS DaysWorked FROM employees;'

# Execute the SQL query to retrieve the data
employee_data = execute_sql_query(sql_query)

# Ensure the data is sorted by EmployeeID
employee_data = employee_data.sort_values(by='EmployeeID')

# Display the result to the user using the provided utility function
show_to_user(employee_data)","import pandas as pd

# SQL query to get the HireDate and calculate the tenure of each employee
sql_query = '''
SELECT EmployeeID, FirstName, LastName, HireDate, 
       DATEDIFF(CURDATE(), HireDate) AS TenureDays
FROM employees
'''  

# Execute the SQL query to retrieve employee data
employee_data = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(employee_data)",The provided code correctly calculates the tenure of each employee in days using the DATEDIFF function and retrieves the relevant data from the employees table. The data is then displayed to the user using the show_to_user function. The code meets the specified Python environment constraints and aligns with the business analytic request.,"
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT e.EmployeeID, DATEDIFF(CURDATE(), e.HireDate) as Tenure FROM employees e;""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Calculate Tenure in years
df['Tenure'] = df['Tenure'] / 365

# Display the result to the user
show_to_user(df)
","The input Python code calculates and displays tenure in years, while the business analytic request requires days worked.",Base
Which products need reordering?,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;'

# Execute the SQL query
data = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(data)
","import pandas as pd

# SQL query to select products that need reordering
sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, UnitsOnOrder, ReorderLevel
FROM products
WHERE Discontinued = 0 AND (UnitsInStock + UnitsOnOrder) <= ReorderLevel
'''

# Executing the SQL query
reorder_products = execute_sql_query(sql_query)

# Display the products that need reordering to the user
show_to_user(reorder_products)","The input Python code does not satisfy the given business analytic request because it modifies the SQL query by including additional conditions (Discontinued = 0 and including UnitsOnOrder in the inventory check) that are not present in the reference implementation. Additionally, the query needs to ensure that units in stock alone (without adding units on order) are less than or equal to the reorder level.","import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL Query
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;'
products_to_reorder = execute_sql_query(sql_query)

# Step 2: Display the Results
show_to_user(products_to_reorder)","The input Python code correctly implements the business analytic request by executing an SQL query to identify products that need reordering based on the condition 'UnitsInStock < ReorderLevel'. The results are then displayed to the user using the 'show_to_user' function. The SQL query condition is slightly different from the reference code ('<= ReorderLevel' vs '< ReorderLevel'), but this difference is minor and still valid for solving the request.",Finetuned
How many products have a reorder level higher than 20?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS HighReorderProducts FROM products WHERE ReorderLevel > 20;""

# Execute the SQL query and get the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the count of high reorder products to the user
show_to_user(result_df.iloc[0, 0])","import pandas as pd

# SQL query to find the number of products with a reorder level higher than 20
sql_query = """"""
SELECT COUNT(*) AS NumberOfProducts 
FROM products 
WHERE ReorderLevel > 20
""""""

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The code provided to evaluate is almost correct but not quite so. The issue lies in the final step where the result is shown to the user. Instead of showing the dataframe directly, it should extract and show the relevant count value from the dataframe, similar to the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT COUNT(*) AS CountAboveReorderLevel FROM products WHERE ReorderLevel > 20;'

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code uses 'show_to_user(result_df)' to display the result dataframe, which is not correct as per the business request. It should instead display 'result_df.iloc[0, 0]', which extracts the count value from the dataframe.",None
Find the customers who have not placed any orders in the current year.,"# Importing necessary library
import pandas as pd

# SQL query to find customers who have not placed any orders in the current year
sql_query = '''
SELECT CustomerID 
FROM customers 
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID 
    FROM orders 
    WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
);'''

# Execute the SQL query
customers_no_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_no_orders_df)
","import pandas as pd

# Define the current year
from datetime import datetime
current_year = datetime.now().year

# SQL query to find customers who have not placed any orders in the current year
sql_query = f""""""
SELECT DISTINCT c.CustomerID
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE YEAR(o.OrderDate) IS NULL OR YEAR(o.OrderDate) <> {current_year}
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(result_df)","The input Python code is incorrect because it fails to accurately find customers who have not placed any orders in the current year. By using a LEFT JOIN and the condition YEAR(o.OrderDate) IS NULL OR YEAR(o.OrderDate) <> {current_year}, it can include customers who have placed orders outside the current year, which shouldn't be filtered out. The correct approach is to use an EXCEPT or NOT IN clause as shown in the reference Python code to exclude those customers who have placed orders in the current year.","import pandas as pd
import plotly.express as px

# Function to find customers who have not placed any orders in the current year

# Define the SQL query
current_year = pd.to_datetime('today').year
current_year_query = f""""""
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o 
ON c.CustomerID = o.CustomerID 
WHERE o.OrderID IS NULL 
OR YEAR(o.OrderDate) < {current_year}
""""""

# Execute the query to get the dataframe
customers_no_orders_df = execute_sql_query(current_year_query)

# Display the result
show_to_user(customers_no_orders_df)
","The input Python code does not correctly identify customers who have not placed any orders in the current year. It uses a LEFT JOIN with conditions that may incorrectly include customers who placed orders in previous years and uses 'YEAR(o.OrderDate) < {current_year}' which is not exactly equivalent to 'OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)'. The reference implementation uses a simpler and correct subquery to identify such customers.",None
Identify the top 5 customers who have incurred the highest total freight costs. Can you also include a bar chart to show this data?,"import plotly.express as px
import pandas as pd

# SQL Query to get the top 5 customers by total freight costs
sql_query = '''
SELECT CustomerID, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY CustomerID 
ORDER BY TotalFreight DESC 
LIMIT 5;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(result_df, x='CustomerID', y='TotalFreight', title='Top 5 Customers by Total Freight Costs', labels={'CustomerID': 'Customer ID', 'TotalFreight': 'Total Freight Cost'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to find the top 5 customers by total freight costs
sql_query = '''
SELECT CustomerID, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY CustomerID
ORDER BY TotalFreight DESC
LIMIT 5
'''

# Execute the SQL query and retrieve the data
freight_data = execute_sql_query(sql_query)

# Create a bar chart with the results
fig = px.bar(freight_data, x='CustomerID', y='TotalFreight', 
             title='Top 5 Customers by Total Freight Costs', 
             labels={'CustomerID': 'Customer ID', 'TotalFreight': 'Total Freight Cost'})

# Show the bar chart to the user
show_to_user(fig)","The input Python code correctly executes the SQL query to find the top 5 customers by total freight costs, retrieves the data, and uses Plotly to create a bar chart. It adheres to the specified Python environment constraints and matches the logic of the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT CustomerID, SUM(Freight) AS TotalFreight FROM orders GROUP BY CustomerID ORDER BY TotalFreight DESC LIMIT 5;'

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='TotalFreight', title='Top 5 Customers by Total Freight Costs')

# Display the resulting bar chart to the user
show_to_user(fig)","The input Python code correctly follows the Python environment constraint and provides a valid implementation to answer the business analytic request. It executes the appropriate SQL query, retrieves the required data, and visualizes it using plotly, matching the reference implementation in functionality.",both
How many units of each product were sold in the first quarter of 2023? Can you provide a bar chart to visualize this data?,"import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS units_sold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY products.ProductID
""""""

# Execute the SQL query and get the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(sales_data, x='ProductID', y='units_sold', title='Units Sold per Product in Q1 2023', labels={'ProductID': 'Product ID', 'units_sold': 'Units Sold'})

# Display the bar chart
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the number of units sold for each product in the first quarter of 2023
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Quantity) AS UnitsSold
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductName
''' 

# Execute the SQL query and get the dataframe
units_sold_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(units_sold_df, x='ProductName', y='UnitsSold', title='Units Sold per Product in Q1 2023', labels={'UnitsSold': 'Units Sold', 'ProductName': 'Product Name'})

# Display the figure to the user
show_to_user(fig)","The provided code correctly fulfills the business analytic request by querying the number of units sold for each product in the first quarter of 2023 and visualizing the data in a bar chart using Plotly. It follows the given Python environment constraints and differs only slightly from the reference implementation by using 'ProductName' instead of 'ProductID', which is acceptable as long as product names are unique.","
import plotly.express as px
import pandas as pd

# SQL query to get the product sales in the first quarter of 2023
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalUnitsSold 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY p.ProductName;
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Creating a bar chart using Plotly
fig = px.bar(sales_data, x='ProductName', y='TotalUnitsSold', title='Units Sold per Product in Q1 2023', labels={'ProductName': 'Product Name', 'TotalUnitsSold': 'Total Units Sold'})

# Display the bar chart to the user
show_to_user(fig)
","The provided implementation is correct. It uses the execute_sql_query to retrieve the sales data for Q1 2023 grouped by product name. Then, it uses Plotly to create a bar chart to visualize this data. The code aligns with the specified utility functions and the given business requirement.",both
How many orders were shipped via each shipping method in 2023? Please include a pie chart to represent this information.,"import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY ShipVia
""""""

# Execute the SQL query to retrieve the data
orders_df = execute_sql_query(sql_query)

# Create a pie chart using plotly
fig = px.pie(orders_df, names='ShipVia', values='OrderCount', title='Orders Shipped via Each Shipping Method in 2023')

# Display the pie chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the count of orders shipped via each shipping method in 2023
sql_query = '''
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
WHERE ShippedDate >= '2023-01-01' AND ShippedDate < '2024-01-01'
GROUP BY ShipVia
'''

# Executing the SQL query
shipping_data = execute_sql_query(sql_query)

# Creating a pie chart to visualize the order counts by shipping method
fig = px.pie(shipping_data, names='ShipVia', values='OrderCount', title='Orders Shipped by Shipping Method in 2023')

# Showing the result to the user
show_to_user(fig)","The input Python code correctly retrieves the count of orders shipped using different shipping methods in 2023 and creates a pie chart to visualize this information. The SQL query is correctly constructed for the given date range, and the code utilizes the provided utility functions correctly.","import pandas as pd
import plotly.express as px

def main():
    # Define the SQL query
    sql_query = '''
    SELECT ShipVia, COUNT(OrderID) AS OrdersCount
    FROM orders
    WHERE YEAR(OrderDate) = 2023
    GROUP BY ShipVia
    '''

    # Execute the SQL query
    orders_data = execute_sql_query(sql_query)

    # Create a pie chart using plotly
    fig = px.pie(orders_data, names='ShipVia', values='OrdersCount', title='Orders Shipped via Each Shipping Method in 2023', hole=0.3)

    # Show the pie chart to the user
    show_to_user(fig)

if __name__ == '__main__':
    main()","The input code correctly implements the business analytic request. It defines the correct SQL query, executes it to retrieve the data, and generates a pie chart using Plotly to visualize the distribution of orders shipped via each method in 2023. It also uses the provided utility functions execute_sql_query and show_to_user as required by the environment constraints.",both
How many orders were placed each month in the current year? Provide a line graph to show the monthly order placements.,"import pandas as pd
import plotly.express as px

# SQL query to retrieve the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY OrderMonth 
ORDER BY OrderMonth;
""""""

# Execute the SQL query and store the result in a DataFrame
order_data = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(order_data, x='OrderMonth', y='TotalOrders', title='Monthly Orders for the Current Year', labels={'OrderMonth': 'Month', 'TotalOrders': 'Number of Orders'})

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count orders each month in the current year
current_year = pd.Timestamp.now().year
sql_query = f""""""
SELECT DATE_TRUNC('month', OrderDate) AS month, COUNT(OrderID) AS order_count
FROM orders
WHERE DATE_PART('year', OrderDate) = {current_year}
GROUP BY month
ORDER BY month;
""""""

# Execute the SQL query
monthly_orders = execute_sql_query(sql_query)

# Create a line graph
fig = px.line(monthly_orders, x='month', y='order_count',
              title='Monthly Orders in {current_year}',
              labels={'month': 'Month', 'order_count': 'Number of Orders'})

# Display the graph to the user
show_to_user(fig)","The Input Python Code To Evaluate correctly follows the outlined Python environment constraints, uses the provided utility functions, and addresses the business analytic request to count and visualize monthly orders in the current year. The SQL query correctly matches the reference code in function and intention, and the graph creation and display are properly implemented.","import pandas as pd
import plotly.express as px

# SQL query to fetch the number of orders placed each month in the current year
sql_query = """"""
SELECT MONTH(OrderDate) AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Creating a line graph to show monthly order placements
fig = px.line(orders_df, x='Month', y='OrderCount', title='Monthly Order Placements in Current Year', labels={'Month': 'Month', 'OrderCount': 'Number of Orders'})

# Display the line graph to the user
show_to_user(fig)","The provided input code fetches the number of orders placed each month in the current year correctly and creates a line graph similar to the reference implementation. Both versions retrieve data for the current year, group them by month, count the orders, and visualize the result using Plotly. Despite minor differences in column names and date formatting, the output logic matches the business analytic request and constraints.",both
Which product had the highest average discount?,"import pandas as pd
# Define the SQL query to find the product with the highest average discount
sql_query = '''
SELECT ProductID, AVG(Discount) AS AvgDiscount
FROM [Order Details]
GROUP BY ProductID
ORDER BY AvgDiscount DESC
LIMIT 1;
'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
table_to_show = result_df
show_to_user(table_to_show)","import pandas as pd

# SQL query to calculate the average discount for each product
sql_query = '''
SELECT OrderDetails.ProductID, AVG(OrderDetails.Discount) AS AverageDiscount
FROM [Order Details] AS OrderDetails
JOIN orders AS Orders ON OrderDetails.OrderID = Orders.OrderID
GROUP BY OrderDetails.ProductID
ORDER BY AverageDiscount DESC
LIMIT 1;
''' 

# Execute the SQL query and get the results
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code includes an unnecessary JOIN operation on the 'orders' table, which is not required according to the business analytic request and the reference implementation. The reference implementation simply uses the 'Order Details' table and correctly generates the desired result. The JOIN operation could potentially change the outcome due to implicit filtering.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the product with the highest average discount
sql_query = 'SELECT ProductID, AVG(Discount) AS AverageDiscount FROM [Order Details] GROUP BY ProductID ORDER BY AverageDiscount DESC LIMIT 1;'

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Check if the result is not empty and contains the expected column
if not result_df.empty and 'ProductID' in result_df.columns and 'AverageDiscount' in result_df.columns:
    # Display the result to the user
    show_to_user(result_df)
else:
    print('No data found or unexpected columns in result.')","The provided Python code correctly follows the business analytic request to identify the product with the highest average discount. It defines an appropriate SQL query, executes it to retrieve the relevant data, and checks that the resultant dataframe contains the expected columns. If valid, it displays the result using the show_to_user function. The code also includes an additional error handling step to check for empty results or unexpected columns, which adds robustness.",Finetuned
What percentage of total stock does each product contribute? Please illustrate this using a pie chart.,"import pandas as pd
import plotly.express as px

# SQL query to retrieve stock percentage data
sql_query = '''
SELECT p.ProductID, ROUND(p.UnitsInStock / (SELECT SUM(UnitsInStock) FROM products) * 100, 2) AS StockPercentage FROM products p;
'''

# Execute the query and get the data in a pandas dataframe
df = execute_sql_query(sql_query)

# Plot a pie chart using plotly
fig = px.pie(df, values='StockPercentage', names='ProductID', title='Percentage of Total Stock by Product')

# Show the pie chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Retrieve data about products and their units in stock
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE Discontinued = 0;""
products_df = execute_sql_query(sql_query)

# Calculate total stock
total_stock = products_df['UnitsInStock'].sum()

# Calculate percentage contribution of each product
products_df['PercentageContribution'] = (products_df['UnitsInStock'] / total_stock) * 100

# Create a pie chart
fig = px.pie(products_df, values='PercentageContribution', names='ProductName', title='Percentage Contribution of Each Product to Total Stock')

# Show the visualization to the user
show_to_user(fig)",The provided implementation correctly calculates the percentage contribution of each product to the total stock and displays it as a pie chart. It also adheres to the given Python environment constraints by using the execute_sql_query and show_to_user utility functions. The minor difference regarding the ProductID and ProductName does not affect the correctness of the output as per the specified business request.,"import pandas as pd
import plotly.express as px

# SQL query to get product stock contributions
sql_query = '''
SELECT p.ProductID, p.ProductName, (p.UnitsInStock * p.UnitPrice) / 
(SELECT SUM(UnitsInStock * UnitPrice) FROM products) * 100 AS ContributionPercentage 
FROM products p;
'''

# Fetching data from the database
products_df = execute_sql_query(sql_query)

# Check for empty data or unexpected data types
if products_df.empty or not pd.api.types.is_numeric_dtype(products_df['ContributionPercentage']):
    raise ValueError('The dataset is empty or ContributionPercentage is not numeric.')

# Creating a pie chart using plotly
fig = px.pie(products_df, names='ProductName', values='ContributionPercentage', title='Percentage of Total Stock Contribution by Product')

# Displaying the pie chart to the user
show_to_user(fig)","The input code is calculating the percentage of total contribution considering both UnitsInStock and UnitPrice, while the business analytic request and reference implementation only consider the UnitsInStock. Specifically, the SQL query in the input code multiplies UnitsInStock by UnitPrice, which changes the intent of measuring stock percentage in terms of quantity of units. This does not align with the business request.",Base
Which employee processed the highest number of orders last month? Can you include a bar chart to visualize this data?,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) 
AND MONTH(o.OrderDate) = MONTH(CURDATE()) - 1 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Assuming result_df contains columns ['EmployeeID', 'OrderCount']

# Bar chart visualization
fig = px.bar(result_df, x='EmployeeID', y='OrderCount', title='Top Employee by Order Count Last Month')

# Display the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total orders processed by each employee last month
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM orders o
JOIN employees e ON o.EmployeeID = e.EmployeeID
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
  AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE)
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OrderCount DESC
LIMIT 1;
'''  

# Execute the SQL query to retrieve the results
highest_order_employee = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(highest_order_employee)

# Generate bar chart for total orders processed by all employees last month
sql_query_all = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM orders o
JOIN employees e ON o.EmployeeID = e.EmployeeID
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
  AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE)
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OrderCount DESC;
'''

# Execute the SQL query for all employees
all_orders_df = execute_sql_query(sql_query_all)

# Create a bar chart to visualize the order counts
fig = px.bar(all_orders_df, x='FirstName', y='OrderCount',
             title='Orders Processed by Each Employee Last Month',
             labels={'FirstName': 'Employee Name', 'OrderCount': 'Number of Orders'})

# Show the bar chart to the user
show_to_user(fig)","The input code correctly answers the business analytic request by identifying the employee who processed the highest number of orders last month and visualizes the data using a bar chart. The SQL query accurately filters the orders from the previous month, and the bar chart is created using Plotly to visualize the order counts for all employees. The use of utility functions `execute_sql_query` and `show_to_user` is also consistent with the Python environment constraints provided.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OrderCount 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC'''  # Order by OrderCount to see who processed the most orders

# Step 2: Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Step 3: Determine the employee with the highest order count
max_orders_employee = orders_df.iloc[0]  # First row after sorting by OrderCount DESC

# Step 4: Display the bar chart for visualization
fig = px.bar(orders_df, x='EmployeeID', y='OrderCount', title='Number of Orders Processed by Employee Last Month', labels={'OrderCount': 'Order Count', 'EmployeeID': 'Employee ID'})

# Step 5: Display the max orders employee info and the bar chart
show_to_user(max_orders_employee.to_frame().T)  # Display the employee with the highest order count
show_to_user(fig)  # Show the bar chart to the user","The provided input Python code does not correctly limit the date range to last month. Instead, it sets the condition to orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH), which includes a 30-31 day range from the current date. This is not the same as selecting the exact month prior to the current month. Additionally, the `LIMIT 1` clause is missing, which ensures only the top employee is selected.",Base
"Determine the month with the highest total sales, and visualize this information with a bar chart.","import pandas as pd
import plotly.express as px

# SQL query to get the monthly total sales
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as order_month, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as total_sales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY order_month 
ORDER BY total_sales DESC 
LIMIT 1;'''

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Ensure the DataFrame is not empty
if not df.empty:
    # Create a bar chart to visualize the total sales for the month with highest sales
    fig = px.bar(df, x='order_month', y='total_sales', title='Month with Highest Total Sales')

    # Display the visualization to the user
    show_to_user(fig)
else:
    print('No data available for the given query.')","import pandas as pd
import plotly.express as px

# SQL query to get total sales per month
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as month,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY month
ORDER BY total_sales DESC
LIMIT 1;
''' 

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Extract month with the highest total sales
highest_sales_month = monthly_sales_df.iloc[0]

# Create bar chart for visualization of total sales per month
bar_chart_sql = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as month,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY month
ORDER BY month;
''' 

# Execute the SQL query to get all monthly sales for bar chart
all_monthly_sales_df = execute_sql_query(bar_chart_sql)

# Create the bar chart
fig = px.bar(all_monthly_sales_df, x='month', y='total_sales',
             title='Total Sales per Month',
             labels={'month': 'Month', 'total_sales': 'Total Sales'})

# Display the bar chart to the user
show_to_user(fig) 

# Display the month with highest sales to the user
show_to_user(pd.DataFrame([highest_sales_month]))","The input Python code is correct according to the specified business analytic request. It correctly determines the month with the highest total sales and provides a bar chart for visualization. Although the approach is slightly different from the reference implementation, the end result is the same.","import pandas as pd
import plotly.express as px

# SQL query to get the month with the highest total sales
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY Month 
ORDER BY TotalSales DESC 
LIMIT 1;'''

# Execute the query to retrieve the data
data = execute_sql_query(sql_query)

# Extract the month and total sales from the result
month_with_highest_sales = data['Month'].iloc[0]
highest_total_sales = data['TotalSales'].iloc[0]

# Bar chart visualization
fig = px.bar(data, x='Month', y='TotalSales', title='Month with Highest Total Sales')

# Display the result to the user
show_to_user(fig)

# Print the month and highest total sales
show_to_user(pd.DataFrame({'Month': [month_with_highest_sales], 'Total Sales': [highest_total_sales]}))","The input Python code correctly follows the given constraints. It uses the provided utility functions execute_sql_query and show_to_user appropriately. It accurately calculates the month with the highest total sales using a SQL query, visualizes this information with a Plotly bar chart, and correctly displays the results.",both
Identify the top 5 suppliers based on the total sales revenue. Provide a bar chart to illustrate this data.,"import pandas as pd
import plotly.express as px

# SQL query to get top 5 suppliers based on total sales revenue
sql_query = '''
SELECT p.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID, s.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(result_df, x='CompanyName', y='TotalRevenue', title='Top 5 Suppliers by Total Sales Revenue', labels={'CompanyName': 'Supplier', 'TotalRevenue': 'Total Sales Revenue'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue for each supplier
sql_query = """"""
SELECT p.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY p.SupplierID, s.CompanyName
ORDER BY TotalSales DESC
LIMIT 5;
""""""

# Execute the SQL query and retrieve the data
supplier_sales = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(supplier_sales, x='CompanyName', y='TotalSales',
             title='Top 5 Suppliers by Total Sales Revenue',
             labels={'TotalSales': 'Total Sales Revenue', 'CompanyName': 'Supplier Company Name'},
             color='TotalSales')

# Show the bar chart to the user
show_to_user(fig)","The provided implementation correctly follows the business analytics request. It calculates the total sales revenue for each supplier using a SQL query, retrieves the top 5 suppliers, and visualizes the data using a bar chart with Plotly. The overall structure and logic match the reference implementation and meet the specified Python environment constraints.","import plotly.express as px

# SQL query to get the top 5 suppliers based on the total sales revenue
sql_query = """"""
SELECT s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(result_df, x='CompanyName', y='TotalRevenue', title='Top 5 Suppliers by Total Sales Revenue')

# Display the bar chart to the user
show_to_user(fig)","The provided code correctly implements the business analytic request by retrieving the top 5 suppliers based on total sales revenue and creating a bar chart to illustrate this data. The SQL query, data retrieval, and visualization parts of the code are consistent with the reference implementation. The minor differences in the SQL query structure (such as the JOIN order) do not affect the correctness of the result.",both
Which customer generated the highest lifetime value?,"import pandas as pd
import plotly.express as px

def get_highest_lifetime_value_customer():
    # Define SQL query to get customer with highest lifetime value
    sql_query = '''
    SELECT customers.CustomerID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * 
               (1 - [Order Details].Discount)) AS CustomerLifetimeValue 
    FROM customers 
    INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
    INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    GROUP BY customers.CustomerID 
    ORDER BY CustomerLifetimeValue DESC 
    LIMIT 1;
    '''
    
    # Execute SQL query and retrieve the result as a pandas dataframe
    result_df = execute_sql_query(sql_query)
    
    # Display result to user
    show_to_user(result_df)

# Call the function
get_highest_lifetime_value_customer()
","import pandas as pd

# SQL query to calculate Customer Lifetime Value
sql_query = '''
SELECT 
    customers.CustomerID, 
    customers.CompanyName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS LifetimeValue
FROM 
    customers
JOIN 
    orders ON customers.CustomerID = orders.CustomerID
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    customers.CustomerID, customers.CompanyName
ORDER BY 
    LifetimeValue DESC
LIMIT 1
'''

# Execute the SQL query
lifetime_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(lifetime_value_df)","The input Python code correctly calculates and displays the customer with the highest lifetime value. It adheres to the business analytic request, follows the Python environment constraints and will provide the correct result.","import pandas as pd
import plotly.express as px

# SQL query to get individual customer lifetime value
sql_query = '''
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID
ORDER BY TotalRevenue DESC
'''

# Execute SQL query
customer_lifetime_value_df = execute_sql_query(sql_query)

# Display the customer with the highest lifetime value
highest_lifetime_value_customer = customer_lifetime_value_df.iloc[0:1]

# Display the result
show_to_user(highest_lifetime_value_customer)","The given input code correctly follows the required steps to determine and display the customer with the highest lifetime value. It executes an SQL query, aggregates customer order data, sorts by total revenue, and displays the result. The overall logic and outcome align with the reference implementation.",both
How many employees live in each country? Can you provide a map or bar chart to visualize this information?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT Country, COUNT(EmployeeID) AS EmployeeCount FROM employees GROUP BY Country;'

# Execute the SQL query
employee_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of employees per country
fig = px.bar(employee_data, x='Country', y='EmployeeCount', title='Number of Employees per Country', labels={'EmployeeCount': 'Number of Employees'})

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Query to get the count of employees in each country
sql_query = """"""
SELECT Country, COUNT(EmployeeID) as EmployeeCount
FROM employees
GROUP BY Country
""""""

# Execute the SQL query
employee_counts_df = execute_sql_query(sql_query)

# Step 2: Create a bar chart to visualize the employee counts by country
fig = px.bar(employee_counts_df, x='Country', y='EmployeeCount',
             title='Number of Employees by Country',
             labels={'EmployeeCount': 'Number of Employees', 'Country': 'Country'})

# Step 3: Show the data visualization to the user
show_to_user(fig)","The provided Python code correctly follows the business analytic request and matches the reference implementation. It queries the number of employees per country, creates a bar chart to visualize this information, and displays the figure to the user. The code adheres to the Python environment constraints provided.","import plotly.express as px
import pandas as pd

# SQL query
sql_query = 'SELECT Country, COUNT(EmployeeID) AS NumberOfEmployees FROM employees GROUP BY Country;'

# Execute the query and get the result as a pandas dataframe
employee_data = execute_sql_query(sql_query)

# Check the dataframe
print(employee_data.head())

# Create a bar chart using Plotly
fig = px.bar(employee_data, x='Country', y='NumberOfEmployees', title='Number of Employees by Country')

# Display the bar chart to the user
show_to_user(fig)

# Create a map visualization using Plotly
fig_map = px.choropleth(employee_data, locations='Country', locationmode='country names', color='NumberOfEmployees', title='Number of Employees by Country')

# Display the map to the user
show_to_user(fig_map)","The input Python code correctly queries the number of employees per country, creates a bar chart, and additionally creates a choropleth map to visualize the data, both of which fulfill the business analytic request.",both
Display the total sales revenue for the month of January 2023 with a visualization.,"import plotly.express as px
import pandas as pd

# SQL query to retrieve the total sales revenue for January 2023
sql_query = '''
    SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
    FROM orders 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    WHERE MONTH(OrderDate) = 1 AND YEAR(OrderDate) = 2023;
'''

# Execute the SQL query and get the result in a dataframe
result_df = execute_sql_query(sql_query)

total_sales = result_df['TotalSales'].iloc[0]

# Create a dataframe for visualization
vis_df = pd.DataFrame({'Month': ['January 2023'], 'Total Sales': [total_sales]})

# Create a bar chart using plotly
fig = px.bar(vis_df, x='Month', y='Total Sales', title='Total Sales Revenue for January 2023')

# Display the visualization
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch total sales for January 2023 from the database
sql_query = '''
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
''' 

# Execute the SQL query using the provided utility function
sales_data = execute_sql_query(sql_query)

# Extract total sales value from the dataframe
total_sales = sales_data['TotalSales'].values[0] if not sales_data.empty else 0

# Create a bar chart to visualize total sales revenue for January 2023
fig = px.bar(x=['January 2023'], y=[total_sales], labels={'x': 'Month', 'y': 'Total Sales Revenue'}, title='Total Sales Revenue for January 2023')

# Display the figure to the user using the provided utility function
show_to_user(fig)","The input Python code correctly follows the specified business analytic request and matches the reference implementation. It uses the provided utility functions execute_sql_query and show_to_user appropriately. The SQL query effectively retrieves the total sales revenue for January 2023, and the plotly library is used to create the required visualization.","import plotly.express as px
import pandas as pd

# SQL query to retrieve total sales revenue for January 2023
sql_query = """"""
SELECT SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales
FROM orders O
JOIN [Order Details] OD ON O.OrderID = OD.OrderID
WHERE DATE_FORMAT(O.OrderDate, '%Y-%m') = '2023-01';
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the DataFrame is correctly populated
if not df.empty:
    total_sales = df.iloc[0]['TotalSales']
    result_df = pd.DataFrame({'TotalSales': [total_sales], 'Month': ['January 2023']})

    # Visualize the result using plotly
    fig = px.bar(result_df, x='Month', y='TotalSales', title='Total Sales Revenue for January 2023')

    # Display the visualization to the user
    show_to_user(fig)
else:
    print('No data retrieved from the database.')","The provided Python code correctly retrieves the total sales revenue for January 2023 and visualizes it using Plotly. The SQL query, data processing, and visualization steps are consistent with the business analytic request and match the reference implementation in terms of functionality, even though there are some differences in the SQL query format. The code also includes a check to handle the case where no data is retrieved, which is a good practice.",both
Visualize the top 5 cities with the highest average shipping cost.,"import plotly.express as px

# SQL Query to get the required data
sql_query = '''SELECT ShipCity, AVG(Freight) AS AverageFreight FROM orders GROUP BY ShipCity ORDER BY AverageFreight DESC LIMIT 5;'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Create a bar plot to visualize the top 5 cities with the highest average shipping cost
fig = px.bar(result_df, x='ShipCity', y='AverageFreight', title='Top 5 Cities with Highest Average Shipping Cost', labels={'ShipCity': 'City', 'AverageFreight': 'Average Shipping Cost'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Write SQL query to get average shipping cost by city
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AverageShippingCost DESC
LIMIT 5;
""""""

# Step 2: Execute the SQL query to get data
average_shipping_costs = execute_sql_query(sql_query)

# Step 3: Create a bar chart to visualize the results
fig = px.bar(
    average_shipping_costs,
    x='ShipCity',
    y='AverageShippingCost',
    title='Top 5 Cities with Highest Average Shipping Cost',
    labels={'ShipCity': 'City', 'AverageShippingCost': 'Average Shipping Cost'}
)

# Step 4: Show the figure to the user
show_to_user(fig)","The input Python code correctly follows the business analytic request and matches the reference implementation. It retrieves the top 5 cities with the highest average shipping cost using an appropriate SQL query, executes the query, and then visualizes the data using Plotly. It adheres to the provided utility functions 'execute_sql_query' and 'show_to_user'. The variable names differ slightly, but functionality and logic are consistent with the requirements.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the top 5 cities with the highest average shipping cost
sql_query = 'SELECT ShipCity, AVG(Freight) AS AverageShippingCost FROM orders GROUP BY ShipCity ORDER BY AverageShippingCost DESC LIMIT 5;'

# Execute the SQL query to retrieve the data
orders_df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(orders_df, x='ShipCity', y='AverageShippingCost', title='Top 5 Cities with the Highest Average Shipping Cost', labels={'ShipCity':'City', 'AverageShippingCost':'Average Shipping Cost'})

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly follows the business analytic request to visualize the top 5 cities with the highest average shipping cost. It uses a SQL query to retrieve the necessary data, creates a bar plot using plotly, and then displays the plot using the provided show_to_user function. The variable names and plot labels are appropriate and match the intention of the request.",both
Which products need to be reordered (units in stock less than reorder level)?,"import pandas as pd
import plotly.express as px

# SQL query to select products that need to be reordered
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query using the provided utility function
products_to_reorder_df = execute_sql_query(sql_query)

# Display the resulting DataFrame using the provided utility function
show_to_user(products_to_reorder_df)

# Add a check if the DataFrame is not empty before plotting
if not products_to_reorder_df.empty:
    # Additionally, we can visualize the data using a plotly bar chart
    fig = px.bar(products_to_reorder_df, x='ProductName', y='ProductID', title='Products Needing Reorder')
    
    # Show the plotly figure
    show_to_user(fig)
else:
    print('No products need to be reordered.')","import pandas as pd

# SQL query to retrieve products that need to be reordered
sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
'''  

# Execute the SQL query and get the results in a DataFrame
products_to_reorder = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(products_to_reorder)","The input Python code correctly fetches the products with UnitsInStock less than ReorderLevel and also filters by Discontinued status. However, it misses the data visualization aspect that is present in the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;'


def fetch_and_display_reorder_products(sql_query):
    # Execute the SQL query to retrieve the needed data
    products_df = execute_sql_query(sql_query)

    if products_df.empty:
        print('No products need to be reordered.')
    else:
        # Display the DataFrame to the user
        show_to_user(products_df)

# Call the function with the SQL query
fetch_and_display_reorder_products(sql_query)","The input code does not fully match the reference implementation. The SQL query in the input code does not select the ProductID as required, leading to incomplete data. Additionally, it lacks the plotly bar chart visualization for providing a richer view of products needing reorder.",None
Visualize the top 5 products by sales revenue.,"import plotly.express as px
import pandas as pd

# The SQL query to fetch the top 5 products by sales revenue
sql_query = (
    ""SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales ""
    ""FROM [Order Details] ""
    ""GROUP BY ProductID ""
    ""ORDER BY TotalSales DESC ""
    ""LIMIT 5;""
)

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty before proceeding with visualization
if not df.empty:
    # Create a bar chart using plotly express
    fig = px.bar(df, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue',
                 labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales Revenue'})

    # Display the figure to the user
    show_to_user(fig)
else:
    # Handle the case where the dataframe is empty
    print('No data available to display.')","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales by product
sql_query = """"""
SELECT
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM
    [Order Details] od
JOIN
    orders o ON od.OrderID = o.OrderID
GROUP BY
    od.ProductID
ORDER BY
    TotalSales DESC
LIMIT 5
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualize the top 5 products by sales revenue
fig = px.bar(result_df, x='ProductID', y='TotalSales',
             title='Top 5 Products by Sales Revenue',
             labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales ($)'})

# Show the visualization to the user
show_to_user(fig)","The provided Python code correctly retrieves and visualizes the top 5 products by sales revenue. It follows the business analytic request by executing a SQL query to fetch the required data, processes the data using pandas, creates a bar chart using plotly express, and finally displays the visualization using the show_to_user function. It aligns well with the reference implementation and meets the environment constraints.","import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalSales DESC
LIMIT 5;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Top 5 Products by Sales Revenue')

# Display the visualization to the user
show_to_user(fig)","The input Python code correctly retrieves the top 5 products by sales revenue, creates a bar chart using plotly express, and displays it to the user using the provided utility functions. It adheres to the environment constraints and matches the intent of the reference implementation, albeit with minor differences in the SQL query, which does not affect correctness.",both
Visualize the correlation between employee hire date and performance.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, employees.HireDate, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, employees.HireDate 
ORDER BY employees.HireDate;
'''

# Execute the SQL query and get the result as a pandas dataframe
employee_sales_df = execute_sql_query(sql_query)

# Convert HireDate to datetime format
employee_sales_df['HireDate'] = pd.to_datetime(employee_sales_df['HireDate'])

# Visualize the correlation between hire date and total sales
fig = px.scatter(employee_sales_df, x='HireDate', y='TotalSales',
 title='Correlation between Employee Hire Date and Performance',
 labels={'HireDate': 'Hire Date', 'TotalSales': 'Total Sales'},
 trendline='ols')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve hire date and total sales of each employee
sql_query = '''
SELECT e.HireDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.HireDate
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Ensure that the HireDate is in datetime format
sales_data['HireDate'] = pd.to_datetime(sales_data['HireDate'])

# Visualize the correlation between HireDate and TotalSales
fig = px.scatter(sales_data, x='HireDate', y='TotalSales', title='Correlation Between Employee Hire Date and Performance',
                 labels={'HireDate': 'Hire Date', 'TotalSales': 'Total Sales'}, trendline='ols')

# Show the visualization to the user
show_to_user(fig)","The input code does not match the reference implementation in grouping. The input code groups the data by 'HireDate' only, missing grouping by 'EmployeeID'. This can lead to incorrect results since 'TotalSales' should be calculated per employee, considering their unique sales transactions.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, 
       DATEDIFF(CURDATE(), employees.HireDate) AS EmploymentDuration,
       AVG(performance_reviews.Rating) AS AveragePerformanceRating
FROM employees 
JOIN performance_reviews ON employees.EmployeeID = performance_reviews.EmployeeID
GROUP BY employees.EmployeeID;
'''

# Execute the SQL query
employees_df = execute_sql_query(sql_query)

# Generate a scatter plot to visualize the correlation
fig = px.scatter(employees_df, x='EmploymentDuration', y='AveragePerformanceRating',
                 title='Correlation Between Employment Duration and Average Performance Rating',
                 labels={'EmploymentDuration': 'Employment Duration (days)', 'AveragePerformanceRating': 'Average Performance Rating'})

# Show the visualization to the user
show_to_user(fig)","The input code does not address the business analytic request to visualize the correlation between employee hire date and performance. Instead, it correlates employment duration with average performance rating. The correlation should be between hire date (a specific point in time) and performance metrics. The logic also misses the calculation of performance metrics based on the hire date, and visualizes a different business question.",None
How many new customers were acquired in May 2023?,"import pandas as pd

# Step 1: Define the SQL query to get new customers acquired in May 2023
sql_query = '''
SELECT COUNT(DISTINCT customers.CustomerID) AS new_customers
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
WHERE orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
'''

# Step 2: Execute the SQL query
new_customers_df = execute_sql_query(sql_query)

# Step 3: Show the result to the user
show_to_user(new_customers_df)","# SQL query to count new customers acquired in May 2023
sql_query = """"""
SELECT COUNT(*) AS new_customers_count 
FROM customers 
WHERE CustomerID IN \
    (SELECT DISTINCT CustomerID \
    FROM orders \
    WHERE OrderDate BETWEEN '2023-05-01' AND '2023-05-31')
""""""

# Execute the SQL query
new_customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(new_customers_df)","The provided code accurately retrieves the count of new customers acquired in May 2023. It meets the requirements of the business analytic request, follows the Python environment constraints, and produces a result that aligns with the reference implementation, despite minor differences in the SQL query syntax.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT COUNT(CustomerID) AS NewCustomers
FROM orders
WHERE OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""

# Execute the SQL query and retrieve the results in a dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)",The input code does not correctly identify new customers who were acquired in May 2023. The SQL query in the input code only counts the number of orders in May 2023 but does not distinguish new customers from existing ones. The reference code correctly identifies new customers by using a JOIN and DISTINCT on the CustomerID.,Base
Which suppliers provide products that are currently in stock?,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = 'SELECT DISTINCT SupplierID FROM products WHERE UnitsInStock > 0;'

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Optionally, display the raw results to the user
show_to_user(result_df)

# If you would like to visualize the data further, e.g., a bar plot of supplier counts
# Since we only have distinct SupplierID and not their counts, we just visualize SupplierID count itself
supplier_counts = result_df['SupplierID'].value_counts().reset_index()
supplier_counts.columns = ['SupplierID', 'Count']

# Create a bar plot
fig = px.bar(supplier_counts, x='SupplierID', y='Count', title='Number of In-Stock Products by Supplier')

# Show the plot to the user
show_to_user(fig)
","sql_query = """"""
SELECT DISTINCT s.SupplierID, p.ProductName
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitsInStock > 0;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(result_df)","The input Python code correctly retrieves the SupplierIDs of products that are currently in stock by using an appropriate SQL query with a JOIN on the suppliers table. The results are then displayed to the user using the show_to_user function. While the code does not include a visualization step like the reference implementation, it still fulfills the basic requirement of the business analytic request.","import pandas as pd
import plotly.express as px
from utils import execute_sql_query, show_to_user

# SQL query to find suppliers providing products that are in stock
sql_query = '''
SELECT suppliers.SupplierID, CompanyName 
FROM suppliers 
WHERE SupplierID IN (
    SELECT SupplierID FROM products 
    WHERE UnitsInStock > 0
);'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optional visualization if needed
fig = px.bar(result_df, x='SupplierID', y='CompanyName', title='Suppliers Providing Products in Stock')
show_to_user(fig)
","The input Python code correctly identifies suppliers that provide products currently in stock. The SQL query is accurately structured to find suppliers with in-stock products, and the data is executed and visualized correctly using plotly. It adheres to the Python environment constraints specified, using the provided utility functions `execute_sql_query` and `show_to_user`.",both
Visualize how many employees are there in each country.,"import plotly.express as px

# Define the SQL query to get the number of employees per country
sql_query = ""SELECT Country, COUNT(*) AS NumEmployees FROM employees GROUP BY Country;""

# Execute the SQL query and get the data in a pandas dataframe
employee_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly Express
fig = px.bar(employee_data, x='Country', y='NumEmployees', title='Number of Employees in Each Country')

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count the number of employees in each country
sql_query = """"""
SELECT Country, COUNT(EmployeeID) as EmployeeCount 
FROM employees 
GROUP BY Country
""""""

# Execute the SQL query and retrieve data as a pandas DataFrame
employees_by_country = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of employees in each country
fig = px.bar(employees_by_country, x='Country', y='EmployeeCount',
             title='Number of Employees in Each Country',
             labels={'EmployeeCount': 'Number of Employees', 'Country': 'Country'},
             color='EmployeeCount',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the figure to the user
show_to_user(fig)","The input Python code correctly implements a bar chart visualization of the number of employees in each country. It follows the specified constraints and achieves the goal of the business analytic request. The use of Plotly Express to create the bar chart is appropriate, and the necessary SQL query is executed to retrieve the required data.","
import plotly.express as px

# SQL query to get employee count by country
df = execute_sql_query('SELECT Country, COUNT(*) AS EmployeeCount FROM employees GROUP BY Country;')

# Create a bar chart using plotly
fig = px.bar(df, x='Country', y='EmployeeCount', title='Number of Employees in Each Country', labels={'EmployeeCount': 'Employee Count'})

# Show the plot to the user
show_to_user(fig)
","The input Python code correctly follows the business analytic request and the given Python environment constraints. It executes a SQL query to get the number of employees per country, retrieves the data in a pandas dataframe, creates a bar chart using Plotly Express, and displays the plot to the user. The implementation achieves the same results as the reference implementation, even though the code is slightly different.",both
Visualize the average fulfillment time for orders by month.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, AVG(DATEDIFF(DAY, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY EXTRACT(MONTH FROM OrderDate)
""""""

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Create a bar plot of the average fulfillment time by month
fig = px.bar(orders_df, x='Month', y='AvgFulfillmentTime', title='Average Fulfillment Time by Month', 
             labels={'Month': 'Month', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the order fulfillment times by month
sql_query = '''
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM
    orders
WHERE
    ShippedDate IS NOT NULL
GROUP BY
    OrderMonth
ORDER BY
    OrderMonth;
'''  

# Execute the SQL query to retrieve the data
fulfillment_data = execute_sql_query(sql_query)

# Create a line plot using Plotly
fig = px.line(fulfillment_data, x='OrderMonth', y='AverageFulfillmentTime',
              title='Average Fulfillment Time for Orders by Month',
              labels={'OrderMonth': 'Month', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'}
             )

# Show the figure to the user
show_to_user(fig)","The provided code correctly executes the SQL query to calculate average fulfillment time by month, creates a line plot using Plotly, and displays the plot to the user using the show_to_user function. The key functionality required by the business analytic request is achieved, despite some differences from the reference implementation (e.g., slight variation in SQL syntax and plot type).","import pandas as pd
import plotly.express as px

# Step 1: Retrieve the data
query = """"""
SELECT EXTRACT(MONTH FROM orders.OrderDate) AS OrderMonth, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY EXTRACT(MONTH FROM orders.OrderDate);
""""""
result_df = execute_sql_query(query)

# Step 2: Create the visualization
fig = px.line(result_df, x='OrderMonth', y='AvgFulfillmentTime', title='Average Fulfillment Time per Month', labels={'OrderMonth': 'Month', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'})

# Step 3: Display the result
show_to_user(fig)","The code implementation fetches the correct data and displays it using Plotly, but it uses a line chart instead of a bar chart as specified in the reference implementation. Additionally, there is a discrepancy in handling the `DATEDIFF` function parameters ordering between the reference (DATEDIFF(DAY, OrderDate, ShippedDate)) and the input code (DATEDIFF(orders.ShippedDate, orders.OrderDate)). Both differences mean that the implementation might not meet the specific requirements of the request correctly.",Base
How many days on average does it take to fulfill an order?,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the average fulfillment time
sql_query = '''
SELECT AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
FROM orders
'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# If there is no column named 'AvgFulfillmentTime', rename it.
if 'AvgFulfillmentTime' not in result_df.columns:
    result_df.columns = ['AvgFulfillmentTime']

# Display the result to the user
show_to_user(result_df)
","import pandas as pd

# SQL query to calculate average order fulfillment time
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentDays
FROM orders
WHERE ShippedDate IS NOT NULL
""""""  

# Execute the SQL query and retrieve the data
avg_fulfillment_time_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(avg_fulfillment_time_df)","The user's code has an error in the SQL query. The DATEDIFF function should be 'DATEDIFF(day, OrderDate, ShippedDate)' to match the correct syntax of the reference query. The user's query is missing 'day', which specifies the unit of the difference.","import pandas as pd
import plotly.express as px

# Function to execute the SQL query
sql_query = ""SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime FROM orders;""

# Execute the SQL query to retrieve data
order_data = execute_sql_query(sql_query)

# Assuming the returned dataframe has one row with the column 'AverageFulfillmentTime'
average_fulfillment_time = order_data.iloc[0]['AverageFulfillmentTime']

# Convert the result to a pandas dataframe for proper display
result_df = pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]})

# Display the result to the user
show_to_user(result_df)
","There is an error in the SQL query. The DATEDIFF function should have 3 arguments: the date part (in this case 'day'), the start date (OrderDate), and the end date (ShippedDate). The correct query should be: 'SELECT AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime FROM orders;'. Additionally, the final dataframe column name should be 'AvgFulfillmentTime' to ensure consistency with the reference implementation.",None
What is the average discount applied per product?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];'

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to get the average discount applied per product
sql_query = '''
SELECT ProductID, AVG(Discount) as avg_discount
FROM [Order Details]
GROUP BY ProductID
'''  

# Execute the SQL query to retrieve data
average_discount_df = execute_sql_query(sql_query)

# Show the result to user
show_to_user(average_discount_df)","The input code groups the data by ProductID and calculates the average discount for each product. However, the business request asks for the overall average discount applied per product, not a grouped average per product. The correct approach is to calculate the average discount across all products without grouping by ProductID, similar to the reference implementation.","# Import the necessary libraries
import pandas as pd
import plotly.express as px

# Function to get the average discount applied per product

def get_average_discount_per_product():
    # SQL query to get the average discount applied per product
    sql_query = '''
    SELECT p.ProductID, p.ProductName, AVG(od.Discount) AS AverageDiscount
    FROM products p
    JOIN [Order Details] od ON p.ProductID = od.ProductID
    GROUP BY p.ProductID, p.ProductName;'''

    # Execute the SQL query
    result_df = execute_sql_query(sql_query)

    # Display the result to user
    show_to_user(result_df)

    # Plotting the average discount per product
    fig = px.bar(result_df, x='ProductName', y='AverageDiscount', title='Average Discount per Product', labels={'ProductName': 'Product Name', 'AverageDiscount': 'Average Discount'})
    show_to_user(fig)

# Call the function to get the average discount per product and display results
get_average_discount_per_product()","The provided Python code calculates the average discount per product, while the business analytic request is asking for the overall average discount applied per product, without breaking it down by each product. The reference implementation calculates the overall average discount directly without grouping by product.",None
Visualize which suppliers have supplied the most products.,"import plotly.express as px

# SQL query
sql_query = '''
SELECT s.SupplierID, COUNT(p.ProductID) AS TotalProductsSupplied 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID 
ORDER BY TotalProductsSupplied DESC;
'''

# Execute the SQL query and get the data
suppliers_df = execute_sql_query(sql_query)

# Ensure that the columns are correctly named and any potential issues with the data are resolved
df.columns = [col.strip() for col in df.columns]
# Create a bar chart to visualize the result
fig = px.bar(suppliers_df, x='SupplierID', y='TotalProductsSupplied',
             title='Suppliers with Most Products Supplied',
             labels={'SupplierID': 'Supplier ID', 'TotalProductsSupplied': 'Total Products Supplied'},
             template='plotly_dark')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the count of products supplied by each supplier
sql_query = '''
SELECT SupplierID, COUNT(ProductID) AS ProductCount
FROM products
GROUP BY SupplierID
ORDER BY ProductCount DESC
'''  

# Execute the SQL query and retrieve the data
supplier_data = execute_sql_query(sql_query)

# Create a bar plot to visualize suppliers with the most products
fig = px.bar(supplier_data, x='SupplierID', y='ProductCount', title='Suppliers by Number of Products Supplied', 
             labels={'SupplierID': 'Supplier ID', 'ProductCount': 'Number of Products Supplied'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly retrieves and visualizes the count of products supplied by each supplier, but it does not exactly follow the business requirement of visualizing based on suppliers table join with products table to associate suppliers to products. The input must use the suppliers table along with the products table in the SQL query and join them to get the SupplierIDs correctly.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT s.SupplierID, s.CompanyName, COUNT(p.ProductID) AS ProductCount FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID GROUP BY s.SupplierID, s.CompanyName;'

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(supplier_data, x='CompanyName', y='ProductCount', title='Number of Products Supplied by Each Supplier', labels={'CompanyName':'Supplier', 'ProductCount':'Number of Products'})

# Show the visualization to the user
show_to_user(fig)
","The provided code does not correctly match the business request. It includes the 'CompanyName' column which is not necessary for visualizing which suppliers supplied the most products. Additionally, it does not sort the suppliers in descending order of the total products supplied, which is required to visualize 'most products'.",None
Visualize which regions have the highest on-time delivery rates.,"import plotly.express as px
import pandas as pd

# SQL query to get the on-time delivery rates by region
sql_query = """"""
SELECT ShipRegion, (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID)) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the on-time delivery rates by region
fig = px.bar(df, x='ShipRegion', y='OnTimeDeliveryRate', title='On-Time Delivery Rates by Region', 
             labels={'ShipRegion': 'Region', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'}, 
             template='plotly_white')

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rates by region
sql_query = '''
SELECT 
    ShipRegion, 
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeDeliveries,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) * 100 AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipRegion
ORDER BY OnTimeDeliveryRate DESC
'''  

# Execute SQL query and retrieve data
region_delivery_rates = execute_sql_query(sql_query)

# Create a bar plot to visualize on-time delivery rates by region
fig = px.bar(region_delivery_rates,
             x='ShipRegion',
             y='OnTimeDeliveryRate',
             title='On-Time Delivery Rates by Region',
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'ShipRegion': 'Region'},
             color='OnTimeDeliveryRate',
             color_continuous_scale='Viridis')

# Show the results to the user
show_to_user(fig)","The input code correctly calculates the on-time delivery rates by region and visualizes them using a bar chart. The SQL query, data retrieval, and plotting steps are all appropriate and produce the desired output. Minor differences from the reference code, such as additional columns in the SQL query and the use of color in the plot, do not affect the correctness.","import pandas as pd
import plotly.express as px

# 1. Define the SQL query to get on-time delivery rates by region
sql_query = """"""
SELECT Region, 
       COUNT(OrderID) * 100.0 / (SELECT COUNT(*) FROM orders WHERE ShippedDate <= RequiredDate) AS OnTimeDeliveryRate 
FROM orders 
WHERE ShippedDate <= RequiredDate 
GROUP BY Region
""""""

# 2. Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# 3. Visualize the data using Plotly
fig = px.bar(orders_df, x='Region', y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rates by Region', 
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'Region': 'Region'})

# 4. Show the visualization to the user
show_to_user(fig)
","The input code calculates the on-time delivery rate by considering the number of on-time shipments relative to all orders where ShippedDate is on time. This is incorrect. The reference implementation calculates the on-time delivery rate as the percentage of on-time shipments out of all orders in a region. Thus, the input code has a flawed query logic and does not provide the correct on-time delivery rate calculation.",Base
How many orders were handled by employees who were hired in the year 2020?,"import pandas as pd
import plotly.express as px

# SQL Query to get the number of orders by employees hired in 2020
total_orders_query = '''
SELECT COUNT(orders.OrderID) AS TotalOrders 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE YEAR(HireDate) = 2020;
'''

# Execute the query and store the result in a dataframe
df_total_orders = execute_sql_query(total_orders_query)

# Assuming the result is a single row with a single column
# We can extract the total orders and print it
if not df_total_orders.empty:
    total_orders = df_total_orders.iloc[0]['TotalOrders']
    print(f'Total Orders handled by employees hired in 2020: {total_orders}')
else:
    print('No orders found for employees hired in 2020.')

# Display the result to the user
show_to_user(df_total_orders)","import pandas as pd

# SQL query to count orders handled by employees hired in 2020
sql_query = '''
SELECT COUNT(o.OrderID) AS TotalOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE e.HireDate >= '2020-01-01' AND e.HireDate < '2021-01-01'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code correctly executes an SQL query to count the orders handled by employees who were hired in 2020 and displays the result using the show_to_user() function, which matches the business request and effectively utilizes the given environment constraints.","import pandas as pd
import plotly.express as px

# SQL Query to count orders handled by employees hired in 2020
sql_query = '''
SELECT COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE e.HireDate BETWEEN '2020-01-01' AND '2020-12-31';
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Visualization (Optional, since it's a single count, visualization might not be necessary)
fig = px.bar(result_df, x=result_df.index, y='OrderCount', title='Orders Handled by Employees Hired in 2020')
show_to_user(fig)","The input code correctly performs the required SQL query to count the number of orders handled by employees hired in 2020. It uses the appropriate date range to filter the employees hired in 2020 and joins the employees and orders tables correctly. The count of orders is then displayed to the user. While the reference implementation includes extracting and printing the total orders explicitly, the core task of counting and displaying the order count is achieved accurately in the input code.",both
Visualize the average discount applied to products per month.,"import pandas as pd
import plotly.express as px

# SQL Query to fetch required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, AVG(Discount) AS AverageDiscount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY month;
""""""

# Execute the SQL query
dataframe = execute_sql_query(sql_query)

# Convert month column to datetime
dataframe['month'] = pd.to_datetime(dataframe['month'], format='%Y-%m')
dataframe.sort_values('month', inplace=True)

# Visualize the data using plotly
fig = px.line(dataframe, x='month', y='AverageDiscount', title='Average Discount per Month', labels={'month': 'Month', 'AverageDiscount': 'Average Discount'})

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average discount per month
sql_query = '''
SELECT
    DATE_TRUNC('month', o.OrderDate) AS month,
    AVG(od.Discount) AS average_discount
FROM
    orders o
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY
    month
ORDER BY
    month;
'''  

# Execute the SQL query and retrieve the data
average_discount_df = execute_sql_query(sql_query)

# Create a line plot to visualize the average discount per month
fig = px.line(average_discount_df, x='month', y='average_discount', title='Average Discount Applied to Products Per Month')

# Show the plot to the user
show_to_user(fig)","The input Python code correctly fulfills the business analytic request of visualizing the average discount applied to products per month. It follows the provided Python environment constraints by using `execute_sql_query` to retrieve the data and `show_to_user` to display the plotly figure. The SQL query and subsequent data handling are appropriately structured to provide the required output, similar to the reference implementation.","# Import the necessary libraries
import pandas as pd
import plotly.express as px


def main():
    # SQL query to fetch the necessary data
    sql_query = '''
    SELECT DATE_TRUNC('month', o.OrderDate) AS Month, AVG(od.Discount) AS AvgDiscount 
    FROM [Order Details] od 
    JOIN orders o ON od.OrderID = o.OrderID 
    GROUP BY DATE_TRUNC('month', o.OrderDate) 
    ORDER BY Month;'''
    
    # Execute the SQL query and get the results in a DataFrame
    df = execute_sql_query(sql_query)
    
    # Check if the returned DataFrame is correct and has the expected columns
    if df.empty:
        print('No data found for the given SQL query.')
        return
    
    # Visualize the average discount applied to products per month
    fig = px.line(df, x='Month', y='AvgDiscount', title='Average Discount Per Month', labels={'Month': 'Month', 'AvgDiscount': 'Average Discount'})
    
    # Display the plotly figure to the user
    show_to_user(fig)
    
# Run the main function
main()","The input Python code correctly executes the SQL query to fetch the average discount per month, checks if the DataFrame is empty, and uses Plotly to visualize the results, similar to the reference implementation. It adheres to the specified Python environment constraints and fulfills the business analytic request.",both
What is the average time between order date and required date?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT DATEDIFF(RequiredDate, OrderDate) AS LeadTime FROM orders;'

# Execute the SQL query to retrieve the lead times
lead_times_df = execute_sql_query(sql_query)

# Calculate the average lead time
average_lead_time = lead_times_df['LeadTime'].mean()

# Create a DataFrame to display the average lead time
average_lead_time_df = pd.DataFrame({'AverageLeadTime': [average_lead_time]})

# Display the average lead time to the user
show_to_user(average_lead_time_df)","import pandas as pd

# SQL query to calculate the average time between OrderDate and RequiredDate
sql_query = """"""
SELECT AVG(DATEDIFF(RequiredDate, OrderDate)) AS AverageTime
FROM orders
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly calculates the average time between the OrderDate and RequiredDate using an SQL query and displays the result. It aligns with the specified business analytic request and produces the correct output, just in a slightly different manner than the reference implementation.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(DATEDIFF(RequiredDate, OrderDate)) AS AverageLeadTime FROM orders;'

# Execute the query and retrieve the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty and has the expected column
if not result_df.empty and 'AverageLeadTime' in result_df.columns:
    average_lead_time = result_df['AverageLeadTime'].iloc[0]
else:
    average_lead_time = None

# Display the result to the user
show_to_user(pd.DataFrame({'AverageLeadTime': [average_lead_time]}))","The input code correctly calculates the average time between order date and required date by leveraging the SQL query to compute the average directly in the database using the AVG() function on the DATEDIFF() result. This is a valid approach and follows the logic of the reference implementation, but in a more optimized manner by reducing the steps involved. It also includes robustness checks to handle potential edge cases like empty results and displays the result correctly.",both
How many products have a stock level below their reorder level?,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to retrieve products with stock level below reorder level
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df[['ProductName']])","import pandas as pd

# SQL query to find the number of products where stock level is below reorder level
sql_query = '''
SELECT COUNT(*) AS LowStockCount
FROM products
WHERE UnitsInStock < ReorderLevel
'''  

# Execute the SQL query and retrieve the results
df_low_stock = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df_low_stock)","The input Python code correctly finds the count of products with stock levels below their reorder level and displays it to the user. However, the business analytic request specifically asks for the product names (not just the count) that have stock levels below their reorder level, which the input code does not provide.","import pandas as pd
import plotly.express as px

# SQL query to find products with stock level below reorder level
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)

# Optionally, visualize the count of such products
stock_below_reorder = result_df.shape[0]
count_df = pd.DataFrame({'Count of Products Below Reorder Level': [stock_below_reorder]})

# Display the count visualization
show_to_user(count_df)
","The input Python code correctly retrieves products with stock level below reorder level using an SQL query and displays the result to the user. Additionally, it also visualizes the count of such products, which is an optional but useful analytic enhancement. The code leverages the specified 'execute_sql_query' and 'show_to_user' functions appropriately. Thus, it fulfills the business analytic request and adheres to the environment constraints.",Finetuned
Which orders were delayed more than five days past the required date?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT OrderID FROM orders WHERE DATEDIFF(ShippedDate, RequiredDate) > 5;""

# Execute the query and get the results in a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_df)","import pandas as pd

# SQL query to find orders that were delayed more than five days past the required date
sql_query = """"""
SELECT * 
FROM orders 
WHERE DATEDIFF(ShippedDate, RequiredDate) > 5
""""""

# Execute the SQL query using the provided utility function
delayed_orders_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(delayed_orders_df)","The input code correctly identifies and fetches the orders delayed more than five days past the required date using a SQL query. It then displays the results using the show_to_user function, similarly to the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT o.OrderID, o.RequiredDate, o.ShippedDate,
    DATEDIFF(DAY, o.RequiredDate, o.ShippedDate) AS DelayDays
FROM orders o
WHERE DATEDIFF(DAY, o.RequiredDate, o.ShippedDate) > 5;
'''

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Display the resulting data
show_to_user(orders_df)

# Visualize the delays
fig = px.bar(orders_df, x='OrderID', y='DelayDays', 
             title='Orders Delayed More Than 5 Days Past Required Date', 
             labels={'OrderID': 'Order ID', 'DelayDays': 'Delay (Days)'})


show_to_user(fig)","The provided code correctly executes an SQL query to find orders delayed more than five days past the required date. It retrieves the OrderID, RequiredDate, ShippedDate, and calculates the delay in days using DATEDIFF. The results are then displayed, and additionally, a plotly bar chart is created and displayed to visualize the delays, which adheres to the given requirements and constraints.",both
What is the average time taken to fulfill an order?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT AVG(DATE_PART('day', ShippedDate::timestamp - OrderDate::timestamp)) AS AverageFulfillmentTime FROM orders;""

# Execute the SQL query to get the result
result_df = execute_sql_query(sql_query)

# Extract the average fulfillment time from the result
average_fulfillment_time = result_df['AverageFulfillmentTime'][0]

# Create a DataFrame to display the result
average_fulfillment_df = pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]})

# Display the result to the user
show_to_user(average_fulfillment_df)
","import pandas as pd

# Define the SQL query to calculate the average time taken to fulfill an order
sql_query = '''
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL
'''

# Execute the SQL query and retrieve the data in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly calculates the average time taken to fulfill an order. It uses the DATEDIFF function to find the difference between OrderDate and ShippedDate, averages the results, and ensures ShippedDate is not null. Finally, it uses the execute_sql_query and show_to_user utilities in accordance with the Python environment constraints.","import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime FROM orders;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average fulfillment time
average_fulfillment_time = result_df['AverageFulfillmentTime'][0]

# Convert to DataFrame for display
average_fulfillment_df = pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]})

# Display the result to the user
show_to_user(average_fulfillment_df)",The input Python code is correct. It follows the Python environment constraints by using the `execute_sql_query` function to execute the SQL query and the `show_to_user` function to display the result. The SQL query correctly calculates the average fulfillment time (number of days) between the order date and shipped date.,both
Calculate the total value of current inventory (UnitPrice * UnitsInStock) for all products.,"import pandas as pd

# SQL query to calculate the total value of current inventory
sql_query = 'SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue FROM products;'

# Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Ensure df is not empty and has the expected column
if not df.empty and 'TotalInventoryValue' in df.columns:
    # Extract the total inventory value from the dataframe
    total_inventory_value = df['TotalInventoryValue'].iloc[0]

    # Convert the result to a dataframe for display
    result_df = pd.DataFrame({'TotalInventoryValue': [total_inventory_value]})

    # Display the result to the user
    show_to_user(result_df)
else:
    # Handle the case when the query results are not as expected
    show_to_user(pd.DataFrame({'Error': ['No data retrieved or unexpected result format']}))","import pandas as pd

# SQL query to calculate total inventory value
sql_query = '''
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products
WHERE Discontinued = 0
'''  # Assuming we only want to count non-discontinued products

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code is incorrect as it includes an additional condition (`WHERE Discontinued = 0`) not present in the provided business analytic request, which specifies calculating inventory value for all products.","import pandas as pd
import plotly.express as px

# SQL query to get the total value of current inventory
sql_query = 'SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue FROM products;'

# Execute the SQL query
inventory_data = execute_sql_query(sql_query)

# Display the total inventory value
show_to_user(inventory_data)","The input Python code does not correctly handle cases where the SQL query result might be empty or unexpected. Also, it does not ensure the result is in the expected format. The reference implementation includes checks to ensure the result is valid before calling show_to_user, which the input code lacks.",None
What is the average lead time for each supplier? (Include a visualization to illustrate the average lead time for comparison among suppliers.),"import plotly.express as px
import pandas as pd

# SQL query to retrieve the required data
sql_query = '''
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY products.SupplierID;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the data is available and correct
if df.empty or 'SupplierID' not in df.columns or 'AverageLeadTime' not in df.columns:
    raise ValueError('Data retrieval failed or data format is incorrect')

# Visualization of average lead time for each supplier
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', title='Average Lead Time for Each Supplier',
             labels={'SupplierID': 'Supplier ID', 'AverageLeadTime': 'Average Lead Time (days)'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get lead time for each supplier
sql_query = '''
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
GROUP BY s.SupplierID, s.CompanyName
'''  

# Execute the SQL query and retrieve the data
lead_time_df = execute_sql_query(sql_query)

# Visualization of average lead time for each supplier
fig = px.bar(lead_time_df, x='CompanyName', y='AverageLeadTime',
             title='Average Lead Time for Each Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier Company Name'})

# Show the result to user
show_to_user(fig)",The input Python code fulfills the business analytic request by calculating the average lead time for each supplier and generating a visualization using Plotly. It correctly executes the SQL query and processes the data as required. The minor difference of including the supplier company name in the input code does not affect the correctness as it still meets the analytical requirement and provides the necessary visual comparison among suppliers.,"import pandas as pd
import plotly.express as px

# SQL query to get the average lead time for each supplier
sql_query = '''
SELECT p.SupplierID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.SupplierID;
'''

# Execute the SQL query and get the result in a dataframe
lead_time_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty for visualization
if not lead_time_df.empty:
    # Create a plotly bar chart to illustrate the average lead time for each supplier
    fig = px.bar(lead_time_df, x='SupplierID', y='AverageLeadTime', 
                 labels={'SupplierID': 'Supplier ID', 'AverageLeadTime': 'Average Lead Time (days)'}, 
                 title='Average Lead Time for Each Supplier')
    
    # Display the visualization to the user
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Error': ['No data available for visualization.']}))",The given code is correct as it meets the requirements of the business analytics request. The SQL query to calculate the average lead time per supplier is logically sound and correctly obtains the data. It then checks if the dataframe is not empty and creates a bar chart using Plotly to visualize the results. The chart is shown to the user using the provided show_to_user function. The code is consistent with the reference implementation and adheres to the Python environment constraints.,both
List all orders including the details of the employee who handled them.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT orders.OrderID, orders.CustomerID, orders.OrderDate, employees.LastName, employees.FirstName 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID;
'''

# Execute the SQL query and retrieve the data into a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Optional: Display the retrieved data to ensure it's correct (Uncomment to debug)
# print(orders_df)

# Visualizing the data (if needed)
fig = px.scatter(orders_df, x='OrderDate', y='OrderID', color='LastName', title='Orders and Handling Employees')

# Ensure the correct display of dates in the plot
fig.update_xaxes(type='category')

# Show the result to the user
show_to_user(fig)

# Alternatively, if just displaying the dataframe is required without visualization, use the following line instead:
# show_to_user(orders_df)","import pandas as pd

# Define the SQL query to retrieve orders and employee details
sql_query = '''
SELECT o.OrderID, o.CustomerID, o.OrderDate, o.RequiredDate, o.ShippedDate,
       o.ShipVia, o.Freight, o.ShipName, o.ShipAddress, o.ShipCity,
       o.ShipRegion, o.ShipPostalCode, o.ShipCountry,
       e.EmployeeID, e.FirstName, e.LastName, e.Title, e.TitleOfCourtesy
FROM orders o
JOIN employees e ON o.EmployeeID = e.EmployeeID
'''   

# Execute the SQL query and store the result in a DataFrame
data = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(data)","The given code retrieves the orders and their associated employee details as requested. It uses the provided utility functions correctly and displays the data to the user. Though it includes additional order details compared to the reference implementation, this does not violate the specific business analytic request.","import pandas as pd
import plotly.express as px

def list_orders_with_employee_details():
    # Define the SQL query
    sql_query = '''
    SELECT o.*, e.EmployeeID, e.FirstName, e.LastName 
    FROM orders o 
    JOIN employees e ON o.EmployeeID = e.EmployeeID;'''

    # Execute the SQL query to retrieve data
    df = execute_sql_query(sql_query)

    # Display the data to the user
    show_to_user(df)

# Call the function to perform the operation
list_orders_with_employee_details()","The input code correctly performs the task of listing all orders including the details of the employee who handled them. It constructs an appropriate SQL query to join the 'orders' and 'employees' tables, executes this query using the provided 'execute_sql_query' function, and then displays the resulting dataframe using the 'show_to_user' function. The code matches the request and follows the Python environment constraints.",both
What is the total quantity of products ordered from each employee? (Include a visualization such as a bar chart to compare the total quantities ordered from each employee.),"import plotly.express as px

# SQL query to get the total quantity of products ordered from each employee
sql_query = '''
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
'''

# Execute the SQL query using the provided utility function `execute_sql_query`
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total quantities ordered from each employee
fig = px.bar(df, x='EmployeeID', y='TotalQuantity', title='Total Quantity of Products Ordered from Each Employee', labels={'EmployeeID': 'Employee ID', 'TotalQuantity': 'Total Quantity'})

# Use the provided utility function `show_to_user` to display the bar chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Query to get the total quantity of products ordered from each employee
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
'''  

# Execute the SQL query
employee_orders = execute_sql_query(sql_query)

# Visualization: Bar chart for total quantities ordered from each employee
fig = px.bar(employee_orders, x='FirstName', y='TotalQuantity', color='LastName',
             title='Total Quantity of Products Ordered from Each Employee',
             labels={'FirstName': 'Employee First Name', 'TotalQuantity': 'Total Quantity Ordered'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly follows the requirements of the business analytic request and the Python environment constraints. It executes the required SQL query to get the total quantity of products ordered from each employee, creates a bar chart using Plotly to visualize this data, and uses the provided utility functions 'execute_sql_query' and 'show_to_user'. Although it includes the employee's first and last names, this provides more detailed information without altering the core functionality.","# Import the necessary libraries
import pandas as pd
import plotly.express as px

# SQL Query to get the total quantity of products ordered from each employee
sql_query = '''SELECT EmployeeID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY EmployeeID;'''

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(order_data, x='EmployeeID', y='TotalQuantity', title='Total Quantity of Products Ordered by Each Employee', labels={'EmployeeID': 'Employee ID', 'TotalQuantity': 'Total Quantity'})

# Show the visualization to the user
show_to_user(fig)","The input Python code only queries the 'Order Details' table, bypassing the necessary joins with the 'orders' and 'employees' tables required to correctly associate product quantities with the correct employees. This omits the direct link between EmployeeID and the orders made by them.",Base
How many orders were shipped late in the last month? (Include a time series visualization to show trends over the last few months.),"import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Utility function provided for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    pass  # placeholder for actual implementation

# Utility function provided for displaying data to the user
def show_to_user(data):
    pass  # placeholder for actual implementation

# Calculate date range for the last few months (assuming we want trends for the last 6 months)
end_date = datetime.now()
start_date = end_date - timedelta(days=180)

# SQL Query to get the number of orders shipped late in the last month
sql_query_last_month = '''
SELECT COUNT(orders.OrderID) AS Late_Orders 
FROM orders 
WHERE orders.RequiredDate < orders.ShippedDate 
AND MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
'''

df_late_orders_last_month = execute_sql_query(sql_query_last_month)

# SQL Query to get the number of orders shipped late over the last few months for trend analysis
sql_query_trend = f'''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS OrderMonth, COUNT(orders.OrderID) AS Late_Orders 
FROM orders 
WHERE orders.RequiredDate < orders.ShippedDate 
AND orders.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}' 
GROUP BY OrderMonth 
ORDER BY OrderMonth;
'''

df_trend = execute_sql_query(sql_query_trend)

# Plot the trend data
fig = px.line(df_trend, x='OrderMonth', y='Late_Orders', title='Late Orders Trend Over the Last Few Months')

# Display the trend plot to the user
show_to_user(fig)

# Optionally, display the number of late orders last month
display_text = f'Total number of late orders last month: {df_late_orders_last_month.iloc[0]['Late_Orders']}'
show_to_user(pd.DataFrame({'': [display_text]}))","import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the date range for the last month
end_date = datetime.now().date()
start_date = (end_date - timedelta(days=30)).date()

# SQL query to find orders that were shipped late in the last month
sql_query = f""""""
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    COUNT(OrderID) AS late_orders
FROM
    orders
WHERE
    ShippedDate > RequiredDate AND
    OrderDate >= '{start_date}' AND
    OrderDate <= '{end_date}'
GROUP BY
    month
ORDER BY
    month;
""""""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Show the count of late orders in the last month
show_to_user(late_orders_df)

# Time series visualization for trends in late orders over the last few months
sql_query_trend = f""""""
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    COUNT(OrderID) AS late_orders
FROM
    orders
WHERE
    ShippedDate > RequiredDate
GROUP BY
    month
ORDER BY
    month;
""""""

# Execute the trend query
trend_df = execute_sql_query(sql_query_trend)

# Create a time series line plot
fig = px.line(trend_df, x='month', y='late_orders', title='Late Orders Trend Over Last Months',
              labels={'month': 'Month', 'late_orders': 'Late Orders Count'})

# Show the plot to the user
show_to_user(fig)","The given code does not specifically calculate the exact number of late orders for the last month as required, nor does it accurately represent the trend for the last few months within a specific date range. It also does not follow the reference code logic to calculate monthly late orders trends within a defined date range.","import pandas as pd
import plotly.express as px

# Define the SQL query to fetch counts of late orders per month over the last few months
sql_time_series_query = '''
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(*) AS LateOrders
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month ASC;  -- Ensure data is sorted by Month
'''

# Execute the SQL query to find the time series data
time_series_df = execute_sql_query(sql_time_series_query)

# Ensure that the Month column is treated as a datetime type for correct sorting
time_series_df['Month'] = pd.to_datetime(time_series_df['Month'], format='%Y-%m')

# DataFrame manipulations
# Sort the data by Month
time_series_df = time_series_df.sort_values(by='Month')

# Visualization using Plotly
fig = px.line(time_series_df, x='Month', y='LateOrders', title='Late Orders Over the Last Few Months', labels={'LateOrders': 'Number of Late Orders', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)
","The input code does not correctly filter the orders to only include those from the last month. It also lacks the logic to calculate the exact number of late orders for the last month specifically. Additionally, the time series visualization might not meet the requirement to determine trends over the last few months as it includes all months available in the dataset without restriction to a specific range like the last 6 months.",None
"How many orders were shipped late (i.e., shipped after the required date)? (Visualize the frequency of late shipments over time.)","import pandas as pd
import plotly.express as px

# Execute the SQL query to find late orders
sql_query = 'SELECT COUNT(*) AS LateOrders FROM orders WHERE ShippedDate > RequiredDate;'
data = execute_sql_query(sql_query)

# Calculate the frequency of late shipments over time
sql_query_late_shipments = 'SELECT ShippedDate, COUNT(*) as LateOrders FROM orders WHERE ShippedDate > RequiredDate GROUP BY ShippedDate;'
late_shipments_data = execute_sql_query(sql_query_late_shipments)

# Convert ShippedDate to datetime
late_shipments_data['ShippedDate'] = pd.to_datetime(late_shipments_data['ShippedDate'])

# Visualize the frequency of late shipments over time
fig = px.line(late_shipments_data, x='ShippedDate', y='LateOrders', title='Frequency of Late Shipments Over Time')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to find late shipments.
sql_query = '''
SELECT ShippedDate, COUNT(*) AS LateShipments
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY ShippedDate
ORDER BY ShippedDate
'''

# Execute the SQL query and retrieve the data.
late_shipments_df = execute_sql_query(sql_query)

# Visualize the frequency of late shipments over time.
fig = px.line(late_shipments_df, x='ShippedDate', y='LateShipments', 
              title='Frequency of Late Shipments Over Time', 
              labels={'ShippedDate': 'Shipped Date', 'LateShipments': 'Count of Late Shipments'})

# Show the visualization to the user.
show_to_user(fig)",The input Python code correctly retrieves the count of late shipments and visualizes the frequency of late shipments over time using Plotly. It aligns with the business analytic request and meets the Python environment constraints by utilizing the 'execute_sql_query' and 'show_to_user' functions appropriately. The minor difference in SQL query structure and column naming does not affect the correctness of the implementation.,"import pandas as pd
import plotly.express as px

# Define the SQL query to count late shipments
sql_query = 'SELECT OrderID, OrderDate, RequiredDate, ShippedDate FROM orders WHERE ShippedDate > RequiredDate'

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Add a new column to indicate if an order was shipped late
orders_df['ShippedLate'] = orders_df['ShippedDate'] > orders_df['RequiredDate']

# Filter the dataframe to only include late shipments
late_shipments_df = orders_df[orders_df['ShippedLate']]

# Group by month to get the frequency of late shipments over time
late_shipments_df['OrderDate'] = pd.to_datetime(late_shipments_df['OrderDate'])
late_shipments_df.set_index('OrderDate', inplace=True)
monthly_late_shipments = late_shipments_df.resample('M').size()

# Visualize the frequency of late shipments over time
fig = px.line(monthly_late_shipments, x=monthly_late_shipments.index, y=monthly_late_shipments.values, title='Frequency of Late Shipments Over Time', labels={'x': 'Date', 'y': 'Number of Late Shipments'})
show_to_user(fig)

# Display the number of late shipments for confirmation
print(f'Total number of late shipments: {len(late_shipments_df)}')
show_to_user(f'Total number of late shipments: {len(late_shipments_df)}')","While the input code does correctly identify late shipments and visualizes the frequency of late shipments over time, it differs from the reference implementation in two main aspects: 1) it groups the late shipments by month rather than by the exact shipment date which can lead to a different visualization and analysis granularity, and 2) it outputs the total number of late shipments differently. Both these differences result in it not conforming to the business analytic request as exactly outlined.",Base
Which employee has the most orders shipped on time? (Include a visualization to compare the on-time shipment rates among employees.),"import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
top_employee_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OnTimeOrders 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.ShippedDate <= o.RequiredDate 
GROUP BY e.EmployeeID;'''

# Step 2: Execute the SQL query to get the data
employees_df = execute_sql_query(top_employee_query)

# Step 3: Find the employee with the most on-time orders
max_ontime_employee = employees_df.loc[employees_df['OnTimeOrders'].idxmax()]

# Display the employee with the most on-time orders
top_employee_data = pd.DataFrame([max_ontime_employee])
show_to_user(top_employee_data)

# Step 4: Visualize the on-time shipment rates among employees
fig = px.bar(employees_df, x='EmployeeID', y='OnTimeOrders', 
             title='On-Time Orders per Employee', 
             labels={'EmployeeID': 'Employee ID', 'OnTimeOrders': 'On-Time Orders'})

# Step 5: Show the visualization to the user
show_to_user(fig)

","import pandas as pd
import plotly.express as px

# Query to retrieve on-time shipment data for each employee
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName,
       COUNT(o.OrderID) AS TotalOrders,
       SUM(CASE WHEN o.ShippedDate <= o.RequiredDate THEN 1 ELSE 0 END) AS OnTimeOrders
FROM employees AS e
JOIN orders AS o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
'''

# Execute the SQL query and store the result in a DataFrame
employee_orders = execute_sql_query(sql_query)

# Calculate On-Time Shipment Rate
employee_orders['OnTimeRate'] = employee_orders['OnTimeOrders'] / employee_orders['TotalOrders']

# Identify the employee with the highest on-time shipment rate
best_employee = employee_orders.loc[employee_orders['OnTimeRate'].idxmax()]

# Visualization: Create a bar chart to compare on-time shipment rates among employees
fig = px.bar(employee_orders,
             x='LastName',
             y='OnTimeRate',
             title='On-Time Shipment Rates by Employee',
             labels={'OnTimeRate': 'On-Time Rate', 'LastName': 'Employee Last Name'},
             text='OnTimeRate')

# Show the figure to the user
show_to_user(fig)

# Print the best employee's details
best_employee_details = {
    'EmployeeID': best_employee['EmployeeID'],
    'Name': f""{best_employee['FirstName']} {best_employee['LastName']}"",
    'OnTimeOrders': best_employee['OnTimeOrders'],
    'TotalOrders': best_employee['TotalOrders'],
    'OnTimeRate': best_employee['OnTimeRate']
}

print(best_employee_details)","The input code calculates the on-time shipment rate rather than finding the employee with the most orders shipped on time, which deviates from the specified business analytic request. Moreover, it focuses on the on-time shipment rates rather than the absolute number of on-time orders. Additionally, it prints the best employee's details instead of using the 'show_to_user' function.","To address the request of identifying the employee with the most orders shipped on time and providing a visualization to compare the on-time shipment rates among employees, we will utilize the `pandas` and `plotly` libraries.

### Step-by-Step Code Breakdown
1. **SQL Query**: We need a SQL query that fetches the `EmployeeID` and the count of on-time orders. Since on-time orders are those with `ShippedDate` before or on `RequiredDate`, we will apply this condition in our SQL query.
  
   The SQL query could look like this:
   ```sql
   SELECT EmployeeID, COUNT(OrderID) AS OnTimeOrders
   FROM orders
   WHERE ShippedDate <= RequiredDate
   GROUP BY EmployeeID
   ORDER BY OnTimeOrders DESC;
   ```

2. **Fetch Data**: We'll execute the SQL query to retrieve data into a pandas DataFrame.

3. **Visualization**: We will create a bar chart comparing the on-time shipment rates among employees. The most on-time shipments can be highlighted distinctly.

4. **Display Results**: Finally, the most on-time shipment employee data and the plot will be displayed to the user.

### Final Python Code
Here's the complete code implementing the above logic:

```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of on-time shipments per employee
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OnTimeOrders 
FROM orders 
WHERE ShippedDate <= RequiredDate 
GROUP BY EmployeeID 
ORDER BY OnTimeOrders DESC;
'''

# Execute the query
df = execute_sql_query(sql_query)

# Display the DataFrame to the user
show_to_user(df)

# Create a bar chart for visualization
fig = px.bar(df, x='EmployeeID', y='OnTimeOrders',
             title='On-Time Shipments by Employee',
             labels={'OnTimeOrders': 'Number of On-Time Orders'},
             template='plotly_dark')

# Highlight the employee with the most on-time orders
most_on_time_employee = df.iloc[0]
fig.add_annotation(x=most_on_time_employee['EmployeeID'],
                   y=most_on_time_employee['OnTimeOrders'],
                   text='Most On-Time Employee',
                   showarrow=True,
                   arrowhead=2)

# Show the visualization to the user
show_to_user(fig)
```

### Explanation:
- The SQL query retrieves the number of on-time orders for each employee and sorts them in descending order.
- The bar chart is generated using `plotly`, showing on-time orders for each employee. The annotation highlights the employee with the highest count of on-time orders.
- The `execute_sql_query` function executes the SQL query and retrieves the data, while `show_to_user` shows the results to the user.

### Important Considerations:
Make sure that the necessary libraries (`pandas` and `plotly`) are installed and available in your execution environment.","The code provided correctly follows the required steps to fulfill the business request. It defines and executes the necessary SQL query to retrieve the number of on-time orders for each employee, finds the employee with the most on-time orders, and creates an appropriate visualization using plotly. Both the `execute_sql_query` and `show_to_user` utility functions are properly used as per the Python environment constraints.",Finetuned
What is the most frequently ordered product? (Include a pie chart or bar chart to show the frequency of orders for different products.),"import plotly.express as px

# SQL query to fetch the frequency of orders for different products
sql_query = '''
SELECT p.ProductName, COUNT(od.ProductID) AS OrderCount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY OrderCount DESC;''' 

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Create a bar chart to show the frequency of orders for different products
fig = px.bar(order_data, x='ProductName', y='OrderCount', title='Frequency of Orders for Different Products')

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Write an SQL query to get the product frequency data
sql_query = '''
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
'''

# Step 2: Execute the SQL query to retrieve the data
product_frequency_df = execute_sql_query(sql_query)

# Step 3: Get the most frequently ordered product
most_frequent_product = product_frequency_df.iloc[0]

# Step 4: Create a bar chart for product frequency
fig = px.bar(product_frequency_df, x='ProductID', y='TotalQuantity', title='Frequency of Ordered Products')

# Step 5: Show results to the user
show_to_user(fig)","The input code provided for evaluation differs from the business analytic request and the reference implementation in several key aspects. The business analytic request requires finding the most frequently ordered product based on order count, while the input code calculates total quantity ordered per product. Additionally, the input code does not retrieve product names but only product IDs, making it harder to interpret the results. Therefore, the input code does not meet the specified business analytic request properly.","import pandas as pd
import plotly.express as px

# SQL query to get the frequency of orders per product
sql_query = ""SELECT ProductID, COUNT(*) AS OrderCount FROM [Order Details] GROUP BY ProductID ORDER BY OrderCount DESC;""

# Execute the SQL query to retrieve data
order_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(order_data, x='ProductID', y='OrderCount', title='Order Frequency per Product', labels={'ProductID': 'Product ID', 'OrderCount': 'Order Count'})

# Show the bar chart to the user
show_to_user(fig)","The input code's SQL query and the subsequent chart use 'ProductID' instead of 'ProductName', which does not directly address the business request to identify the most frequently ordered product by name. Additionally, using 'ProductName' makes the chart more informative for end users.",None
Which products have a unit price greater than 50?,"import pandas as pd

# SQL query to retrieve product names with unit price greater than 50
sql_query = 'SELECT ProductName FROM products WHERE UnitPrice > 50;'

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Check if the result_df is not empty and has the required data
if not result_df.empty:
    # Display the result to the user
    show_to_user(result_df)
else:
    print('No products found with unit price greater than 50.')","import pandas as pd

# SQL query to select products with a unit price greater than 50
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice 
FROM products 
WHERE UnitPrice > 50
""""""

# Execute the query and get the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)",The input Python code correctly retrieves products with a unit price greater than 50 and displays the result to the user. It aligns with the business analytic request and uses the provided utility functions as required.,"import pandas as pd
import plotly.express as px

# SQL Query to fetch products with a unit price greater than 50
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitPrice > 50;'

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The provided input code correctly fetches products with a unit price greater than 50 using an SQL query, retrieves the data as a pandas DataFrame, and displays the result using the show_to_user function. This fulfills the business analytic request and aligns with the Python environment constraints.",both
How many units of each product were ordered last month? (Include a bar chart to compare the number of units ordered per product.),"import plotly.express as px

# Define the SQL query to fetch data
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS UnitsOrderedLastMonth 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderDate >= DATEADD(month, -1, GETDATE()) 
GROUP BY products.ProductID;
'''

# Execute the SQL query and retrieve the data as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty before creating the bar chart
if not df.empty:
    # Create a bar chart using plotly
    fig = px.bar(df, x='ProductID', y='UnitsOrderedLastMonth', 
                 title='Units Ordered Last Month per Product',
                 labels={'ProductID': 'Product ID', 'UnitsOrderedLastMonth': 'Units Ordered Last Month'})

    # Display the bar chart to the user
    show_to_user(fig)
else:
    print('No data found for the given query.')
","import pandas as pd
import plotly.express as px

# Define the SQL query to get the product orders for last month
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) as TotalOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID FROM Orders WHERE MONTH(OrderDate) = MONTH(DATEADD(MONTH, -1, GETDATE()))
    AND YEAR(OrderDate) = YEAR(DATEADD(MONTH, -1, GETDATE()))
)
GROUP BY p.ProductName
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart to compare the number of units ordered per product
fig = px.bar(result_df, x='ProductName', y='TotalOrdered', title='Units Ordered per Product Last Month')

# Show the result to the user
show_to_user(fig)",The provided code correctly meets the business analytic request by executing an SQL query to retrieve the sum of quantities ordered for each product last month. It then uses Plotly to create and display a bar chart comparing the number of units ordered per product. The code properly handles date filtering and matches the purpose of the reference implementation.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ProductID, SUM(Quantity) AS TotalQuantity
FROM [Order Details]
WHERE OrderDate BETWEEN DATEADD(MONTH, -1, GETDATE()) AND GETDATE()
GROUP BY ProductID;
'''

# Execute the SQL query and get the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Check if the DataFrame has the expected columns
if 'ProductID' in df.columns and 'TotalQuantity' in df.columns:
    # Create a bar chart using Plotly
    fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Units Ordered per Product Last Month')

    # Show the result visualization to the user
    show_to_user(fig)
else:
    raise ValueError('The DataFrame does not contain the expected columns: ProductID, TotalQuantity')",The provided code meets the requirements. It correctly constructs an SQL query to fetch the total quantity of each product ordered in the last month and visualizes the results in a bar chart using Plotly. The structure and functionality are aligned with the reference implementation and business analytic request.,both
Which shipping company has the highest on-time delivery rate? (Include a visualization comparing on-time delivery rates among shipping companies.),"import pandas as pd
import plotly.express as px

# SQL Query to retrieve on-time delivery rates of shipping companies
sql_query = '''
SELECT shippers.CompanyName, 
       COUNT(orders.OrderID) AS total_orders, 
       SUM(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 ELSE 0 END) AS on_time_orders
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY on_time_orders / CAST(COUNT(orders.OrderID) AS FLOAT) DESC
LIMIT 1
''' 

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Data preprocessing if needed
result_df['on_time_delivery_rate'] = result_df['on_time_orders'] / result_df['total_orders']

# Create a bar chart visualization with Plotly
fig = px.bar(result_df, x='CompanyName', y='on_time_delivery_rate', 
             title='On-time Delivery Rates by Shipping Companies',
             labels={'on_time_delivery_rate': 'On-Time Delivery Rate', 'CompanyName': 'Shipping Company'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rates by shipping company
sql_query = """"""
SELECT shippers.CompanyName,
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
ORDER BY on_time_delivery_rate DESC
""""""

# Execute SQL query
on_time_delivery_df = execute_sql_query(sql_query)

# Show the results to user
show_to_user(on_time_delivery_df)

# Visualization
fig = px.bar(on_time_delivery_df,
             x='CompanyName',
             y='on_time_delivery_rate',
             title='On-time Delivery Rates by Shipping Company',
             labels={'on_time_delivery_rate': 'On-time Delivery Rate (%)', 'CompanyName': 'Shipping Company'},
             text='on_time_delivery_rate')

# Update layout
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig.update_layout(yaxis_tickformat='%')

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly calculates the on-time delivery rate for each shipping company, sorts the companies by their on-time delivery rates, and visualizes the results using a bar chart in Plotly. It fulfills the business request by determining and comparing the on-time delivery rates of different shipping companies. Additionally, the code adheres to the provided Python environment constraints for data retrieval and visualization.","import plotly.express as px

# Define the SQL query
df_query = '''
SELECT shippers.ShipperID, 
       AVG(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 ELSE 0 END) AS delivery_rate 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.ShipperID 
ORDER BY delivery_rate DESC
'''

# Execute the SQL query
df = execute_sql_query(df_query)

# Filter to get the shipper with the highest on-time delivery rate
highest_delivery_rate_shipper = df.iloc[0]

# Print the ShipperID and its delivery rate
print(f'Shipper with highest delivery rate: {highest_delivery_rate_shipper[""ShipperID""]}, Delivery Rate: {highest_delivery_rate_shipper[""delivery_rate""]}')

# Create a visualization of on-time delivery rates among shipping companies
fig = px.bar(df, x='ShipperID', y='delivery_rate', title='On-Time Delivery Rates by Shipper', labels={'ShipperID': 'Shipper ID', 'delivery_rate': 'On-Time Delivery Rate'})

# Show the visualization
show_to_user(fig)
","The provided Python code implementation has a few issues in comparison to the reference code. Firstly, it does not join the 'Shippers' table to retrieve the company names, using 'ShipperID' instead. Secondly, it calculates the average 'delivery_rate' directly within the SQL query, which might differentiate from the on-time count and overall count division used in the reference. Lastly, it fails to integrate a column named 'CompanyName' for more readable visualization and comparison of on-time rates among shipping companies.",Base
What is the total discount amount given for each product? (Include a bar chart to compare the total discount amounts among products.),"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName;
'''

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Ensure the dataframe is not empty
if not df.empty:
    # Generate the bar chart using plotly
    fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Total Discount Amount for Each Product')
    # Show the bar chart to the user
    show_to_user(fig)
else:
    show_to_user('No data available for the query.')","import pandas as pd
import plotly.express as px

# SQL query to calculate total discount amount for each product
sql_query = '''
SELECT 
    p.ProductName, 
    SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
GROUP BY 
    p.ProductName
'''  

# Execute the SQL query and retrieve the data
discount_data = execute_sql_query(sql_query)

# Display the data to user
show_to_user(discount_data)

# Create a bar chart to visualize the total discount amounts among products
fig = px.bar(discount_data, x='ProductName', y='TotalDiscount', title='Total Discount Amount by Product',
             labels={'TotalDiscount': 'Total Discount Amount', 'ProductName': 'Product Name'})

# Show the plotly figure to the user
show_to_user(fig)","The input Python code is correct as it retrieves the total discount amount for each product and visualizes it with a bar chart. The SQL query correctly calculates total discounts without omitting the multiplication by UnitPrice, assuming UnitPrice is not meant to be part of discount calculation. The functions execute_sql_query and show_to_user are used as per the constraints.","
import plotly.express as px

# SQL query to get the total discount amount for each product
sql_query = '''
SELECT ProductID, SUM(Quantity * UnitPrice * Discount) AS TotalDiscountAmount 
FROM [Order Details] 
GROUP BY ProductID;
'''

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Generate a bar chart to compare the total discount amounts among products
fig = px.bar(discount_data, x='ProductID', y='TotalDiscountAmount', title='Total Discount Amount per Product', labels={'ProductID':'Product ID', 'TotalDiscountAmount':'Total Discount Amount'})

# Display the plotly figure
show_to_user(fig)
","The input Python code implementation does not join the products table to retrieve product names, which prevents it from displaying the product names in the bar chart. The reference implementation groups by ProductName, whereas the input implementation groups by ProductID. Additionally, the labels for the bar chart in the input implementation should match those described in the business analytic request.",Base
Calculate the total number of products sold by each employee. (Include a bar chart to compare the number of products sold by each employee.),"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, 
       SUM([Order Details].Quantity) AS TotalProductsSold 
FROM employees 
INNER JOIN orders ON employees.EmployeeID = orders.EmployeeID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID
'''

# Execute the query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Check if result_df is empty
if result_df.empty:
    raise ValueError('The query returned no results')

# Generate a bar chart using plotly express
fig = px.bar(result_df, x='EmployeeID', y='TotalProductsSold', 
             title='Total Number of Products Sold by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalProductsSold': 'Total Products Sold'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total number of products sold by each employee
sql_query = '''
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.Quantity) AS TotalProductsSold
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, EmployeeName
ORDER BY TotalProductsSold DESC;
'''

# Execute the SQL query and retrieve the results
results_df = execute_sql_query(sql_query)

# Generate a bar chart to compare the number of products sold by each employee
fig = px.bar(results_df, 
             x='EmployeeName', 
             y='TotalProductsSold', 
             title='Total Products Sold by Each Employee', 
             labels={'TotalProductsSold': 'Number of Products Sold', 'EmployeeName': 'Employee Name'},
             color='TotalProductsSold', 
             text='TotalProductsSold')

# Show the results to the user
show_to_user(fig)","The input code correctly implements the business analytic request. It calculates the total number of products sold by each employee and visualizes the result using a bar chart. The code executes the SQL query, processes the results into a pandas DataFrame, and uses plotly express to generate the bar chart, which is then displayed to the user. Additionally, it includes employee names for better readability.","import plotly.express as px

# Execute the SQL query to get the total number of products sold by each employee
sql_query = '''
SELECT e.EmployeeID, SUM(od.Quantity) as TotalProductsSold 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalProductsSold DESC;
'''
data = execute_sql_query(sql_query)

# Check if data is returned and contains the expected columns
if 'EmployeeID' not in data.columns or 'TotalProductsSold' not in data.columns:
    raise ValueError('The query result does not contain the expected columns: EmployeeID and TotalProductsSold')

# Create a bar chart using plotly
fig = px.bar(data, x='EmployeeID', y='TotalProductsSold', title='Total Number of Products Sold by Each Employee', labels={'EmployeeID': 'Employee ID', 'TotalProductsSold': 'Total Products Sold'})

# Show the plot to the user
show_to_user(fig)","The input Python code correctly follows the provided business analytic request and the Python environment constraints. It calculates the total number of products sold by each employee, and it includes the generation of a bar chart using plotly to compare the number of products sold by each employee. The input code also includes checks to ensure the expected columns ('EmployeeID' and 'TotalProductsSold') are present in the result.",both
List customers who have not placed any orders in the last year.,"import pandas as pd
import plotly.express as px

# SQL query to list customers who have not placed any orders in the last year
sql_query = '''
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderID IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the dataframe is not empty before displaying to the user
if not result_df.empty:
    show_to_user(result_df)
else:
    print('No customers found who have not placed any orders in the last year.')","from datetime import datetime, timedelta

# Calculate the date one year ago from today
one_year_ago = (datetime.now() - timedelta(days=365)).date()

# SQL query to get customers with no orders in the last year
sql_query = f""""""
SELECT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, c.City, c.Region, c.PostalCode, c.Country, c.Phone, c.Fax
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID AND o.OrderDate >= '{one_year_ago}'
WHERE o.OrderID IS NULL
""""""

# Execute the SQL query and get the result
no_orders_customers_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(no_orders_customers_df)","The input code meets the requirements of listing customers who have not placed any orders in the last year. It correctly filters customers using a LEFT JOIN and checks for NULL order entries, aligns with the business request, and is expected to deliver a similar result to the reference implementation. Additionally, the code follows the given Python environment constraints, utilizing execute_sql_query and show_to_user functions appropriately.","import pandas as pd
import plotly.express as px

# SQL query to get customers who have not placed any orders in the last year
query = ""SELECT CustomerID FROM customers WHERE CustomerID NOT IN (SELECT DISTINCT CustomerID FROM orders WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR));""

# Execute the SQL query
customers_df = execute_sql_query(query)

# Display the customers DataFrame to the user
show_to_user(customers_df)","The input Python code correctly identifies the customers who have not placed any orders in the last year. It successfully uses the SQL query to find customers whose CustomerID is not in the set of CustomerIDs from orders in the past year, executes it, and displays the result using the show_to_user function. This matches the given business analytic request and is consistent with the reference implementation.",both
Identify products with a unit price greater than the average unit price across all products. (Include a comparison of prices in a bar chart or similar visualization.),"import pandas as pd
import plotly.express as px

# Define the SQL query to get products with unit prices greater than the average unit price
sql_query = '''
SELECT p.ProductID, p.ProductName, p.UnitPrice 
FROM products p 
WHERE p.UnitPrice > (SELECT AVG(UnitPrice) FROM products);
'''

# Execute the SQL query
products_above_average_price = execute_sql_query(sql_query)

# Define the SQL query to get the average unit price for all products
avg_price_query = 'SELECT AVG(UnitPrice) as AvgPrice FROM products;'

# Execute the SQL query to get the average unit price
avg_price_df = execute_sql_query(avg_price_query)
avg_price = avg_price_df['AvgPrice'][0]

# Create a comparison bar chart
fig = px.bar(products_above_average_price, x='ProductName', y='UnitPrice', 
             title='Products with Unit Price Greater than the Average',
             labels={'UnitPrice': 'Unit Price'}, 
             text='UnitPrice')

# Add a line for the average price
fig.add_hline(y=avg_price, line_dash='dash', line_color='red', annotation_text='Average Price', annotation_position='bottom right')

# Display the bar chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Step 1: Retrieve product data from the database
product_query = ""SELECT ProductID, ProductName, UnitPrice FROM products""
products_df = execute_sql_query(product_query)

# Step 2: Calculate the average unit price
average_unit_price = products_df['UnitPrice'].mean()

# Step 3: Identify products with a unit price greater than the average unit price
high_price_products = products_df[products_df['UnitPrice'] > average_unit_price]

# Step 4: Create a bar chart to visualize the comparison of prices
fig = px.bar(high_price_products, x='ProductName', y='UnitPrice', title='Products with Unit Price Greater than Average Unit Price',
             labels={'UnitPrice': 'Unit Price', 'ProductName': 'Product Name'})

# Step 5: Show the bar chart to the user
show_to_user(fig)","The provided code correctly identifies products with a unit price greater than the average unit price and visualizes them in a bar chart. However, it misses the addition of a line for the average price in the bar chart, which is a key feature requested in the business analytic request.","import pandas as pd
import plotly.express as px

# Define SQL queries for the main requirement and the average price
sql_query = 'SELECT ProductID, ProductName, UnitPrice FROM products WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products);'

# Execute the SQL query to retrieve products with a unit price greater than the average
products_above_avg = execute_sql_query(sql_query)

# Generate a bar chart to visualize products with unit prices above the average
fig = px.bar(products_above_avg, x='ProductName', y='UnitPrice', title='Products with Unit Price Greater than Average', labels={'UnitPrice': 'Unit Price', 'ProductName': 'Product Name'})

# Display the visualization
show_to_user(fig)","The input code does generate the bar chart correctly, but it is missing the inclusion of the average price line in the visualization. This is an important aspect of the original business analytics request and reference implementation.",None
What is the most frequently ordered product in 2023? (Include a bar chart to show the frequency of orders for each product in 2023.),"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, products.ProductName, COUNT([Order Details].OrderID) AS order_count 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE YEAR([Order Details].OrderDate) = 2023 
GROUP BY products.ProductID, products.ProductName 
ORDER BY order_count DESC
'''

# Execute the SQL query to retrieve data
product_orders_df = execute_sql_query(sql_query)

# Generate the bar chart for order frequencies for each product in 2023
fig = px.bar(product_orders_df, x='ProductName', y='order_count', title='Frequency of Orders for Each Product in 2023')

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to find the product frequency in 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS frequency
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY frequency DESC
LIMIT 1;  -- To get the most frequently ordered product
""""""

# Execute the SQL query
most_frequent_product_df = execute_sql_query(sql_query)

# Get the most frequently ordered product name
most_frequent_product_name = most_frequent_product_df.iloc[0]['ProductName']

# SQL query to find product frequencies for the bar chart
sql_query_frequencies = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS frequency
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY frequency DESC
""""""

# Execute the SQL query for frequencies
frequencies_df = execute_sql_query(sql_query_frequencies)

# Create a bar chart for product frequencies
fig = px.bar(frequencies_df, x='ProductName', y='frequency',
             title='Frequency of Orders for Each Product in 2023',
             labels={'frequency': 'Frequency of Orders', 'ProductName': 'Product Name'})

# Show the result to the user
show_to_user(fig)

# Display the most frequently ordered product
print(f'The most frequently ordered product in 2023 is: {most_frequent_product_name}')","The input code uses `SUM([Order Details].Quantity)` in the SQL query to find the most frequently ordered product, whereas the business analytic request focuses on the count of orders, not the total quantity ordered. The correct logic should count the number of orders instead of summing quantities. Additionally, the input code uses a `LIMIT 1` clause in the first query, which is unnecessary for gathering complete data to show the bar chart. The reference implementation correctly uses `COUNT([Order Details].OrderID)` to determine order frequencies.","To solve the request, we can follow these steps:

1. Execute the SQL query to get the product frequencies for 2023.
2. Generate and display a bar chart using Plotly.

Hereâ€™s how we can implement it:

```python
# import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to get the product ID with the highest order frequency in 2023
sql_query = """"""
SELECT ProductID, COUNT(*) AS Frequency 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY ProductID 
ORDER BY Frequency DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the most frequently ordered product
most_frequent_product = df.iloc[0]
show_to_user(most_frequent_product)

# Create a bar chart for the frequency of orders for each product
fig = px.bar(df, x='ProductID', y='Frequency', title='Frequency of Orders for Each Product in 2023', labels={'ProductID': 'Product ID', 'Frequency': 'Order Frequency'})

# Display the bar chart
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: The SQL query retrieves the total count of orders grouped by ProductID for the year 2023. The results are ordered by frequency in descending order.
2. **Execute SQL Query**: `execute_sql_query(sql_query)` runs the SQL query and returns the results as a pandas DataFrame.
3. **Display Most Frequently Ordered Product**: The code extracts the most frequent product (the first row of the dataframe) and displays it.
4. **Create Bar Chart**: The bar chart is created using Plotly Express `px.bar()` which generates a visualization of the order frequency for each product.
5. **Show the Bar Chart**: The bar chart is displayed for the user using the `show_to_user(fig)` function.","The input Python code does not match the requirements of the business analytic request. The SQL query in the input code does not join the Order Details with the Products table to get the ProductName, which means the bar chart does not show the product names, only the Product IDs. Moreover, it is missing the necessary join and grouping by ProductName, which is critical to meet the query requirements and context given in the reference implementation.",None
What are the names and IDs of all products that are currently out of stock?,"import pandas as pd

# SQL query to get the names and IDs of all products that are currently out of stock
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;'

# Execute the SQL query and get the result as a pandas dataframe
# Note: Assuming `execute_sql_query` is a provided utility function as mentioned

df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)","import pandas as pd

# SQL query to get product names and IDs of all products that are out of stock
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE UnitsInStock = 0 AND Discontinued = 0
""""""

# Execute the SQL query and retrieve the results
out_of_stock_products = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(out_of_stock_products)","The input code adds an additional condition (Discontinued = 0) that filters out products that are discontinued, which by the business analytic request, is not required. This results in the output excluding some products that are out of stock but discontinued.","import pandas as pd

# Define the SQL query to get the IDs and names of products out of stock
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user in a readable format
show_to_user(result_df)","The input Python code correctly follows the specified business analytic request and matches the reference implementation. The SQL query retrieves IDs and names of products that are currently out of stock, and the query result is shown to the user using the provided utility functions.",Finetuned
How many products were low on stock (below reorder level) in August 2023? (Include a visualization to show the number of low-stock products over time.),"import pandas as pd
import plotly.express as px

# SQL query to retrieve low-stock products in August 2023
sql_query = '''SELECT products.ProductID, products.RecordDate
               FROM products
               WHERE products.UnitsInStock < products.ReorderLevel
               AND MONTH(products.RecordDate) = 8
               AND YEAR(products.RecordDate) = 2023''' 

# Execute the SQL query
low_stock_df = execute_sql_query(sql_query)

# Convert RecordDate to datetime for better manipulation
low_stock_df['RecordDate'] = pd.to_datetime(low_stock_df['RecordDate'])

# Extract date components for more structured analysis
low_stock_df['Date'] = low_stock_df['RecordDate'].dt.date

# Group by date to get count of low-stock products for each day
low_stock_count = low_stock_df.groupby('Date').size().reset_index(name='LowStockCount')

# Create a line plot to visualize the number of low-stock products over time
fig = px.line(low_stock_count, x='Date', y='LowStockCount', title='Low-Stock Products in August 2023', labels={'LowStockCount': 'Number of Low-Stock Products'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the number of low-stock products in August 2023
sql_query = '''
SELECT COUNT(*) AS low_stock_count 
FROM products 
WHERE UnitsInStock < ReorderLevel 
AND ReorderLevel > 0
AND ProductID IN (
    SELECT DISTINCT pd.ProductID
    FROM [Order Details] AS pd 
    JOIN orders AS o ON pd.OrderID = o.OrderID
    WHERE o.OrderDate BETWEEN '2023-08-01' AND '2023-08-31'
)
'''  

# Execute the SQL query to get low-stock product count
low_stock_df = execute_sql_query(sql_query)

# SQL query to get low stock products over time (monthly)
sql_query_trend = '''
SELECT DATE_TRUNC('month', o.OrderDate) AS month,
       COUNT(*) AS low_stock_count
FROM products p
JOIN [Order Details] pd ON p.ProductID = pd.ProductID
JOIN orders o ON pd.OrderID = o.OrderID
WHERE p.UnitsInStock < p.ReorderLevel
AND o.OrderDate >= '2023-01-01' AND o.OrderDate <= '2023-12-31'
GROUP BY month
ORDER BY month
'''  

# Execute trend SQL query
low_stock_trend_df = execute_sql_query(sql_query_trend)

# Create a line plot for low stock products over time
fig = px.line(low_stock_trend_df, x='month', y='low_stock_count', 
              title='Number of Low-Stock Products Over Time', 
              labels={'month': 'Month', 'low_stock_count': 'Low Stock Count'})

# Show the low-stock product count result to the user
show_to_user(low_stock_df)  
# Show the trend visualization to the user
show_to_user(fig)","The input code does not correctly match the business analytic request. The first part of the input code retrieves the number of low-stock products in August 2023 but in a different manner compared to the reference code. More critically, instead of counting low-stock products by each day in August 2023, it aggregates low-stock products over all months in 2023 and plots this trend which is not the requested analysis. The visualization should specifically show the daily low-stock product counts for August 2023, not a monthly trend for the entire year.","
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch products low on stock in August 2023
sql_query = '''
SELECT p.ProductID, p.ProductName 
FROM products p 
WHERE p.UnitsInStock < p.ReorderLevel 
  AND p.Discontinued = 0 
  AND p.CreatedAt BETWEEN '2023-08-01' AND '2023-08-31'
'''

# Execute the SQL query
low_stock_products_df = execute_sql_query(sql_query)

# Count the number of low-stock products in August 2023
low_stock_count = low_stock_products_df.shape[0]

# Display the count to the user
show_to_user(pd.DataFrame({'August_2023_Low_Stock_Products_Count': [low_stock_count]}))

# Additional Query: Get the data for visualization over time
# Assuming we want to visualize over a broader time span, e.g., the last few months
time_series_query = '''
SELECT DATE_FORMAT(p.CreatedAt, '%Y-%m') AS Month, 
       COUNT(*) AS LowStockProductCount 
FROM products p 
WHERE p.UnitsInStock < p.ReorderLevel 
AND p.Discontinued = 0 
GROUP BY Month
ORDER BY Month DESC
'''

# Execute the time series query
time_series_df = execute_sql_query(time_series_query)

# Convert Month to datetime for better plotting
time_series_df['Month'] = pd.to_datetime(time_series_df['Month'])

# Create the plot
fig = px.line(time_series_df, x='Month', y='LowStockProductCount', title='Number of Low-Stock Products Over Time')

# Display the visualization to the user
show_to_user(fig)
","The input Python code is incorrect because it does not restrict the count of low-stock products to just August 2023 in the visualization part. It queries data for visualization over a broader time span, which is not strictly adhering to the given business analytic request. Additionally, it counts the number of low-stock products just once (in August 2023) but does not show this over time within August.",None
What is the total number of products available in the inventory?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS total_products FROM products;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Extract the total number of products from the resulting dataframe
if not result_df.empty:
    total_products = result_df.loc[0, 'total_products']
else:
    total_products = 0

# Convert the result into a DataFrame for better presentation
output_df = pd.DataFrame({'Total Products': [total_products]})

# Display the result using the show_to_user utility function
show_to_user(output_df)
","import pandas as pd

# SQL query to count the total number of products in the inventory
sql_query = ""SELECT COUNT(*) AS total_products FROM products""

# Execute the SQL query and retrieve data
result_df = execute_sql_query(sql_query)

# Extract the total number of products
total_products = result_df['total_products'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'Total Products': [total_products]}))","The input code correctly follows the Python environment constraints and aims to calculate the total number of products in the inventory. It uses the correct SQL query to get the total count, retrieves the data into a DataFrame, extracts the relevant information, and finally displays the result using the show_to_user utility function.","import pandas as pd
import plotly.express as px

# Execute SQL query to get the total number of products
sql_query = 'SELECT COUNT(*) AS TotalProducts FROM products;'
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The input code correctly retrieves the total number of products from the 'products' table using an SQL query, stores the result in a dataframe, and then displays this result to the user. It fulfills the business requirement of determining the total number of products in the inventory, adhering to the provided constraints and utility functions.",both
Which shipping company has the highest on-time delivery rate? (Include a visualization comparing on-time delivery rates among shipping companies.),"# Import required libraries
import plotly.express as px

# Define the SQL query
top_shipping_query = '''
SELECT ShipVia, 
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipVia 
ORDER BY OnTimeDeliveryRate DESC;''' 

# Execute the SQL query and get the result in a pandas dataframe
df = execute_sql_query(top_shipping_query)

# Generate a bar plot to visualize on-time delivery rates among shipping companies
fig = px.bar(df, x='ShipVia', y='OnTimeDeliveryRate', title='On-Time Delivery Rates by Shipping Company', labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-Time Delivery Rate'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate On-time Delivery Rate grouped by shipping company (ShipVia)
sql_query = '''
SELECT ShipVia, 
       COUNT(OrderID) AS TotalOrders, 
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries,
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(OrderID)) AS OnTimeDeliveryRate
FROM orders  
GROUP BY ShipVia
'''  

# Execute the SQL query and retrieve the data
shipping_data = execute_sql_query(sql_query)

# Find the shipping company with the highest on-time delivery rate
highest_on_time_delivery = shipping_data.loc[shipping_data['OnTimeDeliveryRate'].idxmax()]

# Create a bar plot to visualize on-time delivery rates among shipping companies
fig = px.bar(shipping_data, x='ShipVia', y='OnTimeDeliveryRate', 
             title='On-time Delivery Rates by Shipping Company', 
             labels={'OnTimeDeliveryRate': 'On-time Delivery Rate', 'ShipVia': 'Shipping Company'},
             text='OnTimeDeliveryRate')

# Show the figure to the user
show_to_user(fig)

# Display the shipping company with the highest on-time delivery rate
highest_on_time_delivery_rate = highest_on_time_delivery['OnTimeDeliveryRate']
highest_shipping_company = highest_on_time_delivery['ShipVia']
highest_shipping_company, highest_on_time_delivery_rate","The provided code correctly follows the business analytic request and the Python environment constraint. It retrieves the on-time delivery rates, visualizes them using a bar chart, and identifies the shipping company with the highest on-time delivery rate. The logic and output match the reference implementation, albeit with some minor additional details in reporting.","import pandas as pd
import plotly.express as px

# Execute the SQL query to retrieve the required data
sql_query = """"""
SELECT shippers.ShipperID, 
       (COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID)) as on_time_delivery_rate 
FROM orders 
INNER JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.ShipperID
""""""

# Retrieve the data into a pandas dataframe
df = execute_sql_query(sql_query)

# Create visualizations for on-time delivery rates
fig = px.bar(df, x='ShipperID', y='on_time_delivery_rate', title='On-Time Delivery Rates by Shipping Company',
             labels={'ShipperID': 'Shipping Company', 'on_time_delivery_rate': 'On-Time Delivery Rate'},
             text='on_time_delivery_rate')

# Enhance display of text on bars
fig.update_traces(texttemplate='%{text:.2%}', textposition='outside')

# Display the visualization
show_to_user(fig)

# Optionally, if you want to show the DataFrame itself
show_to_user(df)","The input code correctly executes the SQL query to retrieve the on-time delivery rates, calculates the rates, and generates a bar plot using Plotly, which is in accordance with the input constraints and the reference implementation. The enhancements made to the display of text on bars are additional but do not deviate from the core logic of the task.",both
What are the top 5 products in terms of total units sold? (Include a bar chart to show the top 5 products based on total units sold.),"
import plotly.express as px

# SQL query to get the top 5 products in terms of total units sold
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalUnitsSold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
'''

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to show the top 5 products based on total units sold
fig = px.bar(df, x='ProductName', y='TotalUnitsSold', title='Top 5 Products by Total Units Sold', labels={'ProductName': 'Product Name', 'TotalUnitsSold': 'Total Units Sold'})

# Display the plotly figure to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to get total units sold per product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
'''  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart for the top 5 products based on total units sold
fig = px.bar(result_df, x='ProductName', y='TotalUnitsSold', title='Top 5 Products by Total Units Sold',
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})

# Show the results to the user
show_to_user(fig)","The provided Python code meets the requirements of the business analytic request and the constraints of the Python environment. It correctly executes a SQL query to obtain the top 5 products by total units sold, processes the result into a pandas DataFrame, and creates a bar chart using plotly to visualize the data. The output format matches the requirements, and all necessary functions (execute_sql_query and show_to_user) are used appropriately.","The task requires us to write Python code to help visualize the top 5 products based on total units sold using the sweetviz and plotly libraries. Letâ€™s break it down step by step and consider if any adjustments to the process are required.

We'll leverage the pandas operations together with plotly for creating a bar chart. Here's how the code will be structured:

1. Execute the SQL query to retrieve the top 5 products based on total units sold.
2. Use Plotly to create a bar chart.
3. Display the chart result.

Hereâ€™s the implementation code:

```python
import plotly.express as px
import pandas as pd

# Step 1: Execute the SQL query

sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSold
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSold DESC
LIMIT 5;
'''

# Get the data from the SQL query
result_df = execute_sql_query(sql_query)

# Step 2: Create a bar chart using plotly
fig = px.bar(result_df, x='ProductName', y='TotalSold', title='Top 5 Products by Total Units Sold', labels={'ProductName': 'Product Name', 'TotalSold': 'Total Units Sold'})

# Step 3: Display the result to the user
show_to_user(fig)
``` 

### Explanation
- **execute_sql_query**: This function fetches the required data from the database. Query results are stored in a DataFrame.
- **plotly.express**: We use the `bar` function to create a bar chart. The x-axis represents the product names, and the y-axis represents the total units sold.
- **show_to_user**: Finally, the chart is passed to this function which displays it in the UI.

### Required Python Libraries
In case of missing libraries, ensure to install them with:
```bash
pip install pandas plotly
```

### Note:
Make sure the environments for executing SQL and visualizing the data are correctly established in your platform. Adjust the column names as necessary if they differ from whatâ€™s expected.","The input code correctly executes the SQL query to retrieve the top 5 products based on total units sold, creates a bar chart using Plotly to visualize the results, and displays the chart to the user. The implementation matches the business analytic request and follows the given Python environment constraints.",both
What is the monthly average shipping cost?,"import pandas as pd
import plotly.express as px

# SQL query to get the monthly average shipping cost
df = execute_sql_query(""SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost FROM orders GROUP BY Month;"")

# Display the dataframe to the user
show_to_user(df)

# Ensure the 'Month' column is treated as a datetime object for proper plotting
df['Month'] = pd.to_datetime(df['Month'], format='%Y-%m')

df = df.sort_values('Month')  # Sort dataframe by 'Month' to ensure plot is in chronological order

# Create a line plot using Plotly to visualize the monthly average shipping cost
fig = px.line(df, x='Month', y='AvgShippingCost', title='Monthly Average Shipping Cost', labels={'Month': 'Month', 'AvgShippingCost': 'Average Shipping Cost'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd

# SQL query to calculate the monthly average shipping cost
sql_query = '''
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(Freight) AS AverageShippingCost
FROM
    orders
GROUP BY
    Month
ORDER BY
    Month;
'''

# Execute the SQL query
monthly_shipping_costs_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(monthly_shipping_costs_df)","The input Python code does execute the SQL query and display the result, but it does not create a plot using Plotly to visualize the monthly average shipping cost as specified in the business analytic request and demonstrated in the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_TRUNC('month', OrderDate) AS Month, AVG(Freight) AS AvgShippingCost
FROM orders
GROUP BY DATE_TRUNC('month', OrderDate);
'''

# Execute the SQL query to retrieve data
monthly_avg_shipping_cost_df = execute_sql_query(sql_query)

# Display the resulting data to the user
show_to_user(monthly_avg_shipping_cost_df)

# Optionally, visualize the data using Plotly
fig = px.line(monthly_avg_shipping_cost_df, x='Month', y='AvgShippingCost', title='Monthly Average Shipping Cost')
show_to_user(fig)","The input code correctly executes an SQL query to compute the monthly average shipping cost, uses the provided utility functions 'execute_sql_query' and 'show_to_user' correctly, and then visualizes the data using Plotly. The overall functionality adheres to the given business analytic request and produces the expected result.",Finetuned
Which employee has the highest sales in Q1 2023?,"import pandas as pd
import plotly.express as px

# SQL query string based on the given specification
sql_query = '''
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY employees.EmployeeID
ORDER BY employee_sales DESC
LIMIT 1;
'''

# Execute the SQL query and fetch the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to find the employee with the highest sales in Q1 2023
sql_query = '''
SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY total_sales DESC
LIMIT 1
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The provided code correctly matches the business analytic request. It queries for the employee with the highest sales in Q1 2023, including additional details such as the employee's first and last name. The SQL logic performs the necessary joins and aggregations, orders by total sales in descending order, and limits the result to the top employee. The result is then displayed using the show_to_user function.","import pandas as pd
import plotly.express as px

# SQL query definition
sql_query = ''' 
    SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
    FROM [Order Details] od 
    JOIN orders o ON o.OrderID = od.OrderID 
    JOIN employees e ON o.EmployeeID = e.EmployeeID 
    WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
    GROUP BY e.EmployeeID 
    ORDER BY TotalSales DESC 
    LIMIT 1; 
'''

# Execution of SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly follows the Python environment constraints, performs the SQL query to gather the required data, and displays the result to the user. It matches the reference implementation in terms of logic and purpose.",both
What is the total revenue generated from each product sold in 2022? (Include data visualization for better illustration),"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID
'''

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total revenue per product
fig = px.bar(df, x='ProductID', y='total_revenue', title='Total Revenue per Product in 2022', labels={'ProductID': 'Product ID', 'total_revenue': 'Total Revenue'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue for each product sold in 2022
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID, products.ProductName
""""""

# Execute the SQL query
product_revenue_df = execute_sql_query(sql_query)

# Visualize the total revenue
fig = px.bar(product_revenue_df, x='ProductName', y='total_revenue',
             title='Total Revenue Generated from Each Product Sold in 2022',
             labels={'total_revenue': 'Total Revenue', 'ProductName': 'Product Name'},
             text='total_revenue')

# Show the plot to the user
show_to_user(fig)","The input Python code correctly calculates the total revenue for each product sold in 2022 and uses Plotly for visualization. The execution environment constraints are followed, and the code effectively retrieves and visualizes the required data.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity) AS total_revenue
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = 2022
GROUP BY products.ProductName;
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue generated from each product
fig = px.bar(result_df, x='ProductName', y='total_revenue', title='Total Revenue from Each Product Sold in 2022', labels={'ProductName': 'Product Name', 'total_revenue': 'Total Revenue ($)'})

# Display the plot to the user
show_to_user(fig)","The input code is mostly correct but misses a crucial detail from the business analytic request and the reference implementation. Specifically, the input code omitted the handling of the 'Discount' in the calculation of total revenue. This will lead to an incorrect total revenue calculation.",Base
What is the most ordered product in terms of quantity?,"import pandas as pd

# SQL query to find the most ordered product in terms of quantity
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalQuantityOrdered DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if the result dataframe is not empty
if not result_df.empty:
    # Display the result to the user
    show_to_user(result_df)
else:
    print(""No data found."")
","sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 1;
'''

most_ordered_product = execute_sql_query(sql_query)
show_to_user(most_ordered_product)","The input code correctly implements the business analytic request. The SQL query accurately calculates the most ordered product in terms of quantity by joining the 'Order Details' and 'products' tables, grouping by product name, and ordering by the total quantity in descending order. The LIMIT 1 ensures only the top result is retrieved. The code then uses the execute_sql_query function to retrieve the data and show_to_user function to display the result, which aligns with the behavior of the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalQuantityOrdered FROM [Order Details] GROUP BY ProductID ORDER BY TotalQuantityOrdered DESC LIMIT 1;""

# Execute the SQL query and retrieve results
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The input Python code does not join with the 'products' table to get the product name; it only returns the ProductID. This does not fulfill the business analytics request for the most ordered product in terms of quantity.,Base
How many products have less than 10 units in stock?,"import pandas as pd

# SQL query to find products with less than 10 units in stock
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < 10;""

# Execute the query using the provided utility function
df = execute_sql_query(sql_query)

# Count the number of products with less than 10 units in stock
num_products = df.shape[0]

# Display the count
show_to_user(pd.DataFrame({'Number of Products with < 10 units': [num_products]}))","import pandas as pd

# Define the SQL query to count products with less than 10 units in stock
sql_query = """"""
SELECT COUNT(*) AS ProductCount
FROM products
WHERE UnitsInStock < 10
""""""

# Execute the SQL query and retrieve the result
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly counts the number of products with less than 10 units in stock using a SQL COUNT(*) query. It then uses execute_sql_query to retrieve the result and show_to_user to display it. While it differs slightly from the reference implementation in terms of method, it adheres to the business request and Python environment constraints.","import pandas as pd
import plotly.express as px

# SQL Query to count products with less than 10 units in stock
sql_query = 'SELECT COUNT(*) AS LowStockCount FROM products WHERE UnitsInStock < 10;'

# Execute the SQL query and retrieve the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, visualize the result using a bar chart
fig = px.bar(result_df, x=result_df.index, y='LowStockCount', title='Number of Products with Less Than 10 Units in Stock')
show_to_user(fig)","The input code correctly uses the given utility functions to execute a SQL query that counts the number of products with less than 10 units in stock and displays the result to the user. It also includes an optional visualization with Plotly, which is a valid addition within the provided constraints.",both
List the top 5 products with the highest total sales revenue. (Include a bar chart to visualize the comparisons),"import pandas as pd
import plotly.express as px

# SQL query to get the top 5 products with the highest total sales revenue
sql_query = '''
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID, products.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 products by total sales revenue
fig = px.bar(sales_data, x='ProductName', y='TotalSales', 
             title='Top 5 Products by Total Sales Revenue', 
             labels={'ProductName': 'Product Name', 'TotalSales': 'Total Sales Revenue'}, 
             text='TotalSales')

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total sales for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 5
'''

# Execute the SQL query and retrieve the data
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 products by total sales
fig = px.bar(top_products_df, x='ProductName', y='TotalSales', title='Top 5 Products by Total Sales Revenue')

# Show the data to the user
show_to_user(fig)","The input code meets the business analytic request requirements. It correctly retrieves the top 5 products with the highest total sales revenue using the SQL query and visualizes the data using a bar chart. The functionality is consistent with that of the reference implementation, and it adheres to the specified Python environment constraints.","import plotly.express as px

# SQL Query
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSalesRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalSalesRevenue DESC 
LIMIT 5;
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Creating the bar chart using Plotly
fig = px.bar(sales_data, x='ProductName', y='TotalSalesRevenue', 
             title='Top 5 Products with Highest Total Sales Revenue', 
             labels={'ProductName': 'Product Name', 'TotalSalesRevenue': 'Total Sales Revenue ($)'})

# Display the bar chart
show_to_user(fig)","The provided Python code correctly implements the business analytic request to list the top 5 products with the highest total sales revenue and includes a bar chart for visualization. The SQL query accurately retrieves the necessary data, and the plotly library is used to create and display the bar chart. The code adheres to the Python environment constraints by using the 'execute_sql_query' and 'show_to_user' functions.",both
Which products have the highest and lowest inventory turnover ratio? (Include data visualization for comparison),"import pandas as pd
import plotly.express as px

def get_inventory_turnover_ratio():
    # SQL query to get the inventory turnover ratio for each product
    sql_query = '''
    SELECT p.ProductName, 
           SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    GROUP BY p.ProductName 
    ORDER BY InventoryTurnoverRatio DESC
    LIMIT 1;
    '''
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Include an SQL query to get the product with the lowest inventory turnover ratio
    sql_query_low = '''
    SELECT p.ProductName, 
           SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    GROUP BY p.ProductName 
    ORDER BY InventoryTurnoverRatio ASC
    LIMIT 1;
    '''
    
    # Execute the low turnover SQL query
    df_low = execute_sql_query(sql_query_low)
    
    # Merge highest and lowest turnover ratios into a new DataFrame for visualization
    comparison_df = pd.DataFrame({
        ""ProductName"": [df.iloc[0]['ProductName'], df_low.iloc[0]['ProductName']],
        ""InventoryTurnoverRatio"": [df.iloc[0]['InventoryTurnoverRatio'], df_low.iloc[0]['InventoryTurnoverRatio']]
    })
    
    # Create bar plot visualization for comparison
    fig = px.bar(comparison_df, x='ProductName', y='InventoryTurnoverRatio', 
                 title='Highest and Lowest Inventory Turnover Ratio', 
                 labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})
    
    # Show the visualization to the user
    show_to_user(fig)

# Call the function to execute the analysis and visualization
get_inventory_turnover_ratio()","import pandas as pd
import plotly.express as px

# SQL query to calculate Inventory Turnover Ratio for each product
sql_query = '''
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS CostOfGoodsSold, 
    AVG(p.UnitsInStock) AS AverageInventory, 
    CASE 
        WHEN AVG(p.UnitsInStock) > 0 THEN 
            SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) 
        ELSE NULL 
    END AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
'''

# Executing the SQL query
inventory_turnover_data = execute_sql_query(sql_query)

# Finding the products with the highest and lowest Inventory Turnover Ratio
highest_turnover = inventory_turnover_data.loc[inventory_turnover_data[""InventoryTurnoverRatio""].idxmax()]
lowest_turnover = inventory_turnover_data.loc[inventory_turnover_data[""InventoryTurnoverRatio""].idxmin()]

# Creating a summary DataFrame for visualization
summary_df = pd.DataFrame({
    'Product': [highest_turnover['ProductName'], lowest_turnover['ProductName']],
    'Inventory Turnover Ratio': [highest_turnover['InventoryTurnoverRatio'], lowest_turnover['InventoryTurnoverRatio']]
})

# Visualizing the Inventory Turnover Ratio
fig = px.bar(summary_df, x='Product', y='Inventory Turnover Ratio', title='Highest and Lowest Inventory Turnover Ratio')
show_to_user(fig)","The input Python code correctly computes the inventory turnover ratio for each product. It subsequently identifies the products with the highest and lowest ratios, and visualizes the result using plotly. It adheres to the specified business analytic request and matches the reference implementation's functionality.","import plotly.express as px

# Execute the SQL query to get inventory turnover ratio
sql_query = '''
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName
'''

# Retrieve the data
data = execute_sql_query(sql_query)

# Visualize the Inventory Turnover Ratio
fig = px.bar(data, x='ProductName', y='InventoryTurnoverRatio', 
             title='Inventory Turnover Ratio by Product', 
             labels={'ProductName':'Product Name', 'InventoryTurnoverRatio':'Inventory Turnover Ratio'})

# Display the plot
show_to_user(fig)

# Identify the products with highest and lowest inventory turnover ratios
highest_turnover = data.iloc[data['InventoryTurnoverRatio'].idxmax()]
lowest_turnover = data.iloc[data['InventoryTurnoverRatio'].idxmin()]

# Create a summary dataframe
summary_df = pd.DataFrame({
    'Metric': ['Highest Turnover', 'Lowest Turnover'],
    'Product Name': [highest_turnover['ProductName'], lowest_turnover['ProductName']],
    'Inventory Turnover Ratio': [highest_turnover['InventoryTurnoverRatio'], lowest_turnover['InventoryTurnoverRatio']]
})

# Display the summary dataframe
show_to_user(summary_df)","The code does not correctly fulfill the business analytic request. It visualizes the inventory turnover ratio for all products, but does not specifically identify or compare the products with the highest and lowest inventory turnover ratios. Additionally, it does not separate and visualize these two specific products as requested.",Base
Identify employees with the highest and lowest order counts. (Include a bar chart for better comparison),"import pandas as pd
import plotly.express as px

# Define the SQL query
detail_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1 
UNION 
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount ASC 
LIMIT 1;'''

# Execute the query to get the data
data_df = execute_sql_query(detail_query)

# Create the bar chart using plotly
fig = px.bar(data_df, 
            x='EmployeeID', 
            y='OrderCount', 
            text='OrderCount', 
            title='Employees with Highest and Lowest Order Counts', 
            labels={'EmployeeID':'Employee ID', 'OrderCount':'Order Count'}, 
            hover_data=['FirstName', 'LastName'])

# Show the bar chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to find order counts for each employee
sql_query = '''
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
'''  

# Execute the SQL query and store the results in a dataframe
order_counts_df = execute_sql_query(sql_query)

# Identify employees with the highest and lowest order counts
highest_order_count = order_counts_df.nlargest(1, 'OrderCount')
lowest_order_count = order_counts_df.nsmallest(1, 'OrderCount')
result_df = pd.concat([highest_order_count, lowest_order_count])

# Create a bar chart for comparison
fig = px.bar(result_df, x='EmployeeName', y='OrderCount', title='Employees with Highest and Lowest Order Counts',
             labels={'EmployeeName': 'Employee Name', 'OrderCount': 'Order Count'})

# Show the results to the user
show_to_user(result_df)
show_to_user(fig)","The provided input Python code has a logical discrepancy. It fetches all order counts for employees in descending order (ORDER BY OrderCount DESC) and subsequently selects the employee with the smallest order count using the nsmallest function. However, this is not efficient. A more accurate approach is to perform a UNION query to get the highest and lowest order counts in a single SQL execution, as shown in the reference code. Additionally, the input code uses a LEFT JOIN which might include employees with zero orders, whereas the business request typically implies only considering employees with orders.","import plotly.express as px

# SQL query to fetch employees with the highest and lowest order counts
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
HAVING COUNT(o.OrderID) = (
    SELECT MAX(Count) FROM (
        SELECT COUNT(o2.OrderID) AS Count 
        FROM employees e2 
        JOIN orders o2 ON e2.EmployeeID = o2.EmployeeID 
        GROUP BY e2.EmployeeID
    ) AS MaxCount 
    UNION 
    SELECT COUNT(o2.OrderID) AS Count 
    FROM employees e2 
    JOIN orders o2 ON e2.EmployeeID = o2.EmployeeID 
    GROUP BY e2.EmployeeID
);
'''

# Execute the SQL query and fetch the data
data = execute_sql_query(sql_query)

# Plot the data using bar chart for better comparison
fig = px.bar(data, x='EmployeeID', y='OrderCount', title='Employees with Highest and Lowest Order Counts')

# Show the plot to user
show_to_user(fig)","The input Python code does not correctly implement the business analytic request. Specifically, it only returns rows for employees `HAVING COUNT(o.OrderID)`, which results in the employees with the maximum count and all employees who have the same count as the lowest. The reference implementation distinctly identifies the single highest and single lowest order count using separate queries with `LIMIT 1`.",None
Which employee handled the most orders?,"import pandas as pd

# Define the SQL query
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query and retrieve the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY EmployeeID
ORDER BY TotalOrders DESC
LIMIT 1;
'''  

most_orders_employee = execute_sql_query(sql_query)
show_to_user(most_orders_employee)","The input Python code correctly follows the SQL logic to retrieve the employee with the most orders by grouping the orders by EmployeeID, counting the number of orders, ordering by the count in descending order, and limiting the result to one. The use of execute_sql_query() and show_to_user() functions is appropriate and aligns with the Python environment constraints.","import pandas as pd
import plotly.express as px

# SQL query to find the employee who handled the most orders
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)","The input code correctly follows the business analytic request to find the employee who handled the most orders. It uses the correct SQL query to group by EmployeeID, count the orders, order by the order count in descending order, and limit the result to the top employee. It also correctly uses the utility functions `execute_sql_query` to execute the SQL query and `show_to_user` to display the result. The additional import of plotly.express is unnecessary but does not affect the correctness of the code.",both
Calculate the average lead time for each supplier in delivered products. (Include data visualization for more detailed insights),"import pandas as pd
import plotly.express as px

# SQL Query to calculate the average lead time for each supplier in delivered products.
sql_query = '''
SELECT suppliers.SupplierID, CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, CompanyName;
'''

# Execute the SQL query using the provided function, which returns a pandas dataframe.
supplier_lead_time_df = execute_sql_query(sql_query)

# Ensure the dataframe columns are correctly typed
dtype_corrected_supplier_lead_time_df = supplier_lead_time_df.copy()
dtype_corrected_supplier_lead_time_df['AverageLeadTime'] = dtype_corrected_supplier_lead_time_df['AverageLeadTime'].astype(float)

# Display the dataframe to the user using the provided function.
show_to_user(dtype_corrected_supplier_lead_time_df)

# Create a bar chart to visualize the average lead time for each supplier.
fig = px.bar(dtype_corrected_supplier_lead_time_df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier', labels={'CompanyName': 'Supplier', 'AverageLeadTime': 'Average Lead Time (days)'} )

# Show the plot to the user using the provided function.
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define SQL query to calculate average lead time for each supplier
sql_query = '''
SELECT suppliers.SupplierID, suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgLeadTime
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN orders ON orders.OrderID IN (SELECT OrderID FROM [Order Details] WHERE ProductID = products.ProductID)
GROUP BY suppliers.SupplierID, suppliers.CompanyName
'''

# Execute the SQL query and get the result into a DataFrame
lead_time_df = execute_sql_query(sql_query)

# Show the average lead time data to the user
show_to_user(lead_time_df)

# Data visualization
fig = px.bar(lead_time_df, x='CompanyName', y='AvgLeadTime', title='Average Lead Time by Supplier',
             labels={'AvgLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier Name'})
show_to_user(fig)","The provided input code correctly follows the business analytic request to calculate the average lead time for each supplier in delivered products. It matches the output of the reference implementation adequately. The SQL query calculates the average lead time correctly, and the use of `execute_sql_query` and `show_to_user` functions are consistent with the Python environment constraints. The visualization is properly created using Plotly and displayed using the correct utility function. Therefore, the code implementation is correct.","import pandas as pd
import plotly.express as px

# Define the SQL query as per the requirement
sql_query = '''
SELECT products.SupplierID, 
       AVG(DATEDIFF(day, orders.OrderDate, orders.ShippedDate)) AS AverageLeadTime 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE orders.ShippedDate IS NOT NULL 
GROUP BY products.SupplierID;'''

# Execute the SQL query to get the data
lead_time_df = execute_sql_query(sql_query)

# Checking if the dataframe is empty before visualization
if lead_time_df.empty:
    print('No data available for the specified query.')
else:
    # Generate a bar chart for the average lead time by supplier
    fig = px.bar(lead_time_df, x='SupplierID', y='AverageLeadTime', 
                 title='Average Lead Time per Supplier',
                 labels={'SupplierID': 'Supplier ID', 'AverageLeadTime': 'Average Lead Time (days)'} )
    
    # Show the plot to the user
    show_to_user(fig)","The given input Python code does not fully meet the requirements outlined in the business analytic request. It does not include the supplier CompanyName in the query and the visualization. Also, it should convert AverageLeadTime to float type before visualization for consistency. The reference implementation's SQL query filters for delivered products and groups by SupplierID and CompanyName, whereas the provided code only includes SupplierID and misses important context provided by the supplier's company name.",Base
What is the average discount given in orders for the year 2023?,"import pandas as pd

# SQL query to get the average discount for orders in the year 2023
sql_query = (""SELECT AVG([Order Details].Discount) AS avg_discount ""
             ""FROM [Order Details] ""
             ""JOIN orders ON [Order Details].OrderID = orders.OrderID ""
             ""WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'"")

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average discount value from the dataframe
avg_discount = result_df['avg_discount'][0]

# Prepare a dataframe to display to the user
output_df = pd.DataFrame({'Average Discount': [avg_discount]})

# Display the result to the user
show_to_user(output_df)","import pandas as pd

# SQL query to calculate the average discount given in orders for the year 2023
sql_query = """"""
SELECT AVG([Order Details].Discount) AS average_discount
FROM [Order Details] JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
discount_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discount_data)","The input Python code does not match the reference implementation in terms of extracting the average discount value before displaying it to the user. The reference implementation extracts the average discount and then creates a new DataFrame to display, while the input code directly displays the entire result DataFrame.","import pandas as pd

# Define the SQL query to calculate the average discount given in orders for the year 2023
sql_query = '''
SELECT AVG([Order Details].Discount) AS avg_discount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = 2023;
'''

# Use the utility function to execute the SQL query and get the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly calculates the average discount for orders in the year 2023 using the provided utility functions, but it does not format the result into a user-friendly dataframe that specifically labels the average discount, making it less clear for the user to interpret.",None
What is the average order fulfillment time by month? (Include a line chart for monthly trends),"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgOrderFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query to get the data
orders_data = execute_sql_query(sql_query)

# Make sure the 'Month' column is treated as a datetime object for correct plotting
orders_data['Month'] = pd.to_datetime(orders_data['Month'], format='%Y-%m')

# Create a line chart using plotly express
fig = px.line(orders_data, x='Month', y='AvgOrderFulfillmentTime', title='Average Order Fulfillment Time by Month')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average order fulfillment time by month
sql_query = '''
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM
    orders
WHERE
    ShippedDate IS NOT NULL
GROUP BY
    Month
ORDER BY
    Month;
'''  

# Execute the SQL query and retrieve data
fulfillment_data = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(fulfillment_data)

# Create a line chart for monthly trends
fig = px.line(fulfillment_data, x='Month', y='AvgFulfillmentTime',
              title='Average Order Fulfillment Time by Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'Month': 'Month'})
show_to_user(fig)","The input Python code correctly defines the SQL query to calculate the average order fulfillment time by month, ensures that the 'ShippedDate' is not null, executes the query, and retrieves the data in a pandas DataFrame. It then uses Plotly to create a line chart to visualize the monthly average fulfillment time and properly formats the labels and title of the chart. The code follows the specified constraints and achieves the same business analytic request as the reference implementation.","
import plotly.express as px

# Define the SQL query to get average order fulfillment time by month
db_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query to retrieve data
data = execute_sql_query(db_query)

# Ensure the 'Month' column is treated as a datetime object
data['Month'] = pd.to_datetime(data['Month'], format='%Y-%m')

# Sort the data by Month
data = data.sort_values(by='Month')

# Create a line chart for monthly trends
fig = px.line(data, x='Month', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Month', labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)', 'Month': 'Month'})

# Display the chart to the user
show_to_user(fig)
","The input Python code correctly follows the steps needed to calculate the average order fulfillment time by month and plot a line chart to visualize the monthly trends. It executes a SQL query to retrieve the data, processes the 'Month' column to ensure it is in the correct format, sorts the data by 'Month', and then uses plotly express to create and display a line chart. These steps align with those in the reference implementation and meet the business analytic request.",both
What is the total revenue generated by each employee? (Include a bar chart to visualize the revenue distribution),"import plotly.express as px

# SQL query to calculate total revenue by each employee
sql_query = '''
SELECT EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY EmployeeID;
'''

# Execute the SQL query
revenue_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue distribution
fig = px.bar(revenue_df, x='EmployeeID', y='TotalRevenue', title='Total Revenue by Employee', labels={'EmployeeID': 'Employee ID', 'TotalRevenue': 'Total Revenue'})

# Display the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue generated by each employee
sql_query = """"""
SELECT o.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.EmployeeID
""""""

# Execute the SQL query and retrieve the data
revenue_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue distribution per employee
fig = px.bar(revenue_data, x='EmployeeID', y='TotalRevenue', title='Total Revenue Generated by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalRevenue': 'Total Revenue'},
             text='TotalRevenue')

# Show the bar chart to the user
show_to_user(fig)","The input Python code is correct as it follows the Python environment constraint, answers the business analytic request, and the output is generally consistent with the reference implementation. The code calculates the total revenue generated by each employee and visualizes it using a bar chart from the Plotly library.","import pandas as pd
import plotly.express as px

# SQL Query to get the total revenue generated by each employee
def fetch_employee_sales():
    sql_query = '''
    SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
    FROM employees e 
    JOIN orders o ON e.EmployeeID = o.EmployeeID 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    GROUP BY e.EmployeeID, e.FirstName, e.LastName;'''
    return execute_sql_query(sql_query)

# Function to visualize the revenue distribution
def plot_employee_sales(sales_data):
    # Create a full name column
    sales_data['FullName'] = sales_data['FirstName'] + ' ' + sales_data['LastName']
    # Create a bar chart using plotly
    fig = px.bar(sales_data, x='FullName', y='TotalSales', title='Total Revenue Generated by Each Employee', labels={'FullName': 'Employee', 'TotalSales': 'Total Sales ($)'})
    # Show the plot to the user
    show_to_user(fig)

# Fetch data and plot
employee_sales_data = fetch_employee_sales()
plot_employee_sales(employee_sales_data)","The input Python code follows all the constraints given and correctly calculates and visualizes the total revenue generated by each employee. It performs the SQL query properly, fetches the necessary data, modifies it to include a full name column, and uses Plotly to create the required bar chart. The functionality matches the reference implementation, even though it includes additional information (employee first and last names), which enhances the clarity of the output without deviating from the original requirements.",both
Find the total freight cost incurred in the year 2023.,"import pandas as pd

# Define the SQL query to find the total freight cost for the year 2023
sql_query = ""SELECT SUM(Freight) AS TotalFreightCost2023 FROM orders WHERE YEAR(OrderDate) = 2023;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total freight cost value from the result
TotalFreightCost2023 = result_df['TotalFreightCost2023'].iloc[0]

# Display the total freight cost to the user
show_to_user(pd.DataFrame({'TotalFreightCost2023': [TotalFreightCost2023]}))","import pandas as pd

# Define the SQL query to find the total freight cost incurred in the year 2023
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE YEAR(OrderDate) = 2023
""""""

# Execute the SQL query using the provided utility function
freight_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(freight_data)","The input Python code correctly defines an SQL query to sum the 'Freight' column for the year 2023, executes the query using 'execute_sql_query', and displays the result using 'show_to_user'. The code follows the given utility functions and meets the business analytic request.","import pandas as pd

# Define the SQL query to find the total freight cost incurred in the year 2023.
sql_query = ""SELECT SUM(Freight) AS total_freight_cost FROM orders WHERE YEAR(OrderDate) = 2023;""

# Execute the SQL query.
result_df = execute_sql_query(sql_query)

# Display the result to the user.
show_to_user(result_df)","The input code does not correctly extract the total freight cost value from the result dataframe and therefore fails to display the specific total freight cost for the year 2023. It shows the entire result dataframe instead, which may not clearly present the total freight cost to the user, especially if there are multiple columns.",Base
Identify which month has the highest number of orders historically. (Include a bar chart for monthly comparisons),"import pandas as pd
import plotly.express as px

# SQL query to identify monthly order counts
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m') 
ORDER BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query to get the monthly order data
df = execute_sql_query(sql_query)

# Determine the month with the highest number of orders
highest_order_month = df.loc[df['OrderCount'].idxmax()]

# Display the month with the highest order count
show_to_user(pd.DataFrame([highest_order_month]))

# Generate a bar chart for monthly comparisons
fig = px.bar(df, x='Month', y='OrderCount', title='Monthly Order Counts', labels={'Month': 'Month', 'OrderCount': 'Order Count'})

# Show bar chart to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to get the number of orders per month
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY OrderMonth
ORDER BY OrderMonth
'''

# Execute the SQL query to get the data
monthly_orders_df = execute_sql_query(sql_query)

# Identify the month with the highest number of orders
highest_month = monthly_orders_df.loc[monthly_orders_df['NumberOfOrders'].idxmax()]

# Create a bar chart for monthly comparisons
fig = px.bar(monthly_orders_df, x='OrderMonth', y='NumberOfOrders',
             title='Monthly Orders Comparison',
             labels={'OrderMonth': 'Month', 'NumberOfOrders': 'Number of Orders'})

# Show the results to the user
show_to_user(fig)

# Output the month with the highest number of orders
highest_month_response = f'The month with the highest number of orders is {highest_month.OrderMonth} with {highest_month.NumberOfOrders} orders.'
show_to_user(highest_month_response)","The input code correctly follows the business analytic request and Python environment constraints. It effectively identifies the month with the highest number of orders and generates a bar chart for monthly comparisons. The SQL query, data extraction, and visualization logic are in line with the reference implementation. The additional step of displaying the month with the highest number of orders as a string response is a nice enhancement.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    MONTH(OrderDate) AS OrderMonth, 
    COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY MONTH(OrderDate) 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the entire dataframe to the user
show_to_user(orders_df)

# Create a bar chart for monthly comparisons
fig = px.bar(orders_df, x='OrderMonth', y='NumberOfOrders', 
             title='Monthly Orders Comparison',
             labels={'OrderMonth': 'Month', 'NumberOfOrders': 'Number of Orders'})

# Display the plot to the user
show_to_user(fig)

# Identify the month with the highest number of orders
max_orders_month = orders_df.iloc[0]
show_to_user(max_orders_month)","The input code does not correctly follow the business analytic request. Specifically, it orders by NumberOfOrders in descending order, rather than by month. Therefore, it cannot identify which month historically has the highest number of orders. Additionally, it uses the MONTH function, which does not account for different years, making it inappropriate for a historical comparison. The SQL query should use DATE_FORMAT(OrderDate, '%Y-%m') to group by year and month.",Base
Calculate the average number of products per order.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG(od.Quantity) AS AverageProductsPerOrder FROM [Order Details] od;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the average number of products per order
sql_query = '''
SELECT COUNT([Order Details].ProductID) AS ProductCount, COUNT(DISTINCT orders.OrderID) AS OrderCount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
'''  

# Execute the SQL query and retrieve data
result_df = execute_sql_query(sql_query)

# Calculate the average number of products per order
average_products_per_order = result_df['ProductCount'].sum() / result_df['OrderCount'].sum() if result_df['OrderCount'].sum() > 0 else 0

# Convert the result to a DataFrame for display
average_df = pd.DataFrame({'Average Products per Order': [average_products_per_order]})

# Show the result to user
show_to_user(average_df)",The input code to be evaluated computes both ProductCount and OrderCount correctly using a SQL query but calculates the average using the sum of ProductCount and OrderCount columns from the result set. The reference implementation computes the average directly by using the SQL query. The evaluated code might return incorrect results because it manually computes the average after querying the data in a way that does not necessarily match the direct database computation the reference implementation uses.,"import pandas as pd
import plotly.express as px

def main():
    # SQL query to calculate the average number of products per order
    sql_query = ""SELECT AVG(OD.Quantity) as AverageProductsPerOrder FROM [Order Details] OD;""
    
    # Execute the SQL query and retrieve the data as a pandas dataframe
    df = execute_sql_query(sql_query)
    
    # Display the dataframe to the user
    show_to_user(df)

# Call the main function
if __name__ == ""__main__"":
    main()","The input Python code correctly calculates the average number of products per order using an SQL query, executes the query to retrieve the result as a pandas dataframe, and displays the result to the user. It follows the provided Python environment constraints, and its functionality aligns with that of the reference implementation.",Finetuned
Which product has the highest total sales in 2022?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
ORDER BY total_sales DESC
LIMIT 1
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","import pandas as pd

# SQL query to calculate total sales for each product in 2022
sql_query = '''
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID 
ORDER BY total_sales DESC 
LIMIT 1; 
''' 

# Execute the SQL query and retrieve the result
result_df = execute_sql_query(sql_query)

# Show the product with the highest total sales
show_to_user(result_df)","The input Python code is functionally correct. It follows the given Python environment constraints, and it constructs a SQL query to get the product with the highest total sales in 2022. Then, it uses the designated utility functions 'execute_sql_query' and 'show_to_user' to retrieve the data and display the result, respectively.","import pandas as pd
import plotly.express as px


def get_highest_total_sales_product():
    # Define the SQL query
    sql_query = '''
    SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
    GROUP BY products.ProductID 
    ORDER BY total_sales DESC 
    LIMIT 1
    '''
    
    # Execute the SQL query to get the data
    result_df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(result_df)
    
# Call the function to perform the analysis and display the result
get_highest_total_sales_product()","The input Python code correctly follows the specified Python environment constraints. It uses the same SQL query to retrieve the product with the highest total sales in 2022 as the reference implementation. The code properly defines and calls the given utility functions execute_sql_query and show_to_user. Therefore, it meets the requirements and can provide the requested information accurately.",both
How many orders were placed in each quarter of 2022? (Include a bar chart for quarterly comparisons),"import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT QUARTER(orders.OrderDate) AS order_quarter, COUNT(orders.OrderID) AS total_orders
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY order_quarter
'''

# Step 2: Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart for quarterly comparisons
fig = px.bar(orders_df, x='order_quarter', y='total_orders', title='Orders Placed per Quarter in 2022', labels={'order_quarter': 'Quarter', 'total_orders': 'Total Orders'})

# Step 4: Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count orders per quarter for the year 2022
sql_query = '''
SELECT 
    CASE 
        WHEN QUARTER(OrderDate) = 1 THEN 'Q1'
        WHEN QUARTER(OrderDate) = 2 THEN 'Q2'
        WHEN QUARTER(OrderDate) = 3 THEN 'Q3'
        WHEN QUARTER(OrderDate) = 4 THEN 'Q4'
    END AS Quarter,
    COUNT(OrderID) AS OrdersCount
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2022
GROUP BY 
    Quarter
ORDER BY 
    Quarter;
'''  

# Executing the SQL query to retrieve data
quarterly_orders = execute_sql_query(sql_query)

# Plotting the data using plotly
fig = px.bar(quarterly_orders, x='Quarter', y='OrdersCount', title='Orders Placed in Each Quarter of 2022', labels={'OrdersCount':'Number of Orders','Quarter':'Quarter'})

# Displaying the result
show_to_user(fig)","The provided code is correct and meets the business analytic request. It accurately queries the number of orders placed in each quarter of 2022, and it visualizes the results with a bar chart using Plotly. The implementation makes use of the required utility functions 'execute_sql_query' and 'show_to_user', adhering to the Python environment constraints.","import pandas as pd
import plotly.express as px

# SQL Query to retrieve the data
df = execute_sql_query(""""""
SELECT QUARTER(ORDER_DATE) AS quarter, COUNT(*) AS order_count 
FROM orders 
WHERE ORDER_DATE BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY quarter 
ORDER BY quarter;
"""""")

# Make sure the quarters are treated as categorical data
df['quarter'] = df['quarter'].astype(str)

# Create a bar chart using Plotly
fig = px.bar(df, x='quarter', y='order_count', title='Number of Orders Placed in Each Quarter of 2022', labels={'quarter': 'Quarter', 'order_count': 'Number of Orders'})

# Display the result to the user
show_to_user(fig)","The provided implementation adheres to the business analytic request and follows the Python environment constraints. It successfully executes the SQL query to retrieve the count of orders per quarter for the year 2022, converts the quarter information to categorical data type, creates a bar chart using Plotly for visualizing quarterly comparisons, and displays the chart to the user.",both
How many unique customers placed orders in the last quarter?,"import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS unique_customers
FROM orders 
WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE());
""""""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result)","from datetime import datetime, timedelta
import pandas as pd

# Define the start and end dates for the last quarter
end_date = datetime.now()
start_date = (end_date - timedelta(days=end_date.day + 90)).replace(day=1)

# Prepare the SQL query to count unique customers who placed orders in the last quarter
sql_query = f""""""
SELECT COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM orders
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""  

# Execute the SQL query and get the result
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The input code incorrectly calculates the start date for the last quarter by subtracting a fixed 90 days plus the current day, which does not accurately represent a quarter. The SQL query in the reference code uses DATEADD function with a precise subtraction of three months. Additionally, it uses GETDATE(), which is more accurate for the current date in SQL.","import pandas as pd

# Define the SQL query to count unique customers who placed orders in the last quarter
sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM orders
WHERE OrderDate >= CURDATE() - INTERVAL 3 MONTH;
""""""

# Execute the SQL query and get the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
display_df = result_df.rename(columns={'UniqueCustomers': 'Number of Unique Customers'})
show_to_user(display_df)","The input Python code correctly defines and executes an SQL query to count the number of unique customers who placed orders in the last quarter, and it renames the resulting column before displaying it. The core logic and the SQL query are correct, and the additional renaming of the column does not affect the correctness of the code.",Finetuned
What are the top three products that generate the most sales revenue? (Include a bar chart for better visualization),"import plotly.express as px
import pandas as pd

# SQL query to fetch the top three products that generate the most sales revenue
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Safety check to ensure the DataFrame is not empty before plotting
if not result_df.empty:
    # Create a bar chart for better visualization
    fig = px.bar(result_df, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue')
    
    # Display the result to the user
    show_to_user(fig)
else:
    show_to_user(""No data found."")","import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue for each product
sql_query = '''
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalSales DESC
LIMIT 3;
'''  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Renaming the columns for better understanding
result_df.columns = ['ProductID', 'TotalSales']

# Creating a bar chart for the top three products
fig = px.bar(result_df, x='ProductID', y='TotalSales', title='Top 3 Products by Sales Revenue')

# Showing the result to the user
show_to_user(fig)","The input Python code to evaluate correctly follows the specified business analytic request. It executes an SQL query to get the total sales revenue for each product, orders the products by sales revenue, and limits the results to the top three products. The code also renames the resulting DataFrame columns for clarity and creates a bar chart using Plotly, which is then displayed to the user. Therefore, it adheres to the provided Python environment constraints and produces the expected output.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT [Order Details].ProductID, 
SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalRevenue 
FROM [Order Details] 
GROUP BY [Order Details].ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 3;
'''

# Step 2: Execute the SQL query
result_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart using plotly
fig = px.bar(result_df, x='ProductID', y='TotalRevenue', 
             title='Top 3 Products by Sales Revenue', 
             labels={'ProductID':'Product ID', 'TotalRevenue':'Total Revenue ($)'})

# Step 4: Display the bar chart
show_to_user(fig)",The input code incorrectly calculates TotalRevenue by not accounting for discounts. The reference code multiplies by (1 - od.Discount) to get the correct revenue after applying discounts.,Base
What are the names of products that have been discontinued?,"import pandas as pd

# Define the SQL query to retrieve names of discontinued products
sql_query = 'SELECT ProductName FROM products WHERE Discontinued = 1;'

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(products_df)","import pandas as pd

# SQL query to retrieve the names of discontinued products
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE Discontinued = 1;
""""""

# Execute the SQL query using the provided utility function
discontinued_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discontinued_products_df)","The code correctly fetches the names of the discontinued products using an SQL query and then displays the resulting dataframe using the provided utility function.`execute_sql_query` is used to run the SQL against the database, and `show_to_user` is used to display the result. The code adheres to the specified Python environment constraints.","import pandas as pd

# Define the SQL query to get names of discontinued products
discontinued_products_query = 'SELECT ProductName FROM products WHERE Discontinued = 1;'

# Execute the SQL query
discontinued_products_df = execute_sql_query(discontinued_products_query)

# Display the result to the user
show_to_user(discontinued_products_df)","The input code correctly follows the Python environment constraint, executes the SQL query to find the names of discontinued products, and then displays the result to the user. It matches the functionality of the reference implementation.",both
Which supplier has supplied the most quantity of products? Please include a bar chart to visualize the quantities supplied by each supplier.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SupplierID, SUM(UnitsOnOrder) AS TotalQuantitySupplied 
FROM products 
GROUP BY SupplierID 
ORDER BY TotalQuantitySupplied DESC
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities supplied by each supplier
fig = px.bar(df, x='SupplierID', y='TotalQuantitySupplied', title='Quantity Supplied by Each Supplier', labels={'SupplierID': 'Supplier ID', 'TotalQuantitySupplied': 'Total Quantity Supplied'})

# Display the result to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to get total quantity supplied by each supplier
sql_query = '''
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.SupplierID
ORDER BY TotalQuantity DESC
'''

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Find the supplier with the maximum quantity
max_supplier = supplier_data.iloc[0]

# Prepare bar chart to visualize quantities supplied by each supplier
fig = px.bar(supplier_data, x='SupplierID', y='TotalQuantity',
             title='Total Quantity Supplied by Each Supplier',
             labels={'SupplierID': 'Supplier ID', 'TotalQuantity': 'Total Quantity Supplied'})

# Show results to user
show_to_user(supplier_data)
show_to_user(fig)",The input Python code correctly executes a SQL query to retrieve the total quantity supplied by each supplier and visualizes the data using a bar chart with Plotly. It matches the business analytic request by determining which supplier has supplied the most quantity and visualizes the quantities supplied by each supplier. The provided code also adheres to the specified Python environment constraints.,"import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT S.SupplierName, SUM(P.QuantityPerUnit) AS TotalQuantity 
FROM products P 
JOIN suppliers S ON P.SupplierID = S.SupplierID 
GROUP BY S.SupplierName 
ORDER BY TotalQuantity DESC;
'''

# Step 2: Execute the SQL query to retrieve the data
supplier_data = execute_sql_query(sql_query)

# Step 3: Visualize the data using a bar chart
fig = px.bar(supplier_data, x='SupplierName', y='TotalQuantity', title='Total Quantity Supplied by Each Supplier', labels={'TotalQuantity':'Total Quantity', 'SupplierName':'Supplier Name'})

# Step 4: Display the result to the user
show_to_user(fig)

# Display the supplier who has supplied the most quantity
most_supplied_supplier = supplier_data.head(1)
show_to_user(most_supplied_supplier)","The input Python code correctly executes the SQL query to aggregate the total quantity supplied by each supplier, including the supplier name. It then creates a bar chart using Plotly to visualize the data and displays the chart to the user. Additionally, it identifies and displays the supplier who has supplied the most quantity. The code follows the constraints of the provided Python environment.",both
Determine the average discount given by each employee. Please include a bar chart to illustrate the average discounts given by each employee.,"import pandas as pd
import plotly.express as px

# SQL query to determine the average discount given by each employee
sql_query = '''
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;'''

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly to illustrate the average discounts given by each employee
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', title='Average Discount Given by Each Employee', labels={'EmployeeID': 'Employee ID', 'AvgDiscount': 'Average Discount'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve discounts given by each employee
sql_query = '''
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON od.OrderID = o.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
'''

# Execute the SQL query and get the result as a pandas dataframe
average_discounts_df = execute_sql_query(sql_query)

# Display the average discounts to the user
show_to_user(average_discounts_df)

# Create a bar chart to illustrate the average discounts given by each employee
fig = px.bar(average_discounts_df, 
             x='EmployeeName', 
             y='AverageDiscount', 
             title='Average Discount Given by Each Employee', 
             labels={'EmployeeName': 'Employee', 'AverageDiscount': 'Average Discount'})

# Show the plotly figure to the user
show_to_user(fig)","The provided code correctly executes an SQL query to retrieve the average discount given by each employee, including their full names, and then visualizes this data using a bar chart. It follows the specified Python environment constraints and addresses the business analytic request correctly.","import plotly.express as px

# SQL query to get the average discount given by each employee
sql_query = '''
SELECT e.EmployeeID, AVG(od.Discount) AS avg_discount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='avg_discount', title='Average Discount Given by Each Employee', labels={'EmployeeID': 'Employee ID', 'avg_discount': 'Average Discount'})

# Show the plot to the user
show_to_user(fig)","The input Python code correctly constructs the SQL query to calculate the average discount given by each employee, executes it, and appropriately uses Plotly to create and display a bar chart. It matches the functionality of the reference implementation and follows the Python environment constraints.",both
Which month had the highest number of orders placed? Please include a line chart to visualize the number of orders per month.,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the number of orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m') 
""""""

# Execute the SQL query to get the data into a pandas dataframe
orders_per_month_df = execute_sql_query(sql_query)

# Find the month with the highest number of orders placed
max_orders_month_df = orders_per_month_df.sort_values('OrderCount', ascending=False).head(1)

# Create a line chart to visualize the number of orders per month
fig = px.line(orders_per_month_df, x='Month', y='OrderCount', title='Number of Orders Per Month')

# Display the data analysis and visualization result to the user
show_to_user(max_orders_month_df)
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per month
sql_query = """"""
SELECT  
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,  
    COUNT(OrderID) AS OrderCount  
FROM  
    orders  
GROUP BY  
    Month  
ORDER BY  
    Month
""""""

# Execute the SQL query and store the result in a DataFrame
orders_per_month = execute_sql_query(sql_query)

# Identify the month with the highest number of orders
max_orders_month = orders_per_month.loc[orders_per_month['OrderCount'].idxmax()]

# Create a line chart to visualize the number of orders per month
fig = px.line(orders_per_month, x='Month', y='OrderCount', title='Number of Orders Per Month')

# Show the visualization to the user
show_to_user(fig)

# Display the month with the highest number of orders
max_orders_month",The input code does not display the month with the highest number of orders separately using the show_to_user function. It only prepares this value but does not show it to the user.,"import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS YearMonth, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY YearMonth
ORDER BY YearMonth;
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Find the month with the highest number of orders
season_df_sorted = orders_df.sort_values(by='TotalOrders', ascending=False)
highest_orders_month = season_df_sorted.iloc[0]

# Displaying the month with the highest number of orders
show_to_user(highest_orders_month)

# Visualizing the number of orders per month
fig = px.line(orders_df, x='YearMonth', y='TotalOrders', title='Number of Orders per Month')

# Display the line chart
show_to_user(fig)","The Input Python Code correctly retrieves the number of orders per month, identifies the month with the highest number of orders, and visualizes the data using a line chart. The execution of the SQL query, sorting of the data, and creation of the visual representation match the requirements and constraints specified.",Finetuned
Retrieve the contact information for all suppliers located in a specific region.,"import pandas as pd
import plotly.express as px

# Define the specified region for the query
specified_region = 'YourRegionHere'

# SQL query to retrieve supplier contact information in the specified region
sql_query = f""""""
SELECT SupplierID, CompanyName, ContactName, Phone, City, Region 
FROM suppliers 
WHERE Region = '{specified_region}'
""""""

# Execute the SQL query and retrieve the data in a pandas dataframe
supplier_data = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(supplier_data)","import pandas as pd

# Define the region to filter suppliers by
specific_region = 'YourRegionName'  # replace this with the actual region name

# SQL query to retrieve contact information for suppliers in the specific region
sql_query = f""""""
SELECT SupplierID, CompanyName, ContactName, ContactTitle, Address, City, Region, PostalCode, Country, Phone, Fax, HomePage 
FROM suppliers 
WHERE Region = '{specific_region}'
""""""

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Show the retrieved data to the user
show_to_user(supplier_data)","The input Python code correctly follows the query requirements and environment constraints. It constructs the SQL query properly to filter suppliers in the specified region, uses the execute_sql_query function to retrieve the data, and displays the data using show_to_user function.","import pandas as pd
import plotly.express as px

# Define the region to filter suppliers
target_region = 'Specific Region'

# Define the SQL query
sql_query = f""""""
SELECT CompanyName, ContactName, Email, Phone 
FROM suppliers 
WHERE Region = '{target_region}';
""""""

# Execute the SQL query
suppliers_df = execute_sql_query(sql_query)

# Display the contact information for suppliers in the target region
show_to_user(suppliers_df)

# For additional visualization, let's say we want to see the number of suppliers per region
# We can group by region (this is optional and can be modified as per specific need)
count_per_region_query = 'SELECT Region, COUNT(*) as SupplierCount FROM suppliers GROUP BY Region;'
count_per_region_df = execute_sql_query(count_per_region_query)

# Create a bar chart visualization
fig = px.bar(count_per_region_df, x='Region', y='SupplierCount', title='Number of Suppliers per Region')
show_to_user(fig)","The input code correctly fetches the contact information for suppliers in the specified region, meeting the business requirement. It additionally provides a visualization of the number of suppliers per region, which is a valid and useful enhancement.",both
Calculate the discount amount for each order in January 2023.,"import pandas as pd
import plotly.express as px

# SQL Query to calculate discount amount for each order in January 2023
sql_query = '''
SELECT o.OrderID, SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY o.OrderID;
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)","import pandas as pd

# Query to retrieve the orders and their details for January 2023
sql_query = """"""
SELECT o.OrderID, od.UnitPrice, od.Quantity, od.Discount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
""""""

# Execute the SQL query to get the data
orders_data = execute_sql_query(sql_query)

# Calculate the discount amount for each order
# Discount amount = UnitPrice * Quantity * Discount
orders_data['DiscountAmount'] = orders_data['UnitPrice'] * orders_data['Quantity'] * orders_data['Discount']

# Group by OrderID to sum the discount amount for each order
discount_summary = orders_data.groupby('OrderID')['DiscountAmount'].sum().reset_index()

# Display the results to the user
show_to_user(discount_summary)","The input Python code correctly follows the Python environment constraints, retrieves and processes the data to calculate the discount amount for each order in January 2023, and displays the results to the user. It achieves the same outcome as the reference implementation.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT [Order Details].OrderID, 
       SUM(Quantity * UnitPrice * Discount) AS DiscountAmount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31' 
GROUP BY [Order Details].OrderID;
'''

# Execute the SQL query
orders_discount_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_discount_df)",The input code correctly calculates the discount amount for each order in January 2023. It uses an SQL query similar to the reference implementation and correctly executes the query and displays the results using the utility functions provided.,both
What are the total sales by month? Please include a line chart to illustrate the total sales per month.,"import pandas as pd
import plotly.express as px

# SQL query to fetch total sales by month
sql_query = '''
SELECT YEAR(o.OrderDate) AS Year, 
       MONTH(o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
INNER JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
GROUP BY YEAR(o.OrderDate), MONTH(o.OrderDate) 
ORDER BY Year, Month;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate a 'Year-Month' column
df['Year-Month'] = df['Year'].astype(str) + '-' + df['Month'].astype(str)

# Create a line chart using plotly
fig = px.line(df, x='Year-Month', y='TotalSales', title='Total Sales by Month', labels={'Year-Month': 'Year-Month', 'TotalSales': 'Total Sales'})

# Show the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales by month
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY Month
ORDER BY Month;
'''

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Create a line chart for total sales by month
fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales by Month')

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly follows the Python environment constraints. It executes the SQL query to fetch total sales by month, processes the data into a pandas dataframe, and creates a line chart using plotly to visualize the sales per month. The use of execute_sql_query and show_to_user functions matches the environment constraints and fulfills the given business analytic request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY Month;
""""""

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Validate if the retrieved data is as expected
if 'Month' in sales_data.columns and 'TotalSales' in sales_data.columns:
    # Create a line chart to illustrate the total sales per month
    fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales by Month', labels={'TotalSales': 'Total Sales'})
    fig.update_xaxes(title='Month')
    fig.update_yaxes(title='Total Sales')
    # Display the line chart to the user
    show_to_user(fig)
else:
    raise ValueError('The retrieved data does not contain the expected columns: Month and TotalSales.')","The given Input Python Code effectively meets the business analytic request by correctly executing an SQL query to fetch monthly total sales data and generating a line chart to illustrate the total sales per month. The SQL query is correctly formatted to group sales by month, and necessary columns (Month and TotalSales) are verified before plotting. Therefore, it adheres to the specified Python environment constraints and aligns well with the objective of generating and displaying a line chart for total sales by month.",both
Which category has the highest number of products? Please include a bar chart to visualize the number of products in each category.,"import pandas as pd
import plotly.express as px

# SQL query to get the count of products per category
corrected_sql = ""SELECT CategoryID, COUNT(ProductID) AS NumberOfProducts FROM products GROUP BY CategoryID;""

# Execute the SQL query to get the data
df_products = execute_sql_query(corrected_sql)

# Find the category with the highest number of products
category_with_max_products = df_products.loc[df_products['NumberOfProducts'].idxmax()]

# Plot the bar chart for the number of products in each category
fig = px.bar(df_products, x='CategoryID', y='NumberOfProducts', title='Number of Products in Each Category')

# Show the results
data_to_show = pd.DataFrame({'CategoryID_with_Max_Products': [category_with_max_products['CategoryID']], 'NumberOfProducts': [category_with_max_products['NumberOfProducts']]})

show_to_user(data_to_show)
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count the number of products in each category
sql_query = '''
SELECT CategoryID, COUNT(ProductID) AS ProductCount 
FROM products 
GROUP BY CategoryID
ORDER BY ProductCount DESC
'''

# Execute the SQL query
category_counts_df = execute_sql_query(sql_query)

# Visualizing the results using a bar chart
fig = px.bar(category_counts_df, x='CategoryID', y='ProductCount', 
             title='Number of Products in Each Category',
             labels={'CategoryID': 'Category ID', 'ProductCount': 'Number of Products'})

# Show the results to user
show_to_user(fig)","The input code correctly plots the bar chart and displays the number of products in each category. However, it fails to explicitly identify and display the category with the highest number of products, which is part of the original business analytic request.","import pandas as pd
import plotly.express as px

# Define SQL query to count products in each category
sql_query = 'SELECT CategoryID, COUNT(*) AS ProductCount FROM products GROUP BY CategoryID;'

# Execute the SQL query and get the result in a pandas DataFrame
product_count_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of products in each category
fig = px.bar(product_count_df, x='CategoryID', y='ProductCount', title='Number of Products in Each Category')

# Display the bar chart to the user
show_to_user(fig)

# Find the category with the highest number of products
max_product_category = product_count_df[product_count_df['ProductCount'] == product_count_df['ProductCount'].max()]

# Display the category with the highest number of products
show_to_user(max_product_category)","The input code correctly implements the steps to answer the business analytic request. It executes an SQL query to count products in each category, creates a bar chart to visualize the number of products in each category, and identifies and displays the category with the highest number of products. It follows the Python environment constraints and provides the necessary data analysis and visualizations.",Finetuned
Which products received the highest total discount? Please include a bar chart to visualize the total discounts received by each product.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Discount) AS TotalDiscount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalDiscount DESC;
'''

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Create the bar chart
fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Total Discounts Received by Each Product', labels={'ProductName': 'Product Name', 'TotalDiscount': 'Total Discount'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total discount per product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Discount) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalDiscount DESC
'''  

# Execute the SQL query and get the data
product_discounts_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(product_discounts_df)

# Create a bar chart to visualize total discounts applied to each product
fig = px.bar(product_discounts_df, x='ProductName', y='TotalDiscount',
             title='Total Discounts Received by Each Product',
             labels={'TotalDiscount': 'Total Discount', 'ProductName': 'Product Name'})

# Display the bar chart
show_to_user(fig)",The input Python code follows the provided business analytic request and matches the output of the reference implementation. It correctly executes an SQL query to retrieve the total discounts received by each product and visualizes the data using a bar chart. The use of the `execute_sql_query` and `show_to_user` functions also adheres to the Python environment constraints.,"import plotly.express as px

# Define SQL query
sql_query = '''
SELECT p.ProductName, SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalDiscount DESC;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(result_df, x='ProductName', y='TotalDiscount', title='Total Discounts Received by Each Product')

# Display the plotly figure
show_to_user(fig)",The input code incorrectly calculates the TotalDiscount as SUM(od.Discount * od.Quantity * od.UnitPrice) rather than SUM(od.Discount). The reference implementation correctly calculates the total discount.,Base
Which regions have the highest average order value? Please include a bar chart to visualize the average order value by region.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipRegion, AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ShipRegion 
ORDER BY AverageOrderValue DESC
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(result_df, x='ShipRegion', y='AverageOrderValue',
             title='Average Order Value by Region', labels={'ShipRegion': 'Region', 'AverageOrderValue': 'Average Order Value'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL Query to get total sales and count of orders by region
sql_query = '''
SELECT o.ShipRegion, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales, 
       COUNT(DISTINCT o.OrderID) AS OrderCount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.ShipRegion
'''  

# Execute the SQL query and retrieve data
region_sales_df = execute_sql_query(sql_query)

# Calculate Average Order Value (AOV) by region
region_sales_df['AverageOrderValue'] = region_sales_df['TotalSales'] / region_sales_df['OrderCount']

# Create a bar chart to visualize AOV by region
fig = px.bar(region_sales_df, x='ShipRegion', y='AverageOrderValue', title='Average Order Value by Region', labels={'AverageOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})

# Show the figure to the user
show_to_user(fig)","The input code correctly calculates the Average Order Value (AOV) by region. It executes a SQL query to retrieve total sales and count of orders by region, computes the AOV, creates a bar chart using plotly, and displays it using the provided utility function. The result will be similar to the reference implementation.","# Import necessary libraries
import plotly.express as px

# Define the SQL query
sql_query = '''SELECT ShipRegion, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AvgOrderValue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY ShipRegion 
ORDER BY AvgOrderValue DESC;'''

# Execute the SQL query to get the data
order_data = execute_sql_query(sql_query)

# Create the bar chart using plotly
fig = px.bar(order_data, x='ShipRegion', y='AvgOrderValue', title='Average Order Value by Region', labels={'ShipRegion':'Region', 'AvgOrderValue':'Average Order Value'})

# Display the chart to the user
show_to_user(fig)","The given Python code correctly calculates the average order value by region and visualizes it using a bar chart, meeting the specified business analytic request. The method to calculate the average is slightly different but still valid (dividing the total value by the count of distinct orders instead of using AVG function). Otherwise, the code follows the Python environment constraints and provides the correct answer by visualizing the data.",both
Identify the top 3 customers by revenue in the last quarter. Please include a bar chart to visualize the revenues of the top 3 customers.,"import pandas as pd
import plotly.express as px

# Define the SQL query to get top 3 customers by revenue in the last quarter
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as Revenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate > DATE_SUB(NOW(), INTERVAL 3 MONTH) 
GROUP BY customers.CustomerID 
ORDER BY Revenue DESC 
LIMIT 3;'''

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Validate if the result_df is not empty and contains expected columns
if not result_df.empty and 'CustomerID' in result_df.columns and 'Revenue' in result_df.columns:
    # Create a bar chart to visualize the revenues of the top 3 customers
    fig = px.bar(result_df, x='CustomerID', y='Revenue', title='Top 3 Customers by Revenue in the Last Quarter', labels={'CustomerID': 'Customer ID', 'Revenue': 'Revenue'})

    # Display the bar chart to the user
    show_to_user(fig)
else:
    print('No data to display or missing expected columns.')","import pandas as pd
import plotly.express as px

# Define the SQL query to get total revenue per customer for the last quarter
sql_query = '''
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'
AND o.OrderDate < DATE_TRUNC('quarter', CURRENT_DATE)
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalRevenue DESC
LIMIT 3;
'''  

# Execute the SQL query to get the top 3 customers by revenue
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenues of the top 3 customers
fig = px.bar(top_customers_df, x='CompanyName', y='TotalRevenue', title='Top 3 Customers by Revenue',
             labels={'TotalRevenue': 'Revenue', 'CompanyName': 'Customer Name'})

# Show the results to the user
show_to_user(fig)","The input Python code correctly follows the business analytic request and the Python environment constraints. It retrieves the top 3 customers by revenue in the last quarter using a SQL query, checks the necessary columns, creates a bar chart with Plotly, and displays it using the 'show_to_user' function. The slight differences in SQL syntax and data column names do not affect the correctness of the solution.","import pandas as pd
import plotly.express as px

# SQL query to get the top 3 customers by revenue in the last quarter
sql_query = """"""
    SELECT customers.CustomerID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    JOIN customers ON orders.CustomerID = customers.CustomerID 
    WHERE orders.OrderDate BETWEEN date('now', 'start of quarter', '-3 months') AND date('now', 'start of quarter', '+1 month') 
    GROUP BY customers.CustomerID 
    ORDER BY TotalRevenue DESC 
    LIMIT 3;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure that the dataframe is sorted to get top 3 customers by revenue
result_df = result_df.sort_values(by='TotalRevenue', ascending=False).head(3)

# Plot the bar chart using plotly
fig = px.bar(result_df, x='CustomerID', y='TotalRevenue', title='Top 3 Customers by Revenue in the Last Quarter', labels={'CustomerID':'Customer ID', 'TotalRevenue':'Total Revenue'})

# Display the visualization
show_to_user(fig)","The Python code has a time range calculation issue in the WHERE clause for the OrderDate. The reference implementation correctly uses the last three months from the current date, whereas the provided implementation incorrectly uses LINK/UNLINK SQL-specific date functions that may not achieve the same result. Additionally, ensure the result dataframe isn't empty before visualization.",Base
What percentage of orders were delivered before the required date in 2022? Please include a pie chart to illustrate the percentage of orders delivered before the required date.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM(CASE WHEN YEAR(OrderDate) = 2022 AND ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(OrderID) AS BeforeRequiredDateRate 
FROM orders 
WHERE YEAR(OrderDate) = 2022
'''

# Execute the query using the provided utility function
orders_df = execute_sql_query(sql_query)

# Calculate the percentage
before_required_date_rate = orders_df['BeforeRequiredDateRate'].iloc[0] * 100

# Create a dataframe for the pie chart
pie_chart_df = pd.DataFrame({
    'Status': ['Before Required Date', 'After Required Date'],
    'Values': [before_required_date_rate, 100 - before_required_date_rate]
})

# Generate the pie chart using plotly
fig = px.pie(pie_chart_df, values='Values', names='Status', title='Percentage of Orders Delivered Before Required Date in 2022')

# Show the pie chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Execute SQL query to get orders data for 2022
sql_query = """"""
SELECT ShippedDate, RequiredDate
FROM orders
WHERE YEAR(OrderDate) = 2022
""""""
orders_df = execute_sql_query(sql_query)

# Step 2: Create a new column to check if orders were delivered early
orders_df['DeliveredEarly'] = orders_df['ShippedDate'] < orders_df['RequiredDate']

# Step 3: Calculate percentages
total_orders = len(orders_df)
orders_delivered_early = orders_df[orders_df['DeliveredEarly']].shape[0]
percentage_early = (orders_delivered_early / total_orders) * 100

# Prepare data for pie chart
pie_data = pd.Series([orders_delivered_early, total_orders - orders_delivered_early], index=['Delivered Early', 'Not Delivered Early'])

# Step 4: Create pie chart
fig = px.pie(pie_data, values=pie_data.values, names=pie_data.index, title='Percentage of Orders Delivered Before Required Date in 2022')

# Step 5: Show results and pie chart to user
show_to_user(fig)

# Output the percentage
percentage_early
",The given Python code correctly calculates the percentage of orders delivered before the required date in 2022 and generates a pie chart using Plotly. It follows the Python environment constraints by using the provided execute_sql_query and show_to_user functions. The output and logic match the requirements outlined in the business analytic request.,"To determine the percentage of orders delivered before the required date in 2022 and visualize this with a pie chart, we can break down the problem into a few clear steps:

1. **Query the data**: Execute the SQL query to retrieve the count of on-time delivered orders versus total orders in 2022.
  
2. **Calculate the on-time delivery rate**: Use the results from the query to determine the on-time delivery percentage.

3. **Create the pie chart**: Use the `plotly` library to create a pie chart, illustrating the percentage of on-time vs. not on-time deliveries.

4. **Show the result to the user**: Display the pie chart result.

Here is how you can implement these steps in Python:

```python
import pandas as pd
import plotly.graph_objects as go

# Step 1: Execute the SQL query to retrieve required data
sql_query = '''
SELECT COUNT(OrderID) AS TotalOrders,
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM orders
WHERE YEAR(OrderDate) = 2022
'''
df = execute_sql_query(sql_query)

# Step 2: Calculate the on-time delivery rate
if df.empty or df.iloc[0]['TotalOrders'] == 0:
    on_time_rate = 0
else:
    on_time_rate = df.iloc[0]['OnTimeDeliveries'] / df.iloc[0]['TotalOrders']
    
# Create a DataFrame for plotting purposes
pie_data = pd.DataFrame({
    'Status': ['On Time', 'Not On Time'],
    'Percentage': [on_time_rate, 1 - on_time_rate]
})

# Step 3: Create the pie chart using plotly
fig = go.Figure(data=[go.Pie(labels=pie_data['Status'], values=pie_data['Percentage'], hole=.3)])

# Step 4: Show the result to the user
show_to_user(fig)
```
### Explanation of the Code
1. **SQL Query Execution**: The provided SQL query retrieves the total number of orders in 2022 and counts how many of these orders were shipped on or before the required date.

2. **On-Time Delivery Calculation**: The code calculates the on-time delivery rate. If there are no orders (to prevent division by zero), it safely assigns a rate of 0.

3. **Data Preparation for Visualization**: A DataFrame is created for visualization, containing two rows: 'On Time' and 'Not On Time', with their respective percentages.

4. **Pie Chart Visualization**: A pie chart is created using `plotly`, which allows for interactive visualizations.

5. **Result Display**: Finally, the result is displayed to the user.

Before running the code, ensure the libraries (`pandas`, `plotly`) are installed in your Python environment.","The provided input code appropriately performs the required tasks: executing the SQL query, calculating the on-time delivery percentage, preparing data for visualization in a pie chart, and displaying the result using plotly. The logic and structure align well with the business analytic request and reference implementation.",both
Which supplier has the shortest average lead time in April 2023? Please include a bar chart to visualize the average lead times of suppliers.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time 
  FROM orders 
  JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
  JOIN products ON [Order Details].ProductID = products.ProductID 
 WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
 GROUP BY products.SupplierID 
 ORDER BY supplier_lead_time ASC 
 LIMIT 1
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the supplier with the shortest average lead time
show_to_user(result_df)

# Bar chart for average lead times of all suppliers
sql_query_all_suppliers = '''
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time 
  FROM orders 
  JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
  JOIN products ON [Order Details].ProductID = products.ProductID 
 WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
 GROUP BY products.SupplierID 
 ORDER BY supplier_lead_time ASC
'''

# Execute the query for all suppliers
all_suppliers_df = execute_sql_query(sql_query_all_suppliers)

# Create bar chart using plotly
fig = px.bar(all_suppliers_df, x='SupplierID', y='supplier_lead_time', title='Average Lead Time of Suppliers in April 2023', labels={'supplier_lead_time':'Average Lead Time (Days)'})

# Show the bar chart
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the time period for the analysis
start_date = '2023-04-01'
end_date = '2023-04-30'

# SQL query to get the average lead time for suppliers in April 2023
sql_query = f""""""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time  
FROM orders  
JOIN products ON orders.OrderID = products.ProductID  
WHERE orders.OrderDate BETWEEN '{start_date}' AND '{end_date}'  
GROUP BY products.SupplierID
""""""

# Execute the SQL query and retrieve the data
lead_time_df = execute_sql_query(sql_query)

# Identify the supplier with the shortest average lead time
shortest_lead_time_supplier = lead_time_df.loc[lead_time_df['average_lead_time'].idxmin()]

# Display the supplier with the shortest average lead time
print(f'Supplier ID with the shortest average lead time: {shortest_lead_time_supplier.SupplierID}, Average lead time: {shortest_lead_time_supplier.average_lead_time}')

# Visualizing the average lead times of suppliers using a bar chart
fig = px.bar(lead_time_df, x='SupplierID', y='average_lead_time', title='Average Lead Time by Supplier (April 2023)', labels={'SupplierID': 'Supplier ID', 'average_lead_time': 'Average Lead Time (Days)'} )

# Show the plot to the user
show_to_user(fig)","The input Python code contains an incorrect SQL join clause and lacks an ORDER BY clause. It joins orders with products using orders.OrderID and products.ProductID, which is incorrect. The correct join should be JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID JOIN products ON [Order Details].ProductID = products.ProductID. Additionally, it is missing LIMIT 1 in the SQL query to identify a supplier with the shortest average lead time.","import pandas as pd
import plotly.express as px

# SQL query to get the average lead times of suppliers in April 2023
sql_query = '''
SELECT suppliers.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY suppliers.SupplierID
'''

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Find the supplier with the shortest average lead time
shortest_lead_time_supplier = df.loc[df['avg_lead_time'].idxmin()]

# Display the supplier with the shortest average lead time
show_to_user(shortest_lead_time_supplier)

# Create a bar chart to visualize the average lead times of suppliers
fig = px.bar(df, x='SupplierID', y='avg_lead_time', title='Average Lead Times of Suppliers in April 2023')

# Display the bar chart to the user
show_to_user(fig)","The provided implementation is correct as it follows the specified Python environment constraints. It correctly executes an SQL query to retrieve average lead times of suppliers in April 2023, identifies the supplier with the shortest average lead time, and provides the relevant bar chart visualizing the average lead times of all suppliers. The structure and logic closely match the reference implementation.",Finetuned
Who are the employees reporting to each manager?,"import pandas as pd
import plotly.express as px

# SQL query to get employees reporting to each manager
sql_query = '''
SELECT m.EmployeeID AS ManagerID, m.LastName AS ManagerLastName, m.FirstName AS ManagerFirstName,
       e.EmployeeID AS EmployeeID, e.LastName AS EmployeeLastName, e.FirstName AS EmployeeFirstName
FROM employees e
JOIN employees m ON e.ReportsTo = m.EmployeeID;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Data analysis - Group the dataframe by ManagerID, ManagerLastName, and ManagerFirstName
# Keep track of the employees reporting to each manager
grouped_df = df.groupby(['ManagerID', 'ManagerLastName', 'ManagerFirstName']).apply(lambda x: x[['EmployeeID', 'EmployeeLastName', 'EmployeeFirstName']].to_dict('records')).reset_index()
grouped_df.columns = ['ManagerID', 'ManagerLastName', 'ManagerFirstName', 'EmployeesReporting']

# Display the result to the user
show_to_user(grouped_df)
","sql_query = '''
SELECT e.FirstName, e.LastName, e.EmployeeID AS EmployeeID, e.ReportsTo AS ManagerID 
FROM employees e 
WHERE e.ReportsTo IS NOT NULL
ORDER BY e.ReportsTo;
'''
df_employees_reporting = execute_sql_query(sql_query)
show_to_user(df_employees_reporting)","The input code does not fully satisfy the business analytic request. It retrieves employees and their managers but does not group the data to show which employees report to each specific manager. Consequently, it does not provide a clear answer to the question of who reports to whom in an organized manner.","
import pandas as pd
import plotly.express as px

# SQL query to get the employees reporting to each manager
sql_query = '''
SELECT e1.EmployeeID, e1.FirstName, e1.LastName, e1.ReportsTo, e2.FirstName as ManagerFirstName, e2.LastName as ManagerLastName 
FROM employees e1 
LEFT JOIN employees e2 ON e1.ReportsTo = e2.EmployeeID;
'''

# Execute the SQL query
employees_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_df)

# Optional: Visualization
fig = px.histogram(employees_df, x='ReportsTo', title='Number of Employees Reporting to Each Manager', labels={'ReportsTo':'Manager ID'})
show_to_user(fig)
","The input Python code does not correctly satisfy the business analytic request since it does not group the employees by manager. It only retrieves and displays the Employee and Manager data as a flat dataframe without showing which employees report to which managers. Additionally, the optional visualization is useful but not directly necessary for the business request.",None
Find the average discount applied to orders in January 2023. Please include a bar chart to visualize the average discounts applied.,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the average discount
sql_query = ""SELECT AVG(od.Discount) AS AvgDiscount FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';""

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Extract the average discount from the result
avg_discount = result_df['AvgDiscount'][0]

# Create a dataframe for visualization
viz_df = pd.DataFrame({'Month': ['January 2023'], 'AvgDiscount': [avg_discount]})

# Create a bar chart using plotly
fig = px.bar(viz_df, x='Month', y='AvgDiscount', title='Average Discount Applied to Orders in January 2023', labels={'AvgDiscount': 'Average Discount'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

def get_average_discount_january_2023():
    sql_query = '''
    SELECT AVG(D.[Discount]) AS AverageDiscount
    FROM [Order Details] D
    JOIN orders O ON D.OrderID = O.OrderID
    WHERE O.OrderDate >= '2023-01-01' AND O.OrderDate < '2023-02-01'
    '''
    average_discount_df = execute_sql_query(sql_query)
    return average_discount_df

average_discount_df = get_average_discount_january_2023()

# Create a bar chart for visualization
fig = px.bar(average_discount_df, x=['AverageDiscount'], y=['AverageDiscount'], title='Average Discount Applied to Orders in January 2023')
show_to_user(fig)","The evaluated code does not correctly visualize the average discount. The 'px.bar' method's parameters are incorrect. It should use column names for 'x' and 'y', not column values.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT AVG(od.Discount) AS AvgDiscount
FROM orders o
INNER JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-01'
""""""

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Extract the average discount value
avg_discount = result_df['AvgDiscount'][0] if not result_df.empty else 0.0

# Create a DataFrame for visualization
visual_df = pd.DataFrame({'Month': ['2023-01'], 'AvgDiscount': [avg_discount]})

# Create bar chart using plotly
fig = px.bar(visual_df, x='Month', y='AvgDiscount', title='Average Discount in January 2023')

# Display the bar chart to the user
show_to_user(fig)","The input code correctly retrieves the average discount applied to orders in January 2023, accounts for an empty result set by defaulting to 0.0, creates an appropriate DataFrame for visualization, generates a bar chart with plotly, and uses the utility functions to execute the SQL query and display the visualization.",Finetuned
Calculate the total sales for employees located in a specific region.,"import pandas as pd
import plotly.express as px

# SQL query to calculate total sales for employees located in a specific region
sql_query = '''
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE e.Region = 'specific region' 
GROUP BY e.EmployeeID;'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Check the resulting dataframe
print(sales_data.head())

# Plot the total sales for employees located in the specific region
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Total Sales by Employee in Specific Region')

# Display the plot to the user
show_to_user(fig)","import pandas as pd

# Define the region for which to calculate total sales
specific_region = 'YourRegion'  # Replace 'YourRegion' with the desired region

# SQL query to calculate total sales for employees in the specified region
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = '{specific_region}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query and retrieve the dataframe
sales_data = execute_sql_query(sql_query)

# Show the sales data to the user
show_to_user(sales_data)","The input code is meeting the requirement of calculating total sales for employees located in a specific region. It correctly defines the region, constructs the SQL query, executes it, retrieves the data using `execute_sql_query()`, and displays the data using `show_to_user()`. Although it includes additional fields (FirstName, LastName) and sorts the result by TotalSales, these additions do not violate the provided business analytic request or the provided Python environment constraint.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the parameters needed for the function call
region = 'specific_region'  # Replace with the actual region value

# The SQL query to be executed
sql_query = f""""""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE e.Region = '{region}' 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query
sales_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(sales_df)

# (Optional) Visualize the total sales for employees in the specific region using Plotly
fig = px.bar(sales_df, x='EmployeeID', y='TotalSales', title='Total Sales for Employees in Region', labels={'EmployeeID':'Employee ID', 'TotalSales':'Total Sales'})
show_to_user(fig)","The input Python code correctly matches the requirements specified in the business analytic request and conforms to the Python environment constraints. It uses the execute_sql_query function to retrieve the total sales data for employees located in a specific region, aggregates the data as required, and uses the show_to_user function to display both the DataFrame and the visualization. The differences in variable naming and minor formatting do not impact the functional correctness of the code.",both
What are the names of all suppliers who are located in Germany?,"import pandas as pd

# Define the SQL query to find suppliers in Germany
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""

# Execute the SQL query and get the results in a Pandas DataFrame
# Assuming execute_sql_query is previously defined function

df_suppliers = execute_sql_query(sql_query)

# Display the retrieved data to the user
show_to_user(df_suppliers[['CompanyName']])","import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CompanyName 
FROM suppliers 
WHERE Country = 'Germany';
""""""

# Execute the SQL query and retrieve the data
suppliers_in_germany = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(suppliers_in_germany)",The provided input code correctly executes an SQL query to find suppliers located in Germany and then displays the result to the user. It aligns with the business analytic request and adheres to the given Python environment constraints.,"import pandas as pd

# Define the SQL query to fetch suppliers located in Germany
sql_query = 'SELECT CompanyName FROM suppliers WHERE Country = ""Germany"";'

# Execute the SQL query
suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(suppliers_df)",The input code uses double quotes around the country name 'Germany' within the SQL query instead of single quotes. This could potentially cause the query to fail. The references implementation uses single quotes correctly.,Base
What was the average order value in June 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-06';
'''

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Ensure the result is presented to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to calculate the average order value for June 2023
sql_query = '''
SELECT 
    SUM(d.UnitPrice * d.Quantity * (1 - d.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM orders o
JOIN [Order Details] d ON o.OrderID = d.OrderID
WHERE o.OrderDate >= '2023-06-01' AND o.OrderDate < '2023-07-01'
'''

# Execute the SQL query
average_order_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_order_value_df)","The input code correctly calculates the average order value for June 2023 by summing the product of UnitPrice, Quantity, and Discount, then dividing by the count of distinct OrderIDs. It uses a date range to filter orders within June 2023, which is equivalent to using DATE_FORMAT in the reference implementation. The results are then displayed using the show_to_user function.","import pandas as pd
import plotly.express as px

def get_avg_order_value_june_2023():
    # SQL query to get the average order value in June 2023
    sql_query = '''
        SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
        FROM orders o 
        JOIN [Order Details] od ON o.OrderID = od.OrderID 
        WHERE o.OrderDate BETWEEN '2023-06-01' AND '2023-06-30';
    '''

    # Execute the SQL query
    df = execute_sql_query(sql_query)

    # Since the SQL query returns a single value, we extract it
    avg_order_value = df['AvgOrderValue'].iloc[0]
    result_df = pd.DataFrame({'AvgOrderValue': [avg_order_value]})

    # Display the result to the user
    show_to_user(result_df)

# Execute the function to perform the analysis and show the result
get_avg_order_value_june_2023()",The implementation correctly follows the business analytic request and matches the output of the reference implementation. It properly defines and executes the SQL query to calculate the average order value for June 2023 and displays the result using the permitted utility functions. The slight difference in the SQL query is acceptable as it still filters the correct date range.,both
Calculate the average freight cost for each customer. Please include a bar chart to visualize the average freight costs for each customer.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT CustomerID, AVG(Freight) AS AvgFreight FROM orders GROUP BY CustomerID;""

# Execute the SQL query and get the results
customer_freight_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average freight costs for each customer
fig = px.bar(customer_freight_df, x='CustomerID', y='AvgFreight', title='Average Freight Cost per Customer')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate the average freight cost for each customer
sql_query = '''
    SELECT CustomerID, AVG(Freight) AS AvgFreight
    FROM orders
    GROUP BY CustomerID
'''

# Execute the SQL query and retrieve the data
avg_freight_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average freight costs for each customer
fig = px.bar(avg_freight_df, x='CustomerID', y='AvgFreight',
             title='Average Freight Cost per Customer',
             labels={'AvgFreight': 'Average Freight Cost', 'CustomerID': 'Customer ID'})

# Show the figure to the user
show_to_user(fig)","The input Python code correctly calculates the average freight cost for each customer and creates a bar chart to visualize the results. It follows the same logic as the reference implementation and uses the required utility functions `execute_sql_query` and `show_to_user`. Additionally, it adheres to the Python environment constraint, uses Plotly for visualization, and provides appropriate labels for the chart.","import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query
sql_query = 'SELECT CustomerID, AVG(Freight) AS AverageFreight FROM orders GROUP BY CustomerID;'
df = execute_sql_query(sql_query)

# Step 2: Visualize the data using a bar chart
fig = px.bar(df, x='CustomerID', y='AverageFreight', title='Average Freight Cost for Each Customer', labels={'CustomerID': 'Customer ID', 'AverageFreight': 'Average Freight Cost'})

# Step 3: Display the chart to the user
show_to_user(fig)","The input code correctly performs all the steps mentioned in the business analytic request. It executes the SQL query to get the average freight cost per customer, then visualizes this data using a bar chart with Plotly, and finally displays it using the show_to_user function. The implementation is consistent with the reference code and meets the provided constraints.",both
How many orders were placed on weekends in the last three months? Please include a bar chart to visualize the number of orders placed on each weekend.,"import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define SQL query to get weekend orders in the last three months
sql_query = '''
SELECT OrderDate, COUNT(OrderID) AS WeekendOrders 
FROM orders 
WHERE DAYOFWEEK(OrderDate) IN (1, 7) 
AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
GROUP BY OrderDate
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Convert OrderDate to datetime
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])

# Create a column for the weekend day (Saturday/Sunday)
orders_df['Weekend'] = orders_df['OrderDate'].dt.strftime('%A')

# Aggregate total orders by weekend day
weekend_orders_df = orders_df.groupby('Weekend')['WeekendOrders'].sum().reset_index()

# Create a bar chart to visualize the number of orders placed on each weekend day
fig = px.bar(weekend_orders_df, x='Weekend', y='WeekendOrders', title='Number of Orders Placed on Weekends in the Last Three Months')

# Show the bar chart to the user
show_to_user(fig)","
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last three months
end_date = datetime.now()
start_date = end_date - timedelta(days=90)

# SQL query to get the orders placed on weekends in the last three months
sql_query = f""""""
SELECT DATE(OrderDate) AS OrderDate, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
AND DAYOFWEEK(OrderDate) IN (1, 7) -- 1 = Sunday, 7 = Saturday
GROUP BY OrderDate
ORDER BY OrderDate
""""""

# Execute the SQL query and get the data
weekend_orders = execute_sql_query(sql_query)

# Display the total number of weekend orders
total_weekend_orders = weekend_orders['OrderCount'].sum()
print(f'Total orders placed on weekends in the last three months: {total_weekend_orders}')

# Visualize the number of orders placed on each weekend
fig = px.bar(weekend_orders, x='OrderDate', y='OrderCount', title='Weekend Orders in the Last 3 Months',
             labels={'OrderDate': 'Weekend Date', 'OrderCount': 'Number of Orders'})
show_to_user(fig)","The input Python code adheres to the business analytic request and the environment constraints. It correctly calculates the orders placed on weekends over the last three months, generates a bar chart using Plotly, and uses the provided utility functions execute_sql_query and show_to_user. The logic and output closely align with the reference implementation, even if the SQL and some column names differ slightly.","import pandas as pd
import plotly.express as px

# SQL query to get weekend orders in the last three months
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m-%d') AS OrderDate, COUNT(*) AS WeekendOrders
FROM orders
WHERE DAYOFWEEK(OrderDate) IN (1, 7) 
AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
GROUP BY OrderDate
ORDER BY OrderDate;
""""""

# Execute the SQL query
weekend_orders_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(weekend_orders_df, x='OrderDate', y='WeekendOrders', title='Number of Orders Placed on Weekends in the Last Three Months', labels={'OrderDate': 'Date', 'WeekendOrders': 'Number of Weekend Orders'})

# Display the bar chart to the user
show_to_user(fig)",The input Python code accomplishes the SQL query execution and visualization but does not aggregate the orders specifically by weekend days (Saturday/Sunday) as requested. This is crucial for analyzing the total number of orders on each weekend day and creating the bar chart based on that.,Base
What is the total sales revenue generated in the year 2023?,"import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales revenue in 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales revenue from the result
if not result_df.empty:
    total_sales = result_df.iloc[0]['total_sales']
else:
    total_sales = 0

# Create a DataFrame for visualization
sales_df = pd.DataFrame({'Year': ['2023'], 'Total Sales': [total_sales]})

# Create a bar plot using plotly express
fig = px.bar(sales_df, x='Year', y='Total Sales', title='Total Sales Revenue for 2023', labels={'Total Sales': 'Revenue ($)'})

# Display the result to the user
show_to_user(fig)","import pandas as pd

# SQL query to calculate total sales revenue for the year 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(results_df)","The input code correctly calculates the total sales revenue for the year 2023 but only displays the raw results dataframe to the user. It does not process the dataframe to extract the 'total_sales' value and does not create a Plotly visualization as required by the business analytic request. The reference implementation creates a bar plot summarizing the total sales revenue for the year 2023, but the input code skips this important step.","import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)","The input code does not process or visualize the total sales revenue in the year 2023 as required. Although the SQL query is correct, it only executes the query and shows the resulting dataframe, without extracting the 'total_sales' value or visualizing it using plotly as specified in the business analytic request.",None
How many products have been ordered but not yet shipped?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT orders.OrderID FROM orders WHERE orders.ShippedDate IS NULL;'

# Execute the SQL query to get the dataframe using the provided utility function
orders_df = execute_sql_query(sql_query)

# Calculate the number of products that have been ordered but not yet shipped
num_products_not_shipped = len(orders_df)

# Create a dataframe to display the result
result_df = pd.DataFrame({'Number of products not shipped': [num_products_not_shipped]})

# Use the provided utility function to display the result
show_to_user(result_df)","import pandas as pd

# SQL query to count how many products have been ordered but not yet shipped
sql_query = '''
SELECT SUM(p.UnitsOnOrder) AS ProductsOnOrder
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.ShippedDate IS NULL;
'''

# Execute the SQL query and get the results in a pandas dataframe
data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(data)","The input code counts the sum of products on order but not shipped using the 'UnitsOnOrder' field from the 'products' table, which may not accurately reflect the actual number of products ordered but not yet shipped. The reference code simply counts the number of unshipped orders, which is a straightforward and effective approach to answer the business analytic request. The input code may give an incorrect or different count due to differences in the way 'UnitsOnOrder' is managed or if there are discrepancies in joins between products, order details, and orders.","import pandas as pd

# SQL query to find products ordered but not yet shipped
sql_query = '''
SELECT OD.ProductID, SUM(OD.Quantity) AS TotalOrdered
FROM [Order Details] OD
INNER JOIN orders O ON OD.OrderID = O.OrderID
WHERE O.Status != 'Shipped'
GROUP BY OD.ProductID;
'''

# Execute the SQL query
products_not_shipped_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty and display the result
if not products_not_shipped_df.empty:
    show_to_user(products_not_shipped_df)
else:
    print(""No products have been ordered but not yet shipped."")","The input Python code does not accurately meet the business analytic request. The query in the input code calculates the number of products and their total ordered quantity that have not been shipped, while the business request asks for the number of orders that have not been shipped. The reference implementation also counts the number of orders yet to be shipped, not the number of products with their quantities.",None
Which products are low in stock and need reordering?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;""

# Execute the SQL query and get the result in a pandas dataframe
products_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(products_df)","import pandas as pd

# SQL query to fetch products that are low in stock
sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
'''  

# Execute the SQL query and get the result as a DataFrame
low_stock_products = execute_sql_query(sql_query)

# Show the resulting DataFrame to the user
show_to_user(low_stock_products)","The input Python code correctly fetches the products that are low in stock and need reordering by using an SQL query that considers the 'UnitsInStock', 'ReorderLevel', and 'Discontinued' columns. The resulting DataFrame is displayed to the user using the 'show_to_user' utility function. The logic matches the specified business analytic request and satisfies the Python environment constraints.","import pandas as pd
import plotly.express as px

# SQL query to get products that are low in stock and need reordering
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query
products_low_stock = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_low_stock)",The input code does not check if products are discontinued. The reference code includes a condition 'AND Discontinued = 0' to filter out discontinued products.,Base
How many orders were shipped but not yet delivered by the required date?,"# Import necessary libraries
import pandas as pd

# Define the SQL query as given in the business request
sql_query = 'SELECT COUNT(*) FROM orders WHERE ShippedDate > RequiredDate;'

# Execute the SQL query using the provided utility function
orders_df = execute_sql_query(sql_query)

# The result from the query will be a dataframe with one column containing the count
orders_not_delivered_on_time_count = orders_df.iloc[0, 0]

# Convert the result into a pandas dataframe to display
result_df = pd.DataFrame({'Orders Not Delivered On Time': [orders_not_delivered_on_time_count]})

# Display the result using the provided utility function
show_to_user(result_df)","import pandas as pd

# SQL query to fetch the orders that were shipped but not yet delivered by the required date
sql_query = """"""
SELECT COUNT(OrderID) AS UndeliveredOrders
FROM orders
WHERE ShippedDate IS NOT NULL AND ShippedDate > RequiredDate
""""""

# Execute the SQL query and get the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The provided Python code correctly implements the business analytic request, which is to count how many orders were shipped but not yet delivered by the required date. It uses an appropriate SQL query with the necessary conditions (ShippedDate IS NOT NULL and ShippedDate > RequiredDate), and it successfully executes the query and displays the result to the user using the provided utility functions.","import pandas as pd

# SQL query to retrieve orders that were shipped but not yet delivered by the due date
sql_query = 'SELECT COUNT(*) AS LateDeliveries FROM orders WHERE ShippedDate > RequiredDate;'

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(df)",The given implementation aligns with the reference implementation. It correctly counts the orders where the ShippedDate is greater than the RequiredDate and uses the provided utility functions to execute the SQL query and display the result. The minor variation (naming the count as 'LateDeliveries') does not affect the correctness or output.,both
Determine the average number of products per order.,"import pandas as pd

# SQL query to determine the average number of products per order
sql_query = '''
SELECT AVG(ProductCount) AS AverageProductsPerOrder 
FROM (SELECT OrderID, COUNT(ProductID) AS ProductCount 
      FROM [Order Details] 
      GROUP BY OrderID) AS ProductCounts;'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if the result dataframe is empty to avoid IndexError
if not result_df.empty:
    # Extract the average number of products per order from the result
    average_products_per_order = result_df['AverageProductsPerOrder'][0]
else:
    average_products_per_order = None

# Prepare the result to show the user
result_to_show = pd.DataFrame({
    'AverageProductsPerOrder': [average_products_per_order]
})

# Show the result to the user
show_to_user(result_to_show)","import pandas as pd

# SQL query to get the total number of products ordered and count of orders
sql_query = '''
SELECT COUNT(od.ProductID) AS ProductCount, COUNT(DISTINCT o.OrderID) AS OrderCount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Calculate the average number of products per order
if not result_df.empty:
    average_products_per_order = result_df['ProductCount'].iloc[0] / result_df['OrderCount'].iloc[0]
else:
    average_products_per_order = 0

# Convert result into a DataFrame for display
average_df = pd.DataFrame({'Average Products per Order': [average_products_per_order]})

# Show the result to the user
show_to_user(average_df)","The provided code accurately calculates the average number of products per order. It first retrieves the total number of products and the number of unique orders via a SQL query, then calculates the average by dividing those two values. Finally, it presents the result in a DataFrame and displays it. While the approach is different from the reference implementation, it achieves the same result and adheres to the provided utility functions.","import pandas as pd

# SQL query to determine the average number of products per order
sql_query = 'SELECT AVG(Quantity) AS AverageProductsPerOrder FROM [Order Details];'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average number of products per order
average_products_per_order = result_df['AverageProductsPerOrder'].iloc[0]

# Create a dataframe to display the result
average_df = pd.DataFrame({'Average Products Per Order': [average_products_per_order]})

# Display the result to the user
show_to_user(average_df)","The evaluated Python code uses the AVG(Quantity) SQL query which calculates the average quantity of products ordered, but it doesn't account for the number of products per order (which the reference implementation does by using COUNT(ProductID) and averaging that). Therefore, it does not correctly determine the average number of products per order.",Base
Which suppliers provide products that are currently discontinued?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 1;
'''

# Execute the SQL query
suppliers_with_discontinued_products = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(suppliers_with_discontinued_products)

# Additional visualization (Optional)
fig = px.bar(suppliers_with_discontinued_products, x='CompanyName', y='SupplierID', 
             title='Suppliers Providing Discontinued Products', 
             labels={'CompanyName': 'Supplier Company', 'SupplierID': 'Supplier ID'})

# Show the bar plot to the user
show_to_user(fig)","sql_query = """"""
SELECT DISTINCT s.SupplierID, p.ProductName 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
WHERE p.Discontinued = 1
""""""

# Execute the SQL query to get the suppliers and their discontinued products
data = execute_sql_query(sql_query)

# Show the result to user
show_to_user(data)","The input code retrieves the ProductName instead of CompanyName. The request specifically asks for suppliers, implying we need SupplierID and CompanyName.","import pandas as pd
import plotly.express as px

# SQL query to find suppliers providing discontinued products
sql_query = ""SELECT s.CompanyName FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID WHERE p.Discontinued = 1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code only selects the 'CompanyName' of the suppliers providing discontinued products, while the business analytic request requires identifying which suppliers provide discontinued products, including their SupplierID. The reference implementation includes both the SupplierID and CompanyName of the suppliers, and adds a visualization of the results, which the input code lacks.",None
What are the most commonly ordered product quantities?,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS MostCommonQuantities 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID 
ORDER BY MostCommonQuantities DESC;
'''

# Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result dataframe to the user
show_to_user(df)

# Create and display a bar chart visualization
fig = px.bar(df, x='ProductID', y='MostCommonQuantities', title='Most Commonly Ordered Product Quantities', labels={'ProductID': 'Product ID', 'MostCommonQuantities': 'Total Quantity Ordered'})
show_to_user(fig)","import pandas as pd

# SQL query to retrieve quantities ordered from the Order Details table
sql_query = """"""
SELECT Quantity, COUNT(*) as OrderCount
FROM [Order Details]
GROUP BY Quantity
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
quantities_df = execute_sql_query(sql_query)

# Show the most commonly ordered product quantities to the user
show_to_user(quantities_df)","The input code does not correctly answer the business analytic request. The request is to find the most commonly ordered product quantities for each product, but the input code instead finds the most common overall quantities ordered across all products. Additionally, the input code does not perform any visualization as required.","
import plotly.express as px


def get_most_commonly_ordered_quantities():
    # Define the SQL query to get the most commonly ordered product quantities
    sql_query = '''
    SELECT Quantity, COUNT(*) AS OrderCount 
    FROM [Order Details] 
    GROUP BY Quantity 
    ORDER BY OrderCount DESC;
    '''

    # Execute the SQL query
    df = execute_sql_query(sql_query)

    # Display the resultant dataframe to the user
    show_to_user(df)
    
    # Visualize the data using a bar chart
    fig = px.bar(df, x='Quantity', y='OrderCount', title='Most Commonly Ordered Product Quantities', labels={'Quantity': 'Product Quantity', 'OrderCount': 'Order Count'})
    
    # Show the bar chart to the user
    show_to_user(fig)

# Execute the function
get_most_commonly_ordered_quantities()
","The input code does not match the business analytic request or the reference implementation. The reference implementation queries the total quantities ordered for each product, while the input code queries the frequency of different quantities ordered, not tied to specific products. The input code addresses a different question than the requested 'most commonly ordered product quantities'.",None
Find the most expensive product by unit price.,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT ProductName FROM products ORDER BY UnitPrice DESC LIMIT 1;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to get the most expensive product by unit price
sql_query = '''
SELECT ProductID, ProductName, UnitPrice 
FROM products 
WHERE Discontinued = 0 
ORDER BY UnitPrice DESC 
LIMIT 1
'''  

# Execute the SQL query
most_expensive_product_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(most_expensive_product_df)","The input Python code is not correct according to the business analytic request and the reference implementation because it includes a WHERE clause to filter out discontinued products. This additional condition is not part of the original business analytic request, which is specifically to find the most expensive product by unit price.","import pandas as pd

# Define the SQL query to get the most expensive product
sql_query = ""SELECT ProductName FROM products ORDER BY UnitPrice DESC LIMIT 1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the product name from the result dataframe
product_name = result_df.iloc[0, 0]

# Show the result to the user as a dataframe
result_to_show = pd.DataFrame({'Most Expensive Product': [product_name]})
show_to_user(result_to_show)","The input code correctly executes the SQL query to find the most expensive product, extracts the product name from the result, and shows the result to the user in a dataframe format. It adheres to the given functionality of execute_sql_query and show_to_user.",Finetuned
Find the top 5 highest priced products.,"import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query and get the resulting dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
graph = px.bar(result_df, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products', labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price'})
show_to_user(graph)","sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE Discontinued = 0 
ORDER BY UnitPrice DESC 
LIMIT 5;
""""""

# Execute the SQL query to get the top 5 highest priced products.
result_df = execute_sql_query(sql_query)

# Display the result to the user.
show_to_user(result_df)","The input code does not visualize the results as the reference implementation does. It only displays the raw DataFrame without creating a plotly graph. The main task includes displaying the top 5 highest priced products in a graphical format, which the input code fails to do.","import pandas as pd
import plotly.express as px

# SQL query to find the top 5 highest priced products
sql_query = 'SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;'

# Execute the SQL query to retrieve data
products_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(products_df, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products', labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price'})

# Show the chart to the user
show_to_user(fig)","The provided code is correct. It forms the correct SQL query to find the top 5 highest priced products, executes the query using 'execute_sql_query' function to get a pandas dataframe, creates a bar chart using Plotly, and displays the chart using 'show_to_user' function. The logic and flow match the reference implementation.",Finetuned
List customers with their respective regions and count of orders placed.,"
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT customers.CustomerID, customers.Region, COUNT(orders.OrderID) AS total_orders 
FROM customers 
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID 
GROUP BY customers.CustomerID, customers.Region;'''

# Execute the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Display the results to the user as a table
show_to_user(data)

# Optionally, create a visualization using plotly
# Example: Bar chart showing count of orders per region
fig = px.bar(data, x='CustomerID', y='total_orders', color='Region', title='Count of Orders per Customer by Region')

# Show the plotly figure to the user
show_to_user(fig)
","import pandas as pd

# SQL query to list customers with their respective regions and count of orders placed
sql_query = '''
SELECT c.CustomerID, c.CompanyName, c.Region, COUNT(o.OrderID) AS OrderCount
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName, c.Region
ORDER BY c.CompanyName;
'''

# Execute the SQL query using the provided utility function
customer_orders_df = execute_sql_query(sql_query)

# Show the retrieved data to the user
show_to_user(customer_orders_df)","The input Python code correctly retrieves customers' details along with their respective regions and the count of orders placed using an SQL query, and it properly displays the results to the user. The code adheres to the Python environment constraints by utilizing the provided utility functions 'execute_sql_query' and 'show_to_user'. Although the input code includes an additional column (CompanyName) and sorts the results by CompanyName, the main request and intent are accurately fulfilled.","import pandas as pd
import plotly.express as px

# Define the SQL query to get customers with their respective regions and count of orders placed
sql_query = '''
SELECT c.CustomerID, c.Region, COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID, c.Region;
'''

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(results_df)

# Optional: Visualize the data using a bar chart
fig = px.bar(results_df, x='CustomerID', y='OrderCount', color='Region',
             title='Order Count by Customer and Region',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Show the visualization
show_to_user(fig)","The provided Input Python Code uses an inner join ('JOIN') in the SQL query, whereas the Reference Implementation uses a left join ('LEFT JOIN'). This means that customers with no orders will be excluded in the Input Python Code, but included as customers with zero orders in the Reference Implementation, potentially leading to different outputs.",Base
Find the top 5 cities with the highest number of orders and visualize the distribution of orders.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 5;
'''

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Generate the bar chart using Plotly
fig = px.bar(orders_df, x='ShipCity', y='OrderCount', title='Top 5 Cities with the Highest Number of Orders', labels={'ShipCity': 'City', 'OrderCount': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to find the top 5 cities with the highest number of orders
sql_query = '''
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 5;
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)

# Visualization of the distribution of orders
fig = px.bar(result_df, x='ShipCity', y='OrderCount', title='Top 5 Cities by Number of Orders')
show_to_user(fig)","The input Python code correctly follows the business analytic requirements and the environment constraints. It uses 'execute_sql_query' to retrieve the top 5 cities with the highest number of orders, and then utilizes Plotly to visualize the distribution of orders, displaying the results using 'show_to_user'.","To solve the given problem, we will follow these steps:

1. Retrieve the top 5 cities with the highest number of orders using the SQL query: `SELECT ShipCity, COUNT(*) AS OrderCount FROM orders GROUP BY ShipCity ORDER BY OrderCount DESC LIMIT 5;`.
2. Visualize the distribution of orders in these cities using a bar chart.

The Python code to implement this is as follows:

```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to fetch the required data
sql_query = 'SELECT ShipCity, COUNT(*) AS OrderCount FROM orders GROUP BY ShipCity ORDER BY OrderCount DESC LIMIT 5;'
df = execute_sql_query(sql_query)

# Step 2: Create a bar chart to visualize the order distribution in the top 5 cities
fig = px.bar(df, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders', labels={'ShipCity': 'City', 'OrderCount': 'Number of Orders'})

# Display the result using the provided utility function
show_to_user(fig)
```

### Explanation of the Code:
1. **SQL Query Execution**: We send our SQL query to the database using the `execute_sql_query` function and store the result in a DataFrame.
2. **Data Visualization**: We use `plotly.express` to create a bar chart that visually represents the number of orders per city.
3. **Display the Result**: Finally, we use the `show_to_user` function to show the generated plot to the user.",The input code correctly uses the provided utility functions 'execute_sql_query' and 'show_to_user'. The SQL query correctly finds the top 5 cities with the highest number of orders. The visualization part with Plotly is also accurate as per the business analytic request. The code roughly matches the reference implementation and meets the Python environment constraints.,both
What is the total quantity of each product sold and visualize the quantities for comparison?,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID;""

# Execute the SQL query to get the data
product_sales_df = execute_sql_query(sql_query)

# Create a bar plot for product quantities visualization
fig = px.bar(product_sales_df, x='ProductID', y='TotalQuantity', title='Total Quantity of Each Product Sold', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch total quantity sold for each product
sql_query = '''
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
'''

# Execute the SQL query to retrieve the data
product_quantities_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total quantities sold for each product
fig = px.bar(product_quantities_df, x='ProductID', y='TotalQuantity',
             title='Total Quantity of Each Product Sold',
             labels={'TotalQuantity': 'Total Quantity Sold', 'ProductID': 'Product ID'},
             color='TotalQuantity')

# Show the visualization to the user
show_to_user(fig)","The input code correctly fetches the total quantity sold for each product using a SQL query, then it creates a bar chart to visualize these quantities. The primary difference from the reference implementation is the JOIN operation with the 'orders' table (which seems unnecessary based on the given context), and an additional ORDER BY clause, which doesn't affect the correctness. The visualization part is also enhanced with a color dimension based on TotalQuantity, which is acceptable.","import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [order details] GROUP BY ProductID;""

# Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Ensure that the SQL data is sorted by ProductID
sales_data.sort_values(by='ProductID', inplace=True)

# Visualize the quantities for comparison
fig = px.bar(sales_data, x='ProductID', y='TotalQuantity', title='Total Quantity Sold per Product', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})

# Show the visualization to the user
show_to_user(fig)",The input Python code correctly retrieves the total quantity of each product sold using an SQL query and then visualizes the results via a Plotly bar chart. It adheres to the constraints and produces equivalent output to the reference implementation. The addition of sorting by 'ProductID' does not affect the correctness of the result.,both
Find the total sales and the number of orders for each customer in March 2023 and visualize the sales distribution.,"import pandas as pd
import plotly.express as px

# SQL query to get the total sales and the number of orders for each customer in March 2023
sql_query = '''
SELECT O.CustomerID, SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales, COUNT(O.OrderID) AS OrderCount 
FROM orders O 
JOIN [Order Details] OD 
ON O.OrderID = OD.OrderID 
WHERE DATE_FORMAT(O.OrderDate, '%Y-%m') = '2023-03' 
GROUP BY O.CustomerID;'''

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Plotting the sales distribution using plotly express
fig = px.histogram(df, x='TotalSales', title='Sales Distribution for March 2023', labels={'TotalSales': 'Total Sales'})

# Display the visualization to the user
show_to_user(fig)

# Display the dataframe for debugging purposes
df_display = df
show_to_user(df_display)","import pandas as pd
import plotly.express as px

# SQL query to get total sales and number of orders for each customer in March 2023
sql_query = """"""
SELECT 
    o.CustomerID, 
    COUNT(o.OrderID) AS NumberOfOrders, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    o.OrderDate >= '2023-03-01' AND o.OrderDate < '2023-04-01' 
GROUP BY 
    o.CustomerID
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to user
show_to_user(result_df)

# Create a bar chart visualization of total sales distribution
fig = px.bar(result_df, x='CustomerID', y='TotalSales', title='Total Sales Distribution per Customer in March 2023')

# Display the visualization to user
show_to_user(fig)","The input code calculates the total sales and number of orders for each customer in March 2023 correctly and visualizes the sales distribution. It uses a valid SQL query, executes it to get the data, and then creates a bar chart using Plotly to show the sales distribution. The results are displayed to the user as required. Although the visualization type differs from the reference code (bar chart vs histogram), it still fulfills the business analytic request.","import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales, 
       COUNT(orders.OrderID) AS order_count 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY customers.CustomerID
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display DataFrame to user
show_to_user(df)

# Visualize the sales distribution
fig = px.histogram(df, x='total_sales', nbins=20, title='Sales Distribution for March 2023')

# Show the plot to the user
show_to_user(fig)","The input Python code correctly calculates the total sales and the number of orders for each customer in March 2023. It also correctly visualizes the sales distribution using a histogram. The SQL query, data processing, and visualization steps match the business analytic request, with minor differences in the SQL query format, which do not affect the outcome.",both
"How many units have been sold for each product, grouped by supplier and create a visualization for the data?","import plotly.express as px

# SQL query to retrieve data
sql_query = '''
SELECT s.SupplierName, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierName, p.ProductName;'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create visualization using Plotly
fig = px.bar(result_df, x='SupplierName', y='TotalQuantitySold', color='ProductName', title='Total Units Sold per Product Grouped by Supplier')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total units sold for each product grouped by supplier
sql_query = '''
SELECT p.SupplierID, p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID, p.ProductID, p.ProductName
ORDER BY p.SupplierID, p.ProductID
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualize the data using plotly
fig = px.bar(result_df, x='ProductName', y='TotalUnitsSold', color='SupplierID',
             title='Total Units Sold for Each Product Grouped by Supplier',
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})

# Display the visualization to the user
show_to_user(fig)","The input Python code correctly calculates the total units sold for each product grouped by supplier and visualizes the data as requested. It uses the `execute_sql_query` function to retrieve the required data and `plotly.express` to create the bar chart. The output is then displayed to the user using the `show_to_user` function. Although the column coloring and grouping are handled differently from the reference implementation, the result meets the business analytic request requirements.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductID, SUM(od.Quantity) AS UnitsSold
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_data)

# Create a visualization for units sold by product
fig = px.bar(sales_data, x='ProductID', y='UnitsSold', 
             title='Total Units Sold for Each Product', 
             labels={'ProductID': 'Product ID', 'UnitsSold': 'Units Sold'})

# Show the plot to the user
show_to_user(fig)","The input Python code does not group the sales data by supplier and product, which is specified in the business analytic request. It only groups by product and does not consider the supplier information. Additionally, the visualization is not grouped by supplier and product, as required.",Base
Calculate the percentage of orders shipped within 5 days of the order date.,"import pandas as pd
import plotly.express as px

def calculate_percentage_within_5_days():
    # SQL queries
    within_5_days_query = """"""
    SELECT COUNT(OrderID) * 100.0 / (SELECT COUNT(OrderID) FROM orders) AS PercentageWithin5Days 
    FROM orders 
    WHERE DATEDIFF(ShippedDate, OrderDate) <= 5
    """"""
    
    # Execute the SQL query
    within_5_days_df = execute_sql_query(within_5_days_query)
    
    # Extract the result from the dataframe
    percentage_within_5_days = within_5_days_df['PercentageWithin5Days'].iloc[0]
    
    # Prepare the result in a dataframe
    result_df = pd.DataFrame({
        'PercentageWithin5Days': [percentage_within_5_days]
    })
    
    # Display the result to the user
    show_to_user(result_df)
    
if __name__ == ""__main__"":
    calculate_percentage_within_5_days()","import pandas as pd

# Step 1: Retrieve order data from database
sql_query = '''
SELECT OrderDate, ShippedDate
FROM orders
WHERE ShippedDate IS NOT NULL
'''
order_data = execute_sql_query(sql_query)

# Step 2: Calculate the number of orders shipped within 5 days
order_data['OrderDate'] = pd.to_datetime(order_data['OrderDate'])
order_data['ShippedDate'] = pd.to_datetime(order_data['ShippedDate'])
order_data['DaysToShip'] = (order_data['ShippedDate'] - order_data['OrderDate']).dt.days

# Step 3: Calculate percentage
shipped_within_5_days = order_data[order_data['DaysToShip'] <= 5].shape[0]
Total_orders = order_data.shape[0]
percentage_shipped_within_5_days = (shipped_within_5_days / Total_orders * 100) if Total_orders > 0 else 0

# Step 4: Show result to user
result_df = pd.DataFrame({'Percentage of Orders Shipped Within 5 Days': [percentage_shipped_within_5_days]})
show_to_user(result_df)","The input Python code correctly calculates the percentage of orders shipped within 5 days of the order date. It retrieves the necessary data from the database, performs the date calculations and comparison, and then computes the required percentage. After computing the percentage, it displays the result using the provided utilities, which matches the required business logic.","import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query
sql_query = 'SELECT OrderID, OrderDate, ShippedDate FROM orders;'

# Step 2: Execute the SQL query and get the data
orders_df = execute_sql_query(sql_query)

# Step 3: Convert OrderDate and ShippedDate to datetime
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])
orders_df['ShippedDate'] = pd.to_datetime(orders_df['ShippedDate'])

# Step 4: Calculate the number of orders shipped within 5 days
orders_df['shipped_within_5_days'] = orders_df['ShippedDate'] <= orders_df['OrderDate'] + pd.Timedelta(days=5)
orders_within_5_days = orders_df[orders_df['shipped_within_5_days']]

# Step 5: Calculate the percentage of orders shipped within 5 days
total_orders = orders_df.shape[0]
orders_shipped_within_5_days = orders_within_5_days.shape[0]
percentage_shipped_within_5_days = (orders_shipped_within_5_days / total_orders) * 100

# Step 6: Display the result to the user
result_df = pd.DataFrame({'Percentage of Orders Shipped Within 5 Days': [percentage_shipped_within_5_days]})
show_to_user(result_df)","The input Python code correctly calculates the percentage of orders shipped within 5 days of the order date. It extracts the necessary data using the execute_sql_query function, converts date columns to datetime, calculates the percentage of orders shipped within 5 days, and finally displays the result using show_to_user. It follows the reference implementation's logic and meets the business analytic request.",both
What is the total quantity ordered across all products by month and visualize the monthly trends?,"import pandas as pd
import plotly.express as px

# SQL query to retrieve data
sql_query = '''
SELECT MONTH(OrderDate) AS OrderMonth, YEAR(OrderDate) AS OrderYear, SUM(Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
GROUP BY MONTH(OrderDate), YEAR(OrderDate);
'''

# Execute SQL query and get the results in a pandas dataframe
data = execute_sql_query(sql_query)

# Convert columns to appropriate types
data['OrderMonth'] = data['OrderMonth'].astype(int)
data['OrderYear'] = data['OrderYear'].astype(int)
data['TotalQuantityOrdered'] = data['TotalQuantityOrdered'].astype(int)

# Create a 'Year-Month' column for easier sorting and plotting
data['YearMonth'] = pd.to_datetime(data['OrderYear'].astype(str) + '-' + data['OrderMonth'].astype(str) + '-01')

# Sort data by 'YearMonth'
data = data.sort_values(by='YearMonth')

# Plot the monthly trends using plotly
fig = px.line(data, x='YearMonth', y='TotalQuantityOrdered', title='Total Quantity Ordered by Month', labels={
    'YearMonth': 'Month',
    'TotalQuantityOrdered': 'Total Quantity Ordered'
})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Query to retrieve total quantity ordered across all products by month
sql_query = """"""
SELECT
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.Quantity) AS TotalQuantityOrdered
FROM
    [Order Details] od
JOIN
    orders o ON od.OrderID = o.OrderID
GROUP BY
    Month
ORDER BY
    Month
""""""

# Step 2: Execute SQL query and retrieve data
monthly_data = execute_sql_query(sql_query)

# Step 3: Visualize monthly trends using Plotly
fig = px.line(monthly_data, x='Month', y='TotalQuantityOrdered',
              title='Total Quantity Ordered by Month',
              labels={'TotalQuantityOrdered': 'Total Quantity Ordered', 'Month': 'Month'})

# Step 4: Show the visualization to the user
show_to_user(fig)","The provided code correctly retrieves the total quantity ordered by month from the database using a SQL query. The query groups by month, sums the quantities, and orders the result by month, ensuring that the data is sorted for plotting. The code then uses Plotly to visualize the monthly trends and shows the plot to the user, which aligns well with the business analytic request.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalQuantityOrdered 
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID, products.ProductName 
ORDER BY products.ProductID;
'''

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Assuming that the data includes a 'Month' column after querying
data['Month'] = pd.to_datetime(data['Order Date']).dt.to_period('M')

# Group the data by month and sum the total quantity ordered
monthly_data = data.groupby('Month', as_index=False).agg({'TotalQuantityOrdered': 'sum'})

# Plot the monthly trends
fig = px.line(monthly_data, x='Month', y='TotalQuantityOrdered', title='Monthly Trends of Total Quantity Ordered', labels={'TotalQuantityOrdered': 'Total Quantity Ordered', 'Month': 'Month'})

# Display the plot to the user
show_to_user(fig)","The input code's SQL query does not match the business analytic request. The SQL query in the input code groups data by ProductID and ProductName, whereas the request requires summing the total quantity ordered by month. Moreover, the input code assumes a 'Month' column from 'Order Date' which is not defined or queried correctly in the SQL statement.",Base
Which product has generated the highest revenue?,"import pandas as pd
import plotly.express as px

# Define the SQL Query
sql_query = '''SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS Revenue 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY Revenue DESC;'''

# Execute the SQL Query
result_df = execute_sql_query(sql_query)

# Display the product with the highest revenue
if not result_df.empty:
    highest_revenue_product = result_df.iloc[0]
    show_to_user(highest_revenue_product)

# Transform the result_df to a more readable format if needed
result_df['ProductID'] = result_df['ProductID'].astype(str)

# Create a bar plot for visualization
fig = px.bar(result_df, x='ProductID', y='Revenue', title='Revenue by Product', 
             labels={'ProductID': 'Product ID', 'Revenue': 'Revenue'},
             text_auto=True)

# Show to user
show_to_user(fig)

# Print the product with the highest revenue
print(highest_revenue_product)","sql_query = '''
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalRevenue DESC
LIMIT 1;
'''

highest_revenue_product = execute_sql_query(sql_query)
show_to_user(highest_revenue_product)","The input code focuses only on getting the top product by revenue but does not show or visualize the data in a comprehensive way. It fetches the top product and shows it to the user, but it doesn't match the reference implementation which also includes steps to transform and visualize the entire result set.","import pandas as pd
import plotly.express as px

# SQL query to get the product generating the highest revenue
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalRevenue DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The input Python code retrieves only the single product with the highest revenue while the reference code retrieves all products ordered by revenue and then processes it to find the highest one. This directly limits further opportunities for analysis like plotting the revenue of all products.,None
Calculate the average order value for each customer.,"import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue 
FROM customers c 
INNER JOIN orders o ON c.CustomerID = o.CustomerID 
INNER JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query to retrieve data

df = execute_sql_query(sql_query)

# The SQL query already calculates average order value per customer

# Display the result to the user
show_to_user(df)","import pandas as pd

# SQL query to calculate average order value for each customer
sql_query = '''
SELECT  c.CustomerID, 
        c.CompanyName, 
        AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM    customers c
JOIN    orders o ON c.CustomerID = o.CustomerID
JOIN    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
'''

# Execute the SQL query
aov_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(aov_df)",The input code correctly calculates the average order value for each customer by joining the required tables and grouping by CustomerID and CompanyName. The utility functions execute_sql_query and show_to_user are used correctly.,"import pandas as pd

# SQL query to calculate the average order value for each customer
sql_query = '''
SELECT o.CustomerID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID
'''

# Execute the SQL query using the provided utility function
customer_average_order_values = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(customer_average_order_values)","The input Python code matches the intent and calculations of the reference implementation. Both calculate the average order value per customer by joining the orders and order details tables and grouping by the customer ID. The only difference is the use of different table aliases, which does not affect the correctness of the query. The functions 'execute_sql_query' and 'show_to_user' are used as required.",both
What is the average lead time for orders delivered by each supplier and visualize the lead times?,"import pandas as pd
import plotly.express as px

# SQL query to get average lead time for orders delivered by each supplier
sql_query = '''
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID
'''

# Execute the SQL query and retrieve data as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(df, x='SupplierID', y='avg_lead_time', title='Average Lead Time for Orders Delivered by Each Supplier', labels={'SupplierID': 'Supplier ID', 'avg_lead_time': 'Average Lead Time (Days)'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get average lead time for orders per supplier
sql_query = '''SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID''' 

# Execute the SQL query and store the result in a DataFrame
lead_time_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(lead_time_df, x='SupplierID', y='average_lead_time',
             title='Average Lead Time for Orders by Supplier',
             labels={'SupplierID': 'Supplier ID', 'average_lead_time': 'Average Lead Time (days)'}
            )

# Show the figure to the user
show_to_user(fig)",Both the input Python code implementation and the reference implementation accurately fetch the average lead time for orders delivered by suppliers using an SQL query and visualize this data using Plotly. The minor differences in variable names and column labels do not affect the functionality or correctness of the code.,"To analyze the average lead time for orders delivered by each supplier and visualize the results, we can follow these steps in Python:

1. **Query the Database**: Retrieve the average lead time grouped by each supplier.
2. **Process the Data**: Use pandas to manage and analyze the data.
3. **Visualize with Plotly**: Create a bar chart to visualize the average lead time for each supplier.

Hereâ€™s how you can implement this in Python.

```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query and retrieve the data
sql_query = """"""
SELECT p.SupplierID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.SupplierID;
""""""

# Fetch data from the database
lead_time_df = execute_sql_query(sql_query)

# Step 2: Process the data (already handled by SQL query)

# Step 3: Visualize the data
fig = px.bar(lead_time_df, x='SupplierID', y='AvgLeadTime', title='Average Lead Time by Supplier', labels={'SupplierID':'Supplier ID', 'AvgLeadTime':'Average Lead Time (days)'})

# Step 4: Show the plot to the user
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: The SQL query calculates the average lead time for each supplier by measuring the difference between the order date and the shipped date, and grouping the results by the supplier.
2. **Data Retrieval**: `execute_sql_query` retrieves the resulting dataframe.
3. **Visualization**: We use Plotly to create a bar chart, making it easy to see the differences in lead times.
4. **Display Results**: Finally, `show_to_user` displays the result to the user.","The input Python code correctly follows the steps outlined in the business analytic request. It retrieves the average lead time for orders delivered by each supplier using an appropriate SQL query, processes the data correctly using pandas, and creates a bar chart visualization with Plotly. The output is displayed to the user using the show_to_user utility function. The code adheres to the provided Python environment constraints and accomplishes the task effectively.",both
Which suppliers provide products that are currently out of stock?,"import pandas as pd

# Define SQL query to retrieve the required data
sql_query = """"""
SELECT s.SupplierName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.UnitsInStock = 0;
""""""

# Execute the SQL query and retrieve data into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(df)","import pandas as pd

# SQL query to find suppliers of products that are currently out of stock
sql_query = """"""
SELECT DISTINCT p.SupplierID, s.SupplierName
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitsInStock = 0
""""""

# Execute the SQL query and store the result in a DataFrame
out_of_stock_suppliers = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(out_of_stock_suppliers)",The provided code correctly identifies the suppliers of products that are currently out of stock by joining the 'products' and 'suppliers' tables on the 'SupplierID' field and filtering where 'UnitsInStock' is zero. It follows the same logical approach as the reference code and uses the same utility functions to execute the SQL query and display the result.,"import pandas as pd

# Define the SQL query
sql_query = '''SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.UnitsInStock = 0;'''

# Execute the SQL query to retrieve data
suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(suppliers_df)",Both the input and reference codes fulfill the business analytic request of identifying suppliers that provide products which are currently out of stock. The SQL queries are similar in logic and both obtain the required data correctly using a join between the 'suppliers' and 'products' tables where 'UnitsInStock' is 0. The slight differences in SQL query format and the inclusion of the SupplierID in the input code does not alter the correctness of the result.,both
How many units on order are there for each product?,"import pandas as pd
import plotly.express as px

# SQL query to get the product names and units on order
sql_query = 'SELECT p.ProductName, p.UnitsOnOrder FROM products p'

# Execute SQL query
products_df = execute_sql_query(sql_query)

# Check the retrieved DataFrame
print(products_df.head())

# Visualize the data using Plotly
fig = px.bar(products_df, x='ProductName', y='UnitsOnOrder', title='Units on Order for Each Product', labels={'ProductName': 'Product Name', 'UnitsOnOrder': 'Units on Order'})

# Display the chart to the user
show_to_user(fig)","import pandas as pd

# SQL query to get UnitsOnOrder for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, p.UnitsOnOrder 
FROM products p
'''

# Execute the SQL query
units_on_order_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(units_on_order_df)","The input Python code retrieves the correct data (ProductID, ProductName, UnitsOnOrder) and displays it to the user, but it doesn't create a visualization using Plotly as required by the business analytic request.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = 'SELECT ProductName, UnitsOnOrder FROM products;'

# Step 2: Execute the query and retrieve the data
products_df = execute_sql_query(sql_query)

# Step 3: Display the result to the user
show_to_user(products_df)

# Optional visualization
fig = px.bar(products_df, x='ProductName', y='UnitsOnOrder', title='Units on Order for Each Product', labels={'ProductName': 'Product Name', 'UnitsOnOrder': 'Units On Order'})
show_to_user(fig)","The input Python code correctly follows the business analytic request of retrieving and displaying the number of units on order for each product. It utilizes the required utility functions, executes the SQL query, and provides a visualization using Plotly, similar to the reference implementation. All necessary steps are correctly implemented.",Finetuned
How many units of each product are currently in stock?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductID, ProductName, UnitsInStock FROM products;'

# Execute the SQL query using the provided utility function
products_df = execute_sql_query(sql_query)

# Display the data to the user using the provided utility function
show_to_user(products_df)

# For visualization, create a bar chart for the UnitsInStock of each ProductName
fig = px.bar(products_df, x='ProductName', y='UnitsInStock', title='Units In Stock per Product', labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units In Stock'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd

# SQL query to get the current stock of each product
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query and store the result in a dataframe
products_in_stock = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(products_in_stock)","The given code deviates from the reference implementation in a couple of important ways: 1) It adds an additional condition to filter out discontinued products in the SQL query, which may not align with the business analytic request to count all products in stock. 2) It does not create a bar chart visualization for the units in stock of each product, as shown in the reference code. To be correct, the code needs to follow the specified business analytic requirements and utilize plotly for the visualization.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT ProductID, UnitsInStock FROM products;'

# Execute the SQL query to retrieve the data
products_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(products_df)","The evaluated code does not fetch the ProductName column from the database, which is essential for understanding which product the UnitsInStock value corresponds to. Additionally, there is no visualization of the UnitsInStock data in the evaluated code, which is a key part of the reference implementation.",None
Which product has the highest unit price but lowest sales quantity?,"import pandas as pd

# Step 1: Query for product with the highest unit price
query_highest_price = '''
SELECT products.ProductID, products.ProductName, products.UnitPrice
FROM products
WHERE products.UnitPrice = (
    SELECT MAX(products.UnitPrice) 
    FROM products
)'''

# Execute the query and get the result
highest_price_product = execute_sql_query(query_highest_price)

# Extract ProductID, ProductName, and UnitPrice of the highest priced product
highest_price_product_id = highest_price_product.iloc[0]['ProductID']
highest_price_product_name = highest_price_product.iloc[0]['ProductName']
highest_price_product_unit_price = highest_price_product.iloc[0]['UnitPrice']

# Step 2: Check if the highest priced product has any sales quantities
query_check_sales = f'''
SELECT [Order Details].ProductID, SUM([Order Details].Quantity) as TotalQuantity
FROM [Order Details]
WHERE [Order Details].ProductID = {highest_price_product_id}
GROUP BY [Order Details].ProductID
'''

# Execute the query and get the result
sales_quantities = execute_sql_query(query_check_sales)

# Step 3: If the product has no sales quantities, create the result dataframe
if sales_quantities.empty or sales_quantities.iloc[0]['TotalQuantity'] == 0:
    result_df = pd.DataFrame({'ProductID': [highest_price_product_id],
                              'ProductName': [highest_price_product_name],
                              'UnitPrice': [highest_price_product_unit_price],
                              'TotalQuantity': [0]})
else:
    # The product has some sales quantity, hence doesn't meet the condition of zero sales quantity
    result_df = pd.DataFrame(columns=['ProductID', 'ProductName', 'UnitPrice', 'TotalQuantity'])

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Query to get products with their unit price and total sales quantity
sql_query = '''
SELECT products.ProductID, products.ProductName, products.UnitPrice, SUM([Order Details].Quantity) AS total_quantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID, products.ProductName, products.UnitPrice
'''  

# Execute the SQL query
product_data = execute_sql_query(sql_query)

# Find the product with the highest unit price but lowest sales quantity
highest_price_lowest_sales = product_data.loc[product_data['total_quantity'].idxmin()]

# Prepare the result to show to user
result = pd.DataFrame([highest_price_lowest_sales])
show_to_user(result)","The evaluated code does not correctly handle the requested logic of finding the product with the highest unit price but lowest sales quantity. The reference implementation ensures the highest priced product is identified first and then checks its sales quantity. The evaluated code instead directly finds the product with the highest price and lowest sales quantity, which may not ensure the condition is correctly met if there are ties in unit price.","import pandas as pd
import plotly.express as px

def get_product_with_highest_price_lowest_sales():
    # Step 1: Execute SQL query
    sql_query = '''
    SELECT p.ProductName, p.UnitPrice, SUM(od.Quantity) AS TotalQuantity 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    GROUP BY p.ProductName, p.UnitPrice 
    ORDER BY p.UnitPrice DESC, TotalQuantity ASC 
    LIMIT 1;
    '''
    df = execute_sql_query(sql_query)
    
    # Step 2: Display the result
    show_to_user(df)

    # Optional: For visualization
    fig = px.bar(df, x='ProductName', y='UnitPrice', title='Product with Highest UnitPrice but Lowest Sales Quantity', labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price'})
    show_to_user(fig)

# Run the function
get_product_with_highest_price_lowest_sales()","The input code does not correctly meet the business analytic request. The query in the input code attempts to fetch the product with the highest unit price and lowest total sales quantity in one step by using ORDER BY and LIMIT clauses. However, the reference implementation clearly states that the product with the highest unit price should first be identified and then checked if this product has the lowest sales quantity. The input code does not follow this two-step approach, thus it may not provide the correct results according to the specified requirements.",None
Which product had the highest sales in terms of quantity in March 2023?,"import pandas as pd

# Define the SQL query to find the product with the highest sales in terms of quantity in March 2023
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductName
ORDER BY total_quantity DESC
LIMIT 1
'''

# Execute the SQL query and retrieve the results
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","sql_query = """"
SELECT products.ProductID, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductID
ORDER BY total_quantity DESC
LIMIT 1
""""""

df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The given code has a couple of issues: the SELECT statement is missing ; the ProductID is selected instead of ProductName, which makes it harder to identify the product with the highest sales without an additional join with the products table. Additionally, the code does not match the reference implementation closely enough in terms of selecting and displaying the product name.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS total_quantity_sold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductID
ORDER BY total_quantity_sold DESC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","The code implementation fails to retrieve the product name, instead it retrieves the ProductID, which doesn't meet the requirement of showing the product with the highest sales in terms of quantity in March 2023.",None
What is the total sales generated by each employee for the past year? Please include a data visualization to illustrate the results.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and retrieve the data
employee_sales_df = execute_sql_query(sql_query)

# Data visualization using plotly
fig = px.bar(employee_sales_df, x='EmployeeID', y='TotalSales', 
            hover_data=['FirstName', 'LastName'], 
            labels={'TotalSales':'Total Sales'}, 
            title='Total Sales Generated by Each Employee for the Past Year')

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve total sales generated by each employee for the past year
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName,
       SUM(o.UnitPrice * o.Quantity * (1 - o.Discount)) AS TotalSales
FROM employees e
JOIN orders ord ON e.EmployeeID = ord.EmployeeID
JOIN [Order Details] o ON ord.OrderID = o.OrderID
WHERE ord.OrderDate >= NOW() - INTERVAL 1 YEAR
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
'''

# Execute the SQL query and get the data in a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales by each employee
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales',
             title='Total Sales Generated by Each Employee for the Past Year',
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales ($)'},
             text='TotalSales')

# Show the plot to the user
show_to_user(fig)","The input Python code adheres to the specified Python environment constraints, answers the business analytic question by calculating total sales generated by each employee in the past year, and produces a data visualization that closely matches the reference implementation.","import pandas as pd
import plotly.express as px

def main():
    # SQL query to get total sales generated by each employee for the past year
    sql_query = '''
    SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
    FROM employees e 
    JOIN orders o ON e.EmployeeID = o.EmployeeID 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    WHERE o.OrderDate >= DATE('now', '-1 year') 
    GROUP BY e.EmployeeID;
    '''
    
    # Execute the SQL query
    sales_data = execute_sql_query(sql_query)
    
    # Create a bar chart to visualize the results
    fig = px.bar(sales_data, 
                 x='EmployeeID', 
                 y='TotalSales', 
                 title='Total Sales Generated by Each Employee for the Past Year',
                 labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales'})
    
    # Display the visualization
    show_to_user(fig)

# Run the main function
if __name__ == ""__main__"":
    main()","The input code does not include the employee's first and last names in the SQL query and the resulting visualization. The business analytic request specifically asks for a visualization that includes these details as hover data, which the reference implementation does correctly.",Base
Find the average number of days between order placement and order shipping by customer.,"
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageDaysToShip 
FROM orders 
GROUP BY CustomerID;
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(result_df)

# Optionally, create a bar chart visualization
fig = px.bar(result_df, x='CustomerID', y='AverageDaysToShip', title='Average Days to Ship per Customer')

# Display the plotly figure
show_to_user(fig)  
","import pandas as pd

# SQL query to calculate the average number of days between order placement and order shipping by customer
sql_query = '''
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageDays
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY CustomerID
''' 

# Execute the SQL query
average_shipping_days_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_shipping_days_df)","The input Python code correctly computes the average number of days between order placement and order shipping by customer, includes the necessary SQL query constraints, and uses the provided utility functions to execute the query and display the result to the user.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageDaysToShip
FROM orders
GROUP BY CustomerID;
'''

# Execute the SQL query to retrieve data
customer_shipping_data = execute_sql_query(sql_query)

# Displaying the data using the provided function
show_to_user(customer_shipping_data)

# Optional: Create a visualization for better analysis
fig = px.bar(customer_shipping_data, x='CustomerID', y='AverageDaysToShip', title='Average Days to Ship by Customer', labels={'CustomerID':'Customer ID', 'AverageDaysToShip':'Average Days to Ship'})

# Show the plot to the user
show_to_user(fig)","The input Python code correctly follows the specified business analytic request by calculating the average number of days between order placement and order shipping by customer. It also adheres to the Python environment constraints by using the provided `execute_sql_query` and `show_to_user` functions. The code executes the correct SQL query and provides both data display and optional visualization using Plotly, matching the reference implementation in terms of functionality.",both
What is the total sales revenue generated by each product category in the last year? Please include a data visualization to illustrate the results.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales revenue by product category for the last year
sql_query = '''
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY ProductID;
'''

# Execute the SQL query using the provided utility function
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales revenue by product category
fig = px.bar(sales_data,
             x='ProductID',
             y='TotalSales',
             title='Total Sales Revenue by Product Category in the Last Year',
             labels={'ProductID': 'Product Category', 'TotalSales': 'Total Sales Revenue'}
            )

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve total sales revenue by product category in the last year
sql_query = """"""
SELECT p.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY p.CategoryID
""""""

# Execute the SQL query and load the data into a DataFrame
sales_data = execute_sql_query(sql_query)

# Visualize the total sales revenue by product category using Plotly
fig = px.bar(sales_data, x='CategoryID', y='TotalSales',
             title='Total Sales Revenue by Product Category (Last Year)',
             labels={'CategoryID': 'Product Category', 'TotalSales': 'Total Sales Revenue'},
             color='TotalSales')

# Show the visualization to the user
show_to_user(fig)","The provided code correctly executes the SQL query to fetch the total sales revenue by product category for the last year, aggregates the data, and visualizes it using a Plotly bar chart. The use of the products table to retrieve CategoryID appears to be a logical detail enhancement over the reference implementation, which did not group by product category level.","import pandas as pd
import plotly.express as px

# Define and execute the SQL query to get total sales revenue by product category in the last year
sql_query = '''
SELECT categories.CategoryID, categories.CategoryName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY categories.CategoryID, categories.CategoryName
'''

# Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Ensure the data has no missing values and the types are correct
sales_data['CategoryID'] = sales_data['CategoryID'].astype(str)
sales_data['total_sales'] = sales_data['total_sales'].astype(float)

# Create a bar chart to visualize the total sales revenue by product category
fig = px.bar(
    sales_data,
    x='CategoryName',
    y='total_sales',
    title='Total Sales Revenue by Product Category in the Last Year',
    labels={'CategoryName': 'Product Category', 'total_sales': 'Total Sales Revenue'},
    template='plotly'
)

# Display the result to the user
show_to_user(fig)","The provided code correctly implements the business analytic request to calculate the total sales revenue by product category for the last year. It includes appropriate SQL joins and group by clauses to aggregate the total sales revenue for each product category. Also, it creates a bar chart using Plotly to visualize the results and ensures that there are no missing values. The code meets the Python environment constraints by using the utility functions 'execute_sql_query' and 'show_to_user' correctly.",both
Identify suppliers that have not supplied any products in the last year.,"import pandas as pd
import plotly.express as px


def identify_suppliers_no_recent_products():
    # SQL query to identify suppliers that have not supplied any products in the last year
    sql_query = '''
    SELECT suppliers.CompanyName 
    FROM suppliers 
    LEFT JOIN (
        SELECT products.SupplierID, COUNT(*) AS ProductCount 
        FROM products 
        JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
        JOIN orders ON [Order Details].OrderID = orders.OrderID 
        WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
        GROUP BY products.SupplierID
    ) AS recent_products 
    ON suppliers.SupplierID = recent_products.SupplierID 
    WHERE recent_products.ProductCount IS NULL;
    '''
    
    # Execute the SQL query
    result_df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(result_df)
    
    # Optional visualization
    try:
        if not result_df.empty:  # Check if the dataframe is not empty
            fig = px.bar(result_df, x='CompanyName', title='Suppliers with No Products Supplied in the Last Year')
            show_to_user(fig)
    except Exception as e:
        print(f""An error occurred while plotting: {e}"")

# Call the function to execute the code
identify_suppliers_no_recent_products()","from datetime import datetime, timedelta

# Get the current date
current_date = datetime.now()
# Calculate the date one year ago
one_year_ago = current_date - timedelta(days=365)

# SQL query to find suppliers that have not supplied any products in the last year
sql_query = f""""""
SELECT s.SupplierID, s.CompanyName 
FROM suppliers s 
LEFT JOIN products p ON s.SupplierID = p.SupplierID 
LEFT JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID) 
WHERE o.OrderDate < '{one_year_ago.strftime('%Y-%m-%d')}' OR o.OrderDate IS NULL 
GROUP BY s.SupplierID, s.CompanyName
HAVING COUNT(o.OrderID) = 0
""""""

# Execute the SQL query
suppliers_no_products = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(suppliers_no_products)","The input code might incorrectly interpret suppliers who have supplied products more than a year ago as not supplying any products in the last year. The condition 'o.OrderDate < {one_year_ago}' will include any orders before the specific date one year ago, causing incorrect left join behavior and inclusion of wrong suppliers.","
import pandas as pd
import datetime

# Step 1: Determine the date one year ago from today
one_year_ago = datetime.datetime.now() - datetime.timedelta(days=365)

# Step 2: Write the SQL query
query = '''
SELECT CompanyName 
FROM suppliers 
WHERE SupplierID NOT IN (
    SELECT DISTINCT SupplierID 
    FROM products 
    WHERE products.LastSupplierShipDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
);
'''

# Step 3: Execute the SQL query to get the data
suppliers_df = execute_sql_query(query)

# Step 4: Show the result to the user
show_to_user(suppliers_df)
","The input Python code does not correctly identify suppliers that have not supplied any products in the last year. Instead, it checks for suppliers without recent supply records based on `LastSupplierShipDate`, which is not consistent with the reference implementation that checks actual orders placed within the last year.",None
Which products have stock levels below their reorder level?,"import pandas as pd
import plotly.express as px

# Define the SQL query to find products with stock levels below their reorder level
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query and retrieve the data into a pandas dataframe
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)","import pandas as pd

# SQL query to find products with stock levels below their reorder level
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel
""""""

# Execute the SQL query and get the result as a DataFrame
low_stock_products = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(low_stock_products)","The input Python code effectively identifies products with stock levels below their reorder level, executes the required SQL query, retrieves the data into a pandas dataframe using execute_sql_query, and displays the result using show_to_user, matching the intent and function of the reference implementation.","import plotly.express as px

# SQL query to find products with stock levels below their reorder level
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query to retrieve the data
products_below_reorder_level = execute_sql_query(sql_query)

# Display the results using the show_to_user utility
show_to_user(products_below_reorder_level)

# Optionally, create a bar chart to visually represent the data
fig = px.bar(products_below_reorder_level, x='ProductName', y='ProductID', title='Products with Stock Levels Below Reorder Level')
show_to_user(fig)","The input code correctly retrieves products with stock levels below their reorder levels using the specified SQL query. It also displays the results using the show_to_user utility function, as required. Although the code includes an optional bar chart visualization, which the reference code does not, it does not affect the correctness of the implementation as per the business analytic request and environment constraints.",both
How many units of each product are currently on order?,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = 'SELECT ProductName, UnitsOnOrder FROM products;'

# Execute SQL query
products_df = execute_sql_query(sql_query)

# Display dataframe to user
show_to_user(products_df)

# Optional: Visualization (e.g., bar chart)
fig = px.bar(products_df, x='ProductName', y='UnitsOnOrder', title='Units on Order for Each Product')
show_to_user(fig)","import pandas as pd

# SQL query to get the number of units of each product on order
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalUnitsOnOrder
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)","The business analytic request is to find the number of units of each product currently on order, but the evaluated code sums up the quantities from 'Order Details' table rather than directly fetching the 'UnitsOnOrder' from the 'products' table as in the reference implementation. The SQL query in the evaluated code is more complex and unnecessary for this specific request.","import pandas as pd
import plotly.express as px

# SQL Query to fetch product names and units on order
sql_query = 'SELECT ProductName, UnitsOnOrder FROM products;'

# Execute the SQL query and get the result as dataframe
products_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not products_df.empty:
    # Display the fetched data to the user
    display_dataframe(products_df)
    
    # Create a bar chart to visualize units on order for each product
    fig = px.bar(products_df, x='ProductName', y='UnitsOnOrder', title='Units on Order for Each Product')
    
    # Show the bar chart to the user
    show_to_user(fig)
else:
    print('No data available for the given query.')","The input code correctly follows the Python environment constraints. It properly fetches the data using execute_sql_query, checks if the dataframe is not empty, uses plotly for visualization, and then displays the results using show_to_user. The conditional check for an empty dataframe is an addition but does not affect the core functionality.",Finetuned
What is the monthly sales trend for each product over the last year? Please use a data visualization to illustrate the trend.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM') AS Month, 
       SUM([Order Details].Quantity) AS MonthlySales 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderDate >= DATEADD(year, -1, GETDATE()) 
GROUP BY products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM');
'''

# Execute the SQL query and retrieve the data as a pandas dataframe
df = execute_sql_query(sql_query)

# Sort the dataframe by Month for better line plot trends
df.sort_values(by='Month', inplace=True)

# Create a line plot for monthly sales trend for each product
fig = px.line(df, x='Month', y='MonthlySales', color='ProductID', title='Monthly Sales Trend for Each Product')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Calculate the last yearâ€™s date
from datetime import datetime, timedelta
end_date = datetime.now().date()
start_date = end_date - timedelta(days=365)

# SQL query to retrieve monthly sales trend data for each product over the last year
sql_query = f""""""
SELECT 
    p.ProductName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY 
    p.ProductName, Month
ORDER BY 
    Month, p.ProductName;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Check if we received any data
if not sales_data.empty:
    # Create a line plot for each product's sales over the months
    fig = px.line(
        sales_data,
        x='Month',
        y='TotalSales',
        color='ProductName',
        title='Monthly Sales Trend for Each Product Over the Last Year',
        labels={
            'TotalSales': 'Total Sales',
            'Month': 'Month'
        },
        markers=True
    )
    
    # Display the plot to the user
    show_to_user(fig)
else:
    print('No sales data available for the specified period.')","The provided code correctly retrieves data for the monthly sales trend of each product over the last year and visualizes it using a line plot. It follows the Python environment constraint, properly formats the SQL query, processes the data with pandas, and utilizes Plotly for visualization. Additionally, it handles the case where no data is available.","
import pandas as pd
import plotly.express as px

# Define the SQL Query
sql_query = """"""
SELECT p.ProductID, DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY p.ProductID, Month
ORDER BY ProductID, Month;
""""""

# Execute the SQL query
sales_trend_df = execute_sql_query(sql_query)

# Ensure that 'Month' column is treated as datetime for proper plotting
sales_trend_df['Month'] = pd.to_datetime(sales_trend_df['Month'])

# Create a line plot to visualize the monthly sales trend for each product
fig = px.line(sales_trend_df, x='Month', y='TotalQuantity', color='ProductID', title='Monthly Sales Trend per Product Over the Last Year')

# Show the plot to the user
show_to_user(fig)
","The provided Python code correctly implements the requested business analytic. It retrieves the required data from the database for the past year, groups it by product and month, and visualizes the monthly sales trend using a line plot. The logic and the process of data querying, transformation, and visualization align with the reference implementation and meet the specified requirements.",both
Find the average discount provided per order.,"import pandas as pd
import plotly.express as px

# SQL query to find the average discount provided per order.
sql_query = 'SELECT AVG([Order Details].Discount) AS AvgDiscount FROM [Order Details];'

# Execute the SQL query
df = execute_sql_query(sql_query)

# Since we are interested in the average discount, we need to extract that specific value
avg_discount = df['AvgDiscount'][0]

# Create a dataframe to hold the result
result_df = pd.DataFrame({'Metric': ['Average Discount'], 'Value': [avg_discount]})

# Display the results to the user
show_to_user(result_df)
","import pandas as pd

# SQL query to calculate the average discount per order
sql_query = '''
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID
'''

# Execute the SQL query and retrieve the data
average_discount_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_discount_df)","The input code calculates the average discount per order by using group by OrderID and then calculating an average across all the groups, which does not match the business analytic request to find the average discount provided per order. The code should calculate the average discount directly without grouping by OrderID.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG([Order Details].Discount) AS AverageDiscount FROM [Order Details];'

def main():
    # Execute the SQL query to fetch results
    discount_df = execute_sql_query(sql_query)
    
    # Extract the average discount value from the dataframe
    average_discount = discount_df.iloc[0, 0]
    
    # Create a dataframe to display the result
    result_df = pd.DataFrame({'AverageDiscount': [average_discount]})
    
    # Display the result to the user
    show_to_user(result_df)

# Execute the main function
if __name__ == '__main__':
    main()
","The input Python code correctly follows the business analytic request to find the average discount per order and meets the Python environment constraints. It executes an SQL query to obtain the average discount, processes the result into a DataFrame, and displays it using the provided utility functions. The approach and output are consistent with the reference implementation.",Finetuned
What is the average quantity per unit for products supplied by each supplier?,"import pandas as pd
import plotly.express as px

# SQL query to get the average quantity per unit for products supplied by each supplier
sql_query = '''
SELECT s.SupplierID, s.SupplierName, AVG(CAST(p.QuantityPerUnit AS DECIMAL)) AS AverageQuantityPerUnit
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.SupplierName;
'''

# Execute the SQL query and retrieve the data as a pandas dataframe

df = execute_sql_query(sql_query)

# Ensure the column names are adjusted for Plotly, removing any potential leading/trailing spaces
if 'SupplierID' in df.columns and 'SupplierName' in df.columns and 'AverageQuantityPerUnit' in df.columns:
    df = df[['SupplierID', 'SupplierName', 'AverageQuantityPerUnit']]

# Show the data to the user
show_to_user(df)

# Optional: Create a visual representation using plotly
fig = px.bar(df, x='SupplierName', y='AverageQuantityPerUnit', title='Average Quantity Per Unit by Supplier', labels={'SupplierName': 'Supplier Name', 'AverageQuantityPerUnit': 'Average Quantity Per Unit'})

# Show the plotly figure to the user
show_to_user(fig)
","import pandas as pd

# SQL query to calculate the average quantity per unit for each supplier
sql_query = '''
SELECT p.SupplierID, AVG(CAST(SUBSTRING_INDEX(p.QuantityPerUnit, ' ', 1) AS DECIMAL)) AS AverageQuantityPerUnit
FROM products p
GROUP BY p.SupplierID;
'''  

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code does not join tables 'suppliers' and 'products', which means it does not associate products with their suppliers, preventing the calculation of the average quantity per unit for products supplied by each supplier. Additionally, the input code incorrectly handles the 'QuantityPerUnit' field, assuming it always starts with a numeric value.","To compute the average quantity per unit for products supplied by each supplier, you'll want to execute an SQL query to aggregate the data accordingly. Then, you can use the `execute_sql_query` function to get the results and display them using the `show_to_user` function.

Here's the complete code to achieve this:

```python
# Define the SQL query
sql_query = ""SELECT p.SupplierID, AVG(LEN(p.QuantityPerUnit) - LEN(REPLACE(p.QuantityPerUnit, ' ', '')) + 1) AS AverageQuantityPerUnit FROM products p GROUP BY p.SupplierID;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)
```

### Explanation of the SQL Query:
1. `AverageQuantityPerUnit` is computed by evaluating the average number of parts in the `QuantityPerUnit` string across all products from each supplier. This is done by using the string length method to count spaces and derive average counts.

2. `SupplierID` is used to group the results to get average values per supplier. 

### Note:
Before running this code, ensure that `quantityPerUnit` is indeed a text field that denotes different units (like ""12 oz"", ""1 kg"", etc.) and that the logic applied to compute `AverageQuantityPerUnit` fits the data characteristics.

### Assumptions:
- The `QuantityPerUnit` field is formatted in a way that allows for meaningful averaging of quantities per numeric representation.
- Both utility functions `execute_sql_query` and `show_to_user` are available in your execution environment.","The input code does not correctly compute the average quantity per unit as requested. The SQL query provided in the input code is attempting to compute the average by counting the number of parts in the 'QuantityPerUnit' string, which is not a meaningful way to compute the average quantity per unit. The reference implementation correctly casts 'QuantityPerUnit' to a decimal and computes the average over the grouped supplier products, which is the intended calculation.",None
What is the average shipping cost per order for the current year?,"import pandas as pd
import plotly.express as px
from datetime import datetime

def get_average_shipping_cost_current_year():
    current_year = datetime.now().year  # Get the current year
    sql_query = f""""""
        SELECT AVG(orders.Freight) AS shipping_cost_per_order 
        FROM orders 
        WHERE YEAR(orders.OrderDate) = {current_year}
    """"""
    # Execute the SQL query
    result_df = execute_sql_query(sql_query)
    # Display the result to the user
    show_to_user(result_df)

get_average_shipping_cost_current_year()","sql_query = ""SELECT AVG(orders.Freight) AS average_shipping_cost_per_order "" \
             ""FROM orders "" \
             ""WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE())"" \

average_shipping_cost_df = execute_sql_query(sql_query)  
show_to_user(average_shipping_cost_df)","The input code correctly computes the average shipping cost per order for the current year using a SQL query and executes it, then displays the result. It follows the required Python environment constraints by using the provided utility functions execute_sql_query and show_to_user.","import pandas as pd
import plotly.express as px

# SQL query to get the average shipping cost per order for the current year
sql_query = """"""
SELECT AVG(Freight) AS AverageShippingCost 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE())""""""

# Execute the SQL query and retrieve the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)",The input code correctly calculates the average shipping cost per order for the current year and uses the provided utility functions to execute the SQL query and display the result. It adheres to the specified Python environment constraints.,both
Identify the top 3 regions by total sales revenue. Please include a data visualization to illustrate the results.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to retrieve top 3 regions by total sales revenue
sql_query = '''
SELECT 
    customers.Region, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSalesRevenue 
FROM 
    customers 
INNER JOIN 
    orders 
ON 
    customers.CustomerID = orders.CustomerID 
INNER JOIN 
    [Order Details] 
ON 
    orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.Region 
ORDER BY 
    TotalSalesRevenue DESC 
LIMIT 3;
'''

# Execute the SQL query and retrieve the data
regions_sales_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty and has the expected columns
if not regions_sales_df.empty and 'Region' in regions_sales_df.columns and 'TotalSalesRevenue' in regions_sales_df.columns:
    # Creating a bar chart using plotly
    fig = px.bar(regions_sales_df, x='Region', y='TotalSalesRevenue', title='Top 3 Regions by Total Sales Revenue')
    # Display the figure
    show_to_user(fig)
else:
    print('The query did not return the expected data structure.')","import pandas as pd
import plotly.express as px

# SQL query to fetch total sales revenue by region
sql_query = '''
SELECT c.Region, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_revenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
ORDER BY total_revenue DESC
LIMIT 3;
'''  

# Execute SQL query and retrieve the data
region_revenue_df = execute_sql_query(sql_query)

# Data visualization using Plotly
fig = px.bar(region_revenue_df, x='Region', y='total_revenue',
             title='Top 3 Regions by Total Sales Revenue',
             labels={'total_revenue': 'Total Revenue', 'Region': 'Region'})

# Show the result to the user
show_to_user(fig)",The input Python code correctly follows the business analytic request and constraints. It retrieves the top 3 regions by total sales revenue using a valid SQL query and displays the results using a Plotly bar chart. The structure and functionality align with the reference implementation.,"import plotly.express as px

# SQL query to get top 3 regions by total sales revenue
sql_query = '''
SELECT ShipRegion, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ShipRegion
ORDER BY TotalSales DESC
LIMIT 3;
'''

# Execute the SQL query to retrieve the data
data_frame = execute_sql_query(sql_query)

# Create a bar plot to visualize the top 3 regions by total sales
fig = px.bar(data_frame, x='ShipRegion', y='TotalSales', 
             title='Top 3 Regions by Total Sales Revenue', 
             labels={'ShipRegion': 'Region', 'TotalSales': 'Total Sales Revenue'},
             text='TotalSales')

# Show the plot to the user
show_to_user(fig)",The input Python code correctly retrieves the top 3 regions by total sales revenue and visualizes the results using a bar chart with Plotly. It correctly follows the provided Python environment constraints by using the 'execute_sql_query' function to run the SQL query and 'show_to_user' to display the Plotly figure. Minor differences in naming columns or labels do not affect its correctness.,both
How many orders were placed each month? Please include a data visualization to illustrate the trend.,"
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders FROM orders GROUP BY OrderMonth;
""""""

# Execute SQL Query and get the result as pandas dataframe
# Assuming execute_sql_query is defined and returns a pandas dataframe
try:
    df = execute_sql_query(sql_query)
except Exception as e:
    show_to_user(f'Error executing SQL query: {e}')

# Ensure the dataframe is not empty
if df.empty:
    show_to_user('The query returned no results.')
else:
    # Data visualization using plotly
    try:
        fig = px.line(df, x='OrderMonth', y='TotalOrders', title='Total Orders Placed Each Month', labels={'OrderMonth':'Month', 'TotalOrders':'Total Orders'})

        # Display the data visualization
        show_to_user(fig)
    except Exception as e:
        show_to_user(f'Error creating visualization: {e}')
","import pandas as pd
import plotly.express as px

# SQL query to retrieve the count of orders placed each month
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY Month
'''

# Execute the SQL query and retrieve the data
monthly_orders_df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.line(monthly_orders_df, x='Month', y='OrderCount', title='Monthly Orders Count', labels={'OrderCount':'Number of Orders', 'Month':'Month'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly implements the required functionalities: it executes the SQL query to get the monthly order counts, stores the result in a pandas DataFrame, and creates a line chart visualization using Plotly. It also properly uses the 'show_to_user' function to display the visualization. The code effectively addresses the business analytic request and aligns with the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(*) AS OrderCount FROM orders GROUP BY Month;""

# Execute the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Ensure the data is sorted by Month
data['Month'] = pd.to_datetime(data['Month'])
data = data.sort_values(by='Month')

# Create a line chart to visualize the trend
fig = px.line(data, x='Month', y='OrderCount', title='Monthly Order Counts', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})

# Show the data visualization to the user
show_to_user(fig)
","The input Python code correctly executes the SQL query, processes the resulting data, and creates a line chart to visualize the monthly order counts using plotly. It follows the specified Python environment constraints and meets the business analytic request.",both
Which product has the highest cumulative discount in terms of dollar value?,"import pandas as pd
import plotly.express as px

# SQL query to get the product with the highest cumulative discount
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Discount * od.UnitPrice * od.Quantity) AS TotalDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalDiscount DESC
LIMIT 1;
'''

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if dataframe is not empty
if not df.empty:
    # Display the result to the user
    show_to_user(df)

    # Optionally, create a bar chart visualization
    fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Product with Highest Cumulative Discount', labels={'TotalDiscount':'Total Discount ($)', 'ProductName':'Product Name'})
    show_to_user(fig)
else:
    show_to_user('No data available for the given query.')
","import pandas as pd

# SQL query to calculate cumulative discounts for each product
sql_query = '''
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM 
    products p 
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    TotalDiscount DESC
LIMIT 1;
''' 
# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code does not correctly calculate the cumulative discount in dollar value since it only sums the 'Discount * Quantity', whereas it should sum 'Discount * UnitPrice * Quantity'. The missing 'UnitPrice' calculations result in potentially incorrect cumulative discount values.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT o.ProductID, SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDollarValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.ProductID 
ORDER BY TotalDollarValue DESC 
LIMIT 1;''' 

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code to evaluate contains an inconsistency in the SQL query. The 'orders' table should not be used directly to join with the 'Order Details' table. Instead, it should be the 'products' table, matching the reference implementation. Additionally, the 'ProductName' field is missing in the SELECT statement, making it unclear how the output will include the product name. Finally, there's no visualization or proper handling for the scenario where the dataframe is empty.",None
How many different suppliers are there?,"import pandas as pd

# Define the SQL query to count distinct suppliers
sql_query = ""SELECT COUNT(DISTINCT SupplierID) AS SupplierCount FROM products;""

# Execute the SQL query and retrieve the result as a pandas dataframe
# It is assumed that the function execute_sql_query(sql_query) is available in the environment
# which connects to the database and executes the SQL query

df = execute_sql_query(sql_query)

# Extract the count of different suppliers from the dataframe
supplier_count = df['SupplierCount'].iloc[0]

# Format the result as a dataframe for display
result_df = pd.DataFrame({'Total Different Suppliers': [supplier_count]})

# Display the result to the user
# It is assumed that the function show_to_user(data) is available in the environment
# that takes a pandas dataframe or plotly figure and displays it to the user

show_to_user(result_df)","import pandas as pd

# Define SQL query to count distinct suppliers
sql_query = """"""
SELECT COUNT(DISTINCT SupplierID) AS SupplierCount
FROM products
""""""

# Execute the SQL query and retrieve the data
supplier_count_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(supplier_count_df)",The input code does not correctly format the result as per the business analytic request. It directly displays the raw dataframe instead of transforming it to show the count of different suppliers in a more readable format.,"import pandas as pd

# SQL query to get the number of distinct suppliers
sql_query = 'SELECT COUNT(DISTINCT SupplierID) AS NumberOfSuppliers FROM products;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the number of suppliers from the result
number_of_suppliers = result_df.loc[0, 'NumberOfSuppliers']

# Display the number of suppliers to the user
show_to_user(pd.DataFrame({'NumberOfSuppliers': [number_of_suppliers]}))","The provided code accurately follows the business request to count the number of different suppliers. It executes an SQL query to count distinct SupplierID values, retrieves the result as a pandas DataFrame, extracts the count, and displays it using the show_to_user function. Both the structure and logic are consistent with the reference implementation.",Finetuned
What is the correlation between freight cost and fulfillment time? Please include a data visualization to illustrate the correlation.,"import plotly.express as px
import pandas as pd

# Execute the SQL query to retrieve the data
df = execute_sql_query(""SELECT Freight, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders;"")

# Calculate the correlation between Freight and FulfillmentTime
correlation = df['Freight'].corr(df['FulfillmentTime'])

# Print the correlation value
print(f'Correlation between Freight cost and Fulfillment time: {correlation}')

# Create a scatter plot to visualize the correlation
fig = px.scatter(df, x='Freight', y='FulfillmentTime', title='Correlation between Freight cost and Fulfillment time', labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (days)'})

# Show the plot to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Fetch data from the database
query = '''
SELECT 
    Freight, 
    DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
'''  
data = execute_sql_query(query)

# Check if we have data
if not data.empty:
    # Calculate correlation
    correlation = data['Freight'].corr(data['FulfillmentTime'])
    print(f'Correlation between Freight Cost and Fulfillment Time: {correlation}')

    # Create a scatter plot to visualize the correlation
    fig = px.scatter(data, x='Freight', y='FulfillmentTime',
                     title='Correlation between Freight Cost and Fulfillment Time',
                     labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (Days)'}
                    )
    # Show the plot to the user
    show_to_user(fig)
else:
    print('No data found for analysis.')","The provided input code meets the specified business analytic request of calculating and displaying the correlation between freight cost and fulfillment time. It follows the Python environment constraints, uses the 'execute_sql_query' function to retrieve data, calculates the correlation, and visualizes the result using Plotly. The inclusion of an additional check for empty data is a sensible addition, ensuring robustness.","import pandas as pd
import plotly.express as px
from plotly.graph_objects import Figure

# Define the SQL query
sql_query = 'SELECT Freight, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders'

# Execute the SQL query and get the dataframe
result_df = execute_sql_query(sql_query)

# Calculate the correlation coefficient
correlation = result_df['Freight'].corr(result_df['FulfillmentTime'])

# Display the correlation coefficient to the user
show_to_user(pd.DataFrame({'Correlation': [correlation]}))

# Data visualization
fig = px.scatter(result_df, x='Freight', y='FulfillmentTime', title='Correlation between Freight Cost and Fulfillment Time', labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time'})

# Show the plot to the user
show_to_user(fig)","The provided implementation effectively retrieves the required data using an SQL query, calculates the correlation between freight cost and fulfillment time, and visualizes the result using a scatter plot. The functions 'execute_sql_query' and 'show_to_user' are appropriately used according to the Python environment constraints, and the correlation calculation and visualization match the business analytic request.",both
Which employee made the highest sales on a specific date?,"import pandas as pd
import plotly.express as px

# Define the specific date for the analysis
target_date = 'YYYY-MM-DD'

# SQL query to find the employee with the highest sales on the specific date
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate = '{target_date}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the specific date for analysis
date_to_check = '2023-10-01'  # Change this to the desired date

# SQL query to calculate total sales per employee on a specific date
sql_query = f""""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate = '{date_to_check}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","There is a syntax error in the SQL query string definition in the Input Python Code To Evaluate. The opening triple quotes for the SQL query string are not closed properly. Additionally, there is no need for triple quotes for a single-line string. Lastly, there is a missing semicolon at the end of the SQL query string.","import pandas as pd
import plotly.express as px

# Function to get the highest sales by an employee on a specific date

def get_highest_sales_employee_on_date(specific_date):
    # SQL query to find the employee with the highest sales on the specific date
    sql_query = f""""""
    SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalSales 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    JOIN employees ON orders.EmployeeID = employees.EmployeeID 
    WHERE orders.OrderDate = '{specific_date}' 
    GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
    ORDER BY TotalSales DESC 
    LIMIT 1;
    """"""
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    # If the dataframe is not empty, show the result to the user
    if not df.empty:
        show_to_user(df)
        # Optionally, visualize the result using plotly for better understanding
        fig = px.bar(df, x='EmployeeID', y='TotalSales', hover_data=['FirstName', 'LastName'],
                     title=f'Highest Sales by Employee on {specific_date}')
        show_to_user(fig)

# Example usage
specific_date = '2023-09-15'
get_highest_sales_employee_on_date(specific_date)","The input code correctly queries the employee with the highest sales on a specific date and uses the given 'execute_sql_query' and 'show_to_user' functions. Additionally, it provides a visualization using plotly, which is optional but acceptable per the provided constraints.",Finetuned
What is the average unit price of products in each category?,"import pandas as pd
import plotly.express as px

# Define the SQL query to get the average unit price of products in each category
sql_query = 'SELECT CategoryID, AVG(UnitPrice) AS AveragePrice FROM products GROUP BY CategoryID;'

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user in tabular form
show_to_user(df)

# Create a plotly bar chart visualization for the average unit price by category
fig = px.bar(df, x='CategoryID', y='AveragePrice', title='Average Unit Price by Category', labels={'CategoryID':'Category ID', 'AveragePrice':'Average Unit Price'})

# Display the plotly bar chart
show_to_user(fig)","import pandas as pd

# SQL query to calculate average unit price for each category
sql_query = '''
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
'''

# Execute the SQL query and retrieve data into a DataFrame
data = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(data)","The input code doesn't produce a plotly visualization, which is part of the business analytic request. It only displays the data in tabular form, but it does not create and display a plotly bar chart for average unit price by category.","import pandas as pd
import plotly.express as px

# Define the SQL query.
sql_query = 'SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice FROM products GROUP BY CategoryID'

# Execute the SQL query and fetch the results.


def fetch_data_and_visualize():
    # Fetch the data using the provided utility function
    df = execute_sql_query(sql_query)
    
    # Check if dataframe is not empty
    if df.empty:
        print('No data fetched for the given query.')
        return
      
    # Create a bar plot using Plotly
    fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Category', labels={'CategoryID':'Category ID', 'AverageUnitPrice':'Average Unit Price'})
    
    # Display the plot
    show_to_user(fig)

# Execute the function to fetch data and visualize
fetch_data_and_visualize()","The input Python code does not display the data in tabular form before visualizing it, whereas the reference implementation shows the retrieved data in tabular form using the show_to_user function.",None
Which product had the highest sales revenue in 2022? Please include a data visualization to illustrate the sales revenue of top products.,"import plotly.express as px

# SQL query to get the product with the highest sales revenue in 2022
sql_query = '''
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID 
ORDER BY product_sales DESC LIMIT 1
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Extract the ProductID with highest sales
highest_sales_product_id = sales_data['ProductID'].iloc[0]

# Additional query to get the sales data for visualization
sales_query = '''
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID 
ORDER BY product_sales DESC
'''

# Execute the additional query to get sales data for visualization
sales_data_for_viz = execute_sql_query(sales_query)

# Generate the bar plot for sales revenue of top products
fig = px.bar(sales_data_for_viz, x='ProductID', y='product_sales', title='Sales Revenue of Top Products in 2022')

# Show the plot to the user
show_to_user(fig)

# Print the product with the highest sales revenue
show_to_user(f'Product with the highest sales revenue in 2022: {highest_sales_product_id}')","import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue per product in 2022
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales \
FROM [Order Details] \
JOIN orders ON [Order Details].OrderID = orders.OrderID \
JOIN products ON [Order Details].ProductID = products.ProductID \
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' \
GROUP BY products.ProductID, products.ProductName \
ORDER BY total_sales DESC \
LIMIT 10;  
""""""

# Execute SQL query and get the dataframe
sales_data = execute_sql_query(sql_query)

# Identify the product with the highest sales revenue
highest_sales_product = sales_data.iloc[0]

# Prepare data for visualization of top products
fig = px.bar(sales_data, x='ProductName', y='total_sales', \
             title='Top Products by Sales Revenue in 2022', \
             labels={'total_sales': 'Sales Revenue', 'ProductName': 'Products'}, \
             text='total_sales')

# Show the result to the user
show_to_user(fig)

# Display the product with the highest sales revenue
highest_sales_product","The provided code correctly follows the business analytics request to identify the product with the highest sales revenue in 2022. It executes an appropriate SQL query to calculate and retrieve the sales data, identifies the top product by sales, and visualizes the data using a Plotly bar chart. The output format and display functions are used as per the given environment constraints.","To solve the business request of identifying the product with the highest sales revenue in 2022 and visualizing the sales revenue of the top products, we'll need to combine several steps into our Python code.

The SQL query to get the sales revenue data needs to be executed first, followed by data processing and visualization.

Here's the provided Python code to achieve the business analysis request:

```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductName
ORDER BY total_sales DESC
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Ensure sales_data is sorted in descending order and has the highest sales at the top
sales_data_sorted = sales_data.sort_values(by='total_sales', ascending=False)

# Display the product with the highest sales revenue
highest_sales_product = sales_data_sorted.iloc[0]
highest_sales_product_name = highest_sales_product['ProductName']
highest_sales_product_total = highest_sales_product['total_sales']
show_to_user(f'Product with highest sales in 2022: {highest_sales_product_name} with total revenue of {highest_sales_product_total}')

# Data visualization: plot the sales revenue of top products
fig = px.bar(sales_data_sorted, x='ProductName', y='total_sales', title='Top Products by Sales Revenue in 2022')

# Show the plot to the user
show_to_user(fig)
```

### Explanation of the Python Code:

1. **SQL Query Definition**: The SQL query is specified as a multi-line string. It retrieves sales data for products between the dates of 2022, aggregating total sales revenue per product.
  
2. **Execution of the SQL Query**: The `execute_sql_query` function is invoked to execute the query and retrieve results into a pandas DataFrame.

3. **Processing the Data**: The DataFrame is sorted in descending order to ensure the product with the highest sales is at the top.

4. **Display Highest Sales Product**: The highest sales productâ€™s name and total revenue are extracted and displayed using `show_to_user`.

5. **Visualization**: A bar chart is created using `plotly.express` to visualize the sales revenue of the top products.

6. **Show Visualization**: The plot is displayed to the user using `show_to_user`. 

### Note:
Before running the provided code, ensure that you have all dependencies correctly installed and available in your environment","The provided code correctly follows the business analytic request for identifying the product with the highest sales revenue in 2022. The SQL query aggregates total sales per product, and the results are then sorted in descending order to find the top product. It also generates a bar chart using plotly.express to visualize the sales revenue of the top products, and both results are displayed using the show_to_user function.",both
How many orders have been placed by each customer? Please include a data visualization to show the distribution of orders per customer.,"import pandas as pd
import plotly.express as px

# SQL query to get the count of orders placed by each customer
sql_query = 'SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID'

# Execute the query and retrieve the data into a pandas dataframe
df_orders = execute_sql_query(sql_query)

# Data visualization using plotly
fig = px.histogram(df_orders, x='OrderCount', nbins=20, title='Distribution of Orders per Customer', labels={'OrderCount':'Number of Orders'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count orders per customer
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
""""""

# Execute the SQL query and get the data
orders_per_customer = execute_sql_query(sql_query)

# Print the DataFrame (for debugging purposes)
print(orders_per_customer)

# Create a bar chart for the distribution of orders per customer
fig = px.bar(orders_per_customer, x='CustomerID', y='OrderCount',
             title='Number of Orders Placed by Each Customer',
             labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Show the visualization to the user
show_to_user(fig)",The provided code correctly counts the number of orders placed by each customer and visualizes the data using a bar chart with Plotly. It matches the business requirements and uses the provided utility functions correctly.,"import plotly.express as px

# Define the SQL query
sql_query = 'SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID;'

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Generate the distribution plot using plotly
fig = px.histogram(orders_df, x='OrderCount', nbins=20, title='Distribution of Orders per Customer', labels={'OrderCount':'Order Count', 'count':'Frequency'})

# Display the plot
show_to_user(fig)","The input code correctly follows the specified business analytic request and the Python environment constraint. It effectively generates the required data and visualization. The SQL query retrieves the count of orders per customer, and the Plotly library is used correctly to create a histogram to visualize the distribution of order counts per customer. The function 'show_to_user' is used appropriately to display the plot.",both
Which employee generated the most sales in Q4 2023? Please include a data visualization to compare sales generated by all employees.,"import plotly.express as px

# Define the SQL query
sql_query = '''SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 1'''

# Execute the SQL query and get the result as a pandas dataframe
sales_df = execute_sql_query(sql_query)

# Get the top employee who generated the most sales
top_employee_id = sales_df.iloc[0]['EmployeeID']

# Modify the SQL query to get sales data for all employees
all_sales_query = '''SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID
ORDER BY total_sales DESC''' 

# Execute the SQL query and get the result as a pandas dataframe
all_sales_df = execute_sql_query(all_sales_query)

# Create a bar chart to visualize the sales generated by all employees
fig = px.bar(all_sales_df, x='EmployeeID', y='total_sales', title='Total Sales by Employee in Q4 2023', labels={'total_sales': 'Total Sales ($)', 'EmployeeID': 'Employee ID'}, text='total_sales')

# Update layout to enhance visualization
fig.update_layout(xaxis=dict(tickmode='linear'))

# Display the result to the user
show_to_user(fig)

# Also show the top employee ID and their total sales
show_to_user(sales_df)","import pandas as pd
import plotly.express as px

# Define the SQL query to get employee sales in Q4 2023
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
"""""" 

# Execute the SQL query
employee_sales_df = execute_sql_query(sql_query)

# Identify the employee with the most sales
top_employee = employee_sales_df.loc[employee_sales_df['total_sales'].idxmax()]

# Display the employee generating the most sales
print(f""Employee with most sales in Q4 2023: {top_employee['FirstName']} {top_employee['LastName']} with sales of ${top_employee['total_sales']:.2f}."")

# Visualize the sales of all employees
fig = px.bar(employee_sales_df, x='FirstName', y='total_sales',
             title='Sales Generated by Employees in Q4 2023',
             labels={'total_sales': 'Total Sales ($)', 'FirstName': 'Employee First Name'},
             text='total_sales')

# Show the figure to the user
show_to_user(fig)","The input code correctly follows the business analytics request: it identifies the employee with the highest sales in Q4 2023 and visualizes sales for all employees using a bar chart. The SQL queries retrieve the desired data, and the use of the 'execute_sql_query' and 'show_to_user' utility functions aligns with the environment constraints. Additionally, the visualization part uses Plotly, meeting the specified requirements.","import pandas as pd
import plotly.express as px

# Define the SQL query for the specified task
sql_query = '''
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
JOIN employees e ON o.EmployeeID = e.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC;
'''

# Execute the SQL query to get sales data
sales_data = execute_sql_query(sql_query)

# Display the employee who generated the most sales in Q4 2023
display_most_sales_employee_query = sales_data.head(1)
show_to_user(display_most_sales_employee_query)

# Visualize sales data for all employees
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Sales Generated by Employees in Q4 2023')

# Show the visualized plot to the user
show_to_user(fig)","The input Python code correctly follows the specified Python environment constraints and addresses the business analytic request. It executes the necessary SQL query to retrieve sales data for Q4 2023, identifies the employee with the highest sales, and creates a Plotly bar chart to visualize the sales generated by all employees during this period.",both
"What is the maximum, minimum, and average salary of the employees?","import pandas as pd
import plotly.express as px

# SQL query
sql_query = ""SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(result_df)

# Additionally, we can visualize the data using plotly
# Convert the result to a long format for better visualization in plotly
result_long_df = result_df.melt(var_name='Statistic', value_name='Salary')
fig = px.bar(result_long_df, x='Statistic', y='Salary', title='Salary Statistics', labels={'Statistic': 'Statistic', 'Salary': 'Salary'})
show_to_user(fig)","import pandas as pd

# SQL query to get the maximum, minimum, and average salary of the employees
sql_query = """"""
SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary
FROM employees
""""""

# Execute the SQL query
salary_data = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(salary_data)","The provided code correctly executes a SQL query to retrieve the maximum, minimum, and average salaries from the 'employees' table and uses the utility functions 'execute_sql_query' and 'show_to_user' as required by the Python environment constraint. It meets the business analytic request and produces a similar result as the reference code. However, it doesn't include the additional visualization which is not mandatory but is present in the reference implementation.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees;
'''

# Step 2: Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Step 3: Display the results to the user
show_to_user(df)","The input Python code implementation meets the requirements, but it lacks data visualization using plotly as specified in the reference implementation. Visualization is a key part of this task as per the provided specification. To be correct, the code should include converting the result to a long format and creating a bar plot using plotly.",Base
What is the average discount given per order in the last week?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT AVG([Order Details].Discount) AS Average_Discount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 WEEK);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the date range for the last week
today = pd.Timestamp.now()
last_week_start = (today - pd.DateOffset(days=7)).date()
last_week_end = today.date()

# SQL query to calculate the average discount per order in the last week
sql_query = f""""""
SELECT AVG([Order Details].Discount) as AverageDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '{last_week_start}' AND '{last_week_end}'
GROUP BY orders.OrderID
""""""  

# Execute the SQL query and get the data
average_discount_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_discount_df)","The input code has an error in that it groups the results by order, which is not required. The correct query should simply compute the average discount for all orders in the past week without using GROUP BY.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details] WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK);'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the resulting data to the user
show_to_user(result_df)","The input Python code contains an error as it does not join the orders table with the Order Details table, which is necessary to filter the orders by OrderDate in the correct table.",None
What is the average order value for the year 2022?,"import pandas as pd
import plotly.express as px

# SQL query to calculate average order value for the year 2022
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to calculate the Average Order Value for the year 2022
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
""""""

# Execute the SQL query and store the result in a DataFrame
average_order_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_order_value_df)","The input Python code accurately implements the business analytic request by forming a correct SQL query to calculate the average order value for the year 2022, executing the query using the execute_sql_query function, and displaying the result using the show_to_user function. It follows the given Python environment constraints and matches the approach taken in the reference implementation.","import pandas as pd

# SQL Query to get average order value for the year 2022
sql_query = 'SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS avg_order_value FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.OrderDate BETWEEN ""2022-01-01"" AND ""2022-12-31""'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Get the average order value from the dataframe
avg_order_value = result_df['avg_order_value'].iloc[0]

# Convert the result to a dataframe for display
display_df = pd.DataFrame({'avg_order_value': [avg_order_value]})

# Display the average order value to the user
show_to_user(display_df)",The provided Python code correctly calculates and displays the average order value for the year 2022. It follows the given constraints and matches the output of the reference implementation in terms of functionality.,both
How many orders were placed by each customer in the last quarter of 2022? Please include a data visualization to show the orders per customer.,"import pandas as pd
import plotly.express as px

# SQL query to get order count per customer for Q4 2022
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate BETWEEN '2022-10-01' AND '2022-12-31' 
GROUP BY CustomerID
""""""

# Execute SQL query and retrieve the result as a pandas dataframe
order_counts_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the orders per customer
fig = px.bar(order_counts_df, x='CustomerID', y='OrderCount', title='Orders per Customer in Q4 2022')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the date range for the last quarter of 2022
start_date = '2022-10-01'
end_date = '2022-12-31'

# Construct the SQL query to fetch the number of orders for each customer in the last quarter of 2022
sql_query = f""""""
SELECT CustomerID, COUNT(OrderID) as OrderCount
FROM orders
WHERE OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY CustomerID
ORDER BY OrderCount DESC;
""""""  

# Execute the SQL query and retrieve the data
orders_per_customer = execute_sql_query(sql_query)

# Generate a bar chart to visualize the orders per customer
fig = px.bar(orders_per_customer, x='CustomerID', y='OrderCount', title='Orders per Customer in Q4 2022',
             labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Show the visualization to the user
show_to_user(fig)","The code correctly retrieves the number of orders per customer for the last quarter of 2022, and visualizes this information using a Plotly bar chart. It follows the Python environment constraints by utilizing the execute_sql_query and show_to_user functions. Therefore, it meets the specified business analytic request.","Certainly! Below is the Python code that accomplishes the request step by step.

### Python Code

```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the data
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrdersCount 
FROM orders 
WHERE OrderDate BETWEEN '2022-10-01' AND '2022-12-31' 
GROUP BY CustomerID;
'''

# Execute the SQL query and get the data
orders_data = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if orders_data.empty:
    print('No orders data available for the last quarter of 2022.')
else:
    # Create a bar chart visualization
    fig = px.bar(orders_data, x='CustomerID', y='OrdersCount', title='Orders per Customer in Q4 2022', labels={'CustomerID': 'Customer ID', 'OrdersCount': 'Number of Orders'})
    # Show the visualization to the user
    show_to_user(fig)
```

### Explanation
1. **SQL Query Execution**: The provided SQL query is executed using the `execute_sql_query` function to retrieve data on the number of orders per customer in the last quarter of 2022.
2. **Data Checking**: It checks if the resulting DataFrame is non-empty to avoid proceeding with an empty dataset.
3. **Data Visualization**: It uses Plotly Express to create a bar chart depicting the number of orders per customer.
4. **Displaying Result**: Finally, it displays the generated plot using `show_to_user`.

This code should fulfill the given business request comprehensively.","The provided code accurately follows the requirements of the business analytic request. It correctly retrieves the order counts per customer for Q4 2022 using an appropriate SQL query. Additionally, it handles the possibility of an empty dataset and creates a bar chart visualization using Plotly Express, which is then displayed using the show_to_user function. The logic and method of the code match the reference implementation and the Python environment constraints.",both
What is the total quantity of products ordered in each month of the current year? Please include a data visualization to show the quantity ordered per month.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(od.Quantity) AS TotalQuantityOrdered 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY Month;
'''

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Create the data visualization
fig = px.bar(df, x='Month', y='TotalQuantityOrdered', title='Total Quantity of Products Ordered Per Month', labels={'Month': 'Month', 'TotalQuantityOrdered': 'Total Quantity Ordered'})
fig.update_xaxes(type='category')  # Ensure the x-axis is treated as a category

# Show the data visualization to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to get total quantity of products ordered by month for the current year
sql_query = """"""
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(quantity) AS TotalQuantity
FROM
    orders
JOIN
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE
    YEAR(OrderDate) = YEAR(CURDATE())
GROUP BY
    Month
ORDER BY
    Month
""""""

# Fetching data from the database
monthly_orders = execute_sql_query(sql_query)

# Data visualization using Plotly
fig = px.line(monthly_orders, x='Month', y='TotalQuantity', title='Total Quantity of Products Ordered per Month')

# Show results to the user
show_to_user(fig)","The input code implementation mostly correct but uses a line plot (px.line) for visualization instead of a bar plot (px.bar). Since the business request and reference implementation used a bar plot, the input should match that to be considered correct. Additionally, the input code does not ensure the x-axis is treated as a category, which was done in the reference implementation using fig.update_xaxes(type='category').","import pandas as pd
import plotly.express as px

# SQL query to fetch total quantity of products ordered in each month of the current year
sql_query = """"""
SELECT MONTH(o.OrderDate) AS Month, SUM(od.Quantity) AS TotalQuantity 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) 
GROUP BY MONTH(o.OrderDate);""""""

# Execute the SQL query to retrieve the data
order_data = execute_sql_query(sql_query)

# Data visualization using plotly
fig = px.bar(order_data, x='Month', y='TotalQuantity', title='Total Quantity of Products Ordered Per Month', labels={'TotalQuantity': 'Total Quantity', 'Month': 'Month'})

# Display the plotly figure
show_to_user(fig)","The input code correctly retrieves and visualizes the total quantity of products ordered per month for the current year. It adheres to the Python environment constraints, uses the specified utility functions, and the SQL query structure aligns with the reference implementation's intent.",Finetuned
How many orders included products with more than a 10% discount?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT COUNT(DISTINCT od.OrderID) as NumberOfOrders FROM [Order Details] od WHERE od.Discount > 0.10""

# Execute the SQL query
orders_with_discount_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_with_discount_df)","import pandas as pd

# SQL query to fetch Order IDs that have products with more than 10% discount
sql_query = '''
SELECT DISTINCT OrderID
FROM [Order Details]
WHERE Discount > 0.10
'''

# Execute SQL query and store the result in a DataFrame
orders_with_discount = execute_sql_query(sql_query)

# Count the number of unique orders that included products with a discount greater than 10%
count_orders = orders_with_discount['OrderID'].nunique()

# Preparing the result for display
result_df = pd.DataFrame({'Number of Orders with More than 10% Discount': [count_orders]})

# Show the result to the user
show_to_user(result_df)",The input Python code correctly follows the business request to count the number of orders with a product discount greater than 10%. It uses the required utility functions to execute the SQL query and display the result. The logic is correct and the final output is equivalent to the reference implementation.,"import pandas as pd

# SQL query to count orders with products that have more than a 10% discount
sql_query = 'SELECT DISTINCT OrderID FROM [Order Details] WHERE Discount > 0.10'

# Execute the SQL query
order_details_df = execute_sql_query(sql_query)

# Count the distinct OrderIDs
count_orders_with_discount = order_details_df['OrderID'].nunique()

# Create a DataFrame to present the count to the user
result_df = pd.DataFrame({'count_orders_with_discount': [count_orders_with_discount]})

# Display the result to the user
show_to_user(result_df)","The input code correctly initializes an SQL query to get the distinct OrderIDs with more than a 10% discount. It then counts the unique OrderIDs and displays the count using the show_to_user function, which matches the reference implementation in terms of logic and expected output.",both
What is the inventory turnover ratio for the past month?,"import pandas as pd
import plotly.express as px

# SQL query to fetch inventory turnover ratio for the past month
sql_query = '''
SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 MONTH');
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the Inventory Turnover Ratio for the past month
sql_query = '''
SELECT 
    SUM(od.Quantity * od.UnitPrice) AS COGS, 
    AVG(p.UnitsInStock) AS AverageInventory 
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID 
WHERE 
    od.OrderID IN (
        SELECT OrderID 
        FROM orders 
        WHERE OrderDate >= DATEADD(MONTH, -1, GETDATE()) 
    )
'''  

# Execute the SQL query
result = execute_sql_query(sql_query)

# Calculate the Inventory Turnover Ratio
if not result.empty:
    inventory_turnover_ratio = result['COGS'].iloc[0] / result['AverageInventory'].iloc[0]  
else:
    inventory_turnover_ratio = None  

# Show result to the user
show_to_user(pd.DataFrame({'Inventory Turnover Ratio': [inventory_turnover_ratio]}))
","The input code has a key issue in the WHERE clause for date extraction: DATEADD(MONTH, -1, GETDATE()). This approach is SQL Server specific, while the reference implementation leans towards ANSI SQL. Additionally, EXTRACT(MONTH...) aligns better with cross-platform compatibility.","To calculate the inventory turnover ratio for the past month, we need to use the formula:

\[
\text{Inventory Turnover Ratio} = \frac{\text{Cost of Goods Sold (COGS)}}{\text{Average Inventory}}
\]

Let's breakdown the solution into steps:

1. **Extract the COGS for the past month** by summing the `UnitPrice * Quantity` for sold products from `OrderDetails`, joining with `Orders` to filter for the past month using criteria such as `OrderDate` within one month back.

2. **Calculate the Average Inventory** over the past month. We can estimate this using the average of the `UnitsInStock` and `UnitsOnOrder` for each product, or more accurately, by averaging the inventory at the end of each day, for simplicity, we can use a static number from product data.

3. **Compute the Inventory Turnover Ratio** by dividing the COGS by the estimated average inventory.

Now, hereâ€™s the Python code that performs these steps:

```python
import pandas as pd
import plotly.express as px

def calculate_inventory_turnover_ratio():
    # SQL query to get COGS for the past month
    cogs_query = '''
    SELECT SUM(od.UnitPrice * od.Quantity) AS TotalCOGS 
    FROM [Order Details] od 
    JOIN orders o ON od.OrderID = o.OrderID 
    WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
    '''
    cogs_df = execute_sql_query(cogs_query)
    total_cogs = cogs_df.loc[0, 'TotalCOGS'] if not cogs_df.empty else 0

    # SQL query to get average inventory
    avg_inventory_query = '''
    SELECT AVG(p.UnitsInStock + p.UnitsOnOrder) / 2 AS AverageInventory 
    FROM products p;
    '''
    avg_inventory_df = execute_sql_query(avg_inventory_query)
    average_inventory = avg_inventory_df.loc[0, 'AverageInventory'] if not avg_inventory_df.empty else 0

    # Calculate Inventory Turnover Ratio
    inventory_turnover_ratio = total_cogs / average_inventory if average_inventory > 0 else 0

    # Prepare the result for display
    result_df = pd.DataFrame({'Inventory Turnover Ratio': [inventory_turnover_ratio]})
    show_to_user(result_df)
    
    # Optional: Creating a bar plot for better visualization
    fig = px.bar(result_df, x=result_df.index, y='Inventory Turnover Ratio', title='Inventory Turnover Ratio for the Past Month')
    show_to_user(fig)

# Execute the function
calculate_inventory_turnover_ratio()
```

### Key Points in the Code
- The code uses `execute_sql_query` for SQL queries and `show_to_user` for displaying results.
- Care is taken to handle cases where the COGS or average inventory might be zero, preventing division errors.
- Visualization is done using `Plotly` to create an easily interpretable bar chart.","The input Python code correctly calculates the inventory turnover ratio for the past month. The process includes fetching the Cost of Goods Sold (COGS) for the past month and the average inventory. The code then computes the ratio and visualizes it using Plotly. It adheres to the constraints and methods specified, such as using execute_sql_query and show_to_user.",Finetuned
Find the top 3 cities with the most orders placed. Please include a data visualization to show the number of orders per city.,"import plotly.express as px
import pandas as pd

# SQL query to find top 3 cities with the most orders
sql_query = 'SELECT ShipCity, COUNT(*) AS total_orders FROM orders GROUP BY ShipCity ORDER BY total_orders DESC LIMIT 3;'

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Ensure the column names are correct in the dataframe
order_data.columns = ['ShipCity', 'total_orders']

# Data visualization
fig = px.bar(order_data, x='ShipCity', y='total_orders', title='Top 3 Cities with Most Orders', labels={'ShipCity': 'City', 'total_orders': 'Total Orders'})

# Show the data and visualization to the user
show_to_user(fig)

# Display the data in tabular form
show_to_user(order_data)","import pandas as pd
import plotly.express as px

# SQL query to get the count of orders per city
sql_query = '''SELECT c.City, COUNT(o.OrderID) as OrderCount 
           FROM customers c 
           JOIN orders o ON c.CustomerID = o.CustomerID 
           GROUP BY c.City 
           ORDER BY OrderCount DESC 
           LIMIT 3'''  

# Execute the SQL query to retrieve the data
order_counts_df = execute_sql_query(sql_query)

# Visualizing the top 3 cities with the most orders
fig = px.bar(order_counts_df, x='City', y='OrderCount', 
             title='Top 3 Cities with Most Orders', 
             labels={'OrderCount': 'Number of Orders', 'City': 'City'},
             color='OrderCount')

# Show the result to the user
show_to_user(fig)",The input code correctly fetches the top 3 cities with the most orders placed by executing the relevant SQL query. It also properly visualizes the data using Plotly's bar plot and labels the axes appropriately. The use of 'show_to_user' to display the visualization matches the environment constraints.,"import pandas as pd
import plotly.express as px

# SQL query to find the top 3 cities with the most orders placed
sql_query = '''SELECT ShipCity, COUNT(*) AS num_orders FROM orders GROUP BY ShipCity ORDER BY num_orders DESC LIMIT 3;'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Ensure the dataframe is sorted as expected
orders_df = orders_df.sort_values(by='num_orders', ascending=False)

# Create a bar chart to show the number of orders per city
fig = px.bar(orders_df, x='ShipCity', y='num_orders', title='Top 3 Cities with Most Orders', labels={'ShipCity': 'City', 'num_orders': 'Number of Orders'})

# Display the data visualization to the user
show_to_user(fig)","The input Python code correctly meets the business analytic request and follows the Python environment constraints. It correctly performs the SQL query to find the top 3 cities with the most orders, visualizes the result using Plotly, and displays the results using show_to_user function. The overall implementation achieves the intended goal and roughly matches the reference implementation.",both
What is the average shipping cost per order for orders shipped to 'Canada'?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Freight) AS AverageShippingCost FROM orders WHERE ShipCountry = 'Canada';""

# Execute the SQL query to fetch the data
result_df = execute_sql_query(sql_query)

# Ensure the data is a single value dataframe
if not result_df.empty and 'AverageShippingCost' in result_df.columns:
    avg_shipping_cost = result_df['AverageShippingCost'][0]
    print(f""Average Shipping Cost for orders shipped to Canada: {avg_shipping_cost}"")
    # Display the result to the user as a dataframe
    show_to_user(pd.DataFrame({'AverageShippingCost': [avg_shipping_cost]}))
else:
    print(""No data found"")","import pandas as pd

# Define the SQL query to calculate average shipping cost per order for Canada
sql_query = """"""
SELECT AVG(Freight) AS AverageShippingCost
FROM orders
WHERE ShipCountry = 'Canada'
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The provided input code correctly calculates and shows the average shipping cost for orders shipped to Canada. It uses the required `execute_sql_query` utility function to obtain the data and `show_to_user` to display the result. The only difference from the reference implementation is that it directly shows the dataframe which already contains the needed data, thus the implementation is correct and meets the requirements.","import pandas as pd

# SQL query to get the average shipping cost for orders shipped to 'Canada'
sql_query = ""SELECT AVG(Freight) AS AverageShippingCost FROM orders WHERE ShipCountry = 'Canada';""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The evaluated code directly displays the dataframe from the SQL query, which may not ensure that it contains a single value corresponding to the 'AverageShippingCost'. The reference code ensures that the dataframe is a single value before displaying.",Base
What is the retention rate of customers comparing the first half of 2023 to the previous year?,"import plotly.express as px
import pandas as pd

# Query to fetch unique customers count in the first half of 2023
query_2023 = '''SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_2023 
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-06-30' '''

# Query to fetch unique customers count before 2023
query_previous = '''SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_previous 
FROM orders o 
WHERE o.OrderDate < '2023-01-01' '''

# Execute the queries
result_2023 = execute_sql_query(query_2023)
result_previous = execute_sql_query(query_previous)

# Extract counts from the results
customer_count_2023 = result_2023['customer_count_2023'].iloc[0]
customer_count_previous = result_previous['customer_count_previous'].iloc[0]

# Calculate the customer retention rate
if customer_count_previous != 0:  # To avoid division by zero
    customer_retention_rate = customer_count_2023 / customer_count_previous
else:
    customer_retention_rate = 0

# Prepare a DataFrame for visualization
retention_data = pd.DataFrame({
    'Period': ['Before 2023', 'First Half of 2023'],
    'Customer Count': [customer_count_previous, customer_count_2023]
})

# Create a bar plot using plotly
fig = px.bar(retention_data, x='Period', y='Customer Count', title=f'Customer Retention Rate: {customer_retention_rate:.2f}', text='Customer Count')

# Show the plot to the user
show_to_user(fig)","import pandas as pd

# Define the SQL queries for customer retention
query_current_year = '''
SELECT COUNT(DISTINCT CustomerID) AS returning_customers
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
'''  

query_previous_year = '''
SELECT COUNT(DISTINCT CustomerID) AS total_customers
FROM orders
WHERE OrderDate < '2023-01-01'
'''  

# Execute the SQL queries
current_year_df = execute_sql_query(query_current_year)
previous_year_df = execute_sql_query(query_previous_year)

# Extract the values
returning_customers = current_year_df['returning_customers'].values[0]
total_customers = previous_year_df['total_customers'].values[0]

# Calculate retention rate
if total_customers > 0:
    retention_rate = (returning_customers / total_customers) * 100
else:
    retention_rate = 0

# Prepare results for display
result_df = pd.DataFrame({'Metric': ['Retention Rate'], 'Value (%)': [retention_rate]})
show_to_user(result_df)","The evaluated code correctly calculates the retention rate of customers comparing the first half of 2023 to the previous year. The necessary SQL queries to obtain the counts are correct, the retention rate calculation is appropriately handled, and the result is displayed using the show_to_user function. While the exact presentation of the final result differs slightly from the reference implementation, it fulfills the given business analytic request.","To calculate the retention rate of customers comparing the first half of 2023 to the previous year, you'll need to execute SQL queries to derive the required metrics, then perform the necessary calculations in Python. Here's the detailed code implementation:

```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of unique customers in the first half of 2023
query_2023_first_half = '''
SELECT COUNT(DISTINCT CustomerID) AS customer_count
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-06-30';
'''

# SQL query to get the count of unique customers before 2023
query_before_2023 = '''
SELECT COUNT(DISTINCT CustomerID) AS customer_count
FROM orders
WHERE OrderDate < '2023-01-01';
'''

# Execute the queries
customer_count_2023_first_half_df = execute_sql_query(query_2023_first_half)
customer_count_before_2023_df = execute_sql_query(query_before_2023)

# Extract the single values from the dataframes
customer_count_2023_first_half = customer_count_2023_first_half_df.iloc[0]['customer_count']
customer_count_before_2023 = customer_count_before_2023_df.iloc[0]['customer_count']

# Calculate the retention rate
if customer_count_before_2023 == 0:
    retention_rate = 0  # or handle it as you prefer
else:
    retention_rate = (customer_count_2023_first_half / customer_count_before_2023) * 100

# Prepare the result dataframe
result_df = pd.DataFrame({'Retention Rate (%)': [retention_rate]})

# Display the result to the user
show_to_user(result_df)

# Optional: Visualization
fig = px.bar(result_df, x=['Retention Rate (%)'], y='Retention Rate (%)', title='Customer Retention Rate Comparison')
show_to_user(fig)
``` 

### Explanation:
1. **SQL Queries**: Two SQL queries calculate the number of unique customers for the specified periods. One for the first half of 2023 and the other for before 2023.

2. **Execute SQL Queries**: The queries are executed using the provided `execute_sql_query` function, retrieving the results as pandas dataframes.

3. **Data Extraction**: The code extracts the count of unique customers from the resulting dataframes.

4. **Retention Rate Calculation**: The retention rate is calculated by dividing the number of customers in the first half of 2023 by the number before 2023, multiplied by 100. If there were no customers before 2023, the retention rate will be set to zero.

5. **Display Results**: The computed retention rate is presented in a dataframe.

6. **Optional Visualization**: A bar chart is created and displayed using Plotly for better visualization of the retention rate. 

Make sure to adjust the code to fit your environment if your data or tools differ.","The input Python code correctly fetches the unique customer counts for the first half of 2023 and the period before 2023, calculates the retention rate, displays it, and optionally visualizes it. The logic aligns with the business request and is consistent with the reference implementation.",both
How many distinct products have been ordered?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(DISTINCT ProductID) AS DistinctProducts FROM [Order Details]'

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(result_df)","import pandas as pd

# SQL query to count distinct products ordered
sql_query = """"""
SELECT COUNT(DISTINCT ProductID) as DistinctProductCount
FROM [Order Details]
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The given code correctly follows the Python environment constraint. It uses the execute_sql_query function to retrieve data by executing a SQL query that counts distinct ProductID from the [Order Details] table. The result is then displayed to the user using the show_to_user function, consistent with the reference implementation.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(DISTINCT ProductID) AS DistinctProducts FROM [Order Details];'

# Execute the SQL query and fetch the result into a pandas dataframe
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result)",The input Python code correctly executes the SQL query to count the distinct ProductIDs and displays the result using the provided utility functions. It adheres to the specified business analytic request and matches the reference implementation.,both
How many orders were placed each month by each customer? Please include a data visualization to show monthly orders per customer.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT c.CustomerID, DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth, COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID, OrderMonth;'''

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Generate the plot
fig = px.bar(orders_data, x='OrderMonth', y='OrderCount', color='CustomerID', 
             labels={'OrderMonth':'Order Month', 'OrderCount':'Number of Orders', 'CustomerID':'Customer ID'},
             title='Monthly Orders per Customer')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the number of orders placed each month by each customer
sql_query = '''
SELECT 
    c.CustomerID,
    c.CompanyName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
    COUNT(o.OrderID) AS OrderCount
FROM 
    orders o
JOIN 
    customers c ON o.CustomerID = c.CustomerID
GROUP BY 
    c.CustomerID, 
    OrderMonth
ORDER BY 
    c.CustomerID, 
    OrderMonth;
'''

# Execute SQL query and retrieve data
order_data = execute_sql_query(sql_query)

# Data Visualization: Monthly orders per customer
fig = px.bar(
    order_data,
    x='OrderMonth',
    y='OrderCount',
    color='CompanyName',
    title='Monthly Orders per Customer',
    labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'},
    barmode='group'
)

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly executes an SQL query to retrieve the number of orders placed each month by each customer. It then generates a bar plot using Plotly to visualize the data, grouped by 'CompanyName' instead of 'CustomerID', and shows it to the user. While there is a slight difference in the GROUP BY clause and the labels used in the plot, the implementation still fulfills the main business analytic request of showing monthly orders per customer.","Sure! Below is the Python code that executes the SQL query to retrieve the number of orders placed each month by each customer, and then creates a data visualization using Plotly.

```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT YEAR(OrderDate) AS OrderYear, MONTH(OrderDate) AS OrderMonth, 
       CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY YEAR(OrderDate), MONTH(OrderDate), CustomerID 
ORDER BY OrderYear ASC, OrderMonth ASC;
'''

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Create a new 'YearMonth' column to facilitate grouping and sorting
order_data['YearMonth'] = order_data['OrderYear'].astype(str) + '-' + order_data['OrderMonth'].astype(str).str.zfill(2)

# Data visualization using Plotly
fig = px.line(order_data, x='YearMonth', y='OrderCount', color='CustomerID', title='Monthly Orders per Customer')

# Display the visualization
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: The query retrieves the year, month, customer ID, and the count of orders, while grouping by the year, month, and customer ID to get the order count for each customer per month.

2. **Execute SQL Query**: The `execute_sql_query` function retrieves the data as a pandas DataFrame.

3. **Data Manipulation**: The column `YearMonth` is created to facilitate chronological sorting and better visualization.

4. **Data Visualization**: A line plot is created using `plotly.express` where the x-axis represents the 'YearMonth', the y-axis represents 'OrderCount', and each customer's data is differentiated by color.

5. **Display the Visualization**: The `show_to_user` function displays the generated plot to the user.","The input code does not group the data by CustomerID and month correctly because it only uses YEAR and MONTH functions separately instead of using DATE_FORMAT to get 'YYYY-MM' format directly, which could cause formatting and sorting issues. Additionally, it uses a line plot, which is less suitable for categorical data like months; a bar plot would be a better choice as per the business request and the reference implementation.",Base
What is the hire date of the oldest employee?,"import pandas as pd
import plotly.express as px

# SQL Query to find the hire date of the oldest employee
sql_query = 'SELECT e.FirstName, e.LastName, e.HireDate FROM employees e ORDER BY e.HireDate ASC LIMIT 1'

# Execute the SQL query using the provided utility function
employee_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(employee_df)","import pandas as pd

# SQL query to find the hire date of the oldest employee
sql_query = '''
SELECT HireDate 
FROM employees 
ORDER BY BirthDate ASC 
LIMIT 1
'''  

# Execute the SQL query and retrieve the data
oldest_employee_hire_date = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(oldest_employee_hire_date)","The input Python code sorts by 'BirthDate' instead of 'HireDate' and retrieves only the 'HireDate' column. To find the hire date of the oldest employee, it should sort by HireDate and can include other relevant details (like FirstName and LastName) for better clarity, as shown in the reference implementation.","import pandas as pd

# Define the SQL query to get the hire date of the oldest employee
sql_query = '''
SELECT hire_date 
FROM employees 
ORDER BY birth_date LIMIT 1;
'''

# Execute the SQL query and get the result as a dataframe
df = execute_sql_query(sql_query)

# Extract the hire date
if not df.empty:
    hire_date_of_oldest_employee = df.iloc[0]['hire_date']
    hire_date_df = pd.DataFrame({'Hire Date of Oldest Employee': [hire_date_of_oldest_employee]})
    show_to_user(hire_date_df)
else:
    print('No data available to retrieve hire date.')",The input code is incorrect because it orders by 'birth_date' instead of 'hire_date'. It should order by 'hire_date' to find the oldest employee's hire date as per the request and the reference implementation.,None
How many order details entries have a discount greater than 10%?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(*) AS order_details_count FROM [Order Details] WHERE Discount > 0.1;'

# Execute the SQL query to get the data
order_details_df = execute_sql_query(sql_query)

# Display the count to the user
show_to_user(order_details_df)","import pandas as pd

# SQL query to count order details with discounts greater than 10%
sql_query = """"""
SELECT COUNT(*) AS DiscountedOrderDetails
FROM [Order Details]
WHERE Discount > 0.10
""""""

# Execute the SQL query and get the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code to evaluate correctly implements the SQL query to count order details with a discount greater than 10%, executes the query, retrieves the result in a DataFrame, and then displays it to the user. The logic and flow match the reference implementation accurately.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS DiscountedOrders FROM `Order Details` WHERE Discount > 0.10;""

# Execute the query to get the DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code achieves the objective of the business analytic request, following the environment constraints and doing so in a functionally similar way to the reference implementation. The SQL query and the subsequent function calls provide the correct discount filtering and produce the count of order details with a discount greater than 10%.",both
Which supplier has the highest average lead time?,"import pandas as pd
import plotly.express as px

# SQL query to find the supplier with the highest average lead time
sql_query = '''
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY s.CompanyName 
ORDER BY AverageLeadTime DESC 
LIMIT 1;
'''

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Check if there is a result returned and visualize the data
if not results_df.empty:
    fig = px.bar(results_df, x='CompanyName', y='AverageLeadTime', title='Supplier with the Highest Average Lead Time')
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Error': ['No results returned by the query']}))","import pandas as pd

# SQL query to calculate average lead time per supplier
sql_query = '''
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID = o.OrderID
GROUP BY s.SupplierID
ORDER BY AverageLeadTime DESC
LIMIT 1;
'''  

# Execute the SQL query and retrieve the result
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code has two issues. Firstly, the JOIN operation on orders is incorrect, it should join with 'Order Details' as in the reference code. Secondly, the GROUP BY clause should group by s.CompanyName instead of s.SupplierID to correctly calculate the average lead time per supplier.","import pandas as pd
import plotly.express as px

# SQL query to get supplier with the highest average lead time
sql_query = '''
SELECT suppliers.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID 
ORDER BY AverageLeadTime DESC 
LIMIT 1
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The evaluated code correctly identifies the supplier with the highest average lead time but it does not create a meaningful visualization of the result using plotly like the reference code does.,None
Identify employees whose orders had the highest average discount applied. Please include a data visualization to compare the average discounts by employees.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY AvgDiscount DESC;
'''

# Execute the SQL query and fetch the dataframe
employee_discounts_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discounts by employees
fig = px.bar(employee_discounts_df, x='EmployeeID', y='AvgDiscount', title='Average Discounts by Employees', labels={'EmployeeID': 'Employee ID', 'AvgDiscount': 'Average Discount'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Retrieve data from the database using SQL to calculate average discounts per employee.
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY AverageDiscount DESC;
'''

average_discount_df = execute_sql_query(sql_query)

# Step 2: Show the employee(s) with the highest average discount.
highest_discount_employee = average_discount_df.iloc[0]
show_to_user(highest_discount_employee)

# Step 3: Visualization of the average discounts by employees.
fig = px.bar(average_discount_df, x='FirstName', y='AverageDiscount',
             title='Average Discount by Employee',
             labels={'FirstName': 'Employee First Name', 'AverageDiscount': 'Average Discount'},
             text='AverageDiscount')
fig.update_traces(texttemplate='%%{text:.2f}', textposition='outside')
show_to_user(fig)","The input Python code implementation correctly follows the business analytic request. It retrieves the necessary data using SQL, calculates the average discounts per employee, identifies the employee with the highest average discount, and provides a bar chart visualization of the average discounts by employees. The inclusion of the employee's first name and last name in the SQL query enhances the readability of the results.","import pandas as pd
import plotly.express as px

# SQL query to get employees and their average discount
sql_query = '''
SELECT employees.EmployeeID, AVG([Order Details].Discount) AS AvgDiscount 
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
GROUP BY employees.EmployeeID
ORDER BY AvgDiscount DESC
LIMIT 5;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discounts by employee
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', 
             title='Top 5 Employees with Highest Average Discount', 
             labels={'EmployeeID': 'Employee ID', 'AvgDiscount': 'Average Discount'})

# Display the data visualization
show_to_user(fig)
","The input code correctly performs the task as described in the business analytic request. It queries the database to retrieve the average discount data for employees, creates a bar chart using plotly to visualize the average discounts by employee, and then displays the chart. The code follows the Python environment constraint and the logic aligns with the reference implementation.",both
What is the average unit price of products within each category?,"import pandas as pd
import plotly.express as px

def get_average_unit_price_per_category():
    sql_query = 'SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice FROM products GROUP BY CategoryID;'
    df = execute_sql_query(sql_query)
    show_to_user(df)
    
    # Optional: visualize the data
    fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price per Category')
    show_to_user(fig)
    
get_average_unit_price_per_category()","import pandas as pd

# Define the SQL query to get the average unit price of products by category
sql_query = '''
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
WHERE p.Discontinued = 0
GROUP BY p.CategoryID
'''  

# Execute the SQL query and retrieve data into a pandas DataFrame
average_price_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_price_df)","The input Python code correctly implements the business analytic request by calculating the average unit price of products within each category. The SQL query retrieves the CategoryID and the average UnitPrice from the products table, filtering out discontinued products. The results are then displayed to the user using the provided utility functions. The optional visualization step is not included in the input code, but it is not a requirement for correctness.","import pandas as pd
import plotly.express as px

# SQL query to retrieve the data
df = execute_sql_query('SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice FROM products GROUP BY CategoryID;')

# Display the data to the user
show_to_user(df)

# Create a bar chart to visually represent the average unit price per category
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Category', labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'}, height=400)

# Show the bar chart to the user
show_to_user(fig)","The provided code retrieves the average unit price per category using the specified SQL query and displays the resulting DataFrame. It also creates and displays a bar chart using Plotly, which fulfills the business analytic request and matches the functionality of the reference implementation.",both
List the employees who have never made a sale.,"import pandas as pd
import plotly.express as px

# SQL query to list employees who have never made a sale
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL
'''

# Execute the SQL query using the utility function
employees_never_made_sale_df = execute_sql_query(sql_query)

# Show the resulting dataframe to the user
show_to_user(employees_never_made_sale_df)","query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL;
'''  

# Execute the SQL query to get the employees who have never made a sale.
result_df = execute_sql_query(query)  

# Display the result to the user.
show_to_user(result_df)","The input Python code correctly retrieves and displays employees who have never made a sale. It follows the environment constraints, accurately matches the business request, and closely aligns with the reference implementation's output.","
import pandas as pd

# Define the SQL query
def query_employees_without_sales():
    sql_query = '''
    SELECT e.EmployeeID, e.FirstName, e.LastName 
    FROM employees e 
    LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
    WHERE o.OrderID IS NULL;
    '''
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    return df

# Retrieve the data
employees_without_sales = query_employees_without_sales()

# Display the data to the user
show_to_user(employees_without_sales)
",The input Python code correctly performs the task of listing employees who have never made a sale. It defines and executes the proper SQL query and uses the provided utility functions `execute_sql_query` and `show_to_user` as specified. The functionality and output will match the reference implementation.,both
How many orders were shipped but not yet delivered?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT OrderID FROM orders WHERE ShippedDate IS NOT NULL AND RequiredDate IS NULL;'

# Execute the SQL query to retrieve the data
orders_df = execute_sql_query(sql_query)

# Analyze the data: Count the number of orders shipped but not yet delivered
shipped_not_delivered_count = orders_df.shape[0]

# Prepare the results for display
results_df = pd.DataFrame({'Shipped But Not Delivered Orders': [shipped_not_delivered_count]})

# Display the results to the user
show_to_user(results_df)
","import pandas as pd

# SQL query to find the number of orders that were shipped but not yet delivered
sql_query = """"""
SELECT COUNT(*) AS Orders_Shipped_Not_Delivered
FROM orders
WHERE ShippedDate IS NOT NULL AND (RequiredDate > CURRENT_DATE OR RequiredDate IS NULL)
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code incorrectly uses the condition 'RequiredDate > CURRENT_DATE OR RequiredDate IS NULL' in the SQL query instead of just 'RequiredDate IS NULL'. It also returns the count directly from SQL as a single value instead of a DataFrame with the count, which results in a different format of the output compared to the reference implementation.","import pandas as pd

# Define SQL query
sql_query = ""SELECT o.OrderID FROM orders o WHERE o.ShippedDate IS NOT NULL AND o.RequiredDate IS NULL;""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Count the number of orders shipped but not yet delivered
num_orders_not_delivered = orders_df.shape[0]

# Prepare the result DataFrame for visualization
result_df = pd.DataFrame({'Number of Orders Not Delivered': [num_orders_not_delivered]})

# Display the result to user
show_to_user(result_df)","The input code correctly implements the specified business analytic request. It follows the Python environment constraints, executes the appropriate SQL query, counts the number of orders shipped but not yet delivered, and displays the results using the utility function provided.",Finetuned
Which orders have the highest discounts applied?,"import pandas as pd
import plotly.express as px

# SQL Query to retrieve the highest discounts on orders
sql_query = '''
SELECT orders.OrderID, MAX([Order Details].Discount) AS MaxDiscount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY orders.OrderID 
ORDER BY MaxDiscount DESC 
LIMIT 1;
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(result_df)","import pandas as pd

# SQL query to find orders with the highest discounts applied
sql_query = '''
SELECT o.OrderID, SUM(od.Discount) as TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderID
ORDER BY TotalDiscount DESC
'''

# Execute the SQL query and retrieve the data
discounted_orders = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discounted_orders)","The input code aggregates the total discount per order and sorts by total discount. However, the business analytic request specifically asks for which orders have the highest discounts applied, which implies finding the maximum single discount per order, not summing all discounts per order.","import pandas as pd
import plotly.express as px

# SQL query to get the orders with the highest discounts
sql_query = ""SELECT * FROM [Order Details] ORDER BY Discount DESC;""

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(orders_df)

# If we want to visualize the orders with the highest discounts
fig = px.bar(orders_df, x='OrderID', y='Discount', title='Orders with Highest Discounts', labels={'OrderID': 'Order ID', 'Discount': 'Discount Amount'})
show_to_user(fig)","The input code sorts all records from [Order Details] by Discount in descending order and retrieves them all. This does not match the business request to identify the order with the highest discount, which is correctly performed by the reference implementation. The reference SQL query specifically captures the highest discount per order and correctly groups and limits the results.",None
What is the average time taken to ship an order?,"import pandas as pd
import plotly.express as px

# The given SQL query to get the average shipping time
sql_query = 'SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) as AverageShippingTime FROM orders;'

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Visualize the result in a bar chart using plotly
# Since result_df will only contain one row with one column, we need to create a dict to display correctly
fig = px.bar(x=['AverageShippingTime'], y=[result_df.iloc[0]['AverageShippingTime']], labels={'x':'Metric', 'y':'Time in Days'}, title='Average Shipping Time for Orders')

# Display the result to the user
show_to_user(fig)","import pandas as pd

# SQL query to calculate the average shipping time for orders
sql_query = '''
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime
FROM orders
WHERE ShippedDate IS NOT NULL;
'''

# Execute the SQL query and retrieve the data
average_shipping_time_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_shipping_time_df)","The input code does correctly compute the average shipping time and display it to the user using the show_to_user function. However, it does not provide a visual representation of the data using plotly as required. The reference implementation visualizes the result in a bar chart, which is missing in the input code.","import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime FROM orders;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average shipping time
average_shipping_time = result_df['AvgShippingTime'].iloc[0]  # Assuming it's in a DataFrame and single value extraction

# Convert to a DataFrame for display purposes
average_shipping_time_df = pd.DataFrame({'Average Shipping Time': [average_shipping_time]})

# Display the result to the user
show_to_user(average_shipping_time_df)","The provided input code correctly forms and executes the SQL query to calculate the average shipping time. It retrieves this value from the resulting dataframe and converts it into a new dataframe for display purposes. While the reference implementation uses Plotly for visualization, the input code accomplishes the task by properly displaying the average shipping time using a dataframe, thereby meeting the business analytic request.",Finetuned
List the top 5 products by sales for Q2 2023 with a visualization of their respective sales figures.,"import plotly.express as px
import pandas as pd

# Utility function to execute SQL query
sql_query = '''
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY products.ProductID
ORDER BY total_sales DESC
LIMIT 5
'''

top_products_df = execute_sql_query(sql_query)

# Check if top_products_df is not empty
if not top_products_df.empty:
    # Create a bar plot for the top 5 products by sales
    fig = px.bar(top_products_df, x='ProductID', y='total_sales', 
                 title='Top 5 Products by Sales for Q2 2023', 
                 labels={'ProductID':'Product ID', 'total_sales':'Total Sales ($)'})

    # Show the visualization to the user
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Message': ['No data available for Q2 2023']}))","import pandas as pd
import plotly.express as px

# Define the SQL query to get the top 5 products by sales for Q2 2023
query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 5
'''  

# Execute the SQL query
results_df = execute_sql_query(query)

# Create a bar chart to visualize the sales figures
fig = px.bar(results_df, x='ProductName', y='total_sales', title='Top 5 Products by Sales for Q2 2023', labels={'total_sales': 'Total Sales', 'ProductName': 'Product Name'})

# Show the results to the user
show_to_user(fig)","The input Python code correctly implements the business analytic request. It executes the necessary SQL query, retrieves the top 5 products by sales for Q2 2023, and visualizes the sales figures in a bar chart using Plotly. Both the product ID and product name are utilized appropriately in the query and visualization, which is in line with the business requirement.","Here's a step-by-step breakdown of the Python code necessary to accomplish the task:

1. Import necessary libraries.
2. Execute the SQL query to retrieve the top 5 products by sales for Q2 2023.
3. Analyze the data to get sales figures for these products.
4. Create a visualization of the sales figures.
5. Display the result to the user.

Here is the complete code:

```python
# Import necessary libraries
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY p.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5
'''

# Execute the SQL query
sales_data_df = execute_sql_query(sql_query)

# Ensure the data is sorted by TotalSales in descending order
sales_data_df = sales_data_df.sort_values(by='TotalSales', ascending=False)

# Create the visualization using plotly
fig = px.bar(sales_data_df, x='ProductName', y='TotalSales', title='Top 5 Products by Sales for Q2 2023')

# Display the result to the user
show_to_user(fig)
```

### Explanation:
1. The `sql_query` retrieves the top 5 products by sales volume within the specified date range.
2. The sales data is executed and stored in `sales_data_df`.
3. Sales data is sorted in descending order to ensure the top 5 products are identified correctly.
4. A bar chart is created with Plotly to visualize the products and their respective sales figures.
5. Finally, the visualization is displayed to the user.","The evaluated Python code correctly follows the business analytics request. It retrieves the top 5 products by sales for Q2 2023 using an SQL query, sorts the data by TotalSales in descending order, creates a bar chart visualization using Plotly, and displays the result to the user using the provided utility function. The code makes appropriate use of the `execute_sql_query` and `show_to_user` functions in compliance with the specified Python environment constraints.",both
Which products from each supplier have not been discontinued?,"import pandas as pd
import plotly.express as px

# SQL query to fetch products from each supplier that have not been discontinued
sql_query = '''
SELECT suppliers.CompanyName, products.ProductName 
FROM suppliers 
INNER JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 0;
'''

# Execute SQL query
df = execute_sql_query(sql_query)

# Displaying the result directly to the user with show_to_user
def show_to_user(df):
    print(df)
show_to_user(df)
","sql_query = '''
SELECT s.SupplierID, s.CompanyName, p.ProductID, p.ProductName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.Discontinued = 0
ORDER BY s.SupplierID, p.ProductID; 
''' 

# Execute the SQL query and retrieve the data 
result_df = execute_sql_query(sql_query) 

# Show the result to the user 
show_to_user(result_df)","The input code correctly fetches products from each supplier that have not been discontinued. It includes the necessary columns, joins the suppliers and products tables on SupplierID, applies the filtering condition for discontinued products, and orders the result by SupplierID and ProductID. Additionally, it uses the execute_sql_query and show_to_user functions as required by the environment constraints.","import pandas as pd
import plotly.express as px

# Define the SQL Query
sql_query = 'SELECT SupplierID, ProductName FROM products WHERE Discontinued = 0;'

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(products_df)","The input Python code does not fully match the reference implementation. Specifically, the input code does not join the 'suppliers' table with 'products' to get the 'CompanyName'. The expected result should include both CompanyName from 'suppliers' and ProductName from 'products'.",Base
What is the total number of orders where the quantity ordered exceeded 50 units in 2023?,import pandas as pd\n\n# Define the SQL query\nsql_query = '''\nSELECT COUNT(orders.OrderID) AS large_orders \nFROM [Order Details] \nJOIN orders ON [Order Details].OrderID = orders.OrderID \nWHERE [Order Details].Quantity > 50 \nAND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'\n'''\n\n# Execute the SQL query and get the result in a pandas dataframe\ndf = execute_sql_query(sql_query)\n\n# Extract the count of large orders from the dataframe\nlarge_orders = df['large_orders'][0] if not df.empty else 0\n\n# Display the result to the user\nshow_to_user(pd.DataFrame({'large_orders': [large_orders]})),"import pandas as pd

# SQL query to count the total number of orders with quantity exceeded 50 in 2023
total_orders_sql = """"""
SELECT COUNT(orders.OrderID) AS total_orders
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE [Order Details].Quantity > 50
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and store the result in a DataFrame
total_orders_df = execute_sql_query(total_orders_sql)

# Show the result to the user
show_to_user(total_orders_df)","The input code correctly counts the total number of orders with quantity exceeding 50 in 2023. The SQL query properly joins the 'orders' and 'Order Details' tables, filters on the quantity and date range, and uses COUNT to get the total orders. It then correctly executes the SQL query and displays the result using the provided utility functions.","import pandas as pd
from datetime import datetime

# Define the SQL query based on the given business requirement
sql_query = """"""
SELECT COUNT(OrderID) AS HighQuantityOrders
FROM orders
WHERE YEAR(OrderDate) = 2023
AND Quantity > 50;
""""""

# Execute the SQL query to retrieve the necessary data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code incorrectly applies the condition on the 'Quantity' column directly in the 'orders' table, whereas the condition should be applied on the 'Quantity' in the '[Order Details]' table. Moreover, the JOIN operation between orders and order details is missing.",Base
What is the average quantity of products ordered per order?,"import pandas as pd
import plotly.express as px

# SQL Query to get the average quantity of products ordered per order
sql_query = ""SELECT AVG([Order Details].Quantity) AS AverageQuantity FROM [Order Details]""

# Execute the SQL Query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the average quantity of products ordered per order
sql_query = '''
SELECT AVG(total_quantity) AS average_quantity_per_order
FROM (
    SELECT orders.OrderID, SUM([Order Details].Quantity) AS total_quantity
    FROM orders
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
    GROUP BY orders.OrderID
) AS order_totals;
'''

# Execute SQL query and retrieve data
average_quantity_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(average_quantity_df)","The input Python code correctly implements the business analytic request. The SQL query calculates the average quantity of products ordered per order by first summing the quantities per order and then averaging these sums. This follows the correct logic as specified in the reference implementation. Additionally, the 'execute_sql_query' and 'show_to_user' functions are used appropriately as required by the environment constraints.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the average quantity of products ordered per order
sql_query = 'SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average quantity from the result
average_quantity = result_df['AverageQuantity'][0]

# Display the average quantity to the user
show_to_user(pd.DataFrame({'Average Quantity': [average_quantity]}))","The input code correctly implements the logic to calculate the average quantity of products ordered per order. It uses an SQL query to get the average, executes the query, extracts the result, and then displays it to the user. This approach aligns with the reference implementation and follows the Python environment constraints.",both
What is the performance of each product based on sales quantities in Q1 2023 with a visualization comparing sales quantities?,"import pandas as pd
import plotly.express as px

# SQL query based on the business requirements
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS product_performance
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID
'''

# Executing the SQL query
df = execute_sql_query(sql_query)

# Generating the bar plot for product performance
fig = px.bar(df, x='ProductID', y='product_performance', title='Product Performance in Q1 2023', labels={'ProductID': 'Product ID', 'product_performance': 'Sales Quantity'})

# Displaying the visualization
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve product performance data for Q1 2023
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS sales_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
'''  

# Execute the SQL query
product_performance_df = execute_sql_query(sql_query)

# Visualize the sales quantities using a bar chart
fig = px.bar(product_performance_df, x='ProductName', y='sales_quantity', title='Product Sales Quantities in Q1 2023')
show_to_user(fig)","The provided input code correctly executes an SQL query to retrieve product performance data for Q1 2023 and then creates a bar visualization using plotly, which aligns with the business analytic request. The inclusion of ProductName in the output bar chart is an acceptable enhancement that provides more detailed information in the visualization.","import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS product_performance 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY products.ProductID 
ORDER BY product_performance DESC
'''

# Execute the SQL query and get the result
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize product performance based on sales quantities
fig = px.bar(sales_data, x='ProductID', y='product_performance', 
             title='Product Performance Based on Sales Quantities in Q1 2023',
             labels={'ProductID': 'Product ID', 'product_performance': 'Sales Quantities'})

# Show the visualization to the user
show_to_user(fig)","The input Python code fulfills the business analytic request by querying the sales quantities of each product for Q1 2023 and visualizing the data using a bar chart. It also matches the reference implementation closely, including appropriate use of SQL joins, date filtering, and aggregation. The addition of ordering by 'product_performance' in the SQL query is acceptable as it does not affect the correctness of the output. Therefore, the input code is considered correct.",both
Find the top 5 customers by the number of orders placed with a visualization of the number of orders per customer.,"import plotly.express as px
import pandas as pd

# SQL Query to get the top 5 customers by the number of orders placed
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the result_df has the correct columns
result_df.columns = ['CustomerID', 'OrderCount']

# Visualize the number of orders per customer
fig = px.bar(result_df, x='CustomerID', y='OrderCount', 
             title='Top 5 Customers by Number of Orders', 
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the top 5 customers by the number of orders
sql_query = '''
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) as OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderCount DESC
LIMIT 5;
'''  

# Execute the SQL query to retrieve data
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per customer
fig = px.bar(top_customers_df, x='CompanyName', y='OrderCount',
             title='Top 5 Customers by Number of Orders',
             labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer Company Name'},
             color='OrderCount')

# Display the visualization to the user
show_to_user(fig)","The provided Python code correctly executes an SQL query to find the top 5 customers by the number of orders, including relevant customer information (CustomerID and CompanyName). It then creates a bar chart using plotly to visualize this data, which is shown to the user using the show_to_user function. Although it includes additional customer information (CompanyName) and uses a different color aesthetic for visualization, these differences do not impact the correctness of the code in fulfilling the business analytic request.","import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT CustomerID, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
'''

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Create the visualization
fig = px.bar(df_orders, x='CustomerID', y='OrderCount', title='Top 5 Customers by Order Count', labels={'CustomerID':'Customer ID', 'OrderCount':'Order Count'})

# Display the visualization
show_to_user(fig)","The input Python code correctly implements the required functionality. It follows the provided environment constraints by using the specified utility functions execute_sql_query and show_to_user. The code constructs the correct SQL query to retrieve the top 5 customers by the number of orders, processes the result into a DataFrame, and uses Plotly to create and display a bar chart visualizing the number of orders per customer.",both
What is the average shipping time for orders shipped to a specific country in the current month?,"import pandas as pd
import plotly.express as px
from datetime import datetime

# Get the current date
current_date = datetime.now()

# Format the current date to match YYYY-MM for SQL query
current_month = current_date.strftime('%Y-%m')

# Define the specific country to filter orders by
specified_country = 'specified_country'

# SQL query to get the average shipping time for orders shipped to the specified country in the current month
sql_query = f""""""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime
FROM orders
WHERE DATE_FORMAT(OrderDate, '%Y-%m') = '{current_month}'
AND ShipCountry = '{specified_country}'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the specific country for which we want to calculate average shipping time
specific_country = 'Country_Name'  # Replace 'Country_Name' with the desired country

# SQL query to calculate average shipping time for orders shipped to the specific country in the current month
sql_query = f""""""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime
FROM orders
WHERE ShipCountry = '{specific_country}'
AND MONTH(OrderDate) = MONTH(CURRENT_DATE())
AND YEAR(OrderDate) = YEAR(CURRENT_DATE())
AND ShippedDate IS NOT NULL
""""""  

# Execute the SQL query and retrieve the data
average_shipping_time_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_shipping_time_df)  
","The input Python code correctly calculates the average shipping time for orders shipped to a specified country in the current month. It follows the Python environment constraints adequately by using the `execute_sql_query` function to run the SQL query and the `show_to_user` function to display the result. The SQL query properly filters the orders for the current month and the specified country, similar to the reference code.","```python
import pandas as pd

def calculate_average_shipping_time(country):
    # Define the SQL query with the given country as a parameter
    sql_query = f""""""
    SELECT AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS shipping_time 
    FROM orders 
    WHERE orders.ShipCountry = '{country}' 
    AND MONTH(orders.OrderDate) = MONTH(CURRENT_DATE) 
    AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE)
    """"""

    # Execute the query
    result_df = execute_sql_query(sql_query)

    # Extract the average shipping time
    shipping_time = result_df['shipping_time'].iloc[0]

    # Convert to a DataFrame
    result_df_final = pd.DataFrame({'Average Shipping Time': [shipping_time]})

    # Display the result to the user
    show_to_user(result_df_final)

# Replace 'SpecificCountry' with the actual country variable or value
calculate_average_shipping_time('SpecificCountry')
```","The input code correctly calculates the average shipping time for orders shipped to a specified country in the current month. It uses MONTH(CURRENT_DATE) and YEAR(CURRENT_DATE) to filter on the current month, which matches the reference implementationâ€™s logic. The function execute_sql_query will execute the SQL query, and show_to_user will display the resulting DataFrame.",both
Which customers have purchased more than 5 different products?,"import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT customers.CustomerID, customers.CompanyName 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID, customers.CompanyName 
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
'''

# Execute the SQL query and fetch the results into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)

# Optionally, visualize the data using plotly
fig = px.bar(df, x='CustomerID', y='CompanyName', title='Customers with more than 5 different products purchased')
show_to_user(fig)
","
import pandas as pd

# SQL query to find customers who purchased more than 5 different products
sql_query = '''
SELECT o.CustomerID, COUNT(DISTINCT od.ProductID) AS different_products_count 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.CustomerID 
HAVING COUNT(DISTINCT od.ProductID) > 5
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
","The input Python code correctly identifies customers who have purchased more than 5 different products by executing the appropriate SQL query and displaying the result to the user using the provided utility functions. Although it does not visualize the results with Plotly like the reference code, visualization was mentioned as optional.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT o.CustomerID
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY o.CustomerID
HAVING COUNT(DISTINCT od.ProductID) > 5;
'''

# Execute the SQL query to retrieve data
customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_df)
```
","The provided code meets the business analytics requirement of identifying customers who have purchased more than 5 different products. The SQL query accurately joins the relevant tables and uses SQL functions to compute the distinct product count per customer, filtering those with more than 5 different products. The results are fetched into a DataFrame using 'execute_sql_query' and the output is displayed using 'show_to_user'. While the provided code snippet doesn't visualize the data, visualization wasn't specified as a strict requirement based on the business request. Thus, the implementation is correct and sufficient.",both
Which region has the highest on-time delivery rate with a visualization comparing on-time delivery rates across regions?,"import pandas as pd
import plotly.express as px

# SQL query to retrieve the region with the highest on-time delivery rate
sql_query = '''
SELECT ShipRegion, 
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS on_time_rate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY on_time_rate DESC LIMIT 1;'''

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Extract the region with the highest on-time delivery rate
highest_on_time_region = result_df.iloc[0]

# Output the region with the highest on-time delivery rate
show_to_user(highest_on_time_region)

# SQL query to retrieve all on-time delivery rates across regions for visualization
sql_query_all = '''
SELECT ShipRegion, 
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS on_time_rate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY on_time_rate DESC;'''

# Execute SQL query to get the full data
all_regions_df = execute_sql_query(sql_query_all)

# Convert the on_time_rate to numeric in case it's not already
all_regions_df['on_time_rate'] = pd.to_numeric(all_regions_df['on_time_rate'])

# Create a bar chart to visualize on-time delivery rates across regions
fig = px.bar(all_regions_df, x='ShipRegion', y='on_time_rate', title='On-Time Delivery Rates by Region')

# Show the bar chart
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Create the SQL query to fetch on-time delivery data grouped by region
sql_query = '''
SELECT 
    ShipRegion, 
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeOrders 
FROM 
    orders 
GROUP BY 
    ShipRegion
'''  

# Step 2: Execute the SQL query
on_time_delivery_df = execute_sql_query(sql_query)

# Step 3: Calculate the on-time delivery rate
on_time_delivery_df['OnTimeRate'] = on_time_delivery_df['OnTimeOrders'] / on_time_delivery_df['TotalOrders'] * 100

# Step 4: Find the region with the highest on-time delivery rate
highest_on_time_region = on_time_delivery_df.loc[on_time_delivery_df['OnTimeRate'].idxmax()]

# Step 5: Prepare visualization for on-time delivery rates across regions
fig = px.bar(
    on_time_delivery_df,
    x='ShipRegion',
    y='OnTimeRate',
    title='On-time Delivery Rate by Region',
    labels={'OnTimeRate': 'On-time Delivery Rate (%)', 'ShipRegion': 'Region'},
    color='OnTimeRate',
    color_continuous_scale=px.colors.sequential.Viridis
)

# Step 6: Show the highest region and the plot
show_to_user(fig)
print(f'The region with the highest on-time delivery rate is: {highest_on_time_region[""ShipRegion""]} with a rate of {highest_on_time_region[""OnTimeRate""]:.2f}%')","The evaluated code correctly fetches the on-time delivery data, calculates the on-time delivery rate, finds the highest on-time region, and visualizes the on-time delivery rates by region. The approach and results match the business analytic request and the reference implementation, adhering to the given Python environment constraints.","import plotly.express as px

# Function to execute the SQL query and get the data
sql_query = '''
SELECT Region, COUNT(NOrderID) AS OnTimeDeliveryCount 
FROM orders 
WHERE ShippedDate <= RequiredDate 
GROUP BY Region;
'''
df = execute_sql_query(sql_query)

# Calculate the delivery rate
total_orders_query = 'SELECT Region, COUNT(NOrderID) AS TotalOrderCount FROM orders GROUP BY Region;'
total_orders_df = execute_sql_query(total_orders_query)

# Merge dataframes to calculate on-time delivery rates
merged_df = pd.merge(df, total_orders_df, on='Region', suffixes=('_OnTime', '_Total'))

# Compute on-time delivery rate
merged_df['OnTimeDeliveryRate'] = merged_df['OnTimeDeliveryCount'] / merged_df['TotalOrderCount']

# Create a bar plot for on-time delivery rates across regions
fig = px.bar(merged_df, x='Region', y='OnTimeDeliveryRate', title='On-Time Delivery Rate by Region', labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate', 'Region': 'Region'})

# Display the plot to the user
show_to_user(fig)

# Return the region with the highest on-time delivery rate
highest_rate_region = merged_df.loc[merged_df['OnTimeDeliveryRate'].idxmax(), ['Region', 'OnTimeDeliveryRate']]
show_to_user(highest_rate_region)","The input code does not correctly compute the on-time delivery rate as a percentage. Additionally, it does not correctly sort the regions based on the on-time delivery rate before finding the highest rate region.",Base
How many orders were placed in the current year?,"import pandas as pd
import datetime as dt

# Get the current year
current_year = dt.datetime.now().year

# SQL query to count the total orders in the current year
sql_query = f""SELECT COUNT(*) AS TotalOrders FROM orders WHERE YEAR(OrderDate) = {current_year};""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define SQL query to count the number of orders placed in the current year
current_year = pd.to_datetime('today').year
sql_query = f""""""
SELECT COUNT(OrderID) AS TotalOrders
FROM orders
WHERE YEAR(OrderDate) = {current_year}
""""""  

# Execute the SQL query
orders_count_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_count_df)","The input Python code correctly implements the business analytic request by calculating the number of orders placed in the current year. It defines an SQL query that counts the orders with the 'OrderDate' in the current year, executes the query using the provided utility function 'execute_sql_query', and displays the result using the 'show_to_user' function. Additionally, it adheres to the Python environment constraints.","import pandas as pd
from datetime import datetime

def count_orders_in_current_year():
    # Get the current year
    current_year = datetime.now().year
    
    # Construct SQL query
    sql_query = f""""""
    SELECT COUNT(*) AS OrderCount 
    FROM orders 
    WHERE YEAR(OrderDate) = {current_year};
    """"""
    
    # Execute the SQL query
    result_df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(result_df)

# Call the function to perform the action
count_orders_in_current_year()","The input code correctly follows the specified business request and Python environment constraints. It gets the current year, constructs an appropriate SQL query to count orders from that year, executes the query, and then displays the result to the user. The logic and the steps are consistent with the reference implementation, and the core functionality is similar.",both
Calculate the total discount given on all orders in the last month.,"import pandas as pd

# SQL query to calculate the total discount on all orders in the last month
sql_query = '''
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS TotalDiscount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATE_ADD(CURDATE(), INTERVAL -1 MONTH);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd
from datetime import datetime, timedelta

# Define the date range for the last month
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# Format dates to YYYY-MM-DD
start_date_str = start_date.strftime('%Y-%m-%d')
end_date_str = end_date.strftime('%Y-%m-%d')

# SQL query to calculate total discount given on all orders in the last month
sql_query = f""""""
SELECT SUM([Order Details].Discount * [Order Details].Quantity) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '{start_date_str}' AND '{end_date_str}'
""""""  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code does not multiply Discount by UnitPrice, which is necessary to calculate the total discount accurately.","import pandas as pd
import plotly.express as px

# Define the SQL query to calculate the total discount given on all orders in the last month
sql_query = '''
SELECT SUM(Discount * Quantity * UnitPrice) AS TotalDiscountLastMonth
FROM [Order Details]
WHERE OrderID IN (
    SELECT OrderID
    FROM orders
    WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
);''' 

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the value of TotalDiscountLastMonth
if not result_df.empty:
    total_discount = result_df.iloc[0]['TotalDiscountLastMonth']
    print(f'The total discount given on all orders in the last month is: {total_discount}')
else:
    print('No data available for the last month.')","The input code correctly queries the total discount on all orders in the last month using SQL within the provided functions. The logic aligns with the reference implementation, it executes the same essential query, and correctly handles the result.",Finetuned
Which products have a stock level below their reorder level?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0;
'''

# Execute the SQL query to get the products with stock below reorder level
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The input code correctly identifies products with stock levels below their reorder levels by querying the necessary fields from the 'products' table and filtering accordingly. It also respects the constraint to consider only active products (not discontinued). It uses the provided utility functions to execute the SQL query and display the results.,"import pandas as pd

# Step 1: Execute the SQL query to get products with stock below reorder level.
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;'
df = execute_sql_query(sql_query)

# Step 2: Display the results to the user.
show_to_user(df)","The input code correctly follows the Python environment constraints, executes an SQL query to get products with stock level below their reorder level, and displays the result to the user. It performs the required steps and uses the specified utility functions properly.",both
Which month had the highest number of orders placed with a visualization showing the number of orders per month?,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY Month 
ORDER BY NumberOfOrders DESC;
""""""

# Execute SQL query
orders_data = execute_sql_query(sql_query)

# Find the month with the highest number of orders
max_orders_month = orders_data.iloc[0]

# Visualization
fig = px.bar(orders_data, x='Month', y='NumberOfOrders', title='Number of Orders per Month')

# Show results to user
show_to_user(fig)

# Also show the month with the highest number of orders
show_to_user(pd.DataFrame([max_orders_month]))","import pandas as pd
import plotly.express as px

# Step 1: Query to get the number of orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY Month
ORDER BY Month
""""""

# Step 2: Execute the query and get the data
orders_per_month = execute_sql_query(sql_query)

# Step 3: Find the month with the highest number of orders
highest_month = orders_per_month.loc[orders_per_month['NumberOfOrders'].idxmax()]

# Step 4: Create a visualization for the number of orders per month
fig = px.bar(orders_per_month, x='Month', y='NumberOfOrders', title='Number of Orders Per Month')

# Step 5: Show both the highest month and the visualization
show_to_user(orders_per_month)
show_to_user(fig)","The input Python code does not order the results by the number of orders in descending order within the SQL query. This discrepancy could result in an incorrect month being identified as having the highest number of orders. Also, the input code shows the entire DataFrame of orders per month to the user rather than just the month with the highest number of orders.","import plotly.express as px


def get_highest_order_month_and_visualization():
    # Fetch the month with the highest number of orders
    sql_query_max_month = """"""
    SELECT MONTH(OrderDate) AS OrderMonth, COUNT(OrderID) AS OrderCount 
    FROM orders 
    GROUP BY MONTH(OrderDate) 
    ORDER BY OrderCount DESC 
    LIMIT 1;
    """"""
    highest_order_month = execute_sql_query(sql_query_max_month)

    # Fetch the order count per month for visualization
    sql_query_all_months = """"""
    SELECT MONTH(OrderDate) AS OrderMonth, COUNT(OrderID) AS OrderCount 
    FROM orders 
    GROUP BY MONTH(OrderDate);
    """"""
    order_data = execute_sql_query(sql_query_all_months)

    # Create a bar chart using plotly
    fig = px.bar(order_data, x='OrderMonth', y='OrderCount', 
                 labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'},
                 title='Number of Orders per Month')

    # Show the figure and the month with the highest number of orders
    show_to_user(fig)
    show_to_user(highest_order_month)


# Call the function to execute the above logic
get_highest_order_month_and_visualization()","The provided implementation does not correctly match the business analytic request. While both implementations fetch the order count per month, the evaluated code fetches months as integers (MONTH(OrderDate)) instead of formatted years and months (DATE_FORMAT(OrderDate, %Y-%m)) used in the reference implementation. This could lead to confusion when visualizing data across multiple years. Moreover, the evaluated implementation limits the highest month query to one whereas the reference implementation presents it directly from the initial fetch.",None
Determine the employee with the largest average order size with a visualization comparing the average order sizes.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderSize 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY AvgOrderSize DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Determine the employee with the largest average order size
employee_id_with_max_avg_order_size = result_df.iloc[0]['EmployeeID']
avg_order_size = result_df.iloc[0]['AvgOrderSize']

# Additional query to get all employees' average order sizes for comparison
comparison_query = '''
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderSize 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY AvgOrderSize DESC;
'''

# Execute the comparison query
comparison_df = execute_sql_query(comparison_query)

# Create a bar plot for visualization
fig = px.bar(comparison_df, x='EmployeeID', y='AvgOrderSize', 
             title='Comparison of Average Order Sizes by Employee', 
             labels={'EmployeeID':'Employee ID', 'AvgOrderSize':'Average Order Size'})

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average order size per employee
sql_query = '''
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderSize 
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY AverageOrderSize DESC
'''

# Execute the SQL query
average_order_sizes_df = execute_sql_query(sql_query)

# Identify the employee with the largest average order size
largest_average_order_size = average_order_sizes_df.iloc[0]

# Prepare the visualization
fig = px.bar(average_order_sizes_df, 
             x='EmployeeName', 
             y='AverageOrderSize', 
             title='Average Order Sizes by Employee', 
             labels={'AverageOrderSize': 'Average Order Size', 'EmployeeName': 'Employee'}, 
             text='AverageOrderSize')

# Show the visualization to the user
show_to_user(fig)

# Optionally, display the employee with the largest average order size
print(f'Employee with the largest average order size: {largest_average_order_size.EmployeeName} with an average order size of ${largest_average_order_size.AverageOrderSize:.2f}')","The input code implementation accurately meets the business analytic request. It calculates the average order size for each employee, identifies the employee with the largest average order size, and visualizes the results. It adheres to the provided Python environment constraints by using the execute_sql_query and show_to_user functions.","
import plotly.express as px
import pandas as pd

# Define the SQL query
df = execute_sql_query(""""""
SELECT EmployeeID, AVG(OrderSize) AS AvgOrderSize 
FROM (
    SELECT e.EmployeeID, COUNT(od.OrderID) AS OrderSize 
    FROM employees e 
    JOIN orders o ON e.EmployeeID = o.EmployeeID 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    GROUP BY e.EmployeeID, o.OrderID
) AS OrderSizesGrouped 
GROUP BY EmployeeID 
ORDER BY AvgOrderSize DESC;
"""""")

# Fetching the employee with the largest average order size
# Note: `.iloc[0]` will help us get the first row which has the largest AvgOrderSize
largest_avg_order_size_employee = df.iloc[0]

# Visualizing the average order sizes
fig = px.bar(df, x='EmployeeID', y='AvgOrderSize', title='Average Order Sizes by Employee')

# Show the visualization to the user
show_to_user(fig)

# Additionally, display the employee with the largest average order size
show_to_user(pd.DataFrame([largest_avg_order_size_employee]))","The input code contains a significant issue in the SQL query. The subquery 'OrderSizesGrouped' is improperly structured: it counts orders (COUNT(od.OrderID)) instead of calculating the order size (SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))). This results in an incorrect calculation for AvgOrderSize. Additionally, while it does visualize the average order sizes correctly, it lacks the step to explicitly find and emphasize the employee with the largest average order size, which was done in the reference code.",Base
How many distinct customers placed orders each month with a visualization showing the number of distinct customers per month?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_TRUNC('month', o.OrderDate) AS Month, 
COUNT(DISTINCT o.CustomerID) AS UniqueCustomers 
FROM orders o 
GROUP BY Month;
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Ensure the 'Month' column is in datetime format
orders_df['Month'] = pd.to_datetime(orders_df['Month'])

# Sort the dataframe by the 'Month' column
orders_df = orders_df.sort_values(by='Month')

# Create a line plot showing the number of distinct customers per month
fig = px.line(orders_df, x='Month', y='UniqueCustomers', title='Distinct Customers Per Month', labels={'Month': 'Month', 'UniqueCustomers': 'Number of Distinct Customers'})

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get distinct customers per month
sql_query = '''SELECT DATE_TRUNC('month', o.OrderDate) AS month, COUNT(DISTINCT o.CustomerID) AS distinct_customers \
              FROM orders o \
              GROUP BY month \
              ORDER BY month;'''

# Execute the SQL query
monthly_customers = execute_sql_query(sql_query)

# Visualize the result
fig = px.line(monthly_customers, x='month', y='distinct_customers', title='Distinct Customers Per Month',
              labels={'month': 'Month', 'distinct_customers': 'Distinct Customers'})

# Show result to user
show_to_user(fig)","The input code correctly executes the SQL query to get the number of distinct customers per month, uses pandas to handle the data, and employs plotly to create a line plot that matches the requirements of the business analytic request. The primary functions and steps from the reference implementation are adhered to, ensuring that the result is accurate and displays the needed visualization.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(DISTINCT CustomerID) AS DistinctCustomers
FROM orders
GROUP BY Month;
""""""

# Execute the SQL query to retrieve data
order_data = execute_sql_query(sql_query)

# Ensure 'Month' is treated as a datetime type
order_data['Month'] = pd.to_datetime(order_data['Month'], format='%Y-%m')

# Sort the data by 'Month'
order_data = order_data.sort_values(by='Month')

# Create a plotly line chart
fig = px.line(order_data, x='Month', y='DistinctCustomers', title='Number of Distinct Customers per Month', labels={'DistinctCustomers': 'Distinct Customers', 'Month': 'Month'})

# Display the plot
show_to_user(fig)","The input Python code correctly follows the Python environment constraints, computes the number of distinct customers per month, and creates the visualization as requested. The SQL query collects the aggregated data by month, and the rest of the processing in Python matches the intent and structure of the reference implementation.",both
What are the average discounts applied per order?,"import pandas as pd
import plotly.express as px

# SQL query to retrieve average discounts per order
sql_query = '''
SELECT OrderID, AVG(Discount) AS AverageDiscount 
FROM [Order Details] 
GROUP BY OrderID;
'''

# Execute the SQL query and get the result in a pandas dataframe
order_discounts_df = execute_sql_query(sql_query)

# Display the average discounts per order to user
show_to_user(order_discounts_df)

# Optional: Additional visualization using plotly
fig = px.bar(order_discounts_df, x='OrderID', y='AverageDiscount', title='Average Discounts per Order')
show_to_user(fig)","import pandas as pd

# SQL query to calculate average discounts applied per order
sql_query = '''
SELECT OrderID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID
'''

# Execute the SQL query and retrieve the data
average_discounts_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(average_discounts_df)","The input Python code correctly retrieves the average discounts per order by executing the SQL query and displaying the results to the user. It adheres to the Python environment constraints. Though it lacks the optional plotly visualization provided in the reference implementation, it satisfies the core requirement, making it correct.","import pandas as pd
import plotly.express as px

# Define the SQL query
df = execute_sql_query('SELECT AVG(Discount) AS AverageDiscount FROM [Order Details]')

# Extract the average discount value
avg_discount = df['AverageDiscount'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'Average Discount': [avg_discount]}))
",The provided code does not meet the business analytic request of finding average discounts per order. The SQL query in the provided code calculates the overall average discount across all orders instead of the per-order average discounts. The correct implementation should group results by OrderID and then calculate the average discount for each order.,Base
What is the average order fulfillment time for orders made in February 2023? Please include a visualization to compare the daily fulfillment times.,"import pandas as pd
import plotly.express as px

# SQL Query to calculate the average order fulfillment time for February 2023
sql_query_avg_fulfillment = (
    'SELECT AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgFulfillmentTime '
    'FROM orders o '
    'WHERE MONTH(o.OrderDate) = 2 AND YEAR(o.OrderDate) = 2023;'
)

# SQL Query to get daily fulfillment times for February 2023
sql_query_daily_fulfillment = (
    'SELECT DATEDIFF(o.ShippedDate, o.OrderDate) AS FulfillmentTime, '
    'DATE(o.OrderDate) AS OrderDate '
    'FROM orders o '
    'WHERE MONTH(o.OrderDate) = 2 AND YEAR(o.OrderDate) = 2023;'
)

# Execute the queries
avg_fulfillment_df = execute_sql_query(sql_query_avg_fulfillment)
daily_fulfillment_df = execute_sql_query(sql_query_daily_fulfillment)

# Extract the average fulfillment time
average_fulfillment_time = avg_fulfillment_df[""AvgFulfillmentTime""][0]

# Print the average fulfillment time
print('Average Order Fulfillment Time for February 2023: ', average_fulfillment_time)

# Create a visualization to compare the daily fulfillment times
fig = px.line(daily_fulfillment_df, 
              x='OrderDate', 
              y='FulfillmentTime', 
              title='Daily Fulfillment Times for February 2023',
              labels={
                  'OrderDate': 'Order Date',
                  'FulfillmentTime': 'Fulfillment Time (days)'
              })

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get order fulfillment times for orders made in February 2023
sql_query = '''
SELECT DATE(OrderDate) AS OrderDate, 
       DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE OrderDate >= '2023-02-01' AND OrderDate <= '2023-02-28' 
AND ShippedDate IS NOT NULL;
'''

# Execute the SQL query and load the data into a DataFrame
fulfillment_data = execute_sql_query(sql_query)

# Calculate average fulfillment time
average_fulfillment_time = fulfillment_data['FulfillmentTime'].mean()

# Prepare data for visualization
daily_fulfillment = fulfillment_data.groupby('OrderDate').mean().reset_index()

# Create a line plot for daily fulfillment times
fig = px.line(daily_fulfillment, x='OrderDate', y='FulfillmentTime', 
              title='Daily Order Fulfillment Time in February 2023', 
              labels={'FulfillmentTime': 'Average Fulfillment Time (Days)'} )

# Show the result to the user
show_to_user(fig)

# Output the average fulfillment time for further reference
average_fulfillment_time","The provided Python code correctly queries order fulfillment times for February 2023, calculates the average fulfillment time, and creates a plotly line plot to visualize daily fulfillment times. It adheres to the given Python environment constraints by using execute_sql_query and show_to_user functions.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT orders.OrderID, DATEDIFF(orders.ShippedDate, orders.OrderDate) AS order_fulfillment_time 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-02-01' AND '2023-02-28';
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Correctly handle the datetime conversion
df['OrderDate'] = pd.to_datetime(df['OrderDate'])

# Calculate the average order fulfillment time
avg_fulfillment_time = df['order_fulfillment_time'].mean()

# Print the average fulfillment time
print(f""Average Order Fulfillment Time for February 2023: {avg_fulfillment_time}"")

# Group by OrderDate to get daily average fulfillment time
daily_fulfillment = df.groupby(df['OrderDate'].dt.date)['order_fulfillment_time'].mean().reset_index()

# Rename the columns for better clarity
daily_fulfillment.columns = ['Order Date', 'Average Daily Fulfillment Time']

# Create a line chart visualization
fig = px.line(daily_fulfillment, x='Order Date', y='Average Daily Fulfillment Time', title='Daily Order Fulfillment Time for February 2023')

# Show the plot to the user
show_to_user(fig)
```","The input Python code has a critical issue: it attempts to convert the 'OrderDate' column to datetime, but this column is not included in the initial SQL query and as a result, it throws an error. Additionally, the SQL query does not capture daily order dates along with fulfillment time, and the method to calculate daily average fulfillment times deviates from the reference implementation.",Base
Get a list of employees and the number of orders they have handled.,"import pandas as pd
import plotly.express as px

# SQL query to retrieve the required data
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;'''

# Execute the SQL query and get the results in a dataframe
employee_orders_df = execute_sql_query(sql_query)

# Display the results to the user
display_data = employee_orders_df[['EmployeeID', 'FirstName', 'LastName', 'OrderCount']]
show_to_user(display_data)

# Optionally create a bar plot to visualize the number of orders handled by each employee
fig = px.bar(employee_orders_df, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Each Employee', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'})
show_to_user(fig)","import pandas as pd

# SQL query to get the number of orders handled by each employee
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query using the provided utility function
employee_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employee_orders_df)","The input code correctly follows the business analytic request and extracts the required data of employees and the number of orders they handled. It uses a LEFT JOIN which is more inclusive than the JOIN in the reference implementation, ensuring all employees are accounted for even if they haven't handled any orders. It subsequently displays this data to the user using the show_to_user function. It does not visualize the data with a bar plot, but this is mentioned as optional in the reference implementation.","import plotly.express as px

# Execute SQL query to get the list of employees and the number of orders they have handled
df = execute_sql_query('''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID;
''')

# Display the result to the user
show_to_user(df)

# Optionally: Visualize the result using a bar chart
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Employees', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})
show_to_user(fig)","The input code is missing the retrieval and display of the 'FirstName' and 'LastName' fields for employees, which are part of the business analytic request.",Base
What is the inventory turnover ratio for the product 'Chai' in May 2023? Please provide a visualization to show the trend of inventory turnover ratios over time.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.ProductName = 'Chai' AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
'''

# Execute the SQL query to get the data
inventory_turnover_data = execute_sql_query(sql_query)

# Display the inventory turnover ratio for May 2023
show_to_user(inventory_turnover_data)

# Define a query to get the inventory turnover ratios over time for visualization
sql_query_trend = '''
SELECT DATEPART(month, orders.OrderDate) AS month, DATEPART(year, orders.OrderDate) AS year,
SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.ProductName = 'Chai'
GROUP BY DATEPART(year, orders.OrderDate), DATEPART(month, orders.OrderDate)
ORDER BY year, month
'''

# Execute the SQL query to get the trend data
timeline_turnover_data = execute_sql_query(sql_query_trend)

# Convert to datetime for better visualization
timeline_turnover_data['date'] = pd.to_datetime(timeline_turnover_data[['year', 'month']].assign(day=1))

# Create a line plot for the trend of inventory turnover ratios
fig = px.line(timeline_turnover_data, x='date', y='inventory_turnover_ratio', title='Trend of Inventory Turnover Ratios for Chai', labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio', 'date': 'Date'})

# Display the trend visualization
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Step 1: Query the Inventory Turnover Ratio for 'Chai' in May 2023
sql_query_turnover = '''
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.ProductName = 'Chai' 
AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
'''  
inventory_turnover_may = execute_sql_query(sql_query_turnover)

# Step 2: Query the Inventory Turnover Ratios over time
sql_query_trend = '''
SELECT DATE_TRUNC('month', orders.OrderDate) AS month,
SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY month
ORDER BY month
'''  
turnover_trend = execute_sql_query(sql_query_trend)

# Step 3: Create a line plot for the inventory turnover ratios over time
fig = px.line(turnover_trend, x='month', y='inventory_turnover_ratio', title='Inventory Turnover Ratio Over Time',
              labels={'month': 'Month', 'inventory_turnover_ratio': 'Inventory Turnover Ratio'})

# Step 4: Show results to user
show_to_user(inventory_turnover_may)
show_to_user(fig)",The input code implementation does not filter for the product 'Chai' while fetching the inventory turnover ratios over time. This deviates from the requirement outlined in the business analytic request and the reference implementation.,"import pandas as pd
import matplotlib.pyplot as plt
from plotly.express import line

# SQL Query to get inventory turnover ratio for product 'Chai' in May 2023
sql_query = """"""
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) / 
       AVG(inventory.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details], inventory
WHERE [Order Details].ProductID = inventory.ProductID 
      AND inventory.ProductName = 'Chai' 
      AND MONTH(order_date) = 5 
      AND YEAR(order_date) = 2023
""""""

# Execute the SQL query
inventory_turnover_df = execute_sql_query(sql_query)

# Get the inventory turnover ratio value
inventory_turnover_value = inventory_turnover_df['inventory_turnover_ratio'].iloc[0]

# Display the inventory turnover ratio
show_to_user(f""Inventory Turnover Ratio for 'Chai' in May 2023: {inventory_turnover_value}"")

# Assuming there's another SQL query to get the trend of inventory turnover ratios over time
trend_sql_query = """"""
SELECT DATE_FORMAT(order_date, '%Y-%m') AS month,
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / 
       AVG(inventory.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details], inventory
WHERE [Order Details].ProductID = inventory.ProductID
GROUP BY DATE_FORMAT(order_date, '%Y-%m')
""""""

# Execute the trend SQL query
trend_df = execute_sql_query(trend_sql_query)

# Convert 'month' column to datetime for proper plotting
trend_df['month'] = pd.to_datetime(trend_df['month'])

# Sort the dataframe by 'month'
trend_df = trend_df.sort_values(by='month')

# Plot the trend of inventory turnover ratio over time
fig = line(trend_df, x='month', y='inventory_turnover_ratio', title='Inventory Turnover Ratio Trend Over Time')

# Display the plot
show_to_user(fig)","The input code has several issues: using 'inventory' instead of 'products' table, incorrect SQL syntax for date filtering with MONTH() and YEAR(), incorrect aggregation, and using matplotlib instead of plotly for visualization. Also, the date column 'order_date' is not present in the FROM clause tables.",None
Which shipping method has the shortest average order fulfillment time? Please provide a visualization to compare the fulfillment times across all shipping methods.,"import pandas as pd
import plotly.express as px

# SQL query to get average fulfillment times by shipping method
sql_query = '''
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AverageFulfillmentTime ASC;
'''

# Execute the SQL query and get the results in a pandas dataframe
df = execute_sql_query(sql_query)

# Find the shipping method with the shortest average fulfillment time
shortest_fulfillment_method = df.iloc[0]
print(shortest_fulfillment_method)

# Create the visualization with plotly
fig = px.bar(df, x='ShipVia', y='AverageFulfillmentTime', title='Average Fulfillment Time by Shipping Method')

# Show visualization to user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to calculate average order fulfillment time for each shipping method
sql_query = '''
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) as AvgFulfillmentTime
FROM orders
GROUP BY ShipVia
ORDER BY AvgFulfillmentTime
'''

# Execute the SQL query and retrieve the data
fulfillment_data = execute_sql_query(sql_query)

# Determine the shipping method with the shortest average order fulfillment time
shortest_method = fulfillment_data.iloc[0]

# Visualization: Compare the fulfillment times across all shipping methods
fig = px.bar(fulfillment_data, x='ShipVia', y='AvgFulfillmentTime',
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'}
)

# Show the result to the user
show_to_user(fig)","The input code correctly implements the task requirements by executing an SQL query to retrieve average fulfillment times by shipping method, determines the shortest fulfillment method, and uses plotly to create a bar chart visualization. The code is functionally equivalent to the reference implementation and adheres to the provided Python environment constraints.","import pandas as pd
import plotly.express as px

# SQL query to get average fulfillment time per shipping method
sql_query = '''
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AverageFulfillmentTime ASC;
'''

# Execute the SQL query to fetch data
df = execute_sql_query(sql_query)

# Check if the dataframe is empty
if df.empty:
    show_to_user('No data retrieved from the database for the given query.')
else:
    # Plot the average fulfillment time for each shipping method
    fig = px.bar(df, x='ShipVia', y='AverageFulfillmentTime', 
                 title='Average Order Fulfillment Time by Shipping Method', 
                 labels={'ShipVia': 'Shipping Method', 'AverageFulfillmentTime': 'Average Fulfillment Time (days)'})

    # Show the plot to the user
    show_to_user(fig)
","The provided code correctly executes the SQL query to get the average fulfillment times by shipping method, checks if the resulting dataframe is empty, and plots the data using Plotly if data is available. It adheres to the constraints, utilizes the appropriate functions (execute_sql_query and show_to_user), and fulfills the requirement of visualizing the fulfillment times.",both
What is the number of products sold with discounts?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(DISTINCT ProductID) AS ProductsWithDiscount FROM [Order Details] WHERE Discount > 0;'

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to get the number of products sold with discounts
sql_query = """"""
SELECT SUM([Order Details].Quantity) AS TotalQuantitySold
FROM [Order Details]
WHERE [Order Details].Discount > 0
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code computes the total quantity of products sold with discounts, not the count of distinct products with discounts. The correct query should count distinct ProductID where Discount > 0.","import pandas as pd
import plotly.express as px

# Query to count the number of products sold with discounts
discounted_sales_query = 'SELECT COUNT(*) AS DiscountedSales FROM [Order Details] WHERE Discount > 0;'

# Execute the SQL query
result_df = execute_sql_query(discounted_sales_query)

# Show the result to the user
show_to_user(result_df)","The input code calculates the total number of row entries with a discount, not the distinct count of products sold with a discount. The correct query should be 'SELECT COUNT(DISTINCT ProductID) AS ProductsWithDiscount FROM [Order Details] WHERE Discount > 0;'.",None
What is the average order fulfillment time per employee? Provide a visualization to compare the fulfillment times of different employees.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime FROM orders GROUP BY EmployeeID;'

# Execute the SQL query and retrieve the data
employee_fulfillment_data = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(employee_fulfillment_data, x='EmployeeID', y='AverageFulfillmentTime', title='Average Order Fulfillment Time per Employee', labels={'EmployeeID': 'Employee ID', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average order fulfillment time per employee
sql_query = '''
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY EmployeeID
'''  

# Execute the SQL query and get the result as a pandas DataFrame
fulfillment_time_df = execute_sql_query(sql_query)  

# Visualization to compare the fulfillment times of different employees
fig = px.bar(fulfillment_time_df, x='EmployeeID', y='AverageFulfillmentTime',
             title='Average Order Fulfillment Time per Employee',
             labels={'AverageFulfillmentTime': 'Average Fulfillment Time (days)', 'EmployeeID': 'Employee ID'})

# Show the result to the user
show_to_user(fig)","The provided code follows the requirements and constraints. It constructs an appropriate SQL query to compute the average order fulfillment time per employee, executes the query to retrieve the data, creates a bar chart using plotly to visualize the fulfillment times of different employees, and finally uses the show_to_user function to display the visualization.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to get average order fulfillment time per employee
sql_query = '''
SELECT e.EmployeeID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgOrderFulfillmentTime
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
'''

# Execute the SQL query to retrieve data
employee_fulfillment_data = execute_sql_query(sql_query)

# Check for missing or NaN values (if any)
employee_fulfillment_data.dropna(inplace=True)

# Create a visualization using Plotly
fig = px.bar(employee_fulfillment_data, x='EmployeeID', y='AvgOrderFulfillmentTime', 
             title='Average Order Fulfillment Time per Employee', 
             labels={'EmployeeID': 'Employee ID', 'AvgOrderFulfillmentTime': 'Average Order Fulfillment Time (days)'},
             template='plotly_dark')

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly implements the logic to calculate the average order fulfillment time per employee and visualizes it using a bar chart in Plotly. The SQL query is structured properly, the data is processed to remove any missing values, and the visualization includes appropriate labels and a title. Although the input code contains an additional check for NaN values and a different Plotly template, these differences do not affect the correctness or functionality of the overall implementation.",both
What is the average number of units ordered per order?,"import pandas as pd
import plotly.express as px

# SQL query to get the average number of units ordered per order
sql_query = 'SELECT AVG(Quantity) AS AvgQuantityPerOrder FROM [Order Details];'

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Extract the average quantity value
avg_quantity = result_df['AvgQuantityPerOrder'][0]

# Create a dataframe for visualization
viz_df = pd.DataFrame({'Metric': ['AvgQuantityPerOrder'], 'Value': [avg_quantity]})

# Create a bar chart for visualization
fig = px.bar(viz_df, x='Metric', y='Value', title='Average Number of Units Ordered per Order')

# Show the visualized result to the user
show_to_user(fig)","import pandas as pd

# SQL query to get the total units ordered and total orders
sql_query = '''
SELECT SUM([Order Details].Quantity) AS TotalUnitsOrdered, COUNT(DISTINCT orders.OrderID) AS TotalOrders
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Calculate the average units ordered per order
if not result_df.empty:
    average_units_per_order = result_df['TotalUnitsOrdered'].iloc[0] / result_df['TotalOrders'].iloc[0]
else:
    average_units_per_order = 0

# Display the result to the user
show_to_user(pd.DataFrame({'Average Units Ordered Per Order': [average_units_per_order]}))","The input Python code correctly calculates the average number of units ordered per order based on the given SQL query, using the utility functions to execute the query and display the result.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(Quantity) AS AverageUnitsOrdered FROM [Order Details];'

# Execute the query to get the result
result_df = execute_sql_query(sql_query)

# Extract the average units ordered from the result dataframe
average_units_ordered = result_df['AverageUnitsOrdered'].iloc[0]

# Create a dataframe to display
output_df = pd.DataFrame({'Average Units Ordered': [average_units_ordered]})

# Display the result
show_to_user(output_df)","The input Python code correctly calculates the average number of units ordered per order by executing an SQL query. It uses the provided utility functions execute_sql_query and show_to_user, and it matches the business analytic request's requirement. The only difference lies in the representation of the output, but it does not impact the correctness of the code.",both
Determine the total revenue generated from orders shipped to Germany.,"import pandas as pd
import plotly.express as px

# SQL query to determine total revenue from orders shipped to Germany
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.ShipCountry = 'Germany';
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","sql_query = '''
SELECT SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalRevenue
FROM [Order Details] OD
JOIN orders O ON OD.OrderID = O.OrderID
JOIN customers C ON O.CustomerID = C.CustomerID
WHERE C.Country = 'Germany'
'''

# Execute the SQL query to get the total revenue
revenue_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(revenue_df)",The input Python code implementation is incorrect as it includes an additional JOIN with the customers table that is not specified in the business analytic request or present in the reference implementation. The WHERE clause should be checking 'orders.ShipCountry' instead of 'customers.Country'.,"import pandas as pd
import plotly.express as px

# Define the SQL query according to the business request
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * 
(1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE ShipCountry = 'Germany' 
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Assuming the result_df has only one row and one column
if not result_df.empty and 'TotalRevenue' in result_df.columns:
    total_revenue = result_df.iloc[0]['TotalRevenue']
    result_df = pd.DataFrame({'TotalRevenue': [total_revenue]})

# Display the data to the user
show_to_user(result_df)
","The provided code correctly executes the SQL query to determine the total revenue from orders shipped to Germany and handles the result appropriately. Although it adds additional logic to handle the result DataFrame, this does not affect the correctness of the solution. It also follows the Python environment constraints provided.",Finetuned
Determine the freights cost totals for each month in 2023. Please include a month-by-month visualization of freight costs.,"import pandas as pd
import plotly.express as px

# SQL query to get the freight cost totals for each month in 2023
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Freight) AS TotalFreight
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY Month;
'''

# Execute the SQL query and retrieve the data
freight_data = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as a datetime object
freight_data['Month'] = pd.to_datetime(freight_data['Month'] + '-01')

# Sort data by the 'Month' column
freight_data = freight_data.sort_values(by='Month')

# Create a month-by-month visualization using Plotly
fig = px.line(freight_data, x='Month', y='TotalFreight', title='Freight Cost Totals for Each Month in 2023', labels={'Month': 'Month', 'TotalFreight': 'Total Freight Cost'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get monthly freight costs for 2023
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Freight) AS TotalFreight
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY Month
ORDER BY Month
""""""

# Execute the SQL query and retrieve the data
freight_data = execute_sql_query(sql_query)

# Convert the Month column to datetime format for better visualization
freight_data['Month'] = pd.to_datetime(freight_data['Month'])

# Create a line plot using Plotly
fig = px.line(freight_data, x='Month', y='TotalFreight', title='Monthly Freight Costs in 2023',
              labels={'TotalFreight': 'Total Freight Cost', 'Month': 'Month'}, markers=True)

# Show the result to the user
show_to_user(fig)","The input Python code meets the business analytic request by implementing the SQL query to retrieve monthly freight costs for 2023, converting the month column to a datetime format, creating a month-by-month line plot using Plotly, and displaying it using the provided function `show_to_user`. It follows the Python environment constraint and will provide the correct output.","# Import necessary libraries
import plotly.express as px
import pandas as pd

# Define the SQL query to get the freight costs for each month in 2023
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       SUM(Freight) AS total_freight_cost 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY month 
ORDER BY month;
'''

# Execute the SQL query to get the data
freight_data = execute_sql_query(sql_query)

# Ensure month column is treated as a datetime type for proper sorting and handling
freight_data['month'] = pd.to_datetime(freight_data['month'])

# Plot the freight costs for each month using Plotly
fig = px.bar(freight_data, x='month', y='total_freight_cost', 
             title='Total Freight Costs Per Month in 2023',
             labels={'month': 'Month', 'total_freight_cost': 'Total Freight Cost ($)'})

# Show the plot to the user
show_to_user(fig)","The input code correctly follows the business analytic request, producing a total freight cost per month for 2023 and visualizing it using Plotly. The SQL query successfully retrieves the desired data, and the data processing steps ensure the 'month' column is in datetime format for proper handling. While it uses a bar chart instead of a line chart as in the reference implementation, this still meets the business requirement of providing a month-by-month visualization of freight costs.",both
Which categories have an average unit price above $20?,"import pandas as pd
import plotly.express as px

# SQL query to get the categories with average unit price above $20
sql_query = '''
SELECT CategoryName
FROM categories c
JOIN products p ON c.CategoryID = p.CategoryID
GROUP BY c.CategoryName
HAVING AVG(p.UnitPrice) > 20;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user using the utility function
show_to_user(result_df)

# Optional: Visualize the result using a bar plot
fig = px.bar(result_df, x='CategoryName', title='Categories with Average Unit Price Above $20', y='avg_price')
show_to_user(fig)","import pandas as pd

# SQL query to get categories with average unit price above $20
sql_query = '''
SELECT CategoryID, AVG(UnitPrice) as AverageUnitPrice
FROM products
GROUP BY CategoryID
HAVING AVG(UnitPrice) > 20
'''  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(result_df)","The provided code does not join the 'categories' and 'products' tables to get the category names. Instead, it only works with the 'products' table and retrieves the CategoryID and average UnitPrice. The business analytic request specifically asks for category names with average unit prices above $20.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CategoryName 
FROM categories c 
JOIN products p ON c.CategoryID = p.CategoryID 
GROUP BY c.CategoryName 
HAVING AVG(p.UnitPrice) > 20;
'''

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Display the results to the user using the provided utility function
show_to_user(df)","The provided input code correctly follows the specified business analytic request by querying categories with average unit prices above $20. It uses the provided utility functions for executing the SQL query and displaying the results. The main difference from the reference implementation is that it does not include the optional visualization, but this is not required for correctness as per the given instructions.",Finetuned
Who are the suppliers for orders placed in the first quarter of this year?,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the needed data
sql_query = """"""
SELECT DISTINCT s.CompanyName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query using the provided utility function
suppliers_df = execute_sql_query(sql_query)

# Display the data to the user using the provided utility function
show_to_user(suppliers_df)","import pandas as pd

# Define the SQL query to retrieve suppliers for orders placed in the first quarter of this year.
sql_query = """"""
SELECT DISTINCT s.SupplierID, s.CompanyName, s.ContactName, s.ContactTitle, s.Address, s.City, s.Region, s.PostalCode, s.Country, s.Phone, s.Fax, s.HomePage
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
""""""

# Execute the SQL query and retrieve the data
suppliers_q1 = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(suppliers_q1)","The input code retrieves a lot more information than needed. The business request only asks for the suppliers' names, but the input code retrieves SupplierID, CompanyName, ContactName, ContactTitle, Address, City, Region, PostalCode, Country, Phone, Fax, and HomePage. Furthermore, the filtering condition is different; the reference code uses 'BETWEEN' for date filtering while the input uses '>=' and '<'. Lastly, the JOIN condition in the input code using IN (subquery) is unnecessarily complex compared to the reference code.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DISTINCT suppliers.CompanyName, orders.OrderID 
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
'''

# Execute the SQL query to get the data
orders_suppliers_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(orders_suppliers_df)

# Visualize the data with a bar chart showing how many orders each supplier had in Q1
fig = px.bar(orders_suppliers_df, x='CompanyName', y='OrderID', title='Orders from Suppliers in Q1 2023', labels={'CompanyName': 'Supplier', 'OrderID': 'Order Count'})

# Display the bar chart
show_to_user(fig)
","The input code retrieves both the CompanyName and OrderID columns, which is inconsistent with the business analytic request that requires only the suppliers (CompanyName). Although the additional visualization is a value-added feature, it is not required by the request.",None
What is the total sales quantity for each product? Please provide a visualization showing the sales quantity per product.,"import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query
sql_query = 'SELECT ProductID, SUM(Quantity) AS TotalSales FROM [Order Details] GROUP BY ProductID;'

# Step 2: Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Step 3: Create a visualization of the total sales quantity per product
fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Total Sales Quantity per Product', labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales Quantity'})

# Step 4: Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales quantity for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart for total sales quantity per product
fig = px.bar(sales_data, x='ProductName', y='TotalSalesQuantity', 
             title='Total Sales Quantity per Product',
             labels={'TotalSalesQuantity': 'Total Sales Quantity', 'ProductName': 'Product Name'})

# Show result to user
show_to_user(fig)",The input code correctly retrieves total sales quantity for each product and visualizes it using a bar chart. It follows the format specified by the business analytic request and uses the provided utility functions as required.,"import pandas as pd
import plotly.express as px

# SQL query to get total sales quantity for each product
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductName;
'''

# Execute the SQL query and get the result
sales_data = execute_sql_query(sql_query)

# Generate a bar chart to visualize the sales quantity per product
fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Total Sales Quantity per Product', labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity Sold'})

# Show the visualization to the user
show_to_user(fig)",The input Python code correctly executes an SQL query to retrieve the total sales quantity for each product. It then generates a bar chart visualization of the sales quantity per product using Plotly and displays it to the user. The output matches the requirements of the business analytic request.,both
Which city has the highest number of orders? Please visualize the number of orders per city.,"import pandas as pd
import plotly.express as px

# Execute the SQL query
sql_query = '''
SELECT ShipCity, COUNT(OrderID) as NumberOfOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC;
'''

df = execute_sql_query(sql_query)

# Extract the city with the highest number of orders
city_with_highest_orders = df.iloc[0]['ShipCity']

# Extract the number of orders for the city with the highest number of orders
number_of_orders_highest_city = df.iloc[0]['NumberOfOrders']

# Visualize the number of orders per city
fig = px.bar(df, x='ShipCity', y='NumberOfOrders', title='Number of Orders per City')

# Show the results to the user
show_to_user(fig)

# Also show the city with the highest number of orders
highest_orders_df = pd.DataFrame({'City': [city_with_highest_orders], 'NumberOfOrders': [number_of_orders_highest_city]})
show_to_user(highest_orders_df)","import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per city
sql_query = '''
SELECT ShipCity, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY ShipCity
ORDER BY NumberOfOrders DESC
'''

# Execute the SQL query
orders_per_city = execute_sql_query(sql_query)

# Find the city with the highest number of orders
highest_order_city = orders_per_city.iloc[0]

# Display the city with the highest number of orders
print(f""City with the highest number of orders: {highest_order_city['ShipCity']} with {highest_order_city['NumberOfOrders']} orders"")

# Visualize the number of orders per city
fig = px.bar(orders_per_city, x='ShipCity', y='NumberOfOrders', title='Number of Orders per City')
show_to_user(fig)","The provided code correctly follows the business analytic request and the Python environment constraints. It executes the SQL query to get the number of orders per city, finds the city with the highest number of orders, prints this information, and then visualizes the number of orders per city using a plotly bar chart. The functions execute_sql_query and show_to_user are correctly used, and the output format requirements are met.","import pandas as pd
import plotly.express as px

# SQL Query to get the number of orders per city
sql_query = '''
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC;
'''

# Execute the SQL query
orders_per_city_df = execute_sql_query(sql_query)

# Find the city with the highest number of orders
city_with_most_orders = orders_per_city_df.iloc[0]

# Display the city with the highest number of orders
show_to_user(city_with_most_orders)

# Visualize the number of orders per city
fig = px.bar(orders_per_city_df, x='ShipCity', y='OrderCount', title='Number of Orders per City')
show_to_user(fig)","The provided code correctly follows the requirements. It retrieves the number of orders per city, identifies the city with the highest number of orders, and visualizes the results using a bar chart. The code adheres to the constraints of the Python environment by using the provided utility functions 'execute_sql_query' and 'show_to_user'.",both
What is the average order fulfillment time for each shipping method? Provide a visualization to compare the fulfillment times of different shipping methods.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Check the retrieved dataframe
print(orders_df.head())

# Ensure column names are consistent
orders_df.columns = ['ShipVia', 'AverageFulfillmentTime']

# Create a bar chart to compare the fulfillment times of different shipping methods
fig = px.bar(orders_df, x='ShipVia', y='AverageFulfillmentTime', title='Average Order Fulfillment Time by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get order fulfillment time and shipping method
sql_query = """"""
SELECT 
    ShipVia, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    ShipVia
""""""

# Execute SQL query and retrieve data
fulfillment_data = execute_sql_query(sql_query)

# Create a bar plot to visualize average order fulfillment time by shipping method
fig = px.bar(fulfillment_data, x='ShipVia', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'} )

# Show result to user
show_to_user(fig)","The input Python code correctly follows the given business analytic request and constraints. It retrieves the average order fulfillment time for each shipping method and visualizes the results using a bar chart. The code successfully executes the SQL query using 'execute_sql_query' and displays the plotly figure using 'show_to_user'. Despite minor differences in the column names and SQL query specifics, the overall functionality remains intact.","import pandas as pd
import plotly.express as px

# SQL query to get the average order fulfillment time for each shipping method
sql_query = '''
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageOrderFulfillmentTime 
FROM orders 
GROUP BY ShipVia;
'''

# Execute the SQL query and fetch the results
try:
    df = execute_sql_query(sql_query)
except Exception as e:
    print(f'An error occurred while fetching data: {e}')
    raise

# Ensure that the right columns are present in the dataframe
if 'ShipVia' not in df.columns or 'AverageOrderFulfillmentTime' not in df.columns:
    raise ValueError('The resulting dataframe does not contain the expected columns.')

# Display the dataframe to the user (optional)
show_to_user(df)

# Create a visualization using Plotly
fig = px.bar(df, x='ShipVia', y='AverageOrderFulfillmentTime', title='Average Order Fulfillment Time by Shipping Method', labels={'ShipVia': 'Shipping Method', 'AverageOrderFulfillmentTime': 'Average Fulfillment Time (days)'})

# Show the visualization to the user
show_to_user(fig)","The code implementation incorrectly uses the DATEDIFF function without specifying the units (days). The correct reference implementation specifies 'DATEDIFF(day, OrderDate, ShippedDate)' to measure the difference in days.",Base
Which customers have placed orders in the last month?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT CustomerID FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);""

# Execute the SQL query to get the data
customers_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(customers_df)","import pandas as pd
from datetime import datetime, timedelta

# Calculate the date range for the last month
end_date = datetime.now()  # todays date
start_date = end_date - timedelta(days=30)  # 30 days ago

# Create the SQL query to find customers who placed orders in the last month
sql_query = f""""""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The provided Python code correctly calculates the date range for the last month and constructs an SQL query to retrieve customers who placed orders within that timeframe. The SQL query is executed using the execute_sql_query function and the results are displayed using the show_to_user function, as per the provided functionality and requirements.","import pandas as pd
from datetime import datetime, timedelta

# Define the SQL query
sql_query = '''
SELECT DISTINCT customers.CustomerID, customers.ContactName 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
'''

# Execute the SQL query
customers_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(customers_df)
",The input code correctly retrieves the customers who placed orders in the last month by joining the customers and orders tables and applying the correct date filter with SQL query. It then displays the resulting dataframe to the user.,both
List customers who have placed orders within the last 30 days.,"import pandas as pd
import plotly.express as px

# SQL query to get orders from the last 30 days
sql_query = 'SELECT * FROM orders WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY);'

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(orders_df)","import pandas as pd
from datetime import datetime, timedelta

# Define the date range for the last 30 days
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# Prepare the SQL query to fetch customers who placed orders in the last 30 days
sql_query = f""""""
SELECT DISTINCT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, c.City, c.Region, c.PostalCode, c.Country, c.Phone, c.Fax
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query to get the data
customers_recent_orders = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(customers_recent_orders)","The input code fetches the customers who made recent orders by correctly defining the date range for the last 30 days, constructing an SQL query with the appropriate JOIN clause to link customers with orders, and ensures the order dates fall within the last 30 days. The `execute_sql_query` and `show_to_user` functions are used as required.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DISTINCT c.CustomerID, c.CompanyName 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 30 DAY);
'''

# Execute the SQL query to get the data
customers_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(customers_df)",The input code correctly formulates an SQL query to retrieve distinct customer records who have placed orders in the last 30 days and successfully executes and displays the result using the provided utility functions 'execute_sql_query' and 'show_to_user'.,both
What are the names and unit prices of all products?,"import pandas as pd
import plotly.express as px

# SQL query to fetch the names and unit prices of all products
sql_query = 'SELECT ProductName, UnitPrice FROM products;'

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)","import pandas as pd

# SQL query to retrieve product names and unit prices from the products table
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query and store the results in a pandas dataframe
product_data = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(product_data)","The evaluated code includes an additional condition (WHERE Discontinued = 0) that is not present in the reference implementation. This added condition limits the query to only non-discontinued products, which may not satisfy the business analytic request to fetch all product names and unit prices.","import pandas as pd
import plotly.express as px

# Function to execute the SQL query
def get_products_info():
    sql_query = 'SELECT ProductName, UnitPrice FROM products;'
    return execute_sql_query(sql_query)

# Retrieve data
products_info = get_products_info()

# Display the data to the user
show_to_user(products_info)",The input Python code correctly implements the business analytic request by querying the names and unit prices of all products using the SQL query and displaying the result to the user using provided utility functions. The structure and functionality match the reference implementation.,Finetuned
Find the monthly sales performance for each product. Include a visualization to show the monthly sales trends for each product.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate) AS Month, 
SUM(od.Quantity) AS MonthlySales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate);
'''

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Ensure 'Month' is treated as a categorical type for proper sorting and plotting
sales_data['Month'] = sales_data['Month'].astype(int)

# Create a line plot for monthly sales trends for each product
fig = px.line(sales_data, x='Month', y='MonthlySales', color='ProductName', title='Monthly Sales Trends for Each Product', 
              labels={'Month': 'Month', 'MonthlySales': 'Monthly Sales', 'ProductName': 'Product Name'}, 
              category_orders={'Month': list(range(1, 13))})

# Show the plot to the user
show_to_user(fig)
","
import pandas as pd
import plotly.express as px

# SQL query to retrieve monthly sales data for each product
sql_query = '''
SELECT  
    p.ProductID,  
    p.ProductName,  
    DATE_FORMAT(o.OrderDate, '%Y-%m') as Month,  
    SUM(od.Quantity) as TotalQuantity,  
    SUM(od.Quantity * od.UnitPrice) as TotalSales  
FROM products p  
JOIN [Order Details] od ON p.ProductID = od.ProductID  
JOIN orders o ON od.OrderID = o.OrderID  
WHERE o.OrderDate IS NOT NULL  
GROUP BY p.ProductID, Month  
ORDER BY Month, p.ProductID;  
'''

# Execute SQL query to get the data
monthly_sales_data = execute_sql_query(sql_query)

# Visualization of monthly sales trends for each product
fig = px.line(
    monthly_sales_data,
    x='Month',
    y='TotalSales',
    color='ProductName',
    title='Monthly Sales Performance for Each Product',
    labels={'TotalSales': 'Total Sales', 'Month': 'Month'}
)

# Display the plot to the user
show_to_user(fig)
",The input code is not entirely correct as it deviates from the business analytic request and reference implementation in a few ways: 1) It uses 'DATE_FORMAT' to get the month-year format instead of extracting the month; 2) It includes an additional 'TotalQuantity' column which is unnecessary for the request; 3) The SQL query aggregates by 'Month' (which is in 'YYYY-MM' format) instead of extracting only the month as requested. The code should focus on monthly sales performance by month extracted from order dates.,"import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
GROUP BY Month, p.ProductID, p.ProductName
ORDER BY Month;
""""""

sales_data = execute_sql_query(sql_query)

# Ensure the data types are correct
sales_data['Month'] = pd.to_datetime(sales_data['Month'])
sales_data['TotalQuantity'] = sales_data['TotalQuantity'].astype(int)

# Step 2: Create the visualisation
fig = px.line(sales_data, x='Month', y='TotalQuantity', color='ProductID', title='Monthly Sales Performance for Each Product', labels={
    'TotalQuantity': 'Total Quantity Sold',
    'Month': 'Month'
})

# Step 3: Show the result to the user
show_to_user(fig)
","The input code does not exactly match the business analytic request and reference implementation. The primary issue is the grouping period, as the input code groups sales data by year-month (YYYY-MM) instead of extracting the month component as was demonstrated in the reference implementation. Additionally, the SQL query differs since it uses 'DATE_FORMAT' instead of 'EXTRACT(MONTH FROM o.OrderDate)'. Finally, the input code plots the graph using 'ProductID' for color instead of 'ProductName'.",None
What is the total sales revenue generated last month?,"import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue generated last month
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales_Revenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales revenue from the result
total_sales_revenue = result_df['Total_Sales_Revenue'][0]

# Prepare the data for displaying
result_to_display = pd.DataFrame({'Total_Sales_Revenue': [total_sales_revenue]})

# Show the result to the user
show_to_user(result_to_display)","import pandas as pd

# Define the SQL query to calculate total sales revenue for last month
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE)
'''  

# Execute the SQL query to get the total sales revenue
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code does not explicitly extract the TotalSales value from the result dataframe, causing it to show the whole dataframe instead of just the total sales revenue. Also, the column name in the result dataframe is 'TotalSales', but the utility function show_to_user expects a dataframe structured explicitly for display. Additionally, although optional, including plotly for visualization would enhance readability.","import pandas as pd
import plotly.express as px

# SQL Query to get total sales revenue generated last month
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
WHERE MONTH(o.OrderDate) = MONTH(DATE_SUB(CURDATE(), INTERVAL 1 MONTH)) 
AND YEAR(o.OrderDate) = YEAR(CURDATE());
'''

# Execute the SQL query
sales_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_df)","The input code has a few issues. First, it attempts to extract sales data without properly adjusting the date condition to reflect the previous month comprehensively. The change in SQL functions to DATE_SUB and CURDATE is a bit confusing for the calculation part. Also, there is a missing condition to check the year for last month (it checks only the current year). Furthermore, the result extraction is not matching with the reference where the total sales revenue is directly extracted and processed.",None
Which employees have handled the most orders? Please visualize the results to highlight the top performers.,"import pandas as pd
import plotly.express as px

# SQL query to get employees who handled the most orders
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrdersHandled 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrdersHandled DESC;
'''

# Execute the SQL query and get the results in a pandas dataframe
df = execute_sql_query(sql_query)

# Validate the structure of the dataframe
df.columns = ['EmployeeID', 'OrdersHandled']

# Create a bar chart to visualize the top performers
fig = px.bar(df, x='EmployeeID', y='OrdersHandled', title='Top Employees by Orders Handled',
             labels={'EmployeeID':'Employee ID', 'OrdersHandled':'Orders Handled'},
             color='OrdersHandled',
             color_continuous_scale=px.colors.sequential.Plasma)

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Retrieve data on employee order counts
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
'''
df_orders = execute_sql_query(sql_query)

# Step 2: Visualize the results
fig = px.bar(df_orders, x='EmployeeID', y='OrderCount',
             title='Top Performing Employees by Order Count',
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'},
             color='OrderCount')

# Step 3: Display the visualization to the user
show_to_user(fig)","The input Python code correctly implements the business analytic request. It retrieves the employee order counts from a SQL database, processes the data into a pandas DataFrame, and visualizes the results using a Plotly bar chart. The SQL query, DataFrame manipulation, and visualization steps all match the reference implementation in terms of functionality. Though there are minor differences in variable names and labels, they do not impact the correctness of the code.","import plotly.express as px

# Define the SQL query to get EmployeeID and order counts
sql_query = 'SELECT EmployeeID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY EmployeeID ORDER BY OrderCount DESC;'

# Execute the SQL query and retrieve the data
employee_orders_df = execute_sql_query(sql_query)

# Check if the dataframe is empty
if not employee_orders_df.empty:
    # Visualize the results using Plotly
    fig = px.bar(employee_orders_df, x='EmployeeID', y='OrderCount', title='Orders Handled by Employee', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})
    
    # Highlight the top performers by coloring the bars
    fig.update_traces(marker_color='indianred')
    fig.update_layout(barmode='group', xaxis_tickangle=-45)
    
    # Show the visualization to the user
    show_to_user(fig)
else:
    show_to_user(""No data available to display."")","The input Python code correctly fulfills the business analytic request to identify employees who have handled the most orders and visualizes the results using a bar chart. It uses the 'execute_sql_query' function to fetch the data and 'show_to_user' to display the results, which meets the Python environment constraints. Though the visualization style is different (coloring in 'indianred' and adjusting layout), it still effectively highlights the top performers.",both
