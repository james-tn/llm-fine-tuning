Business Analytic Request,Ground Truth Code,Generated Code by Base Model,Base Model Explanation,Generated Code by Finetuned Model,Finetuned Model Explanation,Model that got it right
What was the average order value in Q1 of 2023?,"```python
import pandas as pd

# SQL query to get the relevant data
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalValue,
    COUNT(DISTINCT orders.OrderID) AS OrderCount
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Calculate the average order value
data['AvgOrderValue'] = data['TotalValue'] / data['OrderCount']

# Display the result to the user
show_to_user(data[['AvgOrderValue']])
```","```python
sql_query = """"""
SELECT 
    AVG(OrderValue) AS AverageOrderValue
FROM (
    SELECT 
        orders.OrderID,
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS OrderValue
    FROM 
        orders
    JOIN 
        [Order Details] ON orders.OrderID = [Order Details].OrderID
    WHERE 
        orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-04-01'
    GROUP BY 
        orders.OrderID
) AS OrderValues;
""""""

average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","Both code implementations aim to calculate the average order value for Q1 of 2023. The reference code calculates the total sales value and counts distinct orders, then divides total value by order count to find the average order value. The input code calculates the average of individual order values directly. These approaches are logically equivalent since averaging a sum and dividing are commutative operations. Therefore, the input code is correct.","```python
import pandas as pd

# SQL query to get total order value and total orders for Q1 2023
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_value, 
    COUNT(DISTINCT orders.OrderID) AS order_count
FROM orders 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31';
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the average order value
avg_order_value = df['total_value'].iloc[0] / df['order_count'].iloc[0]

# Create a DataFrame to show the result
result_df = pd.DataFrame({'avg_order_value': [avg_order_value]})

# Show the result to the user
show_to_user(result_df)
```","Both implementations follow the same logic to calculate the average order value for Q1 2023. They execute a similar SQL query to fetch the total order value and count of distinct orders within the specified date range. Then, they compute the average order value by dividing the total value by the number of orders. The difference between the two codes lies in variable names and structure, but the logic and calculations are identical.",both
Which products have the lowest units in stock?,"```python
import pandas as pd

# SQL query to get the products with the lowest units in stock
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products 
ORDER BY UnitsInStock ASC 
LIMIT 1;
""""""

# Execute the SQL query
lowest_stock_product_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(lowest_stock_product_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
ORDER BY UnitsInStock ASC
LIMIT 10;
""""""
lowest_units_in_stock = execute_sql_query(sql_query)
show_to_user(lowest_units_in_stock)
```","The input code retrieves the top 10 products with the lowest units in stock due to the LIMIT 10 clause. However, the reference implementation specifies retrieving only the product with the absolutely lowest amount in stock using LIMIT 1. Hence, the input code does not adhere to the same logic.","```python
import pandas as pd

# SQL query to fetch products with lowest units in stock
sql_query = ""SELECT ProductName FROM products ORDER BY UnitsInStock ASC LIMIT 5;""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(products_df['ProductName'])
```","The input code fetches the top 5 products with the lowest units in stock based only on 'ProductName', whereas the reference code fetches the ProductID, ProductName, and UnitsInStock for the single product with the lowest stock.",None
Which customers placed the highest number of orders last year?,"```python
import pandas as pd

# Define the SQL query to retrieve customers with highest orders last year
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY CustomerID 
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_orders)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to find customers with the highest number of orders last year
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 10
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualize the result
fig = px.bar(result_df, x='CustomerID', y='OrderCount', title='Top Customers by Number of Orders Last Year')
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation by querying for customers with the highest number of orders last year. It uses the same SQL query structure to filter orders from the previous year, group by CustomerID, count the orders, and sort them in descending order. The input code also includes a LIMIT clause to show only the top 10 customers, which does not violate the original request and is a reasonable extension. Additionally, while the input code visualizes the result using Plotly instead of simply displaying the data, this visualization step does not alter the correctness concerning answering the business analytics request.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS NumberOfOrders
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
WHERE orders.OrderDate >= DATE('2022-01-01') AND orders.OrderDate <= DATE('2022-12-31')
GROUP BY customers.CustomerID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the results to find the customers with the highest number of orders
df_sorted = df.sort_values(by='NumberOfOrders', ascending=False)

# Display the result
show_to_user(df_sorted)
```","The provided code correctly identifies the customers with the highest number of orders in the previous year. Despite slight differences, like using specific dates instead of YEAR function and including a JOIN, it still aligns logically with the reference code. It retrieves customer orders from last year, groups by customer, counts orders, and sorts by descending order count.",both
Calculate the total revenue generated by each product and visualize it using a bar chart to compare easily.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM 
    [Order Details] od 
INNER JOIN 
    products p ON od.ProductID = p.ProductID 
GROUP BY 
    p.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalRevenue DESC;
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', title='Total Revenue by Product', labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly calculates the total revenue for each product, taking into account discounts, which is a valid detail not mentioned in the reference code but often needed in real-world scenarios. The code then creates a bar chart to visualize the revenue by product, adhering to the business request. The additional details in GROUP BY (ProductID) and ORDER BY (TotalRevenue DESC) do not change the correctness of fulfilling the business requirement. Overall, the input code achieves the same business objective as the reference implementation.","```python
import plotly.express as px

# SQL query to get total revenue per product
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalRevenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart for total revenue by product
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product', labels={'TotalRevenue': 'Total Revenue', 'ProductID': 'Product ID'})

# Display the visualization
show_to_user(fig)
```","The input code calculates total revenue by 'ProductID', whereas the reference implementation computes it by 'ProductName'. Although both might produce similar bar charts if IDs map one-to-one with product names, it's still different as the business request specifies revenue by product name for clarity. The input does not align with the exact grouping criteria specified.",Base
Which customers are from the United States?,"```python
sql_query = ""SELECT CustomerID FROM orders WHERE ShipCountry = 'USA'""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders
WHERE ShipCountry = 'United States'
""""""
customers_us = execute_sql_query(sql_query)
show_to_user(customers_us)
```","The input code filters customers based on 'ShipCountry = United States', while the reference code uses 'ShipCountry = USA'. The country name should match in both cases to ensure the logic is consistent. Further, the input code uses DISTINCT, which is not present in the reference code, but this does not affect correctness assuming correct country names.","```python
import pandas as pd

# SQL Query to get customers from the United States
sql_query = ""SELECT * FROM customers WHERE Country = 'USA';""

# Execute the query and get the result as a pandas dataframe
customers_usa_df = execute_sql_query(sql_query)

# Display the result to the user
data_to_display = customers_usa_df[['CustomerID', 'CompanyName']]
show_to_user(data_to_display)
```","The input code checks for customers in the 'Country' column of the 'customers' table, while the reference code checks for customers using 'ShipCountry' in the 'orders' table. The tables and conditions used are different, leading to potentially different sets of customers.",None
List the products that are being sold at a discount (UnitPrice in orders < UnitPrice in products).,"```python
import pandas as pd

# SQL query to get products sold at a discount
sql_query = """"""
SELECT p.ProductName 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
WHERE od.UnitPrice < p.UnitPrice;
""""""

# Execute the SQL query
discounted_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discounted_products_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitPrice AS OriginalPrice, od.UnitPrice AS DiscountedPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.UnitPrice < p.UnitPrice
""""""
discounted_products = execute_sql_query(sql_query)
show_to_user(discounted_products)
```","The input code correctly identifies products sold at a discount by joining 'products' and 'Order Details' tables on 'ProductID' and filtering where the order 'UnitPrice' is less than the product 'UnitPrice'. Although the code fetches additional columns ('ProductID', 'OriginalPrice', 'DiscountedPrice'), the core logic matches the reference code's intention of identifying discounted products.","```python
import pandas as pd

# SQL Query to get products on discount
sql_query = """"""
SELECT products.ProductID, products.ProductName, products.UnitPrice AS OriginalPrice, 
orders.UnitPrice AS DiscountedPrice 
FROM products 
JOIN [Order Details] orders 
ON products.ProductID = orders.ProductID 
WHERE orders.UnitPrice < products.UnitPrice;
""""""

# Execute the SQL query
discounted_products_df = execute_sql_query(sql_query)

# Display the result
show_to_user(discounted_products_df)
```","The input Python code correctly implements the logic required to list products sold at a discount. Both the reference code and the input code check if the 'UnitPrice' in 'Order Details' is less than 'UnitPrice' in 'products'. The input code includes additional columns ('ProductID', 'OriginalPrice', 'DiscountedPrice'), but this extra information does not violate the business request or logic, thus maintaining correctness.",both
Which employees generated the highest sales revenue in April 2023 and visualize with a bar chart for comparison?,"```python
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.FirstName, employees.LastName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC
'''

# Execute SQL query and get data
data = execute_sql_query(sql_query)

# Create a full name column for ease of visualization
data['FullName'] = data['FirstName'] + ' ' + data['LastName']

# Create the bar chart using Plotly
fig = px.bar(data, x='FullName', y='total_sales', 
             title='Top Employees by Sales Revenue in April 2023',
             labels={'total_sales': 'Total Sales Revenue', 'FullName': 'Employee Name'})

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, 
       employees.FirstName, 
       employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY total_sales DESC
""""""

employee_sales = execute_sql_query(sql_query)

fig = px.bar(employee_sales, 
              x='FirstName', 
              y='total_sales', 
              color='LastName', 
              title='Highest Sales Revenue by Employees in April 2023',
              labels={'FirstName': 'Employee First Name', 'total_sales': 'Total Sales Revenue'})
show_to_user(fig)
```","The input code uses 'FirstName' on the x-axis with colors by 'LastName' instead of combining both into 'FullName' for clear identification. This results in ambiguous data if first names repeat, affecting correct visualization.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * 
(1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY employee_sales DESC
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(
    sales_data, 
    x='EmployeeID', 
    y='employee_sales', 
    text_auto=True,
    title='Employee Sales Revenue in April 2023',
    labels={'employee_sales': 'Sales Revenue', 'EmployeeID': 'Employee ID'}
)

# Show the visualization to the user
show_to_user(fig)
```","The input code does not meet the business requirement to display employee names on the x-axis for comparison. Instead, it uses EmployeeID, making it difficult to identify employees directly from the chart. Additionally, it lacks the creation of a 'FullName' column that combines first and last names for better visualization, which the reference code does.",None
What is the average order value handled by each employee and visualize with a bar chart for employee comparison?,"```python
import plotly.express as px

# Step 1: Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderValue 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Step 2: Execute the SQL query and retrieve the result as a DataFrame
df = execute_sql_query(sql_query)

# Step 3: Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='AvgOrderValue', title='Average Order Value by Employee', labels={'AvgOrderValue': 'Average Order Value', 'EmployeeID': 'Employee ID'})

# Step 4: Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
    COUNT(o.OrderID) AS TotalOrders,
    CASE 
        WHEN COUNT(o.OrderID) = 0 THEN 0 
        ELSE SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(o.OrderID) 
    END AS AverageOrderValue
FROM 
    employees e
LEFT JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
LEFT JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='EmployeeName', y='AverageOrderValue', 
             title='Average Order Value by Employee', 
             labels={'AverageOrderValue': 'Average Order Value', 'EmployeeName': 'Employee'},
             color='AverageOrderValue')

show_to_user(fig)
```","The input code uses a LEFT JOIN instead of an INNER JOIN, which means employees without orders will be included with an average order value of 0. This can differ from the reference logic that considers only employees with orders. The conditional calculation of average order value in the input code accounts for cases with no orders (setting average to 0) and this logic change is not part of the reference implementation.","```python
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderValue
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Execute SQL query and fetch the data
df = execute_sql_query(sql_query)

# Create a bar chart for average order value by employee
fig = px.bar(df, x='EmployeeID', y='AvgOrderValue', title='Average Order Value by Employee', 
             labels={'AvgOrderValue': 'Average Order Value', 'EmployeeID': 'Employee ID'},
             hover_data={'FirstName': True, 'LastName': True})

# Show the result to the user
show_to_user(fig)
```","The input code produces the correct output by calculating the average order value handled by each employee and visualizes it with a bar chart. The logic mirrors the reference implementation: executing a SQL query to aggregate average order values by employee and displaying this data via Plotly. The only difference is the inclusion of FirstName and LastName in the SQL query and as extra information in the hover data of the bar chart, which does not affect the correctness of the required output.",Finetuned
Find the total revenue generated by each product and illustrate using a bar chart.,"```python
import plotly.express as px

# Execute the SQL query to retrieve data
sql_query = """"""
SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue 
FROM [Order Details] 
GROUP BY ProductID;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue',
             title='Total Revenue Generated by Each Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code calculates total revenue using 'ProductName' instead of 'ProductID'. Additionally, it includes discounts in the revenue calculation, which is not present in the reference implementation. While it visualizes the data correctly, it doesn't adhere to the business request and reference logic, which focuses specifically on 'ProductID' and excludes discounts.","```python
import plotly.express as px

# SQL query to retrieve total revenue generated by each product
sql_query = """"""
SELECT products.ProductID, 
       products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS Revenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID, products.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='Revenue', title='Total Revenue by Product', labels={'Revenue': 'Total Revenue'})

# Show the bar chart
show_to_user(fig)
```","The input code correctly calculates the total revenue generated by each product. It uses similar logic to the reference implementation but includes an additional join with the 'products' table to retrieve 'ProductName'. It groups by both 'ProductID' and 'ProductName', which does not affect the total revenue calculation, and creates a bar chart using Plotly, as required. Therefore, the input code adheres to the business analytics request and the logic of the reference implementation.",Finetuned
Calculate the inventory turnover ratio for each month and represent it with a line chart to observe trends.,"```python
import plotly.express as px

# SQL query defined
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) as InventoryTurnoverRatio 
FROM `Order Details` od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Convert Month to datetime for proper plotting
data['Month'] = pd.to_datetime(data['Month'])

# Generate line chart
fig = px.line(data, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    DATE_TRUNC('month', od.OrderDate) AS Month,
    SUM(od.Quantity * od.UnitPrice) AS TotalSales,
    AVG(p.UnitsInStock) AS AverageInventory
FROM
    [Order Details] od
JOIN
    products p ON od.ProductID = p.ProductID
GROUP BY
    Month
ORDER BY
    Month;
""""""

data = execute_sql_query(sql_query)

data['InventoryTurnoverRatio'] = data['TotalSales'] / data['AverageInventory']

fig = px.line(data, x='Month', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio Over Time')
show_to_user(fig)
```","The input Python code correctly calculates the inventory turnover ratio by dividing the total sales by average inventory for each month. Although the SQL syntax is slightly different (e.g., DATE_TRUNC vs DATE_FORMAT, different SQL dialects), the logic matches the reference implementation. It performs grouping by month, calculates total sales and average inventory, computes the ratio, and plots it as a line chart. Thus, it adheres to the specified business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get inventory turnover data per month
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM orders.OrderDate) AS month, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY EXTRACT(MONTH FROM orders.OrderDate)
""""""

# Execute SQL query
inventory_data = execute_sql_query(sql_query)

# Ensure month is treated as a categorical variable for proper ordering in the line chart
inventory_data['month'] = inventory_data['month'].astype(str)

# Create a line chart to visualize inventory turnover ratio by month
fig = px.line(inventory_data, x='month', y='inventory_turnover', title='Inventory Turnover Ratio by Month', labels={'inventory_turnover': 'Inventory Turnover', 'month': 'Month'})

# Display the result
show_to_user(fig)
```","The input code calculates the inventory turnover ratio using only the month extracted from the OrderDate, not considering the year. This results in aggregating data across different years if present, whereas the reference code distinguishes by year and month. Additionally, the reference calculates using DATE_FORMAT(OrderDate, '%Y-%m') preserving order by month and year, while the input uses EXTRACT(MONTH), leading to possible incorrect plotting if data spans multiple years.",Base
Visualize the performance of products based on sales and inventory levels for each month in 2022 using a combination chart.,"```python
import plotly.graph_objects as go
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, 
       MONTH(orders.OrderDate) AS order_month, 
       SUM([Order Details].Quantity) AS product_performance 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, order_month
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Prepare the data for visualization
pivot_df = df.pivot(index=""order_month"", columns=""ProductID"", values=""product_performance"").fillna(0)

# Create a combination chart
fig = go.Figure()

# Add traces for each product
for product_id in pivot_df.columns:
    fig.add_trace(go.Bar(x=pivot_df.index, y=pivot_df[product_id], name=f'Product {product_id}'))

# Set chart title and labels
fig.update_layout(
    title='Product Performance Based on Sales (2022)',
    xaxis_title='Month',
    yaxis_title='Quantity Sold',
    xaxis=dict(tickmode='linear'),
    barmode='stack'
)

# Show the combination chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.graph_objects as go

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS order_month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales,
    SUM(products.UnitsInStock) AS total_inventory
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    YEAR(orders.OrderDate) = 2022 
GROUP BY 
    order_month 
ORDER BY 
    order_month;
""""""

data = execute_sql_query(sql_query)

fig = go.Figure()
fig.add_trace(go.Bar(x=data['order_month'], y=data['total_inventory'], name='Inventory', marker_color='blue'))
fig.add_trace(go.Line(x=data['order_month'], y=data['total_sales'], name='Sales', line=dict(color='red', width=2)))

fig.update_layout(title='Product Performance in 2022',
                  xaxis_title='Month',
                  yaxis_title='Amount',
                  yaxis=dict(title='Total Sales and Inventory', overlaying='y', side='right'),
                  barmode='group')

show_to_user(fig)
```","The input code does not adhere to the same logic as the reference implementation. The reference code visualizes product performance based on the quantity sold for each product by month using a stacked bar chart. The input code, however, plots total inventory and total sales across all products by month using a grouped bar and line chart. The focus and metrics (quantity sold per product vs. total sales and inventory) are different between the two implementations.","To create a combination chart visualizing the performance of products based on sales and inventory levels for each month in 2022, we will use Plotly for generating our visualizations. Hereâ€™s how we can do this step-by-step:

1. Define the SQL query to retrieve necessary data.
2. Execute the SQL query using the provided utility function to get data in a pandas dataframe.
3. Use Plotly to create a combination chart.

Here is the complete Python code to achieve this:

```python
import pandas as pd
import plotly.graph_objects as go

# SQL query to retrieve the sales and inventory data for products in 2022
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalSold, products.UnitsInStock 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE [Order Details].OrderID IN (
    SELECT OrderID FROM orders WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
) 
GROUP BY products.ProductName
'''

# Execute the SQL query to get the data
data_df = execute_sql_query(sql_query)

# Ensure that the data is sorted by TotalSold for better visualization
data_df.sort_values(by='TotalSold', ascending=False, inplace=True)

# Create a bar chart for Total Sold
fig = go.Figure()

fig.add_trace(go.Bar(
    x=data_df['ProductName'],
    y=data_df['TotalSold'],
    name='Total Sold',
    marker_color='blue'
))

# Create a line chart for Inventory Levels on the same plot
fig.add_trace(go.Scatter(
    x=data_df['ProductName'],
    y=data_df['UnitsInStock'],
    name='Units In Stock',
    marker_color='red'
))

# Update layout to improve visualization
fig.update_layout(
    title='Product Performance in 2022',
    xaxis_title='Product Name',
    yaxis_title='Quantity',
    barmode='group',
    hovermode='x unified'
)

# Show the chart to the user
show_to_user(fig)
```

### Explanation of the Code:
- We define the SQL query that retrieves product names, total sold quantities, and units in stock for products sold in 2022.
- We execute the SQL query using the `execute_sql_query` function which is predefined to interact with the database and retrieve data as a pandas DataFrame.
- We create a combination chart using Plotly: a bar chart for total sold quantities and a line plot for inventory levels.
- Finally, we use the `show_to_user` function to display the visualization.

This combination chart effectively shows how each product has performed based on its sales figures (Total Sold) and its current stock levels (Units In Stock).","The input code visualizes sales and inventory in a combination chart using product names, which does not match the monthly analysis required in the reference implementation. It does not calculate performance per month, uses ProductName instead of ProductID, and combines sales with inventory levels differently.",None
What is the total sales revenue generated by each customer and represent it with a bar chart for comparison?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY CustomerID 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='TotalSales', title='Total Sales Revenue by Customer', labels={'CustomerID': 'Customer ID', 'TotalSales': 'Total Sales Revenue'})

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    orders.CustomerID,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    orders.CustomerID
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.bar(total_sales_df, x='CustomerID', y='TotalSales', title='Total Sales Revenue by Customer')
show_to_user(fig)
```","The input Python code correctly calculates the total sales revenue by each customer using SQL. It performs a SQL query to join 'orders' with 'Order Details', aggregates the sales using SUM after calculating each order's revenue, and groups by 'CustomerID'. The calculation logic adheres to that of the reference implementation. The only slight difference is the absence of 'ORDER BY' in the SQL query, but this does not affect the correctness since it doesn't specify any requirement for ordered results. The Plotly bar chart is also constructed similarly, displaying the results correctly using the 'CustomerID' and 'TotalSales'.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS SalesRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID;
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='CustomerID', y='SalesRevenue', title='Total Sales Revenue by Customer')

# Show the chart to the user
show_to_user(fig)
```","Both implementations correctly calculate total sales revenue per customer and group the results accordingly. The reference code's sort operation on TotalSales and different table joins (starting from 'orders') do not affect the correctness in this context. Hence, the provided code fulfills the business request effectively.",both
Which employee has processed the most orders for customers in the USA and visualize the results using a bar chart?,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShipCountry = 'USA' 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC
LIMIT 1;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create bar chart with Plotly
fig = px.bar(df, x='FirstName', y='OrderCount', text='OrderCount', title='Top Employee Processing USA Orders')
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShipCountry = 'USA'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
""""""

top_employee = execute_sql_query(sql_query)

fig = px.bar(top_employee, x='FirstName', y='OrderCount', text='OrderCount',
             title='Top Employee Processing Orders in the USA',
             labels={'FirstName': 'Employee Name', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The provided code follows the same logic as the reference implementation. Both SQL queries count orders processed by employees for customers in the USA, ordering by the highest count and limiting the result to the top employee. The method of visualization with Plotly is similar, using a bar chart to display the results. While there are minor differences in code structure, such as the usage of aliases for tables, the core functionality is the same.","```python
import plotly.express as px

# SQL query to retrieve required data
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS US_orders
FROM employees
INNER JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE orders.ShipCountry = 'USA'
GROUP BY employees.EmployeeID
ORDER BY US_orders DESC
LIMIT 1
""""""

# Execute the SQL query
data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data_df, x='EmployeeID', y='US_orders', title='Employee with Most USA Orders')

# Display the figure to the user
show_to_user(fig)
```","The provided code does not include employee's first and last names, which are part of the reference implementation's output. Instead, it only retrieves 'EmployeeID', which does not fully satisfy the business request. Consequently, the bar chart does not label the employee accurately in line with the requirement to show the employee's name.",Base
Which product had the highest sales quantity in the last month and use a bar chart to compare top-selling products?,"```python
import plotly.express as px

# SQL query to get top-selling products
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Find the product with the highest sales quantity
top_product = data.head(1)

# Display the top product details
show_to_user(top_product)

# Create a bar chart to compare top-selling products
fig = px.bar(data.head(10), x='ProductName', y='TotalQuantity', title='Top-Selling Products in the Last Month')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

last_month_start = (datetime.now() - pd.DateOffset(months=1)).replace(day=1).date()
last_month_end = (datetime.now() - pd.DateOffset(days=1)).replace(day=1).date()

sql_query = f""""""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT DISTINCT OrderID
    FROM [Order Details]
    WHERE OrderDate BETWEEN '{last_month_start}' AND '{last_month_end}'
)
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC
""""""

top_selling_products = execute_sql_query(sql_query)

highest_sales_product = top_selling_products.iloc[0]
fig = px.bar(top_selling_products, x='ProductName', y='TotalQuantity', 
             title='Top Selling Products in the Last Month', 
             labels={'TotalQuantity': 'Sales Quantity', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code uses different logic to filter orders: it selects OrderIDs based on a BETWEEN condition using last month's start and end dates, which could potentially exclude orders on the last day of the month. The reference code uses a single DATE_SUB condition ensuring coverage of the last month. Correcting this would ensure the logic matches the specified timeframe accurately. Additionally, the input doesn't show highest sales product details, which the reference does.","```python
import pandas as pd
import plotly.express as px

# SQL query to get top-selling products
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].Quantity) AS TotalQuantitySold 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
GROUP BY products.ProductID, products.ProductName;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Find the product with the highest sales quantity
highest_sales_product = sales_data.loc[sales_data['TotalQuantitySold'].idxmax()]

# Output the product with the highest sales quantity
show_to_user(highest_sales_product)

# Create a bar chart to compare top-selling products
fig = px.bar(sales_data, x='ProductName', y='TotalQuantitySold', 
             title='Sales Quantity by Product in the Last Month', 
             labels={'TotalQuantitySold': 'Total Quantity Sold', 'ProductName': 'Product Name'})

# Show the chart to the user
show_to_user(fig)
```","Both implementations achieve the same goal: determining the product with the highest sales quantity in the last month and presenting the top-selling products in a bar chart. The differences in SQL syntax do not affect the final result as both correctly filter the data for the last month and aggregate sales. The reference implementation explicitly orders by TotalQuantity, while the input code uses idxmax(). In practice, the result is the same: identifying the top-selling product and visualizing the top products in a bar chart. Both use Plotly Express to generate the chart and display similar information.",Finetuned
"For each employee, what is the average number of orders handled per month in 2023 and visualize the results with a bar chart?","```python
import plotly.express as px

# SQL query to get the average number of orders per month per employee in 2023
sql_query = """"""
SELECT employees.EmployeeID, AVG(order_count) AS avg_orders_per_month 
FROM (
    SELECT employees.EmployeeID, COUNT(orders.OrderID) AS order_count, 
    MONTH(orders.OrderDate) AS order_month 
    FROM employees 
    LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID 
    WHERE YEAR(orders.OrderDate) = 2023
    GROUP BY employees.EmployeeID, MONTH(orders.OrderDate)
) AS temp 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='avg_orders_per_month', 
             title='Average Number of Orders per Month for Each Employee in 2023', 
             labels={'avg_orders_per_month': 'Avg Orders per Month', 'EmployeeID': 'Employee ID'})

# Show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, 
       employees.FirstName, 
       employees.LastName, 
       COUNT(orders.OrderID) AS total_orders,
       MONTH(orders.OrderDate) AS order_month
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY employees.EmployeeID, order_month
""""""

order_data = execute_sql_query(sql_query)

average_orders_per_month = order_data.groupby(['EmployeeID', 'FirstName', 'LastName']).agg({'total_orders': 'mean'}).reset_index()

fig = px.bar(average_orders_per_month, 
             x='FirstName' + ' ' + 'LastName', 
             y='total_orders', 
             title='Average Orders Handled per Month in 2023', 
             labels={'total_orders': 'Average Orders Per Month', 'FirstName + LastName': 'Employee'},
             text='total_orders')

show_to_user(fig)
```","The input code incorrectly concatenates 'FirstName' and 'LastName' for the 'x' axis, causing a syntax error. It also uses 'JOIN' instead of 'LEFT JOIN', potentially excluding employees with no orders. The group-by mechanism aligns with the reference, but executing 'COUNT' directly without a subquery may lead to unintended results, making it logically inconsistent.","```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    employees.FirstName, 
    employees.LastName, 
    COUNT(orders.OrderID) / 12 AS AvgOrdersPerMonth 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data_df, x='EmployeeID', y='AvgOrdersPerMonth', 
             hover_data={'FirstName': True, 'LastName': True}, 
             labels={'AvgOrdersPerMonth': 'Avg Orders/Month'},
             title='Average Number of Orders Handled per Month by Employee in 2023')

# Show the visualization to the user
show_to_user(fig)
```","The provided code divides the total count of orders by 12, which assumes all employees handled orders in every month of 2023. This approach doesn't account for employees who might not have handled orders every month, unlike the reference code which calculates the average per month per employee by considering only the months they actually worked. This can lead to inaccurate averages if an employee didn't handle orders in every month of 2023.",None
How many discontinued products are still in stock?,"```python
import pandas as pd

# SQL query to find discontinued products still in stock
sql_query = ""SELECT COUNT(*) AS DiscontinuedInStock FROM products WHERE Discontinued = 1 AND UnitsInStock > 0;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Extract the count from the dataframe
discontinued_in_stock = df['DiscontinuedInStock'].iloc[0]

# Display the result to the user
show_to_user(discontinued_in_stock)
```","```python
sql_query = """"""
SELECT SUM(UnitsInStock) AS TotalUnitsInStock
FROM products
WHERE Discontinued = 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code calculates the total stock of discontinued products using SUM(UnitsInStock), whereas the reference code counts the number of discontinued products that have stock (UnitsInStock > 0). The input code doesn't filter for products with UnitsInStock > 0, leading to a different logic and output than the reference implementation.","```python
import pandas as pd

# SQL query to find discontinued products that are still in stock
sql_query = """"""
SELECT products.ProductName 
FROM products 
WHERE products.Discontinued = 1 AND products.UnitsInStock > 0;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
discontinued_in_stock_df = execute_sql_query(sql_query)

# Count the number of discontinued products in stock
count_discontinued_in_stock = discontinued_in_stock_df.shape[0]

# Create a DataFrame to display the count
result_df = pd.DataFrame({
    'count_discontinued_in_stock': [count_discontinued_in_stock]
})

# Show the count result to the user
show_to_user(result_df)
```","The input code correctly implements the logic to find the number of discontinued products that are still in stock. It retrieves the product names where 'Discontinued' equals 1 and 'UnitsInStock' is greater than 0, counts these products, and then displays the count. This matches the logical output of the reference code, which also counts the discontinued products still in stock.",Finetuned
Determine the most frequently used shipping method.,"```python
import pandas as pd

# SQL query to get the most frequently used shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UseCount
FROM orders
GROUP BY ShipVia
ORDER BY UseCount DESC
LIMIT 1;
""""""

# Execute SQL query
most_used_shipping_method_df = execute_sql_query(sql_query)

# Display the result
show_to_user(most_used_shipping_method_df)
```","```python
sql_query = """"""
SELECT ShipVia, COUNT(*) as frequency
FROM orders
GROUP BY ShipVia
ORDER BY frequency DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code is correct. It follows the same logic as the reference implementation by selecting 'ShipVia' and its frequency using COUNT. The code groups by 'ShipVia', orders by frequency in descending order, and limits the result to the top one, which effectively determines the most frequently used shipping method.","```python
import pandas as pd

# Execute SQL query to retrieve necessary data
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS NumberOfOrders
FROM orders 
GROUP BY ShipVia 
ORDER BY NumberOfOrders DESC;
""""""
df = execute_sql_query(sql_query)

# Extract the most frequently used shipping method
most_frequent_shipping_method = df.iloc[0]

# Display the result to the user
show_to_user(most_frequent_shipping_method)
```","The input code correctly retrieves the most frequently used shipping method by executing an SQL query that orders the shipping methods by the number of uses in descending order. It then extracts the first record, which corresponds to the shipping method with the highest count. This approach aligns well with the logic of the reference implementation, which also sorts by count and limits to the top result.",both
Which products have not been ordered in the last three months?,"```python
import pandas as pd

# Define the correct SQL query
sql_query = """"""
SELECT ProductName FROM products 
WHERE ProductID NOT IN (
  SELECT DISTINCT ProductID 
  FROM `Order Details` 
  WHERE OrderID IN (
    SELECT OrderID 
    FROM orders 
    WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
  )
);
""""""

# Execute the SQL query
products_not_ordered_df = execute_sql_query(sql_query)

# Display the result
show_to_user(products_not_ordered_df)
```","```python
from datetime import datetime, timedelta

# Calculate the date three months ago from today
three_months_ago = datetime.now() - timedelta(days=90)
three_months_ago_str = three_months_ago.strftime('%Y-%m-%d')

# SQL query to find products that have not been ordered in the last three months
sql_query = f""""""
SELECT p.ProductID, p.ProductName 
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.OrderID IS NULL OR od.OrderID NOT IN (
    SELECT OrderID 
    FROM [Order Details] 
    WHERE OrderID IN (
        SELECT DISTINCT OrderID 
        FROM [Order Details]
        WHERE OrderDate >= '{three_months_ago_str}'
    )
)
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The provided code has a logical issue. It uses a LEFT JOIN with the condition 'od.OrderID IS NULL' to filter products not linked to orders. However, it incorrectly assumes that missing orders in the last 3 months can be identified by checking OrderID from [Order Details]. The reference code correctly uses two steps: finding 'OrderID' within the last 3 months in 'orders' table and then checking 'ProductID' in 'Order Details'. The evaluated code misinterprets this logic by directly checking 'OrderDate' in 'Order Details', which can lead to incorrect results.","```python
import pandas as pd

# SQL Query to find products not ordered in the last three months
sql_query = """"""
SELECT products.ProductID, products.ProductName 
FROM products 
LEFT JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].ProductID IS NULL OR [Order Details].OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH);
""""""

# Execute the SQL query
df_products_not_ordered = execute_sql_query(sql_query)

# Column renaming or specific filtering if needed
df_products_not_ordered = df_products_not_ordered.rename(columns={""ProductID"": ""ID""})

# Show the results
show_to_user(df_products_not_ordered)
```","The input code incorrectly attempts to identify products not ordered by relying on a LEFT JOIN and checking if OrderDetails.ProductID is NULL or the order date is within three months. This logic is flawed because we want products that haven't been ordered at all in the last three months, not those ordered recently or having NULL references. The reference uses a NOT IN clause correctly to exclude products that have orders in the specified timeframe.",None
What is the average Inventory Turnover Ratio for each month and visualize it using a line chart to show trends?,"```python
import plotly.express as px

# SQL query to calculate Inventory Turnover Ratio
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'Month' to datetime for proper plotting
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart to visualize the trend of Inventory Turnover Ratio
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Average Inventory Turnover Ratio per Month')

# Display the visualization to the user
show_to_user(fig)
```","```python
# SQL query to calculate the average Inventory Turnover Ratio per month
sql_query = """"""
SELECT
    DATE_TRUNC('month', O.OrderDate) AS Month,
    SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS Inventory_Turnover_Ratio
FROM
    [Order Details] OD
JOIN
    products P ON OD.ProductID = P.ProductID
JOIN
    orders O ON OD.OrderID = O.OrderID
GROUP BY
    DATE_TRUNC('month', O.OrderDate)
ORDER BY
    Month;
""""""

# Execute the SQL query to retrieve the data
average_itr_df = execute_sql_query(sql_query)

# Visualize the trends of the Inventory Turnover Ratio using a line chart
import plotly.express as px

fig = px.line(average_itr_df, x='Month', y='Inventory_Turnover_Ratio', 
              title='Average Inventory Turnover Ratio per Month',
              labels={'Inventory_Turnover_Ratio': 'Inventory Turnover Ratio', 'Month': 'Month'})

show_to_user(fig)
```","The input code correctly calculates the average Inventory Turnover Ratio for each month using a SQL query similar to the reference implementation. It groups the data by month and calculates the turnover ratio using `SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock)`. The use of `DATE_TRUNC('month', O.OrderDate)` in the input code is equivalent to `DATE_FORMAT(OrderDate, '%Y-%m')` in the reference instruction, meaning it effectively groups the data by month. Both implementations display the result using a line chart with plotly.express's `px.line`, fulfilling the business analytics request.","```python
import plotly.express as px

# SQL Query to retrieve data for the past 12 months
sql_query = """"""
SELECT 
    DATE_FORMAT(O.OrderDate, '%Y-%m') AS Month, 
    SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS InventoryTurnoverRatio 
FROM 
    products P 
JOIN 
    [Order Details] OD ON P.ProductID = OD.ProductID 
JOIN 
    orders O ON OD.OrderID = O.OrderID 
WHERE 
    O.OrderDate >= DATE_SUB(NOW(), INTERVAL 12 MONTH) 
GROUP BY 
    Month;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Ensure proper data type for Month for visualization
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart to visualize the Inventory Turnover Ratio trends
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Average Inventory Turnover Ratio per Month')

# Show the visualization to the user
show_to_user(fig)
```","The input code restricts data to the past 12 months using the `WHERE` clause, which is not present in the reference implementation. This changes the dataset and potentially the output, as it excludes data outside this period. The reference code does not limit the data by date, calculating the Inventory Turnover Ratio for all available months instead. Thus, the logic differs.",Base
List the top 5 employees with the highest salaries.,"```python
import pandas as pd

# SQL Query to get the top 5 employees with the highest salaries
sql_query = """"""
SELECT EmployeeID, FirstName, LastName, Salary 
FROM employees 
ORDER BY Salary DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_employees_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(top_employees_df)
```","```python
sql_query = """"""
SELECT FirstName, LastName, Salary
FROM employees
ORDER BY Salary DESC
LIMIT 5
""""""

top_employees = execute_sql_query(sql_query)
show_to_user(top_employees)
```","The input code generates the list of the top 5 employees with the highest salaries, similar to the reference implementation. Although the reference code includes 'EmployeeID' in the SELECT clause, it is not explicitly required by the business request. Both implementations adhere to the same logic by ordering the salaries in descending order and limiting the results to 5.","```python
import pandas as pd

# SQL query to get the top 5 employees with the highest salaries
sql_query = """"""
SELECT e.FirstName, e.LastName, e.Salary 
FROM employees e 
ORDER BY e.Salary DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_employees_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(top_employees_df)
```","The input code correctly retrieves the top 5 employees with the highest salaries and displays their FirstName, LastName, and Salary. The reference implementation also retrieves the EmployeeID, but this is not critical to fulfill the business request, which is to list the top 5 employees by salary. Therefore, the input code adheres to the same logic as the reference code and correctly satisfies the request.",both
What's the average discount applied to products?,"```python
import pandas as pd

# SQL query to get the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the average discount
average_discount = result_df['AverageDiscount'].iloc[0]
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
""""""
average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code correctly executes the SQL query to calculate the average discount from the 'Order Details' table and displays the result using 'show_to_user'. It follows the same logical steps as the reference code: forming the SQL query, executing it, and showing the result. The methods and the logic align with the reference implementation's purpose.","```python
import pandas as pd

# SQL Query to get the average discount
sql_query = ""SELECT AVG(DISTINCT discounts.discount) AS AvgDiscount FROM discounts;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the average discount
avg_discount = df['AvgDiscount'].iloc[0]
show_to_user(pd.DataFrame({'AvgDiscount': [avg_discount]}))
```","The provided code queries the average of distinct discount values from a table named 'discounts', which is different from the 'Order Details' table referenced. Additionally, taking an average of distinct discount values does not align with simply averaging all discount values across records, which was the intended logic in the reference implementation.",Base
Calculate the total sales revenue generated each month and illustrate with a line chart.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
GROUP BY Month;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Ensure 'Month' is in datetime format for correct plotting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Create a line chart
fig = px.line(sales_data, x='Month', y='MonthlySales', title='Monthly Sales Revenue', labels={'MonthlySales': 'Sales Revenue', 'Month': 'Month'})

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.line(total_sales_df, x='Month', y='TotalSales', title='Total Sales Revenue Each Month')
show_to_user(fig)
```","The input code effectively follows the same logic as the reference implementation. It queries the total monthly sales revenue by calculating the sum of unit prices multiplied by quantities and adjusted for discounts. It then uses Plotly to create a line chart, which matches the visual requirement. Differences such as the use of square brackets for table names and column names do not affect the logic. Moreover, both codes order the months and visualize the data appropriately, fulfilling the business analytics request.","```python
import plotly.express as px

# SQL query to get total sales revenue per month
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS order_month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY order_month;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Correct column names if needed (this step depends on the actual result of the SQL query execution)
df.columns = df.columns.str.strip()

# Create a line chart of total sales revenue per month
fig = px.line(df, x='order_month', y='total_sales', title='Total Sales Revenue by Month')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code successfully executes a SQL query to calculate total sales revenue by month, using the same logical components as the reference implementation. It joins the 'orders' and 'Order Details' tables, formats the date, and sums the revenue with discounts applied. The minor differences, such as SQL syntax adaptation using square brackets and renaming the columns for clarity, do not affect the logical correctness. The visualization created with Plotly Express is consistent, plotting a line chart of monthly sales revenue, fulfilling the business analytics request.",both
What percentage of orders were shipped after the required date each month and visualize the trends with a bar chart.,"```python
import plotly.express as px

# SQL query to get the percentage of late deliveries each month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) / COUNT(OrderID) AS LateDeliveryRate 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure LateDeliveryRate is in percentage format for plotting
df['LateDeliveryRate'] *= 100

# Create a bar chart to visualize the trend of late delivery rates
fig = px.bar(df, x='Month', y='LateDeliveryRate', 
             title='Monthly Late Delivery Rate',
             labels={'LateDeliveryRate': 'Late Delivery Rate (%)', 'Month': 'Month'})

# Use the defined utility function to display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate > RequiredDate THEN 1 ELSE 0 END) AS LateShipments
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

df = execute_sql_query(sql_query)
df['LateShipmentPercentage'] = (df['LateShipments'] / df['TotalOrders']) * 100

fig = px.bar(df, x='Month', y='LateShipmentPercentage', 
             title='Percentage of Orders Shipped After Required Date by Month',
             labels={'LateShipmentPercentage': 'Late Shipment Percentage', 'Month': 'Month'})

show_to_user(fig)
```","The input Python code correctly calculates the percentage of late shipments each month. It implements logic equivalent to the reference code by counting total orders and late shipments, and then computes the late shipment percentage. The bar chart is formatted to display this trend, aligning with the business request to visualize the percentage of orders shipped after the required date. Although structured slightly differently, the input code logically aligns with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) FILTER (WHERE ShippedDate > RequiredDate) * 100.0 / COUNT(OrderID) AS OnTimeShippingRate
FROM orders
GROUP BY Month;
""""""

# Execute query and retrieve data
data = execute_sql_query(sql_query)

# Sort data by Month for correct plotting order
data['Month'] = pd.to_datetime(data['Month'])
data = data.sort_values('Month')

# Visualization
fig = px.bar(data, x='Month', y='OnTimeShippingRate', title='Percentage of Orders Shipped After Required Date per Month', labels={'OnTimeShippingRate': 'On-Time Shipping Rate (%)', 'Month': 'Month'})
show_to_user(fig)
```","The SQL query in the input code calculates the 'OnTimeShippingRate' using a filter for late shipments and a division to express the result as a percentage. This naming is confusing because it actually represents late shipments, not on-time ones. Furthermore, the reference code calculates 'LateDeliveryRate' directly and converts it to a percentage separately, ensuring clarity. The input code should have maintained consistent naming and order of operations in translating late shipments to a percentage to align with the reference implementation's logic.",Base
Which shipping method was used most frequently?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount
FROM orders
GROUP BY ShipVia
ORDER BY UsageCount DESC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if result_df is not empty before showing to user
if not result_df.empty:
    show_to_user(result_df)
else:
    show_to_user(pd.DataFrame({""Message"": [""No data found""]}))
```","```python
sql_query = """"""
SELECT ShipVia, COUNT(*) as Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
LIMIT 1
""""""

most_frequent_shipping_method = execute_sql_query(sql_query)
show_to_user(most_frequent_shipping_method)
```","Both implementations answer the given business analytics request by identifying the most frequently used shipping method. The input code defines a SQL query that selects the shipping method ('ShipVia') along with its frequency ('COUNT(*) as Frequency'), groups by 'ShipVia', orders by frequency in descending order, and limits the result to one record, which matches the logic of the reference code. The procedural steps of executing the SQL query and displaying the result are functionally equivalent, even though the variable names ('most_frequent_shipping_method' vs. 'result_df') differ. Therefore, the input code is correct.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipVia, COUNT(*) as Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
LIMIT 1;
""""""

# Execute the SQL query to get the most frequently used shipping method
result_df = execute_sql_query(sql_query)

# Show the result to the user, assuming single value DataFrame
show_to_user(result_df.iloc[0])
```","The input code correctly answers the business analytics request by selecting the most frequently used shipping method. It uses a SQL query to count the occurrences per shipping method, orders the results in descending order of frequency, and limits the output to the top entry. This logic matches the reference implementation. Both the input code and reference code use appropriate SQL aggregation and ordering to determine the most used shipping method. The final display of the result also aligns with the intent of the task, provided the database access part (execute_sql_query function) works as expected.",both
What is the customer retention rate from January 2022 to January 2023 and visualize retention trend with a line graph.,"```python
import plotly.express as px
import pandas as pd

# SQL queries to get unique customer counts
query_retained_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS retained_customers_count
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2023-01-01'
AND orders.CustomerID IN (
    SELECT DISTINCT CustomerID
    FROM orders
    WHERE orders.OrderDate < '2022-01-01'
)
""""""

query_existing_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS existing_customers_count
FROM orders
WHERE orders.OrderDate < '2022-01-01'
""""""

# Execute the queries
retained_customers_df = execute_sql_query(query_retained_customers)
existing_customers_df = execute_sql_query(query_existing_customers)

# Calculate retention rate
retained_customers = retained_customers_df['retained_customers_count'].iloc[0]
existing_customers = existing_customers_df['existing_customers_count'].iloc[0]
retention_rate = retained_customers / existing_customers if existing_customers != 0 else 0

# Create a pandas DataFrame for visualization
data = {
    'Date Range': ['2022-01 to 2023-01'],
    'Retention Rate': [retention_rate]
}
retention_df = pd.DataFrame(data)

# Visualization using Plotly
fig = px.line(retention_df, x='Date Range', y='Retention Rate', title='Customer Retention Rate Trend')

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

start_date = '2022-01-01'
end_date = '2023-01-31'

sql_retention = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS order_month,
    COUNT(DISTINCT CustomerID) AS returning_customers
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '{start_date}' AND '{end_date}' 
  AND 
    CustomerID IN (SELECT DISTINCT CustomerID FROM orders WHERE OrderDate < '{start_date}')
GROUP BY 
    order_month
""""""

sql_total_customers = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS order_month,
    COUNT(DISTINCT CustomerID) AS total_customers
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY 
    order_month
""""""

df_retention = execute_sql_query(sql_retention)
df_total = execute_sql_query(sql_total_customers)

df_merged = pd.merge(df_retention, df_total, on='order_month', how='outer', suffixes=('_retention', '_total'))
df_merged['retention_rate'] = df_merged['returning_customers'] / df_merged['total_customers']

fig = px.line(df_merged, x='order_month', y='retention_rate', title='Customer Retention Rate Trend', labels={'retention_rate': 'Retention Rate'})
show_to_user(fig)
```","The input code calculates the retention rate monthly between January 2022 and January 2023, whereas the reference implementation calculates the retention rate for the entire period. To match the reference, the input code should compare retained customers from January 2022 to January 2023 to the existing customers before January 2022, not break it down monthly.","```python
import pandas as pd
import plotly.express as px

# Execute SQL queries to get the necessary data
past_customers_df = execute_sql_query(""""""
    SELECT COUNT(DISTINCT CustomerID) as CustomerCount 
    FROM orders 
    WHERE OrderDate BETWEEN '2021-01-01' AND '2021-12-31'
"""""")

current_customers_df = execute_sql_query(""""""
    SELECT COUNT(DISTINCT CustomerID) as CustomerCount 
    FROM orders 
    WHERE OrderDate BETWEEN '2022-01-01' AND '2023-01-31'
"""""")

# Calculate retention rates
past_customers_count = past_customers_df['CustomerCount'].iloc[0]
current_customers_count = current_customers_df['CustomerCount'].iloc[0]

# Calculate retention rate
retention_rate = current_customers_count / past_customers_count if past_customers_count != 0 else 0

# Create a DataFrame for visualization
retention_trend_df = pd.DataFrame({
    'Date': ['2022-01', '2023-01'],
    'RetentionRate': [current_customers_count / past_customers_count, current_customers_count / past_customers_count]  # Placeholder
})

# Generate a line graph
fig = px.line(retention_trend_df, x='Date', y='RetentionRate', title='Customer Retention Rate Trend')
show_to_user(fig)
```","The input code calculates retention based on two distinct ranges: 2021 for previous customers and 2022-2023 for current. It fails to correctly identify retained customers, who should have made purchases both before and during 2022 to 2023, as shown in the reference implementation. Additionally, retention rate and the time periods in the input are wrongly implemented.",None
What is the average order value for the year 2021?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) AS OrderValue,
    orders.OrderID
FROM 
    orders 
JOIN 
    [Order Details] 
ON 
    orders.OrderID = [Order Details].OrderID 
WHERE 
    YEAR(orders.OrderDate) = 2021;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate average order value
average_order_value = result_df.groupby('OrderID')['OrderValue'].sum().mean()

# Show the result to the user
show_to_user(pd.DataFrame({'AverageOrderValue': [average_order_value]}))
```","```python
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = 2021
""""""

average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","Both implementations calculate the average order value for 2021, but they do so differently. The reference code determines the order values first and then calculates their average by grouping and summing. The input code simplifies this by calculating the total order value and then dividing by the distinct order count directly in SQL. Despite the different approaches, both correctly compute the average for the orders in 2021, adhering to the same business logic.","```python
import pandas as pd

# Define the SQL query to get the average order value for the year 2021
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2021-01-01' AND '2021-12-31';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average order value from the result dataframe
avg_order_value = result_df['AvgOrderValue'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'AvgOrderValue': [avg_order_value]}))
```","Both implementations calculate the average order value for orders placed in 2021. The reference code calculates individual order values and then takes the average, while the evaluated code calculates the sum of all order values divided by the number of orders directly in SQL. Despite different methods, both achieve the same outcome, thus fulfilling the business request accurately.",both
Identify the top 3 products with the most number of orders and illustrate with a bar chart.,"```python
import plotly.express as px

# SQL query to retrieve top 3 products with most orders
sql_query = """"""
SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) AS NumberOfOrders
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY NumberOfOrders DESC
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductName', y='NumberOfOrders', title='Top 3 Products with Most Orders')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 3 products with the most number of orders
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrders
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrders DESC
LIMIT 3
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductName', y='TotalOrders', title='Top 3 Products with Most Number of Orders')
show_to_user(fig)
```","The input Python code uses SUM(od.Quantity) instead of COUNT(od.OrderID) to determine the top 3 products, which results in a different calculation (total quantity instead of number of orders). This does not adhere to the logic specified in the business request and reference implementation.","```python
import plotly.express as px

# Retrieve data from the data warehouse
query = """"""
SELECT ProductID, COUNT(*) AS OrderCount 
FROM `Order Details` 
GROUP BY ProductID 
ORDER BY OrderCount DESC 
LIMIT 3;
""""""
df = execute_sql_query(query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='OrderCount', title='Top 3 Products with Most Orders', labels={'OrderCount': 'Number of Orders'})

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code retrieves the ProductID and its order count, but does not retrieve the ProductName, which is included in the reference implementation. Moreover, the input code uses only the 'Order Details' table without joining to the 'products' table to get the product names, which means the bar chart will show ProductIDs instead of ProductNames. Therefore, it doesn't adhere to the same logic as the reference implementation.",None
What are the average monthly sales generated by each region and present with a multi-line chart for each region.,"```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT territories.RegionID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) /
       COUNT(DISTINCT DATE_TRUNC('month', orders.OrderDate)) AS avg_monthly_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
GROUP BY territories.RegionID
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Multi-line chart
fig = px.line(df, x=df.index, y='avg_monthly_sales', color='RegionID', title='Average Monthly Sales by Region')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS month,
    customers.Region,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
GROUP BY 
    month, customers.Region
ORDER BY 
    month, customers.Region
""""""

df = execute_sql_query(sql_query)

avg_monthly_sales = df.groupby('Region').mean().reset_index()
fig = px.line(avg_monthly_sales, x='month', y='total_sales', color='Region', title='Average Monthly Sales by Region')
show_to_user(fig)
```","The input Python code computes total sales and attempts to group by month and region, while the requirement is to calculate average monthly sales for each region, similar to the reference implementation. Additionally, the plotting in the input code uses 'month' as x-axis, which doesn't match the requirement for average monthly sales per region. The reference uses only RegionID for grouping and divides total sales by the count of distinct months, which is absent in the input.","```python
import plotly.graph_objs as go
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT region.region_description, 
       DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
JOIN region ON customers.Region = region.RegionID 
GROUP BY region.region_description, month
ORDER BY region.region_description, month
""""""

# Execute the SQL query
df_sales = execute_sql_query(sql_query)

# Calculate the average monthly sales per region
df_avg_sales = df_sales.groupby('region_description').agg({'total_sales': 'mean'}).reset_index()

# Create a multi-line chart for average monthly sales by region
lines = []
regions = df_sales['region_description'].unique()
for region in regions:
    region_data = df_sales[df_sales['region_description'] == region]
    lines.append(go.Scatter(
        x=region_data['month'],
        y=region_data['total_sales'],
        mode='lines',
        name=region
    ))

figure = go.Figure(data=lines)
figure.update_layout(title='Average Monthly Sales by Region',
                     xaxis_title='Month',
                     yaxis_title='Total Sales')

# Display the chart
show_to_user(figure)
```","The input code incorrectly calculates total sales per month and finds the mean across all months for each region, which does not match the reference implementationâ€™s logic. The reference code calculates average monthly sales by aggregating total sales and dividing by distinct months. It also incorrectly matches regions via the customers table instead of employee territories.",None
Find the order with the highest discount applied.,"```python
import pandas as pd

# SQL query to find the order with the highest discount
sql_query = ""SELECT OrderID, MAX(Discount) as MaxDiscount FROM [Order Details] GROUP BY OrderID ORDER BY MaxDiscount DESC LIMIT 1;""

# Execute the SQL query and retrieve the data
order_with_max_discount = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_with_max_discount)
```","```python
sql_query = """"""
SELECT OrderID, SUM(Quantity * Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY OrderID
ORDER BY TotalDiscount DESC
LIMIT 1
""""""

highest_discount_order = execute_sql_query(sql_query)
show_to_user(highest_discount_order)
```","The input code calculates the order with the highest total discount by summing 'Quantity * Discount' for each order, whereas the reference implementation finds the order with the single highest discount applied to any order item. These are different metrics, leading to potentially different results.","```python
import pandas as pd

# SQL query to get the order with the highest discount
sql_query = """"""
SELECT orders.OrderID, MAX([Order Details].Discount) as HighDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY orders.OrderID 
ORDER BY HighDiscount DESC 
LIMIT 1;
""""""

# Execute the query
highest_discount_order = execute_sql_query(sql_query)

# Display the result
show_to_user(highest_discount_order)
```","The input code correctly identifies the order with the highest discount. It includes a join operation between 'orders' and '[Order Details]' tables, which still appropriately groups by 'OrderID' and orders by 'HighDiscount' in descending order, returning the top result. Although there is an extra join operation compared to the reference, the logic and outcome remain consistent with the original intent.",Finetuned
Calculate the monthly total sales revenue over the last year and plot with a time series line chart.,"```python
import plotly.express as px

# SQL query to fetch monthly total sales revenue over the last year
sql_query = """"""
SELECT MONTH(o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1
GROUP BY MONTH(o.OrderDate) 
ORDER BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Plot the time series line chart
fig = px.line(df, x='Month', y='TotalSales', labels={'Month': 'Month', 'TotalSales': 'Total Sales Revenue'},
              title='Monthly Total Sales Revenue Over the Last Year')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS OrderMonth,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year'
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.line(total_sales_df, x='OrderMonth', y='TotalSales', title='Monthly Total Sales Revenue Over Last Year')
show_to_user(fig)
```","The input code correctly calculates the monthly total sales revenue over the last year. The difference between the two codes lies in the date filtering and grouping method. The reference code filters sales for the previous year using YEAR() and groups by MONTH(), whereas the input code truncates the date to the month for the current date one year back using DATE_TRUNC() and INTERVAL '1 year'. Both methods correctly capture the monthly sales for the last year. The plotting logic remains consistent with the task description.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY month
ORDER BY month;
""""""

# Execute the SQL Query
sales_data = execute_sql_query(sql_query)

# Plot using plotly
fig = px.line(sales_data, x='month', y='total_sales', title='Monthly Total Sales Revenue Over the Last Year')

# Show to user
show_to_user(fig)
```","The input code calculates monthly sales revenue based on the last 12 months from the current date, rather than specifically the previous calendar year. The SQL for the input code uses 'CURDATE() - INTERVAL 1 YEAR' which could include part of the current year if the execution date is not at the year start. The reference code correctly calculates for the entire previous calendar year using 'YEAR(CURRENT_DATE) - 1'.",Base
How many units are currently in stock for each product?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitsInStock FROM products;""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Display the data to user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0
""""""
units_in_stock_df = execute_sql_query(sql_query)
show_to_user(units_in_stock_df)
```","The input code filters products that are not discontinued (`WHERE Discontinued = 0`), which is not present in the reference code. The business request asks for the stock of each product without any condition on whether they are discontinued. Therefore, the input code is more restrictive than the reference implementation, making it incorrect according to the given business analytics request.","```python
import pandas as pd

# SQL query to retrieve data
sql_query = ""SELECT ProductName, UnitsInStock FROM products;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(df)
```","The input code accurately executes the task of retrieving the 'ProductName' and 'UnitsInStock' from the 'products' table using a SQL query, similar to the reference implementation. It also correctly displays the resulting DataFrame to the user. Thus, it adheres to the same logic and achieves the same result as required.",Finetuned
List employees who have birthdays in the current month.,"```python
from datetime import datetime
import pandas as pd

# Fetch current month
current_month = datetime.now().month

# Define the SQL query
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
WHERE MONTH(e.BirthDate) = {current_month};
""""""

# Execute SQL query
employees_with_birthday = execute_sql_query(sql_query)

# Display the results
show_to_user(employees_with_birthday)
```","```python
from datetime import datetime

current_month = datetime.now().month

sql_query = f""""""
SELECT EmployeeID, FirstName, LastName, BirthDate
FROM employees
WHERE MONTH(BirthDate) = {current_month}
""""""

employees_with_birthdays = execute_sql_query(sql_query)
show_to_user(employees_with_birthdays)
```","The input code correctly fetches the current month and uses it in an SQL query to select employee details for those having birthdays in the current month. Both the input and reference implementations execute the SQL query and display the results. The components used, such as the `execute_sql_query` function and SQL syntax for filtering by month, are consistent between both implementations except for a slight difference in selected columns, which does not impact correctness given the problem statement.","```python
import pandas as pd
from datetime import datetime

# Get current month as a number
current_month = datetime.now().month

# SQL query to select employees with birthdays in the current month
sql_query = f""""""
SELECT EmployeeID, FirstName, LastName, BirthDate
FROM employees
WHERE MONTH(BirthDate) = {current_month};
""""""

# Execute the SQL query
employee_birthdays_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employee_birthdays_df)
```","The input code is correct because it follows the same logic as the reference code. Both implementations fetch the current month, construct an SQL query that selects employees with birthdays in the current month, execute the query, and display the results using the function 'show_to_user'. Differences in column selection (with or without 'BirthDate') do not affect the primary functionality of listing employee IDs, first names, and last names of employees whose birthdays are in the current month.",both
What is the total sales revenue for each product and display with a sorted bar chart.,"```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT P.ProductID, SUM(OD.Quantity * OD.UnitPrice) AS TotalSalesRevenue 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY P.ProductID;
""""""

# Execute the SQL query and store the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Sort the dataframe by TotalSalesRevenue in descending order
df_sorted = df.sort_values(by='TotalSalesRevenue', ascending=False)

# Create a bar chart using plotly express
fig = px.bar(df_sorted, x='ProductID', y='TotalSalesRevenue', title='Total Sales Revenue by Product')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalRevenue DESC
""""""

total_sales_revenue = execute_sql_query(sql_query)

fig = px.bar(total_sales_revenue, 
              x='ProductName', 
              y='TotalRevenue', 
              title='Total Sales Revenue per Product',
              labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code calculates the total revenue including discounts, which is not accounted for in the reference code. The reference code calculates revenue as Quantity * UnitPrice, while the input code uses Quantity * UnitPrice * (1 - Discount). Additionally, the input code includes ProductName in the GROUP BY and ORDER BY clauses, whereas the reference does not include ProductName.","```python
import plotly.express as px

# SQL query to get total sales revenue for each product
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSalesRevenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID, products.ProductName;
""""""

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Sort the dataframe by TotalSalesRevenue
df_sorted = df.sort_values(by='TotalSalesRevenue', ascending=False)

# Create a sorted bar chart
fig = px.bar(df_sorted, x='ProductName', y='TotalSalesRevenue', title='Total Sales Revenue by Product')

# Display the chart to the user
show_to_user(fig)
```","The input code meets the business request to calculate the total sales revenue for each product and display it in a sorted bar chart. Although it differs in implementation details, the core logic aligns with the reference implementation. The input code includes 'ProductName' in the SQL query and calculation, and accounts for discounts, which adds more detail but does not alter the core task of summing the sales revenue. The dataframe is sorted by 'TotalSalesRevenue', and a bar chart is displayed using Plotly, fulfilling the requirement.",Finetuned
Who is the highest paid employee and what is their total sales?,"```python
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY e.Salary DESC 
LIMIT 1;
'''

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Salary
ORDER BY e.Salary DESC
LIMIT 1
""""""

highest_paid_employee = execute_sql_query(sql_query)
show_to_user(highest_paid_employee)
```","The evaluated code fulfills the business analytics request effectively. Both the reference and provided code are designed to retrieve the highest-paid employee along with their total sales. The reference code focuses on 'EmployeeID' and 'Salary', while the provided code also includes 'FirstName' and 'LastName' in the selection, but this does not affect correctness regarding the business request. Both codes order by 'Salary' in descending order and limit the result to the top entry, ensuring that the highest-paid employee is selected. The total sales calculation logic and the join structure are identical in both pieces of code.","```python
import pandas as pd

# Define the SQL query
query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary, 
SUM(od.Quantity * od.UnitPrice) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Salary 
ORDER BY e.Salary DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(query)

# Display the result
show_to_user(df)
```","The evaluated code calculates 'TotalSales' as 'SUM(od.Quantity * od.UnitPrice)', whereas the reference implementation includes a discount factor: 'SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))'. This difference means the evaluated code does not adhere to the same logic regarding sales calculation.",Base
What is the average discount given for each supplier's products and visualize with a bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS AvgDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AvgDiscount', title='Average Discount by Supplier')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='SupplierID', y='AverageDiscount', 
             labels={'SupplierID': 'Supplier ID', 'AverageDiscount': 'Average Discount'},
             title='Average Discount by Supplier')
show_to_user(fig)
```","The input Python code correctly executes the SQL query to calculate the average discount per supplier and visualizes the data using a bar chart. It adheres to the same logic as the reference implementation. The only differences are in column naming ('AverageDiscount' vs 'AvgDiscount') and the use of additional labeling parameters in the Plotly bar chart, which do not affect correctness.","Here's how you can achieve the task using Python code. The code retrieves the average discount per supplier from the database and visualizes it using a bar chart.

```python
import plotly.express as px

# SQL query to get average discount per supplier
sql_query = """"""
SELECT suppliers.CompanyName, AVG(products.Discontinued * [Order Details].Discount) AS avg_discount
FROM suppliers
INNER JOIN products ON suppliers.SupplierID = products.SupplierID
INNER JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY suppliers.CompanyName;
""""""

# Execute the query and get the data as a DataFrame
df = execute_sql_query(sql_query)

# Filter out suppliers with no products or no discounts
df = df.dropna(subset=['CompanyName', 'avg_discount'])

# Create a bar chart
fig = px.bar(df, x='CompanyName', y='avg_discount', title='Average Discount per Supplier')

# Show the visualization to the user
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: The SQL query retrieves suppliers and calculates the average discount for each supplier's products, ensuring it only includes products that are discontinued.
2. **Data Processing**: After executing the SQL query, the code removes any entries where the company name or average discount is missing.
3. **Data Visualization**: A bar chart is generated using Plotly's `px.bar` function, which visualizes the average discount per supplier.
4. **Display**: The bar chart is displayed to the user with `show_to_user()`.

Make sure your `execute_sql_query` and `show_to_user` functions are correctly implemented to handle database queries and visualization outputs.","The input code averages the discount multiplied by the 'Discontinued' field, which is not in the reference. It should compute the average discount directly like the reference. Also, using 'CompanyName' instead of 'SupplierID' deviates from the reference logic. The filtering of NaN values for 'CompanyName' and 'avg_discount' is unnecessary if the SQL query correctly handles these values.",Base
Calculate the total sales revenue generated in the last month.,"```python
import pandas as pd

# SQL Query to calculate total sales revenue for the last month
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Display the result
show_to_user(sales_data.iloc[0]['TotalSales'])
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate the first and last date of the previous month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

sql_query = f""""""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
AND orders.OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}';
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","Both implementations calculate the total sales revenue for the last month using SQL queries. The reference implementation and the input code filter orders by OrderDate to include only those from the last month and sum the revenue generated by multiplying UnitPrice, Quantity, and applying the Discount. The input code correctly determines the first and last day of the previous month using Python's datetime module, which matches the filtering logic requested. Thus, the input implementation follows the same logic and fulfills the business analytics request correctly.","```python
import pandas as pd

# Define the SQL query to calculate total sales revenue generated in the last month
sql_query = """"""
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN DATEADD(MONTH, -1, GETDATE()) AND GETDATE();
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales value
total_sales = result_df.iloc[0]['TotalSales']

# Show the total sales revenue to the user
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))
```","The provided code calculates total sales but does not account for discounts applied to each order. Additionally, it uses 'DATEADD' and 'GETDATE()' instead of 'DATE_SUB' and 'CURDATE()', which suggests different SQL dialects. The logical difference, however, lies in the omission of the discount calculation, leading to an incorrect total when compared to the reference code.",Base
What is the total sales per employee for each month and illustrate with a stacked bar chart.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT e.EmployeeID, 
       strftime('%Y-%m', o.OrderDate) as OrderMonth, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, OrderMonth;
""""""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Create a stacked bar chart
fig = px.bar(result_df, x='OrderMonth', y='TotalSales', color='EmployeeID', 
             title='Total Sales per Employee for Each Month', 
             labels={'TotalSales': 'Total Sales', 'OrderMonth': 'Order Month'}, 
             barmode='stack')

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, OrderMonth
ORDER BY 
    OrderMonth, e.EmployeeID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, 
             x='OrderMonth', 
             y='TotalSales', 
             color='EmployeeName', 
             title='Total Sales per Employee for Each Month', 
             labels={'OrderMonth': 'Month', 'TotalSales': 'Total Sales'},
             text='TotalSales')
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig.update_layout(barmode='stack')
show_to_user(fig)
```","The input Python code correctly executes the SQL query to calculate the total sales per employee for each month, similar to the reference implementation. It computes 'TotalSales' using the same logic and groups by 'EmployeeID' and 'OrderMonth'. Although it includes 'EmployeeName' and orders the results, this does not affect the correctness of the main task. The generated stacked bar chart displays the total sales per employee for each month, using 'EmployeeName' rather than 'EmployeeID', which is a valid enhancement. The inclusion of 'text' for display purposes does not impact functionality. Therefore, the input fulfills the business requirement in alignment with the reference logic.","```python
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT 
    MONTH(orders.OrderDate) AS order_month, 
    orders.EmployeeID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    MONTH(orders.OrderDate), orders.EmployeeID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a stacked bar chart
fig = px.bar(
    df,
    x='order_month',
    y='employee_sales',
    color='EmployeeID',
    title='Total Sales per Employee for Each Month',
    labels={'order_month': 'Order Month', 'employee_sales': 'Sales'},
    barmode='stack'
)

# Display the chart
show_to_user(fig)
```","The input code calculates the order month using MONTH(), which provides only the month number, while the reference code uses strftime('%Y-%m') to get both year and month. This results in a mismatch when orders span across different years but in the same month.",Base
How does the total number of units sold compare between discontinued and active products and visualize with a comparative bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.Discontinued, 
       SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.Discontinued
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a comparative bar chart using Plotly
fig = px.bar(df, x='Discontinued', y='TotalUnitsSold',
             labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'},
             title='Total Units Sold: Discontinued vs Active Products',
             color='Discontinued')

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.Discontinued,
    SUM(od.Quantity) AS TotalUnitsSold
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.Discontinued
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='Discontinued', y='TotalUnitsSold', 
             labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'},
             title='Comparison of Total Units Sold: Discontinued vs Active Products',
             color='Discontinued',
             color_discrete_map={0: 'blue', 1: 'orange'}
            )

show_to_user(fig)
```","The provided code evaluates the total number of units sold for discontinued and active products using a SQL query similar to the reference implementation. Both codes calculate the total units sold for each product status through a SQL `GROUP BY` operation on the `Discontinued` field. The only difference is in the SQL query syntax which doesn't affect the operation and some additional customization in the bar chart color. Both codes use Plotly to plot a bar chart, capturing the comparative visualization as requested.","```python
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT products.Discontinued, SUM([Order Details].Quantity) AS TotalUnitsSold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.Discontinued;
""""""

# Retrieve data into a DataFrame
df = execute_sql_query(sql_query)

# Ensure Discontinued column is treated as a string for display purposes
df['Discontinued'] = df['Discontinued'].astype(str)

# Create a comparative bar chart
fig = px.bar(df, x='Discontinued', y='TotalUnitsSold', title='Total Units Sold by Product Status',
             labels={'Discontinued': 'Product Status (Discontinued=1, Active=0)', 'TotalUnitsSold': 'Total Units Sold'})

# Show the figure
show_to_user(fig)
```","The input Python code correctly retrieves and aggregates the total units sold for active and discontinued products, just like the reference code. It uses a SQL query to group by the 'Discontinued' field and sums up the 'Quantity' field from the 'Order Details' table. Both code snippets use Plotly to visualize the results in a bar chart. Although there are minor differences, such as converting the 'Discontinued' column to a string for display purposes and slight variations in label text, the logic and output remain consistent with the requirements of the business analytics request.",both
Count the total number of orders placed by each customer.,"```python
import pandas as pd

# Construct the SQL query
sql_query = ""SELECT CustomerID, COUNT(*) AS total_orders FROM orders GROUP BY CustomerID;""

# Execute the SQL query and get the result as a pandas dataframe
df_orders = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_orders)
```","```python
sql_query = """"""
SELECT 
    c.CustomerID, 
    COUNT(o.OrderID) AS TotalOrders
FROM 
    customers c
LEFT JOIN 
    orders o ON c.CustomerID = o.CustomerID
GROUP BY 
    c.CustomerID
""""""
order_counts = execute_sql_query(sql_query)
show_to_user(order_counts)
```","The input code uses a LEFT JOIN to ensure that all customers are included, even those without orders, which still satisfies the request to count orders per customer. It groups by CustomerID and counts orders correctly, matching the logical intent of the reference code.","```python
import pandas as pd

# SQL query to count the total number of orders placed by each customer
sql_query = ""SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID""

# Execute SQL query to get data
orders_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(orders_data)
```","The input Python code correctly counts the total number of orders placed by each customer using the SQL query 'SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID'. This adheres to the same logic as the reference implementation, which uses 'COUNT(*)' to achieve the same result. Both queries effectively count the number of orders for each CustomerID and display that using the `show_to_user` function.",both
Identify the product categories with the lowest total sales revenue and display with a bar chart.,"```python
import plotly.express as px

# SQL query to identify the product category with the lowest total sales revenue
sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
ORDER BY TotalRevenue ASC
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales revenue by the lowest product category
fig = px.bar(df, x='CategoryID', y='TotalRevenue', title='Lowest Total Sales Revenue by Product Category')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue by product category
sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY TotalSales ASC
LIMIT 10
""""""

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart for the product categories with the lowest total sales revenue
fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Lowest Total Sales Revenue by Product Category', labels={'CategoryID':'Product Category', 'TotalSales':'Total Sales Revenue'})
show_to_user(fig)
```","The input code finds the top 10 categories with the lowest total sales revenue after applying discounts, while the reference implementation identifies only the single category with the lowest total sales revenue without considering discounts. These differences in logic and output criteria mean the input code doesn't meet the requirements outlined by the reference.","```python
import plotly.express as px

# SQL query to get product categories with the lowest total sales revenue
sql_query = """"""
SELECT c.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID
ORDER BY TotalSales ASC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='CategoryID', y='TotalSales', 
             title='Product Categories with Lowest Total Sales Revenue')

# Show the bar chart to the user
show_to_user(fig)
```","The input code does not limit the results to the single category with the lowest sales revenue. It fetches all categories ordered by total sales revenue, unlike the reference which limits to one. The SQL query also includes a discount calculation not present in the reference.",None
Find the product categories with the highest average unit price.,"```python
import pandas as pd

# SQL query to find the product categories with the highest average unit price
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice
FROM products
GROUP BY CategoryID
ORDER BY AverageUnitPrice DESC;
""""""

# Execute the SQL query
product_categories_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(product_categories_df)
```","```python
sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
ORDER BY AverageUnitPrice DESC
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly implements the business analytics request. It queries the products table for the average unit price grouped by category and orders the results in descending order by average unit price, which is the same logic as the reference implementation, despite slight differences in SQL formatting.","```python
import pandas as pd

# SQL query to get the product categories with the highest average unit price
sql_query = """"""
SELECT categories.CategoryID, categories.CategoryName, 
AVG(products.UnitPrice) AS AverageUnitPrice 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryID 
ORDER BY AverageUnitPrice DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)
```","The input code correctly identifies product categories with the highest average unit price. It extends the reference implementation by including the CategoryName in the output, which does not modify the core logic of the analysis. Both codes aggregate by CategoryID and order by average unit price in descending order. Therefore, the input code adheres to the business analytics request and the logic of the reference solution.",both
How many orders included products with a discount of more than 10%?,"```python
sql_query = """"""
SELECT COUNT(*) as order_count
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0.1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['order_count'][0])
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT o.OrderID) AS OrderCount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount > 0.1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code retrieves the count of unique orders with products that have a discount greater than 10%. It uses COUNT(DISTINCT o.OrderID) to achieve this, which is logically equivalent to the reference implementation that counts orders using COUNT(*). Both approaches ensure counting the number of distinct orders that meet the discount condition, fulfilling the business analytics request.","```python
import pandas as pd

# SQL query to count the number of unique orders with a discount > 10%
sql_query = ""SELECT DISTINCT o.OrderID FROM [Order Details] o WHERE o.Discount > 0.1;""

# Execute the SQL query to retrieve the data
order_data = execute_sql_query(sql_query)

# Count the number of unique orders
order_count = len(order_data)

# Display the result to the user
show_to_user(pd.DataFrame({'Order Count': [order_count]}))
```","The input code does not correctly replicate the logic of the reference implementation. The reference code counts all relevant orders, possibly including duplicates, because it joins the 'orders' and 'Order Details' tables. The input code, however, uses 'DISTINCT' to count only unique 'OrderID's from 'Order Details' directly, which can lead to a different count if there are multiple entries for the same 'OrderID' with a discount over 10%.",Base
What is the performance ranking of products based on sales quantity?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure that the DataFrame is sorted by TotalQuantity in descending order
df = df.sort_values(by='TotalQuantity', ascending=False)

# Display the result
show_to_user(df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC;
""""""

product_performance = execute_sql_query(sql_query)
fig = px.bar(product_performance, x='ProductName', y='TotalSales', title='Product Performance Ranking by Sales Quantity')
show_to_user(fig)
```","Both the reference and input codes execute an SQL query that selects `ProductID`, `ProductName`, and the sum of quantities ordered (`TotalQuantity` in reference and `TotalSales` in input) from the `Order Details` and `products` tables. Both group data by `ProductID` and `ProductName` and sort the results in descending order by the summed quantities. The input code then visualizes the sorted result using Plotly for a bar chart. Despite differences in visualization, the logic and data manipulation align with the reference implementation.","To respond to the request, I'll use SQL to query the data and then display the results using the provided `show_to_user` function. The SQL query will retrieve the product names along with their total sales quantities, ordered in descending order. The following Python code performs these steps:

```python
import pandas as pd

# SQL query to rank products based on total sales quantity
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantitySold
FROM `Order Details`
GROUP BY ProductID
ORDER BY TotalQuantitySold DESC;
""""""

# Execute SQL query to get the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```

This code retrieves the necessary data and presents it to the user, effectively answering the request for the performance ranking of products based on sales quantity.","The input code is incorrect because it doesn't join the 'products' table to include the ProductName as in the reference implementation. This causes the output to lack product names, which are part of the reference's result. Additionally, the column name for total quantity differs ('TotalQuantitySold' vs 'TotalQuantity'), which could affect the display logic if 'show_to_user' relies on the reference column names.",Base
List the orders grouped by required dates and their total freight costs.,"```python
import pandas as pd

# SQL query
sql_query = ""SELECT RequiredDate, SUM(Freight) AS TotalFreightCost FROM orders GROUP BY RequiredDate;""

# Execute query and retrieve dataframe
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","```python
sql_query = """"""
SELECT RequiredDate, SUM(Freight) AS TotalFreightCost
FROM orders
GROUP BY RequiredDate;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code uses an SQL query identical to the reference implementation, selecting 'RequiredDate' and summing 'Freight' grouped by 'RequiredDate'. Both execute the query and display the result, fulfilling the business analytics request.","```python
import pandas as pd

# Execute the SQL query to retrieve data
sql_query = ""SELECT RequiredDate, SUM(Freight) as TotalFreight FROM orders GROUP BY RequiredDate;""
order_data = execute_sql_query(sql_query)

# Display the result
show_to_user(order_data)
```","The input Python code fulfills the business analytics request by grouping the orders by 'RequiredDate' and calculating the 'TotalFreight' (equivalent to 'TotalFreightCost' in the reference). The logic and SQL query are identical in function to the reference implementation, making the input code correct.",both
"Calculate the month-over-month growth rate of total sales for December 2023, including a line chart to illustrate trends over the months.","```python
import pandas as pd
import plotly.express as px

# SQL query to get relevant data
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') IN ('2023-11', '2023-12')
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query and store the result in a dataframe
sales_data = execute_sql_query(sql_query)

# Calculate Month-over-Month Growth Rate
sales_data['MoM_GrowthRate'] = sales_data['TotalSales'].pct_change()

# Extract December 2023 Growth Rate
december_growth_rate = sales_data[sales_data['OrderMonth'] == '2023-12']['MoM_GrowthRate'].values[0]

# Plotting the trend line chart for Total Sales
fig = px.line(
    sales_data,
    x='OrderMonth',
    y='TotalSales',
    title='Total Sales Trend (Nov - Dec 2023)',
    labels={'TotalSales': 'Total Sales ($)', 'OrderMonth': 'Month'}
)

# Display the plot
show_to_user(fig)

# Display the December Growth Rate
show_to_user(pd.DataFrame({'December 2023 MoM Growth Rate': [december_growth_rate]}))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    OrderDate >= '2023-01-01' AND OrderDate < '2024-01-01'
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

sales_data = execute_sql_query(sql_query)
sales_data['PreviousMonthSales'] = sales_data['TotalSales'].shift(1)
sales_data['MoMGrowthRate'] = ((sales_data['TotalSales'] - sales_data['PreviousMonthSales']) / sales_data['PreviousMonthSales']) * 100

fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Total Sales with Month-over-Month Growth Rate', labels={'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code calculates the month-over-month growth rate for the entire year of 2023 but does not specifically calculate or extract the MoM growth rate for December 2023 as required. The reference implementation limits the calculation to November and December and explicitly extracts December's growth rate. Additionally, the input code does not display the December growth rate separately, which is part of the requirement.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch sales data for each month of 2023
sql_query = """"""
SELECT DATE_PART('year', o.OrderDate) AS Year, 
       DATE_PART('month', o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE DATE_PART('year', o.OrderDate) = 2023 
GROUP BY DATE_PART('year', o.OrderDate), DATE_PART('month', o.OrderDate);
""""""

# Execute SQL query
sales_data_2023 = execute_sql_query(sql_query)

# Calculate Month-over-Month Growth Rate
sales_data_2023['MOM_Growth_Rate'] = sales_data_2023['TotalSales'].pct_change() * 100

# Filter data for December 2023
december_growth_rate = sales_data_2023[sales_data_2023['Month'] == 12].copy()

# Display the final growth rate for December 2023
show_to_user(december_growth_rate[['MOM_Growth_Rate']])

# Create a line chart to illustrate trends over the months
fig = px.line(sales_data_2023, x='Month', y='TotalSales', title='Month-over-Month Growth Rate of Total Sales for 2023',
              markers=True)
show_to_user(fig)
```","The input code calculates the MoM growth rate for all of 2023, not just between November and December as required. It also multiplies MoM growth rate by 100 unnecessarily and does not explicitly extract the December growth rate as per the business request.",None
"How does the average unit price of products vary across categories, using a bar chart to visualize differences?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.CategoryID, AVG(products.UnitPrice) AS AverageUnitPrice
FROM products
GROUP BY products.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title=""Average Unit Price Across Categories"")

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average unit price per category
sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

# Execute the SQL query
average_price_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit price across categories
fig = px.bar(average_price_df, x='CategoryID', y='AverageUnitPrice', 
             title='Average Unit Price of Products by Category',
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly calculates the average unit price per category using a SQL query with the same logic as the reference implementation. Both codes execute the query and use Plotly Express to create a bar chart, showing the average unit price grouped by CategoryID. Minor differences like the use of labels in the input do not affect the correctness relative to the business analytics request.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AvgUnitPrice
FROM products p
GROUP BY p.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='AvgUnitPrice', title='Average Unit Price by Category')

# Show the plot to the user
show_to_user(fig)
```","The input code correctly executes an SQL query to calculate the average unit price of products grouped by CategoryID. It uses Plotly to create a bar chart, with the x-axis as 'CategoryID' and the y-axis as 'AvgUnitPrice', reflecting the necessary comparison across categories. This aligns with the logic and intent of the reference implementation.",both
What is the most common shipping city for the current year?,"```python
import pandas as pd

# SQL query to retrieve the most common shipping city for the current year
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
from datetime import datetime

current_year = datetime.now().year

sql_query = f""""""
SELECT ShipCity, COUNT(*) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = {current_year}
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1;
""""""

most_common_city = execute_sql_query(sql_query)
show_to_user(most_common_city)
```","The provided Python code is correct and follows the same logic as the reference implementation. Both codes execute a similar SQL query to find the most common shipping city for the current year by counting orders grouped by 'ShipCity'. They sort by the count in descending order and limit the result to the top entry. Also, both use the current year obtained through datetime functions. The result is displayed using `show_to_user`, matching the reference logic.","To determine the most common shipping city for the current year from the sales data, I will consolidate the relevant information using SQL queries and visualize it with a bar chart for clarity.

Here is the Python code to achieve this:

```python
import pandas as pd

# SQL query to get the most common shipping city for the current year
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE())
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Since we're only interested in the top result
if not df.empty:
    common_city = df.iloc[0]
    print(f""The most common shipping city for the current year is: {common_city['ShipCity']} with {common_city['OrderCount']} orders."")
else:
    print(""No data available for the current year."")
```

### Explanation:
1. **SQL Query Execution**: The query retrieves the `ShipCity` with the highest number of orders for the current year.
2. **Data Handling**: It checks if the resulting DataFrame is not empty and displays the result directly.
3. **Output**: Displays the city and number of orders to the user using a print statement. 

Make sure to run this code in an environment where the `execute_sql_query` function is correctly defined to interact with the MDDX data warehouse.","The input Python code correctly implements the business analytics request. It uses a SQL query to identify the most common shipping city for the current year, similar to the reference code. Both versions select the city with the highest count of orders by grouping the orders by ShipCity and filtering by the current year. The input code also handles the potential for no data by checking if the DataFrame is empty. Although the output method differs (print vs. show_to_user), the core logic matches the reference implementation, fulfilling the business question requirements.",both
How many products have a reorder level of zero?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS ZeroReorderProducts FROM products WHERE ReorderLevel = 0""

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['ZeroReorderProducts'].iloc[0])
```","```python
sql_query = ""SELECT COUNT(*) AS ProductCount FROM products WHERE ReorderLevel = 0""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code outputs the entire DataFrame, while the reference code extracts and displays only the count value using `result_df['ZeroReorderProducts'].iloc[0]`. The logic differs in terms of how the result is shown to the user.","```python
import pandas as pd

# SQL query to find products with a reorder level of zero
sql_query = ""SELECT COUNT(*) as count_zero_reorder FROM products WHERE ReorderLevel = 0;""

# Execute the SQL query and retrieve the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
count_zero_reorder = result_df['count_zero_reorder'][0]
show_to_user(pd.DataFrame({'count_zero_reorder': [count_zero_reorder]}))
```","The input Python code accurately answers the business request by executing a SQL query that counts products with a reorder level of zero, similar to the reference implementation. It retrieves and displays the count correctly, although the way of displaying it is slightly different, which is acceptable as the logic aligns with the reference.",Finetuned
"What is the total revenue generated by each product, visualized with a bar chart for comparison?","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue by product
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalRevenue DESC;
""""""

# Execute SQL query
revenue_data = execute_sql_query(sql_query)

# Create a bar chart for total revenue by product
fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', 
             title='Total Revenue Generated by Each Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly calculates and visualizes the total revenue generated by each product, similar to the reference code. The SQL query selects the sum of total revenue per product and groups by 'ProductName' instead of 'ProductID', which serves the same purpose of identifying products uniquely for the bar chart. The use of 'ProductName' provides a more readable output but does not change the correctness of the code in relation to the request. The visualization uses Plotly to generate and display a bar chart, aligning with the specified business analytics request.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice) AS RevenueGenerated
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

# Execute the SQL query and fetch data
df = execute_sql_query(sql_query)

# Visualize the data with a bar chart
fig = px.bar(df, x='ProductName', y='RevenueGenerated', title='Total Revenue by Product')

# Display the figure to the user
show_to_user(fig)
```","The input code does not calculate the total revenue correctly as it omits the discount applied to each order. The reference implementation correctly accounts for discounts by calculating `SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))` while the input code uses `SUM(od.Quantity * od.UnitPrice)` without considering discounts. Additionally, the input code groups by `ProductID` and `ProductName`, whereas the reference only groups by `ProductID`.",Base
"Find the total quantity sold for each product, excluding discontinued products.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalQuantitySold 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE products.Discontinued = 0 
GROUP BY products.ProductID, products.ProductName;
""""""

# Execute SQL query and retrieve data into a pandas dataframe
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductID, p.ProductName
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly follows the same logic as the reference implementation. It queries the total quantity sold for each product while excluding discontinued products. The SQL syntax and logic, including the JOIN and WHERE clauses, are consistent with the reference, leading to the same outcome.","```python
import pandas as pd

# SQL query to get total quantity sold for each product excluding discontinued products
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE products.Discontinued = 0 
GROUP BY products.ProductID, products.ProductName;
""""""

# Execute the SQL query and retrieve the data
df_products = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_products)
```","The input Python code performs the same operations as the reference implementation. It executes a SQL query to find the total quantity sold for each product, excluding discontinued products, and then displays the result. The query logic and conditions in both codes are identical, fulfilling the business analytics request.",both
Determine the average discount applied across all products.,"```python
import pandas as pd

# SQL query to determine the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average discount value from the dataframe
average_discount = result_df['AverageDiscount'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'Average Discount': [average_discount]}))
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code correctly executes an SQL query that calculates the average discount from the 'Order Details' table, which matches the intended business analytics request. It then displays the result using 'show_to_user', similar to the reference implementation. The minor difference is that the input code directly uses the result dataframe without explicitly extracting the value, but functionally it remains correct.","```python
import pandas as pd

# SQL query to get average discount
sql_query = ""SELECT AVG([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS AvgDiscount FROM [Order Details];""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the average discount result to the user
show_to_user(df['AvgDiscount'].iloc[0])
```","The input Python code incorrectly calculates the average discount by multiplying the UnitPrice, Quantity, and Discount columns. The reference implementation directly averages the Discount column without any multiplication. The calculation logic differs between the two codes, leading to different results.",Base
"How many orders were placed each month in the last year, using a bar chart to show trends over time?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(orders_df, x='Month', y='OrderCount', title='Number of Orders Placed Each Month in the Last Year')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the number of orders placed each month in the last year
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS month, COUNT(OrderID) AS order_count
FROM orders
WHERE OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year'
GROUP BY month
ORDER BY month;
""""""

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Create a bar chart to show trends over time
fig = px.bar(orders_data, x='month', y='order_count', title='Monthly Orders in the Last Year', labels={'month': 'Month', 'order_count': 'Number of Orders'})
show_to_user(fig)
```","The input code and the reference implementation use similar logic to solve the problem. Both queries retrieve the number of orders placed each month for the past year and group the results by month. The input implementation uses DATE_TRUNC and PostgreSQL-syntax for intervals, which achieves the same purpose as DATE_FORMAT and MySQL-syntax in the reference code. The charting logic with Plotly is similarly executed and displayed. The differences in SQL functions and chart labels do not affect the correctness regarding the business analytics request.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(*) AS OrderCount 
FROM 
    orders 
WHERE 
    OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY 
    Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort DataFrame by Month for proper plotting
df = df.sort_values(by='Month')

# Create a bar chart to show the trend
fig = px.bar(df, x='Month', y='OrderCount', title='Monthly Order Count for the Last Year')

# Show the plot to the user
show_to_user(fig)
```","The input code correctly addresses the business analytics request. It performs the same operations as the reference code: executing an SQL query to count orders grouped by month for the past year, sorting by month, and displaying a bar chart of the results. The variable names and chart title differ slightly, but the core logic and data processing remain consistent with the reference implementation.",both
"List the count of products in each category, supplied by supplier.","```python
import pandas as pd

# SQL query to get the count of products in each category, supplied by supplier
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID, s.CompanyName, p.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName, p.CategoryID
""""""

product_count_df = execute_sql_query(sql_query)
show_to_user(product_count_df)
```","The input code is missing the 'SupplierID' in the SELECT and GROUP BY clauses, which was present in the reference implementation. This is important for uniquely identifying groups and adhering to the specified business request of counting products per supplier and category.","Here is the Python code to execute the SQL query and show the results to the user:

```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    categories.CategoryName, 
    suppliers.CompanyName, 
    COUNT(products.ProductID) AS NumberOfProducts 
FROM 
    products 
JOIN 
    categories ON products.CategoryID = categories.CategoryID 
JOIN 
    suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY 
    categories.CategoryName, 
    suppliers.CompanyName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)
```

Make sure the SQL query returns the correct results for the count of products in each category supplied by the supplier, and that `execute_sql_query` and `show_to_user` methods are properly defined to handle the data.","The input Python code calculates the product count by CategoryName and CompanyName, missing the original request to include the SupplierID. The reference code uses SupplierID, CompanyName, and CategoryID as grouping keys, which directly supports the business request. Additionally, the input code's inclusion of CategoryName instead of CategoryID might lead to slightly different results if names are not unique or needed.",None
What is the average order fulfillment time for March 2023?,"```python
import pandas as pd

# Define SQL Query to get order dates and shipped dates
sql_query = """"""
SELECT o.ShippedDate, o.OrderDate
FROM orders o
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-03-31';
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Calculate the average fulfillment time
df['ShippedDate'] = pd.to_datetime(df['ShippedDate'])
df['OrderDate'] = pd.to_datetime(df['OrderDate'])
df['FulfillmentTime'] = (df['ShippedDate'] - df['OrderDate']).dt.days
average_fulfillment_time = df['FulfillmentTime'].mean()

# Display result
show_to_user(pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= '2023-03-01' AND OrderDate < '2023-04-01'
""""""

average_fulfillment_time = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time)
```","The input Python code calculates the average fulfillment time for orders in March 2023 using SQL. The query filters orders by specifying the OrderDate between '2023-03-01' and '2023-03-31', similarly to the reference implementation. It calculates the difference in days between ShippedDate and OrderDate using SQL's DATEDIFF function and computes the average directly in the SQL query. This approach aligns with the logic and result of the reference implementation, which calculates the fulfillment time in Python after executing a SQL query that fetches the necessary data.","```python
import pandas as pd

# SQL Query to get order fulfillment times for March 2023
sql_query = '''
SELECT DATEDIFF(ShippedDate, OrderDate) AS OrderFulfillmentTime
FROM orders
WHERE DATE_FORMAT(OrderDate, '%Y-%m') = '2023-03';
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the average order fulfillment time
average_fulfillment_time = df['OrderFulfillmentTime'].mean()

# Display the result to the user
show_to_user(pd.DataFrame({'AverageOrderFulfillmentTime': [average_fulfillment_time]}))
```","Both implementations retrieve the orders made in March 2023 and calculate the average order fulfillment time. The code to evaluate uses SQL's DATEDIFF to calculate fulfillment time, while the reference calculates it in pandas after data retrieval. Both approaches achieve the same outcome of extracting and averaging fulfillment times.",both
"Identify the top 3 suppliers based on the total sales value of their products, using a bar chart for visualization.","```python
import plotly.express as px

# SQL query to get the top 3 suppliers by total sales value
sql_query = """"""
SELECT SupplierID, SUM([Order Details].UnitPrice * Quantity) AS TotalSalesValue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY SupplierID 
ORDER BY TotalSalesValue DESC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(df, x='SupplierID', y='TotalSalesValue', title='Top 3 Suppliers by Total Sales Value')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total sales value grouped by SupplierID
sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalSales DESC
LIMIT 3;
""""""

# Execute SQL query and retrieve data
top_suppliers_df = execute_sql_query(sql_query)

# Bar chart visualization
fig = px.bar(top_suppliers_df, x='SupplierID', y='TotalSales', title='Top 3 Suppliers by Total Sales Value')
show_to_user(fig)
```","The provided code includes a calculation for total sales that incorporates a discount factor: (1 - od.Discount), which is missing in the reference implementation. This difference indicates a deviation in the total sales calculation, leading to potentially different results when determining the top suppliers.","```python
import plotly.express as px

# SQL query to get the top 3 suppliers based on total sales value
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.CompanyName 
ORDER BY TotalSales DESC 
LIMIT 3;
""""""

# Execute SQL query and retrieve data into a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CompanyName', y='TotalSales', title='Top 3 Suppliers by Total Sales', labels={'CompanyName': 'Supplier', 'TotalSales': 'Total Sales Value'})

# Display the chart to the user
show_to_user(fig)
```","The input code differs from the reference implementation in a critical aspect. The input code accounts for discounts in the calculation of TotalSales by using `(1 - [Order Details].Discount)`, while the reference implementation does not consider discounts. This difference makes the logic of the two implementations mismatched, which results in different outcomes if discounts are present.",None
List all products that need reordering.,"```python
import pandas as pd

# SQL Query to find products that need reordering
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the query
df = execute_sql_query(sql_query)

# Display the filtered result to the user; ensure only the 'ProductName' column is shown
show_to_user(df['ProductName'])
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND (UnitsInStock <= ReorderLevel);
""""""

products_needing_reorder = execute_sql_query(sql_query)
show_to_user(products_needing_reorder)
```","The input code includes additional conditions and columns not present in the reference implementation. It filters out discontinued products (Discontinued = 0) and displays additional columns (ProductID, UnitsInStock, ReorderLevel), which goes beyond the task of listing just the 'ProductName' for potential reordering.","```python
import pandas as pd

# SQL query to select products that need reordering
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
reorder_df = execute_sql_query(sql_query)

# Display the result as a list
show_to_user(reorder_df['ProductName'].tolist())
```","The input code uses a condition 'UnitsInStock < ReorderLevel' instead of 'UnitsInStock <= ReorderLevel' as in the reference code. This means it will not include products where 'UnitsInStock' equals 'ReorderLevel', which is considered for reordering in the reference code.",None
"What is the average order fulfillment time by month for 2023, visualized with a line chart to show changes over time?","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY month
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'month' column to datetime
df['month'] = pd.to_datetime(df['month'])

# Create a line chart
fig = px.line(df, x='month', y='avg_fulfillment_time', title='Average Order Fulfillment Time by Month for 2023')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS order_month,
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY order_month
ORDER BY order_month
""""""

result_df = execute_sql_query(sql_query)

fig = px.line(result_df, x='order_month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time by Month for 2023',
              labels={'order_month': 'Month', 'avg_fulfillment_time': 'Average Fulfillment Time (Days)'})
show_to_user(fig)
```","The input Python code correctly calculates the average order fulfillment time by month for 2023 and visualizes the result with a line chart. It uses a SQL query to group orders by month and calculates the average fulfillment time (difference between 'ShippedDate' and 'OrderDate'). Both the input code and the reference code execute a similar query, transform the month information appropriately, and display a line chart. The differences in the code, such as using 'YEAR(OrderDate) = 2023' instead of a BETWEEN condition and specifying labels for the chart, do not affect the correctness of the result.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average order fulfillment time by month for 2023
sql_query = """"""
SELECT EXTRACT(MONTH FROM orders.OrderDate) AS month, 
       AVG(EXTRACT(DAY FROM orders.ShippedDate - orders.OrderDate)) AS avg_fulfillment_time 
FROM orders 
WHERE EXTRACT(YEAR FROM orders.OrderDate) = 2023 
GROUP BY month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the month column is treated as an integer for correct sorting
df['month'] = df['month'].astype(int)

# Sort the dataframe by month to ensure correct plotting order
df = df.sort_values('month')

# Create a line chart visualization using Plotly
fig = px.line(df, x='month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time by Month for 2023',
              labels={'month': 'Month', 'avg_fulfillment_time': 'Avg Fulfillment Time (Days)'})

# Display the chart
show_to_user(fig)
```","The input code extracts the month using EXTRACT(MONTH FROM orders.OrderDate) which results in an integer and doesn't maintain the year component, potentially allowing for incorrect grouping across the years. The reference code uses DATE_FORMAT(orders.OrderDate, '%Y-%m') to ensure the month is associated with the correct year, which is crucial for 2023 only. This difference may affect the accuracy of the average calculation. Additionally, the SQL in the input uses EXTRACT(DAY FROM orders.ShippedDate - orders.OrderDate) for the date difference, which is incorrect syntax in some dialects and unnecessary when simply using DATEDIFF().",Base
Which products have less than 10 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query and retrieve the data
products_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products 
WHERE UnitsInStock < 10;
""""""
low_stock_products = execute_sql_query(sql_query)
show_to_user(low_stock_products)
```","The input code correctly retrieves products with less than 10 units in stock. Although it selects the 'ProductID' field in addition to 'ProductName' and 'UnitsInStock', this does not affect the primary purpose of identifying products with low stock. The logic of filtering products based on 'UnitsInStock < 10' is consistent with the reference implementation.","```python
import pandas as pd

# SQL Query to get products with less than 10 units in stock
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query to retrieve the data
products_in_low_stock = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_in_low_stock)
```","The input code does not adhere to the logic of the reference implementation. The reference implementation selects 'ProductName' and 'UnitsInStock', whereas the input code selects 'ProductID' and 'ProductName'. The input code is missing the 'UnitsInStock' column, which is necessary to verify the number of units in stock.",Base
Which employee processed the most orders?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY TotalOrders DESC 
LIMIT 1;
""""""

# Execute SQL query
order_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(order_data)
```","```python
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
""""""

top_employee = execute_sql_query(sql_query)
show_to_user(top_employee)
```","The input Python code correctly processes the business analytics request by executing a SQL query to count the number of orders processed by each employee, ordering the results in descending order of order count, and limiting the result to the top employee. The logic matches the reference implementation, with differences only in variable names and column aliases, which do not affect the correctness.","```python
import pandas as pd

# SQL query to find the employee who processed the most orders
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY NumberOfOrders DESC 
LIMIT 1;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Check if the result is not empty
if not orders_df.empty:
    # Get the employee with the most orders
    top_employee = orders_df.iloc[0]
else:
    top_employee = None

# Display the result
show_to_user(top_employee)
```","The input Python code correctly executes a SQL query to retrieve the employee with the most processed orders. It groups by EmployeeID, orders by the count in descending order, and limits the result to one record, similar to the reference code. Additionally, the input code includes checks for empty results and appropriately handles the display, aligning with the business request and logic of the reference implementation.",both
Identify the customer with the most late shipments.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) AS LateOrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.RequiredDate < o.ShippedDate 
GROUP BY c.CustomerID 
ORDER BY LateOrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS LateShipments
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY c.CustomerID, c.CompanyName
ORDER BY LateShipments DESC
LIMIT 1;
""""""

late_shipments_df = execute_sql_query(sql_query)
show_to_user(late_shipments_df)
```","The input code correctly identifies the customer with the most late shipments. It uses the same logic as the reference implementation, checking when the 'ShippedDate' is later than the 'RequiredDate' to count late shipments. It groups by 'CustomerID' and sorts by the count of late shipments, returning the largest count. The inclusion of 'CompanyName' does not affect the correctness of the logic.","```python
import pandas as pd

# SQL query to identify the customer with the most late shipments
sql_query = """"""
SELECT customers.CustomerID, COUNT(*) AS LateShipmentCount
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
WHERE orders.ShippedDate > orders.RequiredDate
GROUP BY customers.CustomerID
ORDER BY LateShipmentCount DESC
LIMIT 1;
""""""

# Execute the SQL query
late_shipments_df = execute_sql_query(sql_query)

# Ensure a single row result
late_shipments_df = late_shipments_df.head(1)

# Show only the relevant column
late_shipments_df = late_shipments_df[['CustomerID']]

# Display the result to the user
show_to_user(late_shipments_df)
```","Both the reference and input codes aim to determine the customer ID with the highest number of late shipments by counting orders where the shipped date is past the required date. Both codes group results by customer ID, order by the count of late shipments in descending order, and limit the result to a single customer. The relevant SQL logic and the core execution flow are consistent, thus the input code is correct.",both
Find the orders placed in the last 30 days and their total freight cost.,"```python
import pandas as pd

# SQL query to find orders in the last 30 days
sql_query = """"""
SELECT o.OrderID, o.OrderDate, o.ShippedDate, o.Freight 
FROM orders o 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 30 DAY);
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate the total freight cost
total_freight_cost = orders_df['Freight'].sum()

# Prepare the result dataframe
result_df = pd.DataFrame({
    'Total Freight Cost': [total_freight_cost]
})

# Show the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta

# Calculate the date 30 days ago from today
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# Format the dates for SQL query
start_date_str = start_date.strftime('%Y-%m-%d')
end_date_str = end_date.strftime('%Y-%m-%d')

# SQL query to find orders placed in the last 30 days and their total freight cost
sql_query = f""""""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE OrderDate BETWEEN '{start_date_str}' AND '{end_date_str}'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code correctly calculates the total freight cost for the orders placed in the last 30 days. It uses a SQL query to sum the freight based on the order dates, similar to the reference code. Although it calculates the date range differently, the logic and the result are equivalent.","```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate the date 30 days ago
date_30_days_ago = datetime.now() - timedelta(days=30)

# SQL query to retrieve orders and their total freight cost in the last 30 days
sql_query = f""""""
SELECT SUM(Freight) AS TotalFreightCost FROM orders WHERE ORDERDATE >= '{date_30_days_ago.strftime('%Y-%m-%d')}';
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input code correctly calculates the total freight cost for orders placed in the last 30 days. It computes the date 30 days ago and uses it in the SQL query to filter orders. Although it uses a different SQL structure to aggregate the freight cost directly in the query instead of calculating it in Python, it adheres to the same logical outcome as the reference implementation.",both
Determine the number of discontinued products.,"```python
import pandas as pd

# SQL Query to determine the number of discontinued products
sql_query = ""SELECT COUNT(*) AS DiscontinuedProducts FROM products WHERE Discontinued = 1;""

# Execute the query using the provided utility function
result_df = execute_sql_query(sql_query)

# Extract the count value from the dataframe
discontinued_count = result_df.iloc[0]['DiscontinuedProducts']

# Display the result to the user
show_to_user(discontinued_count)
```","```python
sql_query = ""SELECT COUNT(*) AS DiscontinuedProducts FROM products WHERE Discontinued = 1""
discontinued_products_df = execute_sql_query(sql_query)
show_to_user(discontinued_products_df)
```",The input code passes the entire DataFrame to show_to_user instead of extracting and passing the count value as in the reference code.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS discontinued_product_count FROM products WHERE Discontinued = 1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the count from the dataframe
discontinued_product_count = result_df['discontinued_product_count'].iloc[0]

# Prepare a result dataframe to display
result_to_show = pd.DataFrame({'discontinued_product_count': [discontinued_product_count]})

# Display the result to the user
show_to_user(result_to_show)
```","Both implementations perform the same task. The input code executes an SQL query to count discontinued products, extracts this count correctly, and then uses a DataFrame to display the result. Although the input code wraps the output in a DataFrame before showing it to the user, this difference in the output format doesn't affect the correctness as per the requirement.",Finetuned
What is the average shipping cost per order per month? Include a visualization to show trends over time.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is sorted correctly
df['Month'] = pd.to_datetime(df['Month'])

# Sort the dataframe by the 'Month' column
df = df.sort_values('Month')

# Create a line plot for average shipping cost per month
fig = px.line(df, x='Month', y='AvgShippingCost', title='Average Shipping Cost per Order per Month')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    AVG(Freight) AS AverageShippingCost
FROM orders
GROUP BY Month
ORDER BY Month
""""""
shipping_cost_data = execute_sql_query(sql_query)

fig = px.line(shipping_cost_data, x='Month', y='AverageShippingCost', title='Average Shipping Cost per Order per Month')
show_to_user(fig)
```","The input Python code evaluates the average shipping cost per order per month similarly to the reference implementation. It uses SQL to group data by month and compute the average freight cost, which matches the reference logic. The use of DATE_TRUNC function for aggregation and ordering in SQL replicates the purpose of DATE_FORMAT in the reference. The input code correctly creates a line plot using Plotly Express, similar to the reference implementation, displaying trends over time. Hence, the code is correct.","```python
import pandas as pd
import plotly.express as px

# Define SQL query to get the average shipping cost per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Convert Month to datetime for proper sorting
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart to visualize the trend
fig = px.line(df.sort_values('Month'), x='Month', y='AvgShippingCost', 
              title='Average Shipping Cost per Order per Month', 
              labels={'AvgShippingCost': 'Avg Shipping Cost', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly calculates the average shipping cost per month by grouping orders by the month derived from the OrderDate and calculates the average freight. The data is then sorted by the 'Month' column, which is converted to datetime for proper sorting, similar to the reference implementation. Both implementations use the same SQL logic and visualization with a line chart to show the trend over time, fulfilling the business analytics request.",both
Find out how many orders each employee managed in a specific date range. Visualize the employee performance comparison.,"```python
import plotly.express as px

# Define the date range
start_date = '2023-01-01'
end_date = '2023-12-31'

# Create the SQL query
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Employee Order Management Performance')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

start_date = '2023-01-01'
end_date = '2023-01-31'

sql_query = f'''
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY e.EmployeeID, EmployeeName
ORDER BY OrderCount DESC
'''

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='EmployeeName', y='OrderCount', 
             title='Orders Managed by Employees from {} to {}'.format(start_date, end_date),
             labels={'OrderCount': 'Number of Orders', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code uses 'LEFT JOIN' instead of 'JOIN', which might return employees with zero orders, not required by the reference implementation. Additionally, the date range used ('2023-01-01' to '2023-01-31') doesn't match the reference range ('2023-01-01' to '2023-12-31'). These discrepancies may lead to different results.","```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Visualize the employee performance comparison
fig = px.bar(order_data, x='EmployeeID', y='OrderCount', title='Employee Performance Comparison')

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly implements the business requirement. It uses the same SQL query to count the number of orders each employee managed within the specified date range. The same libraries (plotly.express) are used for visualization, and the plot is created in a similar manner. The input code meets the business analytics request and follows the logic of the reference implementation.",Finetuned
Which products have been discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query to get the discontinued products
discontinued_products_df = execute_sql_query(sql_query)

# Use the utility function to display the data to the user
show_to_user(discontinued_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE Discontinued = 1
""""""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code retrieves products where the 'Discontinued' flag is 1, and displays the necessary information using 'execute_sql_query' and 'show_to_user' functions. Although it selects both 'ProductID' and 'ProductName' as opposed to just 'ProductName' in the reference, it still satisfies the business analytics request of identifying discontinued products.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_products = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discontinued_products)
```","The input code retrieves both 'ProductID' and 'ProductName' from the database, whereas the reference implementation only retrieves 'ProductName'. The business request asks which products, meaning we interpret this as needing only the product names, adhering strictly to the logic of the reference code.",Base
What is the monthly inventory turnover ratio? Use a visualization to highlight changes over time.,"```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATEPART(month, OrderDate) AS Month, 
       SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY DATEPART(month, OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure Month is treated as categorical for correct plotting
df['Month'] = df['Month'].astype(str)

# Sort the dataframe by Month to ensure correct plotting
df = df.sort_values(by='Month')

# Visualize the data
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate monthly inventory turnover ratio
sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.Quantity * od.UnitPrice) AS COGS,
    AVG(p.UnitsInStock) AS avg_inventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS inventory_turnover_ratio
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    month
ORDER BY 
    month;
""""""

# Execute SQL query
inventory_turnover_df = execute_sql_query(sql_query)

# Visualization of Inventory Turnover Ratio over time
fig = px.line(inventory_turnover_df, x='month', y='inventory_turnover_ratio', title='Monthly Inventory Turnover Ratio', labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio', 'month': 'Month'})
show_to_user(fig)
```","Both implementations calculate the monthly inventory turnover ratio using the formula: COGS (cost of goods sold) divided by the average inventory. They both group data by month and correctly handle division to avoid division by zero. The main difference is in SQL syntax differences: DATEPART vs. DATE_TRUNC, which are equivalent in functionality, and NULLIF to prevent division by zero in the input code. Visualization in both codes is correctly using Plotly to create a line chart highlighting changes over time.","```python
import plotly.express as px

# SQL query to get the monthly inventory turnover ratio
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio 
FROM 
    orders 
JOIN 
    [Order Details] 
ON 
    orders.OrderID = [Order Details].OrderID 
JOIN 
    products 
ON 
    [Order Details].ProductID = products.ProductID 
GROUP BY 
    month;
""""""

# Execute the SQL query
turnover_data = execute_sql_query(sql_query)

# Convert month column to datetime for better plotting
turnover_data['month'] = pd.to_datetime(turnover_data['month'])

# Create a line plot to visualize the monthly inventory turnover ratio
fig = px.line(turnover_data, x='month', y='inventory_turnover_ratio', title='Monthly Inventory Turnover Ratio')

# Show the visualization
show_to_user(fig)
```","The input code calculates the monthly inventory turnover ratio using '%Y-%m', which aggregates by year and month, not just month. The reference implementation uses just the month. This discrepancy can lead to different results if the dataset spans multiple years. The reference code's logic only extracts the month, assuming single-year data or handling across multiple years implicitly.",Base
Which products are associated with the highest total order quantities? Visualize the top products by order quantity.,"```python
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrderedQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalOrderedQuantity DESC;
""""""
data = execute_sql_query(sql_query)

# Visualize the top products by order quantity
fig = px.bar(data, x='ProductName', y='TotalOrderedQuantity', title='Top Products by Order Quantity')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total order quantities by product
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrderQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrderQuantity DESC
LIMIT 10
""""""

# Execute the SQL query
top_products = execute_sql_query(sql_query)

# Create a bar chart to visualize top products by order quantity
fig = px.bar(top_products, x='ProductName', y='TotalOrderQuantity',
             title='Top Products by Total Order Quantity',
             labels={'TotalOrderQuantity': 'Total Order Quantity', 'ProductName': 'Product Name'},
             color='TotalOrderQuantity', 
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the visualization to the user
show_to_user(fig)
```","The input code uses a LIMIT 10 clause, which restricts the result to the top 10 products by order quantity. The reference code does not use a LIMIT, implying that it retrieves all products. Therefore, the logic of limiting the results differs, making the input code incorrect according to the reference implementation.","```python
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalOrderQuantity
FROM [Order Details]
GROUP BY ProductID
ORDER BY TotalOrderQuantity DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the top products by order quantity
fig = px.bar(df, x='ProductID', y='TotalOrderQuantity', title='Top Products by Total Order Quantity')

# Display the visualization
show_to_user(fig)
```","The input code does not match the reference logic because it only retrieves ProductID and not ProductName, making it harder to identify products. The reference code joins the 'products' table to include ProductName, which is essential for clear visualization and understanding. The input code also doesn't ensure products are selected by their total order quantities in a meaningful way, as ProductID is less informative than ProductName.",None
What are the names of products that are currently discontinued?,"```python
import pandas as pd

# SQL query to find product names that are discontinued
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discontinued_products_df[['ProductName']])
```","```python
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code is correct because it effectively executes the same SQL query as the reference implementation. Both the input and reference code select the 'ProductName' from the 'products' table where 'Discontinued' is equal to 1. The result is then passed to 'show_to_user()', which meets the business analytics request. The difference in column selection (subsetting the DataFrame) in the reference code does not alter the correctness of the result as the initial query already specifies only the 'ProductName' column.","```python
import pandas as pd

# SQL query to fetch discontinued products
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Check if the dataframe is empty before displaying
if not discontinued_products_df.empty:
    # Display the result to the user, focusing on ProductName
    show_to_user(discontinued_products_df[['ProductName']])
else:
    show_to_user(""No discontinued products found."")
```","The provided code correctly identifies and displays the names of products that are discontinued, following the same logic as the reference implementation. It checks if the DataFrame is empty and appropriately handles the case of no discontinued products by providing a relevant message to the user. This additional step does not deviate from the primary logic of fulfilling the business analytics request.",both
What is the total freight cost for all orders made in the year 2022?,"```python
import pandas as pd

# SQL query to get the total freight cost for orders made in 2022
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# As result_df will have a single value DataFrame, extract the value
total_freight_cost = result_df['TotalFreightCost'].iloc[0]

# Display the result to the user
show_to_user(total_freight_cost)
```","```python
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""
total_freight_cost_df = execute_sql_query(sql_query)
show_to_user(total_freight_cost_df)
```","The input code does not extract the total freight cost from the DataFrame as the reference code does. The reference code extracts the single value from the DataFrame with `result_df['TotalFreightCost'].iloc[0]` before displaying it, while the input code attempts to show the entire DataFrame with `show_to_user(total_freight_cost_df)`, which might not correctly represent the expected output.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT SUM(Freight) AS TotalFreight FROM orders WHERE YEAR(OrderDate) = 2022;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total freight value
total_freight = result_df.loc[0, 'TotalFreight']

# Display the result
show_to_user(pd.DataFrame({'Total Freight for 2022': [total_freight]}))
```","The input code and the reference implementation both calculate the total freight cost for orders made in 2022. The reference code uses a SQL query with a date range to filter the orders, while the input code uses the SQL YEAR function to achieve the same filtering. Both approaches yield the correct sum of Freight for the specified year. Additionally, the result is extracted similarly from the SQL execution result and presented to the user, fulfilling the business analytics request.",Finetuned
What is the total sales revenue generated in each month? Include a line chart to show monthly revenue trends.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY month;
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Ensure the month column is treated as a string for proper line chart visualization
df['month'] = df['month'].astype(str)

# Create Line Chart
fig = px.line(df, x='month', y='TotalSales', title='Monthly Sales Revenue Trends')

# Show the result to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

monthly_sales = execute_sql_query(sql_query)

fig = px.line(monthly_sales, x='Month', y='TotalSales', title='Monthly Sales Revenue Trends')
show_to_user(fig)
```","The input code correctly implements the business analytics request. It calculates the total sales revenue for each month using SQL, similar to the reference implementation, then generates and displays a line chart to show monthly revenue trends using Plotly. The logic and steps match the reference code, ensuring correct functionality.","```python
import plotly.express as px

# SQL query to get monthly sales data
sql_query = """"""
SELECT DATE_TRUNC('month', orders.OrderDate) AS Month, 
SUM([Order Details].Quantity * [Order Details].UnitPrice) AS MonthlySales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY DATE_TRUNC('month', orders.OrderDate);
""""""

# Execute SQL query and retrieve data into a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Convert 'Month' to a proper datetime format for plotting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Create a line chart using plotly
fig = px.line(sales_data, x='Month', y='MonthlySales', title='Monthly Sales Revenue Trends')

# Show the line chart to the user
show_to_user(fig)
```","The input code does not account for discounts when calculating sales revenue, unlike the reference implementation. The reference code includes discounts by multiplying the total sales with (1 - Discount), which is missing in the input code, thereby leading to different total sales values.",Base
Find the CustomerID and the total number of orders for each customer who has ordered more than 10 times.,"```python
import pandas as pd

# SQL Query to retrieve the data
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS order_count
FROM customers
INNER JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID
HAVING COUNT(orders.OrderID) > 10
""""""

# Execute the SQL query and store the result in a dataframe
customer_orders_df = execute_sql_query(sql_query)

# Display the result
show_to_user(customer_orders_df)
```","```python
sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) AS TotalOrders
FROM orders o
GROUP BY o.CustomerID
HAVING COUNT(o.OrderID) > 10
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly finds the CustomerID and total number of orders for each customer with more than 10 orders. Although the input code does not explicitly join the 'customers' table, it assumes all necessary data is in the 'orders' table, which simplifies the SQL statement while preserving the required logic. The output fulfills the business requirement of identifying customers with more than 10 orders, consistent with the reference code.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CustomerID, COUNT(*) AS TotalOrders 
FROM orders 
GROUP BY CustomerID 
HAVING COUNT(*) > 10;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input code correctly calculates the total number of orders for each customer using the same logic as the reference code. Both queries filter customers with more than 10 orders and group them by CustomerID. The difference lies in the input code pulling directly from the 'orders' table, assuming 'CustomerID' is directly accessible, whereas the reference includes a join with a 'customers' table, which isn't necessary to satisfy the task. Hence, the input code fulfills the requirement despite the structural difference.",both
How many orders were shipped over a week late in August 2023?,"```python
import pandas as pd

# SQL Query to find the number of late orders in August 2023
sql_query = """"""
SELECT COUNT(OrderID) AS LateOrders
FROM orders
WHERE DATEDIFF(ShippedDate, RequiredDate) > 7
AND OrderDate BETWEEN '2023-08-01' AND '2023-08-31';
""""""

# Execute the SQL query and get result in a dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
late_orders_count = df.iloc[0]['LateOrders'] if not df.empty else 0
show_to_user(pd.DataFrame({'Late Orders in August 2023': [late_orders_count]}))
```","```python
sql_query = """"""
SELECT COUNT(*) AS LateOrdersCount
FROM orders
WHERE ShippedDate > DATEADD(DAY, 7, RequiredDate)
  AND ShippedDate BETWEEN '2023-08-01' AND '2023-08-31';
""""""

late_orders_df = execute_sql_query(sql_query)
show_to_user(late_orders_df)
```","The input code counts orders with 'ShippedDate' more than 7 days after 'RequiredDate' and within the ShippedDate range of August 2023. This differs from the reference, which calculates if 'ShippedDate' is 7 days over 'RequiredDate' and checks 'OrderDate' in August 2023. The difference in date columns used for range filtering makes the logic incorrect compared to the reference.","```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT COUNT(OrderID) AS LateOrders
FROM orders
WHERE DATEPART(month, OrderDate) = 8 AND DATEPART(year, OrderDate) = 2023 
      AND DATEDIFF(day, OrderDate, ShippedDate) > 7
""""""

# Execute SQL Query
late_orders_df = execute_sql_query(sql_query)

# Extract the late orders count
late_orders_count = late_orders_df['LateOrders'].iloc[0]

# Display the result
show_to_user(pd.DataFrame({'LateOrders': [late_orders_count]}))
```",The input code calculates orders shipped over a week late by checking the difference between 'OrderDate' and 'ShippedDate' instead of 'RequiredDate' and 'ShippedDate' as in the reference code. This discrepancy leads to different late order definitions.,None
Which employee achieved the highest sales in 2022? Use a visualization for employee sales comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch employee sales data for 2022
sql_query = """"""
SELECT o.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY o.EmployeeID
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Get the employee with the highest sales
top_employee = sales_data.iloc[0]

# Visualize the employee sales comparison using a bar chart
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Employee Sales Comparison 2022')

# Display the visualization result
show_to_user(fig)

# Display the top employee with the highest sales
show_to_user(top_employee)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by employee for the year 2022
sql_query = """"""
SELECT o.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders AS o
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = 2022
GROUP BY o.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1
""""""

# Execute the SQL query
highest_sales_employee = execute_sql_query(sql_query)

# SQL query to get all employees' total sales for visualization
sql_query_visual = """"""
SELECT o.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders AS o
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = 2022
GROUP BY o.EmployeeID
""""""

# Execute the SQL query for visualization
employee_sales_data = execute_sql_query(sql_query_visual)

# Create a bar chart for employee sales comparison
fig = px.bar(employee_sales_data, x='EmployeeID', y='TotalSales', 
             title='Employee Sales Comparison for 2022', 
             labels={'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Show results to user
show_to_user(highest_sales_employee)
show_to_user(fig)
```","The provided input Python code correctly answers the business analytics request by identifying the employee with the highest sales in 2022 and creates a visualization comparing employee sales. The logic is consistent with the reference implementation, albeit achieved with slightly different SQL queries. The key operations, including executing a query to retrieve the top employee and producing a bar chart for visualization, align with the reference workflow.","```python
import plotly.express as px

# SQL query to get sales by employee for 2022
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
sales_df = execute_sql_query(sql_query)

# Find the employee with the highest sales
max_sales_row = sales_df.loc[sales_df['employee_sales'].idxmax()]
max_employee = sales_df[sales_df['employee_sales'] == max_sales_row['employee_sales']]

# Visualize employee sales comparison
fig = px.bar(sales_df, x='EmployeeID', y='employee_sales', title='Employee Sales Comparison for 2022')
show_to_user(fig)

# Show the employee with the highest sales
show_to_user(max_employee)
```","The input code fulfills the business analytics request by identifying the employee with the highest sales in 2022. It retrieves data using a SQL query that calculates sales per employee in 2022, finds the employee with the maximum sales, and visualizes the sales for all employees. The logic and approach align with the reference implementation, despite variations in how the top employee was selected.",both
What are the top 5 best-selling products? Include a bar chart to show sales figures.,"```python
import plotly.express as px

# SQL query to get top 5 best-selling products
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to show sales figures
fig = px.bar(df, x='ProductName', y='TotalSales', title='Top 5 Best-Selling Products')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 5;
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalSales', title='Top 5 Best-Selling Products', 
             labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code retrieves the top 5 best-selling products by summing the quantities sold, similar to the reference code. Both codes use SQL to perform aggregation and a LIMIT clause to retrieve the top 5 products. The small difference in SQL query, selecting ProductID in addition, does not affect the result since the grouping and ordering logic matches. Both implementations create a bar chart using Plotly Express to display the top 5 products along with their sales figures. Thus, the input code is correct and aligns with the reference logic.","```python
import plotly.express as px

# SQL query to fetch the top 5 best-selling products
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSold 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalSold DESC 
LIMIT 5;
'''

# Execute the SQL query and get the result as a DataFrame
df_best_selling = execute_sql_query(sql_query)

# Create a bar chart for the top 5 best-selling products
fig = px.bar(df_best_selling, x='ProductName', y='TotalSold',
             title='Top 5 Best-Selling Products',
             labels={'TotalSold': 'Units Sold', 'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly fetches the top 5 best-selling products using a SQL query similar to the reference code. It groups by 'ProductID' and 'ProductName', orders by 'TotalSold', and limits to 5 results. It then uses Plotly to create a bar chart to display the sales figures, consistent with the reference implementation.",both
Which products have a discount applied in more than 10 orders?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(*) AS OrderCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0.0 
GROUP BY p.ProductName 
HAVING COUNT(*) > 10;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) as OrderCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
GROUP BY p.ProductID, p.ProductName
HAVING COUNT(od.OrderID) > 10
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The provided code correctly addresses the business analytics request. It identifies products with discounts applied in more than 10 orders. Both implementations use SQL to join product and order details, filter rows with discounts, group by product, and apply the HAVING clause to ensure the count of orders is greater than 10. While the reference groups and selects based on ProductName alone, the evaluated code includes ProductID. This does not affect correctness since the question pertains to identifying products by name. The output is equivalent as per the business logic.","```python
import pandas as pd

# SQL Query to get products with a discount in more than 10 orders
sql_query = """"""
SELECT ProductID 
FROM [Order Details] 
WHERE Discount > 0 
GROUP BY ProductID 
HAVING COUNT(OrderID) > 10;
""""""

# Execute the SQL query and get the result as a dataframe
discounted_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discounted_products_df)
```","The input code checks for ProductID rather than ProductName and does not join with the products table. Therefore, it does not return the product names of those having discounts in more than 10 orders as required in the business request and demonstrated in the reference implementation.",Base
What is the average order value for June 2023?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extracting average order value
avg_order_value = df['avg_order_value'].iloc[0]

# Display the result
show_to_user(avg_order_value)
```","```python
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)
```",The input code lacks the step to extract the average order value from the DataFrame. It directly shows the entire DataFrame to the user instead of a single value. The reference code extracts the specific 'avg_order_value' from the DataFrame by referring to the column and the row index before displaying it.,"```python
import pandas as pd

# SQL query to get the sum of order values and count of orders for June 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS OrderValue,
COUNT(DISTINCT orders.OrderID) AS OrderCount
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate average order value
df['AverageOrderValue'] = df['OrderValue'] / df['OrderCount']

# Extract the average order value
average_order_value = df['AverageOrderValue'].iloc[0]

# Create a DataFrame with the result
result_df = pd.DataFrame({'Average Order Value for June 2023': [average_order_value]})

# Display the result
show_to_user(result_df)
```","The input code correctly computes the average order value for June 2023 by executing a SQL query to get the total order value and count of unique orders for the specified period. It then calculates the average by dividing the total order value by the count of unique orders. This matches the logic of the reference implementation. The final result is presented in a DataFrame, which is a valid format for displaying the output.",Finetuned
What is the average value of orders placed in January 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['avg_order_value'].iloc[0])
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
       COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)
```",The input code incorrectly displays the entire DataFrame instead of extracting the average order value from the specific column. It should extract 'avg_order_value' using .iloc[0] like the reference implementation.,"To find the average value of orders placed in January 2023, you will need to calculate the order values based on the data available in the `OrderDetails` and `orders` tables. You can use the following Python code to execute this task:

```python
import pandas as pd

# Define the SQL query to get the total order value for January 2023
sql_query = """"""
SELECT (od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue
FROM orders o
JOIN OrderDetails od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
order_values_df = execute_sql_query(sql_query)

# Calculate the average order value
average_order_value = order_values_df['OrderValue'].mean()

# Display the result to the user
show_to_user(pd.DataFrame({'AverageOrderValue': [average_order_value]}))
```

This code constructs a SQL query to fetch the data needed, calculates the average order value for the specified January 2023 period, and presents the result to the user.","The input Python code calculates the average of OrderValues directly fetched from SQL without combining by OrderID first, whereas the reference implementation calculates total OrderValue per distinct OrderID and then averages it, leading to a potentially different result.",None
"List the customers along with their total spent amounts, ordered by highest to lowest total spent. Use a bar chart to visualize spending.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY TotalSpent DESC;
""""""

# Execute the query using the provided utility function
dataframe = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(dataframe, x='CustomerID', y='TotalSpent', title='Total Spent by Customer', labels={'TotalSpent': 'Total Spent', 'CustomerID': 'Customer ID'})

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    TotalSpent DESC
""""""

result_df = execute_sql_query(sql_query)
fig = px.bar(result_df, x='CompanyName', y='TotalSpent', title='Total Spent by Customers', labels={'TotalSpent':'Total Spent', 'CompanyName':'Customer'})
show_to_user(fig)
```","The input code satisfies the business analytics request by listing customers along with their total spent amounts ordered from highest to lowest. It includes 'CompanyName' in the SQL query to provide more informative labels in the visualization, but this does not change the logic of calculating and ordering total spend per customer. The use of 'CompanyName' for the x-axis in the bar chart is a presentational detail and does not affect correctness. Therefore, the input code accomplishes the same analytical task as the reference code.","```python
import plotly.express as px
import pandas as pd

# SQL query
sql_query = """"""
SELECT CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSpent 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY CustomerID 
ORDER BY TotalSpent DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='TotalSpent', title='Total Spent by Customer', labels={'TotalSpent': 'Total Spent Amount', 'CustomerID': 'Customer ID'})

# Display the bar chart
show_to_user(fig)
```","The input code does not join the 'customers' table to include customer names/IDs. It groups by 'CustomerID' directly from the 'orders' table, which could be incorrect if 'CustomerID' is not directly present or uniquely represented. The reference implementation explicitly joins with 'customers' to ensure accurate customer data.",Base
What is the average order value for Q1 2023?,"```python
import pandas as pd

# SQL query to retrieve necessary data
sql_query = """"""
SELECT
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Extracting the average order value from the dataframe
avg_order_value = df['avg_order_value'][0]

# Display the average order value to the user
show_to_user(avg_order_value)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""
average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","The input code does not extract the average order value from the dataframe before displaying it. Instead, it attempts to display the entire dataframe, which will not produce the desired result. The reference code correctly extracts the 'avg_order_value' from the dataframe before showing it to the user.","```python
import pandas as pd

# SQL query to get the total order value and the distinct order count for Q1 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_order_value, 
    COUNT(DISTINCT o.OrderID) AS order_count 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31';
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Calculate average order value
df['avg_order_value'] = df['total_order_value'] / df['order_count']

# Show the result to the user
show_to_user(df[['avg_order_value']])
```","The input code calculates the average order value for Q1 2023 correctly. It retrieves the total order value and the distinct order count for the specified period, and then computes the average by dividing the total order value by the order count. This adheres to the logic of the reference implementation, which calculates the average directly in the SQL query. Both implementations achieve the same result.",Finetuned
List orders where the shipping cost was above average.,"```python
import pandas as pd

# Execute the SQL query to get the average freight value
avg_freight_query = ""SELECT AVG(Freight) AS average_freight FROM orders""
avg_freight_df = execute_sql_query(avg_freight_query)
average_freight = avg_freight_df.iloc[0]['average_freight']

# Query to get orders where the shipping cost is above average
above_avg_orders_query = f""SELECT * FROM orders WHERE Freight > {average_freight}""
above_avg_orders_df = execute_sql_query(above_avg_orders_query)

# Display the result to the user
show_to_user(above_avg_orders_df)
```","```python
# Calculate the average shipping cost
avg_shipping_cost_query = ""SELECT AVG(Freight) AS avg_freight FROM orders""
avg_shipping_cost_df = execute_sql_query(avg_shipping_cost_query)
avg_shipping_cost = avg_shipping_cost_df['avg_freight'].iloc[0]

# Retrieve orders with shipping cost above the average
above_average_orders_query = f""SELECT * FROM orders WHERE Freight > {avg_shipping_cost}""
above_average_orders_df = execute_sql_query(above_average_orders_query)

show_to_user(above_average_orders_df)
```","The input Python code correctly calculates the average freight cost and retrieves orders with shipping costs above the average. It follows the same logical steps as the reference implementation by executing two queries, first to find the average and second to filter orders based on that average. The variable naming differs slightly, but the logic and operations are consistent.","```python
import pandas as pd

# SQL query to get average shipping cost
avg_shipping_cost_query = ""SELECT AVG(Freight) AS AvgShippingCost FROM orders;""

# Execute the SQL query to get average shipping cost
avg_shipping_cost_df = execute_sql_query(avg_shipping_cost_query)
avg_shipping_cost = avg_shipping_cost_df.at[0, 'AvgShippingCost']

# SQL query to get orders with shipping cost above average
above_avg_shipping_query = f""""""
SELECT orders.* 
FROM orders 
WHERE Freight > {avg_shipping_cost};
""""""

# Execute the SQL query to get orders above average shipping cost
above_avg_shipping_orders = execute_sql_query(above_avg_shipping_query)

# Show the result to the user
show_to_user(above_avg_shipping_orders)
```","The provided input code is functionally equivalent to the reference code. Both scripts perform the same operations: they calculate the average freight/shipping cost and then retrieve orders where the freight is above this average. The variable names and query string formats differ slightly, but the logical flow and operations are identical. Therefore, the input code correctly answers the business analytics request.",both
What is the average freight cost for orders shipped to Europe?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(Freight) AS AverageFreightCost 
FROM orders 
WHERE ShipCountry IN ('Austria', 'Belgium', 'Denmark', 'Finland', 'France', 'Germany', 'Greece', 'Ireland', 'Italy', 
'Netherlands', 'Norway', 'Poland', 'Portugal', 'Spain', 'Sweden', 'Switzerland', 'United Kingdom')
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT AVG(Freight) AS AverageFreightCost
FROM orders
WHERE ShipCountry IN ('France', 'Germany', 'Italy', 'Spain', 'United Kingdom', 'Netherlands', 'Belgium', 'Sweden', 'Norway', 'Finland', 'Denmark', 'Austria', 'Switzerland', 'Ireland', 'Portugal')
""""""
average_freight_cost = execute_sql_query(sql_query)
show_to_user(average_freight_cost)
```","The code does not include some European countries present in the reference implementation such as Greece and Poland, which affects the correctness of the average freight cost calculation.","```python
import pandas as pd

# SQL query to get average freight for European orders
sql_query = """"""
SELECT AVG(Freight) AS avg_freight
FROM orders
WHERE ShipRegion IN ('Europe', 'EU');
""""""

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df['avg_freight'].astype(float).to_frame())
```","The evaluated code checks for orders shipped to regions labeled 'Europe' or 'EU' in the 'ShipRegion' column, whereas the reference code explicitly lists European countries in the 'ShipCountry' column. The logic and region specification are different, making it incorrect according to the given reference implementation.",None
What is the average salary of employees by title and visualize the distribution?,"```python
import plotly.express as px

# Execute the SQL query to get the average salary by title
sql_query = ""SELECT Title, AVG(Salary) AS AvgSalary FROM employees GROUP BY Title;""
df = execute_sql_query(sql_query)

# Create and show the visualization of the salary distribution by title
fig = px.bar(df, x='Title', y='AvgSalary', title='Average Salary by Title', labels={'AvgSalary':'Average Salary'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average salary by title
sql_query = """"""
SELECT Title, AVG(Salary) AS AverageSalary
FROM employees
GROUP BY Title
""""""

# Execute the SQL query
average_salary_df = execute_sql_query(sql_query)

# Visualize the average salary distribution by title
fig = px.bar(average_salary_df, x='Title', y='AverageSalary', title='Average Salary by Title', labels={'AverageSalary': 'Average Salary', 'Title': 'Employee Title'})
show_to_user(fig)
```","The input Python code successfully executes an SQL query to calculate the average salary by title and uses Plotly Express to create a bar chart for visualizing the salary distribution by title. The logic and approach align with the reference implementation, differing only in variable names and label customization, which do not affect the correctness.","```python
import plotly.express as px

# SQL query to get average salary by title
query = """"""
SELECT Title, AVG(Salary) AS AvgSalary 
FROM employees 
GROUP BY Title;
""""""

# Execute the SQL query
df = execute_sql_query(query)

# Create the bar chart to visualize average salary by title
fig = px.bar(df, x='Title', y='AvgSalary', title='Average Salary by Title')

# Show the chart to the user
show_to_user(fig)
```","The input code correctly executes an SQL query to calculate the average salary by title, groups the results by title, and visualizes the data using a bar chart. It also displays the chart using the 'show_to_user' function, following the same logic and intent as the reference implementation. The variable names differ, but this doesn't affect the correctness of the logic.",both
Visualize the total number of orders for each product.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(od.OrderID) AS OrderCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(data, x='ProductName', y='OrderCount', title='Total Number of Orders for Each Product')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, COUNT(od.Quantity) AS TotalOrders
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalOrders DESC
""""""

orders_df = execute_sql_query(sql_query)
fig = px.bar(orders_df, x='ProductName', y='TotalOrders', title='Total Number of Orders for Each Product')
show_to_user(fig)
```","The input code effectively achieves the same outcome as the reference code. Both codes produce a bar chart visualizing the total number of orders for each product. The input code calculates 'TotalOrders' using COUNT on od.Quantity, which is equivalent to counting OrderID in this context, provided each row in 'Order Details' corresponds to one order. A key difference is the use of ORDER BY to sort the results by TotalOrders in descending order; however, this does not affect the correctness of the task, since the objective only specifies to visualize the total orders per product. Both codes join products with 'Order Details' and group by 'ProductName' correctly, using Plotly for visualization.","```python
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT p.ProductID, SUM(od.Quantity) AS TotalOrders 
FROM products p 
JOIN ""Order Details"" od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ProductID', y='TotalOrders', title='Total Number of Orders for Each Product')

# Display the visualization
show_to_user(fig)
```","The input code calculates 'TotalOrders' using SUM(od.Quantity), which is the total quantity ordered for each product, rather than the number of orders. The reference code uses COUNT(od.OrderID) to count the number of distinct orders per product. Therefore, the logic deviates from the reference implementation and the business request.",Base
List the top 5 products with the highest unit price.,"```python
import pandas as pd

# SQL query to get the top 5 products with the highest unit price
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
ORDER BY UnitPrice DESC
LIMIT 5
""""""
top_products = execute_sql_query(sql_query)
show_to_user(top_products)
```","The input code correctly fulfills the business analytics request by selecting the top 5 products with the highest unit price. It mirrors the logic of the reference implementation, using an SQL query to order products by 'UnitPrice' in descending order and limiting the results to 5. Both codes then display the result using 'show_to_user'.","```python
import pandas as pd

# SQL query to fetch the top 5 products with the highest unit price
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
ORDER BY UnitPrice DESC
LIMIT 5;
""""""

# Execute the SQL query and get the result as a dataframe
top_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(top_products_df)
```","The input Python code correctly fetches the top 5 products with the highest unit price using a SQL query that orders the products by UnitPrice in descending order and limits the output to 5 rows. It then executes this query and shows the result to the user, following the same logic as the reference implementation.",both
Visualize the total freight cost for each shipping company in 2023.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY shippers.CompanyName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar plot of total freight cost for each shipping company
fig = px.bar(df, x='CompanyName', y='total_freight_cost', title='Total Freight Cost by Shipping Company in 2023')

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY shippers.CompanyName
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='CompanyName', y='total_freight', title='Total Freight Cost for Each Shipping Company in 2023', labels={'total_freight': 'Total Freight Cost', 'CompanyName': 'Shipping Company'})
show_to_user(fig)
```","The input code correctly executes a SQL query that calculates the sum of freight costs for each shipping company for the year 2023, similar to the reference code. Both queries join the 'orders' and 'shippers' tables, filter by the year 2023, group by company name, and generate a bar plot with Plotly Express. The minor differences in variable names and query format do not affect correctness.","```python
import plotly.express as px

# SQL query to get data
sql_query = """"""
SELECT shippers.CompanyName, 
SUM(orders.Freight) AS total_freight_cost 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY shippers.CompanyName;
""""""

# Execute SQL query and get the data into a pandas dataframe
df = execute_sql_query(sql_query)

# Ensure the column names are correctly referenced
df.columns = df.columns.str.strip()

# Create a visualization of total freight cost for each shipping company
fig = px.bar(df, x='CompanyName', y='total_freight_cost', title='Total Freight Cost for Each Shipping Company in 2023')

# Display the visualization to the user
show_to_user(fig)
```","The input code correctly implements the logic to visualize the total freight cost for each shipping company in 2023. Both the input and reference codes select the company names and sum of freight costs for orders made in 2023, then group by company name. The difference in filtering by year instead of a date range does not affect the outcome since both methods correctly identify orders within 2023. The use of `strip()` on column names in the input code ensures any potential leading or trailing spaces are removed, which is a safe practice and does not alter functionality. The visualization is created and displayed using `plotly.express`, identical in both codes.",both
What is the percentage of orders that were shipped within 3 days of being placed?,"```python
import pandas as pd

# Define the SQL query to execute
sql_query = """"""
SELECT OrderDate, ShippedDate FROM orders;
""""""

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Calculate the number of orders shipped within 3 days
orders_df['DaysToShip'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days
within_three_days_count = orders_df[orders_df['DaysToShip'] <= 3].shape[0]

# Calculate the total number of orders
total_orders_count = orders_df.shape[0]

# Calculate the percentage
percentage_within_three_days = (within_three_days_count / total_orders_count) * 100

# Prepare the results as a dataframe
result_df = pd.DataFrame({
    ""Percentage of Orders Shipped Within Three Days"": [percentage_within_three_days]
})

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(OrderID) AS total_orders,
    SUM(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 3 THEN 1 ELSE 0 END) AS shipped_within_3_days
FROM 
    orders
""""""

result_df = execute_sql_query(sql_query)

percentage_within_3_days = (result_df['shipped_within_3_days'] / result_df['total_orders']) * 100
show_to_user(percentage_within_3_days)
```","Both implementations correctly calculate the percentage of orders shipped within three days of being placed. The input code uses SQL's DATEDIFF function to directly compute the days between 'OrderDate' and 'ShippedDate' and aggregates the results in the SQL query itself, whereas the reference implementation performs this calculation in Python after retrieving the data. The logic and final result of both are equivalent.","```python
import pandas as pd

# SQL Query to retrieve data
sql_query = """"""
SELECT OrderID, OrderDate, ShippedDate FROM orders;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Calculate the processing time in days
df['ProcessingTime'] = (pd.to_datetime(df['ShippedDate']) - pd.to_datetime(df['OrderDate'])).dt.days

# Calculate the percentage of orders shipped within 3 days
percent_shipped_within_3_days = (df[df['ProcessingTime'] <= 3].shape[0] / df.shape[0]) * 100

# Create a dataframe to display the result
result_df = pd.DataFrame({'Percentage of Orders Shipped Within 3 Days': [percent_shipped_within_3_days]})

# Display the result
show_to_user(result_df)
```",The input Python code correctly calculates the percentage of orders shipped within 3 days. It uses the correct logic by subtracting the 'OrderDate' from 'ShippedDate' to find the number of days taken to ship and then calculates the percentage of orders where this is 3 days or less. The slight differences in the variable names and inclusion of an 'OrderID' column in the input code do not affect the correctness of the output logic compared to the reference implementation.,both
Which products have been ordered with a discount?,"```python
import pandas as pd

# SQL query to find products ordered with a discount
sql_query = """"""
SELECT DISTINCT p.ProductName 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0;
""""""

# Execute the query
discounted_products_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discounted_products_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, od.Discount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
""""""
discounted_products = execute_sql_query(sql_query)
show_to_user(discounted_products)
```","The input code retrieves ProductID, ProductName, and Discount for products with discounts, whereas it should only retrieve distinct product names as per the business request and reference code.","```python
import pandas as pd

# SQL query to get products ordered with a discount
sql_query = ""SELECT DISTINCT ProductName FROM [Order Details] d JOIN products p ON d.ProductID = p.ProductID WHERE d.Discount > 0;""

# Execute the SQL query
products_with_discount_df = execute_sql_query(sql_query)

# Display the result
show_to_user(products_with_discount_df)
```","The input code correctly retrieves a list of product names that have been ordered with a discount. It performs the necessary SQL JOIN between the [Order Details] and products tables, filters for discounts greater than zero, and selects distinct product names. This logic aligns with the reference implementation.",Finetuned
What is the total number of orders shipped via each shipping method per month and illustrate the trend?,"```python
import plotly.express as px
import pandas as pd

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, ShipVia, COUNT(OrderID) AS OrdersShipped 
FROM orders 
GROUP BY Month, ShipVia;
""""""

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Pivot the data to have shipping methods in separate columns
pivoted_data = orders_data.pivot(index='Month', columns='ShipVia', values='OrdersShipped').reset_index()

# Create a line plot
fig = px.line(pivoted_data, x='Month', y=pivoted_data.columns[1:], title='Orders Shipped via Each Method per Month',
              labels={'value': 'Orders Shipped', 'variable': 'Shipping Method'}, markers=True)

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    ShipVia,
    COUNT(OrderID) AS TotalOrders
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    Month, ShipVia
ORDER BY 
    Month, ShipVia
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='Month', y='TotalOrders', color='ShipVia', 
              title='Total Number of Orders Shipped via Each Shipping Method per Month',
              labels={'TotalOrders': 'Total Orders', 'Month': 'Month', 'ShipVia': 'Shipping Method'})

show_to_user(fig)
```","The input code calculates the trend using 'ShippedDate' instead of 'OrderDate' as in the reference implementation. This difference could lead to discrepancies if there are orders that haven't been shipped yet or are delayed. Additionally, the reference code pivots the data to have separate columns for each shipping method, while the input code uses Plotly's 'color' parameter to distinguish shipping methods directly in the line plot.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    MONTH(OrderDate) AS Month, 
    ShipperID, 
    COUNT(*) AS TotalOrders 
FROM 
    orders 
GROUP BY 
    MONTH(OrderDate), 
    ShipperID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Illustrate the trend
fig = px.line(data, x='Month', y='TotalOrders', color='ShipperID', title='Total Number of Orders Shipped via Each Shipping Method per Month')

# Display the result to the user
show_to_user(fig)
```","The input code does not fully adhere to the reference implementation due to differences in date processing and data pivoting. The 'Month' is extracted as an integer in the input code, which could lead to incorrect chronological ordering (e.g., January of different years will be grouped together), whereas the reference code formats the date as a string 'YYYY-MM' format. The reference code also pivots the data to have separate columns for each shipping method, which is not done in the input code. This difference affects the trend illustration when creating the line plot, as separate series per shipping method would better illustrate individual trends.",None
Visualize the total number of products supplied by each supplier.,"```python
import plotly.express as px

# SQL query
sql_query = ""SELECT SupplierID, COUNT(ProductID) AS TotalProducts FROM products GROUP BY SupplierID;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart with plotly
fig = px.bar(df, x='SupplierID', y='TotalProducts', title='Total Products Supplied by Each Supplier')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) AS TotalProducts
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CompanyName', y='TotalProducts', title='Total Number of Products Supplied by Each Supplier')
show_to_user(fig)
```","Both the reference and input code address the same business analytics request: they visualize the total number of products supplied by each supplier. The input code correctly performs a SQL join between the 'suppliers' and 'products' tables to count products per supplier, where the supplier is identified by 'CompanyName' instead of 'SupplierID'. The visualization code using Plotly fulfills the same purpose, with only a slight deviation in the column used for the x-axis. The input code is logically consistent with the business analytics request and the reference implementation.","```python
import plotly.express as px
from your_util_module import execute_sql_query

# SQL query to get total products supplied by each supplier
sql_query = """"""
SELECT SupplierID, SUM(UnitsSupplied) AS TotalSupplied FROM products GROUP BY SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total products supplied by each supplier
fig = px.bar(df, x='SupplierID', y='TotalSupplied', title='Total Products Supplied by Each Supplier')

# Display the visualization
fig.show()
```","The provided code uses SUM(UnitsSupplied) instead of COUNT(ProductID). The business request and reference implementation focus on counting the number of products, while the input code calculates the total units supplied, which likely represents a different metric.",Base
Which products need to be reordered?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query
products_to_reorder_df = execute_sql_query(sql_query)

# Display the products that need to be reordered
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND UnitsInStock <= ReorderLevel
""""""

products_to_reorder = execute_sql_query(sql_query)
show_to_user(products_to_reorder)
```","The input code includes an additional filter 'WHERE Discontinued = 0', which is not present in the reference implementation. This means that it will only reorder products that are not discontinued, diverging from the original business request and reference logic.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query to get the data
reorder_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(reorder_df)
```","The input code retrieves 'ProductID, ProductName' and uses '<' instead of '<='. It should match the logic of the reference code which uses 'ProductName' and '<='.",None
Visualize which products have the highest total sales volume in quantity.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalSalesQuantity DESC;
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Plot
fig = px.bar(data, x='ProductName', y='TotalSalesQuantity', 
             title='Products with Highest Total Sales Volume in Quantity')

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSalesVolume
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSalesVolume DESC
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSalesVolume', title='Total Sales Volume by Product', labels={'TotalSalesVolume': 'Total Sales Volume (Quantity)', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request by visualizing the products with the highest total sales volume in quantity. It uses a similar SQL query, grouping by 'ProductID' and 'ProductName', and orders by 'TotalSalesVolume'. The visualization step also aligns with the reference implementation by using Plotly Express for a bar chart. The differences in column labels and slight variations do not affect the correctness of the output.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve product sales
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalQuantity DESC;
""""""

# Execute the query to retrieve data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales volume in quantity
fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Total Sales Volume by Product',
             labels={'TotalQuantity': 'Total Quantity Sold'},
             text='TotalQuantity')

# Show the visualization
show_to_user(fig)
```","The input Python code correctly implements the requested visualization of products with the highest total sales volume in quantity. The SQL queries in both the reference and input codes are equivalent, as both join 'Order Details' and 'products' tables to sum up the quantities and group by 'ProductName', ordering them in descending order of total quantity. The input code correctly uses Plotly Express to create a bar chart, similar to the reference code, and utilizes additional parameters such as 'labels' and 'text' for additional detail. The logic and result are consistent with the business analytics request.",both
Visualize how many orders were placed and fulfilled in each month of 2023.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       COUNT(orders.OrderID) AS orders_placed, 
       COUNT(CASE WHEN orders.ShippedDate IS NOT NULL THEN 1 END) AS orders_fulfilled 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month 
ORDER BY month
""""""

# Execute the SQL query and retrieve data
df = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(df, x='month', y=['orders_placed', 'orders_fulfilled'], 
             labels={'value': 'Number of Orders', 'variable': 'Order Type'}, 
             title='Orders Placed and Fulfilled in 2023',
             barmode='group')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    MONTH(OrderDate) AS month,
    COUNT(OrderID) AS orders_placed,
    COUNT(CASE WHEN ShippedDate IS NOT NULL THEN OrderID END) AS orders_fulfilled
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY MONTH(OrderDate)
ORDER BY month;
""""""

order_data = execute_sql_query(sql_query)

fig = px.line(order_data, x='month', y=['orders_placed', 'orders_fulfilled'], 
               labels={'value': 'Number of Orders', 'month': 'Month'}, 
               title='Orders Placed and Fulfilled in 2023')
show_to_user(fig)
```","The input code uses a line plot instead of a grouped bar chart for visualization. The query groups by MONTH(OrderDate) which gives numeric month values instead of '%Y-%m' string format in the reference, potentially leading to different x-axis labels or sort order issues. The SQL logic for counting fulfilled orders is consistent, but visualization does not match the request or reference implementation.","```python
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       COUNT(*) AS total_orders 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY Month;
""""""
orders_df = execute_sql_query(sql_query)

# Ensure data types are correct for visualization
orders_df['Month'] = pd.to_datetime(orders_df['Month'])

# Create a visualization
fig = px.bar(orders_df, x='Month', y='total_orders', 
             title='Total Orders Placed in Each Month of 2023',
             labels={'total_orders': 'Total Orders', 'Month': 'Month'})

# Visualize the result
show_to_user(fig)
```","The input code only calculates and visualizes the total number of orders placed each month in 2023. It does not compute the number of orders fulfilled (orders with a non-null ShippedDate). To align with the reference implementation and the business request, the code should separately account for both 'orders_placed' and 'orders_fulfilled'.",None
What was the total sales revenue generated in the year 2023?,"```python
import pandas as pd

# SQL query to calculate total sales revenue for the year 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
sales_data_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(sales_data_df)
```
","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""
total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input Python code is correct as it follows the same logic as the reference implementation. Both execute the same SQL query to calculate the total sales revenue for the year 2023, and both call the execute_sql_query() function to execute the SQL statement and show_to_user() to display the result. The structure and logic of the implementation remain consistent.","```python
import pandas as pd

# SQL query to get total sales revenue for the year 2023
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    YEAR(orders.OrderDate) = 2023;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract total sales value
total_sales_2023 = result_df['total_sales'].iloc[0]

# Show the result to the user
show_to_user(total_sales_2023)
```","Both the input code and the reference implementation correctly calculate the total sales revenue for the year 2023. The SQL queries in both implementations select the sum of the product of UnitPrice, Quantity, and the discount adjustment. The input code uses the YEAR(orders.OrderDate) = 2023 condition instead of a date range, which is logically equivalent for selecting all orders in 2023. Additionally, the input code extracts the result from the DataFrame and displays it, which aligns with the intent of the reference code to show the results.",both
Which supplier supplies the highest number of different products?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SupplierID, COUNT(DISTINCT ProductID) AS ProductCount 
FROM products 
GROUP BY SupplierID 
ORDER BY ProductCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Ensure column names are correct and display the result to the user
result_df.columns = ['SupplierID', 'ProductCount']
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(DISTINCT p.ProductID) AS ProductCount
FROM suppliers AS s
JOIN products AS p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY ProductCount DESC
LIMIT 1;
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The provided code is correct because it adheres to the same logic as the reference implementation. Both codes compute the supplier who supplies the highest number of different products by counting distinct ProductIDs and ordering by this count in descending order. The only additional aspect in the input code is the inclusion of 'CompanyName' in the SELECT and GROUP BY clauses, which does not affect the correctness of determining the supplier based on the maximum distinct products.","To determine which supplier supplies the highest number of different products, we can use the following SQL query:

```sql
SELECT products.SupplierID, COUNT(DISTINCT products.ProductID) as ProductCount 
FROM products 
GROUP BY products.SupplierID 
ORDER BY ProductCount DESC 
LIMIT 1;
```

This query groups the products by their `SupplierID`, counts the distinct `ProductID`s for each supplier, orders the result in descending order by the count, and limits the result to the top entry.

Next, we will execute the query using Python and display the result.

Here's the complete code to achieve this:

```python
import pandas as pd

# SQL query to fetch the supplier with the highest number of different products
sql_query = """"""
SELECT products.SupplierID, COUNT(DISTINCT products.ProductID) as ProductCount 
FROM products 
GROUP BY products.SupplierID 
ORDER BY ProductCount DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```

In this case, the dataframe will contain just the top supplier and their product count, which matches the user's request.","The input code correctly implements the business analytics request. It uses a SQL query to find the supplier who supplies the highest number of different products, grouping by SupplierID and counting distinct ProductIDs. It orders the results in descending order and limits the output to one supplier, which matches the logic of the reference implementation.",both
What is the average shipping cost per order for 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
shipping_cost_df = execute_sql_query(sql_query)

# Ensure that only the average cost is presented
average_cost = shipping_cost_df.iloc[0]['shipping_cost_per_order']

# Convert the average cost to a DataFrame
result_df = pd.DataFrame({'shipping_cost_per_order': [average_cost]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(orders.Freight) AS average_shipping_cost
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

average_shipping_cost_df = execute_sql_query(sql_query)
show_to_user(average_shipping_cost_df)
```","The input code calculates the average shipping cost for orders placed in 2023, matching the business request and logic of the reference implementation. Both select the average of the 'Freight' column for orders in the specified date range. The minor difference in column name does not affect correctness. Both implementations display the result, although the input does so directly without further processing, which is acceptable.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(orders.Freight) as AverageShippingCostPerOrder 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the query and get the result as a dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df['AverageShippingCostPerOrder'].iloc[0])
```","The input code correctly calculates the average shipping cost per order for 2023 by using a SQL query, which mirrors the reference code's logic. It then presents the result to the user in compliance with the requirements. Despite minor differences in variable names used, the core logic and result presentation align with the reference implementation.",both
What is the total value of orders shipped in the first quarter of 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT QUARTER(o.OrderDate) AS OrderQuarter, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = 2023 
GROUP BY OrderQuarter;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Filter for the first quarter and retrieve total value
total_value_q1 = df[df['OrderQuarter'] == 1]['TotalValue'].values[0]

# Prepare the result for display
result = pd.DataFrame({
    'OrderQuarter': [1],
    'TotalValue': [total_value_q1]
})

# Display the result
show_to_user(result)
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.ShippedDate >= '2023-01-01' AND o.ShippedDate <= '2023-03-31'
""""""
total_value_df = execute_sql_query(sql_query)
show_to_user(total_value_df)
```","The input code calculates the total value of orders based on shipment dates, not order dates as specified in the reference implementation. The business request was for orders placed in the first quarter, not shipped.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the total order value from the dataframe
total_order_value = df['TotalOrderValue'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'TotalOrderValue': [total_order_value]}))
```","The input code calculates the total value of orders shipped in the first quarter of 2023 by summing up the product of UnitPrice, Quantity, and (1 - Discount) from the 'Order Details' table for orders between '2023-01-01' and '2023-03-31'. This is equivalent to the logic in the reference code, which calculates sums for the first quarter of 2023. While the reference groups by quarters and selects only the first quarter, the input code directly restricts the date range to the first quarter, achieving the same outcome.",Finetuned
What is the Customer Retention Rate for the last 6 months?,"```python
import pandas as pd

# Retrieve customer count for the last 6 months
sql_query_recent = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS customer_count_recent 
FROM orders 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 6 MONTH) AND CURDATE();
""""""
recent_data = execute_sql_query(sql_query_recent)
recent_customers = recent_data['customer_count_recent'].iloc[0]

# Retrieve total customer count for comparison for customer retention
sql_query_previous = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS customer_population_before 
FROM orders 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 12 MONTH) AND DATE_SUB(CURDATE(), INTERVAL 6 MONTH);
""""""
previous_data = execute_sql_query(sql_query_previous)
previous_customers = previous_data['customer_population_before'].iloc[0]

# Calculate Customer Retention Rate
customer_retention_rate = recent_customers / previous_customers if previous_customers != 0 else 0

# Create a DataFrame to display
retention_df = pd.DataFrame({
    'CustomerRetentionRate': [customer_retention_rate]
})

# Use utility function to show the result
show_to_user(retention_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate date ranges
end_date = datetime.now()
start_date = end_date - timedelta(days=180)

# Define SQL query for Customer Retention Rate
sql_query = f""""""
SELECT 
    (COUNT(DISTINCT CASE WHEN o.OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}' THEN o.CustomerID END) * 1.0 / 
    COUNT(DISTINCT o.CustomerID)) AS RetentionRate
FROM 
    orders o
WHERE 
    o.OrderDate < '{start_date.date()}'
""""""

# Execute SQL query
retention_rate_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(retention_rate_df)
```","The input Python code does not correctly calculate the Customer Retention Rate as specified in the request. The logic in the code calculates a RetentionRate by comparing the count of distinct customers from the last six months to the count of all distinct customers before the last six months, which differs from the reference implementation. The reference counts distinct customers in the six months prior to the last six months to serve as a comparison base.","```python
import pandas as pd

# Define the SQL Queries
query_new_customers = """"""
SELECT COUNT(DISTINCT customers.CustomerID) as NewCustomers 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate BETWEEN DATEADD(MONTH, -6, GETDATE()) AND GETDATE();
""""""

query_retained_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) as RetainedCustomers 
FROM orders 
WHERE orders.OrderDate BETWEEN DATEADD(MONTH, -12, GETDATE()) AND DATEADD(MONTH, -6, GETDATE());
""""""

# Execute the SQL Queries
df_new_customers = execute_sql_query(query_new_customers)
df_retained_customers = execute_sql_query(query_retained_customers)

# Calculate the Customer Retention Rate
new_customers = df_new_customers['NewCustomers'].iloc[0]
retained_customers = df_retained_customers['RetainedCustomers'].iloc[0]

# Handle division by zero
customer_retention_rate = (retained_customers / new_customers) if new_customers != 0 else 0

# Create a DataFrame for display
df_result = pd.DataFrame({'Customer Retention Rate': [customer_retention_rate]})

# Show the result to the user
show_to_user(df_result)
```","The input code calculates the retention rate incorrectly by dividing retained customers from 6-12 months ago by new customers from 0-6 months ago, whereas the reference implementation calculates it by dividing recent customers (0-6 months ago) by previous customers (6-12 months ago). The definitions of 'recent' and 'previous' periods are swapped between the two codes, leading to a conceptual discrepancy in the calculations.",None
What is the most common job title among the employees?,"```python
import pandas as pd

# SQL query to get the most common job title
sql_query = """"""
SELECT Title, COUNT(*) AS TitleCount
FROM employees
GROUP BY Title
ORDER BY TitleCount DESC
LIMIT 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
job_title_df = execute_sql_query(sql_query)

# Extract the most common job title and display it to the user
most_common_title = job_title_df.iloc[0]['Title']
show_to_user(most_common_title)
```","```python
sql_query = ""SELECT Title, COUNT(*) as count FROM employees GROUP BY Title ORDER BY count DESC LIMIT 1""
most_common_title = execute_sql_query(sql_query)
show_to_user(most_common_title)
```","The input code retrieves the result directly from the SQL query without accessing the specific column 'Title'. Instead, it should extract the 'Title' from the resulting dataframe to match the reference implementation.","```python
import pandas as pd

# SQL query to find the most common job title
sql_query = """"""
SELECT JobTitle, COUNT(*) AS TitleCount 
FROM employees 
GROUP BY JobTitle 
ORDER BY TitleCount DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code executes a SQL query to find the most common job title correctly, but the column name used in the SQL query is 'JobTitle' instead of 'Title', which might be a discrepancy unless the column name in the database is indeed 'JobTitle'. Additionally, the result is shown directly using 'show_to_user(result_df)', which would display the entire dataframe rather than just the most common job title. The code should extract the specific title from the dataframe before displaying it, similar to the reference implementation with '.iloc[0]['Title']'.",None
Find the difference in days between the hire date and the birthdate of employees.,"```python
import pandas as pd

# SQL query to get employee data
sql_query = """"""
SELECT EmployeeID, HireDate, BirthDate FROM employees;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the difference in days between hire date and birth date
df['HireDate'] = pd.to_datetime(df['HireDate'])
df['BirthDate'] = pd.to_datetime(df['BirthDate'])
df['DaysDifference'] = (df['HireDate'] - df['BirthDate']).dt.days

# Select necessary columns
result_df = df[['EmployeeID', 'DaysDifference']]

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd

sql_query = """"""
SELECT 
    EmployeeID,
    DATEDIFF(HireDate, BirthDate) AS DaysBetweenHireAndBirth
FROM 
    employees
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The provided code uses a SQL DATEDIFF function, which directly computes the difference in days between 'HireDate' and 'BirthDate' within the SQL query. This approach assumes the database supports DATEDIFF and will return integer differences directly from the query execution. While this approach might be correct depending on the database, it differs from the reference implementation, which calculates the difference in Python using pandas. The task requires adherence to the same logic; hence, it doesn't match the reference implementation strategy.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    DATEDIFF(HireDate, BirthDate) AS DifferenceInDays
FROM 
    employees;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The provided Python code relies on using a SQL `DATEDIFF` function, assuming the database supports it, to directly calculate the day difference between hire date and birthdate. The reference implementation uses Python's `pandas` to calculate this difference after fetching dates, ensuring correct data type conversion and calculation directly in Python. The provided code doesn't perform these steps nor does it ensure that the `DATEDIFF` behavior matches Python's date arithmetic exactly. Additionally, it fails to include `EmployeeID` in the result, which is part of the reference implementation.",None
How many products are discontinued?,"```python
import pandas as pd

# SQL query to find the number of discontinued products
sql_query = ""SELECT COUNT(*) AS discontinued_products FROM products WHERE products.Discontinued = 1""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Extract the count of discontinued products
discontinued_products_count = discontinued_products_df.iloc[0]['discontinued_products']

# Display the result
show_to_user(discontinued_products_count)
```","```python
sql_query = ""SELECT COUNT(*) AS discontinued_products FROM products WHERE Discontinued = 1""
discontinued_products_df = execute_sql_query(sql_query)
show_to_user(discontinued_products_df)
```",The provided code does not extract the count of discontinued products from the dataframe before displaying it. It directly passes the entire dataframe to the show_to_user function. The correct step would be to retrieve the specific count value like in the reference implementation.,"```python
import pandas as pd

# SQL query to find the count of discontinued products
sql_query = ""SELECT COUNT(*) AS DiscontinuedCount FROM products WHERE Discontinued=1;""

# Execute the SQL query
discontinued_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discontinued_df['DiscontinuedCount'][0])
```","The input Python code correctly answers the business analytics request by executing a SQL query to count the number of discontinued products, using the same logic as the reference implementation. The variable names and column alias differ but do not affect the correctness, as both extract and display the count from the SQL result set accurately.",Finetuned
List all orders that took more than 10 days to fulfill in 2021.,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT OrderID 
FROM orders 
WHERE YEAR(OrderDate) = 2021 
AND DATEDIFF(ShippedDate, OrderDate) > 10;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT OrderID, OrderDate, ShippedDate, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE YEAR(OrderDate) = 2021 AND DATEDIFF(ShippedDate, OrderDate) > 10
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly identifies orders that took more than 10 days to fulfill in 2021. It uses the same conditions as the reference implementation: filtering by order date in the year 2021 and a fulfillment time greater than 10 days. The inclusion of additional fields such as OrderDate, ShippedDate, and FulfillmentTime in the select clause does not affect the correctness as the core logic is identical to the reference.","```python
import pandas as pd

# SQL query to be executed
sql_query = """"""
SELECT OrderID, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE YEAR(OrderDate) = 2021 AND DATEDIFF(ShippedDate, OrderDate) > 10;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)
```","The input Python code correctly implements the business analytics request. It selects orders from 2021 that took more than 10 days to fulfill. Although the input code includes an additional column 'FulfillmentTime', which is not present in the reference implementation, this does not affect the correctness in terms of fulfilling the business requirement of listing the appropriate orders.",both
What was the total sales revenue generated each month in the year 2022? Please include a time series chart to visualize monthly trends.,"```python
import plotly.express as px

# SQL query as provided
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(OrderDate) = 2022 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Convert 'Month' column to a datetime object for sorting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Sort the dataframe by 'Month'
sales_data = sales_data.sort_values(by='Month')

# Create the time series chart
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Sales Revenue for 2022')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(OrderDate) = 2022
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.line(total_sales_df, x='Month', y='TotalSales', title='Monthly Total Sales Revenue in 2022', labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})
show_to_user(fig)
```","The input Python code correctly answers the business analytics request. It uses a SQL query to calculate the total sales revenue per month for the year 2022 using the same logic as the reference implementation. Both codes format the order date, join the orders with order details, calculate total sales, and group by month. The order and structure of the query are equivalent, and they both create a time series chart using Plotly Express to visualize the trends.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY Month
""""""

# Execute the query and get the results as a pandas dataframe
df = execute_sql_query(sql_query)

# Convert 'Month' column to datetime for proper sorting
df['Month'] = pd.to_datetime(df['Month'])

# Create a time series chart
fig = px.line(df, x='Month', y='TotalSales', title='Monthly Sales Revenue for 2022')

# Show the result to the user
show_to_user(fig)
```","The input code correctly implements the business analytics request. It performs the same operations as the reference implementation though with slight differences in SQL syntax and variable names. Both versions join the 'orders' and 'Order Details' tables, filter for the year 2022, and calculate total sales per month. The conversion of the 'Month' column to a datetime object ensures consistent sorting. The visualization with a time series chart is also implemented correctly. Therefore, the logic aligns with the reference implementation.",both
What was the total sales revenue for the month of January 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-01';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales value
total_sales = result_df.iloc[0, 0]

# Display the result
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
""""""

total_sales_january = execute_sql_query(sql_query)
show_to_user(total_sales_january)
```","Both the input and reference code aim to calculate total sales revenue for January 2023 using a SQL query. The input query accurately calculates the sum of sales for orders placed between '2023-01-01' and '2023-02-01', which is logically equivalent to checking if the order date falls in January 2023 using DATE_FORMAT as in the reference. Despite different syntax, they achieve the same result. Therefore, the input code is correct according to the specified request.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total revenue value
total_revenue = result_df['TotalRevenue'].iloc[0]

# Show the result to the user
show_to_user(pd.DataFrame({'Total Revenue for January 2023': [total_revenue]}))
```","Both implementations correctly calculate the total sales for January 2023. The reference code uses 'DATE_FORMAT' for filtering, while the input code uses 'BETWEEN' for date comparison. Both achieve the correct date range. The input code correctly sums 'UnitPrice * Quantity * (1 - Discount)' as 'TotalRevenue' similarly to the reference implementation's 'TotalSales'. The key steps and logic are aligned.",both
"What is the average order value for orders placed between January 1, 2023, and December 31, 2023?","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and retrieve the data in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Extract the average order value
avg_order_value = result_df['avg_order_value'].iloc[0]

# Display the result to the user
show_to_user(avg_order_value)
```","```python
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""
avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)
```",The input code directly displays the DataFrame instead of extracting the 'avg_order_value' before showing it to the user. It should extract the value using avg_order_value_df['avg_order_value'].iloc[0] as in the reference implementation.,"To calculate the average order value for orders placed between January 1, 2023, and December 31, 2023, we need to sum the total prices of all items in all orders during that period and then divide by the total number of unique orders. 

Hereâ€™s the Python code to perform this operation using the provided MDDX datawarehouse:

```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as total_order_value,
    COUNT(DISTINCT orders.OrderID) as order_count
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Calculate average order value
df['average_order_value'] = df['total_order_value'] / df['order_count']

# Display the result
average_order_value = df[['average_order_value']]
show_to_user(average_order_value)
```

### Explanation:
1. **SQL Query Definition**: We define a SQL query that selects the sum of the total order value and the count of distinct orders for the specified date range.
   
2. **Execute SQL Query**: The `execute_sql_query` function is called with the SQL query string which retrieves the necessary data as a pandas DataFrame.

3. **Calculate Average Order Value**: The average order value is computed by dividing the total order value (`total_order_value`) by the number of distinct orders (`order_count`).

4. **Display Result**: Finally, the calculated average order value is displayed to the user using `show_to_user` function. 

Make sure to adjust any discrepancies in column names from the SQL to the resulting DataFrame structure as needed.","The input code correctly implements the logic described in the business analytics request and follows the same structure as the reference implementation. Both codes calculate the average order value by finding the sum of order values and dividing it by the count of unique orders within the specified date range. The operations performed, such as joining tables, filtering by date range, and calculating the average are consistent between both implementations. Therefore, the input code is correct.",Finetuned
Which city has received the highest number of orders?,"```python
import pandas as pd

# SQL query to find the city with the highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) as TotalOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY TotalOrders DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1;
""""""

highest_order_city = execute_sql_query(sql_query)
show_to_user(highest_order_city)
```","The input code correctly executes a SQL query to find the city with the highest number of orders. It uses the same logic as the reference implementation by selecting the 'ShipCity' and counting 'OrderID', grouping by 'ShipCity', ordering the results by the count in descending order, and limiting the output to one city. Both implementations use the 'execute_sql_query' function and then display the results using 'show_to_user'. Therefore, it is correct.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC LIMIT 1
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The provided code implements the same logical flow as the reference code. It counts the number of orders per city, groups by ShipCity, orders the results in descending order based on the count, and retrieves the top result, which is the correct way to identify the city with the highest number of orders.",both
Which product category has the highest total sales in 2023? Use a bar chart to visualize sales by category.,"```python
import plotly.express as px

# SQL query to get total sales by product category in 2023
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName 
ORDER BY total_sales DESC
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CategoryName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY c.CategoryName
ORDER BY total_sales DESC
""""""

sales_data = execute_sql_query(sql_query)
fig = px.bar(sales_data, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')
show_to_user(fig)
```","The input Python code replicates the logic of the reference implementation accurately. Both codes execute a SQL query to calculate the total sales per product category in 2023 by joining the necessary tables and applying the same sales calculation formula (UnitPrice * Quantity * (1 - Discount)). The only variations are in variable names and formatting, which do not affect the correctness of the solution. Additionally, both implementations use Plotly to visualize the results and display the bar chart.","```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Convert to numeric to avoid any potential issues
sales_data['total_sales'] = pd.to_numeric(sales_data['total_sales'])

# Create a bar chart for sales by category
fig = px.bar(sales_data, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')

# Show the chart to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to calculate total sales by product category in 2023. It aggregates the sales, using the same logic as the reference implementation by joining relevant tables and applying necessary filters. Furthermore, the bar chart is appropriately created using Plotly to visualize sales by category. The minor addition in the input code of converting 'total_sales' to numeric is a precautionary step and does not affect the correctness of the implementation.",both
What is the average reorder level across all products?,"```python
sql_query = ""SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products;""
result_df = execute_sql_query(sql_query)
average_reorder_level = result_df['AverageReorderLevel'].iloc[0]
show_to_user(average_reorder_level)
```","```python
sql_query = ""SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products""
average_reorder_level_df = execute_sql_query(sql_query)
show_to_user(average_reorder_level_df)
```","The input code displays the entire DataFrame containing the average reorder level, whereas the reference code extracts and shows only the singular value. The input doesn't isolate the numeric result for display.","```python
import pandas as pd

# SQL query to get all products
sql_query = ""SELECT ReorderLevel FROM products;""

# Execute the query
df = execute_sql_query(sql_query)

# Calculate the average reorder level
average_reorder_level = df['ReorderLevel'].mean()

# Prepare the result to show to the user
result_df = pd.DataFrame({'AverageReorderLevel': [average_reorder_level]})

# Show the result to the user
show_to_user(result_df)
```","The input code creates a DataFrame with the average reorder level and then uses `show_to_user` on the entire DataFrame, while the reference code only shows the average reorder level value itself. The input code does not adhere to the reference implementation logic in terms of output formatting.",None
What is the total inventory value of products currently in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT SUM(UnitsInStock * UnitPrice) AS TotalInventoryValue FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the total inventory value from the dataframe
total_inventory_value = df.loc[0, 'TotalInventoryValue']

# Prepare a dataframe to display
result_df = pd.DataFrame({'TotalInventoryValue': [total_inventory_value]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products
WHERE Discontinued = 0
""""""

total_inventory_value = execute_sql_query(sql_query)
show_to_user(total_inventory_value)
```","The provided input code filters the products where 'Discontinued = 0', while the reference code does not apply any such filter. This discrepancy means the input code and the reference code operate under different assumptions about which products are considered 'in stock'. Therefore, the input code does not exactly follow the logic of the reference implementation.","To determine the total inventory value of products currently in stock, we can directly calculate the sum of the product of `UnitsInStock` and `UnitPrice` for each product.

Hereâ€™s the Python code to perform this calculation:

```python
import pandas as pd

# Define SQL query
sql_query = ""SELECT UnitPrice, UnitsInStock FROM products;""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Calculate total inventory value
total_inventory_value = (products_df['UnitPrice'] * products_df['UnitsInStock']).sum()

# Prepare the result as a dataframe
result_df = pd.DataFrame({'TotalInventoryValue': [total_inventory_value]})

# Display the result to the user
show_to_user(result_df)
```

This code will calculate the total inventory value and display it as a DataFrame with a single entry labeled ""TotalInventoryValue"".","The input Python code correctly calculates the total inventory value by fetching `UnitPrice` and `UnitsInStock` from the database, multiplying them to get the value for each product, and then summing them up. This aligns with the business request to calculate the total inventory value and follows the same logical steps as the reference implementation.",Finetuned
Find the average quantity of products ordered per order.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG([Order Details].Quantity) AS AverageQuantity
FROM [Order Details]
GROUP BY [Order Details].OrderID
""""""

average_quantity_df = execute_sql_query(sql_query)
show_to_user(average_quantity_df)
```","The input code calculates the average quantity per order by grouping with `OrderID`, which differs from the reference code. The reference code computes the overall average quantity without grouping, which matches the request to 'Find the average quantity of products ordered per order'. The input code's logic averages quantities within each order, not across all orders.","```python
import pandas as pd

# SQL query to get the average quantity of products ordered per order
sql_query = ""SELECT AVG(od.Quantity) AS AverageQuantityPerOrder FROM [Order Details] od;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average quantity value
average_quantity = result_df.loc[0, 'AverageQuantityPerOrder']

# Display the result to user
show_to_user(pd.DataFrame({'AverageQuantityPerOrder': [average_quantity]}))
```","The input Python code correctly calculates the average quantity of products ordered per order. It performs a similar SQL query to the reference code, selecting the average from the 'Quantity' column of the 'Order Details' table. The naming of the alias differs but does not affect the correctness. Both implementations extract and display the same measure, adhering to the same logic and fulfilling the business analytics request.",Finetuned
What is the percentage of orders shipped within the same country as the customer?,"```python
import pandas as pd

# SQL query to get the number of orders shipped within the same country as the customer
sql_query_same_country = """"""
SELECT COUNT(*) as count_same_country 
FROM orders o 
JOIN customers c ON o.CustomerID = c.CustomerID 
WHERE o.ShipCountry = c.Country;
""""""

# SQL query to get the total number of orders
sql_query_total_orders = """"""
SELECT COUNT(*) as total_orders 
FROM orders;
""""""

# Execute the SQL queries
result_same_country = execute_sql_query(sql_query_same_country)
result_total_orders = execute_sql_query(sql_query_total_orders)

# Calculate the percentage of orders shipped within the same country
percentage_same_country = (result_same_country['count_same_country'][0] / result_total_orders['total_orders'][0]) * 100

# Prepare the result for display
result_df = pd.DataFrame({'percent_same_country': [percentage_same_country]})

# Use the show_to_user function to display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(*) AS total_orders,
    SUM(CASE WHEN customers.Country = orders.ShipCountry THEN 1 ELSE 0 END) AS domestic_orders
FROM 
    orders
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
""""""

result_df = execute_sql_query(sql_query)
percentage_domestic = (result_df['domestic_orders'].iloc[0] / result_df['total_orders'].iloc[0]) * 100

show_to_user(pd.DataFrame({'Percentage of Domestic Orders': [percentage_domestic]}))
```","The input code successfully calculates the percentage of orders shipped within the same country as the customer. It accurately uses a SQL query to count total orders and those shipped domestically, replicating the logic in the reference implementation. Both codes compute the percentage in a conceptually similar manner, despite slight differences in SQL and calculation structure.","```python
import pandas as pd

# SQL Query to get all the necessary data
sql_query = """"""
SELECT orders.OrderID, orders.ShipCountry, customers.Country 
FROM orders 
JOIN customers ON orders.CustomerID = customers.CustomerID;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Calculate percentage of orders shipped within the same country
same_country_orders = df[df['ShipCountry'] == df['Country']].shape[0]
total_orders = df.shape[0]

percentage_same_country = (same_country_orders / total_orders) * 100

# Prepare a DataFrame to display
result_df = pd.DataFrame({'Percentage of Orders Shipped Within Same Country': [percentage_same_country]})

# Display the result
show_to_user(result_df)
```","Both the reference implementation and the input code correctly calculate the percentage of orders shipped within the same country as the customer. The logic of joining orders with customers on CustomerID and filtering where ShipCountry matches the customer's Country is consistent in both versions. Although the implementation details differ, the overall approach and outcome are aligned.",both
List all employees who were hired this year.,"```python
from datetime import datetime
import pandas as pd

# Construct the SQL query
current_year = datetime.now().year
sql_query = f""SELECT * FROM employees WHERE YEAR(HireDate) = {current_year};""

# Execute the SQL query and retrieve data
employees_hired_this_year = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_hired_this_year)
```","```python
from datetime import datetime
import pandas as pd

current_year = datetime.now().year
sql_query = f""""""
SELECT EmployeeID, FirstName, LastName, HireDate 
FROM employees 
WHERE YEAR(HireDate) = {current_year}
""""""

employees_hired_this_year = execute_sql_query(sql_query)
show_to_user(employees_hired_this_year)
```","The input code correctly matches the logic of the reference implementation. It constructs an SQL query to select employees hired in the current year using the same condition 'WHERE YEAR(HireDate) = current_year'. Although the input code specifies particular columns (EmployeeID, FirstName, LastName, HireDate) whereas the reference implementation retrieves all columns using '*', the core logic and requirement are met, and this doesn't affect the correctness in fulfilling the business request.","```python
import pandas as pd
from datetime import datetime

# SQL query to find employees hired this year
current_year = datetime.now().year
sql_query = f""SELECT * FROM employees WHERE YEAR(HireDate) = {current_year};""

# Execute the SQL query
employees_this_year = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_this_year)
```","The input Python code constructs the same SQL query as the reference implementation to select employees hired in the current year. It uses the same functions, `execute_sql_query` and `show_to_user`, to execute the query and display results. Therefore, it adheres to the specified logic and is correct.",both
What is the total revenue generated each year? Visualize the trends with a line graph.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS YearlyRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Year 
ORDER BY Year;
""""""

# Execute the SQL query
dataframe = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(dataframe, x='Year', y='YearlyRevenue', title='Total Revenue Generated Each Year', labels={'YearlyRevenue': 'Revenue'})

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    YEAR(o.OrderDate) AS Year,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    YEAR(o.OrderDate)
ORDER BY 
    Year
""""""

revenue_data = execute_sql_query(sql_query)
fig = px.line(revenue_data, x='Year', y='TotalRevenue', title='Total Revenue Generated Each Year')
show_to_user(fig)
```","The input code correctly implements the same logic as the reference code. Both codes query the total revenue generated each year using SQL, summing the product of UnitPrice, Quantity, and the discount factor. The result is grouped by and ordered by the year. The revenue is then visualized using Plotly with a line graph. The differences in the SQL syntax (YEAR function vs EXTRACT(YEAR FROM)) do not affect the logic or the outcome as both extract the year portion. Thus, the input code adheres to the desired business analytics request.","```python
import plotly.express as px

# SQL query to get total revenue per year
sql_query = """"""
SELECT YEAR(o.OrderDate) AS Year, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY YEAR(o.OrderDate);
""""""

# Execute the SQL query and retrieve the data
revenue_data = execute_sql_query(sql_query)

# Visualize the trends with a line graph
fig = px.line(revenue_data, x='Year', y='TotalRevenue', title='Total Revenue Generated Each Year')

# Show the plot to the user
show_to_user(fig)
```","The input Python code implementation is correct because it executes a SQL query that calculates the total revenue for each year exactly like the reference code, using the YEAR function to extract the year from the order date and summing the product of UnitPrice, Quantity, and Discount. The code then visualizes the data using a line graph with Plotly, which fulfills the business analytics request. Both implementations effectively adhere to the same logic despite slight differences in SQL syntax and variable names.",both
Find the total quantity ordered for each product. Use a bar chart for better visualization.,"```python
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, SUM(Quantity) AS total_quantity FROM [Order Details] GROUP BY ProductID;""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='total_quantity', title='Total Quantity Ordered by Product')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT [Order Details].ProductID, SUM([Order Details].Quantity) AS TotalQuantity
FROM [Order Details]
GROUP BY [Order Details].ProductID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductID', y='TotalQuantity', title='Total Quantity Ordered for Each Product')
show_to_user(fig)
```","The provided code correctly executes an SQL query to sum the 'Quantity' for each 'ProductID' from the '[Order Details]' table, similar to the reference implementation. It then creates a bar chart using Plotly to visualize the 'TotalQuantity' for each 'ProductID', just like the reference. The difference in column naming ('TotalQuantity' vs 'total_quantity') is acceptable as both refer to the same aggregated quantity data, preserving the logic and objective.","To fulfill the request of finding the total quantity ordered for each product and visualizing it with a bar chart, we can utilize the `plotly.express` module for the visualization. Here's the Python code that achieves this:

```python
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantityOrdered
FROM [Order Details]
GROUP BY ProductID;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create the bar chart using plotly
fig = px.bar(df, x='ProductID', y='TotalQuantityOrdered', 
             title='Total Quantity Ordered per Product',
             labels={'TotalQuantityOrdered': 'Total Quantity Ordered', 'ProductID': 'Product ID'})

# Display the bar chart using the provided utility function
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: The SQL query selects `ProductID` and calculates the total ordered quantity (`TotalQuantityOrdered`) by summing the `Quantity` grouped by `ProductID`.
   
2. **DataFrame Execution**: The result of executing the SQL query is assumed to return a DataFrame containing at least two columns: `ProductID` and `TotalQuantityOrdered`.

3. **Plotting**: The code uses `plotly.express` to create a bar chart wherein `ProductID` is plotted along the x-axis and `TotalQuantityOrdered` serves as the y-axis.

4. **Display**: Finally, the generated bar chart is displayed to the user using the provided `show_to_user` function.

This code provides a clear, visual representation of the total quantity ordered for each product.","The input code correctly fulfills the business analytics request. It uses an SQL query to retrieve the total quantity ordered for each product and uses Plotly to create a bar chart. The SQL logic matches the reference implementation, and the visualization accurately reflects the required data. The difference in naming the quantity column does not affect the correctness of the logic.",both
How many orders have been placed by customers in Germany in the year 2023?,"```python
import pandas as pd

# SQL query to fetch order count
sql_query = """"""
SELECT COUNT(o.OrderID) as OrderCount 
FROM orders o 
JOIN customers c ON o.CustomerID = c.CustomerID 
WHERE c.Country = 'Germany' 
AND o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
order_count_df = execute_sql_query(sql_query)

# Display the result
show_to_user(order_count_df['OrderCount'][0])
```","```python
sql_query = """"""
SELECT COUNT(orders.OrderID) AS order_count 
FROM orders 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE customers.Country = 'Germany' 
AND YEAR(orders.OrderDate) = 2023
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly counts the number of orders placed by customers in Germany for the year 2023. The SQL query joins the orders and customers tables, filters by the country 'Germany', and checks if the order date falls within the year 2023 using the YEAR() function. This logic matches the intent of the reference implementation.","```python
import pandas as pd

# SQL query to find the number of orders placed by customers in Germany in 2023
sql_query = """"""
SELECT COUNT(*) AS number_of_orders
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
WHERE customers.Country = 'Germany' AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31';
""""""

# Execute the SQL query using the provided utility function and get the result as a pandas dataframe
orders_in_germany_2023 = execute_sql_query(sql_query)

# Extract and display the result to the user
number_of_orders = orders_in_germany_2023.loc[0, 'number_of_orders']
show_to_user(pd.DataFrame({'number_of_orders': [number_of_orders]}))
```","The input code correctly follows the logic of the reference implementation. Both snippets execute a SQL query joining the 'customers' and 'orders' tables, filtering by the country 'Germany' and the date range for 2023, and then counting the orders. The input code retrieves and displays the order count in the same manner as the reference implementation.",both
Calculate the average age of employees.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT BirthDate FROM employees;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the average age
df['Age'] = (pd.to_datetime('today') - pd.to_datetime(df['BirthDate'])) / pd.Timedelta(days=365.25)
avg_age = df['Age'].mean()

# Display the result to the user
show_to_user(pd.DataFrame({'AvgAge': [avg_age]}))
```","```python
sql_query = """"""
SELECT AVG(TIMESTAMPDIFF(YEAR, BirthDate, CURDATE())) AS AverageAge
FROM employees
""""""

average_age_df = execute_sql_query(sql_query)
show_to_user(average_age_df)
```","Both code implementations correctly calculate the average age of employees. The reference implementation calculates individual ages from birth dates and then averages them, while the input code uses SQL to directly compute the average age using the TIMESTAMPDIFF function. Both approaches yield the same result: the average age.","```python
import pandas as pd

# SQL query to fetch employee data
sql_query = ""SELECT DATEDIFF(CURDATE(), BirthDate) / 365 AS Age FROM employees;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the average age
average_age = df['Age'].mean()

# Prepare the result as a DataFrame
result_df = pd.DataFrame({'AverageAge': [average_age]})

# Display the result
show_to_user(result_df)
```",The input Python code correctly calculates the average age of employees in a manner similar to the reference implementation. It uses SQL to compute the age directly and then calculates the mean. Both methods correctly fulfill the business analytics request to calculate the average age of employees.,both
What is the total discount given on orders placed in 2022?,"```python
import pandas as pd

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract total_discount from the dataframe
total_discount = result_df['total_discount'].iloc[0]

# Show the result to the user
show_to_user(total_discount)
```","```python
sql_query = """"""
SELECT SUM(Discount * Quantity) AS TotalDiscount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

total_discount_df = execute_sql_query(sql_query)
show_to_user(total_discount_df)
```",The provided code is incorrect because it shows the entire dataframe 'total_discount_df' to the user instead of extracting the 'TotalDiscount' value and showing only that. The reference implementation extracts the specific discount value using 'result_df['total_discount'].iloc[0]' before displaying it.,"```python
import pandas as pd

# SQL Query to get total discount for orders placed in 2022
sql_query = """"""
SELECT SUM(OD.UnitPrice * OD.Quantity * OD.Discount) AS TotalDiscount 
FROM orders O 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
WHERE O.OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df['TotalDiscount'].sum())
```","The input Python code correctly calculates the total discount on orders placed in 2022. It forms an SQL query to compute the sum of discounts by multiplying UnitPrice, Quantity, and Discount for orders within the specified date range. The resulting sum is then retrieved and displayed using the same method as the reference implementation. Both implementations effectively extract and present the total discount amount, adhering to the logic described in the business request.",Finetuned
Which customer region had the highest average order fulfillment time in the past month? Include a heat map for regional comparison.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
WHERE OrderDate >= CURDATE() - INTERVAL 1 MONTH 
GROUP BY ShipRegion 
ORDER BY AvgFulfillmentTime DESC;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a heat map for regional comparison
fig = px.density_heatmap(df, x='ShipRegion', y='AvgFulfillmentTime', 
                         z='AvgFulfillmentTime',
                         color_continuous_scale='Viridis', 
                         title='Average Order Fulfillment Time by Region')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Get the current date and calculate the date one month ago
one_month_ago = pd.to_datetime(""today"") - pd.DateOffset(months=1)
one_month_ago_str = one_month_ago.strftime('%Y-%m-%d')

# SQL query to get average order fulfillment time by region
sql_query = f""""""
SELECT 
    ShipRegion, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM 
    orders 
WHERE 
    OrderDate >= '{one_month_ago_str}' 
GROUP BY 
    ShipRegion 
ORDER BY 
    AvgFulfillmentTime DESC
""""""

# Execute the SQL query and retrieve data
fulfillment_data = execute_sql_query(sql_query)

# Get the region with the highest average fulfillment time
highest_region = fulfillment_data.iloc[0]

# Create a heat map for the regional comparison
heatmap_fig = px.imshow(
    fulfillment_data.set_index('ShipRegion').T, 
    labels=dict(x=""Region"", y=""Metrics"", color=""Average Fulfillment Time""),
    x=fulfillment_data['ShipRegion'],
    y=[""Average Fulfillment Time""],
    color_continuous_scale='Viridis'
)

# Display results to the user
show_to_user(heatmap_fig)
```","The input code logically matches the reference implementation. It calculates the average order fulfillment time for each region over the past month, executing an appropriate SQL query to do so, similar to the reference code. Both implementations use Plotly to create a heat map for visualization utilizing the Viridis color scale. The input code retrieves the highest region and uses `px.imshow` for the heat map, whereas the reference uses `px.density_heatmap`. Both achieve comparison purposes though their graph creation methods differ slightly, yet still consistent with logic requirements.","```python
import plotly.express as px
import pandas as pd

# SQL query to get average fulfillment time by region
sql_query = """"""
SELECT Region, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
FROM orders 
WHERE OrderDate >= CURDATE() - INTERVAL 1 MONTH
GROUP BY Region
ORDER BY AvgFulfillmentTime DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure column names are consistent with usage later
df.columns = ['Region', 'AvgFulfillmentTime']

# Create a heat map for regional comparison
fig = px.choropleth(
    df,
    locations='Region',
    locationmode='country names',  # Adjust based on the Region column data if necessary
    color='AvgFulfillmentTime',
    color_continuous_scale=px.colors.sequential.Plasma,
    title='Average Order Fulfillment Time by Region (Past Month)'
)

# Show the heat map to the user
show_to_user(fig)

# Showing only the region with the highest average fulfillment time
top_region = df.head(1)
show_to_user(top_region)
```","The input code uses `px.choropleth` instead of `px.density_heatmap`. It also assumes regions can be mapped in `locationmode='country names'`, which may not be correct if regions are not country names. Additionally, the DATEDIFF function has different argument orders (`day` is used, which could be a specific SQL dialect). These differences can lead to inconsistent results and do not adhere to the reference implementation logic where a simple heatmap by region using `px.density_heatmap` is created.",Base
What is the average price per unit of all products?,"```python
import pandas as pd

# SQL query to calculate the average price per unit of all products
sql_query = ""SELECT AVG(UnitPrice) AS AveragePrice FROM products;""

# Execute the SQL query and get the result in a dataframe
df = execute_sql_query(sql_query)

# Display the average price to the user
average_price = df.at[0, 'AveragePrice']
show_to_user(pd.DataFrame({'Average Price': [average_price]}))
```","```python
sql_query = """"""
SELECT AVG(UnitPrice) AS AveragePricePerUnit
FROM products
WHERE Discontinued = 0
""""""

average_price_df = execute_sql_query(sql_query)
show_to_user(average_price_df)
```","The input Python code adds a condition `WHERE Discontinued = 0`, which filters out products that are discontinued. This deviates from the business analytics request of calculating the average price per unit of all products. The reference implementation calculates the average price without any filtering condition.","```python
import pandas as pd

# Define SQL query
sql_query = ""SELECT AVG(UnitPrice) AS AverageUnitPrice FROM products;""

# Execute SQL query and retrieve data
df_average_unit_price = execute_sql_query(sql_query)

# Show the average price per unit to the user
show_to_user(df_average_unit_price['AverageUnitPrice'].iloc[0])
```","The input Python code correctly calculates the average price per unit by executing the SQL query 'SELECT AVG(UnitPrice) AS AverageUnitPrice FROM products;'. It then retrieves the result from the dataframe and displays it to the user with 'show_to_user'. The input code performs the same logical steps as the reference code, although the variable names differ slightly. The key computation and its execution are aligned with the reference implementation.",Finetuned
Find the average order value for each customer. Use a histogram to visualize the distribution.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT c.CustomerID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) as average_order_value 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute SQL query to get data
df = execute_sql_query(sql_query)

# Create histogram to visualize distribution of average order value
fig = px.histogram(df, x='average_order_value', nbins=30, title=""Distribution of Average Order Value per Customer"")

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent,
       COUNT(o.OrderID) AS OrderCount,
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID
""""""

average_order_value_df = execute_sql_query(sql_query)

fig = px.histogram(average_order_value_df, x='AverageOrderValue', 
                   title='Distribution of Average Order Values per Customer',
                   labels={'AverageOrderValue': 'Average Order Value'})
show_to_user(fig)
```","The input code correctly calculates the average order value for each customer by grouping on CustomerID and using the AVG function on the order details. It also includes additional calculations like TotalSpent and OrderCount, which do not affect the correctness of the returned data for AverageOrderValue. The visualization uses Plotly to create a histogram of the average order values, similar to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a histogram to visualize the distribution of average order values
fig = px.histogram(df, x='AvgOrderValue', nbins=30, title='Distribution of Average Order Value per Customer', 
                   labels={'AvgOrderValue': 'Average Order Value'})

# Use the provided utility function to display the figure to the user
show_to_user(fig)
```","Both the reference and input Python codes calculate the average order value for each customer by summing the product of unit price, quantity, and discount, and dividing by the number of distinct orders per customer. The SQL query structure is logically the same in both, and both implementations use Plotly to create a histogram for visualizing the distribution of average order values. The labels for 'average_order_value' are correctly adjusted in the input code as 'AvgOrderValue', ensuring consistency with the SQL query output.",both
What is the on-time delivery rate for the month of April 2023? Visualize the results with a pie chart.,"```python
import plotly.express as px

# The SQL query to get the on-time delivery rate
sql_query = """"""
SELECT COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Extract the on-time delivery rate from the dataframe
on_time_delivery_rate = df.loc[0, 'on_time_delivery_rate']

# Create a pie chart to visualize the on-time delivery rate
data = {'On-Time': on_time_delivery_rate, 'Late': 1 - on_time_delivery_rate}
labels = list(data.keys())
values = list(data.values())

fig = px.pie(names=labels, values=values, title=""On-Time Delivery Rate for April 2023"")

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) AS on_time_deliveries, 
    COUNT(orders.OrderID) AS total_deliveries 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
""""""

result_df = execute_sql_query(sql_query)
on_time_rate = result_df['on_time_deliveries'][0] / result_df['total_deliveries'][0]

labels = ['On-time', 'Late']
values = [result_df['on_time_deliveries'][0], result_df['total_deliveries'][0] - result_df['on_time_deliveries'][0]]

fig = px.pie(names=labels, values=values, title='On-Time Delivery Rate for April 2023')
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate using the logic equivalent to the reference code. It ensures filtered counting with non-identical but logically similar SQL, then computes the ratio for on-time deliveries. The pie chart is produced using valid data, showing on-time versus late deliveries, aligning with the business analysis request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the on-time delivery rate
sql_query = """"""
SELECT 
    (COUNT(OrderID) * 100.0 / (SELECT COUNT(OrderID) FROM orders WHERE DATE_FORMAT(OrderDate, '%Y-%m') = '2023-04'))) AS OnTimeDeliveryRate 
FROM orders 
WHERE ShippedDate <= RequiredDate AND DATE_FORMAT(OrderDate, '%Y-%m') = '2023-04';
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the on-time delivery rate
on_time_delivery_rate = df.iloc[0]['OnTimeDeliveryRate']

# Prepare data for pie chart
data = pd.DataFrame({
    'Status': ['On-Time', 'Late'],
    'Rate': [on_time_delivery_rate, 100 - on_time_delivery_rate]
})

# Create a pie chart
fig = px.pie(data, names='Status', values='Rate', title='On-Time Delivery Rate for April 2023')

# Display the result
show_to_user(fig)
```","Both implementations correctly calculate the on-time delivery rate for April 2023 and visualize it as a pie chart, even though they use slightly different methods. The input code effectively filters the orders from April and counts how many were shipped on time, using DATE_FORMAT to specify the date, and calculates the percentage. The reference implementation uses SQL's FILTER clause for conditional aggregation, but the output and visualization logic are aligned.",both
What is the on-time delivery rate for each month in 2023? Represent findings using a line chart to observe trends over the months.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE NULL END) * 1.0 / COUNT(*) AS on_time_delivery_rate 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the dataframe by month to ensure correct order in the plot
df['month'] = pd.to_datetime(df['month'], format='%Y-%m')
df = df.sort_values(by='month')

# Create a line chart to represent on-time delivery rate over the months
fig = px.line(df, x='month', y='on_time_delivery_rate', title='On-Time Delivery Rate for Each Month in 2023', labels={'on_time_delivery_rate': 'On-Time Delivery Rate', 'month': 'Month'})

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM OrderDate) AS month,
    COUNT(OrderID) AS total_orders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS on_time_orders
FROM 
    orders
WHERE 
    OrderDate >= '2023-01-01' AND OrderDate < '2024-01-01'
GROUP BY 
    month
ORDER BY 
    month;
""""""

df = execute_sql_query(sql_query)

df['on_time_delivery_rate'] = df['on_time_orders'] / df['total_orders'] * 100

fig = px.line(df, x='month', y='on_time_delivery_rate', title='On-time Delivery Rate per Month in 2023', labels={'month': 'Month', 'on_time_delivery_rate': 'On-time Delivery Rate (%)'})
show_to_user(fig)
```","Both the reference and input Python codes calculate the on-time delivery rate per month for 2023 and plot it using a line chart. Although the input code uses `EXTRACT(MONTH FROM OrderDate)` instead of `DATE_FORMAT(OrderDate, '%Y-%m')`, the logic remains consistent as it breaks down orders by month within the year 2023 and computes the on-time delivery rate by dividing the count of on-time shipments by total orders. The plotting logic is also similar in both cases. Therefore, despite slight differences in SQL and variable naming, the input code adheres to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve on-time delivery rate per month
sql_query = """"""
SELECT MONTH(ShippedDate) AS month, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(*) * 100 AS on_time_delivery_rate 
FROM orders 
WHERE YEAR(ShippedDate) = 2023 
GROUP BY MONTH(ShippedDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the 'month' column is used as an integer for correct plotting
df['month'] = df['month'].astype(int)

# Sort the dataframe by month for accurate plotting
df = df.sort_values('month')

# Create a line chart using plotly
fig = px.line(df, x='month', y='on_time_delivery_rate', title='On-Time Delivery Rate for Each Month in 2023',
              labels={'month': 'Month', 'on_time_delivery_rate': 'On-Time Delivery Rate (%)'})

# Display the chart
show_to_user(fig)
```","The input code calculates the on-time delivery rate using the 'ShippedDate' instead of 'OrderDate', which may lead to different monthly groupings than intended. It could cause discrepancies in the grouping and rate calculations, as the reference code groups by 'OrderDate'.",Base
Visualize the total number of units on order for each product in 2022 using a bar chart to compare across products.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].UnitsOnOrder) AS units_on_order
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ProductID', y='units_on_order', title='Units on Order for Each Product in 2022', labels={'units_on_order':'Units on Order'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_units_on_order
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID, products.ProductName
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='ProductName', y='total_units_on_order', title='Total Units on Order for Each Product in 2022', labels={'total_units_on_order': 'Total Units On Order', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code calculates the total units on order using `SUM([Order Details].Quantity)` instead of `SUM([Order Details].UnitsOnOrder)`. It is also grouping by `products.ProductName`, which deviates from the reference implementation focusing on `products.ProductID`. Although it visualizes the data, the metrics and output labels differ from the reference specification.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, SUM(p.UnitsOnOrder) AS TotalUnitsOnOrder
FROM products p
WHERE p.ProductID IN (
    SELECT DISTINCT ProductID
    FROM products p2
    JOIN orders o ON p2.OrderID = o.OrderID
    WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
)
GROUP BY p.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductName', y='TotalUnitsOnOrder', title='Total Units on Order for Each Product in 2022')

# Display the chart to the user
show_to_user(fig)
```","The input code's SQL query is incorrect because it does not correctly join the necessary tables to get the 'UnitsOnOrder'. It uses a subquery to filter ProductID based on OrderID from the orders table, which is not related to the 'UnitsOnOrder'. Additionally, it uses 'p.UnitsOnOrder' directly from the products table without a join to the order details table, whereas the reference query joins the 'Order Details' and 'orders' tables to sum 'UnitsOnOrder' accurately. The logic to sum units based on OrderDate in 2022 is flawed in the input code.",None
What are the names and prices of products that have less than 20 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""

# Execute the query and retrieve the results in a dataframe
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)
```","```python
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
WHERE UnitsInStock < 20
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly performs the same SQL query as the reference implementation, selecting 'ProductName' and 'UnitPrice' from the 'products' table where 'UnitsInStock' is less than 20. The results are then displayed using 'show_to_user', matching the reference implementation's logic and structure.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""

# Execute the query to get the data in a DataFrame
df = execute_sql_query(sql_query)

# Display the resulting DataFrame
show_to_user(df)
```","The input code to evaluate uses the same SQL query and methods as the reference implementation to retrieve product names and prices for products with less than 20 units in stock. The variable names differ, but the logic and outcome are identical.",both
Calculate the total quantity of products sold per product category. Use a pie chart to display the proportion of sales across categories.,"```python
import plotly.express as px

# SQL query to calculate total quantity sold per product category
sql_query = '''
SELECT CategoryID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY CategoryID
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a pie chart
fig = px.pie(df, names='CategoryID', values='TotalQuantity', title='Total Quantity Sold per Product Category')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
""""""

data = execute_sql_query(sql_query)

fig = px.pie(data, names='CategoryID', values='TotalQuantity', title='Total Quantity of Products Sold per Category')
show_to_user(fig)
```","The input code correctly calculates the total quantity of products sold per category and creates a pie chart to display the result. Although the JOIN structure includes the 'orders' table, it ultimately achieves the same aggregation by 'CategoryID' as the reference code. The pie chart parameters are also correctly set. Method differences do not affect the correctness of the business logic.","```python
import plotly.express as px
import pandas as pd

# SQL query to calculate the total quantity of products sold per category
sql_query = """"""
SELECT categories.CategoryName, SUM([Order Details].Quantity) AS QuantitySold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName;
""""""

# Execute the query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a pie chart using plotly
fig = px.pie(df, values='QuantitySold', names='CategoryName', title='Proportion of Sales Across Categories')

# Display the pie chart to the user
show_to_user(fig)
```","The input code calculates the total quantity of products sold per product category and displays it using a pie chart. It fulfills the requirement to evaluate the proportion of sales across categories. The variation in the input code is the use of `CategoryName` instead of `CategoryID`, but this still aligns with the business request as long as it shows proportions per category. This matches the intended logic of computing and visualizing total sales as outlined in the reference implementation.",both
List all orders that were shipped to Germany.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT * FROM orders WHERE ShipCountry = 'Germany';""

# Execute the query and get the data
orders_to_germany_df = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(orders_to_germany_df)
```","```python
sql_query = """"""
SELECT orders.*
FROM orders
WHERE ShipCountry = 'Germany'
""""""
data = execute_sql_query(sql_query)
show_to_user(data)
```","The input code correctly executes a SQL query to select all columns from the 'orders' table where the 'ShipCountry' is 'Germany'. This matches the logic of the reference implementation. It also uses 'execute_sql_query' to retrieve the data and 'show_to_user' to display it, just like the reference code.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT * FROM orders WHERE ShipCountry = 'Germany';""

# Execute the SQL query to retrieve the data
germany_orders_df = execute_sql_query(sql_query)

# Display the orders shipped to Germany
show_to_user(germany_orders_df)
```","The input Python code correctly executes the SQL query to retrieve all orders shipped to Germany and displays the result, matching the logic of the reference implementation. The difference in variable name does not affect the correctness.",both
Who are the top 3 employees based on total sales generated? Use a bar chart to compare their performance.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 employees by total sales
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Top 3 Employees by Total Sales')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 3;
""""""

top_employees = execute_sql_query(sql_query)

fig = px.bar(top_employees, x='EmployeeName', y='TotalSales', 
              title='Top 3 Employees Based on Total Sales',
              labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee'},
              color='TotalSales')
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request by retrieving the top 3 employees based on total sales. It extends the reference code to include employee names, which enhances readability. The ordering and grouping logic to calculate TotalSales is consistent with the reference implementation. The visualization part, using Plotly Express to create a bar chart, correctly displays the TotalSales for the top 3 employees. Despite additional details like employee names and color coding, the core logic matches the reference implementation, fulfilling the request accurately.","```python
import plotly.express as px

# SQL query to get the top 3 employees based on total sales generated
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID
ORDER BY TotalSales DESC
LIMIT 3;
""""""

# Execute the SQL query and get the data into a DataFrame
df = execute_sql_query(sql_query)

# Combine FirstName and LastName for display
df['EmployeeName'] = df['FirstName'] + ' ' + df['LastName']

# Create a bar chart to compare the performance of the top 3 employees
fig = px.bar(df, x='EmployeeName', y='TotalSales', 
             title='Top 3 Employees by Total Sales',
             labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee Name'})

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly answers the business analytics request by identifying the top 3 employees based on total sales and visualizing their performance in a bar chart. It uses the same logic as the reference implementation, specifically the SQL calculation for TotalSales and selection of the top 3 employees. Additionally, it enhances the visualization by combining the first and last names of employees for improved readability. This does not alter the correctness of the solution.",both
What are the total sales for each product? Visualize with a bar chart for easy comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName;
""""""

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Visualize the results with a bar chart
fig = px.bar(df, x='ProductName', y='TotalSales', title='Total Sales per Product')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.bar(total_sales_df, x='ProductName', y='TotalSales', 
             title='Total Sales for Each Product', 
             labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input Python code correctly implements the business request. It calculates the total sales for each product using a SQL query that is logically equivalent to the reference code, ensuring it joins the 'Order Details' and 'products' tables on the ProductID and groups by ProductName. Additionally, it visualizes the total sales per product using a bar chart with Plotly, matching the intended functionality. Minor differences in SQL aliasing and chart labeling do not affect the correctness of the implementation.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the query to get data as a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Total Sales per Product')

# Show the visualization to the user
show_to_user(fig)
```","The input code is incorrect because it does not account for discounts in the calculation of total sales. The reference code includes the term '(1 - [Order Details].Discount)' in the aggregation, which is essential to accurately calculate the total sales. Without this, the input code sums the raw unit prices and quantities, leading to inaccurate results.",Base
List the orders that have not been shipped within the required date.,"```python
import pandas as pd

# Define the SQL query to get the orders that have not been shipped within the required date
sql_query = """"""
SELECT orders.OrderID, orders.RequiredDate, orders.ShippedDate
FROM orders
WHERE orders.ShippedDate IS NULL OR orders.ShippedDate > orders.RequiredDate;
""""""

# Execute the query and get the result in a pandas DataFrame
orders_df = execute_sql_query(sql_query)

# Use the show_to_user function to display the result
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE ShippedDate IS NULL AND RequiredDate < CURRENT_DATE;
""""""
unshipped_orders = execute_sql_query(sql_query)
show_to_user(unshipped_orders)
```","The input code only considers orders where ShippedDate is NULL and the RequiredDate is before CURRENT_DATE. It doesn't account for orders where ShippedDate is later than RequiredDate, while the reference code checks both these conditions. Therefore, it doesn't fully meet the logic of the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT OrderID FROM orders WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query and store the result in a dataframe
orders_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(orders_df)
```","The input code only considers orders with a ShippedDate later than the RequiredDate, while the reference code also includes orders where ShippedDate is NULL. Thus, it fails to meet the full criteria of identifying orders not shipped within the required date as specified in the request.",None
How many products have been discontinued?,"```python
import pandas as pd

# SQL query to count discontinued products
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE products.Discontinued = 1""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df.iloc[0])
```","```python
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE Discontinued = 1""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input Python code correctly uses an SQL query to count products with Discontinued set to 1, similar to the reference implementation. It retrieves and displays the count of discontinued products using the same logic, adhering to the business analytics request.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_df = execute_sql_query(sql_query)

# Since the query returns a count, we extract the count value
discontinued_count = discontinued_df.iloc[0]['discontinued_count']

# Display the result to the user
show_to_user(pd.DataFrame({'discontinued_products': [discontinued_count]}))
```","The input code correctly executes a SQL query to count the number of discontinued products, just like the reference code. It then displays the count using a DataFrame, which is slightly different in display but aligns logically with the reference implementation's intent. The result shown to the user represents the count as requested.",both
What are the total units ordered for each supplier? Show with a bar chart to highlight key suppliers.,"```python
import plotly.express as px

# SQL query as per the business request
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered for Each Supplier')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalUnitsOrdered DESC
""""""

supplier_units_df = execute_sql_query(sql_query)

fig = px.bar(supplier_units_df, x='SupplierID', y='TotalUnitsOrdered',
             title='Total Units Ordered for Each Supplier', labels={'TotalUnitsOrdered': 'Total Units Ordered', 'SupplierID': 'Supplier ID'})

show_to_user(fig)
```","The input code correctly executes the SQL query to retrieve total units ordered grouped by supplier, similarly to the reference code. It correctly joins the 'products' and '[Order Details]' tables using 'ProductID' and groups by 'SupplierID'. While the reference code performs an additional join with the 'suppliers' table, both codes effectively achieve the same outcome of summarizing total units ordered per supplier. The input code also sorts the results, which is an added feature but does not alter the correctness of fulfilling the business request. Both implementations use Plotly to create a bar chart to visualize the data.","```python
import plotly.express as px

# SQL Query to get the total units ordered for each supplier
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN ""Order Details"" od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID;
""""""

# Execute SQL query and get the data in a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart to highlight key suppliers
fig = px.bar(data, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered by Supplier')

# Show the plot to the user
show_to_user(fig)
```","The input Python code correctly implements the same logic as the reference code. Both codes execute an SQL query to select the total units ordered for each supplier by joining the suppliers, products, and order details tables. They then use Plotly to create a bar chart to visualize the data. Differences in the SQL syntax, such as the use of double quotes around table names in the input code versus square brackets in the reference, are just stylistic and do not affect functionality. The data visualization steps are equivalent in both examples.",both
Identify the orders that were placed but never shipped in 2022.,"```python
import pandas as pd

# SQL query to find orders placed but never shipped in 2022
sql_query = """"""
SELECT OrderID FROM orders WHERE ShippedDate IS NULL AND YEAR(OrderDate) = 2022
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE OrderDate >= '2022-01-01' 
  AND OrderDate <= '2022-12-31'
  AND ShippedDate IS NULL
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly identifies orders that were placed but never shipped in 2022. It uses a WHERE clause to filter orders by checking if the OrderDate falls in 2022 and if ShippedDate is NULL, matching the logic of the reference implementation. Both implement the same logic, even though the SQL queries use different conditions for the date filtering.","```python
import pandas as pd

# SQL Query to find orders placed but never shipped in 2022
sql_query = """"""
SELECT DISTINCT o.OrderID 
FROM orders o 
WHERE o.ShippedDate IS NULL 
AND o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute the SQL query to get the data
orders_never_shipped_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_never_shipped_df)
```","The input code correctly identifies the orders placed but never shipped in 2022. It uses the condition 'ShippedDate IS NULL' and checks that 'OrderDate' is within the year 2022 using a BETWEEN statement, which is logically equivalent to the YEAR function used in the reference implementation. Both approaches will yield the same result set.",both
What is the total revenue generated by each customer? Visualize using a bar chart to identify key customers.,"```python
import plotly.express as px

# SQL query to get total revenue by customer
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the query to get the data
revenue_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(revenue_df, x='CustomerID', y='TotalRevenue', title='Total Revenue by Customer')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    customers AS c
JOIN 
    orders AS o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
""""""

customer_revenue_df = execute_sql_query(sql_query)

fig = px.bar(customer_revenue_df, x='CompanyName', y='TotalRevenue', title='Total Revenue Generated by Each Customer')
show_to_user(fig)
```","The input code retrieves the total revenue for each customer similarly to the reference implementation, grouping by both CustomerID and CompanyName. It aggregates the revenue correctly using UnitPrice, Quantity, and Discount. The visualization uses CompanyName instead of CustomerID for the x-axis, which is a valid representation because CompanyName is often more descriptive. Both implementations use Plotly to create the bar chart and display it with `show_to_user(fig)`, fulfilling the business analytics request.","```python
import plotly.express as px

# SQL Query to get total revenue by each customer
sql_query = """"""
SELECT 
    customers.CustomerID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.CustomerID;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create bar chart to visualize total revenue by customer
fig = px.bar(df, x='CustomerID', y='TotalRevenue', title='Total Revenue by Customer', labels={'TotalRevenue': 'Total Revenue', 'CustomerID': 'Customer ID'})

# Show the bar chart
show_to_user(fig)
```","The input Python code fulfills the same business requirements and logical flow as the reference implementation. Both execute an SQL query to calculate total revenue by each customer by joining the necessary tables and aggregating the data by CustomerID. The visualization part uses Plotly to create a bar chart, and both snippets show this chart to the user. Despite slight differences in syntax and formatting, both scripts achieve the same outcome, rendering them essentially correct in addressing the business analytics request.",both
What is the total sales revenue generated in the month of January 2023?,"```python
import pandas as pd

# SQL query to get the total sales revenue for January 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the total sales only
total_sales = result_df['TotalSales'].iloc[0]
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate <= '2023-01-31'
""""""

total_sales_january = execute_sql_query(sql_query)
show_to_user(total_sales_january)
```","The input code correctly calculates the total sales revenue for January 2023 by summing the product of UnitPrice, Quantity, and the discount factor from the Order Details table for orders placed within the specified date range. The logic and calculations match the reference implementation, despite minor differences in SQL syntax. Both codes execute an SQL query to retrieve the total sales and display the same. Thus, the input code is correct.","```python
import pandas as pd

# Define the SQL query to fetch total sales revenue for January 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE MONTH(orders.OrderDate) = 1 AND YEAR(orders.OrderDate) = 2023;
""""""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Display the total sales revenue to the user
show_to_user(df['TotalSales'][0])
```","The input Python code correctly calculates the total sales revenue for January 2023. Both the reference and input code use a SQL query to sum up the sales revenue from the [Order Details] table, joined with the orders table, for January 2023. The input code uses the MONTH() and YEAR() functions to filter the date, which is a valid alternative to using the BETWEEN clause. The logic and outcome of both implementations are consistent, and therefore, the input code is correct.",both
What is the total quantity of each product sold? Use a bar chart to compare quantities sold per product.,"```python
import plotly.express as px

# SQL query to get the total quantity of each product sold
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure column names are correctly referenced
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity Sold per Product')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='ProductName', y='TotalQuantity', title='Total Quantity Sold per Product')
show_to_user(fig)
```","The input Python code correctly calculates the total quantity of each product sold by joining the 'products' and 'Order Details' tables. While it includes the product name in the 'GROUP BY' clause and uses 'ProductName' as the x-axis for the bar chart, it adheres to the same logic as the reference implementation. Both use a SQL query to sum the quantities sold grouped by product and visualize this with a bar chart. The inclusion of 'ProductName' does not alter the logic of the solution.","```python
import plotly.express as px

# SQL query to get total quantity of each product sold
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to compare quantities sold per product
fig = px.bar(df, x='ProductName', y='TotalQuantitySold', title='Total Quantity Sold per Product')

# Display the chart to the user
show_to_user(fig)
```","The input code correctly calculates the total quantity of each product sold and creates a bar chart. It uses `ProductName` instead of `ProductID` for grouping, which is valid as it still answers the business request with comparable logic. The resulting visualization showcases product sales as intended.",both
What are the top 5 customers by order value? Represent using a bar chart to see the top contributors.,"```python
import plotly.express as px

# SQL Query
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalOrderValue 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5;
'''

# Execute SQL Query
df = execute_sql_query(sql_query)

# Create Bar Chart
fig = px.bar(df, x='CustomerID', y='TotalOrderValue', title='Top 5 Customers by Order Value')

# Display to User
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderValue DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='OrderValue', title='Top 5 Customers by Order Value', labels={'OrderValue': 'Order Value', 'CompanyName': 'Customer Name'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request using the same logic as the reference implementation. It calculates the top 5 customers by order value by joining the necessary tables and calculating the total order value. The difference in the code is it includes 'CompanyName' alongside 'CustomerID', which is an acceptable addition for more descriptive output. Both create a bar chart to visualize the data and display it using similar means.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS order_value 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY order_value DESC 
LIMIT 5;
""""""

# Execute the SQL query and store the result in a DataFrame
top_customers_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(top_customers_df, x='CustomerID', y='order_value', title='Top 5 Customers by Order Value')

# Show the chart to the user
show_to_user(fig)
```","The input code correctly matches the logic and intent of the reference implementation. Both scripts execute a SQL query to retrieve the top 5 customers by order value, calculate order values accurately considering discount, join the necessary tables, group by CustomerID, order the results by descending order value, and limit the results to 5. They both use Plotly to create a bar chart and display it. The differences in minor naming conventions and formatting do not affect the logic or outcome.",both
How many products are in each category? Use a pie chart to show distribution across categories.,"```python
import plotly.express as px

# Execute the SQL query to get the data
sql_query = ""SELECT CategoryID, COUNT(ProductID) AS ProductCount FROM products GROUP BY CategoryID;""
df = execute_sql_query(sql_query)

# Create a pie chart to show distribution across categories
fig = px.pie(df, names='CategoryID', values='ProductCount', title='Product Distribution Across Categories')

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS ProductCount
FROM products
GROUP BY CategoryID
""""""

category_distribution = execute_sql_query(sql_query)

fig = px.pie(category_distribution, 
             names='CategoryID', 
             values='ProductCount', 
             title='Product Distribution Across Categories')

show_to_user(fig)
```","The input code executes a SQL query to count the number of products in each category, just like the reference code. Both codes calculate the same query and use Plotly Express to create a pie chart with 'CategoryID' as names and 'ProductCount' as values. The function 'show_to_user' is used to display the chart. Hence, the input code correctly follows the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get the product counts per category
sql_query = """"""
SELECT products.CategoryID, COUNT(products.ProductID) AS ProductCount 
FROM products 
GROUP BY products.CategoryID;
""""""

# Execute the query, and get the data as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a pie chart using plotly
fig = px.pie(df, names='CategoryID', values='ProductCount', title='Product Distribution Across Categories')

# Show the pie chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request according to the logic in the reference code. It successfully performs the necessary SQL query to group by 'CategoryID' and count 'ProductID', constructs a pie chart using Plotly with the correct labels and values, and shows the chart with a similar function. The code adheres to the correct business logic, even if there are slight variations in style.",both
Identify the employees who report to each manager.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    Manager.LastName AS ManagerLastName, 
    Manager.FirstName AS ManagerFirstName, 
    Subordinate.LastName AS EmployeeLastName, 
    Subordinate.FirstName AS EmployeeFirstName 
FROM employees AS Subordinate 
JOIN employees AS Manager 
ON Subordinate.ReportsTo = Manager.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","```python
sql_query = """"""
SELECT e1.FirstName AS EmployeeFirstName, e1.LastName AS EmployeeLastName, 
       e2.FirstName AS ManagerFirstName, e2.LastName AS ManagerLastName
FROM employees e1
LEFT JOIN employees e2 ON e1.ReportsTo = e2.EmployeeID
ORDER BY e2.LastName, e1.LastName;
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly identifies employees reporting to each manager. Both the input and reference implementations perform a self-join on the 'employees' table where 'Subordinate.ReportsTo' is equal to 'Manager.EmployeeID'. The difference lies in the order and the type of join; the input uses a LEFT JOIN with ordering, which still adheres to the intended logic of pairing employees with their respective managers, allowing it to correctly answer the business analytics request.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e2.EmployeeID, e2.ReportsTo FROM employees e2;
""""""

# Execute the SQL query to get the data
employee_data = execute_sql_query(sql_query)

# Filter to show only employees and their direct managers
employee_manager_mapping = employee_data[employee_data['ReportsTo'].notnull()]

# Display the result using the provided utility function
show_to_user(employee_manager_mapping)
```","The input code does not conform to the logic of the reference implementation. The reference code identifies employees who report to each manager by joining the employee table on itself using the 'ReportsTo' field. This enables obtaining both the manager's and employee's names. The input code, on the other hand, only retrieves EmployeeID and ReportsTo without performing a self-join to determine the manager's details and does not provide the necessary names.",Base
Which employee generated the most sales in the last year? Use a bar chart for clearer comparison.,"```python
import plotly.express as px

# SQL query to get total sales for each employee for the last year
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC LIMIT 1;
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to display the sales comparison
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Total Sales by Employee for the Last Year')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get sales data for the last year
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 10
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart for clearer comparison
fig = px.bar(sales_data, x='EmployeeName', y='TotalSales', 
             title='Top Employees by Sales in the Last Year', 
             labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee'})
             
# Show the plot to the user
show_to_user(fig)
```","The input code and reference code use different logic. The reference code only identifies the single top-performing employee based on sales, limiting the result to one. The input code retrieves the top 10 employees by sales and uses full names instead of IDs for the bar chart, representing a broader set of data. This does not directly answer the request of identifying the single highest-selling employee.","```python
import plotly.express as px

# SQL query to get total sales per employee in the last year
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE EXTRACT(YEAR FROM orders.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '1 YEAR') 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Total Sales by Employee in the Last Year', labels={'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Show the figure to user
show_to_user(fig)
```","The input Python code correctly answers the business analytics request: it calculates total sales per employee for the last year using a SQL query similar to the reference. The way the last year is determined is slightly different (using 'CURRENT_DATE - INTERVAL' instead of 'YEAR(CURDATE())'), but achieves the same purpose of filtering orders from the last year. The data is then visualized with a bar chart using Plotly, fulfilling the requirement for a clear comparison of sales by employee. Therefore, the input code adheres to the specified logic and request.",Finetuned
Which products need to be reordered soon?,"```python
import pandas as pd

# SQL Query to retrieve products that need to be reordered
sql_query = """"""
SELECT ProductName
FROM products
WHERE UnitsInStock <= ReorderLevel;
""""""

# Execute the SQL query
reorder_products_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(reorder_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0
""""""
products_to_reorder = execute_sql_query(sql_query)
show_to_user(products_to_reorder)
```","The evaluated Python code adds an additional condition 'Discontinued = 0', which filters out discontinued products. This condition is not present in the reference implementation. Therefore, the evaluated code deviates from the logic specified in the reference implementation and doesn't provide the same result set.","```python
import pandas as pd

# SQL query to get products that need to be reordered
sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock <= ReorderLevel;
""""""

# Execute the SQL query
products_low_stock_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_low_stock_df)
```","The input code correctly implements the logic of selecting products that need reordering by checking if 'UnitsInStock' is less than or equal to 'ReorderLevel'. Although it includes additional columns 'UnitsInStock' and 'ReorderLevel' in the result, this does not affect the correctness of the main logic, which aligns with the reference implementation's intended purpose.",Finetuned
How many orders did each employee handle in the first quarter of this year? Use a bar chart for easy comparison.,"```python
import plotly.express as px

# SQL query
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID;
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Orders Handled by Each Employee in Q1 2023', labels={'EmployeeID':'Employee ID', 'OrderCount':'Order Count'})

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC;
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='EmployeeName', y='OrderCount', title='Number of Orders Handled by Each Employee in Q1 2023', labels={'OrderCount': 'Number of Orders', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code computes the number of orders handled by each employee in the first quarter and visualizes this data using a bar chart, similar to the reference implementation. While it uses LEFT JOIN and includes employee names, these differences do not affect the correctness regarding the main query objective. The date range and logical structure align with the reference intention of filtering based on Q1 2023.","```python
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY EmployeeID;
""""""

# Execute the SQL query and get the data in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Orders Handled by Each Employee in Q1 2023')

# Display the chart to the user
show_to_user(fig)
```","The input code provides the same analysis as the reference code. Both retrieve the number of orders handled by each employee in the first quarter of 2023 and use a bar chart for visualization. Although the input code assumes a direct relationship between EmployeeID and orders without explicitly joining with an employees table, it still computes the correct result based on the orders table data provided. The core logic and output are aligned with the business request.",both
"What is the total sales for each product category this year, and can it be visualized using a bar chart?","```python
import plotly.express as px

# SQL Query provided
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY categories.CategoryName
""""""

# Execute SQL query to get the data
sales_data_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(sales_data_df, x='CategoryName', y='TotalSales', title='Total Sales for Each Product Category This Year')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales for each product category this year
sql_query = """"""
SELECT 
    p.CategoryID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    YEAR(o.OrderDate) = YEAR(CURDATE())
GROUP BY 
    p.CategoryID
""""""

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Visualize the total sales for each product category using a bar chart
fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Total Sales by Product Category This Year', labels={'CategoryID': 'Product Category', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The evaluated code groups by 'CategoryID' instead of 'CategoryName', which doesn't match the reference implementation's logic of displaying sales by category name. This would make the bar chart less informative unless 'CategoryID' is mapped to names later in the visualization, which is not shown.","```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT categories.CategoryID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= '2023-01-01' 
AND orders.OrderDate <= CURRENT_DATE 
GROUP BY categories.CategoryID
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='total_sales', title='Total Sales by Product Category for This Year')

# Show the visualization to the user
show_to_user(fig)
```","The input code returns sales by CategoryID, not CategoryName, differing from the reference. It also uses a fixed date range for the current year instead of extracting the year dynamically. Hence, it does not match the logic of the reference implementation.",None
Find the total freight cost for all orders shipped via each shipping method in 2022 and illustrate it with a pie chart.,"```python
import plotly.express as px

# Execute the SQL query to get the data
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2022 
GROUP BY ShipVia;
""""""
data = execute_sql_query(sql_query)

# Create a pie chart of the total freight cost by shipping method
fig = px.pie(data_frame=data, names='ShipVia', values='TotalFreight', title='Total Freight Cost by Shipping Method (2022)')

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
WHERE YEAR(OrderDate) = 2022
GROUP BY ShipVia
""""""

freight_data = execute_sql_query(sql_query)

fig = px.pie(freight_data, values='TotalFreight', names='ShipVia', title='Total Freight Cost by Shipping Method in 2022')
show_to_user(fig)
```","The input code correctly executes a SQL query to sum the freight costs grouped by shipping method for the year 2022. It then creates a pie chart using Plotly to visualize the total freight cost by shipping method with the same inputs and logic as the reference code. The methods and libraries used (pandas, plotly.express) align with the task requirements and ensure the outcome is consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the freight cost data
sql_query = """"""
SELECT orders.ShipVia, SUM(orders.Freight) AS TotalFreightCost 
FROM orders 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY orders.ShipVia
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a pie chart using plotly
fig = px.pie(df, names='ShipVia', values='TotalFreightCost', title='Total Freight Cost by Shipping Method in 2022')

# Display the pie chart
show_to_user(fig)
```","The input code correctly executes an SQL query to summarize the freight costs grouped by shipping method for the year 2022, using a date range that includes all of 2022. It then uses Plotly Express to create a pie chart with the same specifications as the reference implementation. The difference in the date filtering method (using BETWEEN in the input vs. YEAR function in the reference) does not affect functionality. Column naming in the SQL query result is slightly different but consistently used in the pie chart creation. Overall, it adheres to the same logic as the reference code.",both
What are the five cities with the highest total sales and present them in a ranked bar chart?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCity, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipCity 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not df.empty:
    # Create a ranked bar chart using plotly
    fig = px.bar(df, x='ShipCity', y='TotalSales', 
                 title=""Top 5 Cities by Total Sales"", 
                 labels={'ShipCity': 'City', 'TotalSales': 'Total Sales'})
    
    # Show the figure using the provided utility function
    show_to_user(fig)
else:
    show_to_user(""No data available to display."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.City, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.City
ORDER BY TotalSales DESC
LIMIT 5;
""""""

city_sales_df = execute_sql_query(sql_query)

fig = px.bar(city_sales_df, x='City', y='TotalSales', title='Top 5 Cities with Highest Total Sales', 
              labels={'TotalSales': 'Total Sales', 'City': 'City'})
show_to_user(fig)
```","The input implementation queries cities based on employee locations, while the reference implementation queries based on shipment cities. The business request is to find cities by 'highest total sales', which aligns with shipment destinations. Therefore, the input code deviates from the specified logic in the request.","```python
import plotly.express as px

# SQL query to find the top five cities with the highest total sales
sql_query = """"""
SELECT ShipCity, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipCity 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure columns are named correctly
df.columns = ['City', 'TotalSales']

# Create a ranked bar chart using Plotly
fig = px.bar(df, x='City', y='TotalSales', title='Top 5 Cities by Total Sales', labels={'TotalSales': 'Total Sales', 'City': 'City'})

# Display the result to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It uses an SQL query to retrieve the top five cities by total sales from the database and creates a ranked bar chart using Plotly, similar to the reference implementation. Furthermore, it assigns column names before creating the chart and displays the chart correctly, which adheres to the logic of the reference implementation.",Finetuned
Calculate the total number of units ordered for each product category and visualize it with a histogram.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT c.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
INNER JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryID;
""""""

# Execute SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart of total units ordered for each product category
fig = px.bar(df, x='CategoryID', y='TotalUnitsOrdered', title='Total Units Ordered per Product Category')

# Display the plotly figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
""""""

data = execute_sql_query(sql_query)

fig = px.histogram(data, x='CategoryID', y='TotalUnitsOrdered', title='Total Units Ordered by Product Category', 
                   labels={'CategoryID': 'Product Category', 'TotalUnitsOrdered': 'Total Units Ordered'})
show_to_user(fig)
```","The input code correctly calculates the total number of units ordered for each product category by summing the 'Quantity' from the 'Order Details' table and grouping by 'CategoryID'. It uses a JOIN to connect the 'Order Details' and 'products' tables, similar to the reference code. The only difference is the type of plot used: the input code utilizes a histogram instead of a bar chart. Both visualizations are appropriate for displaying the aggregated data per category, and this choice does not affect the correctness regarding the business analytics request.","```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT c.CategoryID, c.CategoryName, SUM(od.Quantity) AS TotalQuantityOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID, c.CategoryName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the total number of units ordered for each product category
fig = px.bar(df, x='CategoryName', y='TotalQuantityOrdered', title='Total Units Ordered by Product Category')

# Show the visualization to the user
show_to_user(fig)
```","The input code and the reference code both perform the same business analytics task, which is calculating the total number of units ordered for each product category and visualizing it with a bar chart. The input code includes the CategoryName in the SQL query and visualization, which does not change the correctness of the required analysis. The visualization uses 'CategoryName' as the x-axis, whereas the reference code uses 'CategoryID', but this is just an additional label enhancement and does not impact the logic of the solution. Therefore, the input code is correct.",both
"What is the monthly trend of order placements for the current year, and how can a line chart be used to represent it?","```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT MONTH(OrderDate) AS Month, COUNT(*) AS NumberOfOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY MONTH(OrderDate);
""""""

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Sort the DataFrame by Month to ensure the line chart is ordered correctly
orders_df = orders_df.sort_values(by='Month')

# Create line chart using plotly
fig = px.line(orders_df, x='Month', y='NumberOfOrders', title='Monthly Trend of Order Placements')

# Display plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_year = datetime.now().year

sql_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = {current_year} 
GROUP BY 
    Month 
ORDER BY 
    Month;
""""""

monthly_trend_df = execute_sql_query(sql_query)

fig = px.line(monthly_trend_df, x='Month', y='OrderCount', title='Monthly Trend of Order Placements for {current_year}',
              labels={'Month': 'Month', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","Both implementations perform the same core operations: querying the database for order counts per month for the current year, and generating a line chart using Plotly Express to visualize this data. While the input code uses a slightly different SQL query format and includes ORDER BY for ordering the months directly in the query, it achieves the same result as the reference codeâ€™s DataFrame sorting step. The chart titles and labels are appropriately set to display the monthly trend of order placements.","```python
import plotly.express as px

# Define the SQL query for order placements per month for the current year
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m')
ORDER BY 
    DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query and get the result as a pandas DataFrame
order_trend_df = execute_sql_query(sql_query)

# Create a line chart using plotly
fig = px.line(order_trend_df, x='Month', y='OrderCount', 
              title='Monthly Trend of Order Placements',
              labels={'OrderCount': 'Order Count', 'Month': 'Month'})

# Display the plotly figure
show_to_user(fig)
```","Both implementations address the business analytics request by querying the number of orders placed monthly for the current year from the 'orders' table. The input code uses DATE_FORMAT to group by '%Y-%m', ensuring year-month format, which aligns with counting orders per month. The SQL logic in both approaches correctly groups and counts the monthly orders. Each implementation uses Plotly to plot the data, sorting the output as needed for accurate representation. Thus, the logic aligns with the reference implementation, making the input code correct.",both
How long has each employee been working at the company?,"```python
import pandas as pd

# SQL query to get the employee duration
sql_query = ""SELECT employees.EmployeeID, DATEDIFF(CURDATE(), employees.HireDate) AS DaysWorked FROM employees;""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
import pandas as pd
from datetime import datetime

sql_query = """"""
SELECT 
    EmployeeID, 
    LastName, 
    FirstName, 
    HireDate, 
    DATEDIFF(CURRENT_DATE(), HireDate) AS DaysAtCompany
FROM 
    employees
""""""

employee_data = execute_sql_query(sql_query)

employee_data['YearsAtCompany'] = employee_data['DaysAtCompany'] // 365
employee_data['MonthsAtCompany'] = (employee_data['DaysAtCompany'] % 365) // 30

show_to_user(employee_data[['EmployeeID', 'FirstName', 'LastName', 'YearsAtCompany', 'MonthsAtCompany']])
```","The input code correctly calculates how long each employee has been working at the company by using the DATEDIFF function to get the number of days worked. It then further breaks down this number into years and months, which is an additional but valid step not present in the reference code. Both implementations use the same logic to determine the duration of employment, meeting the business request.","```python
import pandas as pd

# Define the SQL query to retrieve EmployeeID and HireDate
sql_query = """"""
SELECT EmployeeID, HireDate FROM employees;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check data types and convert if necessary
if 'HireDate' not in df.columns or pd.api.types.is_object_dtype(df['HireDate']):
    df['HireDate'] = pd.to_datetime(df['HireDate'])

# Calculate the tenure in days for each employee
df['Tenure'] = (pd.to_datetime('today') - df['HireDate']).dt.days

# Select only EmployeeID and Tenure columns for display
result_df = df[['EmployeeID', 'Tenure']]

# Display the result to the user
show_to_user(result_df)
```","The input code correctly computes the tenure in days for each employee by calculating the difference between the current date and the HireDate, which aligns with the logic of the reference implementation. It retrieves EmployeeID and HireDate, converts HireDate to datetime, calculates the tenure, and displays the result, same as the reference code's purpose, although it follows a slightly different approach.",both
Which products need reordering?,"```python
import pandas as pd

# SQL query to identify products that need reordering
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query and retrieve the data
products_to_reorder_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND (UnitsInStock + UnitsOnOrder) <= ReorderLevel
""""""

products_needing_reorder = execute_sql_query(sql_query)
show_to_user(products_needing_reorder)
```","The input code includes additional conditions not present in the reference implementation. It considers products with 'Discontinued = 0' and uses '(UnitsInStock + UnitsOnOrder) <= ReorderLevel' as the condition, while the reference only checks 'UnitsInStock <= ReorderLevel'. These differences change the logic and scope of the query.","```python
import pandas as pd

# SQL query to retrieve parts needing reordering
sql_query = ""SELECT ProductID, ListingDate, ReorderLevel, UnitsInStock FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_to_reorder_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_to_reorder_df)
```","The input code queries for products where UnitsInStock is less than ReorderLevel, which conceptually seems correct. However, it retrieves additional columns (ProductID, ListingDate, ReorderLevel) instead of just ProductName as in the reference. The condition 'UnitsInStock < ReorderLevel' is slightly different from 'UnitsInStock <= ReorderLevel' in the reference, leading to potential differences in product selection.",None
How many products have a reorder level higher than 20?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT * FROM products WHERE ReorderLevel > 20;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Count the number of rows (products) with ReorderLevel > 20
high_reorder_products_count = result_df.shape[0]

# Create a DataFrame to hold the count
count_df = pd.DataFrame({'HighReorderProducts': [high_reorder_products_count]})

# Display the result using the provided utility function
show_to_user(count_df)
```","```python
sql_query = ""SELECT COUNT(*) AS ProductCount FROM products WHERE ReorderLevel > 20""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly creates an SQL query to count the number of products with a reorder level greater than 20. This is equivalent to counting the number of rows in the reference implementation where the reorder level is greater than 20. Both approaches achieve the same result, which is calculating the number of products that meet the condition. The input code simply uses an SQL aggregate function to do this directly in the database query, hence both are logically equivalent.","```python
import pandas as pd

# SQL query to find products with reorder level higher than 20
sql_query = ""SELECT ProductID FROM products WHERE ReorderLevel > 20;""

# Execute the query using the provided utility function
products = execute_sql_query(sql_query)

# Calculate the number of products
product_count = len(products)

# Display the result to the user
show_to_user(pd.DataFrame({'Number of Products': [product_count]}))
```","Both implementations correctly count the number of products with a reorder level higher than 20. The reference code uses 'SELECT *', while the input code uses 'SELECT ProductID'; however, both achieve the same result by counting the rows that meet the condition. The method of displaying the result differs but does not affect correctness.",both
Find the customers who have not placed any orders in the current year.,"```python
import pandas as pd

# Define the SQL queries
query_customers = ""SELECT CustomerID FROM customers;""
query_orders_current_year = ""SELECT DISTINCT CustomerID FROM orders WHERE OrderDate >= DATE_FORMAT(NOW(), '%Y-01-01');""

# Execute the SQL queries
customers_df = execute_sql_query(query_customers)
orders_df = execute_sql_query(query_orders_current_year)

# Find customers who have not placed any orders in the current year
inactive_customers_df = customers_df[~customers_df['CustomerID'].isin(orders_df['CustomerID'])]

# Show result to the user
show_to_user(inactive_customers_df)
```","```python
import pandas as pd

current_year = pd.Timestamp.now().year

sql_query = f""""""
SELECT CustomerID 
FROM orders 
WHERE OrderDate < '{current_year}-01-01' 
GROUP BY CustomerID
""""""

orders_df = execute_sql_query(sql_query)

customers_without_orders = orders_df

show_to_user(customers_without_orders)
```","The input code finds customers who placed orders before the current year, not those who have placed no orders in the current year. It uses an incorrect date comparison, failing to exclude those with current year orders.","```python
import pandas as pd

# SQL query to find customers who have not placed any orders in the current year
sql_query = """"""
SELECT * FROM customers 
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID FROM orders 
    WHERE YEAR(OrderDate) = YEAR(CURDATE())
);
""""""

# Execute the SQL query
customers_without_orders = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(customers_without_orders)
```","The input code correctly implements the business requirement using a single SQL query to find customers who have not placed any orders in the current year. It checks for customers whose CustomerID is not in the list of CustomerIDs with orders this year, aligning with the reference logic.",Finetuned
Identify the top 5 customers who have incurred the highest total freight costs and display in a ranked list.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CustomerID, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY CustomerID 
ORDER BY TotalFreight DESC 
LIMIT 5;
""""""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Ensure the result is sorted and ranked properly
df = df.sort_values(by='TotalFreight', ascending=False).reset_index(drop=True)

# Display the ranked list of top 5 customers by total freight costs
show_to_user(df)
```","```python
sql_query = """"""
SELECT CustomerID, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY CustomerID
ORDER BY TotalFreight DESC
LIMIT 5;
""""""

top_customers = execute_sql_query(sql_query)
show_to_user(top_customers)
```","The input code correctly implements the logic specified in the business analytics request. It executes an SQL query to retrieve the top 5 customers with the highest total freight costs, sorted in descending order. The reference code and the input code both perform the necessary grouping, sorting, and limiting of results. Additionally, since the SQL query inherently returns results in a sorted order, the additional sorting step in the reference code is redundant and does not affect the correctness of the input code.","```python
import pandas as pd

# SQL query to retrieve top 5 customers with highest total freight costs
sql_query = """"""
SELECT CustomerID, SUM(Freight) AS TotalFreight FROM orders 
GROUP BY CustomerID 
ORDER BY TotalFreight DESC 
LIMIT 5;
""""""

# Execute the SQL query
df_top_customers = execute_sql_query(sql_query)

# Display the ranked list to the user
show_to_user(df_top_customers)
```","The provided code has the same logic as the reference code. It correctly executes a SQL query to select the top 5 customers based on the sum of their freight costs, sorts them in descending order, and limits the result to 5 records. Both implementations display the result using the provided 'show_to_user' function.",both
"How many units of each product were sold in the first quarter of 2023, and can this be shown in a grouped bar chart?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
    SELECT products.ProductID, SUM([Order Details].Quantity) AS units_sold 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
    GROUP BY products.ProductID
""""""

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Create a grouped bar chart using plotly
fig = px.bar(df, x='ProductID', y='units_sold', title='Units Sold Per Product in Q1 2023', barmode='group')

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS units_sold
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='units_sold', title='Units Sold per Product in Q1 2023', labels={'units_sold': 'Units Sold', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request. It calculates the units sold for each product in the first quarter of 2023 and generates a grouped bar chart to display these results. Additionally, it includes 'ProductName' in the SELECT clause for more informative labeling in the chart. While it slightly differs from the reference code by including 'ProductName', it adheres to the same logic and fulfills the request requirements.","```python
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS units_sold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductName;
""""""

# Execute the SQL query and retrieve data
df = execute_sql_query(sql_query)

# Create a grouped bar chart
fig = px.bar(df, x='ProductName', y='units_sold', title='Units Sold by Product in Q1 2023')

# Display the bar chart to the user
show_to_user(fig)
```","The input code fulfills the business analytics request correctly. It calculates the number of units sold for each product during the first quarter of 2023 using the same logic as the reference implementation. The only difference is that it groups by 'ProductName' instead of 'ProductID', but this change does not affect the correctness as both can identify products uniquely. The grouped bar chart is created using Plotly, displaying the product name on the x-axis and units sold on the y-axis. Therefore, it addresses the business request accurately.",both
"How many orders were shipped via each shipping method in 2023, and illustrate it with a bar chart?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
    SELECT ShipVia, COUNT(OrderID) AS OrderCount
    FROM orders
    WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
    GROUP BY ShipVia
""""""

# Execute the SQL query and retrieve data as a pandas dataframe
order_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(order_data, x='ShipVia', y='OrderCount', title='Orders Shipped Via Each Method in 2023')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY ShipVia
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ShipVia', y='OrderCount', title='Number of Orders Shipped via Each Shipping Method in 2023', 
             labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```",The input Python code is functionally correct based on the business request and adheres to the logic of the reference implementation. Both codes execute an SQL query to count orders by shipping method for 2023 and use Plotly to generate a bar chart. The difference in the where clause (using YEAR(OrderDate) vs BETWEEN) does not affect correctness as both achieve the same data filtering for 2023. The plot customization with labels in the input code is an enhancement but does not change the core functionality.,"To analyze the number of orders shipped via each shipping method in 2023 and visualize the results in a bar chart, we can follow these steps:

1. **Retrieve the data using SQL query.**
2. **Convert the retrieved data into a DataFrame.**
3. **Use the plotting functionality to create a bar chart.**
4. **Display the bar chart to the user.**

Here is the complete Python code to achieve this:

```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT o.ShipVia, COUNT(o.OrderID) AS number_of_orders 
FROM orders o 
WHERE YEAR(o.ShippedDate) = 2023 
GROUP BY o.ShipVia;
""""""

# Execute the SQL query to get data
orders_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_data, x='ShipVia', y='number_of_orders', title='Orders Shipped via Each Shipping Method in 2023')

# Display the bar chart to the user
show_to_user(fig)
```

### Explanation:
- **SQL Query**: The query selects the shipping method (`ShipVia`) and counts the number of orders (`OrderID`) for the year 2023.
- **Plotting**: We use Plotly's `px.bar` for visualizing the data.
- **Showing the Result**: The figure is displayed using `show_to_user`.

Ensure you have the necessary libraries and context to execute these functions correctly!",The input code uses `YEAR(o.ShippedDate) = 2023` whereas the reference code uses `OrderDate BETWEEN '2023-01-01' AND '2023-12-31'`. The correct column should be `OrderDate` not `ShippedDate` to match the reference logic. Assuming `OrderDate` is the correct field based on the reference implementation.,Base
How many orders were placed each month in the current year and visualize with a line chart?,"```python
import plotly.express as px

# SQL query to get the number of orders placed each month in the current year
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY OrderMonth 
ORDER BY OrderMonth;
""""""

# Execute the query and retrieve the data as a pandas dataframe
orders_data = execute_sql_query(sql_query)

# Create a line chart using plotly
fig = px.line(orders_data, x='OrderMonth', y='TotalOrders', title='Monthly Orders in Current Year', labels={'OrderMonth': 'Month', 'TotalOrders': 'Number of Orders'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_year = datetime.now().year

sql_query = f""""""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(*) AS TotalOrders
FROM orders
WHERE YEAR(OrderDate) = {current_year}
GROUP BY Month
ORDER BY Month;
""""""

orders_per_month = execute_sql_query(sql_query)

fig = px.line(orders_per_month, x='Month', y='TotalOrders', title='Total Orders Per Month in {current_year}')
show_to_user(fig)
```","The input Python code correctly retrieves the number of orders placed each month for the current year using a similar SQL query as the reference implementation. It then visualizes the data with a line chart using Plotly. The logic of grouping by month and counting orders is consistent with the reference implementation, and the key actions are performed correctly. Minor differences in variable names and string formatting do not affect the overall functionality.","```python
import plotly.express as px

# SQL query to get the number of orders per month for the current year
sql_query = """"""
SELECT MONTH(OrderDate) AS OrderMonth, COUNT(OrderID) AS OrdersCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY MONTH(OrderDate);
""""""

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Ensure months are in order
orders_data = orders_data.sort_values(by='OrderMonth')

# Create a line chart using Plotly
fig = px.line(orders_data, x='OrderMonth', y='OrdersCount', title='Monthly Orders in Current Year')

# Display the line chart to the user
show_to_user(fig)
```","The input code correctly calculates the number of orders per month for the current year using a SQL query, groups them by month, and visualizes the results with a line chart. While there is a minor difference in how the months are labeled ('MONTH(OrderDate)' vs. 'DATE_FORMAT(OrderDate, '%Y-%m')'), both approaches fulfill the same business analytics request of showing monthly order counts for the current year. The input code is logically consistent with the reference implementation.",both
Which product had the highest average discount and illustrate it with a bar chart?,"```python
import plotly.express as px

# SQL query to get the product with the highest average discount
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AvgDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY AvgDiscount DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not df.empty:
    # Create a bar chart to illustrate the product with the highest average discount
    fig = px.bar(df, x=""ProductID"", y=""AvgDiscount"", title=""Product with the Highest Average Discount"")

    # Show the result to the user
    show_to_user(fig)
else:
    print(""No data returned from the query."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    AVG(od.Discount) AS AverageDiscount
FROM 
    [Order Details] od
GROUP BY 
    od.ProductID
ORDER BY 
    AverageDiscount DESC
LIMIT 1;
""""""

highest_discount_product = execute_sql_query(sql_query)

product_id = highest_discount_product.iloc[0]['ProductID']

sql_query_details = f""""""
SELECT 
    od.ProductID, 
    AVG(od.Discount) AS AverageDiscount
FROM 
    [Order Details] od
WHERE 
    od.ProductID = {product_id}
GROUP BY 
    od.ProductID;
""""""

product_discount_data = execute_sql_query(sql_query_details)

fig = px.bar(product_discount_data, x='ProductID', y='AverageDiscount', title='Product with Highest Average Discount')
show_to_user(fig)
```","Both code implementations execute a SQL query to determine the product with the highest average discount. They use similar SQL logic, including selecting and averaging the discount, grouping by product ID, and ordering by the average discount in descending order with a limit of 1 to fetch the highest. The input code attempts to retrieve additional details using the 'product_id' and reconstructs the bar chart, adhering to the logic used in the reference implementation. Therefore, the input code is a correct implementation of the requested analytics task.","```python
import plotly.express as px

# SQL Query to get product with highest average discount
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AverageDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY AverageDiscount DESC;
""""""

# Execute SQL Query to get data
df = execute_sql_query(sql_query)

# Get the top product by average discount
top_product_df = df.head(1)

# Visualize the result with a bar chart
fig = px.bar(top_product_df, x='ProductID', y='AverageDiscount', 
             title='Product with Highest Average Discount',
             labels={'ProductID': 'Product ID', 'AverageDiscount': 'Average Discount'})

# Show the chart to the user
show_to_user(fig)
```","The input code successfully retrieves the product with the highest average discount using SQL and creates a bar chart to illustrate this. It uses a similar logic to the reference implementation by ordering the products by average discount in descending order, then selecting the top one. Both codes achieve the same result, although they differ slightly in implementation details, such as using `.head(1)` to select the top product instead of using `LIMIT 1` in SQL.",both
"What percentage of total stock does each product contribute, and can this be visualized in a pie chart?","```python
import plotly.express as px

# SQL query to retrieve the required data
sql_query = """"""
SELECT p.ProductID, 
ROUND(p.UnitsInStock / (SELECT SUM(UnitsInStock) FROM products) * 100, 2) AS StockPercentage 
FROM products p;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Ensure that 'ProductID' and 'StockPercentage' are treated as strings and numeric
df['ProductID'] = df['ProductID'].astype(str)
df['StockPercentage'] = df['StockPercentage'].astype(float)

# Generate a pie chart using Plotly
fig = px.pie(df, names='ProductID', values='StockPercentage', title='Percentage Contribution of Total Stock by Product')

# Display the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, SUM(UnitsInStock) AS TotalStock
FROM products
GROUP BY ProductName
""""""

product_stock_df = execute_sql_query(sql_query)

total_stock = product_stock_df['TotalStock'].sum()
product_stock_df['PercentageContribution'] = (product_stock_df['TotalStock'] / total_stock) * 100

fig = px.pie(product_stock_df, names='ProductName', values='PercentageContribution',
             title='Percentage Contribution of Each Product to Total Stock')
show_to_user(fig)
```","The input code correctly calculates the percentage contribution of each product's stock to the total stock. Both implementations compute the total stock and then calculate the percentage for each product. The input code groups by 'ProductName' instead of 'ProductID', but since it's a valid way to identify products in the dataset, it answers the business request effectively. It then visualizes this using a pie chart, similar to the reference implementation.","```python
import plotly.express as px

# SQL query to get the product stock details
sql_query = ""SELECT ProductName, UnitsInStock FROM products;""

# Execute SQL query and get the data
df = execute_sql_query(sql_query)

# Calculate the percentage contribution to total stock for each product
df['StockContribution'] = (df['UnitsInStock'] / df['UnitsInStock'].sum()) * 100

# Create a pie chart to visualize the contribution of each product to total stock
fig = px.pie(df, values='StockContribution', names='ProductName', title='Percentage Contribution to Total Stock')

# Show the visualization
show_to_user(fig)
```","The input code correctly calculates the percentage contribution of each product to the total stock and visualizes it as a pie chart. The main difference from the reference code is that it uses 'ProductName' rather than 'ProductID', but this does not affect the correctness concerning the business analytics request. Both codes ensure the sum of 'UnitsInStock' is used for the percentage calculation and generate a pie chart using Plotly.",both
Which employee processed the highest number of orders last month?,"```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate last month's year and month
today = datetime.today()
first_day_of_current_month = today.replace(day=1)
last_month_end = first_day_of_current_month - timedelta(days=1)
last_month_year = last_month_end.year
last_month = last_month_end.month

# Define SQL query
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE YEAR(o.OrderDate) = {last_month_year} 
AND MONTH(o.OrderDate) = {last_month} 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and fetch the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate the start and end date for last month
today = datetime.today()
first_day_of_current_month = today.replace(day=1)
last_month_start = (first_day_of_current_month - timedelta(days=1)).replace(day=1)
last_month_end = first_day_of_current_month - timedelta(days=1)

# SQL query to get the employee who processed the highest number of orders last month
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) as OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= '{last_month_start.strftime('%Y-%m-%d')}' 
AND o.OrderDate <= '{last_month_end.strftime('%Y-%m-%d')}'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","Both implementations aim to identify the employee who processed the highest number of orders last month. The reference code calculates the last month based on year and month and constructs a SQL query to count orders for each employee. The input code generates the start and end dates for last month and uses them in the SQL query. Both effectively achieve the same goal by filtering orders from the last month, counting them by employee, and ordering the results to find the top employee. Although the implementations differ slightly (e.g., date handling and additional employee details in the input), they logically align and answer the business analytics request correctly.","```python
import pandas as pd

# Read data from the database
orders_df = execute_sql_query(""SELECT EmployeeID FROM orders WHERE OrderDate BETWEEN '2023-09-01' AND '2023-09-30';"")

# Count the number of orders processed by each employee
order_counts = orders_df['EmployeeID'].value_counts()

# Determine the employee with the highest number of orders
top_employee = order_counts.idxmax()

# Create a DataFrame for display
result_df = pd.DataFrame({'Top Employee': [top_employee], 'Order Count': [order_counts.max()]})

# Show the result to the user
show_to_user(result_df)
```","The input code assumes a fixed date range ('2023-09-01' to '2023-09-30'), which won't dynamically adapt to calculate last month's data based on the current date, unlike the reference code that uses datetime to determine the previous month correctly. This can lead to incorrect results when the code runs in different months.",Base
"Determine the month with the highest total sales, and visualize the monthly sales trend with a line chart.","```python
import plotly.express as px

# SQL query to get monthly sales data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as order_month, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as total_sales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY order_month 
ORDER BY total_sales DESC;
""""""

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Determine the month with the highest total sales
highest_sales_row = monthly_sales_df.iloc[0]

# Visualize the monthly sales trend with a line chart
monthly_sales_df_sorted = monthly_sales_df.sort_values(by='order_month')
fig = px.line(monthly_sales_df_sorted, x='order_month', y='total_sales', title='Monthly Sales Trend')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales
FROM 
    `orders`
JOIN 
    `[Order Details]` ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    TotalSales DESC
LIMIT 1
""""""

highest_sales_month = execute_sql_query(sql_query)

sql_query_trend = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales
FROM 
    `orders`
JOIN 
    `[Order Details]` ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

monthly_sales = execute_sql_query(sql_query_trend)

fig = px.line(monthly_sales, x='Month', y='TotalSales', title='Monthly Sales Trend')
show_to_user(fig)

highest_sales_month
```","The input code correctly determines the month with the highest total sales using the first SQL query with a LIMIT 1 clause and orders by TotalSales in descending order. It then uses a second SQL query to get the full monthly sales trend ordered by Month for visualization. This approach matches the logic of the reference implementation, achieving both tasks: identifying the highest sales month and visualizing the sales trend.","```python
import plotly.express as px

# SQL Query to get monthly sales data
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Month
""""""

# Execute the query and get the data
monthly_sales_df = execute_sql_query(sql_query)

# Determine the month with the highest total sales
highest_sales_month = monthly_sales_df.loc[monthly_sales_df['TotalSales'].idxmax()]

# Display the month with the highest sales
show_to_user(highest_sales_month)

# Visualize the monthly sales trend
fig = px.line(monthly_sales_df, x='Month', y='TotalSales', title='Monthly Sales Trend')
show_to_user(fig)
```","The input code correctly executes a SQL query to compute monthly sales totals and identifies the month with the highest sales using `idxmax()`, which is functionally equivalent to using `iloc[0]` after a descending sort. The line chart for monthly sales trend is also properly created with `plotly.express` similar to the reference implementation. Therefore, the input code achieves the business analytics request correctly.",both
Identify the top 5 suppliers based on the total sales revenue and show this in a ranked bar chart.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT p.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID, s.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the query
top_suppliers_df = execute_sql_query(sql_query)

# Create a ranked bar chart
fig = px.bar(top_suppliers_df, x='CompanyName', y='TotalRevenue', 
             title='Top 5 Suppliers by Total Sales Revenue', 
             text='TotalRevenue', 
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier Name'})

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalRevenue DESC
LIMIT 5
""""""

top_suppliers = execute_sql_query(sql_query)
fig = px.bar(top_suppliers, x='CompanyName', y='TotalRevenue', title='Top 5 Suppliers by Total Sales Revenue', labels={'TotalRevenue': 'Total Sales Revenue', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The provided code aligns with the reference implementation in terms of logic and functionality. Both codes execute a SQL query to calculate the total sales revenue for suppliers and select the top 5 based on this revenue. The query correctly calculates revenue using the formula `SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))` and groups by `SupplierID` and `CompanyName`. The results are then used to create a bar chart with Plotly Express, visualizing the top 5 suppliers by total revenue. The main difference is the order of joins and the presence of an additional join with the 'orders' table in the input code, which does not affect the accuracy of the revenue calculation according to the provided schema. Thus, the input code fulfills the business analytics request correctly.","```python
import plotly.express as px

# SQL query to get the top 5 suppliers based on sales revenue
sql_query = """"""
SELECT SupplierID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY SupplierID 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a ranked bar chart using plotly express
fig = px.bar(df, 
             x='SupplierID', 
             y='TotalRevenue', 
             title='Top 5 Suppliers by Total Sales Revenue',
             labels={'SupplierID': 'Supplier ID', 'TotalRevenue': 'Total Revenue'},
             text='TotalRevenue')

# Update layout to show total revenue on bars
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')

# Show the result to the user
show_to_user(fig)
```","The input code does not select the supplier's CompanyName in the SQL query, which makes it unclear in visualization. The reference code includes supplier names, which aligns better with the business analytics request to rank suppliers by name rather than ID. This causes a mismatch with the required output as per the request.",Base
Which customer generated the highest lifetime value?,"```python
import pandas as pd

# SQL query to find the customer with the highest lifetime value
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS CustomerLifetimeValue
FROM customers
INNER JOIN orders ON customers.CustomerID = orders.CustomerID
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY customers.CustomerID
ORDER BY CustomerLifetimeValue DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    LifetimeValue DESC
LIMIT 1;
""""""

lifetime_value_df = execute_sql_query(sql_query)
show_to_user(lifetime_value_df)
```","Both the input and reference implementations aim to find the customer with the highest lifetime value, calculated by summing the product of UnitPrice, Quantity, and (1 - Discount) for each customer's orders. They join the same tables and compute the sum correctly. The input code includes the CompanyName in the SELECT and GROUP BY clauses, which does not affect the correctness of finding the CustomerID with the highest lifetime value. Therefore, the logical outcomes are equivalent.","```python
import pandas as pd

# SQL query to find the customer with the highest lifetime value
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) 
       AS customer_lifetime_value 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY customer_lifetime_value DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input Python code and the reference implementation both execute a SQL query to calculate the customer with the highest lifetime value. The SQL logic in both snippets is identical, calculating the sum of the product of 'UnitPrice', 'Quantity', and the discount factor per customer. Both queries group by CustomerID and order the results by the calculated lifetime value in descending order, limiting the result to the top customer. Thus, both implementations produce the same analytical result.",both
How many employees live in each country and illustrate it with a map or bar chart?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT Country, COUNT(EmployeeID) AS EmployeeCount 
FROM employees 
GROUP BY Country;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Country', y='EmployeeCount', title='Number of Employees by Country')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Country, COUNT(EmployeeID) AS NumEmployees
FROM employees
GROUP BY Country
""""""

employee_counts = execute_sql_query(sql_query)

fig = px.bar(employee_counts, x='Country', y='NumEmployees', title='Number of Employees per Country')
show_to_user(fig)
```","The input code correctly executes a similar SQL query, aggregating employee counts by country using the column alias 'NumEmployees' instead of 'EmployeeCount'. It uses Plotly to create a bar chart, aligning with the logic and intent of the reference implementation.","```python
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT Country, COUNT(EmployeeID) AS EmployeeCount 
FROM employees 
GROUP BY Country;
""""""

# Executing the SQL query
df = execute_sql_query(sql_query)

# Creating a bar chart to illustrate the number of employees living in each country
fig = px.bar(df, x='Country', y='EmployeeCount', title='Number of Employees Living in Each Country')

# Displaying the visualization to the user
show_to_user(fig)
```","The input code correctly executes a SQL query to count the number of employees by country and creates a bar chart using Plotly, aligning with the reference implementation. Both codes execute the same query and visualize the data similarly, meeting the business request.",both
Visualize the total sales revenue for the month of January 2023 to identify trends or patterns using time-series or bar charts.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales, 
       DAY(OrderDate) as SaleDay
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE MONTH(OrderDate) = 1 AND YEAR(OrderDate) = 2023
GROUP BY DAY(OrderDate)
ORDER BY SaleDay;
""""""

# Execute the query
sales_data = execute_sql_query(sql_query)

# Visualize the data with a time-series line chart
fig = px.line(sales_data, x='SaleDay', y='TotalSales', title='Total Sales Revenue - January 2023', labels={'SaleDay': 'Day of January', 'TotalSales': 'Total Sales Revenue'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    DATE_FORMAT(orders.OrderDate, '%Y-%m-%d') AS OrderDate,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM
    orders
JOIN
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE
    orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
GROUP BY
    DATE_FORMAT(orders.OrderDate, '%Y-%m-%d')
ORDER BY
    OrderDate
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='OrderDate', y='TotalSales', title='Total Sales Revenue - January 2023', labels={'TotalSales': 'Total Sales Revenue', 'OrderDate': 'Order Date'})
show_to_user(fig)
```","The input code differs in logic from the reference code in several ways. The input code aggregates sales data by the 'OrderDate', while the reference code aggregates by 'DAY(OrderDate)'. This results in a different level of granularity, where the input code produces daily sales by date, and the reference code produces sales split by day of the month. Additionally, the input code uses a bar chart instead of a line chart for visualization, which may not align with the purpose of identifying time-series trends. Furthermore, different SQL date functions are used, which could affect compatibility depending on the SQL database being used.","```python
import plotly.express as px

# SQL query to analyze total revenue by each day in January 2023
sql_query = """"""
SELECT 
    DATE(OrderDate) AS Date, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS DailyRevenue 
FROM 
    [Order Details] od 
JOIN 
    orders o ON od.OrderID = o.OrderID 
WHERE 
    STRFTIME('%Y-%m', OrderDate) = '2023-01' 
GROUP BY 
    DATE(OrderDate);
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Ensure the 'Date' column is treated as datetime for plotting
data['Date'] = pd.to_datetime(data['Date'])

# Create a bar chart to visualize daily revenue in January 2023
fig = px.bar(data, x='Date', y='DailyRevenue', title='Total Sales Revenue for January 2023')

# Show the plot to the user
show_to_user(fig)
```","The input Python code successfully evaluates the total sales revenue for January 2023, similar to the reference code. It correctly uses a SQL query to calculate daily revenue and employs a bar chart for visualization, which is a valid alternative to the time-series line chart used in the reference. The logic of the data retrieval and visualization adheres to the business analytics request.",Finetuned
Find and visualize the top 5 cities with the highest average shipping cost to compare differences using a bar chart or map.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageFreight 
FROM orders 
GROUP BY ShipCity 
ORDER BY AverageFreight DESC 
LIMIT 5;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ShipCity', y='AverageFreight', title='Top 5 Cities with Highest Average Shipping Cost', labels={'AverageFreight':'Average Freight'})

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AverageShippingCost DESC
LIMIT 5;
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='ShipCity', y='AverageShippingCost', 
             title='Top 5 Cities with Highest Average Shipping Cost',
             labels={'AverageShippingCost': 'Average Shipping Cost', 'ShipCity': 'City'})
show_to_user(fig)
```",The input Python code is correct. It follows the same logic as the reference implementation: it selects the top 5 cities based on the highest average shipping cost by executing a similar SQL query. The data is then visualized using a bar chart comparing average shipping costs across these cities. The differences in variable names for the average shipping cost and labels are cosmetic and do not affect the correctness of the code.,"```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY ShipCity 
ORDER BY AvgShippingCost DESC 
LIMIT 5;
""""""

# Execute the SQL query
df_top_cities = execute_sql_query(sql_query)

# Visualize the top 5 cities with the highest average shipping cost
fig = px.bar(df_top_cities, x='ShipCity', y='AvgShippingCost', title='Top 5 Cities with Highest Average Shipping Cost')
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It performs a SQL query to calculate the average shipping cost grouped by city, orders them in descending order to get the top 5 cities, and uses Plotly to create a bar chart for visualization. The slight difference in the alias 'AvgShippingCost' does not affect the logic or outcome of the request. The code meets the business analytics requirements and provides the desired output.",both
Which products need to be reordered (units in stock less than reorder level)?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_to_reorder_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0;
""""""

products_to_reorder = execute_sql_query(sql_query)
show_to_user(products_to_reorder)
```","The input code adds an additional condition for checking if the product is not discontinued (`Discontinued = 0`). This condition is not present in the reference implementation. Therefore, the input code will potentially return fewer products than the reference code, making it incorrect according to the specified logic.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query to get the data
products_to_reorder = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_to_reorder)
```","The input code only selects 'ProductName' while the reference code selects both 'ProductID' and 'ProductName'. The business request asks for identifying products based on stock levels, and a unique identifier like 'ProductID' is important for distinguishing between products.",None
Visualize the top 5 products by sales revenue using a bar chart for comparative analysis.,"```python
import plotly.express as px

# SQL query to retrieve top 5 products by sales revenue
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query using provided utility function
sales_data = execute_sql_query(sql_query)

# Ensure ProductID is treated as a categorical variable for plotting
sales_data['ProductID'] = sales_data['ProductID'].astype(str)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue')

# Display the bar chart using provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalSales DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)
fig = px.bar(top_products, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue', labels={'TotalSales': 'Sales Revenue', 'ProductID': 'Product ID'})
show_to_user(fig)
```","The input code correctly answers the business analytics request by visualizing the top 5 products by sales revenue. It uses a SQL query to select the necessary fields, properly groups and orders the data as per revenue, and limits the result to 5 products. The data is then plotted using Plotly to create a bar chart. Although there's an unnecessary table join with 'orders', it doesn't impact the final result. The logic is consistent with the reference implementation.","```python
import plotly.express as px

# SQL query to get top 5 products by sales revenue
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity) as TotalRevenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute SQL query and get data
data = execute_sql_query(sql_query)

# Create a bar chart with the top 5 products by sales revenue
fig = px.bar(data, x='ProductName', y='TotalRevenue', title='Top 5 Products by Sales Revenue')

# Display the figure to the user
show_to_user(fig)
```","The input code differs from the reference by using 'ProductName' instead of 'ProductID', affecting the aggregation logic since multiple products may share the same name. It also misses accounting for the 'Discount' in the revenue calculation, which affects the accuracy of the 'TotalRevenue' compared to 'TotalSales' in the reference.",Base
Analyze and visualize the correlation between employee hire date and performance using scatter plots or correlation matrices.,"```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT employees.EmployeeID, employees.HireDate, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, employees.HireDate 
ORDER BY employees.HireDate;
""""""

# Execute SQL query to retrieve data
df = execute_sql_query(sql_query)

# Ensure HireDate is in datetime format
df['HireDate'] = pd.to_datetime(df['HireDate'])

# Calculate performance metric (e.g., using TotalSales as a proxy for performance)
# Assuming we want to standardize it
df['Performance'] = (df['TotalSales'] - df['TotalSales'].mean()) / df['TotalSales'].std()

# Visualize the correlation between HireDate and Performance
fig = px.scatter(df, x='HireDate', y='Performance', 
                 title='Correlation between Hire Date and Performance',
                 labels={'HireDate': 'Hire Date', 'Performance': 'Performance'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get employee hire date and total sales
sql_query = """"""
SELECT e.HireDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.HireDate
""""""

# Execute the SQL query and retrieve the data
data = execute_sql_query(sql_query)

# Create a scatter plot to visualize correlation
fig = px.scatter(data, x='HireDate', y='TotalSales', title='Correlation between Hire Date and Total Sales',
                 labels={'HireDate': 'Hire Date', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code does not accurately match the reference implementation's logic. The input code calculates and visualizes the correlation between HireDate and TotalSales, while the reference code calculates a standardized performance metric from TotalSales data. The reference code uses this performance metric for the correlation analysis, rather than TotalSales directly. Therefore, the input does not fulfill the analysis requirements as stated in the reference implementation.","To analyze the correlation between employee hire date and performance, we will use a scatter plot. The employee's performance is quantified by their rating, and we can associate hire date with performance to identify trends. Here's how we can achieve that using Python:

```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT employees.HireDate, employees.Rating 
FROM employees 
WHERE employees.Active = 1;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Ensure that 'HireDate' is treated as a datetime format
data['HireDate'] = pd.to_datetime(data['HireDate'])

# Create a scatter plot to analyze correlation between HireDate and Rating
fig = px.scatter(data, x='HireDate', y='Rating', title='Correlation between Hire Date and Performance Ratings',
                 labels={'HireDate': 'Hire Date', 'Rating': 'Performance Rating'})

# Show the plot
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: The query selects the necessary columns (`HireDate` and `Rating`) for employees who are currently active.
2. **Data Retrieval**: `execute_sql_query()` retrieves the data from the database and stores it in a pandas DataFrame.
3. **Data Conversion**: We convert the `HireDate` column to a datetime format for accurate plotting.
4. **Scatter Plot**: We use Plotly's `px.scatter` to visualize the correlation between `HireDate` and `Rating`.
5. **Display**: Finally, `show_to_user()` presents the scatter plot to the user.

This scatter plot allows us to visually inspect any trends or relationships between the hire date and performance ratings.","The input code does not adhere to the logic of the reference implementation. The reference code uses 'TotalSales' from order details to assess performance, while the input uses a direct 'Rating' from employees. This difference affects the correlation analysis, as they are not measuring the same performance metric. Additionally, the reference includes correlation from all employees, while the input only includes active ones, further diverging from the same logic.",None
How many new customers were acquired in May 2023?,"```python
import pandas as pd

# SQL query to count distinct new customers acquired in May 2023
sql_query = """"""
SELECT COUNT(DISTINCT customers.CustomerID) AS new_customers 
FROM customers 
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
AND customers.CustomerID NOT IN (
    SELECT CustomerID 
    FROM orders 
    WHERE OrderDate < '2023-05-01')
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS new_customers
FROM orders
WHERE OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""
new_customers_df = execute_sql_query(sql_query)
show_to_user(new_customers_df)
```","The input code only counts the distinct CustomerIDs from the 'orders' table with orders in May 2023, without ensuring these customers did not have orders before May 2023. The reference code correctly identifies new customers by ensuring they didn't place orders prior to May 2023.","```python
import pandas as pd

# SQL query to get the count of new customers acquired in May 2023
sql_query = """"""
SELECT COUNT(*) AS NewCustomers 
FROM customers 
WHERE DATE_FORMAT(CreateDate, '%Y-%m') = '2023-05';
""""""

# Execute the SQL query
new_customers_df = execute_sql_query(sql_query)

# Extract the count of new customers
new_customers_count = new_customers_df.iloc[0]['NewCustomers']

# Display the result to the user
show_to_user(pd.DataFrame({'NewCustomers': [new_customers_count]}))
```","The input code evaluates new customers based on their creation date in May 2023 using a field 'CreateDate'. The reference code checks for customers with orders in May 2023 who did not have any orders before May 2023. The logic is different, as the input assumes customers are new based on account creation, not order activity.",None
Which suppliers provide products that are currently in stock?,"```python
import pandas as pd

# SQL Query to get suppliers with products currently in stock
sql_query = ""SELECT DISTINCT SupplierID FROM products WHERE UnitsInStock > 0""

# Execute the SQL query
supplier_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(supplier_df)
```","```python
sql_query = """"""
SELECT DISTINCT p.SupplierID, p.ProductName
FROM products p
WHERE p.UnitsInStock > 0 AND p.Discontinued = 0
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code filters products that are not only in stock but also not discontinued by including `p.Discontinued = 0`. This is a different condition than the reference implementation, which only checks for products with UnitsInStock > 0 without considering the Discontinued status.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DISTINCT suppliers.SupplierID, suppliers.SupplierName
FROM products
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
WHERE products.UnitsInStock > 0;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Ensure the dataframe columns are renamed correctly if needed
data.columns = ['SupplierID', 'SupplierName']

# Display the result to the user
show_to_user(data)
```","The input Python code correctly identifies suppliers providing products that are currently in stock. It joins the `products` and `suppliers` tables to return both `SupplierID` and `SupplierName`, which is an enhancement but adheres to the same logic of retrieving suppliers with in-stock products as the reference implementation. Both codes effectively filter by `UnitsInStock > 0` and correctly execute the SQL query.",Finetuned
Visualize the number of employees in each country to identify distribution using a map or bar chart.,"```python
import plotly.express as px

# Execute the SQL query and fetch data
sql_query = ""SELECT Country, COUNT(*) AS NumEmployees FROM employees GROUP BY Country;""
employees_df = execute_sql_query(sql_query)

# Create a map visualization using Plotly
fig_bar = px.bar(employees_df, x='Country', y='NumEmployees', title='Number of Employees per Country')

# Show the bar chart to the user
show_to_user(fig_bar)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Country, COUNT(EmployeeID) AS NumberOfEmployees FROM employees GROUP BY Country""
employee_data = execute_sql_query(sql_query)

fig = px.bar(employee_data, x='Country', y='NumberOfEmployees', title='Number of Employees by Country')
show_to_user(fig)
```","The input Python code correctly implements the requested task. Both the reference and input codes execute a similar SQL query to fetch the number of employees per country. They both use Plotly to create a bar chart based on the SQL query results, with only minor differences: use of 'EmployeeID' instead of '*' for the count. This difference in column selection does not affect the result if EmployeeID is the primary key (unique for each employee), leading to the same result. Consequently, the input code is logically equivalent to the reference.","```python
import plotly.express as px

# SQL query to get the number of employees in each country
sql_query = """"""
SELECT e.Country, COUNT(e.EmployeeID) AS NumberOfEmployees 
FROM employees e 
GROUP BY e.Country
""""""

# Execute SQL query and retrieve data as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='Country', y='NumberOfEmployees', title='Number of Employees per Country')

# Show the chart to the user
show_to_user(fig)
```","Both implementations execute a SQL query to group the number of employees by country and then use Plotly to create a bar chart visualizing this data. The reference code uses COUNT(*) while the input code specifies COUNT(e.EmployeeID), but they achieve the same result as both will count the rows grouped by country. The visualization and display logic is identical, adhering to the business requirement to visualize employee distribution.",both
Visualize the average fulfillment time for orders by month to identify seasonal trends using a line chart.,"```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
    SELECT EXTRACT(MONTH FROM OrderDate) AS Month, 
    AVG(DATEDIFF(DAY, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
    FROM orders 
    GROUP BY EXTRACT(MONTH FROM OrderDate)
""""""

# Execute the SQL query to get a dataframe
data = execute_sql_query(sql_query)

# Convert the Month column to integer in case it's not already
data['Month'] = data['Month'].astype(int)

# Sort the dataframe by Month to ensure correct order in the visualization
data = data.sort_values('Month')

# Create a line chart
fig = px.line(data, x='Month', y='AvgFulfillmentTime', 
              title='Average Fulfillment Time by Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'Month': 'Month'})

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

data = execute_sql_query(sql_query)
fig = px.line(data, x='Month', y='AverageFulfillmentTime', title='Average Fulfillment Time by Month')
show_to_user(fig)
```","The input code groups the orders by `Month` based on the format '%Y-%m', which includes both year and month. The reference code groups by month only, disregarding the year. This discrepancy could show data trends differently, as the input might not correctly reflect seasonal trends across years. Additionally, the Month in input is a string format '%Y-%m', whereas it should be an integer 1-12, which could affect the line chart's order.","```python
import plotly.express as px

# SQL query to retrieve the data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time
FROM orders
GROUP BY month;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Ensure 'month' is treated as a string for correct plotting
data['month'] = data['month'].astype(str)

# Create a line chart using plotly
fig = px.line(data, x='month', y='avg_fulfillment_time', title='Average Fulfillment Time by Month')

# Show the visualization to the user
show_to_user(fig)
```","The input code calculates the average fulfillment time by year and month ('%Y-%m'), while the reference calculates it by month only. This difference in grouping logic means they don't adhere to the same logic. Therefore, the input code does not strictly fulfill the business request as specified.",None
How many days on average does it take to fulfill an order?,"```python
import pandas as pd

# Execute SQL query and retrieve data
df = execute_sql_query(""SELECT OrderDate, ShippedDate FROM orders"")

# Calculate average fulfillment time
df['FulfillmentTime'] = (pd.to_datetime(df['ShippedDate']) - pd.to_datetime(df['OrderDate'])).dt.days
avg_fulfillment_time = df['FulfillmentTime'].mean()

# Create a DataFrame to display the result
result_df = pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]})

# Display result to user
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL AND OrderDate IS NOT NULL;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, y='AverageFulfillmentTime', title='Average Order Fulfillment Time')
show_to_user(fig)
```","The input code accurately calculates the average fulfillment time as requested. It uses an SQL query to compute the average difference in days between 'ShippedDate' and 'OrderDate', ensuring both dates are not null. This logic is consistent with the reference implementation, which also calculates the average in days. The main difference is that the input code uses SQL for calculation and plotting for the display, while the reference uses Pandas for computation and displays a DataFrame.","```python
import pandas as pd

# Define the SQL query to calculate average days to fulfill an order
sql_query = """"""
SELECT AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS Avg_Fulfillment_Days
FROM orders o;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Fix the column name if necessary
result_df.columns = ['Avg_Fulfillment_Days']

# Display the result to the user
show_to_user(result_df['Avg_Fulfillment_Days'].iloc[0])
```","Both implementations achieve the same objective of calculating the average number of days it takes to fulfill an order. The reference implementation does this by calculating the difference directly in Python after importing data, and then computing the average. The input code, on the other hand, performs the average calculation directly in the SQL query using the DATEDIFF function, which achieves the same result. Although the methods differ, the logic and outcome are consistent.",both
What is the average discount applied per product?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute SQL query and retrieve data as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the average discount result to the user
average_discount = df['AverageDiscount'].iloc[0]
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))
```","```python
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY ProductID
""""""
average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code calculates the average discount per ProductID by grouping the data, resulting in multiple values. The reference code calculates a single average discount across all products. Therefore, the input does not adhere to the logic of the reference implementation.","```python
import pandas as pd

# SQL query to get average discount per product
sql_query = """"""
SELECT products.ProductName, AVG([Order Details].Discount) AS AverageDiscount 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input code calculates the average discount per product, which groups discounts by product and averages them for each product. The reference code calculates a single average discount across all order details. The logic and question addressed by both codes are different.",None
Which suppliers have supplied the most products?,"```python
import pandas as pd

# SQL query to get suppliers and the count of products they supplied
sql_query = """"""
SELECT s.SupplierID, COUNT(p.ProductID) AS TotalProductsSupplied 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID 
ORDER BY TotalProductsSupplied DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    p.SupplierID, 
    COUNT(p.ProductID) AS ProductCount
FROM 
    products p
GROUP BY 
    p.SupplierID
ORDER BY 
    ProductCount DESC
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code is missing the join with the suppliers table, which is necessary to get accurate supplier information. It only queries the products table, which may still return counts by SupplierID, but lacks the full logic of joining both tables to ensure it matches the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, COUNT(products.ProductID) AS ProductCount 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.SupplierID, suppliers.CompanyName 
ORDER BY ProductCount DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the results
show_to_user(df)
```","The input Python code correctly implements the logic required by the business analytics request. It counts the number of products supplied by each supplier by joining the 'suppliers' and 'products' tables on 'SupplierID'. It groups the results by 'SupplierID' and 'CompanyName' and orders the count in descending order, similar to the reference code. The inclusion of 'CompanyName' provides additional information but does not alter the result of identifying suppliers supplying the most products.",Finetuned
Visualize which regions have the highest on-time delivery rates using a bar chart or heat map.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipRegion, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID)) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipRegion', y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rates by Region',
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'ShipRegion': 'Region'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion,
       COUNT(OrderID) AS TotalOrders,
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries,
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(OrderID)) * 100 AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipRegion
ORDER BY OnTimeDeliveryRate DESC;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ShipRegion', y='OnTimeDeliveryRate',
             title='On-time Delivery Rates by Region',
             labels={'OnTimeDeliveryRate': 'On-time Delivery Rate (%)'},
             color='OnTimeDeliveryRate',
             color_continuous_scale=px.colors.sequential.Viridis)

show_to_user(fig)
```","Both the reference and input code queries the database to calculate the on-time delivery rate by region. Despite minor differences, both implementations compute the on-time delivery rate using the ratio of on-time deliveries to total orders, multiplied by 100. Both codes then visualize this data using a Plotly bar chart. The input code adds color shading to the bar chart based on the on-time delivery rate, which is an enhancement but does not deviate from the logic required by the business analytics request.","```python
import plotly.express as px

# SQL query to get data
sql_query = """"""
SELECT ShipRegion, 
       CAST(SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS FLOAT) / COUNT(OrderID) AS on_time_delivery_rate 
FROM orders 
GROUP BY ShipRegion;
""""""

# Execute the SQL query to get data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize on-time delivery rates by region
fig = px.bar(df, x='ShipRegion', y='on_time_delivery_rate', 
             title='On-Time Delivery Rates by Region', 
             labels={'on_time_delivery_rate': 'On-Time Delivery Rate', 'ShipRegion': 'Region'},
             template='plotly')

# Display the chart
show_to_user(fig)
```","The input code computes the on-time delivery rate using a similar logic as the reference code. The input code uses a `CAST` and division to calculate the rate, while the reference uses a multiplier to achieve the percentage. Both codes use Plotly to create a bar chart with the same fields for x and y axes and display it. Therefore, the input code is consistent with the business request and the reference implementation logic.",both
How many orders were handled by employees who were hired in the year 2020?,"```python
sql_query = """"""
    SELECT COUNT(orders.OrderID) AS TotalOrders
    FROM employees
    JOIN orders ON employees.EmployeeID = orders.EmployeeID
    WHERE YEAR(HireDate) = 2020;
""""""

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(o.OrderID) AS OrderCount
FROM employees e
INNER JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE YEAR(e.HireDate) = 2020
""""""
order_count_df = execute_sql_query(sql_query)
show_to_user(order_count_df)
```","The evaluated code is correct as it accurately follows the logic of the reference implementation. Both codes execute an SQL query that counts the number of orders handled by employees hired in 2020 by joining the 'employees' and 'orders' tables on 'EmployeeID' and filtering by the year of 'HireDate'. The only differences are in the aliasing of tables ('e' and 'o') and the name of the count column ('OrderCount' vs. 'TotalOrders'), which do not affect the correctness or logic of the query.","```python
# Define the SQL query
sql_query = """"""
SELECT COUNT(*) AS order_count 
FROM orders 
INNER JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE employees.HireDate BETWEEN '2020-01-01' AND '2020-12-31';
""""""

# Execute the SQL query
orders_in_2020_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_in_2020_df)
```",The input code correctly calculates the number of orders handled by employees hired in 2020. It uses an INNER JOIN between the 'orders' and 'employees' tables and filters employees hired within the specified date range for 2020. This logic matches the reference implementation's use of the YEAR function to filter HireDate by the year 2020.,both
Visualize the average discount applied to products per month using a line chart to identify trends.,"```python
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       AVG(Discount) AS AverageDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Convert 'month' column to string if needed (ensure consistent data type)
data['month'] = data['month'].astype(str)

# Create a line chart using plotly
fig = px.line(data, x='month', y='AverageDiscount', title='Average Discount per Month')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    AVG(od.Discount) AS Average_Discount
FROM
    orders o
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY
    Month
ORDER BY
    Month
""""""

average_discount_df = execute_sql_query(sql_query)
fig = px.line(average_discount_df, x='Month', y='Average_Discount', title='Average Discount Applied to Products per Month')
show_to_user(fig)
```","The input code aligns with the stated request and the reference implementation. It executes an SQL query to fetch average discounts per month, processes the data with similar logic by grouping and averaging, utilizes Plotly to create a line chart, and orders the results by month. The slight differences in variable names and column labels do not affect the correctness of solving the tasked request.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(od.Discount) AS AverageDiscount 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
GROUP BY Month;
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Ensure the Month column is treated as a string for correct plotting
df['Month'] = df['Month'].astype(str)

# Create a line chart using Plotly
fig = px.line(df, x='Month', y='AverageDiscount', 
              title='Average Discount Applied to Products Per Month', 
              labels={'Month': 'Month', 'AverageDiscount': 'Average Discount'})

# Display the visualized line chart
show_to_user(fig)
```","The input code correctly fulfills the business analytics request and adheres to the same logic as the reference implementation. Both codes execute an SQL query that calculates the monthly average discount. They ensure the 'month' field is a string for plotting and use Plotly Express to create a line chart visualizing average discounts per month. There are slight differences in SQL syntax (e.g., table alias), titles, and label customizations, but the logical flow and output are consistent with the request.",both
What is the average time between order date and required date?,"```python
import pandas as pd

# SQL query to calculate average time between order date and required date
sql_query = """"""
SELECT OrderDate, RequiredDate FROM orders;
""""""

# Execute the SQL query and get the result in a dataframe
df = execute_sql_query(sql_query)

# Calculate the average time between order date and required date
df['OrderDate'] = pd.to_datetime(df['OrderDate'])
df['RequiredDate'] = pd.to_datetime(df['RequiredDate'])
df['LeadTime'] = (df['RequiredDate'] - df['OrderDate']).dt.days
average_lead_time = df['LeadTime'].mean()

# Display the result to the user
show_to_user(pd.DataFrame({'AverageLeadTime': [average_lead_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(RequiredDate, OrderDate)) AS AverageDeliveryTime
FROM orders
""""""
average_delivery_time_df = execute_sql_query(sql_query)
show_to_user(average_delivery_time_df)
```","The input code correctly calculates the average time between the order date and the required date using a SQL query that computes the difference directly in the database with DATEDIFF. This matches the logic of the reference implementation where the difference is computed after fetching the data. The result is then displayed using the show_to_user function, which adheres to the business request.","```python
import pandas as pd

# SQL query to retrieve necessary data
sql_query = ""SELECT OrderDate, RequiredDate FROM orders WHERE RequiredDate IS NOT NULL;""

# Execute the SQL query and store results in a dataframe
df = execute_sql_query(sql_query)

# Calculate average time difference in days
df['OrderDate'] = pd.to_datetime(df['OrderDate'])
df['RequiredDate'] = pd.to_datetime(df['RequiredDate'])
df['TimeToDelivery'] = (df['RequiredDate'] - df['OrderDate']).dt.days

# Calculate the average time to delivery
avg_time_to_delivery = df['TimeToDelivery'].mean()

# Prepare the result as a DataFrame
result_df = pd.DataFrame({'Average Time to Delivery': [avg_time_to_delivery]})

# Display the result to the user
show_to_user(result_df)
```","The provided code correctly calculates the average time between 'OrderDate' and 'RequiredDate'. The conversion to datetime and calculation of the difference in days is consistent with the reference implementation. Additionally, it properly handles any null 'RequiredDate' values in SQL, ensuring only valid records are processed. Finally, the result is displayed correctly, aligning with the business request.",both
How many products have a stock level below their reorder level?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(ProductName) as NumProductsBelowReorder FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the query and get the result as a Pandas DataFrame
products_below_reorder = execute_sql_query(sql_query)

# Prepare the result to show to user
result_df = pd.DataFrame({'Number of Products Below Reorder Level': products_below_reorder['NumProductsBelowReorder']})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS Products_Below_Reorder_Level
FROM products
WHERE UnitsInStock < ReorderLevel;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The evaluated code correctly constructs a SQL query to count the number of products where the stock level is below the reorder level, similar to the reference code. It uses COUNT(*) and aliases the result as 'Products_Below_Reorder_Level'. The result is then passed to the same function 'show_to_user'. Both implementations achieve the same goal using equivalent logic.","```python
import pandas as pd

# SQL query to find products with stock level below reorder level
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_below_reorder = execute_sql_query(sql_query)

# Count the number of products
count_below_reorder = len(products_below_reorder)

# Display the result to the user
show_to_user(pd.DataFrame({'Count of Products Below Reorder Level': [count_below_reorder]}))
```","Both implementations fulfill the same business requirement: determining how many products have a stock level below the reorder level. The reference code uses a SQL query to directly get the count from the database, while the input code retrieves the product names first and then counts them in Python. The final count result displayed to the user is correct in both cases.",both
Which orders were delayed more than five days past the required date?,"```python
import pandas as pd

# Retrieve all orders
all_orders_df = execute_sql_query(""SELECT OrderID, ShippedDate, RequiredDate FROM orders"")

# Calculate the delay in days
all_orders_df['DelayDays'] = (all_orders_df['ShippedDate'] - all_orders_df['RequiredDate']).dt.days

# Filter orders delayed more than 5 days
delayed_orders_df = all_orders_df[all_orders_df['DelayDays'] > 5][['OrderID']]

# Display the result to the user
show_to_user(delayed_orders_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE DATEDIFF(ShippedDate, RequiredDate) > 5;
""""""

delayed_orders = execute_sql_query(sql_query)
show_to_user(delayed_orders)
```","The input code directly filters orders in the SQL query using DATEDIFF to find delays, which should correctly return orders delayed more than 5 days. However, the code is correct only if the database supports the DATEDIFF function and assumes that missing `ShippedDate` values do not need special handling. The reference code calculates delays after retrieving data, ensuring flexibility in case of SQL constraints or specific date-handling requirements.","```python
import pandas as pd

# SQL query to fetch delayed orders
sql_query = """"""
SELECT OrderID, OrderDate, ShippedDate, RequiredDate 
FROM orders 
WHERE DATEDIFF(ShippedDate, RequiredDate) > 5;
""""""

# Execute the SQL query to get the data
delayed_orders_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(delayed_orders_df)
```","The input code uses an SQL query to directly filter the orders by checking if the difference between ShippedDate and RequiredDate is greater than 5 days. This approach effectively achieves the same goal as the reference implementation, which calculates delay in days within the DataFrame. Both methods result in identifying orders delayed more than five days past the RequiredDate.",Finetuned
What is the average time taken to fulfill an order?,"```python
import pandas as pd

# SQL query to get the average fulfillment time
sql_query = """"""
SELECT AVG(DATE_PART('day', ShippedDate::timestamp - OrderDate::timestamp)) AS AverageFulfillmentTime FROM orders;
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Extract the average fulfillment time from the dataframe
average_fulfillment_time = df.loc[0, 'AverageFulfillmentTime']

# Display the result to the user
show_to_user(pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time_df)
```","The input Python code correctly calculates the average fulfillment time by using the DATEDIFF function in the SQL query which measures the difference between 'ShippedDate' and 'OrderDate'. Similarly, the reference implementation uses DATE_PART function to achieve the same goal. Both implementations extract and display the 'AverageFulfillmentTime' from the result. The logic and result are equivalent, so the input code is correct.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT TIMESTAMPDIFF(DAY, OrderDate, ShippedDate) AS FulfillmentTime FROM orders;""

# Execute the SQL query to get the dataframe
orders_df = execute_sql_query(sql_query)

# Calculate the average fulfillment time
avg_fulfillment_time = orders_df['FulfillmentTime'].mean()

# Prepare the result dataframe for display
result_df = pd.DataFrame({'AverageFulfillmentTime': [avg_fulfillment_time]})

# Show the result
show_to_user(result_df)
```","The input code calculates the average fulfillment time by querying the database for the difference between OrderDate and ShippedDate in days using `TIMESTAMPDIFF`. It then computes the mean of these values and displays the result. This approach is equivalent to the reference implementation, which also calculates the average days between OrderDate and ShippedDate. Both methods achieve the same business analytics request using the correct logic.",both
Calculate and visualize the total value of current inventory (UnitPrice * UnitsInStock) for all products using a pie chart or bar chart for better understanding.,"```python
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT UnitPrice, UnitsInStock FROM products;""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Calculate the total inventory value
total_inventory_value = (df['UnitPrice'] * df['UnitsInStock']).sum()

# Create a bar chart to visualize the total inventory value
fig = px.bar(x=['Total Inventory Value'], y=[total_inventory_value], 
             title='Total Value of Current Inventory', labels={'x': 'Category', 'y': 'Value'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, (UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products
WHERE Discontinued = 0
""""""
inventory_data = execute_sql_query(sql_query)

fig = px.pie(inventory_data, names='ProductName', values='TotalInventoryValue', title='Total Value of Current Inventory')
show_to_user(fig)
```","The input code evaluates the inventory value for each product and visualizes it using a pie chart, filtered by products that are not discontinued. The reference code calculates the total inventory value without any filter and uses a bar chart for visualization of the entire inventory value as a single entity. Thus, the input code does not adhere to the same logic as the reference implementation.","```python
import plotly.express as px

# SQL query to get the total value of current inventory
sql_query = ""SELECT ProductID, (UnitPrice * UnitsInStock) AS InventoryValue FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total value of current inventory
fig = px.bar(df, x='ProductID', y='InventoryValue', title='Total Value of Current Inventory by Product')

# Display the chart to the user
show_to_user(fig)
```","The input code evaluates the inventory value for each product and visualizes those individually using a bar chart. However, the business request and reference code are focused on showing a single total inventory value for all products combined using a single bar. The input code does not calculate or visualize this total, thus not fulfilling the specified requirement.",None
What is the average lead time for each supplier? Visualize the average lead time using a bar chart to compare suppliers effectively.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY products.SupplierID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Ensure 'AverageLeadTime' is treated as a float for plotting
df['AverageLeadTime'] = df['AverageLeadTime'].astype(float)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', 
             title='Average Lead Time for Each Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (days)'}, 
             height=400)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY suppliers.CompanyName
""""""

average_lead_time_df = execute_sql_query(sql_query)
fig = px.bar(average_lead_time_df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier', labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code and the reference implementation are both calculating the average lead time for each supplier and visualizing it using a bar chart. The main difference is that the input code uses the supplier's company name ('CompanyName') instead of 'SupplierID' for visualization, which provides a clearer context for the user. This difference does not affect the correctness of the analysis or the logic. Therefore, the input code correctly adheres to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get average lead time for each supplier
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN orders ON products.ProductID = orders.ProductID 
GROUP BY suppliers.SupplierID, suppliers.CompanyName;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Ensure 'AverageLeadTime' column is numeric
df['AverageLeadTime'] = pd.to_numeric(df['AverageLeadTime'])

# Create a bar chart using plotly
fig = px.bar(df, x='CompanyName', y='AverageLeadTime', 
             title='Average Lead Time by Supplier',
             labels={'CompanyName': 'Supplier', 'AverageLeadTime': 'Average Lead Time (days)'})

# Show the chart
show_to_user(fig)
```","The input code correctly calculates the average lead time for each supplier using a similar method as the reference implementation. It differs slightly by using additional details (CompanyName) and using a different JOIN path via suppliers to orders, but it produces the correct logic for retrieving the average lead time. The visualization approach is consistent, using the company name for labeling, which enhances clarity for presentation. Both implementations achieve the same business objective in different, yet correct, ways.",both
List all orders including the details of the employee who handled them.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT orders.OrderID, orders.CustomerID, orders.OrderDate, 
       employees.LastName, employees.FirstName 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT 
    o.OrderID,
    o.OrderDate,
    o.RequiredDate,
    o.ShippedDate,
    o.ShipName,
    o.ShipAddress,
    o.ShipCity,
    o.ShipRegion,
    o.ShipPostalCode,
    o.ShipCountry,
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    e.Title
FROM 
    orders o
JOIN 
    employees e ON o.EmployeeID = e.EmployeeID
""""""
orders_with_employee_details = execute_sql_query(sql_query)
show_to_user(orders_with_employee_details)
```","The provided code retrieves additional columns such as 'RequiredDate', 'ShippedDate', 'ShipName', 'ShipAddress', 'ShipCity', 'ShipRegion', 'ShipPostalCode', 'ShipCountry', and 'Title' that were not included in the reference implementation. The reference focuses specifically on 'OrderID', 'CustomerID', 'OrderDate', 'FirstName', and 'LastName'. Adding more fields than requested deviates from the requirement, thus making the code not correct as per the given request.","```python
import pandas as pd

# SQL query to retrieve orders and employee details
sql_query = """"""
SELECT o.OrderID, e.EmployeeID, e.FirstName, e.LastName, o.OrderDate 
FROM orders o 
JOIN employees e ON o.EmployeeID = e.EmployeeID;
""""""

# Execute the SQL query
orders_with_employees_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_with_employees_df)
```","The provided input code correctly lists all orders including details of the employee who handled them. It joins the 'orders' and 'employees' tables to retrieve the order ID, order date, and the first and last names of the employee, which matches the logic of the reference implementation. Despite the order of the selected columns being different, the core logic and the output data remain consistent with the business analytics request and the reference code.",Finetuned
What is the total quantity of products ordered from each employee? Use a pie chart to illustrate the proportion of total orders handled by each employee.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalQuantity 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and retrieve the data into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a pie chart using plotly express
fig = px.pie(df, names='EmployeeID', values='TotalQuantity', 
             title='Proportion of Total Orders Handled by Each Employee')

# Display the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
""""""

data = execute_sql_query(sql_query)

fig = px.pie(data, names='EmployeeName', values='TotalQuantity', title='Total Quantity of Products Ordered by Employee')
show_to_user(fig)
```","The input code calculates the total quantity of products ordered from each employee using an SQL query similar to the reference. While the input code includes employee names by concatenating first and last names, it still adheres to the same logic of grouping by employee and summing the quantity. This additional information (employee names) does not affect the correctness. Both codes create a pie chart to visualize the proportion of total orders by employee, fulfilling the business request.","```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT EmployeeID, SUM([Order Details].Quantity) AS TotalQuantity
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY EmployeeID;
""""""

# Execute SQL query and get data as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a pie chart to illustrate the proportion of total orders handled by each employee
fig = px.pie(df, values='TotalQuantity', names='EmployeeID', title='Total Quantity of Products Ordered by Each Employee')

# Show the pie chart
show_to_user(fig)
```","The input code correctly implements the requested functionality: it calculates the total quantity of products ordered by each employee and visualizes the results using a pie chart. The SQL query in the input code correctly sums the 'Quantity' from '[Order Details]' table and groups by 'EmployeeID', which matches the logic of the reference implementation. Additionally, the pie chart is generated using Plotly Express, specifying 'TotalQuantity' as values and 'EmployeeID' as names, consistent with the reference implementation. The differences in naming conventions do not affect the correctness of the logic or the outcome.",both
How many orders were shipped late in the last month?,"```python
import pandas as pd
from datetime import datetime

# Calculate the last month details
today = datetime.today()
first_day_of_this_month = today.replace(day=1)
last_month = first_day_of_this_month - pd.DateOffset(days=1)
last_month_year = last_month.year
last_month_number = last_month.month

# SQL query to count late orders in the last month
sql_query = f""""""
SELECT COUNT(orders.OrderID) AS Late_Orders
FROM orders
WHERE orders.RequiredDate < orders.ShippedDate
AND MONTH(orders.OrderDate) = {last_month_number}
AND YEAR(orders.OrderDate) = {last_month_year};
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Define the date range for the last month
today = datetime.now()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to count late shipped orders
sql_query = f""""""
SELECT COUNT(*) AS LateOrdersCount
FROM orders
WHERE ShippedDate > RequiredDate
AND OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
AND OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
""""""

# Execute the query
late_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(late_orders_df)
```","The input code correctly defines the last month's date range and constructs a SQL query to count orders where 'ShippedDate' is greater than 'RequiredDate' and the 'OrderDate' falls within the last month. This logic matches the reference code, even though the approach to calculating the date range is slightly different.","```python
import pandas as pd
from datetime import datetime, timedelta

# Function to execute the SQL query and get the count of late orders
def get_late_orders_count():
    # Define the SQL query
    sql_query = """"""
    SELECT COUNT(OrderID) AS LateOrdersCount 
    FROM orders 
    WHERE ShippedDate > RequiredDate 
    AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
    """"""
    
    # Execute the SQL query
    late_orders_df = execute_sql_query(sql_query)
    
    # Extract the count of late orders
    late_orders_count = late_orders_df.iloc[0]['LateOrdersCount']
    
    # Create a DataFrame to display the result
    result_df = pd.DataFrame({'LateOrdersCount': [late_orders_count]})
    
    # Display the result to the user
    show_to_user(result_df)

# Call the function to execute the code
get_late_orders_count()
```","The input code logic differs from the reference implementation. The input uses `DATE_SUB(CURDATE(), INTERVAL 1 MONTH)` to retrieve orders from the previous 30 days, which doesn't guarantee it captures exactly the last calendar month. In contrast, the reference code specifically checks the month and year of the `OrderDate` to ensure it pertains to the last month. Additionally, the reference code uses a less than comparison for `ShippedDate` and `RequiredDate`, while the input code uses greater than. This could lead to differing results depending on interpretations of 'late'.",Base
"How many orders were shipped late (i.e., shipped after the required date)?","```python
import pandas as pd

# SQL query to count late orders
sql_query = ""SELECT COUNT(*) AS LateOrders FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(late_orders_df['LateOrders'][0])
```","```python
sql_query = """"""
SELECT COUNT(*) AS LateOrders
FROM orders
WHERE ShippedDate > RequiredDate
""""""
late_orders_df = execute_sql_query(sql_query)
show_to_user(late_orders_df)
```","The input code passes the whole DataFrame to `show_to_user`, while the reference code extracts and displays just the integer value of `LateOrders` using `late_orders_df['LateOrders'][0]`. The logic for retrieving the result differs.","```python
import pandas as pd

# SQL query to execute
sql_query = """"""
SELECT COUNT(*) AS LateOrders
FROM orders
WHERE ShippedDate > RequiredDate;
""""""

# Execute the query
late_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(late_orders_df.iloc[0, 0])
```","The input code correctly replicates the logic of the reference code. Both query the number of late orders from a database by comparing 'ShippedDate' and 'RequiredDate', returning the count of such orders. The difference in accessing the first element from the DataFrame (using iloc instead of column index) does not affect the correctness of the code.",Finetuned
Which employee has the most orders shipped on time? Display the comparison using a bar chart.,"```python
import plotly.express as px

# SQL query to get employee IDs and count of on-time orders
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OnTimeOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate <= o.RequiredDate
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using plotly express
fig = px.bar(df, x='EmployeeID', y='OnTimeOrders', title='On-Time Orders by Employee')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OnTimeOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate <= o.RequiredDate
GROUP BY e.EmployeeID, EmployeeName
ORDER BY OnTimeOrders DESC
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='EmployeeName', y='OnTimeOrders', title='Employee On-Time Shipping Performance', labels={'OnTimeOrders':'Number of On-Time Orders', 'EmployeeName':'Employee'})
show_to_user(fig)
```","The input code correctly implements the logic of counting on-time orders per employee, joining the employees and orders tables, and filtering orders shipped on or before the required date. It adds a feature to include the employee's full name for a more descriptive bar chart, which aligns with the business request. Although the input code includes sorting and renaming of labels, it still adheres to the request to display which employee has the most orders shipped on time using a bar chart.","```python
import plotly.express as px

# SQL query to get the count of on-time orders per employee
sql_query = """"""
SELECT employees.EmployeeID, e.FirstName, e.LastName, COUNT(orders.OrderID) AS OnTimeOrders
FROM employees
INNER JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE orders.ShippedDate <= orders.RequiredDate
GROUP BY employees.EmployeeID, e.FirstName, e.LastName
ORDER BY OnTimeOrders DESC;
""""""

# Execute SQL query using the given function
df = execute_sql_query(sql_query)

# Create a bar chart to display the on-time orders by employee
fig = px.bar(df, x='FirstName', y='OnTimeOrders', text='OnTimeOrders',
             hover_data={'LastName': True},
             labels={'FirstName': 'Employee'},
             title=""Employees with the Most On-Time Orders"")

# Display the result using the given function
show_to_user(fig)
```","The input Python code correctly answers the business analytics request by generating a bar chart of employees with the most on-time orders. Both the reference and input code implement similar logic to retrieve the data using SQL queries and count on-time orders per employee. The differences include additional columns in the select clause (FirstName and LastName), and ordering by OnTimeOrders in the input, which does not affect correctness. The plot is correctly structured in both codes to reflect the required information.",both
What is the most frequently ordered product? Use a bar chart to show frequency counts for the top ordered products.,"```python
import plotly.express as px

# Define the SQL query to get the frequency of ordered products
sql_query = """"""
SELECT p.ProductName, COUNT(od.ProductID) AS OrderCount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY OrderCount DESC
""""""

# Execute the SQL query and retrieve the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Correcting the code: Select only the top products
df_top = df.head(10)  # Assuming we want to display top 10 products

# Create a bar chart using plotly to visualize the frequency counts for the top ordered products
fig = px.bar(df_top, x='ProductName', y='OrderCount', title='Top Ordered Products by Frequency')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
LIMIT 10
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductID', y='TotalQuantity', title='Top Ordered Products', labels={'TotalQuantity': 'Frequency', 'ProductID': 'Product ID'})
show_to_user(fig)
```","The input Python code is not correct because it does not match the logic specified in the reference implementation. The reference code counts the frequency of product orders by product name, while the input code sums quantities of products ordered by product ID. Additionally, the input code does not join the products table to retrieve product names for meaningful labels. These differences mean the code does not correctly address the business analytics request as specified.","Here's the Python code to find the most frequently ordered products and create a bar chart to display the frequency counts of the top ordered products:

```python
import plotly.express as px

# SQL Query to retrieve the top 10 most frequently ordered products
sql_query = """"""
SELECT p.ProductName, COUNT(od.ProductID) AS TotalOrders 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalOrders DESC 
LIMIT 10;
""""""

# Execute the SQL query
df_top_products = execute_sql_query(sql_query)

# Create a bar chart for the top ordered products
fig = px.bar(df_top_products, x='ProductName', y='TotalOrders', title='Top Ordered Products')

# Display the bar chart
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: The SQL query retrieves the 10 most frequently ordered products along with their order counts by joining the `products` table and the `[Order Details]` table.
2. **Data Execution**: The `execute_sql_query(sql_query)` function runs the SQL query to get the data in a pandas DataFrame.
3. **Bar Chart Creation**: `plotly.express` is used to create a bar chart with product names on the x-axis and total orders on the y-axis.
4. **Display Visualization**: The visualization is presented to the user with `show_to_user(fig)`.

This code will provide the user with a visual representation of the top ordered products.","The input code retrieves the top 10 most frequently ordered products and displays them in a bar chart. It correctly joins the `products` and `[Order Details]` tables, groups by `ProductName`, counts orders as `TotalOrders`, and orders them in descending order. The use of `LIMIT 10` directly in the SQL query efficiently retrieves only the necessary rows, aligning with the reference implementation's intent. The plotting and display logic using Plotly to create a bar chart and show it to the user is consistent with the reference implementation.",Finetuned
Which products have a unit price greater than 50?,"```python
sql_query = ""SELECT ProductName FROM products WHERE UnitPrice > 50;""
products_df = execute_sql_query(sql_query)
show_to_user(products_df)
```","```python
sql_query = ""SELECT ProductID, ProductName, UnitPrice FROM products WHERE UnitPrice > 50""
product_data = execute_sql_query(sql_query)
show_to_user(product_data)
```","The input Python code correctly filters products with a unit price greater than 50 and retrieves the necessary information. While it extra includes ProductID and UnitPrice in the query result, this doesn't deviate from the business requirement to identify products priced over 50. The primary task of identifying such products is achieved correctly.","```python
import pandas as pd

# Execute the SQL query to get the products
products_df = execute_sql_query(""SELECT ProductName FROM products WHERE UnitPrice > 50;"")

# Show the results to the user
show_to_user(products_df)
```","The input code correctly executes the same SQL query as the reference implementation to retrieve products with a unit price greater than 50 and then displays the results, following the intended logic.",both
How many units of each product were ordered last month? Visualize the data using a bar chart for a clear comparison.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].Quantity) AS UnitsOrderedLastMonth 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderDate >= DATEADD(month, -1, GETDATE()) 
GROUP BY products.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='UnitsOrderedLastMonth', 
             title='Units Ordered Last Month by Product', 
             labels={'UnitsOrderedLastMonth':'Units Ordered', 'ProductID':'Product ID'})

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the first and last date of the last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to fetch the total quantity of products ordered last month
sql_query = f""""""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID
    FROM [Order Details] 
    WHERE OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
    AND OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
)
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrdered DESC;
""""""

# Execute the SQL query
product_orders = execute_sql_query(sql_query)

# Create the bar chart
fig = px.bar(product_orders, x='ProductName', y='TotalOrdered', 
             title='Total Units Ordered Last Month',
             labels={'TotalOrdered': 'Total Units Ordered', 'ProductName': 'Product Name'},
             text='TotalOrdered')

# Show the visualization
show_to_user(fig)
```","The input code correctly addresses the business analytics request by calculating the total number of units ordered for each product last month. It uses a similar logic to the reference code by joining the 'products' and 'Order Details' tables to sum quantities, with a condition to filter dates for the last month. Although the input code calculates first and last day of the previous month differently and includes 'ProductName' in the output, the overarching logic and purpose are consistent with the reference implementation. The visualization using a bar chart effectively compares the total units ordered for each product.","```python
import plotly.express as px

# SQL query to fetch the number of units of each product ordered last month
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
WHERE MONTH(OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH)
AND YEAR(OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH)
GROUP BY ProductID;
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Create a bar chart for visualizing total quantity ordered per product
fig = px.bar(df, x='ProductID', y='TotalQuantityOrdered', 
             title='Total Quantity Ordered per Product Last Month', 
             labels={'TotalQuantityOrdered': 'Total Quantity Ordered', 'ProductID': 'Product ID'})

# Display the figure using the provided utility function
show_to_user(fig)
```","The input Python code correctly answers the business analytics request by querying the same information: the number of units ordered for each product in the last month. Both implementations calculate this by summing the 'Quantity' and grouping by 'ProductID'. The input code uses a different method to get the previous month's records by manipulating the date with 'CURRENT_DATE - INTERVAL 1 MONTH', which is functionally equivalent to the 'DATEADD' approach in the reference code. Both codes visualize the results using a bar chart with Plotly. Thus, the logic and outcome are consistent with the reference implementation.",both
Which shipping company has the highest on-time delivery rate? A bar chart can show the on-time delivery rates for easy comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the data
sql_query = """"""
SELECT shippers.CompanyName, 
    COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / 
    CAST(COUNT(orders.OrderID) AS float) AS on_time_delivery_rate 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY on_time_delivery_rate DESC
""""""

# Execute the SQL query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the company with the highest on-time delivery rate
top_company = df.iloc[0]
show_to_user(top_company)

# Create a bar chart for on-time delivery rates
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate', 
             title='On-Time Delivery Rates by Shipping Company')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to calculate on-time delivery rates by shipping company
sql_query = """"""
SELECT 
    shippers.CompanyName, 
    COUNT(orders.OrderID) AS total_orders,
    COUNT(orders.OrderID WHERE orders.ShippedDate <= orders.RequiredDate) AS on_time_delivered,
    COUNT(orders.OrderID WHERE orders.ShippedDate <= orders.RequiredDate) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM 
    orders
JOIN 
    shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY 
    shippers.CompanyName
ORDER BY 
    on_time_delivery_rate DESC
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart for the on-time delivery rates
fig = px.bar(result_df, 
             x='CompanyName', 
             y='on_time_delivery_rate', 
             title='On-time Delivery Rate by Shipping Company',
             labels={'on_time_delivery_rate': 'On-time Delivery Rate'},
             text='on_time_delivery_rate')

# Show the graph to the user
show_to_user(fig)
```","The evaluated code uses incorrect SQL syntax for conditional aggregation in COUNT, using 'COUNT(orders.OrderID WHERE...)' instead of the correct 'COUNT(orders.OrderID) FILTER (WHERE...)' used in the reference code. This will result in a SQL syntax error. The calculation logic for 'on_time_delivery_rate' should be the same, but due to the syntax error, the code will not execute as intended.","```python
import plotly.express as px

# SQL query to get on-time delivery rate for each shipping company
sql_query = """"""
SELECT shippers.ShipperID, 
       (COUNT(orders.OrderID) 
       FILTER (WHERE orders.ShippedDate <= orders.RequiredDate)) * 100.0 / COUNT(orders.OrderID) AS OnTimeDeliveryRate 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.ShipperID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort dataframe by OnTimeDeliveryRate to highlight the highest rate
df = df.sort_values(by=""OnTimeDeliveryRate"", ascending=False)

# Create a bar chart for easy comparison of on-time delivery rates
fig = px.bar(df, x='ShipperID', y='OnTimeDeliveryRate', title='On-Time Delivery Rates by Shipping Company')

# Show the bar chart to the user
show_to_user(fig)
```","The input code computes the on-time delivery rate using ShipperID instead of CompanyName, which does not fully answer the business request. It also does not identify the company with the highest rate, which is a specific requirement.",None
What is the total discount amount given for each product? Use a bar chart to display the total discount amounts.,"```python
import plotly.express as px

# SQL query to retrieve total discount amount for each product
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to display the total discount amounts
fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Total Discount Amount for Each Product')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductName', y='TotalDiscount', title='Total Discount Amount by Product')
show_to_user(fig)
```","The input code calculates the total discount as SUM(od.Discount * od.Quantity), which does not include the UnitPrice, whereas the reference implementation uses SUM(od.UnitPrice * od.Quantity * od.Discount). The omission of UnitPrice in the calculation leads to incorrect total discount amounts.","```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * Discount) AS TotalDiscount 
FROM [Order Details] 
GROUP BY ProductID;
""""""

# Execute the query and get the result as a pandas dataframe
discount_data = execute_sql_query(sql_query)

# Create a bar chart to display the total discount amounts for each product
fig = px.bar(discount_data, x='ProductID', y='TotalDiscount', title='Total Discount Amount per Product')

# Show the bar chart to the user
show_to_user(fig)
```","The input code calculates the total discount per ProductID rather than per ProductName, differing from the business request to display total discount amounts by ProductName. Additionally, the SQL query in the input code does not join with the products table to map ProductID to ProductName.",None
Calculate the total number of products sold by each employee. Represent the data using a bar chart.,"```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].Quantity) AS TotalProductsSold
FROM employees
INNER JOIN orders ON employees.EmployeeID = orders.EmployeeID
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='EmployeeID', y='TotalProductsSold', title='Total Products Sold by Each Employee')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.Quantity) AS TotalProductsSold
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='FirstName', y='TotalProductsSold', 
             title='Total Products Sold by Each Employee', 
             labels={'FirstName': 'Employee Name', 'TotalProductsSold': 'Total Products Sold'})

show_to_user(fig)
```","The input code correctly calculates the total number of products sold by each employee and displays it with a bar chart. While it includes FirstName and LastName in the SQL query for additional granularity and uses FirstName for the x-axis in the chart, it adheres to the same logic regarding joining tables and grouping by EmployeeID. These differences do not affect the correctness of the requested operation.","```python
import plotly.express as px

# SQL query to get total products sold by each employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY EmployeeID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total products sold by each employee
fig = px.bar(df, x='EmployeeID', y='TotalOrders', title='Total Products Sold by Each Employee')

# Show the bar chart to the user
show_to_user(fig)
```","The input code incorrectly calculates 'TotalOrders' using a count of 'OrderID', not the sum of 'Quantity' from 'Order Details'. This does not reflect the total number of products sold, unlike the reference code which properly aggregates 'Quantity' to get 'TotalProductsSold'.",Base
List customers who have not placed any orders in the last year.,"```python
import pandas as pd

# SQL query to list customers who have not placed any orders in the last year
sql_query = """"""
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderID IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
""""""

# Execute SQL query and retrieve data as a pandas dataframe
customer_data = execute_sql_query(sql_query)

# Remove duplicates to ensure unique customer results
unique_customer_data = customer_data.drop_duplicates()

# Display the result to the user
show_to_user(unique_customer_data)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate the date one year ago from today
one_year_ago = datetime.now() - timedelta(days=365)
one_year_ago_str = one_year_ago.strftime('%Y-%m-%d')

# SQL query to find customers who have not placed any orders in the last year
sql_query = f""""""
SELECT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, 
       c.City, c.Region, c.PostalCode, c.Country, c.Phone, c.Fax
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID AND o.OrderDate >= '{one_year_ago_str}'
WHERE o.CustomerID IS NULL;
""""""

# Execute the SQL query and get the data
inactive_customers = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(inactive_customers)
```","The input code checks if a customer has placed any orders with an order date in the last year. If `o.OrderDate >= {one_year_ago_str}` fails, the customer is considered inactive. The logic differs: it explicitly checks for the order date criteria in the JOIN, whereas the reference implementation considers any NULL order or orders older than a year (`o.OrderID IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR)`). The input code may exclude customers with no orders ever, focusing only on those with older orders. Additionally, the input code includes more columns, but that doesn't affect the correctness regarding the business request.","```python
import pandas as pd

# SQL query to get customers who have not placed any orders in the last year
sql_query = """"""
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderID IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR);
""""""

# Execute SQL query
customers_df = execute_sql_query(sql_query)

# Display the result
show_to_user(customers_df)
```","The provided input code correctly implements the logic requested in the business analytics query. It retrieves customers who have not placed any orders in the last year using a SQL query, performs a LEFT JOIN on customers and orders, and uses a condition to filter customers with no recent orders. The logic matches the reference implementation, including executing the SQL query and displaying the results. The difference in handling duplicates does not impact the correctness regarding the business question.",Finetuned
Identify products with a unit price greater than the average unit price across all products.,"```python
import pandas as pd

# Execute the SQL query to fetch the product data
products_df = execute_sql_query(""SELECT ProductID, ProductName, UnitPrice FROM products"")

# Calculate the average unit price
average_price = products_df['UnitPrice'].mean()

# Filter products with a unit price greater than the average
filtered_products_df = products_df[products_df['UnitPrice'] > average_price][['ProductID', 'ProductName']]

# Display the result to user
show_to_user(filtered_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice
FROM products
WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products)
""""""
products_above_average_price = execute_sql_query(sql_query)
show_to_user(products_above_average_price)
```","Both the reference implementation and the code to evaluate identify products with a UnitPrice greater than the average UnitPrice across all products. The SQL query in the input code performs this filtering directly in the database, while the reference code does it in Python after fetching all data. Both approaches return the same result.","```python
import pandas as pd

# SQL query to retrieve products with a unit price greater than the average unit price
sql_query = """"""
SELECT * FROM (
    SELECT ProductName, UnitPrice, CategoryID 
    FROM products 
    WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products)
) as subquery;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input code uses a nested SQL query to execute logic. The subquery selects records with a 'UnitPrice' greater than the average across all products. However, it includes 'CategoryID' which is not in the reference implementation. The reference code does not consider 'CategoryID' and focuses only on 'ProductID' and 'ProductName' of products, which results in potential discrepancies if 'CategoryID' influences the logic. Thus, the logic does not fully match the reference implementation structure.",Base
What is the most frequently ordered product in 2023? Use a bar chart to compare the frequencies.,"```python
import plotly.express as px

# Define SQL query to get order counts for 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, COUNT([Order Details].OrderID) AS order_count 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE YEAR([Order Details].OrderDate) = 2023
GROUP BY products.ProductID, products.ProductName 
ORDER BY order_count DESC
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ProductName', y='order_count', title='Most Frequently Ordered Products in 2023')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY products.ProductName
ORDER BY total_quantity DESC
LIMIT 10
""""""

# Execute the SQL query
product_data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(product_data, x='ProductName', y='total_quantity', title='Most Frequently Ordered Products in 2023',
             labels={'total_quantity': 'Order Quantity', 'ProductName': 'Product Name'})

# Show the result to the user
show_to_user(fig)
```","The input code measures 'total_quantity' instead of 'order_count'. The business analytics request asks for the most frequently ordered product, which should be based on the number of orders (order frequency), not the total quantity ordered. Furthermore, the input code limits the results to 10, which changes the scope of the analysis. This deviates from the logic in the reference implementation.","```python
import plotly.express as px

# SQL Query to fetch the required data
sql_query = """"""
SELECT products.ProductID, products.ProductName, COUNT([Order Details].OrderID) AS OrderCount
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE YEAR([Order Details].OrderDate) = 2023
GROUP BY products.ProductID, products.ProductName
ORDER BY OrderCount DESC;
""""""

# Execute SQL query and get the results
df = execute_sql_query(sql_query)

# Check if the dataframe is empty
if df.empty:
    print(""No data found."")
else:
    # Create a bar chart using plotly
    fig = px.bar(df, x='ProductName', y='OrderCount', title='Most Frequently Ordered Products in 2023')

    # Display the result to the user
    show_to_user(fig)
```","The input Python code correctly implements the business analytics request and aligns with the logic of the reference implementation. Both codes use a SQL query to retrieve the products and their order counts for the year 2023, grouped by ProductID and ProductName, and sorted by order counts in descending order. They both utilize Plotly to generate a bar chart with the results and display it to the user. The input code includes an additional check for an empty DataFrame, which does not alter the correctness of the analysis.",Finetuned
What are the names and IDs of all products that are currently out of stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;""

# Execute the SQL query to retrieve the data
out_of_stock_products = execute_sql_query(sql_query)

# Display the result
show_to_user(out_of_stock_products)
```","```python
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE UnitsInStock = 0
""""""
out_of_stock_products = execute_sql_query(sql_query)
show_to_user(out_of_stock_products)
```","The input Python code accurately performs the same task as the reference implementation. Both codes construct and execute an SQL query that selects ProductID and ProductName from the 'products' table where 'UnitsInStock' equals zero, and then display the result using the 'show_to_user' function. Any differences are purely in formatting, not in logic or functionality.","```python
import pandas as pd

# SQL query to get the names and IDs of all products currently out of stock
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;""

# Execute the SQL query and retrieve the result as a pandas dataframe
out_of_stock_products_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(out_of_stock_products_df)
```",The input Python code correctly implements the logic of retrieving names and IDs of products that are out of stock by executing a SQL query with the same logic as the reference implementation. It uses the same SQL query and functions to execute the query (`execute_sql_query`) and display the result (`show_to_user`).,both
How many products were low on stock (below reorder level) in August 2023?,"```python
import pandas as pd

# Define the SQL Query
sql_query = """"""
SELECT products.ProductID 
FROM products 
WHERE products.UnitsInStock < products.ReorderLevel 
AND MONTH(products.RecordDate) = 8 
AND YEAR(products.RecordDate) = 2023
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Count the number of products low on stock
low_stock_count = df['ProductID'].nunique()  # Use nunique to count distinct ProductIDs

# Create a result dataframe to show the count
result_df = pd.DataFrame({""LowStockCount"": [low_stock_count]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS low_stock_products
FROM products
WHERE UnitsInStock < ReorderLevel
AND Discontinued = 0
""""""
results = execute_sql_query(sql_query)
show_to_user(results)
```","The input code does not filter for products below the reorder level specifically in August 2023, as the reference code does. It also includes a filter for 'Discontinued = 0', which is not in the reference implementation. Moreover, it counts using SQL's COUNT(*) directly instead of counting unique 'ProductID's from a result set of a specific date range.","```python
import pandas as pd

# SQL query to retrieve product names and their units in stock
sql_query = """"""
SELECT ProductID,ProductName,UnitsInStock 
FROM products 
WHERE MONTH(DiscontinuedDate) = 8 AND YEAR(DiscontinuedDate) = 2023;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Filter products with units in stock below the reorder level
low_stock_products = df[df['UnitsInStock'] < df['ReorderLevel']]

# Count the number of products low on stock
low_stock_count = low_stock_products.shape[0]
result_df = pd.DataFrame({'Number of Products Low on Stock': [low_stock_count]})

# Display the result
show_to_user(result_df)
```","The input code incorrectly filters products using 'DiscontinuedDate' instead of 'RecordDate'. Additionally, it counts all such entries rather than computing unique 'ProductID's.",None
What is the total number of products available in the inventory?,"```python
import pandas as pd

# SQL query to get the total number of products
sql_query = ""SELECT COUNT(*) as total_products FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['total_products'].iloc[0])
```","```python
sql_query = ""SELECT SUM(UnitsInStock) AS TotalProducts FROM products""
total_products = execute_sql_query(sql_query)
show_to_user(total_products)
```","The input Python code calculates the sum of 'UnitsInStock' from the 'products' table, which gives the total units in stock for all products. However, the business analytics request and reference implementation are asking for the count of distinct products, not the total units in stock.","```python
import pandas as pd

# SQL query to execute
sql_query = ""SELECT SUM(UnitsInStock) AS TotalUnitsInStock FROM products;""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Display the total number of products available in the inventory
total_units_in_stock = df['TotalUnitsInStock'][0]
show_to_user(pd.DataFrame({""TotalUnitsInStock"": [total_units_in_stock]}))
```","The input code calculates the sum of 'UnitsInStock' instead of counting the total number of products. The task requires counting the number of product entries, not summing the stock quantities.",None
Which shipping company has the highest on-time delivery rate? Display the rates using a bar chart for a better comparison.,"```python
import plotly.express as px

# SQL query to retrieve the shipping company's on-time delivery data
sql_query = """"""
SELECT ShipVia, 
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipVia 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query using the provided function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly for better comparison
fig = px.bar(df, x='ShipVia', y='OnTimeDeliveryRate', title='On-Time Delivery Rate by Shipping Company', labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-Time Delivery Rate'})

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, 
       COUNT(OrderID) AS TotalOrders, 
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM orders
GROUP BY ShipVia
""""""

delivery_data = execute_sql_query(sql_query)

delivery_data['OnTimeRate'] = delivery_data['OnTimeDeliveries'] / delivery_data['TotalOrders'] * 100

fig = px.bar(delivery_data, x='ShipVia', y='OnTimeRate', 
             labels={'ShipVia': 'Shipping Company', 'OnTimeRate': 'On-time Delivery Rate (%)'},
             title='On-time Delivery Rate by Shipping Company')

show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate by dividing the number of on-time deliveries by the total orders for each shipping company. This is equivalent to the reference implementation, which performs the same division within the SQL query. Both codes then use Plotly to create a bar chart to visualize the on-time delivery rates, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT ShipVia, (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(*)) * 100 AS on_time_rate 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query and get the result in a dataframe
df = execute_sql_query(sql_query)

# Correct the column names in case they're read with leading/trailing spaces
df.columns = df.columns.str.strip()

# Create a bar chart for on-time delivery rates by shipping company
fig = px.bar(df, x='ShipVia', y='on_time_rate', title='On-Time Delivery Rate by Shipping Company')

# Show the graph to the user
show_to_user(fig)

# Identify the shipping company with the highest on-time delivery rate
max_on_time_delivery_rate = df['on_time_rate'].max()
highest_on_time_company = df[df['on_time_rate'] == max_on_time_delivery_rate]['ShipVia']

# Show the highest on-time delivery rate company to the user
show_to_user(highest_on_time_company)
```","The input code has a logical error in calculating the on-time delivery rate. The SQL expression COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(*) is incorrect because COUNT(CASE...) will return the same count as COUNT(*) since NULLs are not counted by COUNT. The correct way is to use SUM instead of COUNT for the condition. Therefore, the input code does not accurately replicate the logic of the reference code.",Base
What are the top 5 products in terms of total units sold? Visualize the top products using a bar chart for better insights.,"```python
import plotly.express as px

# SQL query to retrieve top 5 products by total units sold
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalUnitsSold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
'''

# Execute the SQL query
df_top_products = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df_top_products, x='ProductName', y='TotalUnitsSold',
             title='Top 5 Products by Total Units Sold',
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalUnitsSold',
              title='Top 5 Products by Total Units Sold',
              labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The provided code correctly implements the required logic to find the top 5 products by total units sold. It uses an SQL query similar to the reference code to aggregate and sort the products based on the total units, and it visualizes the result using a Plotly bar chart. The output of the execution of the SQL query is then correctly visualized with the same parameters as the reference code, fulfilling the business analytics request.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalUnitsSold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
""""""

# Execute SQL query
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(top_products_df, x='ProductName', y='TotalUnitsSold', 
             title='Top 5 Products by Total Units Sold',
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code aligns with the reference implementation's logic and business request. Both codes retrieve the top 5 products based on total units sold by executing a SQL query. The only difference is that the input code does not select 'ProductID'; however, 'ProductID' is not used on the x-axis for visualization, so it does not affect the outcome. Both codes visualize the results using a bar chart with Plotly and display the top products accurately.",both
What is the monthly average shipping cost?,"```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve monthly average shipping cost
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Plot the result
fig = px.line(df, x='Month', y='AvgShippingCost', title='Monthly Average Shipping Cost')

# Display the result to the user
show_to_user(fig)
```","```python
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(Freight) AS AverageShippingCost
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

average_shipping_cost_df = execute_sql_query(sql_query)
show_to_user(average_shipping_cost_df)
```","The input code correctly calculates the monthly average shipping cost using a similar SQL query as the reference. Although it does not include a plot, the core requirement is met through data retrieval organized by the month, consistent with the reference logic.","```python
import pandas as pd

# Define the SQL query to calculate monthly average shipping cost
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
       AVG(Freight) AS MonthlyAvgShippingCost 
FROM orders 
GROUP BY OrderMonth;
""""""

# Execute the SQL query and get the result as a pandas dataframe
monthly_avg_shipping_cost_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(monthly_avg_shipping_cost_df)
```","The input code correctly calculates the monthly average shipping cost using the SQL query. It mirrors the logic of the reference implementation by grouping the 'orders' data by month and calculating the average 'Freight'. The primary difference is the missing plot in the input code, but since the request was only to find the monthly average shipping cost, the core functionality is correct.",both
Which employee has the highest sales in Q1 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID 
ORDER BY employee_sales DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC 
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code correctly retrieves the employee with the highest sales in Q1 2023. While it includes the employee's first and last names, which differ from the reference implementation, the additional information does not affect the core logic or outcome of the query. The grouping and ordering criteria remain consistent with the reference, ensuring it still identifies the employee with the highest sales for the specified period.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID 
ORDER BY employee_sales DESC 
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The provided input Python code is identical to the reference implementation in terms of logic and functionality. Both codes perform the same task: they execute an SQL query to find the employee with the highest sales in Q1 2023. The SQL query, execution, and display steps are unchanged, and the code maintains the correct logic as requested in the business analytics request.",both
What is the total revenue generated from each product sold in 2022? Visualize the revenue distribution across products.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    products.ProductID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID
""""""

# Execute the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Ensure ProductID is treated as a string for visualization purposes
data['ProductID'] = data['ProductID'].astype(str)

# Visualize the revenue distribution across products
fig = px.bar(data, x='ProductID', y='total_revenue', title='Total Revenue by Product in 2022')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID, products.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='total_revenue', title='Total Revenue per Product in 2022')
show_to_user(fig)
```","The input code correctly retrieves the total revenue for each product sold in 2022 by joining the tables correctly and summing up the unit price times quantity with the discount considered. While the input code includes the 'ProductName' in the query and visualization, this does not alter the correctness of the logic, which matches the reference. The visualization task is completed as requested, showing total revenue per product, and the addition of 'ProductName' only enhances clarity without affecting the core requirement.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total revenue per product for 2022
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductName
""""""

# Execute SQL query and store result in a dataframe
revenue_df = execute_sql_query(sql_query)

# Visualization of revenue distribution across products
fig = px.bar(revenue_df, x='ProductName', y='total_revenue', title='Total Revenue by Product in 2022',
             labels={'total_revenue': 'Total Revenue', 'ProductName': 'Product Name'})

# Display the visualization
show_to_user(fig)
```","The input Python code uses the same logic as the reference implementation to calculate the total revenue for each product sold in 2022. The difference lies in the grouping field: the input code groups by 'ProductName' while the reference code groups by 'ProductID'. Assuming that 'ProductName' is uniquely associated with 'ProductID', the input code correctly answers the business analytics request. Furthermore, both implementations visualize the revenue distribution across products using a bar chart. The code can be considered correct given these circumstances.",both
What is the most ordered product in terms of quantity?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
    SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantityOrdered 
    FROM [Order Details] 
    JOIN products 
    ON [Order Details].ProductID = products.ProductID 
    GROUP BY products.ProductName 
    ORDER BY TotalQuantityOrdered DESC 
    LIMIT 1;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

most_ordered_product = execute_sql_query(sql_query)
show_to_user(most_ordered_product)
```","The input Python code correctly follows the logic of the reference implementation. Both codes execute a SQL query that selects the product name and the sum of ordered quantities from the 'Order Details' table, joins with the 'products' table on 'ProductID', groups by product name, and orders the results in descending order of total quantity. The SQL queries limit the results to a single entry, identifying the most ordered product. Therefore, the input code meets the business analytics request accurately.","```python
import pandas as pd

# SQL query to find the most ordered product in terms of quantity
sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY TotalQuantity DESC 
LIMIT 1;
""""""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code only retrieves the ProductID of the most ordered product without joining the 'products' table to get the ProductName. The reference code joins the 'Order Details' and 'products' tables to output the ProductName, which makes it fully address the business request.",Base
How many products have less than 10 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID FROM products WHERE UnitsInStock < 10;""

# Execute the query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Count the number of products with less than 10 units in stock
product_count = len(df)

# Display the result to the user
show_to_user(product_count)
```","```python
sql_query = """"""
SELECT COUNT(*) AS ProductsUnder10Stock 
FROM products 
WHERE UnitsInStock < 10;
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code uses a different SQL query approach by aggregating the count of products with less than 10 units in stock directly in SQL. The reference code retrieves matching product IDs and counts them in Python. Both implement the same logic of counting products with units in stock under 10, thus the input code is correct.","```python
import pandas as pd

# SQL query to find products with less than 10 units in stock
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query
low_stock_products_df = execute_sql_query(sql_query)

# Count the number of products
low_stock_product_count = low_stock_products_df.shape[0]

# Display the result to the user
result_df = pd.DataFrame({'Number of Products with <10 Units': [low_stock_product_count]})
show_to_user(result_df)
```","The input code correctly executes a SQL query to count the number of products with less than 10 units in stock. It deviates slightly from the reference query by selecting 'ProductName' instead of 'ProductID', but this difference does not affect the final count. Both implementations achieve the same result of determining how many products have less than 10 units in stock, thus the input code is correct.",both
List the top 5 products with the highest total sales revenue. Visualize the sales revenue comparison among these products.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID, products.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Visualize the sales revenue comparison among the top 5 products
fig = px.bar(top_products_df, 
             x='ProductName', 
             y='TotalSales', 
             title='Top 5 Products by Total Sales Revenue', 
             labels={'TotalSales': 'Total Sales Revenue', 'ProductName': 'Product Name'})

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue for each product
sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalRevenue DESC
LIMIT 5
""""""

# Execute the SQL query and get the DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart for total sales revenue comparison
fig = px.bar(top_products_df, x='ProductName', y='TotalRevenue', 
             title='Top 5 Products by Total Sales Revenue',
             labels={'TotalRevenue': 'Total Sales Revenue', 'ProductName': 'Product Name'})

# Show the figure to the user
show_to_user(fig)
```","The input code executes an SQL query to retrieve the top 5 products by total sales revenue and visualizes the results using a bar chart, just like the reference implementation. The only difference is the inclusion of an additional join with the 'orders' table, which does not affect the calculation of total sales revenue. The logic and intended outcome match the reference, so the input code is considered correct.","```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute SQL query and retrieve the data
top_products_df = execute_sql_query(sql_query)

# Creating a bar chart using plotly
fig = px.bar(top_products_df, x='ProductName', y='TotalRevenue', 
             title='Top 5 Products by Total Sales Revenue',
             labels={'TotalRevenue': 'Total Sales Revenue', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)
```","The input code accurately reflects the logic of the reference implementation. Both codes execute a SQL query to fetch the top 5 products based on total sales revenue. The SQL queries join the 'Order Details' table with the 'products' table, calculate total sales revenue for each product, and order by total sales in descending order, limiting the result to 5 entries. The visualization part also correctly plots a bar chart with 'ProductName' on the x-axis and sales revenue on the y-axis, matching the intent of visualizing the top 5 products by sales revenue.",both
Which products have the highest and lowest inventory turnover ratio? Visualize the turnover ratios for comparison.,"```python
import plotly.express as px

# Define the SQL query to get inventory turnover ratios
sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    p.ProductName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort to find the highest and lowest inventory turnover ratios
sorted_df = df.sort_values(by='InventoryTurnoverRatio', ascending=False)

# Filter for products with the highest and lowest inventory turnover ratios
highest_df = sorted_df.head(1)
lowest_df = sorted_df.tail(1)
comparison_df = highest_df.append(lowest_df)

# Visualize the turnover ratios for comparison
fig = px.bar(comparison_df, x='ProductName', y='InventoryTurnoverRatio', title='Highest and Lowest Inventory Turnover Ratios for Products')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity * od.UnitPrice) AS Sales,
    AVG(p.UnitsInStock) AS AverageInventory,
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

turnover_data = execute_sql_query(sql_query)

highest_turnover = turnover_data.loc[turnover_data['InventoryTurnoverRatio'].idxmax()]
lowest_turnover = turnover_data.loc[turnover_data['InventoryTurnoverRatio'].idxmin()]

turnover_comparison = turnover_data[['ProductName', 'InventoryTurnoverRatio']]

fig = px.bar(turnover_comparison, x='ProductName', y='InventoryTurnoverRatio',
             title='Inventory Turnover Ratio Comparison',
             labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code does not filter the data to visualize only the highest and lowest inventory turnover ratios. It creates a bar chart for all products rather than just the two of interest. Additionally, the visualization section should only use the highest and lowest turnover data like in the reference code.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT ProductName, 
       SUM(od.Quantity) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY ProductName 
ORDER BY InventoryTurnoverRatio DESC;
""""""

# Execute the query using the provided utility function
df = execute_sql_query(sql_query)

# Visualize Inventory Turnover Ratios
fig = px.bar(df, x='ProductName', y='InventoryTurnoverRatio', 
             title='Inventory Turnover Ratios by Product',
             labels={'InventoryTurnoverRatio': 'Turnover Ratio', 'ProductName': 'Product'},
             color='InventoryTurnoverRatio',
             color_continuous_scale='RdBu')

# Show the visualization to the user
show_to_user(fig)

# Optionally display the products with the highest and lowest turnover ratios
highest_turnover = df.iloc[0]
lowest_turnover = df.iloc[-1]

highest_lowest_df = df.iloc[[0, -1]]
show_to_user(highest_lowest_df)
```","The input code and the reference implementation differ in calculating the inventory turnover ratio. The reference uses revenue (Quantity * UnitPrice) over average stock, which accounts for sales value, while the input uses only the quantity. This affects the result as the turnover involves financial metrics. Additionally, the input code sorts and displays all products and highlights the highest and lowest outside of the main bar plot, whereas the reference explicitly extracts only the highest and lowest for visualization. These differences mean the input does not fully align with the logic of the reference.",None
Identify employees with the highest and lowest order counts. Visualize the order counts for each employee.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1 
UNION 
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount ASC 
LIMIT 1;
""""""

# Execute the query
employees_df = execute_sql_query(sql_query)

# Adjust FirstName for proper visualization if multiple employees have the same name
employees_df['FullName'] = employees_df['FirstName'] + ' ' + employees_df['LastName']

# Generate a bar plot for order counts
fig = px.bar(employees_df, x='FullName', y='OrderCount', color='OrderCount', 
             title='Order Counts for Employees with Highest and Lowest Orders')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY OrderCount;
""""""

employee_order_counts = execute_sql_query(sql_query)

highest_order_count = employee_order_counts.loc[employee_order_counts['OrderCount'].idxmax()]
lowest_order_count = employee_order_counts.loc[employee_order_counts['OrderCount'].idxmin()]

order_counts_fig = px.bar(employee_order_counts, 
                           x='EmployeeID', 
                           y='OrderCount', 
                           title='Order Counts by Employee',
                           labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'},
                           text='OrderCount')

show_to_user(order_counts_fig)

highest_order_count, lowest_order_count
```",The input code does not correctly implement the request as it displays the order counts for all employees rather than identifying and specifically visualizing only the employees with the highest and lowest order counts. The visualization should focus on only those two employees instead of the entire list.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the order counts for each employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID;
""""""
# Execute the SQL query
order_counts_df = execute_sql_query(sql_query)

# Identify employee with highest and lowest order counts
highest_order_employee = order_counts_df.loc[order_counts_df['OrderCount'].idxmax()]
lowest_order_employee = order_counts_df.loc[order_counts_df['OrderCount'].idxmin()]

# Display highest and lowest order count employees
show_to_user(highest_order_employee.to_frame().T)
show_to_user(lowest_order_employee.to_frame().T)

# Plot order counts for each employee
fig = px.bar(order_counts_df, x='EmployeeID', y='OrderCount', title='Order Counts per Employee')
show_to_user(fig)
```","The input code does not correctly address the business analytics request. The reference code retrieves both the employee with the highest and lowest order counts by first joining the employees table with the orders table to include names and then limiting the results via SQL query. In contrast, the input code only retrieves order counts per employee from the orders table and does not ensure that the employees with the highest and lowest order counts are obtained from the full employee data, including their names. Furthermore, it doesn't incorporate the employee names in the final visualization, as the reference code does.",None
Which employee handled the most orders?,"```python
import pandas as pd

# SQL query to get the EmployeeID with the most orders
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Since we need only EmployeeID, extract it from the dataframe
most_orders_employee = result_df['EmployeeID'].iloc[0]

# Display the EmployeeID to the user
show_to_user(most_orders_employee)
```","```python
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
""""""

most_orders_employee = execute_sql_query(sql_query)
show_to_user(most_orders_employee)
```","The input code executes the correct SQL query, but it does not extract the EmployeeID from the resulting dataframe. The result from execute_sql_query is expected to be a dataframe, so the EmployeeID should be extracted similarly to the reference implementation using result_df['EmployeeID'].iloc[0].","```python
import pandas as pd

# Define the SQL query to find the employee with the most handled orders
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS HandledOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY HandledOrders DESC
LIMIT 1;
""""""

# Execute the SQL query using the utility function provided
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The input code retrieves the employee with the most handled orders using a correct SQL query. It joins the employees and orders tables, groups by EmployeeID, and orders the results by handled orders in descending order, selecting the top result with LIMIT 1. This aligns with the logic of the reference implementation, which also seeks the employee ID with the most orders, despite including additional columns (FirstName and LastName) in the GROUP BY statement which doesn't contradict the request.",Finetuned
Calculate the average lead time for each supplier in delivered products. Visualize the lead times to compare suppliers.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT suppliers.SupplierID, CompanyName, 
AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, CompanyName;
""""""

# Execute SQL query and get the data
data = execute_sql_query(sql_query)

# Create a bar plot of average lead time per supplier
fig = px.bar(data, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.CompanyName
""""""

lead_time_df = execute_sql_query(sql_query)
fig = px.bar(lead_time_df, x='CompanyName', y='AvgLeadTime', title='Average Lead Time by Supplier', labels={'AvgLeadTime': 'Average Lead Time (Days)'})
show_to_user(fig)
```","The input code correctly calculates the average lead time for each supplier using a SQL query, similar to the reference code. Both implementations use a JOIN operation to link tables and group by supplier, aggregating the lead time correctly. The visualization step using Plotly Express is also consistent, displaying a bar chart of average lead times, fulfilling the business request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM orders 
JOIN products ON orders.ProductID = products.ProductID 
WHERE orders.ShippedDate IS NOT NULL 
GROUP BY products.SupplierID;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Visualize the average lead time for each supplier
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show visualization
show_to_user(fig)
```","The input Python code does not match the logic of the reference implementation. Specifically, the input code does not join the 'Order Details' table, which is essential to relate orders with products. It also lacks the inclusion of the 'suppliers' table to get 'CompanyName', resulting in missing supplier information in the output. These differences lead to a mismatch in data aggregation logic and supplier identification.",Base
What is the average discount given in orders for the year 2023?,"```python
sql_query = """"""
SELECT AVG([Order Details].Discount) AS avg_discount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute SQL query to get the average discount
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT AVG([Order Details].Discount) AS average_discount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

avg_discount_df = execute_sql_query(sql_query)
show_to_user(avg_discount_df)
```","The provided Python code correctly executes a SQL query to compute the average discount for orders in the year 2023, just like the reference code. Both implementations construct the same SQL query with the correct logic to average the discount from 'Order Details' joined with 'orders', filtered by the date range for 2023. The execution and display logic using `execute_sql_query` and `show_to_user` is also consistent.","To calculate the average discount given in orders for the year 2023 using Python, we need to execute a SQL query that retrieves the average discount from the `OrderDetails` table. Here is the Python code to perform this task:

```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(Discount) AS AvgDiscount 
FROM OrderDetails 
JOIN orders ON OrderDetails.OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31';
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df[['AvgDiscount']])
```

### Explanation:
1. **SQL Query**: The SQL query calculates the average discount from the `OrderDetails` table and filters the results to include only those orders that fall within the year 2023, using the `orders` table to reference the `OrderDate`.
2. **Data Retrieval**: The `execute_sql_query` function is called with the SQL query to get the data in a pandas DataFrame.
3. **Result Display**: The result is displayed to the user, specifically selecting the `AvgDiscount` column from the DataFrame.

Make sure that both `execute_sql_query` and `show_to_user` functions are defined in your environment and behave as expected.","The input Python code correctly calculates the average discount for orders in 2023, matching the reference implementation logic. It uses a similar SQL query to join `OrderDetails` and `orders`, filters by the date range '2023-01-01' to '2023-12-31', and calculates the average discount. The use of `execute_sql_query` and `show_to_user` is consistent with the expected data retrieval and display steps. The difference in column naming (`AvgDiscount`) does not affect the correctness regarding the task's requirements.",both
What is the average order fulfillment time by month? Visualize the monthly fulfillment times.,"```python
import plotly.express as px

# SQL query to fetch required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgOrderFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'Month' to string to ensure proper sorting by month
df['Month'] = df['Month'].astype(str)

# Create line plot using Plotly
fig = px.line(df, x='Month', y='AvgOrderFulfillmentTime', title='Average Order Fulfillment Time by Month')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='OrderMonth', y='AvgFulfillmentTime', 
              title='Average Order Fulfillment Time by Month', 
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)', 'OrderMonth': 'Month'})
show_to_user(fig)
```","The input code correctly answers the business analytics request by calculating the average order fulfillment time via SQL and visualizes it with a line plot. It adheres to the same logic as the reference code, using an SQL query to compute the average of the date differences between 'ShippedDate' and 'OrderDate', grouped by month. The visualization tool, Plotly, is used similarly in both codes to display the results. The code differs mainly in column naming and explicit labels in the plot but achieves the same outcome.","```python
import plotly.express as px

# SQL query to get the average fulfillment time by month
sql_query = """"""
SELECT strftime('%Y-%m', OrderDate) AS Month, 
COUNT(DISTINCT OrderID) AS TotalOrders, 
SUM(julianday(ShippedDate) - julianday(OrderDate)) / COUNT(DISTINCT OrderID) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a line plot of the average fulfillment time by month
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Month', labels={'AvgFulfillmentTime': 'Avg Fulfillment Time (Days)'})

# Show the plot
show_to_user(fig)
```","Both the reference and the input Python code aim to solve the same business question: calculating the average order fulfillment time by month and visualizing it. The input code uses the `strftime` function for SQLite as opposed to `DATE_FORMAT` in the reference SQL, which is likely for MySQL. This is acceptable if the database backend differs. The input code also adds a step to calculate the sum and count for average fulfillment time, which aligns with the overall logic of getting the average, similar to the reference code's use of `AVG`. The visualization logic is consistent, using Plotly for a line plot. Thus, the input code effectively meets the request using alternative, yet correct, approaches.",both
What is the total revenue generated by each employee? Visualize employee contribution to revenue.,"```python
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY EmployeeID;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using plotly to visualize employee contribution to revenue
fig = px.bar(df, x='EmployeeID', y='TotalRevenue', title='Employee Contribution to Revenue')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.EmployeeID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.EmployeeID
""""""

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Create a bar plot to visualize the employee contribution to revenue
fig = px.bar(revenue_data, x='EmployeeID', y='TotalRevenue', 
             title='Total Revenue Generated by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalRevenue': 'Total Revenue'})

show_to_user(fig)
```","The input code provides the total revenue generated by each employee by executing an SQL query that calculates the sum of product of unit price, quantity, and (1 - discount) for each employee. It groups the results by EmployeeID, which matches the logic in the reference code. The visualization uses Plotly Express to create a bar chart, similar to the reference implementation. The differences, such as variable names or label customization, do not affect the correctness of the code with regard to the request.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Execute the query to get data
df = execute_sql_query(sql_query)

# Visualize the employee contribution to revenue
fig = px.bar(df, x='EmployeeID', y='TotalRevenue', title='Total Revenue by Employee')

# Show the visualization
show_to_user(fig)
```","The input Python code calculates the total revenue generated by each employee and visualizes it, adhering to the same logic as the reference code. It executes a SQL query with appropriate JOINs and GROUP BY operations to compute the total revenue, which is then visualized using a bar chart with Plotly. The minor differences in SQL from aliases and specific JOIN syntax do not affect the correctness of the output, which remains consistent with the business analytics request.",both
Find the total freight cost incurred in the year 2023.,"```python
import pandas as pd

# Execute the SQL query to get the data
result_df = execute_sql_query(""SELECT SUM(Freight) AS TotalFreightCost2023 FROM orders WHERE YEAR(OrderDate) = 2023;"")

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE YEAR(OrderDate) = 2023
""""""

total_freight_cost_df = execute_sql_query(sql_query)
show_to_user(total_freight_cost_df)
```","The input Python code correctly executes an SQL query to calculate the total freight cost for the orders in the year 2023. The logic and query structure are the same as the reference implementation, ensuring the business analytics request is fulfilled.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT SUM(Freight) AS TotalFreightCost FROM orders WHERE YEAR(OrderDate) = 2023;""

# Execute the SQL query to get the data
data_df = execute_sql_query(sql_query)

# Display the sum of Freight directly, since the result should be a single value
total_freight_cost = data_df['TotalFreightCost'].iloc[0]
show_to_user(pd.DataFrame({'TotalFreightCost': [total_freight_cost]}))
```","Both implementations perform the same task: calculating the total freight cost for the year 2023. The input code uses a similar SQL query and the logic to extract and display the result matches the reference code. Therefore, the solution is correct.",both
Identify which month has the highest number of orders historically. Visualize the order count by month.,"```python
import plotly.express as px

# SQL query to get order counts by month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Visualize order count by month
fig = px.bar(order_data, x='Month', y='OrderCount', title='Order Count by Month')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get order count by month
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') as OrderMonth, 
    COUNT(OrderID) as OrderCount
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Identify the month with the highest number of orders
highest_month = order_data.loc[order_data['OrderCount'].idxmax()]

# Create a bar plot for order count by month
fig = px.bar(order_data, x='OrderMonth', y='OrderCount', title='Order Count by Month')
show_to_user(fig)
```","The input Python code correctly adheres to the business analytics request. It employs the same logic as the reference implementation to query order counts by month from the database, using the SQL statement with DATE_FORMAT and COUNT. It then executes this query using a hypothetical function `execute_sql_query`. The code further identifies the month with the highest order count using `idxmax()`, which isn't explicitly required but provides additional useful information without deviating from the core request. Finally, it creates and displays a bar plot of order counts by month using Plotly, exactly as in the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get order counts by month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Find the month with the highest number of orders
top_month = df.loc[df['OrderCount'].idxmax(), 'Month']

# Log the month with the highest order count
print(""Month with highest number of orders:"", top_month)

# Visualize the order count by month
fig = px.bar(df, x='Month', y='OrderCount', title='Order Count by Month')
show_to_user(fig)
```","The provided code effectively implements the same logic as the reference code. It retrieves order counts grouped by month and creates a bar chart to visualize the order count by month. Additionally, it identifies the month with the highest number of orders, which is a useful analytical insight. The only differences lie in minor details such as alias naming in the SQL query and adding an 'ORDER BY' clause, which does not affect the correctness of the business requirement.",both
Calculate the average number of products per order.,"```python
import pandas as pd

# Define the SQL query to calculate the average number of products per order
sql_query = ""SELECT AVG(od.Quantity) AS AverageProductsPerOrder FROM [Order Details] od;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Correctly extract the average products per order from the result dataframe
average_products_per_order = result_df['AverageProductsPerOrder'][0]

# Display the result
show_to_user(pd.DataFrame({'Average Products Per Order': [average_products_per_order]}))
```","```python
sql_query = """"""
SELECT AVG(product_count) AS average_products_per_order
FROM (
    SELECT o.OrderID, COUNT(od.ProductID) AS product_count
    FROM orders o
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    GROUP BY o.OrderID
) AS order_summary
""""""
average_products_df = execute_sql_query(sql_query)
show_to_user(average_products_df)
```","Both the reference and the input code calculate the average number of products per order, but the input code approaches it by first counting products per order. The input code groups by OrderID to count products within each order, then calculates the average of these counts. The reference code calculates the average directly from quantities in Order Details. Both methods arrive at the same metric through equivalent logic, thus the input code is correct.","```python
import pandas as pd

# SQL query to get the Count of Products per Order
sql_query = """"""
SELECT COUNT(OrderDetails.ProductID) as ProductCount 
FROM [Order Details] AS OrderDetails 
GROUP BY OrderDetails.OrderID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the average number of products per order
average_products_per_order = df['ProductCount'].mean()

# Prepare the result to show
result_df = pd.DataFrame({'AverageProductsPerOrder': [average_products_per_order]})

# Show the result to the user
show_to_user(result_df)
```","Both the reference and input code calculate the average number of products per order, but using different approaches. The input code first retrieves the count of products for each order, then computes the mean of these counts, which is equivalent to the average calculated in the reference code. Therefore, the input code adheres to the intended logic and correctly answers the business analytics request.",both
Which product has the highest total sales in 2022?,"```python
import pandas as pd

# SQL Query to retrieve the product with the highest total sales in 2022
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID 
ORDER BY total_sales DESC 
LIMIT 1
""""""

# Execute the SQL query and retrieve the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, products.ProductName 
ORDER BY total_sales DESC 
LIMIT 1;
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code retrieves the product with the highest total sales in 2022, similar to the reference code. Both implementations calculate total sales in the same way and restrict results to the year 2022. The input code includes an additional field 'ProductName' in the SELECT clause and GROUP BY statement, which doesn't affect the correctness related to identifying the product with the highest sales. Therefore, the logic aligns with the reference implementation.","```python
import pandas as pd

# SQL query to get the product with the highest total sales in 2022
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE YEAR(o.OrderDate) = 2022 
GROUP BY p.ProductName 
ORDER BY TotalSales DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","Both the reference and input implementations aim to identify the product with the highest total sales in 2022. The input code accurately calculates the total sales per product by using the same logic - multiplying 'UnitPrice', 'Quantity', and the discount factor. Both implementations correctly filter for orders in 2022. The key difference is that the reference uses 'ProductID', while the input uses 'ProductName'. Assuming the uniqueness of 'ProductName', the business logic is sufficiently similar to achieve the same goal, thus the input is valid.",both
How many orders were placed in each quarter of 2022? Visualize the quarterly order distribution.,"```python
import plotly.express as px

# SQL query to get the number of orders per quarter for 2022
sql_query = """"""
SELECT QUARTER(orders.OrderDate) AS order_quarter, COUNT(orders.OrderID) AS total_orders
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY order_quarter
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the dataframe by order_quarter to ensure the correct order in visualization
df = df.sort_values(by='order_quarter')

# Create a bar chart to visualize the quarterly order distribution
fig = px.bar(df, x='order_quarter', y='total_orders', title='Quarterly Orders Distribution in 2022',
             labels={'order_quarter': 'Quarter', 'total_orders': 'Total Orders'})

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    QUARTER(OrderDate) AS quarter, 
    COUNT(OrderID) AS order_count 
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY 
    QUARTER(OrderDate)
ORDER BY 
    quarter;
""""""

order_data = execute_sql_query(sql_query)

fig = px.bar(order_data, x='quarter', y='order_count', 
             labels={'quarter': 'Quarter', 'order_count': 'Number of Orders'},
             title='Quarterly Order Distribution in 2022')
show_to_user(fig)
```","Both the input Python code and the reference implementation perform the same operations to achieve the desired business analytics request. They execute a SQL query that aggregates the number of orders per quarter in 2022, group the results by quarter, and use Plotly Express to create a bar chart for visualization. The input code includes sorting in the SQL query itself, maintaining the output order. Thus, the provided code is correct as it adheres to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve order data
sql_query = """"""
SELECT COUNT(OrderID) as OrderCounts, QUARTER(OrderDate) as Quarter 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY Quarter;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Verify the dataframe columns
orders_df.columns = ['OrderCounts', 'Quarter']

# Visualize the quarterly order distribution
fig = px.bar(orders_df, x='Quarter', y='OrderCounts', title='Quarterly Order Distribution for 2022')

# Display the visualization
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. Both codes execute a SQL query to count the number of orders placed in each quarter of 2022. The query groups by quarter and counts the orders, which matches the reference logic. The resulting data is visualized using a bar chart with Plotly Express, displaying the quarters on the x-axis and the count of orders on the y-axis. The column names in the dataframe and the chart parameters are appropriately set, and the final visualization is shown to the user. Therefore, the input code is correct.",both
How many unique customers placed orders in the last quarter?,"```python
import pandas as pd

# Define the SQL query to get unique customer IDs
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders
WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE());
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Count the unique customers
unique_customers_count = len(result_df['CustomerID'].unique())

# Display the result to the user
show_to_user(pd.DataFrame({'unique_customers': [unique_customers_count]}))
```","```python
import pandas as pd

# Define the last quarter date range
end_date = pd.Timestamp.now()
start_date = end_date - pd.DateOffset(months=3)

# SQL query to count unique customers who placed orders in the last quarter
sql_query = f""""""
SELECT COUNT(DISTINCT CustomerID) as unique_customers
FROM orders
WHERE OrderDate BETWEEN '{start_date.strftime(""%Y-%m-%d"")}' AND '{end_date.strftime(""%Y-%m-%d"")}'
""""""

# Execute SQL query and get the result
unique_customers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(unique_customers_df)
```","The input code uses a date range in the WHERE clause that includes the current day by using BETWEEN with the end_date set to the current day (pd.Timestamp.now()). This differs from the reference implementation, which uses the SQL function GETDATE() to get current date and filters orders from three months ago to the present without including the current day's exact time. The logic may differ slightly if the current day should be excluded.","```python
import pandas as pd

# SQL Query to get unique customers who placed orders in the last quarter.
sql_query = """"""
SELECT CustomerID 
FROM orders 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH);
""""""

# Execute the query
orders_df = execute_sql_query(sql_query)

# Get the unique customers
unique_customers_count = len(orders_df['CustomerID'].unique())

# Prepare the result in a DataFrame for display
result_df = pd.DataFrame({'unique_customers': [unique_customers_count]})

# Display the result
show_to_user(result_df)
```","The input Python code correctly solves the problem by querying for unique CustomerIDs from the orders table where the OrderDate is within the last three months. The difference in date functions between DATEADD and DATE_SUB is due to different SQL dialects (GETDATE and CURDATE), but both achieve the same logic: filtering orders from the last quarter. The use of 'unique()' to count distinct CustomerIDs is identical in functionality. The logic and steps are consistent with the reference implementation.",Finetuned
What are the top three products that generate the most sales revenue? Visualize their sales revenue for comparison.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the query to get data
data = execute_sql_query(sql_query)

# Ensure the dataframe has columns in the correct case
data.columns = ['ProductID', 'TotalRevenue']

# Create a bar chart for visualization
fig = px.bar(data, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY Revenue DESC
LIMIT 3;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='Revenue', title='Top 3 Products by Sales Revenue', labels={'ProductID': 'Product ID', 'Revenue': 'Sales Revenue'})
show_to_user(fig)
```","The provided code correctly retrieves the top three products by sales revenue using a SQL query similar to the reference. The JOIN with the orders table doesn't affect the outcome as it's not part of the revenue computation, which is otherwise aligned. The visualization uses Plotly to create a bar chart, and appropriate labels are added, matching the request's intent.","```python
import plotly.express as px

# SQL query to get the top three products by sales revenue
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
INNER JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales revenue of the top three products
fig = px.bar(sales_data, x='ProductName', y='TotalRevenue', title='Top 3 Products by Sales Revenue')

# Show the visualization to the user
show_to_user(fig)
```","The input code retrieves and visualizes the top three products by sales revenue, similar to the reference code. It joins the products table to fetch product names, which is an enhancement for clearer visualization. The logic of calculating total revenue and using a bar chart for visualization remains consistent with the reference code.",both
What are the names of products that have been discontinued?,"```python
import pandas as pd

# SQL Query to get discontinued products
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query to retrieve the dataframe
discontinued_products_df = execute_sql_query(sql_query)

# Display the names of products that have been discontinued
show_to_user(discontinued_products_df['ProductName'])
```","```python
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE Discontinued = 1;
""""""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input Python code correctly constructs an SQL query to select product names from the 'products' table where the 'Discontinued' column is equal to 1. It then executes the query and uses the same function 'show_to_user' to display the results. The logic and end result align with the reference implementation, fulfilling the business analytics request.","```python
import pandas as pd

# SQL query to fetch names of discontinued products
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discontinued_products_df)
```","The input code displays the entire DataFrame to the user instead of just the 'ProductName' column, which is inconsistent with the reference implementation. The reference code explicitly selects the 'ProductName' column for display.",Base
Which supplier has supplied the most quantity of products?,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT SupplierID, SUM(UnitsOnOrder) AS TotalQuantitySupplied 
FROM products 
GROUP BY SupplierID 
ORDER BY TotalQuantitySupplied DESC 
LIMIT 1;
""""""

# Execute SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Correctly display just the SupplierID
max_supplier_id = result_df['SupplierID'].iloc[0]

# Display the SupplierID to the user
show_to_user(max_supplier_id)
```","```python
sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The provided code joins the 'products' table with the 'Order Details' table and calculates the total quantity based on 'Quantity' from the 'Order Details' table. However, the reference code sums 'UnitsOnOrder' from the 'products' table itself. This difference in the data column used for aggregation changes the business logic of determining the supplier with the most supplied quantity.","```python
import pandas as pd

# SQL query to get supplier data based on quantity
sql_query = """"""
SELECT suppliers.CompanyName, SUM([Order Details].Quantity) AS TotalQuantitySupplied
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY TotalQuantitySupplied DESC;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Display the supplier with the most quantity of products supplied
top_supplier = df.iloc[0:1].reset_index(drop=True)
show_to_user(top_supplier)
```","The input code retrieves supplier data by joining multiple tables and considers the `Quantity` from `[Order Details]`, whereas the reference code uses `UnitsOnOrder` from the `products` table. This indicates a logical difference, focusing on different data sources for calculating the `TotalQuantitySupplied`. Also, the input code displays both the supplier company name and the quantity, while the reference shows only the `SupplierID`.",None
Determine the average discount given by each employee.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, 
       e.FirstName, 
       e.LastName, 
       AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code calculates the same average discount per employee as the reference implementation. It includes additional columns (FirstName and LastName) in the SELECT and GROUP BY clauses, which does not alter the calculated average discounts. Both implementations correctly join the tables and group by EmployeeID to compute the average discount, so the logic aligns with the business analytics request.","```python
import pandas as pd

# SQL query to get average discount by employee
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG([Order Details].Discount) AS AverageDiscount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Display the resulting DataFrame to the user
show_to_user(df)
```","The input Python code correctly queries the average discount given by each employee. It uses the same logic and structure as the reference implementation, joining the 'employees', 'orders', and '[Order Details]' tables. The SQL query aggregates the discounts by employee, just as the reference code does. Although there are minor differences in the alias naming, the core logic remains aligned with the business analytics request.",both
Which month had the highest number of orders placed? Provide a visualization to compare monthly order volumes.,"```python
import plotly.express as px

# Query to get monthly order counts
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
ORDER BY Month
""""""

# Execute the SQL query
monthly_order_data = execute_sql_query(sql_query)

# Find the month with the highest number of orders
highest_order_month = monthly_order_data.loc[monthly_order_data['OrderCount'].idxmax()]

# Visualize monthly order volumes
fig = px.bar(monthly_order_data, x='Month', y='OrderCount', 
             title=f""Monthly Order Volumes (Highest: {highest_order_month['Month']})"", 
             labels={'OrderCount': 'Number of Orders'})

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY Month
""""""

monthly_orders = execute_sql_query(sql_query)

highest_month = monthly_orders.loc[monthly_orders['OrderCount'].idxmax()]

fig = px.bar(monthly_orders, x='Month', y='OrderCount', title='Monthly Order Volumes', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})
show_to_user(fig)
```","The input code follows the same logic as the reference code. It correctly executes the SQL query to group and count orders by month, finds the month with the highest number of orders, and creates a bar chart to visualize the monthly order volumes. Although the chart title slightly differs, the core functionality and objective of identifying the month with the highest orders and visualizing the data are accomplished correctly.","```python
import plotly.express as px

# SQL query to get monthly order data
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
    COUNT(OrderID) AS MonthlyOrderCount 
FROM 
    orders 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m') 
ORDER BY 
    MonthlyOrderCount DESC;
""""""

# Execute the query and store the result in a DataFrame
order_data = execute_sql_query(sql_query)

# Create a line chart for monthly order volumes
fig = px.line(order_data, x='OrderMonth', y='MonthlyOrderCount', title='Monthly Order Volumes')

# Show the visualization to the user
show_to_user(fig)

# Find the month with the highest number of orders
max_orders_month = order_data.iloc[0]

# Display the month with the highest number of orders
show_to_user(max_orders_month)
```","The main issue with the input code is the difference in how it orders the data. It sorts the results by 'MonthlyOrderCount' in descending order, while the reference code sorts by 'Month'. This does not follow the same logic if the goal is to visualize and check the trend over time, which requires chronological order. Additionally, although the month with the highest order count is correctly identified as the first entry in the input code, the result is printed without being integrated into the visualization title, missing a key detail from the reference code.",Base
Retrieve the contact information for all suppliers located in a specific region.,"```python
import pandas as pd

# Define the specific region
specified_region = 'specified_region'

# Create the SQL query
sql_query = f""""""
SELECT SupplierID, CompanyName, ContactName, Phone, City, Region
FROM suppliers
WHERE Region = '{specified_region}';
""""""

# Execute the SQL query and retrieve the data
suppliers_df = execute_sql_query(sql_query)

# Display the retrieved data
show_to_user(suppliers_df)
```","```python
region = 'specific_region'  # Replace with the desired region

sql_query = f""""""
SELECT 
    SupplierID, 
    CompanyName, 
    ContactName, 
    ContactTitle, 
    Address, 
    City, 
    Region, 
    PostalCode, 
    Country, 
    Phone, 
    Fax, 
    HomePage 
FROM 
    suppliers 
WHERE 
    Region = '{region}'
""""""

supplier_contacts = execute_sql_query(sql_query)
show_to_user(supplier_contacts)
```","The input code successfully retrieves contact information for suppliers in the specified region, similar to the reference code, but with additional fields. It meets the business requirement by fetching the required 'SupplierID', 'CompanyName', 'ContactName', 'Phone', 'City', and 'Region', and does not violate the logic of the reference implementation.","```python
import pandas as pd

# Define the SQL query to retrieve supplier contact information from a specific region, e.g., 'East Coast'
region = 'East Coast'
sql_query = f""SELECT CompanyName, ContactName, Email, Phone FROM suppliers WHERE Region = '{region}';""

# Execute the SQL query
suppliers_df = execute_sql_query(sql_query)

# Display the data frame to the user
show_to_user(suppliers_df)
```","The input code is not correct because it does not retrieve the SupplierID and includes 'Email', which is not requested. It uses a hardcoded region 'East Coast', which differs from the parameterized approach in the reference code.",Base
Calculate the discount amount for each order in January 2023.,"```python
import pandas as pd

# SQL query to fetch the required data
sql_query = """"""
SELECT o.OrderID, SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY o.OrderID;
""""""

# Execute the SQL query to get the results in a dataframe
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    od.OrderID,
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
GROUP BY 
    od.OrderID
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly calculates the discount amount for each order in January 2023. The logic in the query accurately matches the reference implementation. It selects the necessary fields, groups by OrderID, and calculates the discount amount using the SUM aggregator. The date range is also correctly defined to include all orders in January 2023. The difference in the GROUP BY clause is only cosmetic, as od.OrderID and o.OrderID refer to the same field due to the JOIN operation on OrderID.","```python
import pandas as pd

# Execute SQL Query to get orders in January 2023
sql_query = """"""
SELECT o.OrderID, od.UnitPrice, od.Quantity, od.Discount 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';
""""""
orders_df = execute_sql_query(sql_query)

# Calculate DiscountAmount for each order
orders_df['DiscountAmount'] = orders_df['UnitPrice'] * orders_df['Quantity'] * orders_df['Discount']

# Group by OrderID to sum up DiscountAmount for each order
discounts_df = orders_df.groupby('OrderID').agg(DiscountAmount=('DiscountAmount', 'sum')).reset_index()

# Display the result to the user
show_to_user(discounts_df)
```","The input Python code correctly calculates the discount amount for each order in January 2023, adhering to the same logic as the reference implementation. Both implementations perform a database query to fetch data with conditions on the OrderDate. The input implementation then accurately computes the discount per order detail and aggregates these using a group by operation on OrderID to get the total discount amount per order, which aligns with the reference implementation.",both
What are the total sales by month? Use a line or bar chart to illustrate monthly sales trends.,"```python
import plotly.express as px

# SQL query to get the total sales by month
sql_query = """"""
SELECT 
    YEAR(o.OrderDate) AS Year, 
    MONTH(o.OrderDate) AS Month, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM 
    orders o 
INNER JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
GROUP BY 
    YEAR(o.OrderDate), 
    MONTH(o.OrderDate) 
ORDER BY 
    Year, 
    Month;
""""""

# Execute the query and get the dataframe
sales_data = execute_sql_query(sql_query)

# Ensure we use the 'Year' and 'Month' columns combined for correct x-axis
sales_data['YearMonth'] = sales_data['Year'].astype(str) + '-' + sales_data['Month'].astype(str).str.zfill(2)

# Create a line chart to illustrate monthly sales trends
fig = px.line(sales_data, x='YearMonth', y='TotalSales', title='Monthly Sales Trends', labels={'YearMonth': 'Month', 'TotalSales': 'Total Sales'}, markers=True)

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY Month
ORDER BY Month
""""""

monthly_sales = execute_sql_query(sql_query)
fig = px.line(monthly_sales, x='Month', y='TotalSales', title='Total Sales by Month')
show_to_user(fig)
```","The input code successfully computes the total sales by month and generates a line chart to show the trends, adhering to the logical approach of the reference implementation. It combines 'Year' and 'Month' into a single 'Month' string using SQL's DATE_FORMAT function, similar to how the reference code combines them later in Python. The SQL query in both implementations aggregates sales data and the final visualization effectively demonstrates the monthly sales trends.","```python
import plotly.express as px

# SQL query to get total sales by month
sql_query = """"""
SELECT 
    TO_CHAR(orders.OrderDate, 'YYYY-MM') AS Month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY TO_CHAR(orders.OrderDate, 'YYYY-MM')
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a line chart with Plotly
fig = px.line(df, x='Month', y='TotalSales', title='Monthly Sales Trends', labels={'TotalSales': 'Total Sales', 'Month': 'Month'})

# Show the plot
show_to_user(fig)
```","The input code correctly calculates the total sales by month using the SQL function TO_CHAR to format the dates as 'YYYY-MM', which directly gives the monthly sales trend. This format function achieves the same purpose as the reference implementation's separate handling of year and month. Both implementations group by month and compute the total sales similarly. The use of a line chart to display monthly sales trends is consistent with the reference implementation, satisfying the business analytics request.",both
Which category has the highest number of products?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS NumberOfProducts 
FROM products 
GROUP BY CategoryID 
ORDER BY NumberOfProducts DESC 
LIMIT 1;
""""""

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT CategoryID, COUNT(ProductID) as ProductCount
FROM products
GROUP BY CategoryID
ORDER BY ProductCount DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code is logically equivalent to the reference implementation. Both codes count the number of products per category, order the categories by this count in descending order, and return the top result. Despite minor differences in naming conventions for aliasing, the input code correctly addresses the business analytics request.","```python
import pandas as pd

# SQL query to get the category with the highest number of products
sql_query = """"""
SELECT products.Category, COUNT(products.ProductName) AS TotalProducts 
FROM products 
GROUP BY products.Category 
ORDER BY TotalProducts DESC 
LIMIT 1;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","Both the input and reference implementations aim to determine the category with the highest number of products. The input code correctly uses the COUNT function to tally 'ProductName' for each 'Category', groups by 'Category', orders by 'TotalProducts' in descending order, and limits the result to 1. These operations align with the reference code, which groups by 'CategoryID' and seeks to find the maximum 'NumberOfProducts'. The difference in column names ('CategoryID' vs. 'Category' and 'ProductID' vs. 'ProductName') is semantic and likely related to table schema differences, but the logic and intent remain consistent.",both
Which products received the highest total discount? Present this data with a bar chart for better comparison.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Discount) AS TotalDiscount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalDiscount DESC;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Correct column names for Plotly
df.columns = ['ProductName', 'TotalDiscount']

# Create a bar chart
fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Products with the Highest Total Discount')

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalDiscount DESC
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductName', y='TotalDiscount', title='Total Discounts by Product')
show_to_user(fig)
```","The provided input code calculates the total discount by multiplying the discount by the quantity (`SUM(od.Discount * od.Quantity)`), whereas the reference implementation calculates the total discount without considering the quantity (`SUM([Order Details].Discount)`). This results in different totals, as the input code factors in the quantity sold for each discount, which is not consistent with the reference logic.","```python
import plotly.express as px

# SQL query to get products with the highest total discount
sql_query = """"""
SELECT ProductID, SUM(Discount * Quantity * UnitPrice) AS TotalDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalDiscount DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalDiscount', title='Total Discounts by Product')

# Display the bar chart to the user
show_to_user(fig)
```","The provided code calculates total discount as `SUM(Discount * Quantity * UnitPrice)` instead of `SUM(Discount)`. The reference code sums only the discount, while the provided code multiplies it by quantity and unit price, leading to different results.",None
Which regions have the highest average order value? Use a bar chart to compare average order values across regions.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipRegion, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * 
       (1 - [Order Details].Discount)) AS AverageOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipRegion 
ORDER BY AverageOrderValue DESC
""""""

# Execute SQL query to get the data
data = execute_sql_query(sql_query)

# Create a bar chart to compare average order values across regions
fig = px.bar(data, x='ShipRegion', y='AverageOrderValue', 
             title='Average Order Value by Region',
             labels={'ShipRegion': 'Region', 'AverageOrderValue': 'Average Order Value'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.ShipRegion, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.ShipRegion
ORDER BY AverageOrderValue DESC
""""""

average_order_value_df = execute_sql_query(sql_query)

fig = px.bar(average_order_value_df, 
             x='ShipRegion', 
             y='AverageOrderValue', 
             title='Average Order Value by Region', 
             labels={'AverageOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})
show_to_user(fig)
```","The provided Python code uses a different logic to calculate the average order value. In the reference implementation, the average is based on line items, calculating the average value per region directly from the sums of line item values, whereas the input code calculates average order value by summing up order values for each region and dividing by the count of distinct orders, which might give different results if there are varying numbers of line items per order. This discrepancy causes the logic to differ from the reference implementation.","```python
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT region.RegionDescription, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
JOIN region ON customers.Region = region.RegionID 
GROUP BY region.RegionDescription
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to compare average order values across regions
fig = px.bar(df, x='RegionDescription', y='avg_order_value', title='Average Order Value by Region')

# Show the bar chart to the user
show_to_user(fig)
```","The input code is not correct because it uses a different table 'region' to determine regions, joining it via 'customers.Region', while the reference code uses 'ShipRegion' from the 'orders' table. Thus, the logic for determining regions is not consistent with the reference implementation.",None
Identify the top 3 customers by revenue in the last quarter. Include a bar chart to visualize customer revenue comparison.,"```python
import plotly.express as px

# Execute the SQL query using the provided utility function
sql_query = """"""
SELECT customers.CustomerID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as Revenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate > DATE_SUB(NOW(), INTERVAL 3 MONTH) 
GROUP BY customers.CustomerID 
ORDER BY Revenue DESC 
LIMIT 3;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart to visualize customer revenue comparison
fig = px.bar(df, x='CustomerID', y='Revenue', title='Top 3 Customers by Revenue in the Last Quarter')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

last_quarter_start = '2023-07-01'
last_quarter_end = '2023-09-30'

sql_query = f""""""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate BETWEEN '{last_quarter_start}' AND '{last_quarter_end}'
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    TotalRevenue DESC
LIMIT 3;
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='TotalRevenue', title='Top 3 Customers by Revenue in Last Quarter')
show_to_user(fig)
```","The input Python code correctly queries the top 3 customers by revenue in the last quarter using the dates '2023-07-01' to '2023-09-30', ensuring the time frame aligns with the reference implementation's intention of the 'last 3 months'. The code aggregates the revenue correctly by joining orders and order details, sums the total revenue, sorts it in descending order, and limits the output to the top 3 customers. It includes a bar chart using plotly to visualize the results by 'CompanyName', a logical choice since it is included in the SELECT statement. Thus, the code meets the criteria of the business analytics request similarly to the reference code.","```python
import plotly.express as px

# SQL query to get top 3 customers by revenue in the last quarter
sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) 
AS TotalRevenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTHS) 
GROUP BY customers.CustomerID, customers.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query and fetch the data
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart for customer revenue comparison
fig = px.bar(top_customers_df, x='CompanyName', y='TotalRevenue', 
             title='Top 3 Customers by Revenue in the Last Quarter',
             labels={'TotalRevenue':'Revenue', 'CompanyName':'Customer'})

# Show the chart
show_to_user(fig)
```","The input code correctly implements the business analytics request by obtaining the top 3 customers by revenue in the last quarter. It uses a SQL query with similar logic as the reference code, including joining the necessary tables, calculating revenue, and ordering the results. The only difference is the inclusion of the 'CompanyName' in the output, which does not affect the correctness. Both implementations limit the results to the top 3 by revenue and use a bar chart to visualize the data. The use of 'CURDATE()' vs 'NOW()' in the date comparison is functionally similar in this context.",both
What percentage of orders were delivered before the required date in 2022?,"```python
import pandas as pd

# Execute the SQL query using the utility function
orders_df = execute_sql_query(""SELECT OrderDate, ShippedDate, RequiredDate FROM orders"")

# Filter orders for the year 2022
orders_2022 = orders_df[pd.to_datetime(orders_df['OrderDate']).dt.year == 2022]

# Calculate the number of orders delivered on or before the required date
delivered_on_time = orders_2022[orders_2022['ShippedDate'] <= orders_2022['RequiredDate']].shape[0]

# Calculate the percentage
before_required_date_rate = (delivered_on_time / orders_2022.shape[0]) * 100

# Create a DataFrame to display the result
result_df = pd.DataFrame({'BeforeRequiredDateRate': [before_required_date_rate]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(OrderID) AS total_orders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS delivered_early
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2022
""""""

result_df = execute_sql_query(sql_query)
percentage_early_delivery = (result_df['delivered_early'].iloc[0] / result_df['total_orders'].iloc[0]) * 100

show_to_user(pd.DataFrame({'Percentage Delivered Early': [percentage_early_delivery]}))
```","Both the reference and input implementations calculate the percentage of orders delivered on time in 2022. The input code achieves this using SQL to filter and count directly, while the reference uses pandas filtering. Both compute the percentage using the same logic: (delivered_on_time / total_orders) * 100. Despite differing in approach, the input code provides correct results following the required business logic.","```python
import pandas as pd

# Define the SQL queries
orders_query = """"""
SELECT OrderID, ShippedDate FROM orders WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""
on_time_orders_query = """"""
SELECT OrderID, ShippedDate FROM orders WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31' AND ShippedDate <= RequiredDate
""""""

# Execute SQL queries to get the data
orders_df = execute_sql_query(orders_query)
on_time_orders_df = execute_sql_query(on_time_orders_query)

# Calculate the number of on-time deliveries and total orders
on_time_deliveries = len(on_time_orders_df)
total_orders = len(orders_df)

# Calculate the percentage of on-time deliveries
on_time_delivery_rate = (on_time_deliveries / total_orders) * 100

# Create a DataFrame to display the result
result_df = pd.DataFrame({'on_time_delivery_rate': [on_time_delivery_rate]})

# Display the result to the user
show_to_user(result_df)
```","The input code correctly calculates the percentage of orders delivered before the required date in 2022. It filters orders within 2022 and counts those where the ShippedDate is less than or equal to the RequiredDate, similar to the reference implementation. The methodology of using SQL queries to gather the necessary data aligns with the reference logic of filtering and comparison.",both
Which supplier has the shortest average lead time in April 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY products.SupplierID
ORDER BY supplier_lead_time ASC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time
FROM orders
JOIN products ON orders.OrderID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY average_lead_time ASC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code contains a mistake in the JOIN operation. It joins orders with products using orders.OrderID = products.ProductID, but it should be joining [Order Details] with orders using [Order Details].OrderID = orders.OrderID, then joining with products using [Order Details].ProductID = products.ProductID, as in the reference code. This results in incorrect logic for calculating the average lead time per supplier.","```python
import pandas as pd

# SQL query from the business request
sql_query = """"""
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY products.SupplierID 
ORDER BY supplier_lead_time ASC 
LIMIT 1
""""""

# Execute the SQL query
supplier_lead_time_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(supplier_lead_time_df)
```","The input Python code correctly replicates the logic of the reference implementation. Both the input and reference codes execute the same SQL query to determine the supplier with the shortest average lead time in April 2023. The structure of the SQL query and the order of operations, such as joining tables and calculating the average lead time, are identical. The differences in variable names do not impact the correctness or the outcome of the query execution.",Finetuned
Who are the employees reporting to each manager?,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT m.EmployeeID AS ManagerID, 
       m.LastName AS ManagerLastName, 
       m.FirstName AS ManagerFirstName, 
       e.EmployeeID AS EmployeeID, 
       e.LastName AS EmployeeLastName, 
       e.FirstName AS EmployeeFirstName 
FROM employees e 
JOIN employees m ON e.ReportsTo = m.EmployeeID;
""""""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Display the results
show_to_user(df)
```","```python
sql_query = """"""
SELECT e1.FirstName AS EmployeeFirstName, e1.LastName AS EmployeeLastName, 
       e2.FirstName AS ManagerFirstName, e2.LastName AS ManagerLastName
FROM employees e1
LEFT JOIN employees e2 ON e1.ReportsTo = e2.EmployeeID
ORDER BY e2.LastName, e2.FirstName, e1.LastName, e1.FirstName;
""""""

employee_manager_df = execute_sql_query(sql_query)
show_to_user(employee_manager_df)
```","The input code uses a LEFT JOIN instead of an INNER JOIN, resulting in inclusion of employees without managers. This deviates from the reference code that uses a JOIN (which implies INNER JOIN), specifically focusing on employees who have managers.","```python
import pandas as pd

# SQL query to get employees reporting to each manager
sql_query = """"""
SELECT e1.ManagerID, e1.EmployeeID, e1.LastName, e1.FirstName 
FROM employees e1;
""""""

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(df)
```","The input code does not correctly filter and join tables to identify reports to managers. It selects ManagerID, EmployeeID, LastName, and FirstName from a single 'employees' table without performing the necessary join based on 'ReportsTo' field, unlike the reference code.",None
Find the average discount applied to orders in January 2023.,"```python
import pandas as pd

# SQL Query to find average discount
sql_query = """"""
SELECT AVG(od.Discount) AS AvgDiscount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG([Order Details].Discount) AS AverageDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
""""""

average_discount = execute_sql_query(sql_query)
show_to_user(average_discount)
```","The input Python code correctly calculates the average discount for orders in January 2023. It uses a SQL query that performs an inner join between 'orders' and 'Order Details' tables, and filters orders with dates between January 1, 2023, and before February 1, 2023. This range covers all of January 2023, matching the logic of the reference code. The SQL structure and logic adhere to the business analytics request.","```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT OrderDetails.Discount 
FROM orders 
JOIN OrderDetails ON orders.OrderID = OrderDetails.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = df['Discount'].mean()

# Display the result
show_to_user(pd.DataFrame({'Average Discount': [average_discount]}))
```","The input code correctly calculates the average discount by first selecting the discounts from the order details for orders in January 2023, then computes the average using pandas. This aligns with the reference implementation's logic using SQL to achieve the same outcome.",both
Calculate the total sales for employees located in a specific region.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = 'specific region'
GROUP BY e.EmployeeID;
""""""

# Execute the query and get the result as a dataframe
sales_data_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_data_df)
```","```python
region = ""Specific Region""  # Replace with the desired region
sql_query = f""""""
SELECT 
    e.EmployeeID, 
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    e.Region = '{region}'
GROUP BY 
    e.EmployeeID
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code calculates the total sales for employees in a specific region, adhering to the same logic as the reference implementation. The key difference is that the input code also retrieves the employee's full name by concatenating first and last names, but this does not affect the calculation of total sales. The SQL query structure in both codes is functionally equivalent, correctly grouping by EmployeeID and summing the sales figures.","```python
import pandas as pd

def calculate_sales_for_region(region):
    # Define the SQL query
    sql_query = """"""
    SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
    FROM employees e
    JOIN orders o ON e.EmployeeID = o.EmployeeID
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    WHERE e.Region = ?
    GROUP BY e.EmployeeID;
    """"""
    
    # Execute the SQL query with the region parameter
    df = execute_sql_query(sql_query, (region,))
    
    # Display the results to the user
    show_to_user(df)

# An example usage
calculate_sales_for_region(""North America"")
```",The input code correctly calculates the total sales for employees in a specified region by using a SQL query that sums up sales based on employee ID and filters by the given region. It adheres to the same logic as the reference implementation.,both
What are the names of all suppliers who are located in Germany?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""

# Execute the query
suppliers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(suppliers_df)
```","```python
sql_query = """"""
SELECT CompanyName 
FROM suppliers 
WHERE Country = 'Germany'
""""""
german_suppliers = execute_sql_query(sql_query)
show_to_user(german_suppliers)
```","The input Python code constructs and executes an SQL query to select the CompanyName from the suppliers table where the Country is Germany. This matches the logic and intent of the reference implementation, as it retrieves the same data by using the same SQL condition and then displays the result using a function presumed to be similar to 'show_to_user'. Therefore, the code fulfills the business analytics request correctly.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""

# Execute the SQL query to get the data
germany_suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(germany_suppliers_df)
```","The provided Python code correctly implements the business analytics request. It uses the same SQL query to select supplier names located in Germany, executes the query, and displays the result to the user. The variable name 'germany_suppliers_df' is different but does not affect the correctness of the logic.",both
What was the average order value in June 2023?,"```python
import pandas as pd

# SQL query to calculate average order value in June 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-06';
""""""

# Execute the query and retrieve the result in a dataframe
df = execute_sql_query(sql_query)

# Display the average order value to the user
show_to_user(df['AvgOrderValue'].iloc[0])
```","```python
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-06-01' AND o.OrderDate < '2023-07-01'
""""""

average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","The input Python code correctly calculates the average order value for June 2023 using a SQL query that sums the total value of orders (considering discounts) and divides by the number of distinct orders. The logic is the same as the reference code; both codes calculate the average by summing prices and dividing by the count of distinct orders. The date condition ('2023-06') is expressed differently but functionally equivalent, filtering orders within June 2023. Therefore, the input code is correct.","```python
import pandas as pd

# SQL query to calculate the average order value in June 2023
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-06';
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df['AverageOrderValue'].iloc[0])
```","The input Python code calculates the average order value for June 2023 correctly. It uses the same SQL logic as the reference implementation: summing the total price of the order (UnitPrice * Quantity * (1 - Discount)) and dividing by the count of distinct OrderIDs. The only difference is the alias name 'AverageOrderValue' instead of 'AvgOrderValue', which does not affect the correctness of the logic. The result is displayed similarly, ensuring consistency with the reference implementation.",both
Calculate the average freight cost for each customer. Use a bar chart to compare freight costs across customers.,"```python
import plotly.express as px

# Execute the SQL query to retrieve the data
sql_query = ""SELECT CustomerID, AVG(Freight) AS AvgFreight FROM orders GROUP BY CustomerID;""
df = execute_sql_query(sql_query)

# Create a bar chart to compare freight costs across customers
fig = px.bar(df, x='CustomerID', y='AvgFreight', title='Average Freight Cost per Customer', labels={'AvgFreight': 'Average Freight Cost', 'CustomerID': 'Customer ID'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, AVG(Freight) AS AverageFreight
FROM orders
GROUP BY CustomerID
""""""
df = execute_sql_query(sql_query)

fig = px.bar(df, x='CustomerID', y='AverageFreight', title='Average Freight Cost per Customer', labels={'AverageFreight': 'Average Freight Cost', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```",The provided code is correct because it follows the same logic as the reference implementation to calculate average freight per customer and visualize it using a bar chart. Both codes apply the same SQL logic to group by CustomerID and compute the average freight. They also create similar bar charts using Plotly. The difference in the alias name 'AvgFreight' in the reference and 'AverageFreight' in the evaluated code does not affect the correctness of the implementation.,"```python
import plotly.express as px

# SQL query to calculate the average freight cost for each customer
sql_query = ""SELECT CustomerID, AVG(Freight) AS AverageFreight FROM orders GROUP BY CustomerID;""

# Execute SQL query and retrieve the data as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to compare freight costs across customers
fig = px.bar(df, x='CustomerID', y='AverageFreight', title='Average Freight Cost per Customer')

# Display the bar chart to the user
show_to_user(fig)
```","Both the input code and reference implementation calculate the average freight cost per customer using a SQL query that groups by customer ID and uses AVG to compute the average freight. The only difference is the alias for the average, 'AverageFreight' vs. 'AvgFreight', which is a non-critical difference as both aliases refer to the same calculation and are used consistently in their respective plots. The logic and operations are the same in both codes.",both
How many orders were placed on weekends in the last three months? Present the data with a bar chart for each weekend.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders placed on weekends in the last three months
sql_query = """"""
SELECT DAY(OrderDate) AS Day, MONTH(OrderDate) AS Month, YEAR(OrderDate) AS Year, COUNT(OrderID) AS WeekendOrders 
FROM orders 
WHERE DAYOFWEEK(OrderDate) IN (1, 7) 
AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
GROUP BY Year, Month, Day
""""""

# Execute the SQL query and get the dataframe
df = execute_sql_query(sql_query)

# Combine the day, month, and year into a single date column
df['OrderDate'] = pd.to_datetime(df[['Year', 'Month', 'Day']])

# Create a bar chart with Plotly
fig = px.bar(df, x='OrderDate', y='WeekendOrders', title='Weekend Orders in the Last 3 Months')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last three months
end_date = datetime.now()
start_date = end_date - timedelta(days=90)

# SQL query to retrieve weekend order counts
sql_query = f""""""
SELECT 
    DATE(OrderDate) AS WeekendDate,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
WHERE 
    OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
    AND DAYOFWEEK(OrderDate) IN (1, 7)  -- 1 for Sunday, 7 for Saturday
GROUP BY 
    WeekendDate
ORDER BY 
    WeekendDate;
""""""

# Execute the SQL query and retrieve the data
weekend_orders = execute_sql_query(sql_query)

# Plotting the data
fig = px.bar(weekend_orders, x='WeekendDate', y='OrderCount', title='Weekend Orders in the Last 3 Months', labels={'OrderCount': 'Number of Orders', 'WeekendDate': 'Date'})
show_to_user(fig)
```","The input code correctly implements the required logic to count weekend orders in the past three months. It utilizes a SQL query to filter orders by weekend days (Sunday and Saturday) and within the specified date range calculated using a 90-day timedelta. The results are grouped by each distinct weekend date to provide a count for each day, similar to the reference code. Furthermore, the code generates a bar chart using Plotly to visualize these counts, adhering to the requirements. Therefore, the solution aligns with the business analytics request and follows the logic of the reference implementation correctly.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m-%d') AS OrderDate, COUNT(*) AS OrderCount 
FROM orders 
WHERE OrderDate >= NOW() - INTERVAL 3 MONTH 
AND WEEKDAY(OrderDate) IN (5, 6) 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m-%d');
""""""

# Execute the SQL query and get the data
data_df = execute_sql_query(sql_query)

# Create a bar chart for weekend orders
fig = px.bar(data_df, x='OrderDate', y='OrderCount', title='Weekend Orders in the Last Three Months')

# Show the plot to the user
show_to_user(fig)
```","The input Python code correctly implements the logic of counting weekend orders over the last three months and visualizing them. The primary difference from the reference code is the SQL query syntax for filtering weekend days and date computations, which is acceptable as both queries extract dates from the last three months and group by weekend days. The resulting bar chart displays the data correctly, fulfilling the business analytics request.",both
What is the total sales revenue generated in the year 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
total_sales = df['total_sales'].iloc[0]
show_to_user(total_sales)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""
total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input code displays the entire DataFrame using 'show_to_user(total_sales_df)', whereas the reference code extracts the total sales value with 'total_sales = df['total_sales'].iloc[0]' before displaying it. The input code does not adhere to the same logic as the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# If the dataframe is not empty, extract the total revenue
if not df_result.empty:
    total_revenue = df_result.iloc[0]['TotalRevenue']
else:
    total_revenue = 0

# Show the result to the user
show_to_user(pd.DataFrame({'TotalRevenue': [total_revenue]}))
```","The provided code correctly implements the logic of the reference code. Both codes execute an SQL query to calculate the total sales revenue for the year 2023 by summing the product of UnitPrice, Quantity, and (1 - Discount) from the [Order Details] table joined with the orders table, filtered by the order date range of 2023. The provided code differs from the reference only in how the result is handled: checking for an empty DataFrame and formatting the output using a DataFrame before displaying it. These differences do not affect the overall result or logic required to meet the business analytics request.",Finetuned
How many products have been ordered but not yet shipped?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT COUNT(orders.OrderID) AS Products_Not_Shipped FROM orders WHERE orders.ShippedDate IS NULL;""

# Execute the query
df_orders_not_shipped = execute_sql_query(sql_query)

# Prepare result to show
result_df = pd.DataFrame({'Products_Not_Shipped': [df_orders_not_shipped['Products_Not_Shipped'].iloc[0]]})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS ProductsOnOrderNotShipped
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.ShippedDate IS NULL
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","Both the provided input code and the reference code aim to count the number of orders with a NULL 'ShippedDate', which means they are not yet shipped. In the reference code, it directly counts from the 'orders' table, assuming the count of 'OrderID' directly relates to products not shipped. The input code adds a join with the 'Order Details' table, which might imply there can be multiple records per order, but the final task remains to count non-shipped records. While the query structure differs, both are effectively counting orders with a NULL 'ShippedDate', which fulfills the business request.","```python
import pandas as pd

# SQL query to get products that have been ordered but not yet shipped
sql_query = ""SELECT * FROM products WHERE UnitsOnOrder > 0 AND Discontinued = 0;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if df is not empty and count the number of products
if not df.empty:
    product_count = len(df)
else:
    product_count = 0

# Create a DataFrame to display the result
result_df = pd.DataFrame({'Number of Products': [product_count]})

# Show the result to the user
show_to_user(result_df)
```","The reference code is counting orders that are not yet shipped using the 'orders' table and checking for NULL 'ShippedDate'. The input code instead uses the 'products' table, checking products with 'UnitsOnOrder' greater than 0 and filtering by 'Discontinued' status. These queries address different conditions and logic, leading to fundamentally different analyses.",Base
Which products are low in stock and need reordering?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE UnitsInStock <= ReorderLevel 
AND Discontinued = 0;
""""""

# Execute the SQL query to get the data
low_stock_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(low_stock_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;
""""""

low_stock_products = execute_sql_query(sql_query)
show_to_user(low_stock_products)
```","The input code correctly identifies products that are low in stock by selecting them based on the 'UnitsInStock' being less than or equal to the 'ReorderLevel' and 'Discontinued' being 0. Although it fetches additional columns ('ProductID', 'UnitsInStock', 'ReorderLevel'), it does not contradict the business logic and still addresses the specified analytics request appropriately.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query to get the data
low_stock_products = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(low_stock_products)
```","The input code does not include a condition to check if the products are not discontinued. The reference implementation includes 'AND Discontinued = 0' in the SQL query to ensure discontinued products are not considered, which is missing in the input code.",Base
How many orders were shipped but not yet delivered by the required date?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS Count FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result['Count'][0])
```","```python
sql_query = """"""
SELECT COUNT(OrderID) AS UnfulfilledOrders
FROM orders
WHERE ShippedDate IS NOT NULL 
AND ShippedDate > RequiredDate;
""""""

unfulfilled_orders_df = execute_sql_query(sql_query)
show_to_user(unfulfilled_orders_df)
```","The evaluated code correctly answers the question. It counts the number of orders where the 'ShippedDate' is not null and is greater than the 'RequiredDate', indicating they were shipped but not delivered by the required date. This logic matches the reference implementation.","```python
import pandas as pd
from datetime import datetime

# Get today's date to compare with RequiredDate
today_date = datetime.now().date()

# Define SQL query
sql_query = ""SELECT * FROM orders WHERE ShipDate > RequiredDate;""

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Use condition to find orders shipped but not delivered on time
late_shipped_orders_df = orders_df[orders_df['RequiredDate'] < today_date]

# Count the number of orders
late_shipped_orders_count = late_shipped_orders_df.shape[0]

# Prepare result to display
result_df = pd.DataFrame({'Count of Late Shipped Orders': [late_shipped_orders_count]})

# Show the result to the user
show_to_user(result_df)
```","The input code incorrectly applies 'today's date' comparison, misinterpreting 'orders shipped but not yet delivered by the required date.' The count should directly use 'ShippedDate > RequiredDate' as in the reference code, not 'RequiredDate < today_date.' The logic deviates from the request.",Base
Determine the average number of products per order.,"```python
import pandas as pd

# SQL query to determine the average number of products per order
sql_query = """"""
SELECT AVG(ProductCount) AS AverageProductsPerOrder 
FROM (
    SELECT OrderID, COUNT(ProductID) AS ProductCount 
    FROM [Order Details] 
    GROUP BY OrderID
) AS ProductCounts;
""""""

# Execute the SQL query
average_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_df['AverageProductsPerOrder'])
```","```python
sql_query = """"""
SELECT AVG(product_count) AS average_products_per_order
FROM (
    SELECT orders.OrderID, COUNT([Order Details].ProductID) AS product_count
    FROM orders
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
    GROUP BY orders.OrderID
) AS order_counts
""""""

average_products_df = execute_sql_query(sql_query)
show_to_user(average_products_df)
```","The input code calculates the average number of products per order by joining the 'orders' table with the 'Order Details' table, grouping by 'OrderID', and counting the 'ProductID'. This is analogous to the reference implementation, which also groups by 'OrderID' and calculates the average from these counts.","To determine the average number of products per order, we can follow these steps:
1. Execute a SQL query to retrieve the required data.
2. Use the `pandas` library to compute the average.
3. Display the result to the user.

Hereâ€™s how to implement it in Python:

```python
import pandas as pd

# Define SQL queries
sql_query_total_orders = ""SELECT COUNT(DISTINCT OrderID) AS TotalOrders FROM [Order Details];""
sql_query_total_quantity_per_order = ""SELECT SUM(Quantity) AS TotalQuantity FROM [Order Details];""

# Execute the SQL queries
total_orders_df = execute_sql_query(sql_query_total_orders)
total_quantity_df = execute_sql_query(sql_query_total_quantity_per_order)

# Ensure there are valid results
if not total_orders_df.empty and not total_quantity_df.empty:
    total_orders = total_orders_df['TotalOrders'][0]
    total_quantity = total_quantity_df['TotalQuantity'][0]

    # Calculate average products per order
    avg_products_per_order = total_quantity / total_orders

    # Prepare the result as a DataFrame for display
    result_df = pd.DataFrame({'AvgProductsPerOrder': [avg_products_per_order]})

    # Show the result to the user
    show_to_user(result_df)
else:
    raise ValueError(""Query execution returned empty results."")
```

### Explanation:
1. **SQL Queries**: Retrieve two datasets, one for the total number of distinct orders and another for the total quantity of products.
2. **Data Retrieval**: Execute the SQL queries using the utility function `execute_sql_query()`.
3. **Data Calculation**: Check if results are empty; then calculate the average directly.
4. **Data Display**: Convert the result into a pandas DataFrame and use `show_to_user()` function to display it.

Make sure to adapt the column names used based on the DataFrame structure returned by the SQL execution.","The given input Python code evaluates the average number of products per order by calculating the total quantity of products and dividing it by the total number of orders. This is incorrect because 'Quantity' typically represents the number of items, possibly duplicated, in each order line. The correct approach, as per the reference code, should count the distinct product occurrences per order and average that count across all orders. The reference code achieves this by grouping by OrderID and counting ProductID, then averaging those counts.",Base
Which suppliers provide products that are currently discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT DISTINCT p.SupplierID, p.ProductName
FROM products p
WHERE p.Discontinued = 1
""""""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code lists distinct SupplierIDs and ProductNames from the products table where products are discontinued. However, it does not join with the suppliers table to get the CompanyName, unlike the reference code which correctly joins the suppliers and products tables to identify and list distinct SupplierIDs and CompanyNames of discontinued products.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DISTINCT suppliers.CompanyName 
FROM suppliers 
JOIN products 
ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 1;
""""""

# Execute the SQL query
discontinued_suppliers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discontinued_suppliers_df)
```","The input code retrieves the CompanyName of suppliers with discontinued products, which satisfies the business analytics request of identifying suppliers of discontinued products. While it doesn't include SupplierID as the reference implementation does, the request does not explicitly require it. Thus, the logic adheres to the reference implementation's intent.",Finetuned
What are the most commonly ordered product quantities?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS MostCommonQuantities 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID 
ORDER BY MostCommonQuantities DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT Quantity, COUNT(*) as OrderCount
FROM [Order Details]
GROUP BY Quantity
ORDER BY OrderCount DESC
LIMIT 10
""""""

quantities_df = execute_sql_query(sql_query)
show_to_user(quantities_df)
```","The input code does not match the logic of the reference implementation. The reference code calculates the total quantities ordered for each product and sorts them to find the most commonly ordered quantities per product. The input code, however, calculates how frequently each individual order quantity appears and returns the top 10 most frequent quantities regardless of product.","To find the most commonly ordered product quantities, we can execute the provided SQL query to retrieve the data from the 'Order Details' table, then analyze the result using Python to find the most frequent quantities.

Here's the Python code that accomplishes this:

```python
import pandas as pd

# SQL query to get the ordered product quantities
sql_query = """"""
SELECT Quantity, COUNT(Quantity) AS OrderCount
FROM [Order Details]
GROUP BY Quantity
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Reset the index for better readability
df.reset_index(drop=True, inplace=True)

# Show the top results to the user
show_to_user(df.head())
```

This code executes the SQL query to get the quantities and their order counts, orders them in descending order by count, and displays the top results to the user. Adjust the `show_to_user` method to match your specific implementation if necessary.","The input code calculates the frequency of each ordered quantity across all products, not the most commonly ordered quantities per product. The reference code calculates summed quantities for each product and sorts by these sums, indicating the most ordered products overall. The logic here differs significantly between the two implementations.",None
Find the most expensive product by unit price.,"```python
import pandas as pd

sql_query = ""SELECT ProductName FROM products ORDER BY UnitPrice DESC LIMIT 1;""
df = execute_sql_query(sql_query)

most_expensive_product = df['ProductName'].iloc[0]

result_df = pd.DataFrame({'Most Expensive Product': [most_expensive_product]})
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE Discontinued = 0 
ORDER BY UnitPrice DESC 
LIMIT 1;
""""""

most_expensive_product = execute_sql_query(sql_query)
show_to_user(most_expensive_product)
```","The input code includes an additional condition 'WHERE Discontinued = 0' which filters out discontinued products. This condition is not present in the reference implementation. Additionally, the input code directly shows the result without formatting it into a new DataFrame with the specified column name 'Most Expensive Product'.","```python
import pandas as pd

# SQL query to find the most expensive product by unit price
sql_query = """"""
SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the most expensive product details
most_expensive_product = df.iloc[0]

# Show the result to the user
show_to_user(most_expensive_product)
```","The input code is incorrect because it presents the most expensive product with both ProductName and UnitPrice fields, while the reference implementation only returns the ProductName. The format of the output in the input code does not match the expected result shown in the reference implementation, which specifically creates a DataFrame with the 'Most Expensive Product' label.",None
Find the top 5 highest priced products with a visualization to compare prices.,"```python
import plotly.express as px

# Define SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Generate a bar chart to compare prices
fig = px.bar(df, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
ORDER BY UnitPrice DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products', labels={'UnitPrice': 'Price', 'ProductName': 'Product'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request as it follows the same logic as the reference implementation. It executes a SQL query to select the top 5 highest priced products ordered by UnitPrice, stores the result in a dataframe, and uses Plotly to create a bar chart to compare prices. The additions of labels in the plot do not change the core logic and still meet the requirements. Therefore, the implementation is correct.","```python
import plotly.express as px

# SQL query to fetch top 5 highest priced products
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 highest priced products
fig = px.bar(df, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products')

# Display the visualization to the user
show_to_user(fig)
```","The input Python code is correct as it adheres to the same logic and structure as the reference implementation. Both versions execute an SQL query to retrieve the top 5 highest priced products, store the result in a DataFrame, create a bar chart with Plotly Express to visualize the product prices, and then display the chart to the user. The primary query structure and operations are identical, ensuring the business request is fulfilled.",both
"List customers with their respective regions and count of orders placed, visualizing order counts geographically.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    customers.CustomerID, 
    customers.Region, 
    COUNT(orders.OrderID) AS total_orders 
FROM 
    customers 
LEFT JOIN 
    orders 
ON 
    customers.CustomerID = orders.CustomerID 
GROUP BY 
    customers.CustomerID, customers.Region;
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Aggregate total_orders by region
aggregated_data = data.groupby('Region', as_index=False)['total_orders'].sum()

# Visualize order counts geographically
fig = px.bar(aggregated_data, x='Region', y='total_orders', color='Region', 
             title='Order Counts by Region')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, c.Region, COUNT(o.OrderID) AS OrderCount
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName, c.Region
ORDER BY c.Region, OrderCount DESC;
""""""

customer_orders = execute_sql_query(sql_query)

fig = px.scatter_geo(customer_orders,
                     locations=""Region"",
                     size=""OrderCount"",
                     hover_name=""CompanyName"",
                     title=""Customer Order Counts by Region"",
                     template=""plotly"")

show_to_user(fig)
```","The input code uses a scatter_geo plot instead of a bar chart to visualize the data, which deviates from the reference. Additionally, it aggregates by customer and not by region for order counts.","To address the request, we need to perform the following steps:

1. **Execute SQL Query**: Retrieve the customer, region, and order count data by executing the provided SQL query.
2. **Visualize the Results**: Create a visualization to show order counts geographically by region.

Here's the Python code that accomplishes these tasks:

```python
import plotly.express as px

# Step 1: Execute the SQL query
sql_query = """"""
SELECT c.CustomerID, c.Region, COUNT(o.OrderID) AS OrderCount 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID, c.Region;
""""""
df = execute_sql_query(sql_query)

# Step 2: Visualize order counts geographically
fig = px.choropleth(
    df,
    locationmode='ISO-3',
    locations='Region',  # Assume 'Region' is compatible with iso3 format
    color='OrderCount',
    hover_name='CustomerID',
    color_continuous_scale='Blues',
    title='Order Counts by Region'
)

# Showing the plot to the user
show_to_user(fig)
```

Please ensure that the geographical data aligns with what Plotly expects for proper mapping, adjusting `""Region""` if necessary. Adjust the default color scheme or any plot parameters based on specific user requirements or preferences.","The input code uses `px.choropleth` for visualizing order counts, assuming 'Region' is in a format compatible with ISO-3 country codes. However, the reference code uses a bar chart (`px.bar`) for summarizing and visualizing order counts by region. There is a conceptual discrepancy between a bar chart and a geographical map. Additionally, the input code does not aggregate order counts by region before visualization, unlike the reference implementation.",None
"Find the top 5 cities with the highest number of orders, using a bar chart for comparison.","```python
import plotly.express as px

# Execute the SQL query to get the top 5 cities with highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 5;
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders')
show_to_user(fig)
```","The input Python code follows the same logic as the reference implementation. It executes a SQL query to fetch the top 5 cities with the highest number of orders and uses Plotly to create a bar chart, which is then displayed to the user. Both the SQL query and the plotting code are correct and align with the business analytics request.","```python
import plotly.express as px

# SQL query to find the top 5 cities with the highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrdersCount FROM orders GROUP BY ShipCity ORDER BY OrdersCount DESC LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart for the top 5 cities
fig = px.bar(df, x='ShipCity', y='OrdersCount', title='Top 5 Cities with Highest Number of Orders')

# Display the bar chart
show_to_user(fig)
```","The input Python code successfully executes a SQL query to find the top 5 cities with the highest number of orders, grouping by 'ShipCity' and ordering by the count in descending order. It then uses Plotly to create a bar chart of the results with the same logic and intent as the reference implementation. The only difference is in the alias used for the count, which doesn't affect the result.",both
"What is the total quantity of each product sold, visualized with a bar chart?","```python
import plotly.express as px

# SQL query to get the total quantity of each product sold
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity Sold by Product')

# Show the result to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.Quantity) AS TotalQuantity
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalQuantity DESC
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='ProductID', y='TotalQuantity', title='Total Quantity of Each Product Sold')
show_to_user(fig)
```","The input code accurately retrieves the total quantity of each product sold using a SQL query that sums the Quantity grouped by ProductID, which matches the logic of the reference implementation. Although the input code includes an additional JOIN and ORDER BY clause, it does not affect the correctness in terms of calculating and visualizing the total quantity per product using a bar chart.","```python
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantitySold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalQuantitySold', title=""Total Quantity Sold by Product"")

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request by calculating the total quantity sold per product and visualizing it using a bar chart. Although it differs from the reference implementation by including a JOIN to retrieve product names instead of using ProductID, the logic is consistent, and it achieves the same outcome.",both
Find the total sales and the number of orders for each customer in March 2023 with a bar chart for comparison.,"```python
import plotly.express as px

# The SQL query to execute
sql_query = """"""
SELECT O.CustomerID, SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales, 
COUNT(O.OrderID) AS OrderCount 
FROM orders O 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
WHERE DATE_FORMAT(O.OrderDate, '%Y-%m') = '2023-03' 
GROUP BY O.CustomerID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for comparison
fig = px.bar(data, x='CustomerID', y=['TotalSales', 'OrderCount'], 
             barmode='group', 
             title='Total Sales and Number of Orders for Each Customer in March 2023')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.CustomerID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
    COUNT(o.OrderID) AS NumberOfOrders
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-03-01' AND o.OrderDate < '2023-04-01'
GROUP BY 
    o.CustomerID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CustomerID', y='TotalSales', title='Total Sales by Customer in March 2023', 
             labels={'TotalSales': 'Total Sales', 'CustomerID': 'Customer ID'})
fig.add_bar(x=data['CustomerID'], y=data['NumberOfOrders'], name='Number of Orders')
show_to_user(fig)
```","The input code correctly calculates the total sales and the number of orders for each customer in March 2023. The SQL query logic matches the reference with the same conditions and aggregation. The bar chart effectively displays both total sales and order counts for comparison, similar to the intended purpose of the reference code, albeit using a slightly different method of adding the second bar series.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales, 
       COUNT(orders.OrderID) AS order_count 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for total sales and number of orders for each customer
fig = px.bar(data, x='CustomerID', y=['total_sales', 'order_count'], 
             barmode='group', 
             title='Total Sales and Number of Orders for Each Customer in March 2023',
             labels={'value': 'Amount', 'variable': 'Metrics'})

# Display the chart
show_to_user(fig)
```","Both implementations perform the same task: they calculate the total sales and the number of orders for each customer in March 2023. The input code uses proper JOINs and dates to filter records in March 2023. It also groups by CustomerID and aggregates TotalSales and OrderCount correctly. Although the method of filtering dates differs slightly (using BETWEEN vs DATE_FORMAT), the logic remains consistent. Additionally, both scripts visualize the results with a similar bar chart. Therefore, the input code meets the requirements of the given task.",both
"How many units have been sold for each product, grouped by supplier, visualized with a stacked bar chart?","```python
import plotly.express as px

# SQL query to retrieve the required data
sql_query = '''
SELECT s.SupplierName, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierName, p.ProductName;
'''

# Execute the SQL query to get the data in a dataframe
df = execute_sql_query(sql_query)

# Create the stacked bar chart using plotly
fig = px.bar(df, x='SupplierName', y='TotalQuantitySold', color='ProductName', 
             title='Units Sold for Each Product by Supplier', 
             labels={'TotalQuantitySold': 'Total Quantity Sold', 'SupplierName': 'Supplier'})

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, p.SupplierID, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName, p.SupplierID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, 
             x='ProductName', 
             y='TotalUnitsSold', 
             color='SupplierID', 
             title='Units Sold for Each Product Grouped by Supplier', 
             labels={'TotalUnitsSold': 'Units Sold', 'ProductName': 'Product Name'},
             text='TotalUnitsSold')

fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(barmode='stack')

show_to_user(fig)
```","The input Python code retrieves data grouped by ProductName and SupplierID, whereas the reference code groups data by SupplierName and ProductName. The input code also visualizes the data using ProductName on the x-axis and color by SupplierID, which does not align with the business analytics request to show a stacked bar chart grouped by supplier.","```python
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT p.ProductCategoryID, p.SupplierID, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductCategoryID, p.SupplierID;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a stacked bar chart using plotly
fig = px.bar(df, 
             x='ProductCategoryID', 
             y='TotalUnitsSold', 
             color='SupplierID', 
             title='Units Sold by Product Category and Supplier',
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductCategoryID': 'Product Category ID'})

# Show the visualization to the user
show_to_user(fig)
```","The input code does not correctly follow the original business analytics request. It groups data by ProductCategoryID and SupplierID instead of SupplierName and ProductName. The visualization is also labeled incorrectly, as it uses ProductCategoryID instead of SupplierName and SupplierID instead of ProductName. Furthermore, the SQL query does not match the structure that fetches the needed information by supplier and product.",None
Calculate the percentage of orders shipped within 5 days of the order date.,"```python
import pandas as pd

# Execute query to retrieve all orders data
orders_df = execute_sql_query(""SELECT OrderID, OrderDate, ShippedDate FROM orders"")

# Calculate percentage of orders shipped within 5 days
orders_df['DaysDifference'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days
within_5_days = orders_df['DaysDifference'] <= 5
percentage_within_5_days = within_5_days.sum() * 100.0 / len(orders_df)

# Prepare the result as a dataframe
result_df = pd.DataFrame({
    'PercentageWithin5Days': [percentage_within_5_days]
})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 5 THEN OrderID END) AS OrdersShippedWithin5Days
FROM 
    orders
""""""

result_df = execute_sql_query(sql_query)

percentage_shipped_within_5_days = (result_df['OrdersShippedWithin5Days'].iloc[0] / result_df['TotalOrders'].iloc[0]) * 100

show_to_user(pd.DataFrame({'Percentage Shipped Within 5 Days': [percentage_shipped_within_5_days]}))
```","The input Python code correctly calculates the percentage of orders shipped within 5 days. It uses a SQL query to calculate the total number of orders and orders shipped within 5 days using the DATEDIFF function directly in the database. The percentage is then calculated by dividing the number of shipments within 5 days by the total number of orders and multiplying by 100. This approach aligns logically with the reference implementation, as it achieves the same result using SQL aggregation functions.","```python
import pandas as pd

# Define the SQL query 
sql_query = """"""
SELECT OrderDate, ShippedDate 
FROM orders
""""""

# Execute the query to get the data
orders_df = execute_sql_query(sql_query)

# Calculate the on-time delivery rate
orders_df['DeliveryTime'] = (pd.to_datetime(orders_df['ShippedDate']) - pd.to_datetime(orders_df['OrderDate'])).dt.days
on_time_rate = (orders_df['DeliveryTime'] <= 5).mean()

# Create a DataFrame to display the result
result_df = pd.DataFrame({'OnTimeDeliveryRate': [on_time_rate]})

# Show the result to the user
show_to_user(result_df)
```","The input code correctly calculates the percentage of orders shipped within 5 days of the order date. Although the variable names and slightly the approach differ, the logic aligns with the reference implementation. The difference in using `.mean()` instead of dividing by the length of the dataframe is mathematically equivalent for binary conditions. The result is packaged into a DataFrame and displayed, fulfilling the business analytics request.",both
"What is the total quantity ordered across all products by month, with a line chart to show trends?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT MONTH(OrderDate) AS OrderMonth, 
       YEAR(OrderDate) AS OrderYear, 
       SUM(Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
GROUP BY YEAR(OrderDate), MONTH(OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort data by year and month for proper trend visualization
df.sort_values(by=['OrderYear', 'OrderMonth'], inplace=True)

# Concatenate year and month for the x-axis
df['YearMonth'] = df['OrderYear'].astype(str) + '-' + df['OrderMonth'].astype(str)

# Create a line chart using Plotly
fig = px.line(df, x='YearMonth', y='TotalQuantityOrdered', 
              labels={'YearMonth': 'Year-Month', 'TotalQuantityOrdered': 'Total Quantity Ordered'},
              title='Monthly Total Quantity Ordered Across All Products')

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total quantity ordered by month
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(Quantity) AS Total_Quantity_Ordered
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a line chart to show trends
fig = px.line(data, x='Month', y='Total_Quantity_Ordered', title='Total Quantity Ordered by Month')
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request by grouping the total quantity ordered by month, similarly to the reference code. While there are some differences in implementation, such as the use of DATE_FORMAT in the SQL query and a slightly different method of sorting, the result is the same: a line chart showing the monthly trends of total quantities ordered. Both codes appropriately handle SQL execution and produce a visual output using Plotly, addressing the core requirement.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
SUM(od.Quantity) AS TotalQuantity 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
GROUP BY Month;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a line chart
fig = px.line(df, x='Month', y='TotalQuantity', title='Total Quantity Ordered by Month')

# Display the line chart
show_to_user(fig)
```","The provided code correctly answers the business analytics request. It aggregates the total quantity ordered by month and creates a trend line chart. The query groups by month using 'DATE_FORMAT' which aligns with the reference implementation's goal. Both codes use Plotly for the line chart, reflecting the same logical outcome for visual representation of trends.",both
"Which product has generated the highest revenue, and visualize this with a bar chart?","```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS Revenue
FROM [Order Details]
GROUP BY ProductID
ORDER BY Revenue DESC;
""""""

# Execute the SQL query and get the data in a pandas DataFrame
data_df = execute_sql_query(sql_query)

# Visualize the revenue of each product
fig = px.bar(data_df, x='ProductID', y='Revenue', title='Product Revenue')

# Show the visualization
show_to_user(fig)

# Determine the product with the highest revenue
highest_revenue_product = data_df.iloc[0]
show_to_user(highest_revenue_product)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    Revenue DESC
LIMIT 1
""""""

highest_revenue_product = execute_sql_query(sql_query)

sql_query_details = """"""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
""""""

all_products_revenue = execute_sql_query(sql_query_details)

fig = px.bar(all_products_revenue, 
             x='ProductID', 
             y='Revenue', 
             title='Revenue by Product', 
             labels={'ProductID': 'Product ID', 'Revenue': 'Total Revenue'})

show_to_user(fig)
```","The input code correctly answers the business analytics request by identifying the product with the highest revenue and visualizing all products' revenue with a bar chart. It uses two queries, one to find the highest revenue product with a 'LIMIT 1' clause, ensuring it follows the same logic as the reference implementation for determining the top product. The second query aggregates and visualizes the revenues of all products, which aligns with the original requirement.","```python
import plotly.express as px

# SQL query to find the product with highest revenue
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalRevenue DESC 
LIMIT 1;
""""""

# Execute SQL query
highest_revenue_product_df = execute_sql_query(sql_query)

# Verify the dataframe is not empty and contains expected data
if not highest_revenue_product_df.empty:
    # Create a bar chart using plotly
    fig = px.bar(highest_revenue_product_df, 
                 x='ProductName', 
                 y='TotalRevenue', 
                 title='Product with Highest Revenue')

    # Show the bar chart to the user
    show_to_user(fig)
else:
    print(""No data found."")
```","The input code only retrieves the product with the highest revenue using a LIMIT 1 clause, rather than retrieving all products and determining the highest after retrieval. Moreover, the input only visualizes this single product, not all products with their revenues. The task requires visualizing the revenue for each product to identify the one with the highest revenue, similar to the reference code.",Base
Calculate the average order value for each customer with a bar chart for comparison.,"```python
import plotly.express as px

# SQL query to calculate average order value for each customer
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM customers c 
INNER JOIN orders o ON c.CustomerID = o.CustomerID 
INNER JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly to visualize average order value for each customer
fig = px.bar(df, x='CustomerID', y='AverageOrderValue', title='Average Order Value per Customer')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average order value per customer
sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
""""""

# Execute the SQL query
average_order_value_df = execute_sql_query(sql_query)

# Create bar chart for average order value
fig = px.bar(average_order_value_df, 
             x='CompanyName', 
             y='AverageOrderValue', 
             title='Average Order Value by Customer',
             labels={'AverageOrderValue': 'Average Order Value', 'CompanyName': 'Customer'},
             text='AverageOrderValue')

# Show the plot to the user
show_to_user(fig)
```","The input code uses the `AVG()` function instead of calculating the average by dividing the total value by the number of distinct orders, which could lead to different results. Also, the group by clause includes `c.CompanyName`, causing potential differences if multiple customers share the same ID.","Here's a Python script to calculate the average order value for each customer and display it using a bar chart.

```python
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT customers.CustomerID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderValue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for average order value for each customer
fig = px.bar(data, x='CustomerID', y='AvgOrderValue', title='Average Order Value per Customer')

# Show the plot
show_to_user(fig)
```

This code retrieves data for the average order value per customer from the database and visualizes it as a bar chart using plotly.","The input code uses the AVG function instead of computing the average using SUM and COUNT as in the reference implementation. This can lead to different results if there are multiple order details per order, as AVG calculates the mean of all (UnitPrice * Quantity * (1 - Discount)) values, while the reference code divides the total order value by distinct order counts.",None
"What is the average lead time for orders delivered by each supplier, visualized with a bar chart?","```python
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID
""""""
data = execute_sql_query(sql_query)

# Create the bar chart
fig = px.bar(data, x='SupplierID', y='avg_lead_time', title='Average Lead Time by Supplier')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time
FROM orders 
JOIN products ON orders.OrderID = products.ProductID 
GROUP BY products.SupplierID
""""""

lead_time_data = execute_sql_query(sql_query)

fig = px.bar(lead_time_data, x='SupplierID', y='average_lead_time', 
             title='Average Lead Time for Orders Delivered by Each Supplier', 
             labels={'SupplierID': 'Supplier ID', 'average_lead_time': 'Average Lead Time (Days)'})

show_to_user(fig)
```","The input code has an error in the SQL query. It incorrectly joins the 'products' table directly to 'orders' using 'OrderID' and 'ProductID', which is not aligned with the reference implementation's correct join using '[Order Details]'. This leads to missing the required join logic present in the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT 
    suppliers.SupplierName, 
    suppliers.SupplierID, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM 
    suppliers 
JOIN 
    orders 
ON 
    suppliers.SupplierID = orders.SupplierID 
GROUP BY 
    suppliers.SupplierName, suppliers.SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierName', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show the bar chart
show_to_user(fig)
```","The input code uses `suppliers.SupplierName` for the x-axis, deviating from the reference, which uses `SupplierID`. Additionally, it aggregates data from a different set of tables, specifically joining only `suppliers` and `orders`, possibly missing products data which might affect matching suppliers to the actual orders.",None
Which suppliers provide products that are currently out of stock?,"```python
import pandas as pd

# SQL query to find suppliers providing out-of-stock products
sql_query = """"""
SELECT s.SupplierName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.UnitsInStock = 0;
""""""

# Execute the SQL query
out_of_stock_suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(out_of_stock_suppliers_df)
```","```python
sql_query = """"""
SELECT DISTINCT p.SupplierID, p.ProductName 
FROM products p 
WHERE p.UnitsInStock = 0
""""""

out_of_stock_suppliers = execute_sql_query(sql_query)
show_to_user(out_of_stock_suppliers)
```","The input code selects distinct SupplierIDs and ProductNames from products where UnitsInStock is 0, but it does not join with the suppliers table to get SupplierNames. Thus, it does not fully implement the request to find which suppliers provide out-of-stock products.","```python
import pandas as pd

# SQL query to retrieve suppliers providing out-of-stock products
sql_query = """"""
SELECT DISTINCT suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.UnitsInStock = 0;
""""""

# Execute the SQL query to get the data
suppliers_out_of_stock = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(suppliers_out_of_stock[['CompanyName']])
```","Both implementations correctly identify suppliers providing products that are out of stock. The difference in column naming ('SupplierName' vs 'CompanyName') does not affect the correctness of the logic. Both codes use a JOIN on `SupplierID` and filter on `UnitsInStock = 0`, which fulfills the business analytics request.",Finetuned
How many units on order are there for each product?,"```python
import pandas as pd

# SQL query
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductID, SUM(UnitsOnOrder) AS TotalUnitsOnOrder
FROM products
GROUP BY ProductID
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The business analytics request and the reference implementation ask for the number of units on order for each product, using the 'ProductName' field. The input code uses 'ProductID' and applies a SUM operation, which suggests aggregation but changes the requested grouping logic.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, UnitsOnOrder FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(df)
```","The input code retrieves 'ProductID' instead of 'ProductName.' The business analytics request and reference implementation specify that the product name is required, not the product ID.",None
How many units of each product are currently in stock?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT ProductID, ProductName, UnitsInStock FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsInStock 
FROM products
WHERE Discontinued = 0
""""""

product_stock = execute_sql_query(sql_query)
show_to_user(product_stock)
```","The input code queries only for products that are not discontinued, while the reference code retrieves all products, irrespective of whether they are discontinued or not. Additionally, the input code does not retrieve the 'ProductID', which the reference code does.","```python
import pandas as pd

# SQL query to get the product name and units in stock
sql_query = ""SELECT ProductName, UnitsInStock FROM products;""

# Execute SQL query using the given function
products_in_stock = execute_sql_query(sql_query)

# Display the results in an appropriate format
show_to_user(products_in_stock)
```","The input code omits the 'ProductID' field in the SQL query. The reference implementation includes 'ProductID, ProductName, UnitsInStock', while the evaluated code only includes 'ProductName, UnitsInStock'. Therefore, it does not answer the business analytics request to provide the number of units of each product in stock, because 'ProductID' may be needed for accurate identification of each product.",None
Which product has the highest unit price but lowest sales quantity?,"```python
import pandas as pd

# SQL query to find the product with the highest unit price but lowest sales quantity
sql_query = """"""
SELECT products.ProductID, products.ProductName 
FROM products 
WHERE products.UnitPrice = (SELECT MAX(products.UnitPrice) FROM products) 
AND products.ProductID NOT IN (
    SELECT ProductID 
    FROM [Order Details] 
    WHERE Quantity > 0
)
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
       [Order Details].UnitPrice, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductID, products.ProductName, [Order Details].UnitPrice
ORDER BY [Order Details].UnitPrice DESC, total_quantity ASC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code orders products by UnitPrice descending and total_quantity ascending, then fetches only the first one. It does not correctly identify products with the highest unit price but the lowest sales quantity like the reference code does. The reference implementation explicitly checks for the maximum UnitPrice and ensures the product has no sales in the 'Order Details' table.","```python
import pandas as pd

sql_query = """"""
SELECT products.ProductName, products.UnitPrice, SUM([Order Details].Quantity) AS TotalQuantity
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductName, products.UnitPrice
ORDER BY products.UnitPrice DESC, TotalQuantity ASC
LIMIT 1;
""""""

# Execute the SQL query to get the result
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The input code tries to find the product with the highest unit price and the lowest sales quantity using a different approach â€” it calculates total quantities per product and sorts by unit price descending and total quantity ascending. However, it does not ensure that the product has zero sales quantity, which is crucial in the reference implementation. The reference code explicitly filters out products with a sales quantity greater than zero.",None
Which product had the highest sales in terms of quantity in March 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
    SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
    GROUP BY products.ProductName 
    ORDER BY total_quantity DESC 
    LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_quantity DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The provided code correctly executes a SQL query to find the product with the highest sales quantity in March 2023. It joins the necessary tables, filters by the specified date range, groups by ProductID and ProductName, orders by total quantity in descending order, and limits the result to one. The addition of grouping by ProductID does not alter the correctness compared to the reference, as it only maintains the relationship between ProductName and ProductID without affecting the query's purpose.","```python
import pandas as pd

# SQL query to retrieve products sold in quantity in March 2023
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY ProductID
ORDER BY TotalQuantity DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code retrieves the product with the highest quantity sold by 'ProductID' instead of 'ProductName', as specified in the request. The reference implementation joins the 'products' table to get 'ProductName', while the input code does not.",Base
What is the total sales generated by each employee for the past year?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    e.EmployeeID
ORDER BY 
    TotalSales DESC;
""""""

total_sales_data = execute_sql_query(sql_query)
show_to_user(total_sales_data)
```","The input Python code correctly implements the logic specified in the business analytics request. It calculates the total sales by each employee for the past year using SQL, similar to the reference implementation. The addition of 'ORDER BY TotalSales DESC' does not affect the correctness, as it only sorts the output.","```python
import pandas as pd

# SQL query to get total sales by each employee for the past year
sql_query = """"""
SELECT EmployeeID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY EmployeeID;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_data)
```","The input code correctly queries the total sales generated by each employee for the past year. It joins the 'employees', 'orders', and 'Order Details' tables and computes the total sales using the same formula as the reference code. Both implementations filter orders from the past year and group the results by EmployeeID. The absence of employee names in the input query does not impact the correctness regarding the requested task.",both
Visualize the average number of days between order placement and order shipping by customer.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageDaysToShip
FROM orders
GROUP BY CustomerID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average days to ship by customer
fig = px.bar(data, x='CustomerID', y='AverageDaysToShip', 
             title='Average Days to Ship by Customer',
             labels={'CustomerID': 'Customer ID', 'AverageDaysToShip': 'Average Days to Ship'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgDaysToShip
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY CustomerID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CustomerID', y='AvgDaysToShip', title='Average Days Between Order Placement and Shipping by Customer')
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation, despite minor differences. Both codes compute the average number of days between the order placement and shipping by customer using a similar SQL query. The input code also includes a filter for non-null 'ShippedDate', which is a reasonable addition as null values would not be meaningful for this metric. Both pieces of code create a similar bar chart visualization using Plotly Express and display it with 'show_to_user(fig)'. Therefore, the input code meets the requirements of the business analytics request.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgDaysToShip
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CustomerID', y='AvgDaysToShip', title='Average Days to Ship by Customer', 
             labels={'AvgDaysToShip': 'Average Days to Ship', 'CustomerID': 'Customer ID'})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code is functionally equivalent to the reference implementation. It calculates the average number of days between order placement and shipping by customer using the same logic. The inclusion of the 'customers' table joined with 'orders' likely ensures all customers are considered, but does not alter the computation of the average days per customer. The visualization is created using Plotly in both codes, displaying the same information with appropriate labels. Therefore, the input code satisfies the business analytics request just like the reference code.",both
Visualize the total sales revenue generated by each product category in the last year.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by product
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY ProductID;
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Assuming we have a separate table to get ProductID to Category mapping
product_category_query = """"""
SELECT ProductID, CategoryName 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID;
""""""
product_category_data = execute_sql_query(product_category_query)

# Merge the data to include CategoryName
merged_data = pd.merge(data, product_category_data, on='ProductID')

# Calculate total sales by Category
category_sales = merged_data.groupby('CategoryName', as_index=False)['TotalSales'].sum()

# Visualize using plotly
fig = px.bar(category_sales, x='CategoryName', y='TotalSales', title='Total Sales Revenue by Product Category in Last Year')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    p.CategoryID
""""""

sales_data = execute_sql_query(sql_query)
fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Total Sales Revenue by Product Category (Last Year)')
show_to_user(fig)
```","The input code groups the sales data by CategoryID without joining the categories table to map CategoryID to CategoryName. It visualizes the results with CategoryID on the x-axis instead of CategoryName, which doesn't fully satisfy the business analytics request to visualize by product category name.","```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT p.Category, 
       SUM(od.Quantity * od.UnitPrice) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY p.Category;
""""""

# Execute the SQL query
data_df = execute_sql_query(sql_query)

# Ensure the column names match those used in the SQL query results
data_df.columns = ['Category', 'TotalSales']

# Create a bar chart to visualize the total sales revenue by category
fig = px.bar(data_df, x='Category', y='TotalSales', title='Total Sales Revenue by Product Category Over the Last Year')

# Show the visualization to the user
show_to_user(fig)
```","The input code does not implement the correct logic for calculating total sales revenue as per the business analytics request. The reference code calculates total sales including the discount by using `(UnitPrice * Quantity * (1 - Discount))`. Additionally, the input code uses 'p.Category' in the GROUP BY clause, which should match the CategoryName from a product-category mapping in a separate query, as seen in the reference code.",None
Identify suppliers that have not supplied any products in the last year.,"```python
import pandas as pd

# SQL query to identify suppliers not active in last year
sql_query = """"""
SELECT suppliers.CompanyName 
FROM suppliers 
LEFT JOIN (
    SELECT products.SupplierID, COUNT(*) AS ProductCount 
    FROM products 
    JOIN ""Order Details"" ON products.ProductID = ""Order Details"".ProductID 
    JOIN orders ON ""Order Details"".OrderID = orders.OrderID 
    WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY products.SupplierID
) AS recent_products 
ON suppliers.SupplierID = recent_products.SupplierID 
WHERE recent_products.ProductCount IS NULL;
""""""

# Execute the query
inactive_suppliers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(inactive_suppliers_df)
```","```python
from datetime import datetime, timedelta

one_year_ago = (datetime.now() - timedelta(days=365)).date()

sql_query = f""""""
SELECT s.SupplierID, s.CompanyName
FROM suppliers s
LEFT JOIN products p ON s.SupplierID = p.SupplierID
LEFT JOIN orders o ON p.ProductID = o.OrderID
WHERE o.OrderDate < '{one_year_ago}' OR o.OrderDate IS NULL
GROUP BY s.SupplierID, s.CompanyName
HAVING MAX(o.OrderDate) < '{one_year_ago}'
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code does not correctly identify suppliers that have not supplied any products in the last year. It incorrectly joins 'orders' with 'products' on OrderID instead of ProductID and uses 'OrderDate' in the WHERE clause incorrectly. The logic of filtering and aggregating order dates differs from the reference code, which correctly excludes suppliers by checking for NULL ProductCount after a left join. The HAVING clause in the input code does not correctly capture suppliers with no recent orders.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName
FROM suppliers
LEFT JOIN products ON suppliers.SupplierID = products.SupplierID
WHERE products.ProductID IS NULL
OR suppliers.SupplierID NOT IN (
    SELECT DISTINCT products.SupplierID
    FROM products
    JOIN orders ON products.ProductID = orders.ProductID
    WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
);
""""""

# Execute the SQL query
df_suppliers = execute_sql_query(sql_query)

# Show the resulting dataframe to the user
show_to_user(df_suppliers)
```","The provided code is incorrect as it attempts to join 'products' directly with 'suppliers', which can incorrectly identify inactive suppliers without checking their activity in the last year. It also checks for 'products.ProductID IS NULL', which wouldn't be effective given the left join structure; this part is redundant. The second part of the WHERE clause is incorrect as it selects from 'products' and 'orders' without joining 'Order Details' to track product orders, unlike the reference code. The reference code properly checks product activity by joining 'Order Details' with 'orders' and filtering by date.",None
Which products have stock levels below their reorder level?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
low_stock_products = execute_sql_query(sql_query)
show_to_user(low_stock_products)
```","The input code includes an additional condition that products must not be discontinued (Discontinued = 0). This condition is not present in the reference implementation, thus altering the logic and potentially excluding some products that should be included as per the original request.","```python
import pandas as pd

# SQL Query to find products with stock below reorder level
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_below_reorder_level = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_below_reorder_level)
```","The input Python code accurately implements the logic of the reference code. Both execute a SQL query that selects products where 'UnitsInStock' is less than 'ReorderLevel', and then display the result using the 'show_to_user' function. The variable names differ slightly, but the logic and steps are the same.",Finetuned
How many units of each product are currently on order?,"```python
import pandas as pd

# SQL query to get units on order for each product
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products;""

# Execute SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsOnOrder
FROM products
WHERE Discontinued = 0
""""""
data = execute_sql_query(sql_query)
show_to_user(data)
```","The input code includes a condition 'WHERE Discontinued = 0' that filters out discontinued products. This is not present in the reference implementation, which simply retrieves all products. Therefore, the input code does not adhere to the same logic as the reference implementation.","```python
import pandas as pd

# SQL query to get product names and units on order
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products;""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```",The input Python code matches the reference implementation in both the SQL query executed and the method used to display the results. Both implementations aim to provide the user with the units on order for each product using the same logic.,Finetuned
What is the monthly sales trend for each product over the last year?,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM') AS Month, 
SUM([Order Details].Quantity) AS MonthlySales
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
WHERE [Order Details].OrderDate >= DATEADD(year, -1, GETDATE()) 
GROUP BY products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM');
""""""

# Execute the query and retrieve data as a dataframe
df = execute_sql_query(sql_query)

# Sort the dataframe by Month to ensure the trend line is accurate
df = df.sort_values(by='Month')

# Create a line plot for the monthly sales trend of each product
fig = px.line(df, x='Month', y='MonthlySales', color='ProductID', title='Monthly Sales Trend for Each Product')

# Show the plot to the user
show_to_user(fig)
```","```python
from datetime import datetime, timedelta
import pandas as pd
import plotly.express as px

# Calculate the last year's date range
end_date = datetime.now()
start_date = end_date - timedelta(days=365)

# Create SQL query to fetch monthly sales data for each product
sql_query = f""""""
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY 
    p.ProductID, 
    p.ProductName, 
    Month
ORDER BY 
    Month, p.ProductID;
""""""

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Plot the monthly sales trend for each product
fig = px.line(monthly_sales_df, 
              x='Month', 
              y='TotalSales', 
              color='ProductName', 
              title='Monthly Sales Trend for Each Product Over the Last Year',
              labels={'TotalSales': 'Total Sales', 'Month': 'Month'})
show_to_user(fig)
```","The input code calculates TotalSales by multiplying Quantity, UnitPrice, and applying a Discount, which differs from the reference implementation that sums only Quantity. In the business request context, the trend is about the number of items sold rather than revenue. Thus, the logic deviates from the reference implementation's focus on quantity.","To analyze the monthly sales trend for each product over the last year, we can utilize Python's `pandas` library along with SQL queries. Below is an outline of the steps we need to take:

1. Utilize the `execute_sql_query` function to fetch the required sales data.
2. Calculate the monthly sales trend for each product using `pandas` functionality.
3. Use the `show_to_user` function to present the results in a user-friendly manner.

Here's how the implementation of these steps looks in Python:

```python
import pandas as pd
from datetime import datetime

# Step 1: Formulate the SQL query
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].Quantity) AS TotalQuantity,
       MONTH([Order Details].OrderDate) AS OrderMonth,
       YEAR([Order Details].OrderDate) AS OrderYear
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE [Order Details].OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
GROUP BY products.ProductID, OrderMonth, OrderYear
ORDER BY OrderYear, OrderMonth;
""""""

# Step 2: Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Step 3: Create the monthly trend per product using pivot table
pivot_data = sales_data.pivot_table(index='OrderYear', columns='OrderMonth', values='TotalQuantity', fill_value=0)

# Step 4: Present the data to the user
show_to_user(pivot_data)
```

In this code:
- We executed the SQL query correctly while ensuring it fetches the needed data.
- We used a pivot table to reshape the data for clear visibility of trends over the last year.
- Finally, we displayed the data to the user with the correct format. 

Make sure to check the execution result to ensure the displayed data meets the user's expectations.","The input code calculates the monthly sales trend using a pivot table, which is different from the reference code that uses Plotly to create a line plot. The input code also aggregates sales at a less granular level by combining year and month separately, while the reference groups by formatted year-month. Additionally, the input code uses a different date function (DATE_SUB vs. DATEADD) which might affect compatibility and accuracy. Furthermore, the input code displays a pivot table instead of a line plot, not meeting the 'trends' requirement as requested.",None
Find the average discount provided per order.,"```python
import pandas as pd

# SQL query to get order discounts
sql_query = ""SELECT Discount FROM [Order Details];""

# Execute the SQL query
order_details_df = execute_sql_query(sql_query)

# Calculate the average discount per order
avg_discount = order_details_df['Discount'].mean()

# Prepare the result in a DataFrame for display
result_df = pd.DataFrame({'AvgDiscount': [avg_discount]})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscountPerOrder
FROM [Order Details]
GROUP BY OrderID
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The provided code computes the average discount per order by grouping by 'OrderID' and then averaging those values. The reference implementation calculates the overall average discount across all entries without considering 'OrderID.' Therefore, the logic differs as the input code calculates a more granular average, which is not the same as the overall average requested.","```python
import pandas as pd

# Define SQL query to calculate average discount per order
sql_query = """"""
SELECT AVG([Order Details].Discount) AS AverageDiscount
FROM [Order Details];
""""""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df['AverageDiscount'][0])
```","Both the reference and input implementations aim to calculate the average discount per order. The reference code retrieves all discounts into a DataFrame and calculates the mean using Pandas, whereas the input code calculates the average directly in the SQL query. Although the approaches differ, they both accurately compute the average discount, and the result is displayed correctly in each case.",Finetuned
Visualize the average quantity per unit for products supplied by each supplier.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT s.SupplierID, s.SupplierName, AVG(CAST(p.QuantityPerUnit AS DECIMAL)) AS AverageQuantityPerUnit
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.SupplierName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(df, x='SupplierName', y='AverageQuantityPerUnit',
             title='Average Quantity Per Unit by Supplier',
             labels={'AverageQuantityPerUnit': 'Average Quantity Per Unit', 'SupplierName': 'Supplier Name'})

# Show to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(CAST(p.QuantityPerUnit AS FLOAT)) AS AvgQuantityPerUnit
FROM products p
GROUP BY p.SupplierID
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='SupplierID', y='AvgQuantityPerUnit', title='Average Quantity Per Unit by Supplier')
show_to_user(fig)
```","The input code does not include the supplier names in the query, only the SupplierID. The reference implementation joins with the suppliers table to get the SupplierName, which is essential for the visualization task described. The input code may correctly calculate the average quantity, but the lack of supplier names means it does not fully satisfy the business analytics request for a clear visualization per supplier.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.SupplierName, products.QuantityPerUnit 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Splitting the 'QuantityPerUnit' to get the numeric part and converting it to float
df['NumericQuantity'] = df['QuantityPerUnit'].str.extract(r'(\d+\.?\d*)').astype(float)

# Calculate the average quantity per unit for each supplier
avg_quantity_per_unit = df.groupby('SupplierName')['NumericQuantity'].mean().reset_index()

# Create a bar chart to visualize the average quantity per unit per supplier
fig = px.bar(avg_quantity_per_unit, x='SupplierName', y='NumericQuantity', 
             title='Average Quantity Per Unit by Supplier',
             labels={'NumericQuantity': 'Average Quantity', 'SupplierName': 'Supplier'})

# Show the plot to the user
show_to_user(fig)
```","The input code achieves the desired outcome using a different approach but adheres to the same logic and correctly visualizes the average quantity per unit for products supplied by each supplier. Both implementations join suppliers and products, extract relevant numeric data from 'QuantityPerUnit', compute the average, and use Plotly to visualize the result. The code variations like how the numeric quantity is extracted do not affect the correctness relative to the business requirement.",Finetuned
Visualize the average shipping cost per order for the current year.,"```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# SQL query to get the average shipping cost per order for the current year
sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order 
FROM orders 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE())
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a DataFrame to use for plotting
current_year = datetime.now().year
plot_df = pd.DataFrame({
    'Year': [current_year],
    'Average Shipping Cost': df['shipping_cost_per_order']
})

# Visualize the result
fig = px.bar(plot_df, x='Year', y='Average Shipping Cost',
             labels={'Year': 'Year', 'Average Shipping Cost': 'Average Shipping Cost'},
             title='Average Shipping Cost Per Order for the Current Year')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average shipping cost per order for the current year
current_year = pd.to_datetime(""today"").year
sql_query = f""""""
SELECT AVG(orders.Freight) AS average_shipping_cost 
FROM orders 
WHERE YEAR(orders.OrderDate) = {current_year}
""""""

# Execute the SQL query
average_shipping_cost_df = execute_sql_query(sql_query)

# Visualize the result
fig = px.bar(average_shipping_cost_df, x=['average_shipping_cost'], y=['average_shipping_cost'],
             labels={'average_shipping_cost':'Average Shipping Cost ($)'},
             title='Average Shipping Cost per Order for the Current Year')
show_to_user(fig)
```","The input code incorrectly uses a bar chart where the x-axis is set to the column name as a list, and the y-axis is also set to the column name as a list. This setup is incorrect. The input code should create a DataFrame with the current year and average shipping cost, similar to the reference implementation, and then use these for the x and y axes in the plot. The reference code constructs a plot_df DataFrame with 'Year' and 'Average Shipping Cost' columns, using these for the x and y axes, respectively.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the average shipping cost per order for the current year
sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order
FROM orders
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar plot using Plotly
fig = px.bar(df, y='shipping_cost_per_order', title='Average Shipping Cost per Order for the Current Year')

# Display the plot
show_to_user(fig)
```","The input code's SQL query calculates the average shipping cost for orders from the last 365 days, not just for the current year. The condition WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) includes orders from one year before today's date, which does not align with the logic in the reference implementation, which specifically retrieves data for the current calendar year using the condition YEAR(orders.OrderDate) = YEAR(CURDATE()).",None
Visualize the top 3 regions by total sales revenue.,"```python
import plotly.express as px

# SQL query to retrieve the top 3 regions by total sales revenue
sql_query = """"""
SELECT customers.Region, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSalesRevenue 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.Region 
ORDER BY TotalSalesRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Visualize the data using plotly
fig = px.bar(df, x='Region', y='TotalSalesRevenue', title='Top 3 Regions by Total Sales Revenue')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
ORDER BY TotalSales DESC
LIMIT 3;
""""""

top_regions = execute_sql_query(sql_query)
fig = px.bar(top_regions, x='Region', y='TotalSales', title='Top 3 Regions by Total Sales Revenue')
show_to_user(fig)
```","The provided code correctly follows the business analytics request and logic of the reference implementation. It executes a SQL query to retrieve the top 3 regions by total sales revenue, using JOIN operations to combine data from the customers, orders, and order details tables, and it groups and orders the results by TotalSales. The visualization is also created and displayed using Plotly, matching the functionality of the reference code.","```python
import plotly.express as px

# SQL query to get the top 3 regions by total sales revenue
sql_query = """"""
SELECT ShipRegion, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipRegion 
ORDER BY TotalSales DESC 
LIMIT 3;
""""""

# Execute the SQL query
regions_sales_df = execute_sql_query(sql_query)

# Visualize the top 3 regions by total sales revenue
fig = px.bar(regions_sales_df, x='ShipRegion', y='TotalSales', title='Top 3 Regions by Total Sales Revenue')

# Show the visualization to the user
show_to_user(fig)
```","The input code uses 'ShipRegion' from orders and calculates 'TotalSales' based on possibly incorrect grouping, while the reference groups by 'customers.Region'. The join order is also different. This could lead to discrepancies in regions and their sales totals.",Base
Visualize how many orders were placed each month.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY OrderMonth;
""""""

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders placed each month
fig = px.bar(df, x='OrderMonth', y='TotalOrders', title='Monthly Orders Count', labels={'OrderMonth': 'Order Month', 'TotalOrders': 'Total Orders'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

df_orders = execute_sql_query(sql_query)

fig = px.line(df_orders, x='OrderMonth', y='TotalOrders', title='Monthly Orders Placed', labels={'OrderMonth': 'Month', 'TotalOrders': 'Number of Orders'})
show_to_user(fig)
```","The input code uses a line chart instead of a bar chart to visualize the monthly order counts. While both visualizations can convey the information, the reference implementation specifically uses a bar chart. The task requires adherence to the same logic and visualization type as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch data
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
GROUP BY 
    Month;
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Ensure 'Month' is treated as a string for proper sorting
orders_df['Month'] = orders_df['Month'].astype(str)

# Create a line plot to visualize the number of orders per month
fig = px.line(orders_df, x='Month', y='OrderCount', title='Monthly Order Counts')

# Display the plot to the user
show_to_user(fig)
```","The input code uses a line plot instead of a bar chart to visualize the data. The business request specifies the need to visualize how many orders were placed each month, and although both line and bar charts can show this information, the reference implementation specifically uses a bar chart. Adherence to the same visualization type is important for consistency. Additionally, while both the input and reference codes use the same SQL logic, the visualization type differs, leading to a mismatch.",None
Which product has the highest cumulative discount in terms of dollar value?,"```python
# Define the SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Discount * od.UnitPrice * od.Quantity) AS TotalDiscount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalDiscount DESC LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.Discount) AS CumulativeDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY CumulativeDiscount DESC
LIMIT 1;
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code incorrectly calculates the cumulative discount. It uses SUM(od.Quantity * od.Discount), while the reference implementation uses SUM(od.Discount * od.UnitPrice * od.Quantity). The input code must include UnitPrice in the discount calculation to be correct.","```python
import pandas as pd

# SQL query to get the cumulative discount
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * Discount) AS CumulativeDiscount
FROM [Order Details]
GROUP BY ProductID;
""""""

# Execute the SQL query and get the dataframe
df = execute_sql_query(sql_query)

# Find the product with the highest cumulative discount
max_discount_product = df.loc[df['CumulativeDiscount'].idxmax()]

# Display the result
show_to_user(max_discount_product)
```","The input code does not join the 'Order Details' and 'products' tables to obtain the product name, unlike the reference code. It only considers 'ProductID', and lacks additional grouping by 'ProductName' which affects understanding which product has the highest discount.",None
How many different suppliers are there?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT COUNT(DISTINCT SupplierID) as distinct_suppliers FROM products;""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Extract the count from the dataframe and display
distinct_suppliers_count = result_df['distinct_suppliers'][0]
show_to_user(pd.DataFrame({'Distinct Suppliers Count': [distinct_suppliers_count]}))
```","```python
sql_query = ""SELECT COUNT(DISTINCT SupplierID) AS DifferentSuppliers FROM products""
suppliers_count = execute_sql_query(sql_query)
show_to_user(suppliers_count)
```","The input code correctly executes an SQL query to count the distinct SupplierID values from the 'products' table, aligning with the logic of the reference implementation. Both the input and reference get the distinct supplier count and display the result. The column name in the query result ('DifferentSuppliers') is not significant to the correctness, as it doesn't affect the logic or outcome.","```python
import pandas as pd

# SQL query to retrieve the number of suppliers
sql_query = ""SELECT COUNT(DISTINCT SupplierID) AS SupplierCount FROM products;""

# Execute the SQL query using the provided utility function
supplier_count_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(supplier_count_df)
```","The input code correctly executes the SQL query to count distinct SupplierID from the products table, just like the reference code. Both use COUNT(DISTINCT SupplierID) to obtain the number of unique suppliers. The result is then displayed to the user; however, the input code directly uses the result dataframe without extracting the count into a new dataframe. Despite this, it fulfills the analytics request and follows the same logic as the reference implementation.",both
Visualize the correlation between freight cost and fulfillment time.,"```python
import plotly.express as px

# SQL query
sql_query = ""SELECT Freight, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders;""

# Execute the query and retrieve data
df = execute_sql_query(sql_query)

# Create a scatter plot to visualize the correlation
fig = px.scatter(df, x='Freight', y='FulfillmentTime', 
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (days)'})

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS FulfillmentTime,
    AVG(Freight) AS FreightCost
FROM 
    orders
GROUP BY 
    MONTH(OrderDate), YEAR(OrderDate)
""""""

data = execute_sql_query(sql_query)

fig = px.scatter(data, x='FreightCost', y='FulfillmentTime', 
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'FreightCost': 'Freight Cost', 'FulfillmentTime': 'Average Fulfillment Time (Days)'})

show_to_user(fig)
```","The provided code calculates the average Freight and Fulfillment Time grouped by month and year. This aggregation changes the nature of data and correlation analysis compared to the reference, which uses per-order values. Aggregates can't visualize per-order correlations directly.","Here's how you can visualize the correlation between freight cost and fulfillment time using the provided Python code and libraries:

```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT freight, DATEDIFF(shipped_date, order_date) AS fulfillment_time
FROM orders;
""""""

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Visualize the correlation using a scatter plot
fig = px.scatter(df, x='freight', y='fulfillment_time', 
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'freight': 'Freight Cost', 'fulfillment_time': 'Fulfillment Time'})

# Show the plot to the user
show_to_user(fig)
```

This code retrieves data using `execute_sql_query`, creates a scatter plot with Plotly using `plotly.express`, and displays the plot using `show_to_user`.","The input Python code fulfills the business analytics request by accurately visualizing the correlation between freight cost and fulfillment time, as requested. The SQL query retrieves the correct fields: `freight` and the difference between `shipped_date` and `order_date` (as `fulfillment_time`). This aligns with the reference implementation which uses similar logic with different variable names for SQL fields but equivalent SQL logic. The scatter plot in the input code correctly visualizes these fields similarly to the reference code using Plotly, maintaining the necessary labels and title. The `show_to_user` function is used to display the plot, which is consistent with the reference implementation's approach.",Finetuned
Which employee made the highest sales on a specific date?,"```python
from datetime import datetime
import pandas as pd

# Define the date for which we want to find the highest sales
target_date = 'YYYY-MM-DD'

# SQL query to find the employee with the highest sales on the specific date
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate = '{target_date}' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC LIMIT 1;
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
import pandas as pd

specific_date = '2023-10-01'

sql_query = f""""""
SELECT e.EmployeeID, 
       e.FirstName, 
       e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate = '{specific_date}'
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

highest_sales_employee = execute_sql_query(sql_query)
show_to_user(highest_sales_employee)
```","The input Python code correctly follows the logic of the reference implementation. It uses an SQL query to fetch the employee with the highest sales on a specified date, '2023-10-01', similar to the reference. It correctly selects the total sales, orders by 'TotalSales' descending, and limits the output to 1, which matches the reference implementation's approach.","```python
import pandas as pd

# Define SQL query to get employee with highest sales on a specific date
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate = 'YOUR_SPECIFIC_DATE'
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 1
""""""

# Execute SQL query
sales_data = execute_sql_query(sql_query)

# Display the result
show_to_user(sales_data)
```","The provided code does not select 'FirstName' and 'LastName' in the SQL query, which are included in the reference implementation. This omission makes it incomplete in terms of capturing the required employee details.",Base
What is the average unit price of products in each category? (Consider visualizing the average unit prices by category using a bar chart for easier comparison.),"```python
import plotly.express as px

# SQL query to execute
sql_query = ""SELECT CategoryID, AVG(UnitPrice) AS AveragePrice FROM products GROUP BY CategoryID;""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit prices by category
fig = px.bar(df, x='CategoryID', y='AveragePrice', title='Average Unit Price by Category')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_prices_df = execute_sql_query(sql_query)

fig = px.bar(average_prices_df, x='CategoryID', y='AverageUnitPrice', 
             title='Average Unit Price by Category', 
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})

show_to_user(fig)
```","The input code accurately retrieves the average unit price of products grouped by category from the database and visualizes the results using a bar chart. It uses the SQL query to compute the average prices, stores the results in a DataFrame, and creates a Plotly bar chart similar to the reference implementation. The differences in naming (e.g., 'AverageUnitPrice' vs. 'AveragePrice') and labels for the axes do not affect the correctness as the logic and functionality remain aligned with the reference code.","```python
import pandas as pd
import plotly.express as px

# Query to get the average unit price of products in each category
sql_query = """"""
SELECT c.CategoryName, AVG(p.UnitPrice) AS AverageUnitPrice 
FROM products p 
JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit prices by category
fig = px.bar(df, x='CategoryName', y='AverageUnitPrice', title='Average Unit Price by Category', labels={'AverageUnitPrice': 'Average Unit Price', 'CategoryName': 'Category'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code is correct because it adheres to the requirements and logic of the business analytics request. Both the reference and input implementations calculate the average unit price of products by category and visualize it using a bar chart. The input code enhances the result by providing a more informative axis label ('CategoryName' instead of 'CategoryID') by joining the 'categories' table to obtain category names, which preserves the intended logic.",both
Which product had the highest sales revenue in 2022?,"```python
import pandas as pd

# SQL query to find the product with highest sales revenue in 2022
sql_query = """"""
SELECT products.ProductID, 
       products.ProductName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, products.ProductName
ORDER BY product_sales DESC 
LIMIT 1
""""""

# Execute the SQL query and retrieve the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = 2022 
GROUP BY products.ProductID, products.ProductName 
ORDER BY total_revenue DESC 
LIMIT 1
""""""

highest_sales_product = execute_sql_query(sql_query)
show_to_user(highest_sales_product)
```","The input code correctly queries for the product with the highest sales revenue in 2022. It calculates the total revenue using the same fields (UnitPrice, Quantity, Discount) and applies the correct summarization and filtering logic. Despite minor differences in formatting, both codes group by ProductID and ProductName, order by the calculated total sales, and limit the result to one productâ€”making the logic consistent with the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = 2022 
GROUP BY products.ProductID 
ORDER BY product_sales DESC 
LIMIT 1;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(sales_data)
```","The input code does not select the ProductName, which is required to fully answer the business analytics request. The reference implementation retrieves both ProductID and ProductName, whereas the input code only retrieves ProductID.",Base
How many orders have been placed by each customer? (A bar chart can be used to visualize the number of orders per customer.),"```python
import plotly.express as px

# SQL query to get the order count per customer
sql_query = ""SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Creating a bar chart using plotly
fig = px.bar(orders_df, x='CustomerID', y='OrderCount', title='Number of Orders per Customer')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
""""""

orders_per_customer = execute_sql_query(sql_query)

fig = px.bar(orders_per_customer, x='CustomerID', y='OrderCount', 
             title='Number of Orders per Customer', 
             labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```","The input Python code correctly executes a SQL query to count orders by CustomerID and groups them as required. It uses plotly to create a bar chart of the order counts per customer, similar to the reference implementation. The ordering of results by 'OrderCount' does not affect the correctness related to the request. Therefore, the logic used and the final outcome align with the reference code requirements.","```python
import plotly.express as px

# SQL query to get number of orders per customer
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS orders_count 
FROM orders 
GROUP BY CustomerID
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_df, x='CustomerID', y='orders_count', title='Number of Orders per Customer')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly answers the business analytics request. It uses a SQL query to count the number of orders per customer, grouping by CustomerID, just like the reference code. The query result is stored in the same way, and the bar chart is created using Plotly with the same parameters for visualization. The minor difference in the alias name ('orders_count' vs 'OrderCount') does not affect the correctness of the logic. Therefore, the input code aligns with the intent of the reference implementation.",both
Which employee generated the most sales in Q4 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 1
""""""

# Execute the SQL query using the utility function
sales_data_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_data_df)
```","```python
sql_query = """"""
SELECT employees.EmployeeID, 
       employees.FirstName, 
       employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY total_sales DESC
LIMIT 1
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code answers the business question and follows the same logic as the reference implementation. The input code includes additional fields (FirstName and LastName) in the SELECT clause and GROUP BY statement, which do not affect the correctness of identifying the employee with the most sales. Both codes calculate total sales for employees in Q4 2023 and order them to find the top seller.","```python
import pandas as pd

# SQL query to get the EmployeeID and total sales for Q4 2023
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```",The input code is correct as it follows the same logic as the reference implementation. Both SQL queries accurately calculate the total sales for each employee in Q4 2023 and return the employee with the highest sales. The execution and result display steps are also equivalent.,both
"What is the maximum, minimum, and average salary of the employees? (A box plot can visualize salary distribution effectively.)","```python
import plotly.express as px

# Define SQL query
sql_query = ""SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees;""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Display max, min, and average salary
show_to_user(result_df)

# Query to get salary data for box plot
salary_query = ""SELECT Salary FROM employees;""

# Execute query to get all salaries
salary_df = execute_sql_query(salary_query)

# Create box plot for salary distribution
fig = px.box(salary_df, y='Salary', title='Salary Distribution')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees;""
salary_stats = execute_sql_query(sql_query)

fig = px.box(salary_stats, y=['MaxSalary', 'MinSalary', 'AvgSalary'], title=""Salary Distribution"")
show_to_user(fig)
```","The input code incorrectly visualizes the statistics (max, min, avg) instead of individual salaries. The reference code executes a separate query to collect all individual salaries for a box plot, which accurately visualizes the salary distribution. The input code does not meet this requirement and plots incorrect data.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the necessary salary statistics
sql_query = """"""
SELECT 
    MAX(Salary) AS MaxSalary,
    MIN(Salary) AS MinSalary,
    AVG(Salary) AS AvgSalary
FROM employees;
""""""

# Execute the SQL query
salary_stats_df = execute_sql_query(sql_query)

# Display the salary statistics
show_to_user(salary_stats_df)

# SQL query to retrieve all employees' salaries for box plot
sql_query_boxplot = ""SELECT Salary FROM employees;""

# Execute the SQL query for the box plot
salaries_df = execute_sql_query(sql_query_boxplot)

# Create a box plot for salary distribution
fig = px.box(salaries_df, y=""Salary"", title=""Salary Distribution of Employees"")

# Adjust x-axis title
fig.update_layout(yaxis_title=""Salary"")

# Display the box plot to the user
show_to_user(fig)
```","The input code captures the same logic as the reference code. It executes the SQL queries to get the maximum, minimum, and average salary, and then creates a box plot for the salary distribution. Both the input and reference codes use SQL queries to retrieve necessary statistics and salaries, display them using a function like 'show_to_user', and use Plotly to create a box plot. The input code also includes a slight additional step to update the y-axis title, which does not affect the correctness concerning the business analytics request.",Finetuned
What is the average discount given per order in the last week?,"```python
import pandas as pd

# SQL query to retrieve average discount per order in the last week
sql_query = """"""
SELECT AVG([Order Details].Discount) AS Average_Discount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 WEEK);
""""""

# Execute SQL query and get the result as a dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['Average_Discount'][0])
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate the date for one week ago
last_week_date = (datetime.now() - timedelta(days=7)).date()

# SQL query to calculate the average discount per order in the last week
sql_query = f""""""
SELECT AVG(Discount) AS AverageDiscountPerOrder
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= '{last_week_date}'
""""""

# Execute the SQL query
average_discount_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_discount_df)
```","The input code calculates the average discount per order in the last week similar to the reference implementation. Both implementations use a JOIN between 'orders' and 'Order Details' tables and apply a WHERE clause to filter orders from the last week. The SQL syntax and logic align with the task requirement, even though the execution methods slightly differ.","```python
import pandas as pd

# SQL query to calculate the average discount per order in the last week
sql_query = """"""
SELECT AVG([Order Details].Discount) AS AverageDiscount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate >= CURDATE() - INTERVAL 7 DAY;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average discount value
average_discount = result_df['AverageDiscount'].iloc[0]

# Prepare data for display
display_df = pd.DataFrame({'AverageDiscount': [average_discount]})

# Display the result
show_to_user(display_df)
```","Both implementations calculate the average discount for orders in the last week using a SQL query, and there are only minor differences in the SQL syntax, which do not affect the logic or results. Both use a 'JOIN' to combine tables on 'OrderID' and filter using the date range 'orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 WEEK)' vs. 'orders.OrderDate >= CURDATE() - INTERVAL 7 DAY', which are equivalent. The handling of output is also effectively the same.",both
What is the average order value for the year 2022?,"```python
import pandas as pd

# SQL query to calculate average order value for the year 2022
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) 
       / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the average order value from the DataFrame
average_order_value = df['avg_order_value'].iloc[0]

# Display the result to user
show_to_user(average_order_value)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

average_order_value = execute_sql_query(sql_query)
show_to_user(average_order_value)
```","The input code directly assigns the result of `execute_sql_query` to `average_order_value`. This assumes that `average_order_value` is directly a numeric value, whereas it should be extracted from the resulting DataFrame, as shown in the reference code (`df['avg_order_value'].iloc[0]`). Without this extraction step, `show_to_user` is likely called with an incorrect data structure.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
    SELECT 
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
    FROM 
        orders 
    JOIN 
        [Order Details] ON orders.OrderID = [Order Details].OrderID 
    WHERE 
        orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute the SQL query and get the result as a dataframe
df = execute_sql_query(sql_query)

# Extract the average order value from the dataframe
avg_order_value = df['avg_order_value'].iloc[0]

# Display the result to the user
show_to_user({'Average Order Value (2022)': avg_order_value})
```","The input code is correct as it computes the average order value for the orders placed in 2022, using the same logic as the reference code. It calculates the total value of all orders by summing the product of unit price, quantity, and discount factor, and divides by the count of distinct order IDs. The only difference is in the presentation of the result, where the input code formats it as a dictionary, which does not affect the correctness of the calculation.",Finetuned
How many orders were placed by each customer in the last quarter of 2022? (Consider visualizing this using a bar chart for better insights.),"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
  SELECT CustomerID, COUNT(OrderID) AS OrderCount 
  FROM orders 
  WHERE OrderDate BETWEEN '2022-10-01' AND '2022-12-31' 
  GROUP BY CustomerID
""""""

# Execute the SQL query and get the result as a dataframe
orders_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(orders_data, x='CustomerID', y='OrderCount', title='Orders by Customer in Q4 2022')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= '2022-10-01' AND OrderDate < '2023-01-01'
GROUP BY CustomerID
""""""

orders_count = execute_sql_query(sql_query)

fig = px.bar(orders_count, x='CustomerID', y='OrderCount', title='Orders Placed by Each Customer in Q4 2022')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It uses an equivalent SQL query to select the count of orders per customer between October 1, 2022, and December 31, 2022, which aligns with Q4 2022. The query logic is equivalent as it considers an inclusive start date and an exclusive end date ('2023-01-01'), which is a valid approach. Additionally, the visualization is correctly created using Plotly and displayed to the user. Therefore, the input code fulfills the requirements of the task.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS OrderCount 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate BETWEEN '2022-10-01' AND '2022-12-31' 
GROUP BY customers.CustomerID
""""""

# Execute SQL query to get data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders by each customer
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Orders by Customer in Q4 2022')

# Show the visualization
show_to_user(fig)
```","The provided Python code correctly matches the logic of the reference implementation. It is filtering orders placed in the last quarter of 2022 and grouping them by CustomerID to count the number of orders per customer. The use of a join with the 'customers' table is valid as it ensures that the CustomerID is accurately related to an order. The bar chart visualization correctly displays this information. Thus, the input code fulfills the business analytics request.",both
What is the total quantity of products ordered in each month of the current year? (A line chart or bar chart can illustrate monthly totals.),"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(od.Quantity) AS TotalQuantityOrdered 
FROM `Order Details` od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY Month;
""""""

# Execute SQL query and get data
df = execute_sql_query(sql_query)

# Create a line chart to represent the total quantity ordered each month
fig = px.line(df, x='Month', y='TotalQuantityOrdered', title='Total Quantity of Products Ordered Each Month in Current Year', labels={'TotalQuantityOrdered': 'Total Quantity Ordered'})

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_year = datetime.now().year

sql_query = f""""""
SELECT 
    MONTH(OrderDate) AS Month,
    SUM([Order Details].Quantity) AS TotalQuantity
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    YEAR(OrderDate) = {current_year}
GROUP BY 
    MONTH(OrderDate)
ORDER BY 
    Month;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='Month', y='TotalQuantity', labels={'Month': 'Month', 'TotalQuantity': 'Total Quantity Ordered'}, title='Total Quantity of Products Ordered Each Month')
show_to_user(fig)
```","The input code correctly implements the logic to calculate the total quantity of products ordered per month for the current year. It uses SQL to summarize the data similarly to the reference code and retrieves the necessary information. The code uses MONTH(OrderDate) for grouping, which aligns with the desired monthly summation, and correctly executes and visualizes the results using a bar chart. The differences lie in using a bar chart instead of a line chart and handling SQL query formatting specificities (e.g., brackets for table names), both of which do not impact the main objective.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
SUM([Order Details].Quantity) AS TotalQuantity 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE()) 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate monthly totals
fig = px.bar(df, x='Month', y='TotalQuantity', title='Total Quantity of Products Ordered Per Month')

# Display the chart
show_to_user(fig)
```","The input code correctly calculates the total quantity of products ordered each month in the current year. It uses a SQL query with a date format to group by month and sums the quantities. The query logic matches the reference code. The visualization uses a bar chart instead of a line chart, which is an acceptable modification for illustrating monthly totals as both are effective for this purpose.",both
How many orders included products with more than a 10% discount?,"```python
import pandas as pd

# Define SQL query to count distinct orders with more than 10% discount
sql_query = """"""
SELECT COUNT(DISTINCT od.OrderID) as NumberOfOrders 
FROM [Order Details] od 
WHERE od.Discount > 0.10
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df['NumberOfOrders'][0])
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT od.OrderID) AS OrderCount
FROM [Order Details] od
WHERE od.Discount > 0.10
""""""
order_count_df = execute_sql_query(sql_query)
show_to_user(order_count_df)
```",The input code correctly counts distinct orders with more than 10% discount but fails to display the exact value. It outputs the DataFrame containing the count instead of directly displaying the value as in the reference implementation.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT COUNT(DISTINCT OrderID) as QuantityOfOrders 
FROM `Order Details` 
WHERE Discount > 0.1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the count value from the result
quantity_of_orders = result_df['QuantityOfOrders'].iloc[0]

# Create a new DataFrame for the output
output_df = pd.DataFrame({'QuantityOfOrders': [quantity_of_orders]})

# Show the result to the user
show_to_user(output_df)
```","The input Python code correctly addresses the business analytics request by counting distinct orders with more than a 10% discount. It follows the same logic as the reference implementation, differing only in variable naming and the format of the output displayed to the user. The SQL logic is consistent, and the extraction of results from the executed query aligns with the reference code.",Finetuned
What is the inventory turnover ratio for the past month?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 MONTH')
AND EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '1 MONTH');
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate Inventory Turnover Ratio for the past month
sql_query = """"""
SELECT 
    SUM(od.Quantity * od.UnitPrice) AS CostOfGoodsSold,
    AVG(p.UnitsInStock) AS AverageInventory
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    od.OrderID IN (
        SELECT OrderID FROM Orders WHERE OrderDate >= DATEADD(month, -1, GETDATE())
    )
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate the Inventory Turnover Ratio
if not result_df.empty:
    turnover_ratio = result_df['CostOfGoodsSold'].iloc[0] / result_df['AverageInventory'].iloc[0]
else:
    turnover_ratio = None

# Create a DataFrame to display the result
turnover_ratio_df = pd.DataFrame({'Inventory Turnover Ratio': [turnover_ratio]})

# Display the result to the user
show_to_user(turnover_ratio_df)
```","The input code does not correctly calculate the Inventory Turnover Ratio. The input code's subquery gets orders from 'Orders' where 'OrderDate' is within the last month using DATEADD, which may not restrict to exactly the past calendar month. Also, 'GETDATE()' and DATEADD do not align with the reference code's logic using CURRENT_DATE and EXTRACT for exact month matching. The reference implementation calculates turnover specifically for the past month using SQL date functions to extract year and month, ensuring accuracy.","```python
import pandas as pd

# SQL query to get the inventory turnover ratio for the past month
sql_query = """"""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    [Order Details] 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    [Order Details].OrderID IN (
        SELECT OrderID FROM orders WHERE MONTH(OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) AND YEAR(OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH)
    )
""""""

# Execute the SQL query
inventory_turnover_ratio_df = execute_sql_query(sql_query)

# Display the result
show_to_user(inventory_turnover_ratio_df)
```","Both code implementations calculate the inventory turnover ratio for the past month. They achieve this using the sum of Quantity times UnitPrice divided by the average UnitsInStock, filtered by orders from the previous month, using similar logic for date extraction and comparisons. Although the input code uses a subquery for filtering orders by date, it effectively performs the same operation as the reference code.",Finetuned
Find the top 3 cities with the most orders placed. (A bar chart can be useful to visualize and compare the top cities.),"```python
import plotly.express as px

# SQL query to get the top 3 cities with the most orders placed
sql_query = """"""
SELECT ShipCity, COUNT(*) AS total_orders 
FROM orders 
GROUP BY ShipCity 
ORDER BY total_orders DESC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top cities
fig = px.bar(df, x='ShipCity', y='total_orders', title='Top 3 Cities with Most Orders', labels={'ShipCity': 'City', 'total_orders': 'Total Orders'})

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.City, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.City
ORDER BY OrderCount DESC
LIMIT 3;
""""""

top_cities_df = execute_sql_query(sql_query)

fig = px.bar(top_cities_df, x='City', y='OrderCount', title='Top 3 Cities with Most Orders', 
             labels={'OrderCount': 'Number of Orders', 'City': 'City'})
show_to_user(fig)
```","Both the input and reference code effectively achieve the same objective of finding the top 3 cities with the most orders. The input code correctly joins the customers and orders tables, groups by city, counts orders, and limits to the top 3. The bar chart visualization uses similar parameters, with the same logic applied to extract and visualize the data. The differences in table names or join logic are valid variations that still satisfy the request.","```python
import plotly.express as px

# SQL query to get top 3 cities with most orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ShipCity', y='OrderCount', title='Top 3 Cities with Most Orders')

# Show the figure to the user
show_to_user(fig)
```","The input code correctly implements the logic to find the top 3 cities with the most orders placed. It uses a SQL query to select cities grouped by ShipCity, counts the orders using COUNT(OrderID), orders the result by the order count in descending order, and limits the output to 3. This logic matches the reference implementation. Additionally, a bar chart is created using Plotly to visualize the data, which is also consistent with the reference.",both
What is the average shipping cost per order for orders shipped to 'Canada'?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Freight) AS AverageShippingCost FROM orders WHERE ShipCountry = 'Canada';""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Since the result is a single value in a DataFrame, extract and print it.
average_shipping_cost = df['AverageShippingCost'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'AverageShippingCost': [average_shipping_cost]}))
```","```python
sql_query = """"""
SELECT AVG(Freight) AS average_shipping_cost
FROM orders
WHERE ShipCountry = 'Canada'
""""""
average_shipping_cost_df = execute_sql_query(sql_query)
show_to_user(average_shipping_cost_df)
```","The input code correctly computes the average shipping cost for orders shipped to 'Canada'. It uses the same SQL query logic as the reference implementation to calculate the average of the 'Freight' column where 'ShipCountry' is 'Canada'. It then directly displays the result using 'show_to_user', which matches the intended outcome of the reference code.","```python
import pandas as pd

# SQL query to get the average shipping cost for orders shipped to 'Canada'
sql_query = ""SELECT AVG(orders.Freight) AS avg_shipping_cost FROM orders WHERE orders.ShipCountry = 'Canada';""

# Execute the query using the provided utility function
df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(df.iloc[0]['avg_shipping_cost'])
```","Both the reference and input code execute a SQL query to calculate the average freight cost for orders shipped to Canada. The structure of the query is identical, and both retrieve and display the result. While the input code uses a slightly different method to access and show the result, the logic and outcome are the same, fulfilling the business analytics request.",both
What is the retention rate of customers comparing the first half of 2023 to the previous year? (A line graph could help show changes in retention rates over time.),"```python
import pandas as pd
import plotly.express as px

# Define SQL queries
first_half_2023_query = """"""
SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_2023_1H
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
""""""

previous_year_query = """"""
SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_prev_year
FROM orders o 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute queries
first_half_2023_df = execute_sql_query(first_half_2023_query)
previous_year_df = execute_sql_query(previous_year_query)

# Calculate retention rate
customer_retention_rate = (first_half_2023_df['customer_count_2023_1H'][0] / 
                           previous_year_df['customer_count_prev_year'][0])

# Create DataFrame for visualization
retention_data = pd.DataFrame({
    'Period': ['First Half 2023'],
    'Retention Rate': [customer_retention_rate]
})

# Visualize retention rate
fig = px.line(retention_data, x='Period', y='Retention Rate', 
              title='Customer Retention Rate: First Half 2023 vs Previous Year')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL queries for retention rates
first_half_2023_query = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS returning_customers
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
""""""

previous_year_query = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS total_customers
FROM orders
WHERE orders.OrderDate < '2023-01-01'
""""""

# Execute the queries
first_half_2023_df = execute_sql_query(first_half_2023_query)
previous_year_df = execute_sql_query(previous_year_query)

# Calculate retention rate
returning_customers = first_half_2023_df['returning_customers'][0]
total_customers = previous_year_df['total_customers'][0]

retention_rate = returning_customers / total_customers if total_customers > 0 else 0

# Create DataFrame for visualization
retention_data = pd.DataFrame({
    'Period': ['First Half 2023', 'Previous Year'],
    'Retention Rate': [retention_rate, total_customers]
})

# Plot line graph for retention rates
fig = px.line(retention_data, x='Period', y='Retention Rate', title='Customer Retention Rate Comparison')
show_to_user(fig)
```","The input code incorrectly calculates the retention rate and its visualization. It computes 'returning_customers' only for the first half of 2023 and compares it to 'total_customers' who ordered before 2023. The reference code calculates the ratio of unique customers in the first half of 2023 to those throughout 2022, which accurately represents retention relative to the previous year. Additionally, the input code includes an incorrect period 'Previous Year' in the DataFrame for retention visualization, which doesn't exist in the context of retention rate computation, contrasting the reference logic.","To analyze the retention rate of customers comparing the first half of 2023 to the previous year using a line graph, we need to calculate the retention rate for both periods. The formula for retention rate is:

\[
\text{Retention Rate} = \frac{\text{Number of Returning Customers}}{\text{Total Number of Customers in Previous Period}}
\]

Here's a step-by-step process to retrieve, calculate, and visualize this data:

### Step 1: SQL Queries

1. **Get Returning Customers for H1 2023**:
   - Customers who placed an order between January 1, 2023, and June 30, 2023.

   ```sql
   SELECT customer_id 
   FROM orders 
   WHERE order_date BETWEEN '2023-01-01' AND '2023-06-30'
   ```

2. **Get Total Customers for H1 2022**:
   - Customers who placed an order between January 1, 2022, and June 30, 2022.

   ```sql
   SELECT customer_id 
   FROM orders 
   WHERE order_date BETWEEN '2022-01-01' AND '2022-06-30'
   ```

### Step 2: Execute SQL Queries

Using the provided Python function, execute the SQL queries and retrieve the data.

### Step 3: Calculate Retention Rates

The retention rates can be calculated as shown below.

### Step 4: Visualization

We will use the retention rates over the specified periods to create a line graph.

### Python Code

```python
import pandas as pd
import plotly.express as px

# SQL Queries
query_h1_2023 = """"""
SELECT customer_id 
FROM orders 
WHERE order_date BETWEEN '2023-01-01' AND '2023-06-30'
""""""

query_h1_2022 = """"""
SELECT customer_id 
FROM orders 
WHERE order_date BETWEEN '2022-01-01' AND '2022-06-30'
""""""

# Execute SQL Queries
df_h1_2023 = execute_sql_query(query_h1_2023)
df_h1_2022 = execute_sql_query(query_h1_2022)

# Calculate Retention Rates
retention_rate_2023 = len(df_h1_2023['customer_id'].unique()) / len(df_h1_2022['customer_id'].unique())
retention_rate_2022 = len(df_h1_2022['customer_id'].unique()) / len(df_h1_2022['customer_id'].unique())

# Prepare Data for Visualization
data = {
    'period': ['H1 2023', 'H1 2022'],
    'retention_rate': [retention_rate_2023, retention_rate_2022]
}
df_retention = pd.DataFrame(data)

# Create a line graph
fig = px.line(df_retention, x='period', y='retention_rate', title='Customer Retention Rate Comparison')
show_to_user(fig)
```

This code calculates the customer retention rates for the first half of 2023 compared to the previous year and visualizes this information in a line graph. The `show_to_user` function is invoked to display this graph to the user.","The evaluated Python code calculates retention rates by comparing distinct customers in H1 2023 to H1 2022, while the reference code compares H1 2023 to the entire previous year (2022). Retention should be calculated based on the total customers of the previous period (i.e., the entire 2022) to match the logic of the reference implementation.",None
How many distinct products have been ordered?,"```python
import pandas as pd

# SQL query to get the distinct product IDs
sql_query = ""SELECT DISTINCT ProductID FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate the count of distinct products
distinct_product_count = len(result_df)

# Display the result to the user
show_to_user(pd.DataFrame({'DistinctProducts': [distinct_product_count]}))
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT ProductID) AS DistinctProducts
FROM [Order Details]
""""""
distinct_products_df = execute_sql_query(sql_query)
show_to_user(distinct_products_df)
```","The input code correctly calculates and displays the number of distinct products ordered by using a SQL query that counts distinct ProductID entries. Although it approaches the task differently by retrieving the aggregated count directly from SQL and presenting it, it adheres to the same logic and achieves the intended outcome of determining the number of distinct products.","```python
import pandas as pd

# SQL query to count distinct products
sql_query = ""SELECT COUNT(DISTINCT ProductID) AS DistinctProductsOrdered FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the count value
distinct_count = result_df['DistinctProductsOrdered'].iloc[0]

# Prepare the result to display
result_to_display = pd.DataFrame({'DistinctProductsOrdered': [distinct_count]})

# Display the result to the user
show_to_user(result_to_display)
```","The evaluated Python code correctly answers the business analytics request by counting the distinct products ordered. Both the reference implementation and the evaluated code achieve the same goal. The reference code uses a method to collect distinct ProductIDs and counts them, while the evaluated code directly counts distinct ProductIDs using SQL. Both approaches result in the correct distinct product count. Therefore, the evaluated code is correct.",both
How many orders were placed each month by each customer? (A stacked bar chart might provide a clear visual representation.),"```python
import plotly.express as px

# Step 1: Execute SQL Query
sql_query = """"""
SELECT c.CustomerID, DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth, 
COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID, OrderMonth;
""""""
df = execute_sql_query(sql_query)

# Step 2: Create a stacked bar chart
fig = px.bar(df, x='OrderMonth', y='OrderCount', color='CustomerID', 
             title='Monthly Orders by Customer', 
             labels={'OrderMonth':'Order Month', 
                     'OrderCount':'Order Count', 
                     'CustomerID':'Customer ID'}, 
             barmode='stack')

# Step 3: Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    DATE_TRUNC('month', o.OrderDate) AS OrderMonth, 
    COUNT(o.OrderID) AS OrderCount
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
GROUP BY 
    c.CustomerID, c.CompanyName, OrderMonth
ORDER BY 
    OrderMonth, c.CustomerID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, 
             x='OrderMonth', 
             y='OrderCount', 
             color='CompanyName', 
             title='Monthly Orders by Each Customer',
             labels={'OrderMonth': 'Order Month', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The reference implementation uses 'CustomerID' for coloring the bars in the chart, while the input code uses 'CompanyName'. This results in differences in how customers are represented visually. Additionally, the input code uses 'DATE_TRUNC('month', o.OrderDate)' which might alter the date formatting compared to the reference's 'DATE_FORMAT(o.OrderDate, '%Y-%m')'. The input code includes 'CompanyName' in the SELECT and GROUP BY clauses, which is not present in the reference code. These differences mean the input code does not adhere to the same logic as the reference implementation.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    CustomerID, 
    EXTRACT(MONTH FROM OrderDate) AS Month, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
GROUP BY 
    CustomerID, Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a stacked bar chart
fig = px.bar(df, x='Month', y='OrderCount', color='CustomerID', title='Monthly Orders per Customer',
             labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})

# Show the chart
show_to_user(fig)
```","The input code does not match the reference implementation or the business request in terms of grouping by both CustomerID and a formatted year-month. The reference groups by CustomerID and a formatted monthly string (YYYY-MM), whereas the input code only extracts the month and lacks the year component, which would combine data from different years incorrectly. Therefore, it does not fulfill the request to detail orders for each month by each customer.",None
What is the hire date of the oldest employee?,"```python
import pandas as pd

# Execute the SQL query to get the oldest employee's hire date
sql_query = ""SELECT e.FirstName, e.LastName, e.HireDate FROM employees e ORDER BY e.HireDate ASC LIMIT 1""
oldest_employee_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(oldest_employee_df)
```","```python
sql_query = """"""
SELECT HireDate 
FROM employees 
ORDER BY HireDate 
LIMIT 1;
""""""

oldest_employee_hire_date = execute_sql_query(sql_query)
show_to_user(oldest_employee_hire_date)
```","The provided code correctly queries the hire date of the oldest employee by ordering the employees by HireDate in ascending order and selecting the first entry, which is functionally equivalent to the reference implementation. Both codes aim to return the same data. The reference code fetches additional columns, but for the question of getting the oldest hire date, the provided code is sufficient and follows the same logic.","```python
import pandas as pd

# SQL query to get the hire date of the oldest employee
sql_query = """"""
SELECT EmployeeID, HireDate FROM employees ORDER BY HireDate ASC LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the hire date
oldest_employee_hire_date = result_df['HireDate'].iloc[0]

# Display the result
show_to_user(oldest_employee_hire_date)
```","The input code correctly identifies the hire date of the oldest employee by ordering the employees based on their hire date in ascending order and selecting the first record. This matches the logic of the reference implementation, which also sorts employees by hire date and retrieves the earliest one. The input and reference codes execute similar operations, ensuring the correct hire date is returned, though they differ in selecting additional columns.",both
How many order details entries have a discount greater than 10%?,"```python
import pandas as pd

# The SQL query to get the count of order details entries with a discount greater than 10%
sql_query = ""SELECT COUNT(*) as count FROM [Order Details] WHERE Discount > 0.1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the count result to the user
show_to_user(result_df['count'][0])
```","```python
sql_query = """"""
SELECT COUNT(*) AS DiscountedOrders
FROM [Order Details]
WHERE Discount > 0.10
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly executes a SQL query to count the number of entries in the 'Order Details' table where the discount is greater than 10%. The SQL syntax and logic align with the reference implementation, and the result is shown to the user using show_to_user, which matches the reference code's intent.","```python
import pandas as pd

# SQL Query to get the count of order details with a discount greater than 10%
sql_query = ""SELECT COUNT(*) AS discount_count FROM [Order Details] WHERE Discount > 0.10;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user (show 'discount_count' column only)
show_to_user(result_df['discount_count'])
```","The input Python code is correct. It queries the database for the count of order details entries with a discount greater than 10%. The logic and expected result match the reference implementation, with a minor difference in column alias 'discount_count' instead of 'count', which does not affect the correctness of the solution.",both
Which supplier has the highest average lead time? (A bar chart can highlight differences among suppliers.),"```python
import plotly.express as px

# SQL query to retrieve data on suppliers and their average lead time
sql_query = """"""
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY s.CompanyName 
ORDER BY AverageLeadTime DESC
""""""

# Execute the SQL query and get the data in a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to highlight differences among suppliers
fig = px.bar(df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    s.SupplierID, 
    s.CompanyName, 
    AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    orders o ON o.OrderID IN (SELECT OrderID FROM `Order Details` od WHERE od.ProductID = p.ProductID)
GROUP BY 
    s.SupplierID, s.CompanyName
ORDER BY 
    AvgLeadTime DESC
""""""

lead_time_data = execute_sql_query(sql_query)
fig = px.bar(lead_time_data, x='CompanyName', y='AvgLeadTime', title='Average Lead Time by Supplier', labels={'AvgLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","Both implementations use a similar approach to finding the supplier with the highest average lead time. They join the relevant tables to calculate the average lead time and then create a bar chart to visualize the results. Although the input code uses a slightly different SQL approach to join the orders and products, it still achieves the same outcome by calculating the average lead time per supplier. The grouping and ordering also match the reference implementation, ensuring correctness of the logic.","```python
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT SupplierID, AVG(DATEDIFF(OrderDate, RequiredDate)) AS AverageLeadTime 
FROM products 
JOIN orders ON products.ProductID = orders.ProductID 
GROUP BY SupplierID 
ORDER BY AverageLeadTime DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize average lead time by supplier
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code calculates the average lead time using `DATEDIFF(OrderDate, RequiredDate)`, while the reference uses `DATEDIFF(o.ShippedDate, o.OrderDate)`. Additionally, the input code aggregates by `SupplierID` directly from the `products` table, which doesn't align with the reference that joins multiple tables. This difference in logic and data fields results in an incorrect implementation relative to the business analytics request and reference.",Base
Identify employees whose orders had the highest average discount applied. (Consider using a bar chart to visualize discounts by employee.),"```python
import plotly.express as px

# SQL query to retrieve required data
sql_query = """"""
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY AvgDiscount DESC;
""""""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Visualize the average discount by employee using a bar chart
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', title='Average Discount by Employee')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY AvgDiscount DESC
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Visualize the discounts by employee
fig = px.bar(data, x='EmployeeName', y='AvgDiscount', 
             title='Average Discount Applied by Employee',
             labels={'AvgDiscount': 'Average Discount', 'EmployeeName': 'Employee'},
             color='AvgDiscount')

show_to_user(fig)
```","The input code achieves the same goal as the reference code by retrieving the average discount per employee and displaying it in a bar chart. Although the input code includes concatenating the employee's first and last names for a more detailed visualization and adds color to the bars, these differences do not affect the correctness concerning the business analytics request.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT EmployeeID, AVG([Order Details].Discount) AS AvgDiscount
FROM [Order Details]
INNER JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY EmployeeID
ORDER BY AvgDiscount DESC;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', title='Avg Discount by Employee ID', labels={'AvgDiscount': 'Average Discount'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code is not correct because it only joins 'Order Details' with 'orders', missing the 'employees' table. This prevents the identification of which employee is associated with the discounts, which is necessary to find the employee with the highest average discount.",Base
What is the average unit price of products within each category? Show this using a bar chart of categories along with their average unit prices.,"```python
import plotly.express as px

# SQL Query to get average unit price per category
sql_query = ""SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice FROM products GROUP BY CategoryID;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the data type for CategoryID is string for proper categorical display
df['CategoryID'] = df['CategoryID'].astype(str) 

# Create a bar chart using plotly
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price per Category')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_prices = execute_sql_query(sql_query)

fig = px.bar(average_prices, x='CategoryID', y='AverageUnitPrice', 
             title='Average Unit Price of Products by Category', 
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})
show_to_user(fig)
```","The input code correctly executes an SQL query to select the average unit price per CategoryID from the products table, similar to the reference implementation. It then uses Plotly Express to create and display a bar chart. The logic and structure adhere closely to the reference implementation, fulfilling the requirement of calculating and visualizing the average unit prices by category.","```python
import plotly.express as px

# SQL Query to get the average unit price of products within each category
sql_query = """"""
SELECT categories.CategoryName, AVG(products.UnitPrice) AS AverageUnitPrice 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart of categories along with their average unit prices
fig = px.bar(data, x='CategoryName', y='AverageUnitPrice', title='Average Unit Price by Category', labels={'AverageUnitPrice': 'Average Unit Price', 'CategoryName': 'Category'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code is correct as it results in a bar chart of categories with their average unit prices, which is the requirement stated in the business analytics request. The reference implementation groups by CategoryID, whereas the input code groups by CategoryName. Both ways achieve the same goal since CategoryID and CategoryName are logically related through a join with the categories table. This approach provides a similar comprehension of results, displaying average prices per category. Additionally, the input code uses more descriptive labels, which enhances readability but does not affect the correctness of the logic.",both
List the employees who have never made a sale.,"```python
import pandas as pd

# SQL query to retrieve employees who have never made a sale
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o 
ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL
""""""

# Execute the SQL query
employees_without_sales_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(employees_without_sales_df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.EmployeeID IS NULL
""""""
employees_with_no_sales = execute_sql_query(sql_query)
show_to_user(employees_with_no_sales)
```","The provided code uses `WHERE o.EmployeeID IS NULL`, which is incorrect because it would miss any case where an order exists but does not match the employee IDs, rather than checking if no order exists. The reference implementation correctly checks `WHERE o.OrderID IS NULL` to determine employees who have never made a sale by verifying if the joined orders have no matching entry.","```python
import pandas as pd

# Define SQL query to find employees who have never made a sale
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.EmployeeID IS NULL;
""""""

# Execute the SQL query to get the data in a dataframe
employees_no_sales_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_no_sales_df)
```","The evaluation code checks if o.EmployeeID is NULL to determine if an employee never made a sale. However, it should check if o.OrderID is NULL, which correctly indicates that an employee has no associated orders and therefore never made a sale.",None
How many orders were shipped but not yet delivered?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT OrderID FROM orders WHERE ShippedDate IS NOT NULL AND RequiredDate IS NULL;""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Count the number of orders shipped but not yet delivered
shipped_not_delivered_count = orders_df.shape[0]

# Create a result DataFrame to display
result_df = pd.DataFrame({
    ""Shipped but Not Delivered Count"": [shipped_not_delivered_count]
})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS UnfulfilledOrders
FROM orders
WHERE ShippedDate IS NOT NULL AND DeliveryDate IS NULL
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The business analytics request asks for the number of orders that have been shipped but not yet delivered. The input code correctly counts the number of such orders by using 'WHERE ShippedDate IS NOT NULL AND DeliveryDate IS NULL', similarly to the reference code's logic of checking 'WHERE ShippedDate IS NOT NULL AND RequiredDate IS NULL'. Furthermore, the input code returns the count derived from the SQL query and displays it to the user, fulfilling the request successfully, despite the slight difference in the column name used for delivery condition.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(OrderID) as PendingOrders FROM orders WHERE ShippedDate IS NOT NULL AND (DeliveredDate IS NULL OR Status != 'Delivered')""

# Execute the SQL query
pending_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(pending_orders_df.iloc[0])
```","The input code checks if the 'DeliveredDate' is NULL or the 'Status' is not 'Delivered', which is not the same logic as the reference. The reference checks 'ShippedDate IS NOT NULL AND RequiredDate IS NULL', focusing on 'RequiredDate' instead, which represents a different condition.",Base
Which orders have the highest discounts applied? Visualize the top orders with the highest discounts using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get order discounts
sql_query = """"""
SELECT orders.OrderID, MAX([Order Details].Discount) AS MaxDiscount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY orders.OrderID 
ORDER BY MaxDiscount DESC 
LIMIT 10
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the top orders with the highest discounts
fig = px.bar(df, x='OrderID', y='MaxDiscount', title='Top Orders with Highest Discounts')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.OrderID, SUM(od.Discount) AS TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderID
ORDER BY TotalDiscount DESC
LIMIT 10
""""""

top_discount_orders = execute_sql_query(sql_query)

fig = px.bar(top_discount_orders, x='OrderID', y='TotalDiscount', title='Top Orders with Highest Discounts', labels={'TotalDiscount': 'Total Discount'})
show_to_user(fig)
```","The input code sums the discounts for each order, whereas the reference code uses the maximum discount per order. This results in different logic and outputs.","```python
import plotly.express as px

# SQL Query to retrieve data
sql_query = ""SELECT OrderID, Discount FROM [Order Details] ORDER BY Discount DESC;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top orders with the highest discounts
fig = px.bar(df.head(10), x='OrderID', y='Discount', title='Top Orders with Highest Discounts')

# Display the visualization to the user
show_to_user(fig)
```","The input code differs significantly from the reference code in the logic used to determine the top orders with the highest discounts. The reference code correctly groups by OrderID and selects the maximum discount for each order. The input code simply orders all discount entries and picks the top 10 without grouping by OrderID, which does not answer the business analytics request correctly.",None
What is the average time taken to ship an order? Use a histogram to visualize the distribution of shipping times.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get the shipping times
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) as ShippingTime FROM orders;
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Calculate the average shipping time
average_shipping_time = df['ShippingTime'].mean()

# Display the average shipping time to the user
average_df = pd.DataFrame({'AverageShippingTime': [average_shipping_time]})
show_to_user(average_df)

# Create a histogram to visualize the distribution of shipping times
fig = px.histogram(df, x='ShippingTime', title='Distribution of Shipping Times')

# Display the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATEDIFF(ShippedDate, OrderDate) AS ShippingTime
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
""""""

shipping_times_df = execute_sql_query(sql_query)

average_shipping_time = shipping_times_df['ShippingTime'].mean()
histogram_fig = px.histogram(shipping_times_df, x='ShippingTime', title='Distribution of Shipping Times')

show_to_user(histogram_fig)
```","The input code does not display the average shipping time to the user, as required by the business analytics request. The reference implementation creates a DataFrame for the average shipping time and displays it, which is missing in the input code.","```python
import plotly.express as px

# SQL query to retrieve order data
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS ShippingTime 
FROM orders 
WHERE ShippedDate IS NOT NULL;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the average shipping time
average_shipping_time = df['ShippingTime'].mean()

# Show the average
show_to_user(f""Average Shipping Time: {average_shipping_time}"")

# Create a histogram to visualize the distribution
fig = px.histogram(df, x='ShippingTime', nbins=30, title='Distribution of Shipping Times')

# Show the histogram to the user
show_to_user(fig)
```","The input code performs the same core tasks as the reference implementation: it calculates the average shipping time between 'OrderDate' and 'ShippedDate' for records where 'ShippedDate' is not null, then displays this value to the user. It also creates a histogram to visualize the distribution of shipping times, which aligns with the business analytics request. The addition of a condition to check for non-null 'ShippedDate' ensures data validity and does not alter the intended logic. Both codes utilize the same pandas operations and Plotly for visualization.",Finetuned
List the top 5 products by sales for Q2 2023. Represent these top products using a bar chart for better insight.,"```python
import plotly.express as px

# SQL query to list top 5 products by sales for Q2 2023
sql_query = """"""
SELECT products.ProductID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY products.ProductID 
ORDER BY total_sales DESC 
LIMIT 5
""""""

# Execute the SQL query
df_top_products = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df_top_products, x='ProductID', y='total_sales', title='Top 5 Products by Sales for Q2 2023')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve top 5 products by sales for Q2 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 5
""""""

# Execute the SQL query
top_products = execute_sql_query(sql_query)

# Create a bar chart for better insight
fig = px.bar(top_products, x='ProductName', y='total_sales', 
             title='Top 5 Products by Sales (Q2 2023)', 
             labels={'total_sales': 'Total Sales', 'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly executes an SQL query to find the top 5 products by sales for Q2 2023, using the same filtering logic on dates and calculation for total sales as the reference code. Additionally, it retrieves product names along with IDs and utilizes these names in the bar chart, which provides enhanced readability. The use of `plotly.express` to create a bar chart and `show_to_user(fig)` to display it aligns with the intended functionality of the reference. Thus, the logic and outcome match the business analytics request accurately.","```python
import plotly.express as px

# SQL query to get top 5 products by sales for Q2 2023
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY p.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(top_products_df, x='ProductName', y='TotalSales', title='Top 5 Products by Sales for Q2 2023')

# Visualize the chart
show_to_user(fig)
```","The input code calculates 'TotalSales' based solely on the quantity of products sold, whereas the reference code calculates 'total_sales' based on the unit price, quantity, and discounts. This means the input code does not correctly match the logic of the reference code, which considers the revenue generated by the sales, not just the volume of sales.",Base
Which products from each supplier have not been discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, products.ProductName 
FROM suppliers 
INNER JOIN products 
ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 0;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, p.ProductID, p.ProductName
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.Discontinued = 0
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The provided Python code correctly answers the business analytics request. It selects SupplierID, CompanyName, ProductID, and ProductName from the suppliers and products tables, joining them on SupplierID and filtering for products with Discontinued set to 0. Despite having additional columns like SupplierID and ProductID, it adheres to the same logic as the reference implementation and ensures that the products listed are not discontinued for each supplier.","```python
import pandas as pd

# SQL query to fetch relevant data
sql_query = """"""
SELECT p.ProductID, p.ProductName, s.SupplierID 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
WHERE p.Discontinued = 0;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Display data to the user
show_to_user(df)
```","The evaluated code returns the ProductID, ProductName, and SupplierID, whereas the reference implementation returns CompanyName and ProductName. The evaluated code does not include the CompanyName field, making it incorrect for this request.",Base
What is the total number of orders where the quantity ordered exceeded 50 units in 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT COUNT(orders.OrderID) AS large_orders 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Quantity > 50 
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and get the result in a dataframe
df_large_orders = execute_sql_query(sql_query)

# Extract the count value from the dataframe
large_orders_count = df_large_orders.iloc[0]['large_orders']

# Display the result to the user
show_to_user(pd.DataFrame({'Large Orders Count': [large_orders_count]}))
```","```python
sql_query = """"""
SELECT COUNT(*) AS total_orders
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE [Order Details].Quantity > 50 AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly counts the number of orders where the quantity exceeds 50 units in 2023. It uses a similar SQL query to perform the count, considering only orders with the specified quantity and date range. The difference in the alias name for the count result ('large_orders' versus 'total_orders') does not affect the correctness of the solution. Both implementations retrieve and display the correct count.","```python
import pandas as pd

# Execute the SQL query to get the required data
sql_query = """"""
SELECT o.OrderID 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE od.Quantity > 50 AND YEAR(o.OrderDate) = 2023;
""""""
orders_df = execute_sql_query(sql_query)

# Count the number of unique OrderIDs
orders_count = len(orders_df['OrderID'].unique())

# Display the result to the user
show_to_user(pd.DataFrame({'TotalOrders': [orders_count]}))
```","The input Python code correctly counts the total number of orders where the quantity ordered exceeded 50 units in 2023. It executes a SQL query using the `YEAR` function to filter the orders from 2023 and checks for quantities greater than 50. It counts the unique OrderIDs, which matches the logic in the reference implementation that counts the orders directly based on the same conditions. The results are consistent with the business analytics request.",both
What is the average quantity of products ordered per order?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG([Order Details].Quantity) AS AverageQuantity FROM [Order Details]""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Extract the average quantity and display it
average_quantity = df_result['AverageQuantity'].iloc[0]
show_to_user(pd.DataFrame({'AverageQuantity': [average_quantity]}))
```","```python
sql_query = """"""
SELECT AVG(Quantity) AS AverageQuantityPerOrder
FROM [Order Details]
GROUP BY OrderID
""""""
average_quantity_per_order_df = execute_sql_query(sql_query)
show_to_user(average_quantity_per_order_df)
```","The input code calculates the average quantity per order by grouping the results by OrderID, which is not what the reference implementation does. The reference implementation calculates the overall average quantity across all order details without grouping by OrderID.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT Quantity FROM [Order Details];""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Calculate the average quantity ordered per order
average_quantity_per_order = df['Quantity'].mean()

# Show the result to the user
show_to_user(pd.DataFrame({'AverageQuantityPerOrder': [average_quantity_per_order]}))
```","Both code implementations correctly calculate the average quantity of products ordered per order. The reference code uses a SQL query to directly compute the average in the database, while the input code retrieves all quantities and calculates the average in Python. Both methods yield the same result.",Finetuned
What is the performance of each product based on sales quantities in Q1 2023? Use a line or bar chart to illustrate product performance.,"```python
import plotly.express as px

# SQL query to retrieve the sales quantities for each product in Q1 2023
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS product_performance
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate product performance
fig = px.bar(df, x='ProductID', y='product_performance', title='Product Performance in Q1 2023')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
""""""

product_performance_df = execute_sql_query(sql_query)

fig = px.bar(product_performance_df, x='ProductName', y='total_quantity', title='Product Performance Q1 2023', labels={'total_quantity': 'Sales Quantity', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code accurately fulfills the business analytics request. It correctly retrieves the sales quantities for each product in Q1 2023 using an SQL query. The query aggregates the quantity data by product and includes the product name, which is an enhancement over the reference code. It then visualizes the data using a bar chart with labeled axes, which aligns with the requirement to illustrate product performance. Although there are differences, such as including the 'ProductName' column, these differences do not violate the request and add additional clarity; thus, the code is correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS performance
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY performance DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ProductName', y='performance', title='Product Performance in Q1 2023')

# Show the result to user
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It retrieves the sales quantities for each product in Q1 2023. The main difference is that 'ProductName' is used instead of 'ProductID', which provides a clearer label in the visualization but still answers the question of product performance. The use of 'ORDER BY' to sort by performance does not affect the correctness of the output visualization. Therefore, the input code meets the business analytics request.",both
Find the top 5 customers by the number of orders placed. Show results using a bar chart.,"```python
import plotly.express as px

# Define SQL query to retrieve top 5 customers by number of orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Top 5 Customers by Number of Orders')

# Display the result using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderCount DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='OrderCount', title='Top 5 Customers by Number of Orders', labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer Name'})
show_to_user(fig)
```","The input code adheres to the business analytics request and the core logic of the reference implementation. Both implementations query the top 5 customers by order count and display results using a bar chart. The input code includes an additional join to retrieve the company name, which enhances the chart's readability without altering the intended outcome. Thus, it appropriately answers the business request and follows the logic of the reference code.","```python
import plotly.express as px

# SQL query to retrieve top 5 customers by number of orders
sql_query = """"""
SELECT CustomerID, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Top 5 Customers by Number of Orders',
             labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Show the result to the user
show_to_user(fig)
```","The input code correctly retrieves and processes the data to find the top 5 customers by the number of orders. It uses the same SQL logic as the reference code, counting the orders grouped by CustomerID, ordering them in descending order of count, and limiting the results to the top 5. It then visualizes the data using Plotly in a bar chart format, similar to the reference code. An additional labels parameter is included in the input code, but this does not affect the correctness as it only adds labels to the axes.",both
What is the average shipping time for orders shipped to a specific country in the current month?,"```python
import pandas as pd
from datetime import datetime

# Set the specified country
specified_country = 'specified_country'

# Execute the SQL query to get the average shipping time
# Use a parameterized query to avoid SQL injection
query = """"""
    SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime 
    FROM orders 
    WHERE DATE_FORMAT(OrderDate, '%%Y-%%m') = DATE_FORMAT(CURDATE(), '%%Y-%%m') 
    AND ShipCountry = %s;
""""""
result_df = execute_sql_query(query, (specified_country,))

# Show the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
from datetime import datetime

current_month = datetime.now().month
current_year = datetime.now().year
country = 'Specified Country'  # Replace with the specific country

sql_query = f""""""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime
FROM orders
WHERE MONTH(OrderDate) = {current_month} AND YEAR(OrderDate) = {current_year} AND ShipCountry = '{country}'
""""""

average_shipping_time_df = execute_sql_query(sql_query)
show_to_user(average_shipping_time_df)
```","The input code uses `f-string` to directly insert variables into the SQL query, which can lead to SQL injection vulnerabilities when handling user inputs. The reference code uses a parameterized query (`%s` with a parameter tuple). Additionally, the input code uses `MONTH` and `YEAR` functions instead of `DATE_FORMAT` to filter the current month, which is logically correct but less efficient than using `DATE_FORMAT` once.","```python
import pandas as pd

# SQL Query to fetch the average shipping time
sql_query = """"""
SELECT 
    orders.ShipCountry, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageShippingTime 
FROM 
    orders 
WHERE 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') = DATE_FORMAT(CURRENT_DATE, '%Y-%m')
GROUP BY 
    orders.ShipCountry;
""""""

# Execute the SQL query and get the dataframe
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)
```","The input code calculates the average shipping time for all countries, while the reference code restricts this calculation to a specific country. Additionally, the input code groups by 'ShipCountry' which means it returns results for multiple countries, whereas the reference implementation filters for one specified country using a parameterized query.",None
Which customers have purchased more than 5 different products?,"```python
sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY customers.CustomerID, customers.CompanyName
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
""""""

# Execute the SQL query
df_customers = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_customers)
```","```python
sql_query = """"""
SELECT orders.CustomerID, COUNT(DISTINCT [Order Details].ProductID) AS product_count
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.CustomerID
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code does not return the 'CompanyName' of the customers, which is part of the specified business request. It only returns 'CustomerID' and 'product_count', lacking the 'CompanyName' required to match the reference implementation.","```python
import pandas as pd

# SQL query to find customers who purchased more than 5 different products
sql_query = """"""
SELECT o.CustomerID, COUNT(DISTINCT od.ProductID) AS DifferentProducts
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID
HAVING COUNT(DISTINCT od.ProductID) > 5;
""""""

# Execute the SQL query
df_customers = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_customers)
```","The input code retrieves only the CustomerID and the number of different products purchased, without including the CompanyName as in the reference implementation. The reference query also retrieves the CompanyName by joining with the customers table, which is missing in the input code.",None
Which region has the highest on-time delivery rate? Present this information with a pie chart or bar chart.,"```python
import plotly.express as px

# Define the SQL query to execute.
sql_query = """"""
SELECT ShipRegion, (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS on_time_rate
FROM orders
GROUP BY ShipRegion
ORDER BY on_time_rate DESC
LIMIT 1;
""""""

# Execute the SQL query using the provided utility function.
df = execute_sql_query(sql_query)

# Visualize the data with a bar chart to show the on-time delivery rates by region.
fig = px.bar(df, x='ShipRegion', y='on_time_rate', title='On-Time Delivery Rate by Region')

# Display the result to the user.
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rate by region
sql_query = """"""
SELECT 
    ShipRegion, 
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    ShipRegion
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Calculate on-time delivery rate
df['OnTimeDeliveryRate'] = df['OnTimeDeliveries'] / df['TotalOrders']

# Find the region with the highest on-time delivery rate
highest_on_time_region = df.loc[df['OnTimeDeliveryRate'].idxmax()]

# Prepare data for visualization
visualization_data = df.copy()
visualization_data['Region'] = visualization_data['ShipRegion']
visualization_data['OnTimeDeliveryRate'] = visualization_data['OnTimeDeliveryRate'] * 100

# Create a bar chart
fig = px.bar(visualization_data, 
             x='Region', 
             y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rate by Region',
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'})

# Show the result to the user
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate for each region using SQL and a Pandas DataFrame. It then finds the region with the highest on-time delivery rate by identifying the index of the maximum rate. The on-time delivery rate is visualized using a bar chart, similar to the reference implementation. The input and reference both aim to display on-time rates by region in a bar chart, adhering to the same overall logic and goal, albeit with slightly different intermediate steps.","To visualize the region with the highest on-time delivery rate, we can use a bar chart. This approach allows for clearer comparison, especially if there are multiple regions involved. Below is the Python code that achieves this:

```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    Region, 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID) AS OnTimeDeliveryRate 
FROM 
    orders 
GROUP BY Region 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Filter to get the region with the highest on-time delivery rate
highest_rate_region_df = df.head(1)

# Create a bar chart using plotly
fig = px.bar(highest_rate_region_df, x='Region', y='OnTimeDeliveryRate', title='Highest On-Time Delivery Rate by Region')

# Show the chart to the user
show_to_user(fig)
``` 

### Explanation:
- The SQL query retrieves the on-time delivery rates for each region, sorted in descending order.
- The Python code filters the data to get the region with the highest on-time delivery rate.
- A bar chart is created with Plotly, which is appropriate for displaying this singular comparative data.
- Finally, the bar chart is displayed to the user.","The input code correctly calculates the on-time delivery rate for each region, sorts them in descending order, and then selects the top region to visualize using a bar chart. This matches the logic of the reference implementation. The difference in column names (ShipRegion vs. Region) does not affect functionality, assuming they are equivalent in context. Both pieces of code aim to present the same data and result effectively, fulfilling the business analytics request.",both
How many orders were placed in the current year?,"```python
from datetime import datetime
import pandas as pd

# SQL query
sql_query = f""""""
SELECT COUNT(*) AS TotalOrders FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the total orders to the user
show_to_user(result_df)
```","```python
from datetime import datetime

current_year = datetime.now().year
sql_query = f""""""
SELECT COUNT(OrderID) AS total_orders
FROM orders
WHERE YEAR(OrderDate) = {current_year}
""""""
total_orders_df = execute_sql_query(sql_query)
show_to_user(total_orders_df)
```","Both implementations use a similar SQL query to count the number of orders in the current year, leveraging the YEAR function on the OrderDate column and the CURRENT_DATE function or datetime module to determine the current year. The logic to execute the SQL query and display the results is also consistent between the two implementations.","```python
import pandas as pd
from datetime import datetime

# Define the SQL query
current_year = datetime.now().year
sql_query = f""""""
SELECT OrderID, OrderDate 
FROM orders 
WHERE YEAR(OrderDate) = {current_year};
""""""

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Count the number of orders and create a dataframe to display the result
order_count = len(result_df)
count_df = pd.DataFrame({'OrderCount': [order_count]})

# Display the result to the user
show_to_user(count_df)
```","The input code correctly filters orders for the current year using SQL and counts the number of resulting rows. Although the method of counting differs from the reference (using `len()` instead of SQL `COUNT(*)`), the final outcome is equivalent and answers the business analytics request properly. The resulting count is then encapsulated in a DataFrame and displayed, which adheres to the requested functionality.",both
Calculate the total discount given on all orders in the last month.,"```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate the start date for the last month
start_date_last_month = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1).strftime('%Y-%m-%d')

# SQL query to calculate the total discount
sql_query = f""""""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS TotalDiscount 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate >= '{start_date_last_month}';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate the first and last date of the last month
today = datetime.now()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to calculate total discount
sql_query = f""""""
SELECT SUM([Order Details].Discount * [Order Details].Quantity) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
AND orders.OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query
total_discount_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(total_discount_df)
```","The input code calculates the discount as `SUM([Order Details].Discount * [Order Details].Quantity)` whereas the reference code uses `SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount)`. The input code doesn't account for the UnitPrice, which is necessary to correctly calculate the total discount value in monetary terms.","```python
import pandas as pd

# SQL query to calculate total discount for last month
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE MONTH(orders.OrderDate) = MONTH(DATE_SUB(CURDATE(), INTERVAL 1 MONTH)) 
AND YEAR(orders.OrderDate) = YEAR(DATE_SUB(CURDATE(), INTERVAL 1 MONTH));
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the result
total_discount = df.iloc[0]['TotalDiscount']
show_to_user(pd.DataFrame({'Total Discount': [total_discount]}))
```","The provided input code correctly calculates the total discount based on the orders from the last month, similar to the reference implementation. Both implementations determine the total discount by multiplying the quantity, unit price, and discount for each order detail, and then summing the result. In the reference code, the last month's start date is calculated through date manipulation, while the input code uses SQL functions MONTH and DATE_SUB to ensure the query accounts for the previous month. Both methods effectively identify and calculate the total discounts for the intended time period.",Finetuned
Which products have a stock level below their reorder level?,"```python
import pandas as pd

# Define the SQL query to find products with stock below reorder level
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user using the provided utility function
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code fetches additional details (ProductID, UnitsInStock, ReorderLevel) and filters out products that are discontinued (Discontinued = 0), which the reference implementation does not specify. The reference implementation only selects ProductName and does not consider whether the products are discontinued.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the query
products_low_stock_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(products_low_stock_df)
```","The input code correctly identifies products with stock levels below their reorder level using the same SQL query as the reference implementation. It executes the SQL query and displays the result to the user using equivalent function calls. Thus, it adheres to the same logic and meets the business analytics request.",Finetuned
Which month had the highest number of orders placed? Show this with a bar chart of months and their corresponding order numbers.,"```python
import plotly.express as px

# SQL query to get the number of orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY Month
ORDER BY NumberOfOrders DESC
""""""

# Execute the SQL query and get the result as a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Create a bar chart showing the number of orders per month
fig = px.bar(orders_df, x=""Month"", y=""NumberOfOrders"", title=""Number of Orders per Month"")

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY OrderCount DESC
LIMIT 1
""""""

highest_order_month = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY Month
""""""

monthly_orders = execute_sql_query(sql_query_all)

fig = px.bar(monthly_orders, x='Month', y='OrderCount', title='Monthly Orders Count', labels={'OrderCount': 'Number of Orders'}, color='OrderCount')
show_to_user(fig)
```","The input code correctly obtains the monthly order counts needed to create the bar chart, similar to the reference implementation. It first finds the month with the highest orders using a query with a LIMIT 1 clause, which is slightly different but doesn't affect the final output because it subsequently generates a second query to obtain all monthly data. This aligns with the reference goal of displaying a bar chart of orders per month, adhering to the same logic and end objective as the reference code. Therefore, it is considered correct.","```python
import plotly.express as px
import pandas as pd

# SQL query to get all months with the number of orders
sql_query = """"""
SELECT MONTH(orders.OrderDate) AS OrderMonth, COUNT(orders.OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY MONTH(orders.OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the data is sorted by OrderMonth
df.sort_values('OrderMonth', inplace=True)

# Create a bar chart
fig = px.bar(df, x='OrderMonth', y='NumberOfOrders', title='Number of Orders Per Month', labels={'OrderMonth': 'Month', 'NumberOfOrders': 'Number of Orders'})

# Show the chart to the user
show_to_user(fig)

# Optional: Find the month with the highest number of orders
max_orders_month = df.loc[df['NumberOfOrders'].idxmax()]
show_to_user(max_orders_month)
```","The input code calculates the number of orders per month using the MONTH() function, which extracts the month as an integer, whereas the reference code uses DATE_FORMAT to get the month in 'YYYY-MM' format. The input code also does not sort by 'NumberOfOrders' in descending order, which is necessary to identify the month with the highest orders, as done in the reference code.",Base
Determine the employee with the largest average order size. Visualize this using a bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderSize 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY AvgOrderSize DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the dataframe is empty
if df.empty:
    raise ValueError(""No data returned from the query."")

# Create a bar chart to visualize the result
fig = px.bar(df, x='EmployeeID', y='AvgOrderSize', title='Employee with Largest Average Order Size')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderSize
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
ORDER BY 
    AverageOrderSize DESC
LIMIT 1
""""""

largest_avg_order_size_df = execute_sql_query(sql_query)

fig = px.bar(largest_avg_order_size_df, 
              x='EmployeeName', 
              y='AverageOrderSize', 
              title='Employee with Largest Average Order Size')
show_to_user(fig)
```","The input code accomplishes the same task as the reference, determining the employee with the largest average order size using a slightly modified SQL query. Both implementations compute the average order size by joining employees, orders, and order details, grouping by EmployeeID, ordering by the computed average order size, and limiting results to one. The input code includes EmployeeName in the visualization for clarity, but this does not affect the correctness relative to the business request. The visualization using Plotly is consistent with the requirements.","```python
import plotly.express as px

# SQL query to determine the employee with the largest average order size
sql_query = """"""
SELECT e.EmployeeID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderSize
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY AverageOrderSize DESC
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the result with a bar chart
fig = px.bar(df, x='EmployeeID', y='AverageOrderSize', title='Employee with Largest Average Order Size')

# Display the bar chart
show_to_user(fig)
```",The input code correctly implements the business requirement and adheres to the same logic as the reference implementation. Both SQL queries calculate the average order size by employing a join operation across tables and ordering the results in descending order of average order size. The visualization part using Plotly Express is also functionally equivalent.,both
How many distinct customers placed orders each month? Use a line chart to show trends over the months.,"```python
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT DATE_TRUNC('month', o.OrderDate) AS Month, 
       COUNT(DISTINCT o.CustomerID) AS UniqueCustomers 
FROM orders o 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure 'Month' column is recognized as a date
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart using the data
fig = px.line(df, x='Month', y='UniqueCustomers', title='Distinct Customers Placing Orders Each Month', labels={'Month': 'Month', 'UniqueCustomers': 'Number of Unique Customers'})

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    COUNT(DISTINCT CustomerID) AS DistinctCustomers
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='OrderMonth', y='DistinctCustomers', 
              title='Distinct Customers Who Placed Orders Each Month', 
              labels={'OrderMonth': 'Month', 'DistinctCustomers': 'Number of Distinct Customers'})
show_to_user(fig)
```","Both the provided and reference code perform similar operations: they select distinct customers per month from an orders table, compute the monthly count, and visualize the result with a line chart. The only difference is the method of date extraction: the reference code uses `DATE_TRUNC` in SQL, while the provided code uses `DATE_FORMAT`, which is an acceptable alternate method. The logic and end-result are consistent, making the implementation correct.","```python
import plotly.express as px

# SQL query to get the number of distinct customers for each month
sql_query = """"""
SELECT strftime('%Y-%m', OrderDate) AS OrderMonth, 
       COUNT(DISTINCT CustomerID) AS DistinctCustomers 
FROM orders 
GROUP BY OrderMonth
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Plotting the data using a line chart
fig = px.line(df, x='OrderMonth', y='DistinctCustomers', 
              title='Distinct Customers Placing Orders Each Month', 
              markers=True)

# Display the line chart
show_to_user(fig)
```","The provided code retrieves the number of distinct customers placing orders each month and presents it using a line chart, which aligns with the business analytics request and the reference code logic. It uses the SQLite function `strftime` to group by month, similar to the `DATE_TRUNC` function in SQL. The only differences are in the implementation details (like the use of markers in the chart), but these do not affect the correctness of fulfilling the request.",both
What are the average discounts applied per order?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT OrderID, AVG(Discount) AS AverageDiscount FROM [Order Details] GROUP BY OrderID;""

# Execute the SQL query using the provided utility function
order_discounts_df = execute_sql_query(sql_query)

# Display the data analysis result
show_to_user(order_discounts_df)
```","```python
sql_query = """"""
SELECT OrderID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID
""""""
average_discounts_df = execute_sql_query(sql_query)
show_to_user(average_discounts_df)
```","The input Python code correctly mirrors the reference implementation's logic. It forms an SQL query to calculate the average discount per order by selecting the OrderID and calculating the AVG(Discount), and then grouping by OrderID, which matches the business analytics request. Both implementations use the same query structure and functions (execute_sql_query and show_to_user) to process and display the results.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG([Order Details].Discount) AS AvgDiscount 
FROM [Order Details];
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['AvgDiscount'].mean())
```","The input code calculates the overall average discount across all orders by taking the mean of all discounts in the dataset, rather than averaging discounts per individual order and then computing those averages. The reference code uses a GROUP BY clause to compute an average discount for each order, which aligns with the business query of finding average discounts per order.",Base
What is the average order fulfillment time for orders made in February 2023?,"```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT DATEDIFF(o.ShippedDate, o.OrderDate) AS FulfillmentTime 
FROM orders o 
WHERE MONTH(o.OrderDate) = 2 AND YEAR(o.OrderDate) = 2023;
""""""

# Execute the query and retrieve data
orders_df = execute_sql_query(sql_query)

# Calculate the average fulfillment time
avg_fulfillment_time = orders_df['FulfillmentTime'].mean()

# Display the result
show_to_user(pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE OrderDate >= '2023-02-01' AND OrderDate < '2023-03-01';
""""""

average_fulfillment_time = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time)
```","The input code correctly calculates the average order fulfillment time for orders made in February 2023. It uses SQL to directly compute the average difference between ShippedDate and OrderDate for the specified date range, which matches the logic of calculating fulfillment times individually and then finding their mean, as done in the reference code. Although a different method is used, the result is the same.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS OrderFulfillmentTime
FROM orders o
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-02';
""""""

# Execute SQL query and store the result dataframe
df = execute_sql_query(sql_query)

# Since SQL aggregation returns a single value, we can extract it
order_fulfillment_time = df['OrderFulfillmentTime'].iloc[0]

# Create a dataframe for display
result_df = pd.DataFrame({'OrderFulfillmentTime': [order_fulfillment_time]})

# Display the result
show_to_user(result_df)
```","The input Python code correctly calculates the average order fulfillment time for orders made in February 2023. It uses a SQL query to select the average of the date difference between ShippedDate and OrderDate for orders in February 2023. The condition DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-02' ensures only the relevant orders are included, similar to the reference implementation's use of MONTH and YEAR functions. The result is then extracted and displayed similarly to the reference code. Thus, the logic aligns with the reference implementation and addresses the business analytics request effectively.",both
Get a list of employees and the number of orders they have handled.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, EmployeeName
ORDER BY NumberOfOrders DESC;
""""""

employee_orders_df = execute_sql_query(sql_query)
show_to_user(employee_orders_df)
```","The input code meets the business analytics request by obtaining a list of employees and the number of orders each has handled. It correctly joins the 'employees' and 'orders' tables using EmployeeID. The difference from the reference code is that it uses CONCAT to combine the first and last names and orders the result by the number of orders. The LEFT JOIN also ensures that employees with zero orders are included, which is a reasonable variation but does not conflict with the main requirement.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input code uses a LEFT JOIN without including employee names in the SELECT clause or GROUP BY clause, whereas the reference uses a JOIN and includes both first and last names. As a result, the input code does not match the logic or output structure of the reference implementation.",Base
What is the inventory turnover ratio for the product 'Chai' in May 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.ProductName = 'Chai'
AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the inventory turnover ratio value
inventory_turnover_ratio = df.iloc[0]['inventory_turnover_ratio']

# Display the result
show_to_user(inventory_turnover_ratio)
```","```python
import pandas as pd

start_date = '2023-05-01'
end_date = '2023-05-31'

sql_query = f""""""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) AS cost_of_goods_sold,
    AVG(products.UnitsInStock) AS average_inventory
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    products.ProductName = 'Chai' AND 
    orders.OrderDate BETWEEN '{start_date}' AND '{end_date}'
""""""

data = execute_sql_query(sql_query)
if not data.empty and data['average_inventory'].iloc[0] != 0:
    inventory_turnover_ratio = data['cost_of_goods_sold'].iloc[0] / data['average_inventory'].iloc[0]
    result_df = pd.DataFrame({'Inventory Turnover Ratio': [inventory_turnover_ratio]})
else:
    result_df = pd.DataFrame({'Inventory Turnover Ratio': [0]})

show_to_user(result_df)
```","The input code correctly calculates the inventory turnover ratio for the product 'Chai' in May 2023, matching the logic of the reference implementation. It calculates the cost of goods sold as the sum of (Quantity * UnitPrice) and determines the average inventory using the AVG() function on UnitsInStock. The calculation and conditions align with the reference code.","```python
import pandas as pd

# SQL query to get the needed data
sql_query = """"""
SELECT 
    orders.OrderID, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) AS GrossRevenue 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    products.ProductName = 'Chai' 
    AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31' 
GROUP BY orders.OrderID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the metrics
inventory_turnover_ratio = df['GrossRevenue'].sum() / df['OrderID'].nunique()

# Prepare the result for display
result_df = pd.DataFrame({'InventoryTurnoverRatio': [inventory_turnover_ratio]})

# Show the result to the user
show_to_user(result_df)
```",The input code calculates the inventory turnover ratio incorrectly. It computes it as the sum of 'GrossRevenue' divided by the number of unique 'OrderID'. The reference implementation calculates it as the sum of 'Quantity * UnitPrice' divided by the average 'UnitsInStock' for 'Chai'. The input code fails to use 'UnitsInStock' and thus does not match the logic of the reference implementation.,Base
Which shipping method has the shortest average order fulfillment time?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AverageFulfillmentTime ASC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY ShipVia
ORDER BY AverageFulfillmentTime ASC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly answers the business analytics request. It calculates the shortest average order fulfillment time by grouping orders by 'ShipVia', computing the difference between 'ShippedDate' and 'OrderDate', and returns the shipping method with the minimum average fulfillment time, adhering to the logic of the reference implementation. The additional condition 'WHERE ShippedDate IS NOT NULL' is valid as it ensures calculations are done only for orders that have been shipped, which aligns with the intent of the query.","```python
import pandas as pd

# SQL query to find the shipping method with the shortest average order fulfillment time
sql_query = """"""
SELECT shippers.ShipperName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgFulfillmentTime 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.ShipperName 
ORDER BY AvgFulfillmentTime ASC 
LIMIT 1;
""""""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result)
```",The input Python code not only calculates the average order fulfillment time similar to the reference but also provides additional context by joining the shippers table to return the shipper's name. The logic for calculating the average fulfillment time and ordering results to find the shortest is consistent with the reference implementation.,both
What is the number of products sold with discounts?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductID 
FROM [Order Details] 
WHERE Discount > 0;
""""""

# Execute the query to retrieve data
result_df = execute_sql_query(sql_query)

# Count distinct ProductID
products_with_discount = result_df['ProductID'].nunique()

# Send the result to the user
show_to_user(pd.DataFrame({'ProductsWithDiscount': [products_with_discount]}))
```","```python
sql_query = """"""
SELECT COUNT(*) AS ProductsSoldWithDiscount
FROM [Order Details]
WHERE Discount > 0
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code counts all rows where Discount > 0, indicating the total number of order lines with discounts, but it does not count distinct ProductIDs as in the reference implementation. The reference code determines the number of unique products sold with a discount.","```python
import pandas as pd

# SQL query based on the business request
sql_query = """"""
SELECT SUM([Order Details].Quantity) AS DiscountedUnits 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Discount > 0;
""""""

# Execute the SQL query to get the data
discounted_units_df = execute_sql_query(sql_query)

# Display the result
show_to_user(discounted_units_df.iloc[0]['DiscountedUnits'])
```","The input code calculates the total quantity of discounted units sold, not the number of distinct products sold with discounts, as required. The reference code counts distinct ProductIDs with a discount, aligning with the business request.",None
What is the average order fulfillment time per employee?,"```python
import pandas as pd

# Execute the SQL query
df = execute_sql_query(""""""
SELECT EmployeeID, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY EmployeeID;
"""""")

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY EmployeeID
""""""
average_fulfillment_time = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time)
```","The input code correctly calculates the average order fulfillment time per employee by grouping the results by EmployeeID and computing the average difference between the OrderDate and ShippedDate. It also includes a null check for ShippedDate to ensure only completed orders are considered. The direction of the DATEDIFF is consistent with the subtraction used in the reference code, effectively achieving the same calculation. Therefore, the logic adheres to the request and reference implementation.","```python
import pandas as pd

# SQL query to retrieve necessary data
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgOrderFulfillmentTime 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID;
""""""

# Execute SQL query and get the data in a dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The input code provides the average order fulfillment time grouped by EmployeeID, which is the main requirement. Although it includes additional columns for the employee's first and last names, it adheres to the same logic as the reference implementation by correctly calculating and grouping the average fulfillment time.",both
What is the average number of units ordered per order?,"```python
import pandas as pd

# SQL Query to execute
sql_query = ""SELECT AVG(Quantity) AS AvgQuantityPerOrder FROM [Order Details];""

# Execute the query and get the result in a dataframe
result_df = execute_sql_query(sql_query)

# Since the result is a single value, extract and display it
avg_quantity_per_order = result_df['AvgQuantityPerOrder'].iloc[0]

# Create a dataframe to display the result
display_df = pd.DataFrame({'AvgQuantityPerOrder': [avg_quantity_per_order]})

# Show the result to the user
show_to_user(display_df)
```","```python
sql_query = """"""
SELECT AVG(Quantity) AS AverageUnitsOrdered
FROM [Order Details]
GROUP BY OrderID
""""""
average_units_ordered_df = execute_sql_query(sql_query)
show_to_user(average_units_ordered_df)
```","The input code calculates the average number of units ordered per order by averaging quantities after grouping by OrderID. This means it calculates an average for every order ID, rather than a single average across all orders. The reference code calculates a single average of all quantities, which is different from grouping by OrderID first and then averaging. Therefore, the logic is not equivalent.","```python
import pandas as pd

# SQL Query to compute the average number of units ordered per order
sql_query = ""SELECT products.ProductID, products.ProductName, AVG([Order Details].Quantity) AS AverageUnitsOrdered FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID GROUP BY products.ProductID;""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Sort the result by ProductID (or any other field of interest)
df_sorted = df.sort_values(by='ProductID')

# Display the result to the user
show_to_user(df_sorted)
```","The input code computes the average number of units ordered per product, grouping by ProductID, while the reference code computes the overall average number of units per order without grouping by product. Thus, the logic and result differ from the reference implementation.",None
Determine the total revenue generated from orders shipped to Germany.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.ShipCountry = 'Germany';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
total_revenue = result_df['TotalRevenue'][0] if not result_df.empty else 0
show_to_user(pd.DataFrame({'TotalRevenue': [total_revenue]}))
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE c.Country = 'Germany'
""""""

total_revenue_df = execute_sql_query(sql_query)
show_to_user(total_revenue_df)
```","Both the reference and input code aim to calculate the total revenue from orders shipped to Germany. The input code differs slightly in its approach by joining the 'customers' table to filter by 'Country', whereas the reference code filters by 'orders.ShipCountry'. Assuming that 'orders.ShipCountry' and 'customers.Country' are consistent in terms of shipping orders to Germany, the logic and the outcome of the query remain correct. Both codes calculate the revenue using the same method: multiplying unit price, quantity, and applying a discount.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.ShippingCountry = 'Germany';
""""""

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Display the result to the user
# The correct way to fetch the revenue value is to extract it from the dataframe after query execution
total_revenue = revenue_data.iloc[0]['Revenue'] if not revenue_data.empty else 0
show_to_user(pd.DataFrame({'Total Revenue': [total_revenue]}))
```",The evaluated code has a logic flaw: it uses 'ShippingCountry' instead of 'ShipCountry' to filter orders shipped to Germany. This discrepancy means the query won't return correct results if the column is named 'ShipCountry' as in the reference.,Base
Determine the freights cost totals for each month in 2023 and visualize them to identify trends.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Freight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY Month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Convert Month to datetime for proper sorting
data['Month'] = pd.to_datetime(data['Month'])

# Visualize the results
fig = px.line(data, x='Month', y='TotalFreight', title='Monthly Freight Costs in 2023', markers=True)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    SUM(Freight) AS TotalFreight 
FROM 
    orders 
WHERE 
    OrderDate >= '2023-01-01' AND 
    OrderDate < '2024-01-01'
GROUP BY 
    Month 
ORDER BY 
    Month
""""""

freight_data = execute_sql_query(sql_query)

fig = px.line(freight_data, x='Month', y='TotalFreight', title='Monthly Freight Costs in 2023', labels={'TotalFreight': 'Total Freight Cost', 'Month': 'Month'})
show_to_user(fig)
```","The evaluated code achieves the same goal as the reference code: calculating and visualizing the total freights per month for the year 2023. It uses an SQL query to sum freights by month, similarly restricting the date range to orders within 2023. While it uses a different SQL function (DATE_TRUNC), the logic remains consistent with the reference code by grouping and ordering by month. The visualization is done correctly using Plotly's line plot, ensuring the same analysis outcome as the reference implementation.","```python
import plotly.express as px

# SQL query to determine freight cost totals for each month in 2023
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM(Freight) AS TotalFreight 
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY 
    Month 
ORDER BY 
    Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the data to identify trends
fig = px.line(df, x='Month', y='TotalFreight', title='Freight Cost Trends in 2023')

# Display the visualization to the user
show_to_user(fig)
```","The input Python code is correct as it accurately captures the business analytics request. Both codes query the total freight costs for each month in 2023 from a database and visualize the data using a line chart. The key difference is the method to filter the year 2023: the reference code uses YEAR(OrderDate) = 2023, while the input code uses a date range. Both methods are equivalent in functionality and will produce the same dataset. The final visualization part is consistent with the reference code, effectively showing the trend of freight costs per month in 2023.",both
Which categories have an average unit price above $20?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CategoryName 
FROM categories c 
JOIN products p ON c.CategoryID = p.CategoryID 
GROUP BY c.CategoryName 
HAVING AVG(p.UnitPrice) > 20;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
HAVING AVG(p.UnitPrice) > 20
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code only returns CategoryID from the products table with an average unit price above $20, instead of the CategoryName from the categories table as per the reference implementation. The two codes differ in their logic; the input code does not join with the categories table to fetch the category names.","```python
import pandas as pd

# SQL query to get categories with an average unit price above $20
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AVERAGE_UNIT_PRICE
FROM products
GROUP BY CategoryID
HAVING AVG(UnitPrice) > 20.0;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The input Python code retrieves CategoryID with an average UnitPrice above $20, whereas the reference code retrieves CategoryName. The input does not join with the categories table to get the CategoryName.",None
Who are the suppliers for orders placed in the first quarter of this year?,"```python
import pandas as pd

# SQL query to find suppliers for orders placed in the first quarter of 2023
sql_query = """"""
SELECT DISTINCT s.CompanyName
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
suppliers_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(suppliers_df)
```","```python
from datetime import datetime

# Get the current year
current_year = datetime.now().year

# Formulate the SQL query to find suppliers for orders placed in the first quarter of the current year
sql_query = f""""""
SELECT DISTINCT s.SupplierID, s.CompanyName, s.ContactName, s.ContactTitle, s.Address, s.City, s.Region, s.PostalCode, s.Country, s.Phone
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= '{current_year}-01-01' AND o.OrderDate < '{current_year}-04-01'
""""""

# Execute the SQL query
suppliers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(suppliers_df)
```","The input code collects an extensive list of supplier details, whereas the reference code only retrieves distinct company names. The additional fields in the input code could lead to incorrect output if the intention was to match the reference code precisely. Additionally, the input assumes the current year dynamically, which might give different results than the fixed year 2023 as specified in the reference implementation.","```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT DISTINCT s.SupplierID, s.CompanyName 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute SQL Query
result_df = execute_sql_query(sql_query)

# Clean the result to get distinct suppliers only
result_df_distinct = result_df.drop_duplicates(subset=['SupplierID', 'CompanyName'])

# Show the result
show_to_user(result_df_distinct)
```","The provided code accomplishes the same task as the reference implementation. It correctly joins the orders, order details, products, and suppliers tables to find suppliers for orders placed in the first quarter of 2023. The main difference is that it initially selects both SupplierID and CompanyName and uses Pandas to ensure distinct results. Although this step might seem redundant because the SQL query already performs a DISTINCT operation, it does not contradict the logic of the task. Thus, the code is logically equivalent to the reference implementation.",Finetuned
What is the total sales quantity for each product and visualize to compare performance across products?,"```python
import plotly.express as px

# Execute the SQL query to retrieve the data
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalSales FROM [Order Details] GROUP BY ProductID;""
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales quantity for each product
fig = px.bar(df, x='ProductID', y='TotalSales', title='Total Sales Quantity for Each Product')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSalesQuantity',
             title='Total Sales Quantity for Each Product',
             labels={'TotalSalesQuantity': 'Sales Quantity', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly computes the total sales quantity for each product by joining the 'products' table with the 'Order Details' table, and grouping by ProductID and ProductName. The use of 'ProductName' in the visualization provides more context compared to just 'ProductID', aligning with the business request to compare performance across products. The use of `px.bar` for visualization and `show_to_user` to display the chart is consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Fetch the data using the provided utility function
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName;
""""""
sales_data = execute_sql_query(sql_query)

# Visualize the total sales quantity for each product
fig = px.bar(sales_data, x='ProductName', y='TotalQuantitySold', title='Total Sales Quantity per Product')

# Use the utility function to display the visualization
show_to_user(fig)
```","The input code differs from the reference implementation because it aggregates sales by 'ProductName' instead of 'ProductID'. While it correctly calculates and visualizes sales quantity, the business analytics request specifically asks for aggregation by product identifier, namely 'ProductID'. Additionally, involving 'ProductName' changes the grouping granularity, potentially leading to different numbers if multiple products share names.",Base
Which city has the highest number of orders?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) as NumberOfOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC 
LIMIT 1;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1;
""""""

highest_city_orders = execute_sql_query(sql_query)
show_to_user(highest_city_orders)
```","The input Python code correctly fulfills the business analytics request. It queries the database to count the number of orders per city and retrieves the city with the highest number of orders. The logic and structure are consistent with the reference implementation, although variable names differ slightly, which does not affect the correctness of the code.","```python
import pandas as pd

# SQL query to find the city with the highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","Both the input Python code and the reference implementation correctly address the business analytics request of identifying the city with the highest number of orders. They both use an SQL query that selects the city, counts the orders, groups by the city, orders by the count in descending order, and limits the result to the top entry. The slight difference in the alias used ('OrderCount' vs 'NumberOfOrders') does not affect the logic or outcome of the query.",both
What is the average order fulfillment time for each shipping method and visualize to compare performance?,"```python
import plotly.express as px

# SQL query to fetch the relevant data
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY ShipVia;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Rename columns if necessary
df.columns = ['ShipVia', 'AverageFulfillmentTime']

# Create a visualization to compare average fulfillment times
fig = px.bar(df, x='ShipVia', y='AverageFulfillmentTime', title='Average Order Fulfillment Time by Shipping Method')

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average order fulfillment time by shipping method
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipVia
""""""

# Execute the SQL query
fulfillment_data = execute_sql_query(sql_query)

# Visualization of the average order fulfillment time by shipping method
fig = px.bar(fulfillment_data, x='ShipVia', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Avg Fulfillment Time (days)'})

show_to_user(fig)
```","The input code uses DATEDIFF(ShippedDate, OrderDate) instead of DATEDIFF(day, OrderDate, ShippedDate) as in the reference code. This could lead to incorrect results if DATEDIFF doesn't default to 'day', if date fields are in wrong order, or SQL implementation differs. Other differences like column naming and visualization labels don't affect logic adherence.","```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average fulfillment time for each shipping method
fig = px.bar(df, x='ShipVia', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Avg Fulfillment Time (days)'})

# Show the plot
show_to_user(fig)
```","The input code incorrectly uses DATEDIFF with parameters (ShippedDate, OrderDate) instead of (day, OrderDate, ShippedDate) as in the reference. This results in the days difference being calculated in the reverse order, potentially leading to negative or incorrect values.",None
Which customers have placed orders in the last month?,"```python
import pandas as pd

# Define the SQL query to get customers who placed orders in the last month.
sql_query = ""SELECT CustomerID FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);""

# Execute the SQL query and retrieve the data.
df_customers = execute_sql_query(sql_query)

# Remove duplicate CustomerIDs if any.
df_unique_customers = df_customers.drop_duplicates()

# Display the customer data to the user.
show_to_user(df_unique_customers)
```","```python
from datetime import datetime, timedelta

# Calculate the date one month ago
last_month_date = datetime.now() - timedelta(days=30)
formatted_date = last_month_date.strftime('%Y-%m-%d')

# SQL query to get customers who placed orders in the last month
sql_query = f""""""
SELECT DISTINCT CustomerID
FROM orders
WHERE OrderDate >= '{formatted_date}'
""""""

# Execute the SQL query and get the results
result_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(result_df)
```","The input code correctly calculates the date one month ago and queries for customers who placed orders on or after that date. It uses DISTINCT to remove duplicate CustomerIDs directly in the SQL query, achieving the same effect as drop_duplicates in the reference implementation. Both pieces of code achieve the business objective of identifying unique customers who placed orders in the last month.","```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate the date one month ago
one_month_ago = datetime.now() - timedelta(days=30)
one_month_ago_str = one_month_ago.strftime('%Y-%m-%d')

# Define the SQL query
sql_query = f""""""
SELECT DISTINCT customers.CustomerID 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate >= '{one_month_ago_str}'
""""""

# Execute the SQL query
customer_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customer_data)
```","The input Python code correctly identifies customers who have placed orders in the last month using a SQL query that selects distinct CustomerIDs from the orders placed in the specified date range. The date computation uses a similar logic to determine the last month date, adhering to the essence of the reference implementation by considering the last 30 days. Both implementations remove duplicates effectively, either by using `DISTINCT` in the SQL query or `drop_duplicates()` on the DataFrame. Additionally, the final step of displaying results is consistent between both implementations.",both
List customers who have placed orders within the last 30 days.,"```python
import pandas as pd

# SQL query to get customers who have placed orders in the last 30 days
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders 
WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY);
""""""

# Execute the SQL query
customers_last_30_days = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_last_30_days)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate the date 30 days ago
thirty_days_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')

# Create SQL query to retrieve customers who placed orders in the last 30 days
sql_query = f""""""
SELECT DISTINCT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, 
                c.City, c.Region, c.PostalCode, c.Country, c.Phone
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate >= '{thirty_days_ago}'
""""""

# Execute the SQL query
customer_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(customer_data)
```","The input code retrieves additional customer details like CompanyName, ContactName, etc., from the 'customers' table. This provides a different output than the reference code, which only retrieves the CustomerID. The inclusion of extra data elements means the logic differs from the reference implementation.","```python
import pandas as pd

# SQL query string
sql_query = """"""
SELECT DISTINCT customers.CustomerID, customers.CompanyName 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate >= CURDATE() - INTERVAL 30 DAY;
""""""

# Execute the SQL query
customer_orders_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(customer_orders_df)
```",The input code successfully retrieves customers who have placed orders within the last 30 days. It joins the 'customers' and 'orders' tables and filters based on the 'OrderDate'. The additional selection of 'CompanyName' does not affect the task's requirement of listing distinct customers. The logic aligns with the reference implementation.,Finetuned
What are the names and unit prices of all products?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products;""

# Execute the query and get the results in a DataFrame
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)
```","```python
sql_query = ""SELECT ProductName, UnitPrice FROM products""
product_data = execute_sql_query(sql_query)
show_to_user(product_data)
```","The input Python code correctly retrieves the 'ProductName' and 'UnitPrice' from the 'products' table, matching the business request and adhering to the same logic as the reference implementation. The absence of a semicolon at the end of the SQL query does not affect its correctness or functionality in this context.","```python
import pandas as pd

# SQL query to get product names and unit prices
sql_query = ""SELECT ProductName, UnitPrice FROM products;""

# Execute the SQL query and get the results as a pandas dataframe
product_data = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(product_data)
```","The input code correctly retrieves product names and unit prices using an SQL query identical to the reference implementation. It assigns the result to a DataFrame and displays it, following the same logic and fulfilling the business request as described by the reference implementation.",both
Find the monthly sales performance for each product and visualize to identify sales trends.,"```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    EXTRACT(MONTH FROM o.OrderDate) AS Month, 
    SUM(od.Quantity) AS MonthlySales 
FROM [Order Details] od 
JOIN products p 
ON od.ProductID = p.ProductID 
JOIN orders o 
ON od.OrderID = o.OrderID 
GROUP BY p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as an integer for correct x-axis ordering
df['Month'] = df['Month'].astype(int)

# Create the visualization
fig = px.line(
    df, 
    x='Month', 
    y='MonthlySales', 
    color='ProductName',
    labels={'MonthlySales': 'Monthly Sales', 'Month': 'Month'},
    title='Monthly Sales Performance for Each Product'
)

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity) AS TotalSold
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, Month
ORDER BY 
    Month, p.ProductID
""""""

monthly_sales = execute_sql_query(sql_query)

fig = px.line(monthly_sales, x='Month', y='TotalSold', color='ProductName',
              title='Monthly Sales Performance by Product',
              labels={'TotalSold': 'Total Units Sold', 'Month': 'Month'})
show_to_user(fig)
```","The input code uses the DATE_FORMAT function to format the OrderDate as '%Y-%m', extracting year and month together, which is inconsistent with the reference code where only the month is extracted using EXTRACT(MONTH FROM o.OrderDate). The groupings and the intention to compare month by month are affected, making the results potentially different from required monthly trends across the entire dataset.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve monthly sales performance for each product
sql_query = """"""
SELECT p.ProductName, DATE_FORMAT(od.OrderDate, '%Y-%m') AS Month, 
SUM(od.Quantity) AS MonthlySales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName, Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as a categorical type for correct ordering
df['Month'] = pd.to_datetime(df['Month'])

# Create a line plot to visualize monthly sales trends for each product
fig = px.line(df, x='Month', y='MonthlySales', color='ProductName', 
              title='Monthly Sales Performance by Product', 
              markers=True)

# Display the plot
show_to_user(fig)
```","The input code uses DATE_FORMAT to extract 'Month' in 'YYYY-MM' format, missing the need to extract just the month and year like in the reference. This affects the grouping logic. The reference code extracts only the month, which is represented as an integer (1-12), and uses EXTRACT(MONTH FROM o.OrderDate). Additionally, the input code lacks a join with the orders table to retrieve order dates.",None
What is the total sales revenue generated last month?,"```python
# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales_Revenue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH)
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales revenue from the result
total_sales_revenue = result_df.loc[0, 'Total_Sales_Revenue']

# Show the result to the user
show_to_user(total_sales_revenue)
```","```python
from datetime import datetime, timedelta
import pandas as pd

last_month = (datetime.now() - pd.DateOffset(months=1)).strftime(""%Y-%m"")
sql_query = f""""""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '{last_month}'
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly calculates the total sales revenue for last month. It constructs a SQL query that sums up the sales revenue using UnitPrice, Quantity, and Discount from the [Order Details] table, joined with the orders table. The date filter uses DATE_FORMAT to match the OrderDate against the previous month, which aligns with the current date minus one month, formatted as '%Y-%m'. The query retrieves the same information as the reference implementation. Despite minor differences in formatting (like table aliasing and date handling), the logic remains consistent, making the implementation correct.","```python
import pandas as pd

# SQL query to get the total sales revenue for last month
last_month_sales_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE ORD_DATE >= DATE_SUB(LAST_DAY(CURRENT_DATE - INTERVAL 1 MONTH), INTERVAL DAY(LAST_DAY(CURRENT_DATE - INTERVAL 1 MONTH)) - 1 DAY)
AND ORD_DATE < LAST_DAY(CURRENT_DATE) + INTERVAL 1 DAY;
""""""

# Execute the SQL query
last_month_sales_df = execute_sql_query(last_month_sales_query)

# Show the result of the total sales revenue
show_to_user(last_month_sales_df)
```","The input code calculates the total sales using a different approach for determining the date range compared to the reference implementation. The reference code uses MONTH and YEAR functions to target the last month, while the input code uses DATE_SUB and LAST_DAY but fails to match the complete logic. Additionally, the input code attempts to display the entire DataFrame instead of extracting a single value for 'TotalSales' as the reference does.",Base
"Which employees have handled the most orders, and can this be illustrated using a bar chart to compare the number of orders handled by each employee?","```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrdersHandled
FROM orders
GROUP BY EmployeeID
ORDER BY OrdersHandled DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='EmployeeID', y='OrdersHandled', title='Number of Orders Handled by Each Employee')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""

employees_orders = execute_sql_query(sql_query)

fig = px.bar(employees_orders, x='EmployeeID', y='OrderCount', 
             title='Number of Orders Handled by Each Employee',
             labels={'OrderCount': 'Number of Orders', 'EmployeeID': 'Employee ID'})

show_to_user(fig)
```","The input Python code closely follows the logic and intent of the reference implementation. Both codes execute an SQL query that counts the number of orders handled by each employee and orders the results in descending order by the count. The input code labels the y-axis as 'Number of Orders' for clarity, which is a minor enhancement. The visualization part uses Plotly to create a bar chart, similar to the reference code, and both use 'show_to_user' to display the chart. Thus, the input code correctly accomplishes the task as specified.","```python
import plotly.express as px

# SQL query to get the employee order counts
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Create a bar chart comparing the number of orders handled by each employee
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Each Employee')

# Display the chart to the user
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. Both codes execute a SQL query to count the number of orders handled by each employee, group by EmployeeID, and sort by the order count in descending order. The retrieved data is used to create a bar chart using Plotly, with similar attributes for the x-axis, y-axis, and chart title. The minor difference in naming the count column ('OrdersHandled' vs 'OrderCount') does not affect the logic or correctness of the implementation.",both
