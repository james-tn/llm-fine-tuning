Question,Ground Truth Query,Generated Query by FT,Explanation by FT,Generated Query by Base Model,Explanation by Base Model,Model that got it right,Model that got it wrong
What was the average order value in Q1 of 2023?,SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AvgOrderValue FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31',"SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') as Month, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY Month;","The generated SQL query groups the results by month (DATE_FORMAT(o.OrderDate, '%Y-%m') as Month), which is not required by the user question. The ground truth query correctly calculates the overall average order value for the entire Q1 of 2023 without grouping by month.","```sql
SELECT 
    AVG(SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))) AS AverageOrderValue
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-04-01'
GROUP BY 
    orders.OrderID;
```","The generated SQL query calculates the average of sums grouped by OrderID (which is redundant) whereas the ground truth SQL query correctly averages the total order value by dividing the sum of order values by the count of distinct orders. Thus, the generated query does not accurately answer the user's question about the average order value for Q1 of 2023.",Both,None
Which products have the lowest units in stock?,"SELECT ProductID, ProductName, UnitsInStock FROM products ORDER BY UnitsInStock ASC LIMIT 1;","SELECT ProductID, ProductName FROM products ORDER BY UnitsInStock ASC;","The generated SQL query does not include the 'UnitsInStock' column, which is essential to verify that the products have the lowest stock. Additionally, it does not use the LIMIT 1 clause, which ensures only the product with the lowest units in stock is returned.","```sql
SELECT ProductID, ProductName, UnitsInStock
FROM products
ORDER BY UnitsInStock ASC
LIMIT 10;
```","The generated query returns the 10 products with the least units in stock, whereas the ground truth query returns only the single product with the least units in stock.",Both,None
Which customers placed the highest number of orders last year?,"SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 GROUP BY CustomerID ORDER BY OrderCount DESC","SELECT CustomerID, COUNT(OrderID) AS OrdersCount FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY CustomerID ORDER BY OrdersCount DESC;","The generated SQL query does not correctly filter for orders placed only in the last calendar year. Instead, it filters for orders placed within the last 365 days from the current date, which can span across two different years. The ground truth query correctly filters for orders within the previous calendar year.","```sql
SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE) - 1
GROUP BY CustomerID
ORDER BY NumberOfOrders DESC;
```",The generated SQL query correctly counts the number of orders placed by each customer in the previous year and orders the results in descending order of the number of orders. The differences in column aliases (NumberOfOrders vs OrderCount) do not affect the correctness of the query.,Base,FT
Which customers are from the United States?,SELECT CustomerID FROM orders WHERE ShipCountry = 'USA',SELECT CustomerID FROM orders WHERE ShipCountry = 'USA';,The generated SQL query correctly identifies customers from the United States by selecting CustomerID from the orders table where the ShipCountry is 'USA'.,"```sql
SELECT DISTINCT CustomerID 
FROM orders 
WHERE ShipCountry = 'United States';
```","The generated SQL query uses 'United States' for the ShipCountry value, while the ground truth query uses 'USA'. Without knowing the exact entries in the database, these might refer to different values and thus return different results. Furthermore, the generated query uses DISTINCT, which is not necessary given the question.",FT,Base
Which employees generated the highest sales revenue in April 2023?,"SELECT employees.FirstName, employees.LastName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales FROM [Order Details] JOIN orders ON [Order Details].OrderID = orders.OrderID JOIN employees ON orders.EmployeeID = employees.EmployeeID WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' GROUP BY employees.EmployeeID ORDER BY total_sales DESC","SELECT employees.EmployeeID, employees.FirstName, employees.LastName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales FROM [Order Details] JOIN orders ON [Order Details].OrderID = orders.OrderID JOIN employees ON orders.EmployeeID = employees.EmployeeID WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' GROUP BY employees.EmployeeID ORDER BY employee_sales DESC","Both queries correctly join the necessary tables, calculate the sales for each employee in April 2023, group by EmployeeID, and order by the sales in descending order. The difference in column selection (including EmployeeID in the generated query) does not affect the correctness regarding answering the user question.","```sql
SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY employees.EmployeeID
ORDER BY total_sales DESC
```","The generated SQL query correctly calculates the total sales and orders them in descending order. However, it returns 'EmployeeID' instead of 'FirstName' and 'LastName' as specified in the ground truth query. To fully answer the user's question as intended, employee names should be included.",FT,Base
Calculate the inventory turnover ratio for each month.,"SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) as InventoryTurnoverRatio FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');","SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID JOIN orders o ON od.OrderID = o.OrderID GROUP BY DATE_FORMAT(o.OrderDate, '%Y-%m');","The generated query includes a join with the 'orders' table and uses 'DATE_FORMAT(o.OrderDate, '%Y-%m')' in the GROUP BY clause, while the ground truth query does not include this join and uses 'DATE_FORMAT(OrderDate, '%Y-%m')' directly. This difference could potentially lead to incorrect results.","```sql
SELECT 
    MONTH(OrderDate) AS Month, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    products
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
GROUP BY 
    MONTH(OrderDate)
```","The generated query uses MONTH(OrderDate) to group by month, which only considers the month component and not the year. Thus, it may aggregate data incorrectly across different years. The ground truth query correctly uses DATE_FORMAT to group by year and month together. Additionally, the generated query includes an extra join with the ORDERS table, which is unnecessary for the question.",Both,None
What is the performance of products based on sales and inventory levels for each month in 2022?,"SELECT products.ProductID, MONTH(orders.OrderDate) AS order_month, SUM([Order Details].Quantity) AS product_performance FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY products.ProductID, order_month","SELECT p.ProductID, DATE_FORMAT(o.OrderDate, '%Y-%m') AS sales_month, SUM(od.Quantity) AS product_performance, SUM(od.Quantity * od.UnitPrice) AS sales_value FROM [Order Details] od JOIN orders o ON od.OrderID = o.OrderID JOIN products p ON od.ProductID = p.ProductID WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY p.ProductID, sales_month ORDER BY sales_month ASC","The generated SQL query includes 'SUM(od.Quantity * od.UnitPrice) AS sales_value', which is not present in the ground truth query. Additionally, the ground truth query uses 'MONTH(orders.OrderDate)' while the generated query uses 'DATE_FORMAT(o.OrderDate, '%Y-%m')'. The generated query also orders the result set, which is not specified in the ground truth query.","```sql
SELECT products.ProductID, 
       SUM([Order Details].Quantity) AS product_performance, 
       AVG(products.UnitsInStock) AS average_inventory 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, MONTH(orders.OrderDate)
```","The generated query includes an extra computation for average inventory levels, which is not asked for in the user question. Additionally, the generated SQL does not include the month of the order date in the SELECT clause, which is needed to meet the requirement of analyzing performance based on inventory levels and sales for each month in 2022.",Both,None
Which product had the highest sales quantity in the last month?,"SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID WHERE od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) GROUP BY p.ProductID, p.ProductName ORDER BY TotalQuantity DESC LIMIT 1;","```sql
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID WHERE od.OrderDate ≥ DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY p.ProductName ORDER BY TotalQuantity DESC LIMIT 1;
```","The generated SQL query has an issue with the usage of '≥' instead of '>=' which is incorrect syntax in SQL. Additionally, it does not group by 'ProductID', which could lead to incorrect results if there are products with the same name but different IDs.","```sql
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT DISTINCT OrderID
    FROM [Order Details]
    WHERE MONTH(OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
    AND YEAR(OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH)
)
GROUP BY p.ProductID
ORDER BY TotalQuantity DESC
LIMIT 1;
```","The generated SQL query uses a subquery to filter records from the last month based on the DISTINCT OrderID with the condition on OrderDate, leading to potential complications. The WHERE clause in the ground truth is more direct and accurate as it filters records based on the OrderDate directly. Additionally, the generated query only selects ProductName, while the ground truth also considers ProductID. The ground truth also uses DATE_SUB(CURDATE(), INTERVAL 1 MONTH) which is a more straightforward approach to filter dates from the last month.",Both,None
"For each employee, what is the average number of orders handled per month in 2023?","SELECT employees.EmployeeID, AVG(order_count) AS avg_orders_per_month FROM (SELECT employees.EmployeeID, COUNT(orders.OrderID) AS order_count, MONTH(orders.OrderDate) AS order_month FROM employees LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID GROUP BY employees.EmployeeID, MONTH(orders.OrderDate)) AS temp GROUP BY employees.EmployeeID","SELECT employees.EmployeeID, COUNT(orders.OrderID) AS avg_orders_per_month FROM orders JOIN employees ON orders.EmployeeID = employees.EmployeeID WHERE YEAR(orders.OrderDate) = 2023 GROUP BY employees.EmployeeID, MONTH(orders.OrderDate) ORDER BY avg_orders_per_month DESC","The generated SQL query does not correctly calculate the average number of orders handled per month for each employee in 2023. Instead, it provides the count of orders for each employee per month, but misses aggregating these counts to compute the average per month. Additionally, it doesn't handle scenarios where there might not be any orders for certain months.","```sql
SELECT employees.EmployeeID, 
       COUNT(orders.OrderID) / 12.0 AS average_orders_per_month 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY employees.EmployeeID;
```","The generated SQL query calculates the total number of orders handled by each employee in 2023 and then divides this number by 12 to get the average per month. This approach assumes all employees are handling orders every month and doesn't account for employees who may not handle orders in certain months. The ground truth query, on the other hand, calculates the number of orders per month for each employee and then takes the average, which is a more accurate representation of the average monthly orders for each employee.",Both,None
Which products have not been ordered in the last three months?,"SELECT ProductName FROM products WHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM [Order Details] WHERE OrderID IN (SELECT OrderID FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)));","SELECT p.ProductName FROM products p LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID WHERE od.OrderID IS NULL OR p.ProductID NOT IN (SELECT DISTINCT ProductID FROM [Order Details] WHERE DATE_SUB(CURDATE(), INTERVAL 3 MONTH) < OrderDate);",The generated SQL query does not correctly identify products which have not been ordered in the last three months. The condition 'od.OrderID IS NULL' does not correctly filter out products that have orders in the last three months. The Ground Truth SQL query correctly focuses on filtering out products based on the 'OrderDate' from the 'orders' table.,"```sql
SELECT p.ProductID, p.ProductName 
FROM products p 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.OrderID IS NULL OR od.OrderID NOT IN (
    SELECT OrderID 
    FROM [Order Details] 
    WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE())
)
```","The generated SQL query will not return the correct answer. It attempts to join products with 'Order Details' but does not include the necessary relationship with the 'orders' table to check the 'OrderDate'. Additionally, the condition 'od.OrderID IS NULL' is intended to find products that have never been ordered, which is not necessary or relevant to determining if they have been ordered in the last three months.",Both,None
What is the average Inventory Turnover Ratio for each month?,"SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID JOIN orders o ON od.OrderID = o.OrderID GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');","SELECT DATE_TRUNC('month', o.OrderDate) AS Month, (SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)) AS AvgInventoryTurnover FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID JOIN orders o ON o.OrderID = od.OrderID GROUP BY DATE_TRUNC('month', o.OrderDate);","The generated SQL query uses DATE_TRUNC to truncate the date to a month, while the ground truth SQL query uses DATE_FORMAT. Additionally, the generated SQL query groups by DATE_TRUNC, whereas ground truth groups by DATE_FORMAT. Also, the generated SQL query uses AVGInventoryTurnover as the alias for the calculated field, while the ground truth query uses InventoryTurnoverRatio.","```sql
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS Average_Inventory_Turnover_Ratio
FROM 
    [Order Details]
JOIN 
    products ON [Order Details].ProductID = products.ProductID
GROUP BY 
    Month
```","The generated SQL query is missing a JOIN on the 'orders' table to properly obtain the 'OrderDate' field. Without this join, 'OrderDate' in the SELECT clause is ambiguous and will result in an error or incorrect data retrieval.",Both,None
What percentage of orders were shipped after the required date each month?,"SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) / COUNT(OrderID) AS LateDeliveryRate FROM orders GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')","SELECT year(o.OrderDate) AS year, month(o.OrderDate) AS month, (COUNT(CASE WHEN o.ShippedDate > o.RequiredDate THEN 1 END) * 100.0 / COUNT(o.OrderID)) AS LateDeliveryRate FROM orders o GROUP BY year(o.OrderDate), month(o.OrderDate)","Both queries correctly calculate the percentage of orders shipped after the required date each month. The generated query uses the year and month functions separately while the ground truth query uses DATE_FORMAT, but the results will be the same.","```sql
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    (COUNT(orders.OrderID WHERE orders.ShippedDate > orders.RequiredDate) / COUNT(orders.OrderID)) * 100 AS Percentage_Shipped_After_Required_Date
FROM 
    orders
GROUP BY 
    Month
```",The generated query attempts to use the 'WHERE' clause incorrectly within the 'COUNT' function. It should use a 'CASE WHEN' statement within the 'COUNT' function to count orders shipped after the required date.,FT,Base
Which shipping method was used most frequently?,"SELECT ShipVia, COUNT(OrderID) AS UsageCount FROM orders GROUP BY ShipVia ORDER BY UsageCount DESC LIMIT 1","SELECT ShipVia, COUNT(OrderID) AS ShippingMethodCount FROM orders GROUP BY ShipVia;",The generated SQL query lists the count of orders per shipping method but does not determine which method was used the most frequently. The ground truth query orders the results and limits it to the most frequently used shipping method.,"```sql
SELECT ShipVia, COUNT(*) AS Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
LIMIT 1;
```","Both the generated SQL query and the ground truth SQL query are functionally equivalent. They both select the shipping method (ShipVia) and the count of orders grouped by ShipVia, then order the results by the count in descending order, and limit the output to the most frequently used shipping method. The difference in column names does not affect the correctness of the answer.",Base,FT
What is the customer retention rate from January 2022 to January 2023?,(SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2023-01-01') / (SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate < '2022-01-01') AS customer_retention_rate,(SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2023-01-01') / (SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate < '2022-01-01') AS customer_retention_rate,"The generated SQL query and the ground truth SQL query are identical. However, they do not correctly calculate the customer retention rate. The correct calculation should be the count of customers who made at least one order before January 2022 and also made at least one order between January 2022 and January 2023, divided by the count of customers who made at least one order before January 2022.","```sql
(SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2023-01-31') / (SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate < '2022-01-01') AS customer_retention_rate
```",The generated SQL query incorrectly includes the date '2023-01-31' instead of '2023-01-01' in the date range. This causes the retention rate to be calculated over an extended period compared to the user question and the ground truth query.,Both,None
What is the average order value for the year 2021?,SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AverageOrderValue FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID WHERE YEAR(orders.OrderDate) = 2021;,SELECT (SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID)) AS AvgOrderValue FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE YEAR(o.OrderDate) = 2021;,"Both queries are functionally equivalent, using the correct tables and columns, with necessary joins and WHERE condition for the year 2021. They both calculate the average order value for the year 2021 accurately.","```sql
SELECT 
    AVG(SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))) AS AverageOrderValue
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    YEAR(orders.OrderDate) = 2021
GROUP BY 
    orders.OrderID;
```","The generated SQL query calculates the average of individual order totals after grouping by OrderID, rather than directly computing the total sales value and dividing by the distinct number of orders to get the average order value. This differs from the ground truth query, which correctly calculates the average order value by summing the orders and dividing by the count of distinct order IDs.",FT,Base
Identify the top 3 products with the most number of orders.,"SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) AS NumberOfOrders FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.ProductID, p.ProductName ORDER BY NumberOfOrders DESC LIMIT 3;","```sql
SELECT p.ProductID, COUNT(od.OrderID) AS OrderCount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID 
ORDER BY OrderCount DESC 
LIMIT 3;
```","The generated SQL query correctly identifies the top 3 products with the most number of orders. Although it does not include the ProductName column, which is present in the ground truth query, the user question does not explicitly ask for product names. Hence, the generated query still satisfies the user question by providing the ProductID and the order count.","```sql
SELECT TOP 3 products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalOrders
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY TotalOrders DESC;
```","The generated SQL query calculates the total quantity of all products ordered (SUM([Order Details].Quantity)) rather than the number of orders placed for each product (COUNT(od.OrderID)). While both can indicate popularity, the user question specifies the number of orders, not the quantity ordered.",FT,Base
What are the average monthly sales generated by each region?,"SELECT territories.RegionID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT DATE_TRUNC('month', orders.OrderDate)) AS avg_monthly_sales FROM [Order Details] JOIN orders ON [Order Details].OrderID = orders.OrderID JOIN employees ON orders.EmployeeID = employees.EmployeeID JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID GROUP BY territories.RegionID","SELECT r.RegionID, (SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID)) AS avg_monthly_sales FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID JOIN employeeTerritories et ON o.EmployeeID = et.EmployeeID JOIN territories r ON et.TerritoryID = r.TerritoryID GROUP BY r.RegionID","The generated SQL query does not correctly calculate the average monthly sales. It divides the total sales by the count of distinct OrderIDs rather than the count of distinct months in the order dates. Additionally, it doesn't handle the date truncation to determine the months.","```sql
SELECT region.RegionDescription, 
       AVG(total_sales) AS average_monthly_sales 
FROM (
    SELECT region.RegionDescription, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
    FROM orders 
    JOIN employees ON orders.EmployeeID = employees.EmployeeID 
    JOIN territories ON employees.EmployeeID = employeeTerritories.EmployeeID 
    JOIN region ON territories.RegionID = region.RegionID 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    GROUP BY region.RegionDescription, YEAR(orders.OrderDate), MONTH(orders.OrderDate)
) AS monthly_sales 
GROUP BY region.RegionDescription;
```","The Generated SQL Query and Ground Truth SQL Query both aim to calculate average monthly sales by region. However, the Generated SQL Query joins incorrect tables or fields. Specifically, in the generated SQL, the join conditions are incorrect (e.g., employees join with territories directly) and also it lacks the distinct month count which is crucial for calculating the true monthly average. On the other hand, Ground Truth SQL correctly handles the table joins and calculates the average monthly sales by considering distinct months.",Both,None
Find the order with the highest discount applied.,"SELECT od.OrderID, MAX(od.Discount) FROM [Order Details] od;","SELECT o.OrderID, od.Discount FROM [Order Details] od JOIN orders o ON o.OrderID = od.OrderID ORDER BY od.Discount DESC LIMIT 1;","The generated query arranges all the orders and picks the first one, whereas the ground truth query directly extracts the maximum discount applied among orders. The ordering method in the generated query could lead to different results if there are ties in the highest discount.","```sql
SELECT OrderID, ProductID, UnitPrice, Quantity, Discount
FROM [Order Details]
ORDER BY Discount DESC
LIMIT 1;
```","The generated SQL query does not correctly correspond to the user question. It attempts to find the order with the highest discount by sorting all records and limiting the result to one row, which can be correct. However, it selects additional fields (ProductID, UnitPrice, Quantity) that are unnecessary. It should focus on the OrderID with the highest discount or apply an aggregate function directly to find the highest discount per order.",Both,None
Calculate the monthly total sales revenue over the last year.,"SELECT MONTH(o.OrderDate) AS Month, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) GROUP BY MONTH(o.OrderDate) ORDER BY Month;","SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlyTotalSales FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE OrderDate > DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY Month","The generated SQL query uses DATE_FORMAT to get the month and year combined, GROUPS by this combined format, and uses DATE_SUB to consider the sales in the last 12 months. The generated query may include partial months from over a year ago while the ground truth query considers only the months within the current year utilizing YEAR function, making it a year-to-date calculation.","```sql
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    Month
ORDER BY 
    Month;
```","The generated query calculates the monthly total sales revenue for the last 12 months from the current date, whereas the ground truth query calculates the monthly total sales revenue for the current calendar year. The date range filters are different.",Both,None
Who is the highest paid employee and what is their total sales?,"SELECT e.EmployeeID, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY e.EmployeeID ORDER BY e.Salary DESC LIMIT 1;","SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY e.EmployeeID ORDER BY e.Salary DESC LIMIT 1;","The generated SQL query returns the highest paid employee and their total sales. It includes additional columns (FirstName, LastName) which are not in the ground truth query but still answers the user's question correctly and follows the correct schema.","```sql
SELECT e.FirstName, e.LastName, e.Salary, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
LEFT JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY e.Salary DESC
LIMIT 1;
```","The generated query incorrectly groups by e.EmployeeID without including all non-aggregated columns in the SELECT clause (e.FirstName, e.LastName, e.Salary). The absence of FirstName and LastName in the ground truth makes it unclear if they are valid fields. Additionally, if the employees table doesn't contain these fields or if grouping isn't properly handled, this can cause errors or incorrect results. Finally, the generated query utilizes LEFT JOIN which may include employees with no sales, whereas INNER JOIN ensures only employees with sales are considered.",FT,Base
How does the total number of units sold compare between discontinued and active products?,"SELECT products.Discontinued, SUM([Order Details].Quantity) AS TotalUnitsSold FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID GROUP BY products.Discontinued","SELECT p.ProductName, SUM(CASE WHEN p.Discontinued = 1 THEN od.Quantity ELSE 0 END) AS TotalUnitsSoldDiscontinued, SUM(CASE WHEN p.Discontinued = 0 THEN od.Quantity ELSE 0 END) AS TotalUnitsSoldActive FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.ProductName;",The generated SQL query incorrectly groups by ProductName and aggregates units sold separately for each product. The user question requires a comparison of total units sold between discontinued and active products as a whole. The ground truth query correctly groups by the Discontinued status and sums the quantities accordingly.,"```sql
SELECT 
    CASE 
        WHEN p.Discontinued = 1 THEN 'Discontinued' 
        ELSE 'Active' 
    END AS ProductStatus,
    SUM(od.Quantity) AS TotalUnitsSold
FROM 
    products p
LEFT JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.Discontinued;
```","Both queries correctly calculate the total number of units sold for discontinued and active products. The generated query uses a CASE statement to label the product status as 'Discontinued' or 'Active', and it uses a LEFT JOIN instead of an INNER JOIN, but these differences do not change the correctness of the result.",Base,FT
Identify the product categories with the lowest total sales revenue.,"SELECT CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.CategoryID ORDER BY TotalRevenue ASC LIMIT 1;","```sql
SELECT c.CategoryName, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON p.ProductID = od.ProductID 
JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryName 
ORDER BY TotalRevenue ASC;
```","The generated query does not limit the result to the category with the lowest total sales revenue. It lists all categories sorted by total revenue in ascending order. Additionally, the ground truth query uses 'LIMIT 1' to ensure only the category with the lowest revenue is returned.","```sql
SELECT products.CategoryID, SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSalesRevenue
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.CategoryID
ORDER BY TotalSalesRevenue ASC;
```",The generated SQL query lists all product categories ordered by total sales revenue in ascending order but does not limit the result to the lowest total sales revenue category. The ground truth query includes a LIMIT 1 clause to identify only the lowest total sales revenue category.,Both,None
Calculate the month-over-month growth rate of total sales for December 2023.,"SELECT (SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) - LAG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) OVER (ORDER BY DATE_FORMAT(o.OrderDate, '%Y-%m'))) / LAG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) OVER (ORDER BY DATE_FORMAT(o.OrderDate, '%Y-%m') ) AS MoM_GrowthRate FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') IN ('2023-11', '2023-12');","SELECT ((SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / SUM(od2.UnitPrice * od2.Quantity * (1 - od2.Discount)) - 1) * 100) AS MoM_Growth_Rate FROM [Order Details] od JOIN orders o ON od.OrderID = o.OrderID JOIN [Order Details] od2 ON od2.OrderID = o2.OrderID AND DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-12' WHERE o.OrderDate BETWEEN DATE_SUB('2023-12-01', INTERVAL 1 MONTH) AND DATE_ADD('2023-12-01', INTERVAL 1 MONTH GROUP BY DATE_FORMAT(o.OrderDate, '%Y-%m'))",The generated SQL query has syntax issues and uses incorrect logic to calculate the month-over-month growth rate. It attempts to join the same table twice without proper aliasing and has malformed date conditions without proper aggregation logic. The ground truth SQL query correctly calculates the growth by comparing the sales of two consecutive months using the LAG function.,"```sql
WITH MonthlySales AS (
    SELECT 
        DATE_FORMAT(OrderDate, '%Y-%m') AS SaleMonth,
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
    FROM 
        orders
    JOIN 
        [Order Details] ON orders.OrderID = [Order Details].OrderID
    WHERE 
        OrderDate >= '2023-11-01' AND OrderDate < '2024-01-01'
    GROUP BY 
        SaleMonth
)

SELECT 
    (CurrentMonth.TotalSales - PreviousMonth.TotalSales) / PreviousMonth.TotalSales * 100 AS GrowthRate
FROM 
    (SELECT TotalSales FROM MonthlySales WHERE SaleMonth = '2023-12') AS CurrentMonth,
    (SELECT TotalSales FROM MonthlySales WHERE SaleMonth = '2023-11') AS PreviousMonth;
```","The generated SQL query correctly calculates the month-over-month growth rate for total sales for December 2023 by first calculating the total sales for November and December 2023 and then finding the percentage growth rate. The approach is different from the ground truth query, which uses window functions, but the final result addresses the user's question correctly. Both queries use the same schema and necessary fields, resulting in the correct answer.",Base,FT
How many products have a reorder level of zero?,SELECT COUNT(*) AS ZeroReorderProducts FROM products WHERE ReorderLevel = 0,"SELECT ProductID, ProductName FROM products WHERE ReorderLevel = 0;","The generated SQL query selects the ProductID and ProductName for products where the ReorderLevel is zero, which lists the products with different attributes but does not count them. The ground truth SQL query correctly counts how many products have a reorder level of zero.","```sql
SELECT COUNT(*) AS NumberOfProducts
FROM products
WHERE ReorderLevel = 0;
```","Both queries correctly count the number of products with a reorder level of zero, even though they use different column labels for the result set.",Base,FT
"List the count of products in each category, supplied by supplier.","SELECT s.SupplierID, s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID GROUP BY s.SupplierID, s.CompanyName, p.CategoryID;","```sql
SELECT p.CategoryID, s.SupplierID, COUNT(*) AS ProductCount FROM products p JOIN suppliers s ON p.SupplierID = s.SupplierID GROUP BY p.CategoryID, s.SupplierID;
```","The generated query does not include the supplier's company name, which is part of the ground truth query. While both queries provide the count of products in each category by supplier, the generated query omits a required column (CompanyName) that was included in the ground truth query.","```sql
SELECT p.CategoryID, s.SupplierID, COUNT(p.ProductID) AS ProductCount
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY p.CategoryID, s.SupplierID
```","The generated SQL query correctly lists the count of products in each category supplied by each supplier. Although it doesn't include the 'CompanyName' column, the core requirement of counting products per category per supplier is met with the 'SupplierID'.",Base,FT
Which products have less than 10 units in stock?,"SELECT ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10;","SELECT ProductID, ProductName FROM products WHERE UnitsInStock < 10;","The generated SQL query includes the column 'ProductID' which is not in the Ground Truth SQL query. The Ground Truth SQL query includes the column 'UnitsInStock' which is not in the generated SQL query. Therefore, they will not produce the same result set.","```sql
SELECT ProductID, ProductName, UnitsInStock
FROM products
WHERE UnitsInStock < 10;
```","The generated SQL query correctly identifies products with less than 10 units in stock. Although it includes the ProductID column which is not in the ground truth query, it still answers the user's question accurately by providing the ProductName and UnitsInStock.",Base,FT
Identify the customer with the most late shipments.,"SELECT c.CustomerID, COUNT(o.OrderID) AS LateOrderCount FROM customers c JOIN orders o ON c.CustomerID = o.CustomerID WHERE o.RequiredDate < o.ShippedDate GROUP BY c.CustomerID ORDER BY LateOrderCount DESC LIMIT 1;","SELECT o.CustomerID, COUNT(*) AS LateShipments FROM orders o WHERE o.ShippedDate IS NOT NULL AND o.ShippedDate > o.RequiredDate GROUP BY o.CustomerID ORDER BY LateShipments DESC;","The generated query does not include a LIMIT 1 clause, which means it will return all customers with late shipments ordered by count. The user question specifically asks for the customer with the most late shipments, which requires returning only the top result.","```sql
SELECT orders.CustomerID, COUNT(*) AS LateShipments
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY orders.CustomerID
ORDER BY LateShipments DESC
LIMIT 1;
```","The generated SQL query correctly identifies the customer with the most late shipments by counting the number of times the shipped date is later than the required date, grouping by customer ID, and ordering by the count in descending order to get the highest count. The schema aligns with the ground truth query and the result set will be the same.",Base,FT
Find the orders placed in the last 30 days and their total freight cost.,"SELECT o.OrderID, o.OrderDate, o.ShippedDate, o.Freight FROM orders o WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 30 DAY);","```sql
SELECT SUM(Freight) AS TotalFreightCost FROM orders WHERE OrderDate >= CURDATE() - INTERVAL 30 DAY;
```","The generated SQL query only calculates the total freight cost of the orders placed in the last 30 days, whereas the user question asks for the orders themselves along with their total freight costs. The ground truth query lists the orders with their details for the last 30 days. ","```sql
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE OrderDate >= CURDATE() - INTERVAL 30 DAY;
```","The generated SQL query only calculates the total freight cost of orders placed in the last 30 days, but it does not include the details of each order as required by the user's question. The ground truth SQL query retrieves the order ID, order date, shipped date, and freight cost for each order placed in the last 30 days.",Both,None
What is the monthly inventory turnover ratio?,"SELECT DATEPART(month, OrderDate) AS Month, SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS InventoryTurnoverRatio FROM [Order Details] OD JOIN products P ON OD.ProductID = P.ProductID GROUP BY DATEPART(month, OrderDate);","SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID JOIN products p ON od.ProductID = p.ProductID GROUP BY Month;","While both the generated query and the ground truth query aim to compute the monthly inventory turnover ratio, there are differences in the use of functions. The generated query uses DATE_FORMAT(o.OrderDate, '%Y-%m') to extract the month and year, while the ground truth query uses DATEPART(month, OrderDate) to extract only the month. Additionally, the generated query includes the orders table (o), which is not present in the ground truth query. These differences can lead to discrepancies in the results.","```sql
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS Month, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
```","The generated SQL query includes an additional join with the 'orders' table, which is unnecessary for calculating the inventory turnover ratio and could impact the results. Additionally, the use of DATE_TRUNC instead of DATEPART means it is not consistent with the ground truth SQL query's method of extracting the month.",Both,None
Find the CustomerID and the total number of orders for each customer who has ordered more than 10 times.,"SELECT customers.CustomerID, COUNT(orders.OrderID) AS order_count FROM customers INNER JOIN orders ON customers.CustomerID = orders.CustomerID GROUP BY customers.CustomerID HAVING COUNT(orders.OrderID) > 10","```sql
SELECT c.CustomerID, COUNT(o.OrderID) AS TotalOrders FROM customers c JOIN orders o ON c.CustomerID = o.CustomerID GROUP BY c.CustomerID HAVING TotalOrders > 10;
```","The generated SQL query correctly joins the 'customers' and 'orders' tables on the 'CustomerID' field, groups by 'CustomerID', counts the 'OrderID', and filters for customers with more than 10 orders. The column labels and aggregate function usage align with the user's question.","```sql
SELECT CustomerID, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10;
```",The generated SQL query does not account for the customers who have not placed any orders. It only queries from the orders table and does not join with the customers table to include all customers. The ground truth query correctly joins the customers and orders tables to ensure all customers are accounted for.,FT,Base
How many orders were shipped over a week late in August 2023?,"SELECT COUNT(OrderID) AS LateOrders FROM orders WHERE DATEDIFF(ShippedDate, RequiredDate) > 7 AND OrderDate BETWEEN '2023-08-01' AND '2023-08-31';","```sql
SELECT COUNT(*) AS LateOrders FROM orders WHERE ShippedDate > RequiredDate AND DATE_FORMAT(OrderDate, '%Y-%m') = '2023-08';
```","The generated SQL query checks if ShippedDate is merely after RequiredDate, which includes all orders shipped late (even by one day), whereas the ground truth SQL query accurately checks if the ShippedDate is more than a week late compared to RequiredDate. Additionally, the date filtering for August 2023 in the generated query is based on OrderDate, but it should be adjusted to focus on orders actually late by a week.","```sql
SELECT COUNT(OrderID) AS LateOrders
FROM orders
WHERE ShippedDate > DATEADD(DAY, 7, RequiredDate)
  AND OrderDate >= '2023-08-01'
  AND OrderDate <= '2023-08-31';
```","Both queries correctly count the number of orders that were shipped more than 7 days late in August 2023. The key difference lies in the method used to calculate lateness (DATEADD vs DATEDIFF), but both achieve the same result. The date filtering for August 2023 is also correctly applied in both.",Base,FT
What is the average freight cost for orders shipped to Europe?,"SELECT AVG(Freight) AS AverageFreightCost FROM orders WHERE ShipCountry IN ('Austria', 'Belgium', 'Denmark', 'Finland', 'France', 'Germany', 'Greece', 'Ireland', 'Italy', 'Netherlands', 'Norway', 'Poland', 'Portugal', 'Spain', 'Sweden', 'Switzerland', 'United Kingdom');",SELECT AVG(Freight) AS AvgFreightCost FROM orders WHERE ShipRegion = 'Europe';,"The generated SQL query uses the 'ShipRegion' column to determine if the orders are shipped to Europe, while the ground truth query uses a list of European countries specified in the 'ShipCountry' column. The correctness of the generated query depends on the schema and data in the 'ShipRegion' column ensuring it accurately represents shipping to Europe, which is not guaranteed here.","```sql
SELECT AVG(Freight) AS AverageFreightCost
FROM orders
WHERE ShipCountry IN ('France', 'Germany', 'Italy', 'Spain', 'United Kingdom', 'Netherlands', 'Belgium', 'Sweden', 'Austria', 'Denmark', 'Finland', 'Ireland', 'Norway', 'Switzerland', 'Portugal', 'Greece', 'Poland', 'Czech Republic', 'Hungary', 'Romania', 'Slovakia');
```","The generated SQL query includes an extensive list of countries in Europe, with some additional ones that are valid entries for Europe. Both queries aim to calculate the average freight cost for orders shipped to European countries, and the schema and logic are correct.",Base,FT
Calculate the total freight cost for each shipping company in 2023.,"SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost FROM orders JOIN shippers ON orders.ShipVia = shippers.ShipperID WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY shippers.CompanyName","SELECT shippers.ShipperID, SUM(orders.Freight) AS total_freight_cost FROM orders JOIN shippers ON orders.ShipVia = shippers.ShipperID WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY shippers.ShipperID","The generated SQL query groups by ShipperID instead of CompanyName. The user question asks for the total freight cost for each shipping company, which implies the result should be aggregated and labeled by the CompanyName rather than the ShipperID.","```sql
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY shippers.CompanyName;
```","The generated SQL query correctly calculates the total freight cost for each shipping company in 2023 by summing the 'Freight' values from the 'orders' table, where the 'OrderDate' is within the specified date range, and groups the results by 'CompanyName' from the 'shippers' table. The syntax and logic are correct and will produce the desired output.",Base,FT
What is the total number of orders shipped via each shipping method per month?,"SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, ShipVia, COUNT(OrderID) AS OrdersShipped FROM orders GROUP BY Month, ShipVia;","SELECT ShipVia, DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrdersCount FROM orders GROUP BY ShipVia, Month;",The generated SQL query and the ground truth SQL query will produce the same result set. Both group the data by shipping method and month and count the number of orders. The order of the columns in the GROUP BY clause does not affect the result.,"```sql
SELECT 
    ShipVia, 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS TotalOrders
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    ShipVia, 
    Month
ORDER BY 
    Month;
```",The generated SQL query uses 'ShippedDate' instead of 'OrderDate' and also limits the results to non-null shipped dates. These deviations could lead to different results compared to the ground truth query which counts orders based on 'OrderDate'.,FT,Base
Which products need to be reordered?,SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;,SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;,"The generated SQL query uses the '<' operator, which excludes items where UnitsInStock is exactly equal to ReorderLevel. The ground truth query correctly includes these items with the '<=' operator.","```sql
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel;
```","The generated SQL query correctly identifies the products that need to be reordered by checking if the UnitsInStock is less than or equal to the ReorderLevel. While it includes additional columns (ProductID and UnitsInStock), these do not detract from its correctness.",Base,FT
How many orders were placed and fulfilled in each month of 2023?,"SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, COUNT(orders.OrderID) AS orders_placed, COUNT(CASE WHEN orders.ShippedDate IS NOT NULL THEN 1 END) AS orders_fulfilled FROM orders WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY month ORDER BY month","SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, COUNT(orders.OrderID) AS orders_placed FROM orders WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY month;","The generated SQL query only counts the orders placed in each month of 2023, but does not account for the orders fulfilled. The user question asked for both the number of orders placed and fulfilled, which the ground truth query correctly addresses by including a condition to count orders with a shipped date.","```sql
SELECT MONTH(orders.OrderDate) AS month, 
       COUNT(orders.OrderID) AS total_orders 
FROM orders 
WHERE YEAR(orders.OrderDate) = 2023 
AND orders.ShippedDate IS NOT NULL 
GROUP BY MONTH(orders.OrderDate)
```","The generated SQL query does not distinguish between orders placed and orders fulfilled. It only counts orders that were placed and fulfilled for each month of 2023, but the user question asks for a count of all orders placed in each month and then how many of them were fulfilled. The ground truth query correctly separates these counts.",Both,None
What is the total value of orders shipped in the first quarter of 2023?,"SELECT QUARTER(o.OrderDate) AS OrderQuarter, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE YEAR(o.OrderDate) = 2023 GROUP BY OrderQuarter;",SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValueQ12023 FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.ShippedDate BETWEEN '2023-01-01' AND '2023-03-31';,"The generated SQL query correctly calculates the total value of orders shipped in the first quarter of 2023 by summing the UnitPrice, Quantity, and applying the Discount, and it filters orders shipped between January 1st, 2023 and March 31st, 2023. The difference in using ShippedDate versus OrderDate is context-specific but generally acceptable as both refer to the timeframe for the first quarter of 2023.","```sql
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.ShippedDate >= '2023-01-01' AND o.ShippedDate <= '2023-03-31';
```","The generated SQL query correctly calculates the total value of orders shipped in the first quarter of 2023. However, the ground truth SQL query focuses on orders placed in 2023 and groups the result by quarter, which is not asked by the user. Both are different in their approach, but the generated query satisfies the user's question by directly calculating the total value of orders shipped in the specified period.",FT,Base
What is the Customer Retention Rate for the last 6 months?,"SELECT (SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 6 MONTH) AND CURDATE()) / (SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate < DATE_SUB(CURDATE(), INTERVAL 6 MONTH)) AS CustomerRetentionRate;","To calculate the Customer Retention Rate for the last 6 months, we need to compare the number of unique customers who placed orders in the last 6 months with those who had placed orders before that period.

## SQL Query:
```sql
WITH current_customers AS (
    SELECT COUNT(DISTINCT orders.CustomerID) AS CurrentRate 
    FROM orders 
    WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 6 MONTH) AND CURDATE()
), 
past_customers AS (
    SELECT COUNT(DISTINCT orders.CustomerID) AS PastRate 
    FROM orders 
    WHERE orders.OrderDate < DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
) 
SELECT (CurrentRate / PastRate) * 100 AS RetentionRate 
FROM current_customers, past_customers;
```",Both the generated query and the ground truth query are calculating the Customer Retention Rate for the last 6 months. The generated query uses Common Table Expressions (CTEs) to get the counts of unique customers in the current and past periods and then computes the retention rate. The ground truth query directly uses subqueries within the SELECT statement to achieve the same result. Both queries correctly utilize the schema and answer the question.,"```sql
SELECT 
    (COUNT(DISTINCT orders.CustomerID) 
     WHERE orders.OrderDate BETWEEN DATEADD(MONTH, -6, GETDATE()) AND GETDATE()) 
    / 
    (COUNT(DISTINCT orders.CustomerID) 
     WHERE orders.OrderDate < DATEADD(MONTH, -6, GETDATE())) 
) AS CustomerRetentionRate
FROM 
    orders;
```","The generated SQL query is incorrect because it improperly uses COUNT in the SELECT clause without proper subqueries or aggregation, and it erroneously structures the WHERE clauses inside the COUNT function. The ground truth query correctly separates the counts into distinct subqueries.",FT,Base
Which product category has the highest total sales in 2023?,"SELECT categories.CategoryName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN categories ON products.CategoryID = categories.CategoryID WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY categories.CategoryName ORDER BY total_sales DESC","SELECT categories.CategoryID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN categories ON products.CategoryID = categories.CategoryID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY categories.CategoryID ORDER BY total_sales DESC","The generated SQL query is missing the 'orders' table in the JOIN clauses. Specifically, it should include 'JOIN orders ON [Order Details].OrderID = orders.OrderID'. As a result, the query will not filter by the correct order date range, which is necessary to answer the question correctly.","```sql
SELECT categories.CategoryID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY categories.CategoryID
ORDER BY total_sales DESC
LIMIT 1;
```","The generated SQL query mistakenly left out the JOIN clause for the 'orders' table; hence, it will not filter the results by the OrderDate. Additionally, the generated query groups by 'CategoryID', while the ground truth query groups by 'CategoryName'. The ground truth query aim is to display the category name with the highest total sales.",Both,None
What is the total inventory value of products currently in stock?,SELECT SUM(UnitsInStock * UnitPrice) AS TotalInventoryValue FROM products;,SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue FROM products WHERE Discontinued = 0;,"The generated SQL query includes a condition (WHERE Discontinued = 0) to filter out discontinued products, while the user question and ground truth SQL query do not specify this condition. The Ground Truth SQL Query calculates the total inventory value of all products in stock without any condition on the Discontinued status.","```sql
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products
WHERE Discontinued = 0;
```","The generated query includes a condition `WHERE Discontinued = 0`, which only considers products that are not discontinued. The ground truth query does not have this condition and thus considers all products. Therefore, the generated query might exclude some products, resulting in a different total inventory value.",Both,None
Find the average quantity of products ordered per order.,SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];,"```sql
SELECT AVG(Quantity) AS AvgOrderQuantity FROM [Order Details];
```",The generated SQL query and the ground truth SQL query are functionally equivalent. Both queries calculate the average quantity of products ordered per order from the 'Order Details' table. The difference in column alias ('AvgOrderQuantity' vs. 'AverageQuantity') does not affect the correctness of the query as it answers the user question correctly.,"```sql
SELECT AVG(SUM([Order Details].Quantity)) AS AverageQuantityPerOrder
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.OrderID;
```","The generated SQL query attempts to calculate the average of summed quantities per order, which would result in an incorrect average of averages. The ground truth query correctly calculates the overall average quantity of products by directly averaging the Quantity column from the [Order Details] table.",FT,Base
Calculate the average age of employees.,SELECT AVG((CURRENT_DATE - BirthDate) / 365.25) AS AvgAge FROM employees;,"SELECT e.EmployeeID, (strftime('%Y', 'now') - strftime('%Y', e.BirthDate)) AS Age FROM employees e;","The generated query calculates the age of each employee but does not calculate the average age. In contrast, the ground truth query correctly computes the average age of all employees using the AVG function.","```sql
SELECT AVG(YEAR(CURDATE()) - YEAR(BirthDate)) AS AverageAge FROM employees;
```","Both queries correctly calculate the average age of employees. The generated SQL uses a different method (YEAR function) compared to the ground truth (arithmetic based on CURRENT_DATE), but both methods will yield the correct result.",Base,FT
Which customer region had the highest average order fulfillment time in the past month?,"SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime FROM orders WHERE OrderDate >= CURDATE() - INTERVAL 1 MONTH GROUP BY ShipRegion ORDER BY AvgFulfillmentTime DESC;","SELECT o.ShipRegion, AVG(DATEDIFF(DAY, o.OrderDate, o.ShippedDate)) AS AvgFulfillmentTime FROM orders o WHERE o.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE) GROUP BY o.ShipRegion ORDER BY AvgFulfillmentTime DESC",Both queries correctly compute the average order fulfillment time for each customer region in the past month and order the results in descending order of the average fulfillment time. The differences in SQL functions and syntax do not affect the correctness of the query.,"```sql
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= DATEADD(MONTH, -1, GETDATE())
GROUP BY ShipRegion
ORDER BY AverageFulfillmentTime DESC
LIMIT 1;
```","The generated query intends to find the past month's records by using DATEADD with GETDATE. However, GETDATE returns the current date and time which could lead to a difference in the time portion. The ground truth query accurately uses CURDATE() which handles date only and ensures full days in the calculation.",FT,Base
What is the on-time delivery rate for the month of April 2023?,SELECT COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / COUNT(orders.OrderID) AS on_time_delivery_rate FROM orders WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30',SELECT COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) / COUNT(orders.OrderID) AS on_time_delivery_rate FROM orders WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30',Both SQL queries calculate the on-time delivery rate correctly by counting the number of orders where the `ShippedDate` is on or before the `RequiredDate` and dividing it by the total number of orders. The difference in syntax (using `CASE WHEN` vs. `FILTER`) does not affect the correctness of the result.,"```sql
SELECT COUNT(orders.OrderID) / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
AND orders.ShippedDate <= orders.RequiredDate
```","The generated SQL query incorrectly calculates the on-time delivery rate. It calculates the same count for both the numerator and the denominator, providing an incorrect result of 1 every time. The ground truth correctly filters the orders that were shipped on time and then divides by the total number of orders.",FT,Base
What is the on-time delivery rate for each month in 2023?,"SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE NULL END) * 1.0 / COUNT(*) AS on_time_delivery_rate FROM orders WHERE YEAR(OrderDate) = 2023 GROUP BY month;","SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) * 100 AS OnTimeDeliveryRate FROM orders WHERE DATE_FORMAT(OrderDate, '%Y') = '2023' GROUP BY Month;",Both the generated SQL query and the ground truth SQL query capture the on-time delivery rate for each month in 2023 by grouping the data by months and comparing the ShippedDate with the RequiredDate. The difference in the date functions and slight variations in the COUNT function do not affect the correctness of the result.,"```sql
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID WHERE ShippedDate <= RequiredDate) / COUNT(OrderID) AS OnTimeDeliveryRate
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2023
GROUP BY 
    Month;
```","The generated SQL query is syntactically incorrect. The COUNT function is incorrectly used with a WHERE clause inside it. Additionally, the result of the division should be cast to a decimal to avoid integer division issues.",FT,Base
What is the total number of units on order for each product in 2022?,"SELECT products.ProductID, SUM(products.UnitsOnOrder) AS units_on_order FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY products.ProductID","SELECT products.ProductID, SUM(products.UnitsOnOrder) AS total_units_on_order FROM products GROUP BY products.ProductID",The generated SQL query does not filter orders by the year 2022 and does not join the 'Order Details' and 'orders' tables to correctly aggregate the units on order for each product.,"```sql
SELECT products.ProductID, SUM(products.UnitsOnOrder) AS total_units_on_order
FROM products
JOIN orders ON products.ProductID = [Order Details].ProductID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
```","The generated SQL query does not include a join on [Order Details] table, which is necessary to properly link products and orders directly.",Both,None
Calculate the total quantity of products sold per product category.,"SELECT CategoryID, SUM([Order Details].Quantity) AS TotalQuantity FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID GROUP BY CategoryID","SELECT p.CategoryID, SUM(od.Quantity) AS TotalQuantity FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID JOIN products p ON od.ProductID = p.ProductID GROUP BY p.CategoryID;",The generated SQL query correctly joins the tables and sums the quantities per product category. It includes all necessary tables and joins to accurately compute the total quantity of products sold per product category.,"```sql
SELECT ProductID, SUM(Quantity) AS TotalQuantity
FROM [Order Details]
GROUP BY ProductID;
```","The generated SQL query groups the total quantity sold by ProductID, not by product category. The ground truth query correctly groups by CategoryID after joining the products and [Order Details] tables.",FT,Base
What are the total units ordered for each supplier?,"SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY s.SupplierID","```sql
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID 
ORDER BY TotalUnitsOrdered DESC;
```",The generated SQL query correctly computes the total units ordered for each supplier by joining the appropriate tables and aggregating the data with SUM. The ORDER BY clause in the generated query does not alter the correctness of the result.,"```sql
SELECT p.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID;
```","The generated query joins the `products` table with the `Order Details` table directly. It uses `SupplierID` from the `products` table instead of joining the `suppliers` table to get the correct `SupplierID`. This could potentially cause errors if the `SupplierID` is not directly referenced in the `products` table, or it may miss context from the `suppliers` table.",FT,Base
Which employee generated the most sales in the last year?,"SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) GROUP BY e.EmployeeID ORDER BY TotalSales DESC LIMIT 1;","SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) - 1 GROUP BY e.EmployeeID ORDER BY TotalSales DESC LIMIT 1;","The generated SQL query filters the orders to the previous year using 'YEAR(o.OrderDate) = YEAR(CURDATE()) - 1', whereas the ground truth query filters to the current year using 'YEAR(o.OrderDate) = YEAR(CURDATE())'. This difference means the generated query answers a different question than asked.","```sql
SELECT e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
```","The generated SQL query incorrectly calculates the date range by using DATE_SUB(CURDATE(), INTERVAL 1 YEAR). This would include the last 365 days instead of data for the last calendar year. The correct condition is YEAR(o.OrderDate) = YEAR(CURDATE()).",Both,None
What is the total sales for each product category this year?,"SELECT categories.CategoryName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID JOIN products ON [Order Details].ProductID = products.ProductID JOIN categories ON products.CategoryID = categories.CategoryID WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) GROUP BY categories.CategoryName","SELECT p.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID JOIN products p ON od.ProductID = p.ProductID WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) GROUP BY p.CategoryID;","The generated SQL query correctly calculates the total sales for each product category this year but it groups by 'CategoryID' instead of 'CategoryName'. The ground truth query groups by 'CategoryName', which provides more meaningful information.","```sql
SELECT 
    products.CategoryID,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN 
    products ON [Order Details].ProductID = products.ProductID
WHERE 
    YEAR(orders.OrderDate) = YEAR(CURDATE())
GROUP BY 
    products.CategoryID;
```","The generated SQL query groups by `CategoryID` from the products table, whereas the ground truth query groups by `CategoryName` from the categories table. The user question specifies 'product category', which implies the query should group by category name, providing a more meaningful and descriptive result.",Both,None
Calculate the total number of units ordered for each product category.,"SELECT c.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered FROM [Order Details] od INNER JOIN products p ON od.ProductID = p.ProductID INNER JOIN categories c ON p.CategoryID = c.CategoryID GROUP BY c.CategoryID;","You can use the following SQL query to calculate the total number of units ordered for each product category:

```sql
SELECT categories.CategoryName, SUM(orders.Quantity) AS TotalQuantity FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN categories ON products.CategoryID = categories.CategoryID GROUP BY categories.CategoryName;
```","The generated SQL query correctly calculates the total number of units ordered for each product category. The main difference is that the generated query displays the CategoryName instead of CategoryID, which still correctly answers the user's question.","```sql
SELECT products.CategoryID, SUM([Order Details].Quantity) AS TotalUnitsOrdered
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.CategoryID;
```",The generated query does not join the 'categories' table to get the correct 'CategoryID'. It only groups by 'products.CategoryID' without confirming it corresponds correctly to the categories.,FT,Base
Which products need reordering?,SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;,"```sql
SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;
```","The generated SQL query uses the condition 'UnitsInStock < ReorderLevel' which does not include cases where UnitsInStock is exactly equal to ReorderLevel. According to the ground truth query, products should be reordered even if UnitsInStock is exactly equal to ReorderLevel (i.e., 'UnitsInStock <= ReorderLevel'). Therefore, the condition should be 'UnitsInStock <= ReorderLevel' to match the requirement accurately.","```sql
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;
```","The generated SQL query retrieves all the necessary information to determine which products need reordering, including additional columns such as ProductID and UnitsInStock. The critical check for UnitsInStock being less than or equal to the ReorderLevel is present and accurate.",Base,FT
How many products have a reorder level higher than 20?,SELECT COUNT(*) AS HighReorderProducts FROM products WHERE ReorderLevel > 20;,"SELECT ProductID, ProductName FROM products WHERE ReorderLevel > 20;","The generated SQL query SELECT ProductID, ProductName FROM products WHERE ReorderLevel > 20; retrieves the ProductID and ProductName for products with a ReorderLevel higher than 20. However, the user asked for the count of such products, which the ground truth query (SELECT COUNT(*) AS HighReorderProducts FROM products WHERE ReorderLevel > 20;) correctly answers by returning the number of products matching the criteria.","```sql
SELECT COUNT(*) AS ProductCount
FROM products
WHERE ReorderLevel > 20;
```",Both queries correctly count the number of products with a reorder level higher than 20. The column naming in the result set is different but that does not affect the correctness of the query.,Base,FT
Find the customers who have not placed any orders in the current year.,"SELECT CustomerID FROM customers WHERE CustomerID NOT IN (SELECT DISTINCT CustomerID FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR));",SELECT CustomerID FROM customers WHERE CustomerID NOT IN (SELECT CustomerID FROM orders WHERE YEAR(OrderDate) = YEAR(CURDATE()));,"The generated SQL query filters orders from the current year using WHERE YEAR(OrderDate) = YEAR(CURDATE()). This assumes the current year exclusively, while the ground truth SQL query considers a 1-year interval starting from the current date using DATE_SUB(CURDATE(), INTERVAL 1 YEAR), which might lead to different results depending on the current date.","```sql
SELECT DISTINCT CustomerID 
FROM customers 
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID 
    FROM orders 
    WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE())
);
```","The generated SQL query accurately identifies customers who have not placed any orders in the current year by comparing the year of the order date with the current year. However, the ground truth query filters orders placed in the last year. If the current year and last year period definitions do not match (e.g., if the current date is Jan 5 and looking for orders since Jan 5 last year), results might differ.",Both,None
How many units of each product were sold in the first quarter of 2023?,"SELECT products.ProductID, SUM([Order Details].Quantity) AS units_sold FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY products.ProductID","SELECT products.ProductID, SUM([Order Details].Quantity) AS total_units_sold FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY products.ProductID","The generated SQL query correctly calculates the total units sold for each product in the first quarter of 2023 by summing the quantities from the Order Details table, joining with the products and orders tables, and filtering by the appropriate date range. The only difference from the ground truth is the alias for the sum column, which does not affect the correctness of the query.","```sql
SELECT products.ProductID, SUM([Order Details].Quantity) AS units_sold
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID
```","The generated SQL query does not include the join with the products table, which is necessary to correctly reference the ProductID from the products table.",FT,Base
What percentage of total stock does each product contribute?,"SELECT p.ProductID, ROUND(p.UnitsInStock / (SELECT SUM(UnitsInStock) FROM products) * 100, 2) AS StockPercentage FROM products p;","SELECT p.ProductName, ((p.UnitsInStock * p.UnitPrice) / (SELECT SUM(UnitsInStock * UnitPrice) FROM products)) * 100 AS StockContributionPercentage FROM products p;","The generated SQL query calculates the percentage contribution to the total value of the stock (UnitsInStock * UnitPrice) for each product, whereas the ground truth query calculates the percentage contribution to the total units in stock for each product.","```sql
SELECT 
    p.ProductID,
    p.ProductName,
    (p.UnitsInStock * 100.0 / SUM(p.UnitsInStock) OVER ()) AS StockPercentage
FROM 
    products p;
```",The generated SQL query correctly calculates the percentage of total stock for each product using a window function. The use of window functions and direct SELECT subqueries both provide the desired result. The schema and logic are correct.,Base,FT
Which employee processed the highest number of orders last month?,"SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) AND MONTH(o.OrderDate) = MONTH(CURDATE()) - 1 GROUP BY e.EmployeeID ORDER BY OrderCount DESC LIMIT 1;","```sql
SELECT e.EmployeeID, COUNT(od.OrderID) AS TotalOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE DATE_PART('month', o.OrderDate) = DATE_PART('month', CURRENT_DATE - INTERVAL '1' MONTH)
AND DATE_PART('year', o.OrderDate) = DATE_PART('year', CURRENT_DATE - INTERVAL '1' MONTH)
GROUP BY e.EmployeeID
ORDER BY TotalOrders DESC
LIMIT 1;
```","The generated SQL query includes a join with the [Order Details] table which is not required for this question. The User Question asks for the number of orders processed by each employee, not the details of items within each order. Additionally, the date filtering condition in the generated query uses DATE_PART which might be specific to certain databases and is more complicated compared to the simpler and more universally supported YEAR and MONTH functions in the ground truth query.","```sql
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE MONTH(o.OrderDate) = MONTH(CURDATE() - INTERVAL 1 MONTH) 
  AND YEAR(o.OrderDate) = YEAR(CURDATE())
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
```","The generated query uses the same filtering logic for determining the orders in the last month but includes the first and last names of employees in the SELECT clause, which is not present in the ground truth query. The schema is also slightly incorrect as the generated query uses e.EmployeeID, e.FirstName, e.LastName while ground truth query uses only e.EmployeeID.",Both,None
What is the correlation between employee hire date and performance?,"SELECT employees.EmployeeID, employees.HireDate, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales FROM employees JOIN orders ON employees.EmployeeID = orders.EmployeeID JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID GROUP BY employees.EmployeeID ORDER BY employees.HireDate;","SELECT e.EmployeeID, e.HireDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.OrderDate BETWEEN e.HireDate AND DATE_ADD(e.HireDate, INTERVAL 1 YEAR) GROUP BY e.EmployeeID, e.HireDate ORDER BY e.Salary ASC;","The generated query includes a WHERE clause that limits the orders to those within a year of the hire date, which is not mentioned in the user's question. Additionally, the grouping involves both EmployeeID and HireDate, while the ground truth query only groups by EmployeeID. The ordering is also incorrect as it orders by Salary instead of HireDate.","```sql
SELECT 
    e.HireDate, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.HireDate;
```","The generated SQL query groups by HireDate rather than EmployeeID, which would result in incorrect aggregation of sales data for employees sharing the same hire date. The ground truth SQL query correctly groups by EmployeeID and orders the results by HireDate.",Both,None
How many new customers were acquired in May 2023?,SELECT COUNT(DISTINCT customers.CustomerID) AS new_customers FROM customers JOIN orders ON customers.CustomerID = orders.CustomerID WHERE orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31',SELECT COUNT(DISTINCT orders.CustomerID) AS new_customers FROM orders WHERE orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31',"The generated SQL query only counts the number of distinct customers who placed orders in May 2023, not necessarily new customers. The ground truth SQL query specifically determines new customers by joining the customers and orders tables.","```sql
SELECT COUNT(DISTINCT CustomerID) AS new_customers 
FROM orders 
WHERE OrderDate BETWEEN '2023-05-01' AND '2023-05-31';
```","The generated SQL query counts distinct CustomerIDs from the orders table within the specified date range, but it doesn't ensure those are 'new' customers. The ground truth query ensures it by joining with the customers table and checking the orders within the date range to count only newly acquired customers.",Both,None
What is the average fulfillment time for orders by month?,"SELECT EXTRACT(MONTH FROM OrderDate) AS Month, AVG(DATEDIFF(DAY, OrderDate, ShippedDate)) AS AvgFulfillmentTime FROM orders GROUP BY EXTRACT(MONTH FROM OrderDate)","```sql
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime FROM orders GROUP BY Month;
```","The generated SQL query groups by the full year and month (YYYY-MM format) while the ground truth query groups by the month of the year. Additionally, the ground truth query uses EXTRACT to get the month, which could imply an aggregation by month across multiple years, losing the Year context. The format of DATEDIFF function usage is also slightly different between the two queries but that depends on the SQL dialect.","```sql
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS Average_Fulfillment_Time
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
```","The generated SQL query groups by the year and month together, which means it will generate a separate row for each month of each year. The ground truth SQL query groups just by month, combining the same months across different years into a single row. Furthermore, the `DATEDIFF` function syntax used in the ground truth SQL query uses 'DAY' as the interval, while the generated SQL query assumes it calculates days by default.",Both,None
What is the average discount applied per product?,SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];,"SELECT ProductID, AVG(Discount) AS AverageDiscount FROM [Order Details] GROUP BY ProductID;","The generated SQL query calculates the average discount grouped by each product, whereas the ground truth SQL query calculates the overall average discount across all products. The user's question asks for the average discount per product, so the ground truth query is the correct one.","```sql
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details];
```","The generated SQL query correctly calculates the average discount applied per product. It matches the ground truth query in both syntax and logic, and it references the correct table and column.",Base,FT
Which suppliers have supplied the most products?,"SELECT s.SupplierID, COUNT(p.ProductID) AS TotalProductsSupplied FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID GROUP BY s.SupplierID ORDER BY TotalProductsSupplied DESC;","```sql
SELECT suppliers.SupplierID, COUNT(products.ProductID) AS ProductCount FROM suppliers JOIN products ON suppliers.SupplierID = products.SupplierID GROUP BY suppliers.SupplierID ORDER BY ProductCount DESC;
```","The generated SQL query correctly identifies the suppliers who have supplied the most products by joining the 'suppliers' and 'products' tables on the 'SupplierID' column, grouping by 'SupplierID', counting the number of products, and ordering by the count in descending order. The column labels differ but the result set will fulfill the user question requirements.","```sql
SELECT SupplierID, COUNT(ProductID) AS TotalProducts
FROM products
GROUP BY SupplierID
ORDER BY TotalProducts DESC;
```","The generated query does not explicitly involve the `suppliers` table, which means it may miss out on suppliers who have not supplied any products or produce an incorrect supplier list due to missing proper joins.",FT,Base
Which regions have the highest on-time delivery rates?,"SELECT ShipRegion, (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID)) AS OnTimeDeliveryRate FROM orders GROUP BY ShipRegion ORDER BY OnTimeDeliveryRate DESC;","SELECT ShipRegion, COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(*) AS OnTimeDeliveryRate FROM orders GROUP BY ShipRegion;","The generated SQL query calculates the on-time delivery rate correctly but it does not order the results by the OnTimeDeliveryRate in descending order as the ground truth query does. To fully address the user question about the 'highest' on-time delivery rates, the results need to be sorted.","```sql
SELECT ShipRegion, 
       COUNT(OrderID) FILTER (WHERE ShippedDate <= RequiredDate) * 100.0 / COUNT(OrderID) AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipRegion
ORDER BY OnTimeDeliveryRate DESC;
```","Both SQL queries calculate the on-time delivery rates by region and order the results by those rates in descending order. The logic and final output of both queries are equivalent, even though the syntax is slightly different.",Base,FT
How many orders were handled by employees who were hired in the year 2020?,SELECT COUNT(orders.OrderID) AS TotalOrders FROM employees JOIN orders ON employees.EmployeeID = orders.EmployeeID WHERE YEAR(HireDate) = 2020;,"SELECT e.EmployeeID, COUNT(o.OrderID) AS OrdersCount FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID WHERE YEAR(e.HireDate) = 2020 GROUP BY e.EmployeeID;","The generated SQL query provides the order count grouped by each employee, while the ground truth query sums the total number of orders handled by all employees hired in 2020. The user's question asks for the total count of orders handled, not the count per employee.","```sql
SELECT COUNT(*) AS OrderCount
FROM orders
WHERE EmployeeID IN (
    SELECT EmployeeID 
    FROM employees 
    WHERE YEAR(HireDate) = 2020
);
```","Both the generated SQL query and the ground truth SQL query correctly count the number of orders handled by employees who were hired in the year 2020. Although they use different approaches (subquery vs. join), they deliver the same result.",Base,FT
What is the average lead time for each supplier?,"SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID GROUP BY products.SupplierID;","SELECT suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime FROM suppliers INNER JOIN products ON suppliers.SupplierID = products.SupplierID INNER JOIN orders ON products.ProductID = [Order Details].ProductID GROUP BY suppliers.CompanyName;","The generated SQL query incorrectly joins tables, using 'orders' directly instead of 'Order Details' for matching ProductID, and mismatches table aliases. Additionally, it uses the suppliers.CompanyName instead of products.SupplierID for grouping and output.","```sql
SELECT suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY suppliers.CompanyName;
```","The generated SQL query groups by suppliers' company names and appropriately calculates the average lead time. Although the grouping is by CompanyName rather than SupplierID, it still provides the required result, which is the average lead time for each supplier.",Base,FT
How many orders were shipped late in the last month?,SELECT COUNT(orders.OrderID) AS Late_Orders FROM orders WHERE orders.RequiredDate < orders.ShippedDate AND MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);,"SELECT COUNT(OrderID) AS LateOrders FROM orders WHERE OrderDate >= DATE_FORMAT(NOW() - INTERVAL 1 MONTH, '%Y-%m-01') AND ShippedDate > RequiredDate;","The generated SQL query calculates the order date from the start of the current month to the previous month, which is incorrect for finding orders shipped late in the last month. The ground truth query correctly identifies orders from the last month by using MONTH and YEAR functions to ensure it considers dates strictly from the last month.","```sql
SELECT COUNT(OrderID) AS LateOrders
FROM orders
WHERE ShippedDate > RequiredDate AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
```","The generated SQL query checks for orders in the last 30 days, not specifically the last month. It uses 'DATE_SUB(CURDATE(), INTERVAL 1 MONTH)' which does not guarantee it's for the previous calendar month. Meanwhile, the ground truth SQL checks specifically for the previous calendar month by comparing both month and year extracted from the current date minus one month.",Both,None
"How many orders were shipped late (i.e., shipped after the required date)?",SELECT COUNT(*) AS LateOrders FROM orders WHERE ShippedDate > RequiredDate;,"SELECT o.OrderID, o.CustomerID, o.ShippedDate, o.RequiredDate FROM orders o WHERE o.ShippedDate > o.RequiredDate;","The generated query retrieves the details (OrderID, CustomerID, ShippedDate, RequiredDate) of the orders that were shipped late, but it does not provide the count of such orders as requested in the user question.","```sql
SELECT COUNT(*) AS LateOrders
FROM orders
WHERE ShippedDate > RequiredDate;
```","The generated SQL query correctly counts the number of orders where the ShippedDate is later than the RequiredDate, which matches the user question. The schema and logic are correct, and it produces the expected result.",Base,FT
What is the most frequently ordered product?,"SELECT p.ProductName, COUNT(od.ProductID) AS OrderCount FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.ProductName ORDER BY OrderCount DESC LIMIT 1;","SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity FROM [Order Details] od GROUP BY od.ProductID ORDER BY TotalQuantity DESC LIMIT 1;","The generated query sums the quantities of the products to find the most frequently ordered product, while the ground truth query counts the number of orders to determine the most frequently ordered product by product name. These are different approaches and might yield different results depending on the data.","```sql
SELECT OrderDetails.ProductID, SUM(OrderDetails.Quantity) AS TotalQuantity
FROM [Order Details] AS OrderDetails
GROUP BY OrderDetails.ProductID
ORDER BY TotalQuantity DESC
LIMIT 1;
```","The generated SQL query orders products by the total quantity ordered, while the ground truth orders by the count of orders. These are not necessarily the same thing, so the generated query may not correctly identify the most frequently ordered product as intended.",Both,None
How many units of each product were ordered last month?,"SELECT products.ProductID, SUM([Order Details].Quantity) AS UnitsOrderedLastMonth FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID WHERE [Order Details].OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY products.ProductID;","SELECT p.ProductName, SUM(od.Quantity) AS UnitsOrdered FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID WHERE od.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE) GROUP BY p.ProductName;","Although the core logic of calculating the sum of quantities ordered in the last month is correct, there are two key issues. First, the generated SQL query uses `ProductName` instead of the `ProductID`, which could lead to ambiguity if products have the same name. Secondly, the generated SQL query uses `CURRENT_DATE`, while the ground truth query uses `GETDATE()`; these might be interchangeable in some SQL dialects but could differ in others.","```sql
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE MONTH(od.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(od.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH)
GROUP BY p.ProductID, p.ProductName;
```","The generated SQL query accounts for both the month and year separately, which is correct, but it uses CURRENT_DATE and the INTERVAL keyword, which may not be supported by all SQL dialects. Additionally, it includes the product name in the selection and grouping, which although informative, is not required by the user question or the ground truth query. The WHERE clause's date filter is also different, possibly leading to different results depending on the SQL engine's interpretation of dates.",Both,None
Which shipping company has the highest on-time delivery rate?,"SELECT shippers.CompanyName, COUNT(orders.OrderID) WHERE orders.ShippedDate <= orders.RequiredDate / COUNT(orders.OrderID) AS on_time_delivery_rate FROM orders JOIN shippers ON orders.ShipVia = shippers.ShipperID GROUP BY shippers.CompanyName ORDER BY on_time_delivery_rate DESC LIMIT 1","SELECT shippers.ShipperID, shippers.CompanyName, COUNT(orders.OrderID WHERE orders.ShippedDate <= orders.RequiredDate) / COUNT(orders.OrderID) AS on_time_delivery_rate FROM orders JOIN shippers ON orders.ShipVia = shippers.ShipperID GROUP BY shippers.ShipperID","The generated SQL query contains a syntax error in the COUNT function and omits the ORDER BY and LIMIT clauses present in the ground truth SQL query. Also, GROUP BY should be on shippers.CompanyName instead of shippers.ShipperID.","```sql
SELECT shippers.CompanyName, 
       COUNT(orders.OrderID WHERE orders.ShippedDate <= orders.RequiredDate) * 1.0 / COUNT(orders.OrderID AS on_time_delivery_rate
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY on_time_delivery_rate DESC 
LIMIT 1;
```","The generated SQL query has a syntax error. The COUNT function is used incorrectly by placing the WHERE clause inside it, which is not valid SQL syntax. Additionally, there is a missing parenthesis before AS in COUNT(orders.OrderID). Both the COUNT and division operations should be outside the COUNT function and handled properly.",Both,None
What is the total discount amount given for each product?,"SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY p.ProductName;","```sql
SELECT p.ProductID, p.ProductName, SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.ProductID, p.ProductNameORDER BY TotalDiscount DESC;
```","The generated SQL query includes the ProductID in the SELECT statement and GROUP BY clause, whereas the ground truth query does not. The user question specifies the total discount amount given for each product, which matches the ground truth query that only summarizes by ProductName. The inclusion of ProductID is unnecessary for answering the user question as requested.","```sql
SELECT 
    products.ProductID,
    products.ProductName,
    SUM([Order Details].Discount * [Order Details].UnitPrice * [Order Details].Quantity) AS TotalDiscount
FROM 
    products
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY 
    products.ProductID, products.ProductName;
```","The generated SQL query correctly calculates the total discount amount given for each product using the appropriate schema. It groups the results by ProductID and ProductName, and sums the discount amount based on the UnitPrice, Quantity, and Discount fields from the order details.",Base,FT
List customers who have not placed any orders in the last year.,"SELECT c.CustomerID, c.CompanyName FROM customers c LEFT JOIN orders o ON c.CustomerID = o.CustomerID WHERE o.OrderID IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR);","```sql
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderID IS NULL OR o.OrderDate < DATEADD(year, -1, CURRENT_DATE);
```",Both queries correctly identify customers who have not placed any orders in the last year. The difference is in the date functions used: DATEADD and CURRENT_DATE in the generated query versus DATE_SUB and CURDATE in the ground truth query. Both achieve the same outcome.,"```sql
SELECT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, c.City, c.Region, c.PostalCode, c.Country, c.Phone, c.Fax
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID AND o.OrderDate >= DATEADD(year, -1, GETDATE())
WHERE o.OrderID IS NULL;
```","The generated SQL query only checks for orders placed within the last year using `DATEADD(year, -1, GETDATE())`. It does not account for customers who never placed any orders at all, unlike the ground truth SQL which checks using `DATE_SUB(CURDATE(), INTERVAL 1 YEAR)` and also considers `o.OrderID IS NULL` which correctly captures customers who have not placed any orders in the last year or ever.",FT,Base
Identify products with a unit price greater than the average unit price across all products.,"SELECT p.ProductID, p.ProductName FROM products p WHERE p.UnitPrice > (SELECT AVG(UnitPrice) FROM products);",SELECT ProductName FROM products WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products);,"The generated SQL query lacks the ProductID in the SELECT clause, which is included in the ground truth SQL query. Although the main criterion for filtering the products is met, the set of columns to be returned is not identical to those expected in the ground truth query.","```sql
SELECT ProductID, ProductName, UnitPrice
FROM products
WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products);
```","The generated SQL query correctly identifies products with a unit price greater than the average unit price across all products. It retrieves the ProductID, ProductName, and UnitPrice, whereas the ground truth query only retrieves ProductID and ProductName. The additional column does not affect the correctness of the result.",Base,FT
What is the most frequently ordered product in 2023?,"SELECT products.ProductID, products.ProductName, COUNT([Order Details].OrderID) AS order_count FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID GROUP BY products.ProductID ORDER BY order_count DESC LIMIT 1","SELECT products.ProductID, COUNT([Order Details].OrderID) AS order_frequency FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY products.ProductID ORDER BY order_frequency DESC LIMIT 1","The generated SQL query correctly identifies the most frequently ordered product in 2023 by considering the date range within 2023, but it doesn't include the product name in the result. The ground truth query does not consider the year 2023 specificity, which is essential for answering the user question.","```sql
SELECT products.ProductID, COUNT([Order Details].Quantity) AS order_count 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY products.ProductID 
ORDER BY order_count DESC 
LIMIT 1;
```","The generated SQL query does not join the 'products' table correctly; it only joins 'Order Details' with 'orders'. Additionally, it uses 'orders.OrderDate' to filter for the year 2023 instead of 'Order Details.OrderID'. The generated query does not include the 'products.ProductName' column specified in the ground truth query.",Both,None
How many products were low on stock (below reorder level) in August 2023?,SELECT products.ProductID FROM products WHERE products.UnitsInStock < products.ReorderLevel AND MONTH(products.RecordDate) = 8 AND YEAR(products.RecordDate) = 2023,"SELECT products.ProductID, products.ProductName FROM products WHERE products.UnitsInStock < products.ReorderLevel AND products.ProductID IN (SELECT [Order Details].ProductID FROM [Order Details] JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2023-08-01' AND '2023-08-31')","The generated SQL query checks for products low on stock based on whether they were ordered in August 2023, rather than checking the inventory record date directly. The correct query should use the RecordDate field in the products table to ensure the stock level is checked for August 2023 specifically.","```sql
SELECT COUNT(*) AS low_stock_products 
FROM products 
WHERE UnitsInStock < ReorderLevel AND ProductID IN (
    SELECT ProductID FROM [Order Details] JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-08-01' AND '2023-08-31'
);
```","The generated SQL query attempts to filter products based on orders made in August 2023, which is incorrect. It checks the order date rather than the product's stock level date. The ground truth SQL query correctly filters products that were below reorder level in August 2023 based on the product's stock level record date.",Both,None
What is the total number of products available in the inventory?,SELECT COUNT(*) FROM products;,SELECT SUM(UnitsInStock) AS TotalProductsAvailable FROM products;,"The generated SQL query calculates the sum of the units in stock for all products, which gives the total quantity of items available, not the number of distinct products. The ground truth SQL query counts the total number of distinct products in the inventory.","```sql
SELECT SUM(UnitsInStock) AS TotalProductsAvailable
FROM products;
```","The generated SQL query calculates the total number of available units in stock by summing the UnitsInStock column, whereas the ground truth query simply counts the total number of rows (i.e., the number of distinct products). The two queries provide different results: one gives the total units available and the other gives the total number of product types.",Both,None
What is the most ordered product in terms of quantity?,"SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantityOrdered FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID GROUP BY products.ProductName ORDER BY TotalQuantityOrdered DESC LIMIT 1;","SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.ProductID ORDER BY TotalQuantity DESC;",The generated SQL query is missing the LIMIT 1 clause to return only the most ordered product.,"```sql
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductName
ORDER BY TotalQuantity DESC
LIMIT 1;
```","The generated SQL query correctly calculates the total quantity ordered for each product, groups the results by product name, and orders them in descending order to return the most ordered product. The difference in column alias 'TotalQuantity' vs 'TotalQuantityOrdered' does not affect the correctness of the result.",Base,FT
How many products have less than 10 units in stock?,"SELECT ProductID, ProductName FROM products WHERE UnitsInStock < 10;",SELECT ProductName FROM products WHERE UnitsInStock < 10;,"The generated query does not answer the question correctly because it retrieves the names of the products with less than 10 units in stock, while the user is asking for the count of such products.","```sql
SELECT COUNT(*) AS LowStockCount 
FROM products 
WHERE UnitsInStock < 10;
```","The generated SQL query returns the count of products with less than 10 units in stock, which is not what the user question is specifically asking for. The ground truth query provides the actual detailed product information (ProductID and ProductName), not just the count.",Both,None
Which products have the highest and lowest inventory turnover ratio?,"SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY p.ProductName ORDER BY InventoryTurnoverRatio DESC LIMIT 1;","SELECT p.ProductName, (SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)) AS InventoryTurnoverRatio FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY p.ProductID ORDER BY InventoryTurnoverRatio DESC LIMIT 1; SELECT p.ProductName, (SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)) AS InventoryTurnoverRatio FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY p.ProductID ORDER BY InventoryTurnoverRatio ASC LIMIT 1;","The generated SQL query consists of two separate queries: one for the highest inventory turnover ratio and the other for the lowest. However, generating two separate SELECT statements is not optimal. The ground truth query focuses on fetching just the highest turnover ratio product. Moreover, the generated query groups by ProductID instead of ProductName, which might not align with the user's request perfectly.","```sql
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    InventoryTurnoverRatio DESC
LIMIT 1
UNION ALL
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    InventoryTurnoverRatio ASC
LIMIT 1;
```","The generated SQL query attempts to select both the highest and lowest inventory turnover ratios by using UNION ALL with two separate queries. However, it doesn't correctly combine the results in a way that directly answers the question. The ground truth SQL query correctly focuses on finding only the highest inventory turnover ratio but does not address how to find the lowest. The generated query introduces unnecessary complexity and deviates from the structure needed to correctly answer the question.",Both,None
Identify employees with the highest and lowest order counts.,"SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID GROUP BY e.EmployeeID ORDER BY OrderCount DESC LIMIT 1 UNION SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID GROUP BY e.EmployeeID ORDER BY OrderCount ASC LIMIT 1;","```sql
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID GROUP BY e.EmployeeID ORDER BY OrderCount DESC;
```",The generated SQL query does not accurately answer the question. It only retrieves the order counts of employees in descending order but does not identify the employees with the highest and lowest order counts. The ground truth query correctly identifies the employees with the highest and lowest order counts.,"```sql
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;

SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount ASC
LIMIT 1;
```","The generated SQL query correctly identifies the employees with the highest and lowest order counts. However, it does not include the employee's full name (FirstName and LastName), which is included in the ground truth SQL query. Additionally, the generated query separates the results into two queries, whereas the ground truth combines them using UNION.",Both,None
What is the total revenue generated by each employee?,"SELECT EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalRevenue FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID GROUP BY EmployeeID;","SELECT EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY o.EmployeeID;",The generated SQL query mistakenly references 'od.EmployeeID' instead of 'o.EmployeeID' in the GROUP BY clause.,"```sql
SELECT 
    orders.EmployeeID,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    orders.EmployeeID;
```","Both the generated SQL query and the ground truth SQL query calculate the total revenue generated by each employee by joining the 'orders' and '[Order Details]' tables on OrderID and then grouping the results by EmployeeID. The syntax and structure for both queries are effectively the same, and they will return the correct answer with equivalent result sets.",Base,FT
How many unique customers placed orders in the last quarter?,"SELECT COUNT(DISTINCT CustomerID) FROM orders WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE());",SELECT COUNT(DISTINCT orders.CustomerID) AS UniqueCustomers FROM orders WHERE QUARTER(OrderDate) = QUARTER(NOW()) - 1 AND YEAR(OrderDate) = YEAR(NOW());,"The generated SQL query filters for orders placed in the last quarter of the current year, but the ground truth query finds orders in the last three months from the current date which might not strictly correspond to the last quarter. Additionally, the functions used for date manipulation differ (QUARTER and NOW vs. DATEADD and GETDATE). These differences could lead to different results depending on the current date.","```sql
SELECT COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM orders
WHERE OrderDate >= DATEADD(quarter, -1, GETDATE()) AND OrderDate < GETDATE();
```","The generated SQL query uses an incorrect date range. It calculates the date range as the last quarter from today, whereas the ground truth SQL query correctly uses the last 3 months from today. The date range logic should be consistent with the last 3 months.",Both,None
Which supplier has supplied the most quantity of products?,"SELECT SupplierID, SUM(UnitsOnOrder) AS TotalQuantitySupplied FROM products GROUP BY SupplierID ORDER BY TotalQuantitySupplied DESC LIMIT 1;","SELECT s.SupplierID, SUM(od.Quantity) AS TotalSupplied FROM products p JOIN suppliers s ON p.SupplierID = s.SupplierID JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY s.SupplierID ORDER BY TotalSupplied DESC;","The generated SQL query calculates the total quantity supplied based on the 'Order Details' table, whereas the user question is asking about the total quantity supplied based on the 'products' table, specifically the 'UnitsOnOrder'. Therefore, the data sources used are incorrect and the generated query would not provide the correct answer.","```sql
SELECT p.SupplierID, SUM(od.Quantity) AS TotalSupplied
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalSupplied DESC
LIMIT 1;
```","The generated SQL query calculates the total quantity supplied using the Order Details table and sums the quantity from orders, while the ground truth SQL query calculates it using the UnitsOnOrder field from the products table. These approaches could yield different results depending on the data in these tables.",Both,None
Retrieve the contact information for all suppliers located in a specific region.,"SELECT SupplierID, CompanyName, ContactName, Phone, City, Region FROM suppliers WHERE Region = 'specified_region';","```sql
SELECT CompanyName, ContactName, Phone, City FROM suppliers WHERE Region = 'SpecificRegion';
```","The generated SQL query incorrectly assumes a specific region named 'SpecificRegion', while the ground truth query uses a placeholder 'specified_region' which suggests it can be replaced by an actual value. Moreover, the generated query does not include the 'SupplierID' and 'Region' fields in the SELECT clause, which are parts of the ground truth query result.","```sql
SELECT SupplierID, CompanyName, ContactName, ContactTitle, Address, City, PostalCode, Country, Phone, Fax
FROM suppliers
WHERE Region = 'specific_region';
```","The generated SQL query checks for 'specific_region', while the ground truth checks for 'specified_region'. Additionally, the generated query includes more columns than needed and misses the 'Region' column.",Both,None
Which category has the highest number of products?,"SELECT CategoryID, COUNT(ProductID) AS NumberOfProducts FROM products GROUP BY CategoryID ORDER BY NumberOfProducts DESC LIMIT 1;","SELECT c.CategoryID, COUNT(p.ProductID) AS NumberOfProducts FROM products p INNER JOIN categories c ON p.CategoryID = c.CategoryID GROUP BY c.CategoryID ORDER BY NumberOfProducts DESC;","The generated SQL query retrieves all categories ordered by the number of products, whereas the ground truth query retrieves only the category with the highest number of products by using the LIMIT 1 clause.","```sql
SELECT CategoryID, COUNT(ProductID) AS ProductCount
FROM products
GROUP BY CategoryID
ORDER BY ProductCount DESC
LIMIT 1;
```","The generated SQL query correctly answers the user question since it groups by CategoryID, counts the number of products for each category, and orders the results by the count in descending order, limiting the result to the top category. The differences in column label names do not affect the correctness of the results.",Base,FT
Which products received the highest total discount?,"SELECT products.ProductName, SUM([Order Details].Discount) AS TotalDiscount FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID GROUP BY products.ProductName ORDER BY TotalDiscount DESC;","SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.Discount) AS TotalDiscount FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY p.ProductID ORDER BY TotalDiscount DESC;","The generated SQL query calculates the total discount by multiplying the quantity with the discount for each order detail, which is not required by the user question. The ground truth query correctly sums only the discounts, not taking quantity into account.","```sql
SELECT p.ProductID, p.ProductName, SUM(od.Discount) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalDiscount DESC;
```","The generated SQL query correctly answers the question by selecting the products along with the highest total discount. It aggregates the discount amounts for each product and orders them in descending order, which aligns with the user's request. The schema and logic of both queries are equivalent, despite minor differences in column naming.",Base,FT
Which regions have the highest average order value?,"SELECT ShipRegion, AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID GROUP BY ShipRegion ORDER BY AverageOrderValue DESC","SELECT ShipRegion, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AvgOrderValue FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY ShipRegion ORDER BY AvgOrderValue DESC;","The generated SQL query correctly calculates the average order value per region by joining the 'orders' table with the 'Order Details' table, grouping by 'ShipRegion', and ordering the results by the average order value in descending order. The schema and the logic are consistent with the ground truth query.","```sql
SELECT 
    orders.ShipRegion, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AverageOrderValue
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    orders.ShipRegion
ORDER BY 
    AverageOrderValue DESC;
```","The generated SQL query calculates the average order value by dividing the total value of orders by the count of distinct orders, which may not be accurate. The ground truth query correctly uses the AVG function to compute the average directly.",FT,Base
Identify the top 3 customers by revenue in the last quarter.,"SELECT customers.CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as Revenue FROM customers JOIN orders ON customers.CustomerID = orders.CustomerID JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID WHERE orders.OrderDate > DATE_SUB(NOW(), INTERVAL 3 MONTH) GROUP BY customers.CustomerID ORDER BY Revenue DESC LIMIT 3;","SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue FROM customers c JOIN orders o ON c.CustomerID = o.CustomerID JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.OrderDate BETWEEN DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH) AND CURRENT_DATE GROUP BY c.CustomerID ORDER BY TotalRevenue DESC LIMIT 3;","The generated SQL query includes orders from the entire past 3 months, not just the last quarter. The 'last quarter' typically refers to a specific 3-month period within the fiscal year, whereas the generated query calculates from the current date back 3 months.","```sql
SELECT 
    customers.CustomerID, 
    customers.CompanyName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM 
    customers
JOIN 
    orders ON customers.CustomerID = orders.CustomerID
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    orders.OrderDate BETWEEN DATEADD(QUARTER, -1, GETDATE()) AND GETDATE()
GROUP BY 
    customers.CustomerID, customers.CompanyName
ORDER BY 
    TotalRevenue DESC
LIMIT 3;
```","While both queries calculate the total revenue correctly, the generated SQL Query uses the incorrect method to determine the date range for the last quarter. It uses DATEADD(QUARTER, -1, GETDATE()), which does not precisely match the 3-month interval required. The ground truth query properly uses DATE_SUB(NOW(), INTERVAL 3 MONTH) to capture the last three months accurately. Additionally, the first query includes the CompanyName in the SELECT and GROUP BY statements, which is not necessary for answering the user question.",Both,None
What percentage of orders were delivered before the required date in 2022?,SELECT SUM(CASE WHEN YEAR(OrderDate) = 2022 AND ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(OrderID) AS BeforeRequiredDateRate FROM orders WHERE YEAR(OrderDate) = 2022,SELECT COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(*) AS OnTimeDeliveryRate FROM orders WHERE EXTRACT(YEAR FROM OrderDate) = 2022;,"The generated SQL query has an issue with the denominator of the division. It should count only those orders from 2022, but it currently counts all orders. Additionally, it filters the orders to be only from 2022 both in the WHERE clause and in the CASE statement, whereas it should only filter in the WHERE clause.","```sql
SELECT 
    (COUNT(OrderID WHERE ShippedDate < RequiredDate) * 100.0 / COUNT(OrderID)) AS PercentageDeliveredBeforeRequired
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2022;
```",The generated SQL query contains a syntax error with 'COUNT(OrderID WHERE ShippedDate < RequiredDate)'. The correct approach is to use a CASE statement to count the orders that were shipped before the required date.,Both,None
Which supplier has the shortest average lead time in April 2023?,"SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID JOIN products ON [Order Details].ProductID = products.ProductID WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' GROUP BY products.SupplierID ORDER BY supplier_lead_time ASC LIMIT 1","SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID JOIN products ON [Order Details].ProductID = products.ProductID WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' GROUP BY products.SupplierID ORDER BY supplier_lead_time ASC LIMIT 1","The generated SQL query is identical to the ground truth SQL query. It correctly selects the supplier with the shortest average lead time within April 2023 using appropriate joins and filtering. Therefore, it will give the correct answer to the user's question.","```sql
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time 
FROM orders 
JOIN products ON orders.OrderID = products.ProductID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY products.SupplierID 
ORDER BY average_lead_time ASC 
LIMIT 1;
```","The generated SQL query incorrectly joins the orders table to the products table directly on orders.OrderID = products.ProductID. The correct join requires an intermediate join with an order details table on orders.OrderID = [Order Details].OrderID, followed by a join between [Order Details].ProductID and products.ProductID. This will ensure each order's product is correctly referenced.",FT,Base
Who are the employees reporting to each manager?,"SELECT m.EmployeeID AS ManagerID, m.LastName AS ManagerLastName, m.FirstName AS ManagerFirstName, e.EmployeeID AS EmployeeID, e.LastName AS EmployeeLastName, e.FirstName AS EmployeeFirstName FROM employees e JOIN employees m ON e.ReportsTo = m.EmployeeID;","```sql
SELECT e1.EmployeeID, e2.EmployeeID AS ReportsTo FROM employees e1 LEFT JOIN employees e2 ON e1.ReportsTo = e2.EmployeeID;
```","The generated SQL query does not correctly answer the question. It lists employee IDs without providing adequate details about the manager or the employees reporting to them. Additionally, the query should focus on employees with a direct reporting relationship, specifically using an inner join instead of a left join.","```sql
SELECT e1.FirstName AS EmployeeFirstName, e1.LastName AS EmployeeLastName, e2.FirstName AS ManagerFirstName, e2.LastName AS ManagerLastName
FROM employees e1
JOIN employees e2 ON e1.ReportsTo = e2.EmployeeID
ORDER BY e2.LastName, e2.FirstName, e1.LastName, e1.FirstName;
```","The generated SQL query correctly identifies the employees reporting to each manager by joining the employees table on the ReportsTo column and retrieving relevant employee and manager names. Although the columns in the result set differ slightly, both queries answer the user's question accurately.",Base,FT
How many orders were placed on weekends in the last three months?,"SELECT COUNT(OrderID) AS WeekendOrders FROM orders WHERE DAYOFWEEK(OrderDate) IN (1, 7) AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)","SELECT COUNT(orders.OrderID) as WeekendOrdersCount FROM orders WHERE WEEKDAY(orders.OrderDate) IN (5, 6) AND orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH);","The generated SQL query uses WEEKDAY() function which considers Saturday (5) and Sunday (6) as weekends, whereas the ground truth query uses DAYOFWEEK() function which considers Sunday (1) and Saturday (7) as weekends. The two functions have different indexing and thus the generated query would give incorrect results.","```sql
SELECT COUNT(OrderID) 
FROM orders 
WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE()) 
AND DATENAME(WEEKDAY, OrderDate) IN ('Saturday', 'Sunday');
```","The generated query uses 'DATENAME(WEEKDAY, OrderDate)' to extract the name of the day, whereas the ground truth query uses 'DAYOFWEEK(OrderDate)' which returns an integer representing the day of the week. The generated query also uses 'DATEADD(MONTH, -3, GETDATE())' to extract the date from 3 months ago, whereas the ground truth query uses 'DATE_SUB(CURDATE(), INTERVAL 3 MONTH)'. Although the approaches are different, the generated query will produce the intended result as the schema and logic are correct. However, care must be taken as the naming of weekdays ('Saturday', 'Sunday') should match the database configuration for locale. Overall, I would adjust my response to 'yes' considering these specifics might already match.",Both,None
How many products have been ordered but not yet shipped?,SELECT orders.OrderID FROM orders WHERE orders.ShippedDate IS NULL;,SELECT SUM(UnitsOnOrder) AS ProductsNotShipped FROM products;,"The generated SQL query sums the 'UnitsOnOrder' from the 'products' table, which indicates the total units of products ordered. However, the user asked for the number of products that have been ordered but not yet shipped. The ground truth SQL query correctly checks the 'orders' table for orders where the 'ShippedDate' is NULL, which accurately answers the user's question.","```sql
SELECT COUNT(DISTINCT [Order Details].ProductID) AS ProductsOrderedNotShipped
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.ShippedDate IS NULL;
```","The generated SQL query counts the distinct ProductIDs from the Order Details table where the related orders have not been shipped, which aligns with the user question asking for how many products have been ordered but not yet shipped. The ground truth query, however, only retrieves OrderIDs from the orders table without addressing the product count or status, thus it does not answer the user's question correctly. Hence, the generated SQL query is correct, but the ground truth query is not.",Both,None
Which products are low in stock and need reordering?,SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;,"SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;","The generated SQL query does not include the condition to check if the product is discontinued. The Ground Truth SQL query includes a check for Discontinued = 0, which ensures only active products are considered. Therefore, the generated query might include discontinued products which wouldn't need reordering.","```sql
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;
```","The generated SQL query includes additional columns (ProductID, UnitsInStock, ReorderLevel) in the SELECT clause, but it correctly identifies products that are low in stock and need reordering by including the necessary conditions in the WHERE clause. This distinction does not affect the correctness of the query in answering the user's question.",Base,FT
What are the most commonly ordered product quantities?,"SELECT products.ProductID, SUM([Order Details].Quantity) AS MostCommonQuantities FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID GROUP BY products.ProductID ORDER BY MostCommonQuantities DESC;","SELECT Quantity AS MostCommonQuantity, COUNT(*) AS Frequency FROM [Order Details] GROUP BY Quantity ORDER BY Frequency DESC;","The generated SQL query counts the frequency of each quantity ordered, whereas the ground truth SQL query sums product quantities per product and sorts them by the sum.","```sql
SELECT Quantity, COUNT(*) AS OrderCount
FROM [Order Details]
GROUP BY Quantity
ORDER BY OrderCount DESC;
```","The generated SQL query lists the quantities and the count of how many times each quantity was ordered, while the ground truth query aims to find the most commonly ordered quantities per product. The generated query does not join the 'products' table and does not group by the ProductID as required by the ground truth.",Both,None
List customers with their respective regions and count of orders placed.,"SELECT customers.CustomerID, customers.Region, COUNT(orders.OrderID) AS total_orders FROM customers LEFT JOIN orders ON customers.CustomerID = orders.CustomerID GROUP BY customers.CustomerID, customers.Region;","```sql
SELECT c.Region, COUNT(o.OrderID) AS Orders_Count FROM customers c JOIN orders o ON c.CustomerID = o.CustomerID GROUP BY c.Region;
```","The generated SQL query does not list customers with their respective regions and count of orders placed, but rather lists regions with the respective count of orders. The query also uses an INNER JOIN instead of a LEFT JOIN, which would exclude customers who have not placed any orders.","```sql
SELECT 
    customers.Region, 
    customers.CompanyName, 
    COUNT(orders.OrderID) AS OrderCount 
FROM 
    customers 
LEFT JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
GROUP BY 
    customers.Region, 
    customers.CompanyName;
```","The generated query does not include the CustomerID in the SELECT and GROUP BY clauses, which is necessary to uniquely identify each customer. The user question specifically asks for a list of customers, and the Ground Truth query ensures customers are uniquely identified by including CustomerID.",Both,None
"How many units have been sold for each product, grouped by supplier?","SELECT s.SupplierName, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY s.SupplierName, p.ProductName;","```sql
SELECT p.ProductName, s.SupplierName, SUM(od.Quantity) AS TotalSold FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID JOIN suppliers s ON p.SupplierID = s.SupplierID GROUP BY s.SupplierName, p.ProductName ORDER BY s.SupplierName;
```","The generated SQL query correctly joins the tables, groups the results by supplier and product, and sums the quantity sold. The order of the joins and selected columns differs slightly, but the query correctly answers the user's question.","```sql
SELECT p.SupplierID, p.ProductID, SUM(od.Quantity) AS UnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID, p.ProductID
```","The generated SQL query correctly calculates the total quantity sold, grouped by supplier and product. However, it does not include the supplier name and product name as required by the user question, which could be crucial for understanding the results.",FT,Base
Calculate the percentage of orders shipped within 5 days of the order date.,"SELECT COUNT(OrderID) * 100.0 / (SELECT COUNT(OrderID) FROM orders) AS PercentageWithin5Days FROM orders WHERE DATEDIFF(ShippedDate, OrderDate) <= 5;","SELECT MONTH(OrderDate) AS Month, COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders WHERE MONTH(OrderDate) = MONTH(o.OrderDate)) AS PercentageShippedWithin5Days FROM orders o WHERE DATEDIFF(ShippedDate, OrderDate) <= 5 GROUP BY MONTH(OrderDate);","The generated SQL query provides the percentage of orders shipped within 5 days for each month, whereas the ground truth query calculates the overall percentage of orders shipped within 5 days of the order date. The user query asks for the overall percentage, not a month-by-month breakdown.","```sql
SELECT 
    (COUNT(OrderID WHERE DATEDIFF(ShippedDate, OrderDate) <= 5) * 100.0 / COUNT(OrderID)) AS Percentage_Shipped_Within_5_Days
FROM 
    orders;
```","The generated SQL query contains a syntax error with the COUNT function inside the WHERE clause. Additionally, it does not properly separate the counting of orders within 5 days from the total order count. The ground truth query correctly separates these counts and accurately computes the percentage.",Both,None
What is the total quantity ordered across all products by month?,"SELECT MONTH(OrderDate) AS OrderMonth, YEAR(OrderDate) AS OrderYear, SUM(Quantity) AS TotalQuantityOrdered FROM [Order Details] GROUP BY OrderMonth, OrderYear;","```sql
SELECT EXTRACT(YEAR_MONTH FROM o.OrderDate) AS OrderMonth, SUM(od.Quantity) AS TotalQuantity FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY OrderMonth ORDER BY OrderMonth;
```","The generated SQL query uses EXTRACT(YEAR_MONTH) which extracts the year and month in a single value, but it should not involve both year and month together for accurate aggregation per month. Additionally, the join on the 'Order Details' table is missing in the Ground Truth SQL Query.","```sql
SELECT 
    MONTH(o.OrderDate) AS OrderMonth,
    SUM(od.Quantity) AS TotalQuantityOrdered
FROM 
    [Order Details] od
JOIN 
    Orders o ON od.OrderID = o.OrderID
GROUP BY 
    MONTH(o.OrderDate)
ORDER BY 
    OrderMonth;
```","The generated SQL query calculates the total quantity ordered by month without considering the year, while the ground truth query accounts for both the month and the year. This means the generated query would aggregate totals for the same month across different years, leading to potentially incorrect monthly totals.",Both,None
Which product has generated the highest revenue?,"SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS Revenue FROM [Order Details] GROUP BY ProductID ORDER BY Revenue DESC;","SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS ProductRevenue FROM [Order Details] od GROUP BY ProductID ORDER BY ProductRevenue DESC LIMIT 1;","The generated SQL query is almost correct but it uses 'LIMIT 1' to return only one result. This specific information was not specified in the ground truth SQL query. Besides, in standard SQL, 'LIMIT' is not universally accepted. The ground truth query computes the revenue and orders it, but it does not explicitly limit the result to one product.","```sql
SELECT 
    [Order Details].ProductID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
GROUP BY 
    [Order Details].ProductID
ORDER BY 
    TotalRevenue DESC
LIMIT 1;
```","The generated SQL query effectively answers the user question by calculating the total revenue for each product and ordering the results to find the highest revenue product. Despite the JOIN clause being technically unnecessary to answer the question since it is only retrieving information from [Order Details], the output will still be correct.",Base,FT
Calculate the average order value for each customer.,"SELECT c.CustomerID, AVG((od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(o.OrderID)) AS AverageOrderValue FROM customers c INNER JOIN orders o ON c.CustomerID = o.CustomerID INNER JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY c.CustomerID;","SELECT customers.CustomerID, AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue FROM customers JOIN orders ON customers.CustomerID = orders.CustomerID JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID GROUP BY customers.CustomerID;","The generated SQL query correctly calculates the average order value for each customer by joining the customers, orders, and [Order Details] tables, and then grouping by CustomerID. Although the aggregation technique differs slightly from the ground truth, it still correctly averages the order values for each customer.","```sql
SELECT 
    customers.CustomerID, 
    customers.CompanyName, 
    AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue
FROM 
    customers
JOIN 
    orders ON customers.CustomerID = orders.CustomerID
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    customers.CustomerID, 
    customers.CompanyName
```","The generated SQL query calculates the average order value per customer correctly by joining the relevant tables and using AVG() with appropriate columns. However, the ground truth SQL divides the product of UnitPrice, Quantity, and (1 - Discount) by the COUNT of OrderID, making it different from the generated SQL which does not include this division. The correct average order value should indeed incorporate the count to get the accurate average per order for each customer.",FT,Base
Which suppliers provide products that are currently out of stock?,SELECT s.SupplierName FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID WHERE p.UnitsInStock = 0;,"SELECT s.SupplierID, s.CompanyName FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID WHERE p.UnitsInStock = 0;","The generated SQL query correctly joins the suppliers and products tables on the SupplierID and filters for products that are out of stock (UnitsInStock = 0). Although the selected columns are different (SupplierID and CompanyName vs. SupplierName), both queries answer the question asked by identifying the suppliers providing products that are currently out of stock.","```sql
SELECT DISTINCT s.SupplierID
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitsInStock = 0;
```","The generated query returns the SupplierID, while the user question asks for the supplier names. The ground truth query correctly returns SupplierName.",FT,Base
How many units on order are there for each product?,"SELECT p.ProductName, p.UnitsOnOrder FROM products p","SELECT ProductName, UnitsOnOrder FROM products;",The generated SQL query retrieves the ProductName and UnitsOnOrder for each product but does not aggregate the units on order. It retrieves the raw data instead of the count of units on order for each product.,"```sql
SELECT ProductID, SUM(UnitsOnOrder) AS TotalUnitsOnOrder
FROM products
GROUP BY ProductID;
```","The generated query aggregates UnitsOnOrder per ProductID and returns the total units on order for each product. The ground truth query retrieves the product name and the units on order without any aggregation. Therefore, the generated query does not match the intent of the ground truth query.",Both,None
How many units of each product are currently in stock?,"SELECT ProductID, ProductName, UnitsInStock FROM products;","SELECT products.ProductName, products.UnitsInStock FROM products;","The generated SQL query correctly retrieves the product names and the number of units in stock for each product. Although it does not include the ProductID column as in the ground truth, it still answers the user's question accurately.","```sql
SELECT ProductID, ProductName, UnitsInStock
FROM products
WHERE UnitsInStock > 0;
```","The generated SQL query includes a WHERE clause that filters for products with UnitsInStock > 0, while the ground truth SQL query retrieves all products regardless of the UnitsInStock value. The user's question asks for units of each product currently in stock, which doesn't specify a need to filter out products with zero stock.",FT,Base
Which product has the highest unit price but lowest sales quantity?,"SELECT products.ProductID, products.ProductName FROM products WHERE products.UnitPrice = (SELECT MAX(products.UnitPrice) FROM products) AND products.ProductID NOT IN (SELECT [Order Details].ProductID FROM [Order Details] WHERE [Order Details].Quantity > 0)","SELECT products.ProductID, products.UnitPrice, SUM([Order Details].Quantity) AS total_quantity FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID GROUP BY products.ProductID ORDER BY UnitPrice DESC, total_quantity ASC LIMIT 1","The generated SQL query correctly finds the product with the highest unit price, but it does not ensure that the product has the lowest sales quantity. The ground truth query ensures that the product has the highest unit price and is not listed in the order details with any sales quantity. The generated query using LIMIT 1 does not guarantee this condition.","```sql
SELECT products.ProductID, products.UnitPrice, SUM([Order Details].Quantity) AS total_quantity
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID
ORDER BY products.UnitPrice DESC, total_quantity ASC
LIMIT 1;
```",The generated SQL query does not correctly address the condition of the product having the highest unit price and the lowest sales quantity. It sorts by unit price and quantity but does not find the product with the maximum unit price first and then compare the sales quantity as the ground truth does.,Both,None
Which product had the highest sales in terms of quantity in March 2023?,"SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' GROUP BY products.ProductName ORDER BY total_quantity DESC LIMIT 1","SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' GROUP BY products.ProductID, products.ProductName ORDER BY total_quantity DESC LIMIT 1","Both the generated SQL query and the ground truth query correctly determine which product had the highest sales in terms of quantity in March 2023. The inclusion of ProductID in the generated query does not affect the accuracy of the result, as both queries will return a single product with the highest total quantity.","```sql
SELECT products.ProductID, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductID
ORDER BY total_quantity DESC
LIMIT 1;
```","The generated query does not join the 'products' table, and hence it cannot retrieve the product name. It only retrieves the ProductID, which does not fully answer the user's question regarding the product name with the highest sales.",FT,Base
What is the total sales generated by each employee for the past year?,"SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY e.EmployeeID;","SELECT e.EmployeeID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE() GROUP BY e.EmployeeID;","The generated SQL query will correctly calculate the total sales generated by each employee for the past year. It groups the sales by EmployeeID and sums the total sales, filtering orders from the past year. The discrepancy in selecting the first name and last name in the ground truth is not essential for answering the user question, which only asks for EmployeeID and total sales.","```sql
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName;
```","The generated SQL query groups the results by EmployeeID, FirstName, and LastName, whereas the ground truth query only groups by EmployeeID. Grouping by EmployeeID alone is sufficient to get the total sales per employee, and the addition of FirstName and LastName is unnecessary.",FT,Base
What is the total sales revenue generated by each product category in the last year?,"SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales FROM [Order Details] JOIN orders ON orders.OrderID = [Order Details].OrderID WHERE OrderDate >= CURDATE() - INTERVAL 1 YEAR GROUP BY ProductID;","SELECT p.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID JOIN products p ON od.ProductID = p.ProductID WHERE o.OrderDate >= DATEADD(YEAR, -1, CURRENT_DATE) GROUP BY p.CategoryID;","The Ground Truth SQL query is grouping by ProductID, while the Generated SQL Query is grouping by CategoryID. Additionally, the Ground Truth Query is not joining with a products table to get the CategoryID, and it does not specify which category each product belongs to. The User Question asks for total sales revenue by product category, but the Ground Truth SQL Query provides the revenue by product.","```sql
SELECT p.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY p.CategoryID;
```","The generated SQL query correctly aggregates sales revenue per product category, but there is a discrepancy in the column selection and joins compared to the ground truth. The ground truth query groups by ProductID, whereas the generated query groups by CategoryID. Additionally, the generated query includes a join with the products table to get CategoryID, while the ground truth query doesn't consider the product category.",Both,None
Identify suppliers that have not supplied any products in the last year.,"SELECT suppliers.CompanyName FROM suppliers LEFT JOIN (SELECT products.SupplierID, COUNT(*) AS ProductCount FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY products.SupplierID) AS recent_products ON suppliers.SupplierID = recent_products.SupplierID WHERE recent_products.ProductCount IS NULL;","SELECT suppliers.SupplierID, suppliers.CompanyName FROM suppliers LEFT JOIN products ON suppliers.SupplierID = products.SupplierID LEFT JOIN [Order Details] ON products.ProductID = [Order Details].ProductID LEFT JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderID IS NULL OR DATEDIFF(DAY, orders.OrderDate, GETDATE()) > 365;","The generated SQL query has a logical flaw. It uses 'orders.OrderID IS NULL' in the WHERE clause, which can result in suppliers being incorrectly included if they have older orders not covered by 'DATEDIFF'. The ground truth query properly identifies suppliers by first filtering products supplied in the last year and then checking if suppliers have no such products. The generated query's logic can return incorrect results because it combines conditions inappropriately.","```sql
SELECT s.SupplierID, s.CompanyName
FROM suppliers s
LEFT JOIN products p ON s.SupplierID = p.SupplierID
LEFT JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
WHERE o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) OR o.OrderDate IS NULL
GROUP BY s.SupplierID, s.CompanyName
HAVING COUNT(o.OrderID) = 0;
```","The generated SQL query has a logical error in the WHERE clause. The condition `o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) OR o.OrderDate IS NULL` does not correctly identify suppliers that have not supplied any products in the last year. Instead, it should focus on checking if no orders exist in the last year, similar to the ground truth query which uses a subquery to check if recent products have been supplied.",Both,None
How many units of each product are currently on order?,"SELECT ProductName, UnitsOnOrder FROM products;","SELECT p.ProductName, p.UnitsOnOrder FROM products p;",The generated SQL query does not provide the count of units on order for each product; it only selects the product name and units on order without aggregating the data.,"```sql
SELECT products.ProductName, SUM(products.UnitsOnOrder) AS TotalUnitsOnOrder
FROM products
GROUP BY products.ProductName;
```","The generated SQL query calculates the sum of UnitsOnOrder grouped by ProductName, which answers the user's question correctly. However, the ground truth query just retrieves the ProductName and UnitsOnOrder without any aggregation. The ground truth query does not provide how many units of each product are currently on order. Therefore, the generated query is actually the correct one while the ground truth query is not answering the user's question.",Both,None
What is the monthly sales trend for each product over the last year?,"SELECT products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM') AS Month, SUM([Order Details].Quantity) AS MonthlySales FROM products JOIN [Order Details] ON products.ProductID = [Order Details].ProductID WHERE [Order Details].OrderDate >= DATEADD(year, -1, GETDATE()) GROUP BY products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM');","SELECT p.ProductName, DATEPART(MONTH, o.OrderDate) AS Month, SUM(od.Quantity) AS MonthlySales FROM [Order Details] od JOIN orders o ON od.OrderID = o.OrderID JOIN products p ON od.ProductID = p.ProductID WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE()) GROUP BY p.ProductName, DATEPART(MONTH, o.OrderDate) ORDER BY p.ProductName, Month;","The generated SQL query calculates the monthly sales trend for each product but uses `DATEPART(MONTH, o.OrderDate)` instead of `FORMAT([Order Details].OrderDate, 'yyyy-MM')`. This can result in aggregating data in an unintentionally granular way, especially when dealing with multiple years. Additionally, the generated query groups by ProductName instead of ProductID, which could lead to issues if there are products with the same name.","```sql
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    products.ProductID, 
    products.ProductName, 
    SUM([Order Details].Quantity) AS TotalSold 
FROM 
    [Order Details] 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY 
    Month, products.ProductID 
ORDER BY 
    Month, products.ProductID;
```","Both the generated query and the ground truth query output the monthly sales trend for each product over the last year. Despite slight differences in date formatting and ordering, they correctly join the 'Order Details' and 'products' tables, filter by the last year, and group by month and product ID to sum the quantities sold.",Base,FT
Find the average discount provided per order.,SELECT AVG([Order Details].Discount) AS AvgDiscount FROM [Order Details];,SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];,"Both queries calculate the average discount from the 'Order Details' table, giving the correct result. Minor differences in column label naming ('AverageDiscount' vs. 'AvgDiscount') don't affect the correctness of the output.","```sql
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID;
```","The generated SQL query groups by OrderID, which calculates the average discount per order separately, rather than calculating the overall average discount across all orders. The ground truth query calculates the average discount without grouping.",FT,Base
What is the average quantity per unit for products supplied by each supplier?,"SELECT s.SupplierID, s.SupplierName, AVG(CAST(p.QuantityPerUnit AS DECIMAL)) AS AverageQuantityPerUnit FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID GROUP BY s.SupplierID, s.SupplierName;","SELECT suppliers.SupplierName, AVG(LENGTH(products.QuantityPerUnit) - LENGTH(REPLACE(products.QuantityPerUnit, ' ', '')) + 1) AS AvgQuantityPerUnit FROM products JOIN suppliers ON products.SupplierID = suppliers.SupplierID GROUP BY suppliers.SupplierName;","The generated SQL query attempts to calculate the average quantity per unit by counting spaces in the QuantityPerUnit string, which is not meaningful for this problem. The ground truth query correctly converts QuantityPerUnit to a numeric form to calculate the average. Therefore, the generated query does not correctly answer the question.","```sql
SELECT 
    SupplierID, 
    AVG(QuantityPerUnit) AS AverageQuantityPerUnit
FROM 
    products
GROUP BY 
    SupplierID;
```","The generated SQL query does not join the suppliers table, so it misses out the SupplierName which is part of the user question. Additionally, the ground truth query casts QuantityPerUnit as DECIMAL, which ensures proper averaging, while the generated query does not.",Both,None
Which product has the highest cumulative discount in terms of dollar value?,"SELECT p.ProductID, p.ProductName, SUM(od.Discount * od.UnitPrice * od.Quantity) AS TotalDiscount FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.ProductID, p.ProductName ORDER BY TotalDiscount DESC LIMIT 1;","SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * od.Discount) AS TotalDiscountValue FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.ProductID, p.ProductName ORDER BY TotalDiscountValue DESC LIMIT 1;",Both generated and ground truth SQL queries calculate the total discount value per product and order the results to get the product with the highest cumulative discount. The column labels and calculation formulas are equivalent in functionality.,"```sql
SELECT od.ProductID, SUM(od.Quantity * od.Discount) AS TotalDiscount
FROM [Order Details] od
GROUP BY od.ProductID
ORDER BY TotalDiscount DESC
LIMIT 1;
```","The generated SQL query does not correctly calculate the total discount in dollar value. It multiplies Quantity by Discount directly, which doesn't account for the UnitPrice. The ground truth SQL query correctly multiplies Discount by UnitPrice and then by Quantity to get the dollar value of the cumulative discount.",FT,Base
What is the correlation between freight cost and fulfillment time?,"SELECT Freight, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders;","SELECT orders.Freight, DATEDIFF(orders.ShippedDate, orders.OrderDate) AS FulfillmentTime FROM orders;",The generated SQL query only selects the Freight and calculates FulfillmentTime but does not compute the correlation between Freight and FulfillmentTime.,"```sql
SELECT 
    CORR(Freight, DATEDIFF(ShippedDate, OrderDate) AS Correlation
FROM 
    orders;
```","The generated SQL query attempts to directly calculate the correlation using the CORR function, which is correct in terms of what the user asks for. However, the provided ground truth query does not compute the correlation but simply extracts the two columns needed to compute it (Freight and FulfillmentTime). Thus, the generated query would answer the user’s question correctly but the ground truth query does not, indicating a possible mistake in the provided ground truth.",Both,None
Which product had the highest sales revenue in 2022?,"SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY products.ProductID ORDER BY product_sales DESC LIMIT 1","SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY products.ProductID ORDER BY total_sales DESC LIMIT 1","The generated SQL query is missing the JOIN on the 'orders' table in the WHERE clause. The correct JOIN condition should explicitly connect the 'orders' table with '[Order Details]', similar to the ground truth query.","```sql
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales_revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
ORDER BY total_sales_revenue DESC
LIMIT 1;
```",The generated SQL query is incorrect because it does not join the 'products' table properly to fetch the 'ProductID' and does not have product name information if necessary. The ground truth SQL query correctly joins the 'products' and 'orders' tables to calculate the revenue.,Both,None
What is the inventory turnover ratio for the past month?,SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID JOIN orders o ON od.OrderID = o.OrderID WHERE EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 MONTH');,"SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID WHERE od.OrderID IN (SELECT DISTINCT OrderID FROM orders WHERE OrderDate >= DATEADD(month, -1, GETDATE()));","The generated SQL query uses GETDATE() and DATEADD functions to filter OrderDate for the past month, which is syntactically valid but assumes a specific database's date functions. The ground truth uses standard SQL 'EXTRACT' and 'INTERVAL' for date extraction and comparison. Additionally, the generated query does not join the 'orders' table directly, relying on an IN subquery. Hence, while both approaches attempt to answer the question, their logic and readability differ.","```sql
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    products
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID
WHERE 
    [Order Details].OrderID IN (SELECT OrderID FROM orders WHERE OrderDate >= DATEADD(MONTH, -1, GETDATE()))
```","The generated query uses GETDATE() and DATEADD to filter orders from the past month, while the ground truth query uses EXTRACT and an INTERVAL to specify the previous month. Depending on the current date, these approaches may not yield the same results, especially around month boundaries. Additionally, the ground truth query's use of EXTRACT ensures it captures the entire past month more accurately.",Both,None
What is the retention rate of customers comparing the first half of 2023 to the previous year?,(SELECT COUNT(DISTINCT o.CustomerID) FROM orders o WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-06-30') / (SELECT COUNT(DISTINCT o.CustomerID) FROM orders o WHERE o.OrderDate < '2023-01-01') AS customer_retention_rate,(SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-06-30') / (SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-06-30') AS customer_retention_rate,"The generated query calculates the retention rate by comparing the distinct customers in the first half of 2023 to the first half of 2022. However, the ground truth query calculates the retention rate by comparing the distinct customers in the first half of 2023 to all customers before 2023. Thus, the approach to calculating retention is different in the two queries.","```sql
SELECT 
  (SELECT COUNT(DISTINCT orders.CustomerID) 
   FROM orders 
   WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-06-30') / 
  (SELECT COUNT(DISTINCT orders.CustomerID) 
   FROM orders 
   WHERE orders.OrderDate < '2023-01-01') AS customer_retention_rate;
```","The generated SQL query and the ground truth SQL query are essentially equivalent. Both queries employ a similar logic: they count the distinct customer IDs in the orders table for the specified date ranges and then compute the ratio. The only difference is in the aliasing, where the generated query uses explicit table references whereas the ground truth does not, but this does not affect the functionality or correctness of the query.",Base,FT
What is the hire date of the oldest employee?,"SELECT e.FirstName, e.LastName, e.HireDate FROM employees e ORDER BY e.HireDate ASC LIMIT 1","SELECT e.EmployeeID, e.HireDate FROM employees e ORDER BY e.BirthDate ASC LIMIT 1;",The generated query orders employees by BirthDate which does not correctly answer the question. The correct approach is to identify the oldest employee by HireDate.,"```sql
SELECT HireDate 
FROM employees 
WHERE BirthDate = (SELECT MIN(BirthDate) FROM employees);
```","The generated SQL query finds the hire date of the employee with the earliest birth date, not the hire date of the oldest employee in terms of hire date. The ground truth query correctly orders the employees by HireDate and takes the first entry.",Both,None
Which supplier has the highest average lead time?,"SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID JOIN [Order Details] od ON p.ProductID = od.ProductID JOIN orders o ON od.OrderID = o.OrderID GROUP BY s.CompanyName ORDER BY AverageLeadTime DESC LIMIT 1;","SELECT suppliers.SupplierID, suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgLeadTime FROM suppliers JOIN products ON suppliers.SupplierID = products.SupplierID JOIN [Order Details] ON products.ProductID = [Order Details].ProductID JOIN orders ON [Order Details].OrderID = orders.OrderID GROUP BY suppliers.SupplierID, suppliers.CompanyName ORDER BY AvgLeadTime DESC;","The generated SQL query does not include the LIMIT 1 clause, which ensures that only the supplier with the highest average lead time is returned. Without this limit, the query would return a list of suppliers sorted by average lead time, but it wouldn't directly answer the question of which supplier has the highest average lead time.","```sql
SELECT suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgLeadTime
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN orders ON products.ProductID = [Order Details].ProductID
GROUP BY suppliers.SupplierID
ORDER BY AvgLeadTime DESC
LIMIT 1;
```",The generated SQL query groups by suppliers.SupplierID instead of suppliers.CompanyName and does not correctly join the [Order Details] table. The Ground Truth query correctly associates the order details with the orders using the OrderID.,Both,None
Identify employees whose orders had the highest average discount applied.,"SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY e.EmployeeID ORDER BY AvgDiscount DESC;","```sql
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY e.EmployeeID ORDER BY AvgDiscount DESC;
```",The generated SQL query correctly identifies the employees whose orders had the highest average discount applied. It performs the necessary joins and calculates the average discount before ordering the results correctly.,"```sql
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY AverageDiscount DESC
LIMIT 1;
```","The generated query includes columns FirstName and LastName and limits the result to one record, which is not a requirement stated in the ground truth query. Additionally, the ground truth query does not include these additional columns.",FT,Base
How many orders were shipped but not yet delivered?,SELECT OrderID FROM orders WHERE ShippedDate IS NOT NULL AND RequiredDate IS NULL;,SELECT O.OrderID FROM orders O WHERE O.ShippedDate IS NOT NULL AND O.RequiredDate > O.ShippedDate;,"The generated query checks if the RequiredDate is greater than the ShippedDate, which does not directly indicate undelivered orders. The ground truth query correctly identifies orders that have been shipped but not yet delivered by checking if the RequiredDate is NULL.","```sql
SELECT COUNT(*) AS UnfulfilledOrders
FROM orders
WHERE ShippedDate IS NOT NULL AND RequiredDate > ShippedDate;
```","The generated query is incorrect because it checks for orders where 'RequiredDate' is greater than 'ShippedDate', while the user question asks for orders that have been shipped but not yet delivered. The ground truth query correctly identifies such orders by checking if 'RequiredDate' is NULL after shipment.",Both,None
Which orders have the highest discounts applied?,"SELECT orders.OrderID, MAX([Order Details].Discount) AS MaxDiscount FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID GROUP BY orders.OrderID ORDER BY MaxDiscount DESC LIMIT 1;","SELECT o.OrderID, od.Discount FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID ORDER BY od.Discount DESC;","The generated SQL query does not match the user's request. The user's question asks for the orders with the highest discounts applied, which implies finding the order that received the maximum discount. The ground truth SQL query correctly aggregates the discounts per order and orders them, returning the order with the single highest discount. The generated SQL query lists all orders and discounts and sorts them, but does not aggregate and limit results to the highest discount, hence it does not correctly answer the user question.","```sql
SELECT OrderID, SUM(Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY OrderID
ORDER BY TotalDiscount DESC;
```","The generated SQL query calculates the total discount for each order and orders them by the total discount. The ground truth query finds the order with the single highest discount applied to any product within that order, not the sum of discounts. Additionally, the ground truth also limits the result to the single order with the highest individual discount applied.",Both,None
What is the average quantity of products ordered per order?,SELECT AVG([Order Details].Quantity) AS AverageQuantity FROM [Order Details],SELECT AVG(Quantity) AS AverageQuantityPerOrder FROM [Order Details];,Both the generated SQL query and the ground truth SQL query calculate the average quantity of products ordered across all orders from the 'Order Details' table. The slight difference in column alias naming does not affect the correctness of the query.,"```sql
SELECT AVG(SUM([Order Details].Quantity)) AS Average_Quantity_Per_Order
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.OrderID;
```","The generated SQL query is incorrect because it attempts to use the SUM function within the AVG function, which is unnecessary and misleading. The correct approach is to directly calculate the average of the quantities from the [Order Details] table, as shown in the ground truth SQL query.",FT,Base
What is the average shipping time for orders shipped to a specific country in the current month?,"SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime FROM orders WHERE DATE_FORMAT(OrderDate, '%Y-%m') = DATE_FORMAT(CURDATE(), '%Y-%m') AND ShipCountry = 'specified_country';","SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime FROM orders WHERE DATE_FORMAT(OrderDate, '%Y-%m') = DATE_FORMAT(NOW(), '%Y-%m') AND ShipCountry = 'chosen_country';","The generated SQL query correctly calculates the average shipping time for orders shipped to a specific country in the current month. Both the generated and ground truth queries use the same logic, filtering criteria, and calculation method, differing only in the function used to get the current date (NOW() vs. CURDATE()) and the placeholder for the country name ('chosen_country' vs. 'specified_country'). These differences are acceptable and do not impact the correctness of the query.","```sql
SELECT AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageShippingTime
FROM orders
WHERE MONTH(orders.ShippedDate) = MONTH(CURRENT_DATE())
  AND YEAR(orders.ShippedDate) = YEAR(CURRENT_DATE())
  AND orders.ShipCountry = 'SpecificCountry';
```","The generated query filters based on the shipping date being in the current month, while the ground truth query filters based on the order date being in the current month. Additionally, the ground truth query uses 'specified_country' rather than 'SpecificCountry'.",FT,Base
Which customers have purchased more than 5 different products?,"SELECT customers.CustomerID, customers.CompanyName FROM customers JOIN orders ON customers.CustomerID = orders.CustomerID JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID GROUP BY customers.CustomerID, customers.CompanyName HAVING COUNT(DISTINCT [Order Details].ProductID) > 5","```sql
SELECT customers.CustomerID, COUNT(DISTINCT [Order Details].ProductID) AS num_different_products FROM [Order Details] JOIN orders ON [Order Details].OrderID = orders.OrderID JOIN customers ON orders.CustomerID = customers.CustomerID GROUP BY customers.CustomerID HAVING num_different_products > 5
```",The generated query correctly identifies customers who have purchased more than 5 different products by using the COUNT(DISTINCT [Order Details].ProductID) and HAVING clause. The inclusion of the CustomerID alone instead of also including CompanyName does not affect the correctness of the answer to the question.,"```sql
SELECT orders.CustomerID
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.CustomerID
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5;
```",The generated SQL query is missing information. It only selects the CustomerID from the orders table and does not join with the customers table to provide more accurate customer information like the ground truth query does. The ground truth query also includes the CompanyName.,FT,Base
Which region has the highest on-time delivery rate?,"SELECT ShipRegion, (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS on_time_rate FROM orders GROUP BY ShipRegion ORDER BY on_time_rate DESC LIMIT 1;","SELECT ShipRegion, COUNT(*) * 1.0 / SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS on_time_delivery_rate FROM orders GROUP BY ShipRegion ORDER BY on_time_delivery_rate DESC;","The generated SQL does not have the correct calculation for on-time delivery rate. It divides the total count by the sum of the on-time deliveries rather than the other way around. Thus, the result will be incorrect. Also, the generated query lacks the LIMIT 1 clause to return only the region with the highest rate.","```sql
SELECT ShipRegion, 
       COUNT(OrderID WHERE ShippedDate <= RequiredDate) * 1.0 / COUNT(OrderID) AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipRegion
ORDER BY OnTimeDeliveryRate DESC
LIMIT 1;
```",The generated SQL query has a syntax error in the COUNT function with the WHERE clause incorrectly placed inside the COUNT function. The correct syntax to calculate the on-time delivery rate would be to use the SUM with a CASE statement similar to the ground truth query.,Both,None
Calculate the total discount given on all orders in the last month.,"SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS TotalDiscount FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID WHERE orders.OrderDate >= DATE_ADD(CURDATE(), INTERVAL -1 MONTH);","SELECT SUM([Order Details].Discount * [Order Details].UnitPrice * [Order Details].Quantity) AS TotalDiscount FROM [Order Details], orders WHERE orders.OrderDate BETWEEN NOW() - INTERVAL 1 MONTH AND NOW();","The generated SQL query has two issues: first, it does not correctly join the orders and [Order Details] tables based on OrderID; second, the time interval calculation using NOW() is not exact for determining the last month as it can vary by the current time.","```sql
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
```",Both the generated SQL query and the ground truth SQL query correctly calculate the total discount given on all orders in the last month. The differences in the date calculation functions (DATE_SUB vs. DATE_ADD with a negative interval) and the placement of `UnitPrice` and `Quantity` in the SUM operation do not affect the correctness of the calculation.,Base,FT
Determine the employee with the largest average order size.,"SELECT employees.EmployeeID, AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderSize FROM employees JOIN orders ON employees.EmployeeID = orders.EmployeeID JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID GROUP BY employees.EmployeeID ORDER BY AvgOrderSize DESC LIMIT 1;","```sql
SELECT e.EmployeeID, AVG(od.Quantity * od.UnitPrice) AS AverageOrderSize FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID JOIN [Order Details] od ON o.OrderID = od.OrderID GROUP BY e.EmployeeID ORDER BY AverageOrderSize DESC LIMIT 1;
```","The generated SQL query does not account for the discount in calculating the average order size, which is included in the ground truth query.","```sql
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderSize
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY AverageOrderSize DESC
LIMIT 1;
```","Both the generated SQL query and the ground truth SQL query compute the same result by joining 'employees', 'orders', and 'Order Details' tables. They both calculate the average order size per employee and return the employee with the largest average order size. The only differences are in the naming conventions of the columns and aliases used (e.g., 'e' vs. 'employees'), which do not affect the correctness of the answer.",Base,FT
How many distinct customers placed orders each month?,"SELECT DATE_TRUNC('month', o.OrderDate) AS Month, COUNT(DISTINCT o.CustomerID) AS UniqueCustomers FROM orders o GROUP BY Month;","SELECT DATE_PART('month', OrderDate) AS Month, COUNT(DISTINCT CustomerID) AS DistinctCustomers FROM orders GROUP BY DATE_PART('month', OrderDate);","The generated SQL query groups by the month without truncating the date, which could potentially lead to incorrect grouping if the date also contains time. The ground truth query correctly uses DATE_TRUNC to ensure accurate month grouping.","```sql
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    COUNT(DISTINCT CustomerID) AS DistinctCustomers
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
```",Both SQL queries aim to count the number of distinct customers who placed orders each month. The only difference is the formatting function used for the date: DATE_FORMAT() in MySQL and DATE_TRUNC() in PostgreSQL. Both queries use an appropriate method for grouping by month and counting distinct customers.,Base,FT
What are the average discounts applied per order?,"SELECT OrderID, AVG(Discount) AS AverageDiscount FROM [Order Details] GROUP BY OrderID;","SELECT OrderID, AVG(Discount) AS AvgDiscount FROM [Order Details] GROUP BY OrderID;","The generated SQL query and the ground truth SQL query produce the same results, averaging the discounts per OrderID and grouping by OrderID. The column alias difference (AvgDiscount vs AverageDiscount) does not affect the correctness of the result.","```sql
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID;
```","The generated SQL query does not select the OrderID, which is necessary to identify the average discount per order. Therefore, it does not fully answer the user question.",FT,Base
What is the number of products sold with discounts?,SELECT COUNT(DISTINCT ProductID) AS ProductsWithDiscount FROM [Order Details] WHERE Discount > 0;,SELECT COUNT(od.ProductID) AS ProductsSoldWithDiscount FROM [Order Details] od WHERE od.Discount > 0;,"The generated SQL query counts the number of individual products sold with discounts, whereas the ground truth SQL query counts the number of distinct products sold with discounts. This can lead to different results if there are multiple rows for the same product with discounts.","```sql
SELECT SUM([Order Details].Quantity) AS TotalProductsSoldWithDiscounts
FROM [Order Details]
WHERE Discount > 0;
```","The generated SQL query calculates the total quantity of products sold with discounts, whereas the user question asks for the number of unique products sold with discounts. The ground truth query correctly counts distinct ProductID values with discounts, aligning with the user's request.",Both,None
Which categories have an average unit price above $20?,SELECT CategoryName FROM categories c JOIN products p ON c.CategoryID = p.CategoryID GROUP BY c.CategoryName HAVING AVG(p.UnitPrice) > 20;,"SELECT c.CategoryID, AVG(p.UnitPrice) AS AvgUnitPrice FROM products p INNER JOIN categories c ON p.CategoryID = c.CategoryID GROUP BY c.CategoryID HAVING AVG(p.UnitPrice) > 20;",The generated SQL query selects CategoryID instead of CategoryName. The user question requests the category names.,"```sql
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice
FROM products
GROUP BY CategoryID
HAVING AVG(UnitPrice) > 20;
```","The generated SQL query only returns the CategoryID and the average UnitPrice, which does not fully answer the user question that asks for the category names. The ground truth query joins the categories and products tables to get the CategoryName, which is required to accurately answer the user question.",Both,None
What is the average order fulfillment time for each shipping method?,"SELECT ShipVia, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime FROM orders GROUP BY ShipVia;","SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime FROM orders GROUP BY ShipVia;","Both the generated query and the ground truth query calculate the average time difference between OrderDate and ShippedDate for each shipping method (ShipVia). Although the DATEDIFF function syntax slightly differs, both queries perform the same computation and produce the correct answer.","```sql
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY ShipVia;
```","The generated SQL query has a mistake in the parameters of the DATEDIFF function. The ground truth query specifies the datepart 'day' in the DATEDIFF function, which is required to ensure that the difference is calculated in days. The generated query does not specify the datepart, which might lead to an incorrect result depending on the SQL dialect.",FT,Base
List customers who have placed orders within the last 30 days.,"SELECT * FROM orders WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY);","```sql
SELECT customers.CustomerID, customers.CompanyName 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY);
```","The generated SQL query selects customers who have placed orders within the last 30 days by joining the 'customers' and 'orders' tables and filtering based on the 'OrderDate'. The ground truth query, although correct, does not specifically list the customers from the order details. Hence, the generated query is more accurate in answering the user question.","```sql
SELECT DISTINCT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, c.City, c.Region, c.PostalCode, c.Country, c.Phone, c.Fax
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate >= CURDATE() - INTERVAL 30 DAY;
```","The generated SQL query correctly lists the customers who have placed orders within the last 30 days by joining the customers and orders tables, but the ground truth SQL query does not achieve this as it only lists the orders without linking back to customer details. The two queries serve different purposes.",FT,Base
Find the monthly sales performance for each product.,"SELECT p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate) AS Month, SUM(od.Quantity) AS MonthlySales FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID JOIN orders o ON od.OrderID = o.OrderID GROUP BY p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate);","SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity, DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID JOIN orders o ON od.OrderID = o.OrderID GROUP BY p.ProductID, Month;","The generated SQL query and the ground truth SQL query group by different aspects of the date. The generated query uses DATE_FORMAT(o.OrderDate, '%Y-%m') to generate a month-year string while the ground truth query only uses EXTRACT(MONTH FROM o.OrderDate) without considering the year, which could result in aggregation issues if the data spans multiple years.","```sql
SELECT 
    products.ProductID, 
    products.ProductName, 
    SUM([Order Details].Quantity) AS TotalSold
FROM 
    products
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY 
    products.ProductID, 
    products.ProductName
ORDER BY 
    products.ProductID;
```","The generated SQL query does not include the grouping by month and does not involve joining the orders table to access the OrderDate for extracting the month. Therefore, it does not calculate the monthly sales performance for each product as requested.",Both,None
