Business Analytic Request,Ground Truth Code,Generated Code by Base Model,Base Model Explanation,Generated Code by Finetuned Model,Finetuned Model Explanation,Model that got it right
What was the average order value in Q1 of 2023?,"```python
import pandas as pd

# SQL query to get the relevant data
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalValue,
    COUNT(DISTINCT orders.OrderID) AS OrderCount
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Calculate the average order value
data['AvgOrderValue'] = data['TotalValue'] / data['OrderCount']

# Display the result to the user
show_to_user(data[['AvgOrderValue']])
```","```python
sql_query = """"""
SELECT 
    AVG(sd.total_sales) AS average_order_value
FROM (
    SELECT 
        o.OrderID,
        SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
    FROM 
        orders o
    JOIN 
        [Order Details] od ON o.OrderID = od.OrderID
    WHERE 
        o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
    GROUP BY 
        o.OrderID
) sd
""""""

average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","Both implementations calculate the average order value for orders placed in Q1 2023. The input code uses a subquery to aggregate total sales per order and subsequently calculates the average of these totals. The logic is consistent with the reference implementation, which sums up total sales and divides by the order count. Therefore, despite different approaches, the input code is correct as it achieves the same result.","```python
import pandas as pd

# Query to calculate the average order value in Q1 of 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
avg_order_value_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(avg_order_value_df.to_dict(orient='records'))
```","The input code correctly calculates the average order value for Q1 of 2023 using SQL. It computes the total value of orders and divides by the count of distinct orders directly within the SQL query. The result is equivalent to the reference implementation, which computes these values separately and then divides them in Python. Both approaches yield the same result, adhering to the request specifications.",both
Which products have the lowest units in stock?,"```python
import pandas as pd

# SQL query to get the products with the lowest units in stock
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products 
ORDER BY UnitsInStock ASC 
LIMIT 1;
""""""

# Execute the SQL query
lowest_stock_product_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(lowest_stock_product_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
ORDER BY UnitsInStock ASC
LIMIT 10;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code retrieves the top 10 products with the lowest units in stock, whereas the reference code retrieves only the single product with the lowest stock. This means the input code does not strictly adhere to the business request as defined by the reference implementation.","```python
import pandas as pd

# SQL query to find products with the lowest units in stock
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products 
ORDER BY UnitsInStock ASC;
""""""

# Execute the SQL query using the provided utility function
products_low_stock = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(products_low_stock)
```","The input code orders products by 'UnitsInStock' in ascending order but does not limit the result to only the product with the lowest stock. The reference implementation uses 'LIMIT 1' to ensure only the product with the lowest stock is returned. Thus, the input code will return all products ordered by stock level, not just the lowest one.",None
Which customers placed the highest number of orders last year?,"```python
import pandas as pd

# Define the SQL query to retrieve customers with highest orders last year
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY CustomerID 
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_orders)
```","```python
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) as NumberOfOrders
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1
GROUP BY CustomerID
ORDER BY NumberOfOrders DESC
LIMIT 10;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The provided code limits the results to the top 10 customers using 'LIMIT 10;', which is not present in the reference implementation. The reference code intends to list all customers who placed orders, ordered by the order count, without limiting the number of results.","```python
import pandas as pd

query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE) - 1 
GROUP BY CustomerID 
ORDER BY OrderCount DESC
""""""

df = execute_sql_query(query)
show_to_user(df)
```","The input code closely mirrors the logic of the reference implementation. Both codes query the same details: CustomerID and OrderCount for orders placed last year, group them by CustomerID, and order by OrderCount in descending order. The difference between 'CURDATE()' and 'CURRENT_DATE' in SQL is negligible, as they function equivalently in this context. Therefore, the input code correctly fulfills the business analytics request.",Finetuned
Calculate the total revenue generated by each product and visualize it using a bar chart to compare easily.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM 
    [Order Details] od 
INNER JOIN 
    products p ON od.ProductID = p.ProductID 
GROUP BY 
    p.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)
fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')
show_to_user(fig)
```","The input code includes a discount factor when calculating TotalRevenue, represented by '(1 - od.Discount)', which deviates from the reference implementation that does not account for discounts. This results in different revenue calculations. The rest of the logic, including the SQL query structure and visualization method, aligns with the reference implementation.","```python
import plotly.express as px

query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

df_revenue = execute_query(query)

fig = px.bar(df_revenue, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')
show_to_user(fig)
```","The input code correctly calculates the total revenue for each product using a SQL query that parallels the logic of the reference implementation. Both implementations join the 'products' and 'Order Details' tables on 'ProductID' and group by 'ProductName' to calculate total revenue. The visualization is also correctly implemented using Plotly to create a bar chart, matching the reference implementation. The differences in table join order ('products' with 'Order Details' vs. 'Order Details' with 'products') do not affect the correctness of the output.",Finetuned
Which customers are from the United States?,"```python
sql_query = ""SELECT CustomerID FROM orders WHERE ShipCountry = 'USA'""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE ShipCountry = 'United States'
""""""
customer_us_df = execute_sql_query(sql_query)
show_to_user(customer_us_df)
```","The input code checks for customers from 'United States' while the reference code checks for 'USA'. These are different country labels and could yield different results. To be correct, both codes should check for the same country identifier.","```python
query = ""SELECT DISTINCT CustomerID FROM orders WHERE ShipCountry = 'USA';""
customer_data = execute_sql_query(query)
show_to_user(customer_data)
```","The input code retrieves customers from the United States by executing a SQL query similar to the reference code. The input code uses 'SELECT DISTINCT CustomerID' to ensure unique customer IDs, which is consistent with the intent of identifying customers from the USA. Both use ShipCountry = 'USA' and show the results using show_to_user().",Finetuned
List the products that are being sold at a discount (UnitPrice in orders < UnitPrice in products).,"```python
import pandas as pd

# SQL query to get products sold at a discount
sql_query = """"""
SELECT p.ProductName 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
WHERE od.UnitPrice < p.UnitPrice;
""""""

# Execute the SQL query
discounted_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discounted_products_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitPrice AS ProductUnitPrice, od.UnitPrice AS OrderUnitPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.UnitPrice < p.UnitPrice
""""""

discounted_products = execute_sql_query(sql_query)
show_to_user(discounted_products)
```","The input code correctly identifies products being sold at a discount by comparing their UnitPrice in orders to the UnitPrice in products. It uses a SQL JOIN on ProductID and filters for cases where the order's UnitPrice is less than the product's UnitPrice. This logic matches the reference implementation. The additional columns (ProductID, ProductUnitPrice, OrderUnitPrice) do not affect the correctness of identifying discounted products.","```python
import pandas as pd

# SQL query to get products sold at a discount
sql_query = """"""
SELECT p.ProductID, p.ProductName 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.UnitPrice < p.UnitPrice;
""""""

# Execute the query
discounted_products_df = execute_sql_query(sql_query)

# Display the result
show_to_user(discounted_products_df)
```","The input Python code correctly lists the products sold at a discount by comparing the UnitPrice in the 'Order Details' with the UnitPrice in 'products'. Despite including 'ProductID' in the SELECT statement, which the reference does not, it adheres to the same logic and fulfills the business analytics request.",both
Which employees generated the highest sales revenue in April 2023 and visualize with a bar chart for comparison?,"```python
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.FirstName, employees.LastName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC
'''

# Execute SQL query and get data
data = execute_sql_query(sql_query)

# Create a full name column for ease of visualization
data['FullName'] = data['FirstName'] + ' ' + data['LastName']

# Create the bar chart using Plotly
fig = px.bar(data, x='FullName', y='total_sales', 
             title='Top Employees by Sales Revenue in April 2023',
             labels={'total_sales': 'Total Sales Revenue', 'FullName': 'Employee Name'})

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, 
       CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY employees.EmployeeID
ORDER BY TotalSales DESC
LIMIT 10;
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='EmployeeName', y='TotalSales', title='Top Employees by Sales Revenue in April 2023')
show_to_user(fig)
```","The input code correctly matches the business request and follows the logic of the reference implementation. It calculates the total sales revenue per employee for April 2023 and creates a bar chart for visualization. The only notable differences are that the input code uses a CONCAT function for employee names and limits the results to the top 10, which does not alter the correctness of the solution. Overall, the input code addresses the request appropriately.","```python
import plotly.express as px

# SQL query to get employee sales data
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID
""""""

# Execute query
df = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(df, x='EmployeeID', y='employee_sales', title='Employee Sales in April 2023', labels={'employee_sales': 'Sales'})

# Show the chart to user
show_to_user(fig)
```","The input code fails to create the full names of employees by using only the EmployeeID as the x-axis in the bar chart. It doesn't select the First Name and Last Name, thus making it unclear who from the employees are represented. Additionally, it doesn't order the results by the total sales; therefore, it doesn't adhere to the logic of showing the highest sales revenue, as requested.",Base
What is the average order value handled by each employee and visualize with a bar chart for employee comparison?,"```python
import plotly.express as px

# Step 1: Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderValue 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Step 2: Execute the SQL query and retrieve the result as a DataFrame
df = execute_sql_query(sql_query)

# Step 3: Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='AvgOrderValue', title='Average Order Value by Employee', labels={'AvgOrderValue': 'Average Order Value', 'EmployeeID': 'Employee ID'})

# Step 4: Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
       COUNT(o.OrderID) AS TotalOrders,
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, EmployeeName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='EmployeeName', y='AverageOrderValue', 
             title='Average Order Value Handled by Each Employee', 
             labels={'AverageOrderValue': 'Average Order Value', 'EmployeeName': 'Employee'},
             color='AverageOrderValue')

show_to_user(fig)
```","The input code correctly calculates the average order value per employee using the SQL query, similarly to the reference implementation. The main difference is the inclusion of employee names instead of just IDs, which enhances the chart's readability. The input code uses Plotly to generate a bar chart, accomplishing the task as required. Both implementations follow the same logic to compute the required metric and visualize it.","```python
import plotly.express as px

# SQL query to get average order value per employee
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AvgOrderValue 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='EmployeeID', y='AvgOrderValue', title='Average Order Value per Employee')

# Display the result
show_to_user(fig)
```","Both implementations calculate the average order value handled by each employee and use a bar chart for visualization. The input code uses SUM and divides by COUNT(DISTINCT orders.OrderID) to find the average order value, which is logically equivalent to using AVG in this case since each order is distinct. Thus, both answers the business request correctly.",both
Find the total revenue generated by each product and illustrate using a bar chart.,"```python
import plotly.express as px

# Execute the SQL query to retrieve data
sql_query = """"""
SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue 
FROM [Order Details] 
GROUP BY ProductID;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')
show_to_user(fig)
```","The input code uses 'ProductName' instead of 'ProductID' and includes 'Discount' in the revenue calculation. This deviates from the reference implementation's logic, which does not consider discounts and uses 'ProductID'. Thus, the input code answers a different question and does not fully align with the reference implementation.","```python
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) as TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Retrieve data
data_df = execute_sql_query(sql_query)

# Plot bar chart
fig = px.bar(data_df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

# Display result
show_to_user(fig)
```","The input code aims to calculate total revenue per product, which aligns with the request. However, it includes discounts in the revenue calculation `(1 - od.Discount)`, which differs from the reference implementation. This calculation change can result in different values than the reference code, which does not account for discounts. Additionally, the input code uses `ProductName` instead of `ProductID` for the grouping, differing in the granularity of the results. Hence, the logic deviates from the reference code.",None
Calculate the inventory turnover ratio for each month and represent it with a line chart to observe trends.,"```python
import plotly.express as px

# SQL query defined
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) as InventoryTurnoverRatio 
FROM `Order Details` od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Convert Month to datetime for proper plotting
data['Month'] = pd.to_datetime(data['Month'])

# Generate line chart
fig = px.line(data, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.Quantity * od.UnitPrice) AS COGS,
    AVG(p.UnitsInStock) AS Average_Inventory
FROM 
    ""Order Details"" od
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

data = execute_sql_query(sql_query)
data['Inventory_Turnover_Ratio'] = data['COGS'] / data['Average_Inventory']

fig = px.line(data, x='Month', y='Inventory_Turnover_Ratio', title='Inventory Turnover Ratio Over Time')
show_to_user(fig)
```","Both implementations aim to calculate the inventory turnover ratio by dividing Cost of Goods Sold (COGS) by Average Inventory for each month. The reference uses `SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)` directly in the SQL query, while the input code calculates these components separately and then divides them after executing the query. Both follow the same logic and produce a line chart to represent the trends. Differences in SQL syntax (DATE_FORMAT vs. DATE_TRUNC) are irrelevant to the logic. Therefore, the input is correct.","```python
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) 
AS InventoryTurnoverRatio 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY Month;
""""""

df = execute_sql_query(sql_query)
df.columns = ['Month', 'InventoryTurnoverRatio']

fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio Trend')
show_to_user(fig)
```","The provided code correctly follows the business logic described in the reference implementation. Both versions calculate the inventory turnover ratio by aggregating order details and products, grouped by month. They differ in syntax, but this is due to different SQL dialects. The computed data is then plotted using Plotly Express to create a line chart, fulfilling the task requirements. Therefore, the input code is correct in terms of logic and output.",both
Visualize the performance of products based on sales and inventory levels for each month in 2022 using a combination chart.,"```python
import plotly.graph_objects as go
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, 
       MONTH(orders.OrderDate) AS order_month, 
       SUM([Order Details].Quantity) AS product_performance 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, order_month
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Prepare the data for visualization
pivot_df = df.pivot(index=""order_month"", columns=""ProductID"", values=""product_performance"").fillna(0)

# Create a combination chart
fig = go.Figure()

# Add traces for each product
for product_id in pivot_df.columns:
    fig.add_trace(go.Bar(x=pivot_df.index, y=pivot_df[product_id], name=f'Product {product_id}'))

# Set chart title and labels
fig.update_layout(
    title='Product Performance Based on Sales (2022)',
    xaxis_title='Month',
    yaxis_title='Quantity Sold',
    xaxis=dict(tickmode='linear'),
    barmode='stack'
)

# Show the combination chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.graph_objects as go

# SQL query to retrieve sales and inventory levels for products in 2022
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    products.ProductID,
    SUM([Order Details].Quantity) AS total_sales,
    SUM(products.UnitsInStock) AS total_inventory
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    YEAR(orders.OrderDate) = 2022
GROUP BY 
    month, products.ProductID
ORDER BY 
    month, products.ProductID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a combination chart to visualize performance
fig = go.Figure()

# Add sales data as bar
for product_id in data['ProductID'].unique():
    product_data = data[data['ProductID'] == product_id]
    fig.add_trace(go.Bar(
        x=product_data['month'],
        y=product_data['total_sales'],
        name=f'Product {product_id} Sales',
        hoverinfo='y'
    ))

# Add inventory data as line
for product_id in data['ProductID'].unique():
    product_data = data[data['ProductID'] == product_id]
    fig.add_trace(go.Scatter(
        x=product_data['month'],
        y=product_data['total_inventory'],
        mode='lines+markers',
        name=f'Product {product_id} Inventory',
        hoverinfo='y'
    ))

# Update layout of the figure
fig.update_layout(
    title='Product Performance: Sales and Inventory Levels in 2022',
    xaxis_title='Month',
    yaxis_title='Count',
    barmode='group'
)

# Show the visualization to the user
show_to_user(fig)
```","The input code includes both sales and inventory data, showing them as bars and lines, respectively. The reference implementation only considers sales data and visualizes it using stacked bars. The business request mentions visualizing 'performance based on sales and inventory,' but the logic in the reference only addresses sales. Hence, the input code deviates significantly from the reference logic.","```python
import plotly.graph_objects as go

sql_query = """"""
SELECT p.ProductName, 
       EXTRACT(MONTH FROM o.OrderDate) AS month, 
       SUM(od.Quantity) AS TotalQuantitySold, 
       SUM(od.Quantity * od.UnitPrice) AS TotalRevenue, 
       AVG(p.UnitsInStock) AS AvgInventoryLevel 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = 2022 
GROUP BY p.ProductName, month;
""""""

df = execute_sql_query(sql_query)

fig = go.Figure()

for product in df['ProductName'].unique():
    product_df = df[df['ProductName'] == product]
    
    fig.add_trace(go.Bar(
        x=product_df['month'],
        y=product_df['TotalQuantitySold'],
        name=f'{product} Sold',
        marker_color='blue',
        yaxis='y'
    ))
    
    fig.add_trace(go.Scatter(
        x=product_df['month'],
        y=product_df['AvgInventoryLevel'],
        name=f'{product} Avg Inventory',
        mode='lines',
        yaxis='y2'
    ))

fig.update_layout(
    title='Monthly Product Performance in 2022',
    yaxis=dict(title='Total Quantity Sold', titlefont=dict(color='blue'), tickfont=dict(color='blue')),
    yaxis2=dict(title='Avg Inventory Level', titlefont=dict(color='red'), tickfont=dict(color='red'), overlaying='y', side='right'),
    xaxis_title='Month'
)

show_to_user(fig)
```","The provided code differs from the reference in various ways, including data fields used and the type of visualization. The reference focuses on sales quantity only with a stacked bar chart for different products, while the evaluated code uses both bar and line charts for quantity sold and inventory levels, respectively. Additionally, the reference uses ProductID and order_month, whereas the evaluated code uses ProductName and includes TotalRevenue and AvgInventoryLevel, which are not part of the reference logic.",None
What is the total sales revenue generated by each customer and represent it with a bar chart for comparison?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY CustomerID 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='TotalSales', title='Total Sales Revenue by Customer', labels={'CustomerID': 'Customer ID', 'TotalSales': 'Total Sales Revenue'})

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.CustomerID
""""""

sales_data = execute_sql_query(sql_query)
fig = px.bar(sales_data, x='CustomerID', y='TotalSales', title='Total Sales Revenue per Customer')
show_to_user(fig)
```","The input code and reference code both perform the same task of calculating the total sales revenue by each customer and plotting it using a bar chart. The SQL query in the input matches the reference in terms of logic: joining the 'orders' and 'Order Details' tables, calculating the total sales, grouping by 'CustomerID', and summing the revenue correctly. The difference in table alias and the omission of the ORDER BY clause in the input code does not affect the correctness of the overall task of generating the bar chart. Thus, the input code fulfills the business analytics request accurately.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT o.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.CustomerID;
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='CustomerID', y='TotalSales', title='Total Sales Revenue by Customer')

# Show the result
show_to_user(fig)
```","The input code correctly calculates the total sales revenue for each customer by joining the 'orders' and 'Order Details' tables and summing the product of UnitPrice, Quantity, and 1 minus Discount, grouped by CustomerID. The implementation creates a similar bar chart using plotly.express as the reference code. The ordering of the results in the SQL query does not affect the calculation or the chart. Therefore, the input code meets the business analytics requirements and adheres to the same logic as the reference implementation.",both
Which employee has processed the most orders for customers in the USA and visualize the results using a bar chart?,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShipCountry = 'USA' 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC
LIMIT 1;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create bar chart with Plotly
fig = px.bar(df, x='FirstName', y='OrderCount', text='OrderCount', title='Top Employee Processing USA Orders')
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShipCountry = 'USA'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OrderCount DESC
LIMIT 1;
""""""

top_employee = execute_sql_query(sql_query)

fig = px.bar(top_employee, x='LastName', y='OrderCount', title='Top Employee by Order Count in the USA',
             labels={'LastName': 'Employee Name', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The provided code and reference code both perform a similar SQL query to find the employee with the most processed orders to the USA. The discrepancy lies in how they handle the resulting data. The reference implementation uses `FirstName` for the x-axis in the bar chart, while the input code uses `LastName`. Therefore, they do not adhere to the same visualization logic as specified.","```python
import pandas as pd
import plotly.express as px

query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShipCountry = 'USA' 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

df = execute_query(query)
df['FullName'] = df['FirstName'] + ' ' + df['LastName']

fig = px.bar(df, x='FullName', y='OrderCount', title='Employee with Most Orders in the USA')
show_to_user(fig)
```","The provided code fulfills the business requirement by querying the employee who processed the most orders for customers in the USA using a SQL query similar to the reference. Both codes use a similar logic by joining employees and orders tables, filtering for 'USA', grouping by EmployeeID, and sorting to get the top employee. The visualization is correctly handled with Plotly using a bar chart. Although the input code uses the full name for the x-axis, it does not alter the correct logic implementation or the output requirements.",Finetuned
Which product had the highest sales quantity in the last month and use a bar chart to compare top-selling products?,"```python
import plotly.express as px

# SQL query to get top-selling products
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Find the product with the highest sales quantity
top_product = data.head(1)

# Display the top product details
show_to_user(top_product)

# Create a bar chart to compare top-selling products
fig = px.bar(data.head(10), x='ProductName', y='TotalQuantity', title='Top-Selling Products in the Last Month')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the last month period
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to get sales data for the last month
sql_query = f""""""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
WHERE 
    od.OrderID IN (
        SELECT OrderID 
        FROM Orders 
        WHERE OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}' 
        AND OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
    )
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    TotalSales DESC
LIMIT 10
""""""

# Execute the SQL query
top_selling_products = execute_sql_query(sql_query)

# Identify the product with the highest sales quantity
highest_sales_product = top_selling_products.iloc[0]

# Create a bar chart to compare top-selling products
fig = px.bar(top_selling_products, x='ProductName', y='TotalSales', title='Top-Selling Products in the Last Month')
show_to_user(fig)
```","The input Python code correctly retrieves the products with the highest sales in the last month and uses a bar chart to visualize the top-selling products. It calculates the date range to cover the last month accurately, executes an SQL query to obtain aggregated sales data, and generates a bar chart for visualization. Although the approach in the SQL query construction differs slightly from the reference, it achieves the same goal. Both codes identify the top product based on sales and present the information using Plotly for visualization.","```python
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE EXTRACT(YEAR FROM od.OrderDate) = 2023 
    AND EXTRACT(MONTH FROM od.OrderDate) = 9 
GROUP BY p.ProductName 
ORDER BY TotalQuantity DESC
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Top-Selling Products')
show_to_user(fig)
```","The input code checks for sales in September 2023 explicitly, while the reference code uses a dynamic date range for the last month. This doesn't adhere to the same logic, as the input code will not work if the current month is not October 2023. Additionally, the input code never identifies or displays the single product with the highest sales, only plotting the bar chart, differing from the requirement to identify and display this top product.",Base
"For each employee, what is the average number of orders handled per month in 2023 and visualize the results with a bar chart?","```python
import plotly.express as px

# SQL query to get the average number of orders per month per employee in 2023
sql_query = """"""
SELECT employees.EmployeeID, AVG(order_count) AS avg_orders_per_month 
FROM (
    SELECT employees.EmployeeID, COUNT(orders.OrderID) AS order_count, 
    MONTH(orders.OrderDate) AS order_month 
    FROM employees 
    LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID 
    WHERE YEAR(orders.OrderDate) = 2023
    GROUP BY employees.EmployeeID, MONTH(orders.OrderDate)
) AS temp 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='avg_orders_per_month', 
             title='Average Number of Orders per Month for Each Employee in 2023', 
             labels={'avg_orders_per_month': 'Avg Orders per Month', 'EmployeeID': 'Employee ID'})

# Show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    employees.EmployeeID,
    employees.FirstName,
    employees.LastName,
    COUNT(orders.OrderID) AS total_orders,
    COUNT(orders.OrderID) / 12.0 AS avg_orders_per_month
FROM 
    orders 
JOIN 
    employees ON orders.EmployeeID = employees.EmployeeID
WHERE 
    YEAR(orders.OrderDate) = 2023
GROUP BY 
    employees.EmployeeID, employees.FirstName, employees.LastName
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, 
              x='FirstName', 
              y='avg_orders_per_month', 
              text='avg_orders_per_month',
              title='Average Orders Handled per Month by Employee in 2023',
              labels={'FirstName': 'Employee Name', 'avg_orders_per_month': 'Average Orders per Month'})

show_to_user(fig)
```","The input code calculates the average number of orders per month by dividing the total orders by 12, which assumes each employee made orders every month. The reference implementation calculates the average per month correctly by considering only the months where orders were actually made by each employee. Additionally, the input code uses employee first names for the x-axis, which can lead to confusion if multiple employees have the same name, unlike the reference code which uses EmployeeID.","```python
import plotly.express as px

query = """"""
SELECT EmployeeID, COUNT(OrderID) / 12 AS AvgOrdersPerMonth 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY EmployeeID;
""""""

df = execute_query(query)

fig = px.bar(df, x='EmployeeID', y='AvgOrdersPerMonth', title='Avg Orders Per Month per Employee in 2023')
show_to_user(fig)
```","The input code incorrectly calculates the average by dividing the total orders by 12 for each employee, regardless of how many months they actually had orders in 2023. The reference implementation correctly averages the orders per month per employee using actual monthly counts.",None
How many discontinued products are still in stock?,"```python
import pandas as pd

# SQL query to find discontinued products still in stock
sql_query = ""SELECT COUNT(*) AS DiscontinuedInStock FROM products WHERE Discontinued = 1 AND UnitsInStock > 0;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Extract the count from the dataframe
discontinued_in_stock = df['DiscontinuedInStock'].iloc[0]

# Display the result to the user
show_to_user(discontinued_in_stock)
```","```python
sql_query = """"""
SELECT SUM(UnitsInStock) AS TotalUnitsInStock
FROM products
WHERE Discontinued = 1;
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code attempts to calculate the total units in stock for discontinued products by using SUM(UnitsInStock), instead of counting the number of discontinued products that still have stock available. The reference implementation correctly counts the entries where products are discontinued and have stock greater than zero. Thus, the input code does not answer the same business analytics request.","```python
import pandas as pd

# SQL query to find discontinued products still in stock
sql_query = ""SELECT SUM(UnitsInStock) AS TotalInStock FROM products WHERE Discontinued = 1;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df['TotalInStock'][0])
```","The input code is incorrect because it calculates the sum of 'UnitsInStock' for all discontinued products, not the count of discontinued products still in stock. The reference code checks for discontinued products where 'UnitsInStock' > 0, and then counts them. The logic does not match the reference implementation or the business analytics request.",None
Determine the most frequently used shipping method.,"```python
import pandas as pd

# SQL query to get the most frequently used shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UseCount
FROM orders
GROUP BY ShipVia
ORDER BY UseCount DESC
LIMIT 1;
""""""

# Execute SQL query
most_used_shipping_method_df = execute_sql_query(sql_query)

# Display the result
show_to_user(most_used_shipping_method_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS method_count
FROM orders
GROUP BY ShipVia
ORDER BY method_count DESC
LIMIT 1;
""""""

most_frequent_shipping_method = execute_sql_query(sql_query)

show_to_user(most_frequent_shipping_method)
```","The input code correctly implements the business analytics request by using a SQL query to find the most frequently used shipping method. It groups by 'ShipVia', counts the number of orders, orders them in descending order of count, and limits the result to one entry. This logic is consistent with the reference implementation.","```python
import pandas as pd

# Execute the SQL query to get the shipping method frequency
sql_query = """"""
SELECT ShipVia, COUNT(*) as UsageFrequency 
FROM orders 
GROUP BY ShipVia 
ORDER BY UsageFrequency DESC 
LIMIT 1;
""""""
result_df = execute_sql_query(sql_query)

# Display the most frequently used shipping method
result = result_df[['ShipVia', 'UsageFrequency']].iloc[0]
show_to_user(result)
```","The provided Python code correctly executes a SQL query to determine the most frequently used shipping method. It selects `ShipVia` and counts the number of `OrderID`, groups the results by `ShipVia`, orders them by the count, and limits the result to the top one. This logic aligns with the reference implementation. The final selection and display of the result are also correct.",both
Which products have not been ordered in the last three months?,"```python
import pandas as pd

# Define the correct SQL query
sql_query = """"""
SELECT ProductName FROM products 
WHERE ProductID NOT IN (
  SELECT DISTINCT ProductID 
  FROM `Order Details` 
  WHERE OrderID IN (
    SELECT OrderID 
    FROM orders 
    WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
  )
);
""""""

# Execute the SQL query
products_not_ordered_df = execute_sql_query(sql_query)

# Display the result
show_to_user(products_not_ordered_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

three_months_ago = (datetime.now() - timedelta(days=90)).strftime('%Y-%m-%d')

sql_query = f""""""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.OrderID IS NULL OR od.OrderID NOT IN (
    SELECT DISTINCT OrderID
    FROM [Order Details]
    WHERE OrderDate >= '{three_months_ago}'
)
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code generates an incorrect SQL query. It attempts to find products not ordered in the last three months by using a LEFT JOIN on [Order Details]. While this would include products with no orders, it incorrectly filters where od.OrderID IS NULL combined with a subquery not matching based on OrderDate, leading to potentially incorrect exclusions of ordered products. The reference implementation correctly filters products not in the set of product IDs ordered in the specified timeframe.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT p.ProductName 
FROM products p 
LEFT JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
WHERE od.OrderID IS NULL OR od.OrderDate < CURDATE() - INTERVAL 3 MONTH;
""""""

# Execute the query and get the result
products_not_ordered = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_not_ordered)
```","The input Python code does not correctly implement the required logic for determining products not ordered in the last three months. The key issues are: 1) It incorrectly uses a LEFT JOIN and condition 'od.OrderID IS NULL OR od.OrderDate < CURDATE() - INTERVAL 3 MONTH'. The left join approach with 'IS NULL' would aim to identify products with no orders at all, rather than those not ordered in the last three months. 2) 'od.OrderDate < CURDATE() - INTERVAL 3 MONTH' is an incorrect condition because 'OrderDate' is not a field in 'Order Details' and should be checked from the 'orders' table similar to the reference code. The reference code correctly identifies products by checking against order dates within the last three months, using subqueries to compare ProductIDs associated with recent orders.",None
What is the average Inventory Turnover Ratio for each month and visualize it using a line chart to show trends?,"```python
import plotly.express as px

# SQL query to calculate Inventory Turnover Ratio
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'Month' to datetime for proper plotting
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart to visualize the trend of Inventory Turnover Ratio
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Average Inventory Turnover Ratio per Month')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS Inventory_Turnover_Ratio
FROM 
    products 
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY 
    month
ORDER BY 
    month;
""""""

inventory_turnover_df = execute_sql_query(sql_query)

fig = px.line(inventory_turnover_df, x='month', y='Inventory_Turnover_Ratio', title='Average Inventory Turnover Ratio by Month')
show_to_user(fig)
```","The input code does not correctly calculate the Inventory Turnover Ratio as it misses the join with orders table and the filtering by month from the orders. Additionally, it does not convert the 'month' to datetime before plotting, which is present in the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', O.OrderDate) AS Month, 
       SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS InventoryTurnoverRatio 
FROM products P 
JOIN [Order Details] OD ON P.ProductID = OD.ProductID 
JOIN orders O ON OD.OrderID = O.OrderID 
GROUP BY Month;
""""""

# Execute SQL query
data_df = execute_sql_query(sql_query)

# Convert 'Month' column to datetime for proper sorting
data_df['Month'] = pd.to_datetime(data_df['Month'])

# Sort the data by Month
data_df = data_df.sort_values('Month')

# Create line chart using plotly
fig = px.line(data_df, x='Month', y='InventoryTurnoverRatio', title='Average Inventory Turnover Ratio by Month')

# Display the visualization
show_to_user(fig)
```","The input Python code implements the same logic as the reference implementation. Both codes execute a SQL query to calculate the monthly average Inventory Turnover Ratio using similar calculations and groupings. The codes then convert the 'Month' column to a datetime format, ensuring correct temporal sorting, and create a line chart using Plotly to visualize the trend. Minor differences such as the SQL date-truncation function and column alignment do not affect the fundamental logic or the correctness of the analysis.",Finetuned
List the top 5 employees with the highest salaries.,"```python
import pandas as pd

# SQL Query to get the top 5 employees with the highest salaries
sql_query = """"""
SELECT EmployeeID, FirstName, LastName, Salary 
FROM employees 
ORDER BY Salary DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_employees_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(top_employees_df)
```","```python
sql_query = """"""
SELECT FirstName, LastName, Salary
FROM employees
ORDER BY Salary DESC
LIMIT 5
""""""
top_employees = execute_sql_query(sql_query)
show_to_user(top_employees)
```","The provided code correctly retrieves the top 5 employees based on salary in descending order. While the input code omits the 'EmployeeID' field compared to the reference, it still satisfies the business requirement by listing employees' first names, last names, and salaries. The core logic to fetch top salaries with a limit of 5 is implemented as expected.","```python
import pandas as pd

# SQL Query to retrieve the top 5 employees with the highest salaries
sql_query = ""SELECT EmployeeID, LastName, FirstName, Salary FROM employees ORDER BY Salary DESC LIMIT 5;""

# Execute the query and get the result as a dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input Python code correctly retrieves and displays the top 5 employees with the highest salaries. Both the input code and the reference code use the same SQL logic: selecting EmployeeID, FirstName, LastName, and Salary from the employees table, ordering by Salary in descending order, and limiting the result to 5. Despite the slight difference in SQL query formatting (different column order), the functionality and logic remain the same.",both
What's the average discount applied to products?,"```python
import pandas as pd

# SQL query to get the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the average discount
average_discount = result_df['AverageDiscount'].iloc[0]
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
""""""
average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```",The input code correctly replicates the logic of the reference implementation. Both execute a SQL query to calculate the average discount from the 'Order Details' table and display the result using the 'show_to_user' function. The difference in how the DataFrame is accessed does not affect the correctness.,"```python
import pandas as pd

# SQL query to calculate the average discount
sql_query = ""SELECT AVG(Discount) AS AvgDiscount FROM [Order Details];""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['AvgDiscount'])
```","The input Python code correctly calculates and displays the average discount. Both the input and reference codes execute an SQL query to calculate the average discount using the `AVG` function on the `Discount` field from the `[Order Details]` table. The difference in alias naming (`AvgDiscount` vs `AverageDiscount`) does not affect the correctness, and both codes correctly use `show_to_user` to display the result. Therefore, the logic and the business request are appropriately fulfilled.",both
Calculate the total sales revenue generated each month and illustrate with a line chart.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
GROUP BY Month;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Ensure 'Month' is in datetime format for correct plotting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Create a line chart
fig = px.line(sales_data, x='Month', y='MonthlySales', title='Monthly Sales Revenue', labels={'MonthlySales': 'Sales Revenue', 'Month': 'Month'})

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    month
ORDER BY 
    month;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='month', y='total_sales', title='Total Sales Revenue by Month', labels={'total_sales': 'Total Sales Revenue', 'month': 'Month'})
show_to_user(fig)
```","Both implementations perform the same query by calculating total sales revenue per month using the same logic. The SQL queries, although slightly different in syntax (e.g., brackets vs backticks for table names), achieve the same result. The chart creation and visualization aspect is consistent between the two implementations, producing a line chart with the monthly sales data.","```python
import plotly.express as px

query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Month;
""""""

df = execute_sql_query(query)
fig = px.line(df, x='Month', y='TotalSales', title='Monthly Total Sales Revenue')
show_to_user(fig)
```","The input code does not convert the 'Month' column to datetime format before plotting. This is crucial for correct plotting of time-based data. Additionally, there is a difference in the SQL syntax between the reference implementation, which uses backticks, and the input code, which uses square brackets. This may affect execution depending on the SQL environment.",Base
What percentage of orders were shipped after the required date each month and visualize the trends with a bar chart.,"```python
import plotly.express as px

# SQL query to get the percentage of late deliveries each month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) / COUNT(OrderID) AS LateDeliveryRate 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure LateDeliveryRate is in percentage format for plotting
df['LateDeliveryRate'] *= 100

# Create a bar chart to visualize the trend of late delivery rates
fig = px.bar(df, x='Month', y='LateDeliveryRate', 
             title='Monthly Late Delivery Rate',
             labels={'LateDeliveryRate': 'Late Delivery Rate (%)', 'Month': 'Month'})

# Use the defined utility function to display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate > RequiredDate THEN 1 ELSE 0 END) AS LateShipments
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

orders_data = execute_sql_query(sql_query)
orders_data['LateShipmentPercentage'] = (orders_data['LateShipments'] / orders_data['TotalOrders']) * 100

fig = px.bar(orders_data, x='OrderMonth', y='LateShipmentPercentage', 
             title='Percentage of Orders Shipped After Required Date Each Month',
             labels={'LateShipmentPercentage': 'Late Shipment Percentage (%)'})
show_to_user(fig)
```","The input code correctly calculates the percentage of orders shipped after the required date for each month. It uses a similar SQL logic by counting late shipments and dividing by the total orders, then multiplying by 100 to get a percentage. The visualization with Plotly is appropriately set up to reflect the trend over time. The calculation and visualization logic align with the reference implementation.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       COUNT(CASE WHEN orders.ShippedDate > orders.RequiredDate THEN 1 END) / COUNT(orders.OrderID) AS LateDeliveryRate 
FROM orders 
GROUP BY Month
""""""

df = execute_sql_query(sql_query)
df['LateDeliveryRate'] = df['LateDeliveryRate'] * 100

fig = px.bar(df, x='Month', y='LateDeliveryRate', labels={'LateDeliveryRate': 'Late Delivery Rate (%)'})
show_to_user(fig)
```","The provided code matches the logic of the reference implementation. It computes the percentage of orders shipped after the required date for each month by dividing the count of late shipments by total orders each month. Both implementations adjust the 'LateDeliveryRate' to a percentage before visualization. The differences are in the labeling and the use of different string formatting for 'Month', which doesn't affect logic or correctness. Thus, it accurately fulfills the business request.",both
Which shipping method was used most frequently?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount
FROM orders
GROUP BY ShipVia
ORDER BY UsageCount DESC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if result_df is not empty before showing to user
if not result_df.empty:
    show_to_user(result_df)
else:
    show_to_user(pd.DataFrame({""Message"": [""No data found""]}))
```","```python
sql_query = """"""
SELECT ShipVia, COUNT(*) AS Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
LIMIT 1
""""""

most_frequent_shipping_method = execute_sql_query(sql_query)
show_to_user(most_frequent_shipping_method)
```","The input Python code correctly calculates the shipping method used most frequently by counting the number of occurrences of each 'ShipVia' value, ordering them in descending order by count, and limiting the result to the top one, similar to the reference code. The differences in variable naming and result handling do not affect the core logic.","```python
import pandas as pd

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(""SELECT ShipVia, COUNT(*) AS Frequency FROM orders GROUP BY ShipVia ORDER BY Frequency DESC LIMIT 1"")

# Show the result to the user
show_to_user(orders_df)
```","The provided code correctly executes an SQL query that groups the 'ShipVia' column to count the frequency of each shipping method, orders them in descending order, and limits the result to the top entry. This logic aligns with the reference implementation, which aims to identify the most frequently used shipping method. Both implementations use a similar SQL approach, differing slightly in SQL syntax but achieving the same business objective.",both
What is the customer retention rate from January 2022 to January 2023 and visualize retention trend with a line graph.,"```python
import plotly.express as px
import pandas as pd

# SQL queries to get unique customer counts
query_retained_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS retained_customers_count
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2023-01-01'
AND orders.CustomerID IN (
    SELECT DISTINCT CustomerID
    FROM orders
    WHERE orders.OrderDate < '2022-01-01'
)
""""""

query_existing_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS existing_customers_count
FROM orders
WHERE orders.OrderDate < '2022-01-01'
""""""

# Execute the queries
retained_customers_df = execute_sql_query(query_retained_customers)
existing_customers_df = execute_sql_query(query_existing_customers)

# Calculate retention rate
retained_customers = retained_customers_df['retained_customers_count'].iloc[0]
existing_customers = existing_customers_df['existing_customers_count'].iloc[0]
retention_rate = retained_customers / existing_customers if existing_customers != 0 else 0

# Create a pandas DataFrame for visualization
data = {
    'Date Range': ['2022-01 to 2023-01'],
    'Retention Rate': [retention_rate]
}
retention_df = pd.DataFrame(data)

# Visualization using Plotly
fig = px.line(retention_df, x='Date Range', y='Retention Rate', title='Customer Retention Rate Trend')

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

start_date = '2022-01-01'
end_date = '2023-01-31'

retention_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    (COUNT(DISTINCT CASE WHEN OrderDate BETWEEN '{start_date}' AND '{end_date}' THEN CustomerID END) / 
    COUNT(DISTINCT CustomerID)) * 100 AS retention_rate
FROM 
    orders
WHERE 
    OrderDate < '{start_date}'
GROUP BY 
    month;
""""""

retention_data = execute_sql_query(retention_query)

fig = px.line(retention_data, x='month', y='retention_rate', title='Customer Retention Rate Trend (Jan 2022 - Jan 2023)', labels={'retention_rate': 'Retention Rate (%)'})
show_to_user(fig)
```","The input code calculates retention rates for each month within the period by dividing the number of customers who made purchases in the specified period by customers before the start date. This approach differs from the reference code, which computes retention by checking customers who made purchases before the start date and after it up to the end date and divides by the number of customers existing before the start date. Additionally, the input code represents retention as a percentage instead of a fraction, as in the reference.","```python
import pandas as pd
import plotly.express as px

# SQL queries to retrieve data
query_current_period = """"""
SELECT orders.CustomerID
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31';
""""""

query_previous_period = """"""
SELECT orders.CustomerID
FROM orders
WHERE orders.OrderDate < '2023-01-01';
""""""

# Execute the SQL queries
df_current = execute_sql_query(query_current_period)
df_previous = execute_sql_query(query_previous_period)

# Calculate customer retention rate
current_customers = df_current['CustomerID'].nunique()
previous_customers = df_previous['CustomerID'].nunique()
customer_retention_rate = current_customers / previous_customers if previous_customers > 0 else 0

# Create a dataframe for visualization
retention_data = pd.DataFrame({
    'Period': ['Current', 'Previous'],
    'CustomerCount': [current_customers, previous_customers]
})

# Visualize retention trend
fig = px.line(retention_data, x='Period', y='CustomerCount', title='Customer Retention Trend')
show_to_user(fig)
```","The input code calculates and visualizes the count of unique customers in the current and previous periods, instead of calculating and visualizing the retention rate. Additionally, it uses '2023-01-01' to '2023-12-31' instead of '2022-01-01' to '2023-01-01'. The reference implementation calculates the retention rate between two specified dates and visualizes the retention trend in a line graph, which the input does not follow.",None
What is the average order value for the year 2021?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) AS OrderValue,
    orders.OrderID
FROM 
    orders 
JOIN 
    [Order Details] 
ON 
    orders.OrderID = [Order Details].OrderID 
WHERE 
    YEAR(orders.OrderDate) = 2021;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate average order value
average_order_value = result_df.groupby('OrderID')['OrderValue'].sum().mean()

# Show the result to the user
show_to_user(pd.DataFrame({'AverageOrderValue': [average_order_value]}))
```","```python
sql_query = """"""
SELECT 
    AVG(total_sales) AS average_order_value 
FROM (
    SELECT 
        orders.OrderID,
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
    FROM 
        orders
    JOIN 
        [Order Details] ON orders.OrderID = [Order Details].OrderID
    WHERE 
        YEAR(orders.OrderDate) = 2021
    GROUP BY 
        orders.OrderID
) AS sales_per_order;
""""""

average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","The input code and the reference code both calculate the average order value for the year 2021. They use the same logic: multiplying unit price by quantity and adjusting for discounts to find total sales per order, grouping by OrderID, and then averaging these totals. The input code uses a subquery to calculate total sales per order and directly computes the average, which is equivalent to the reference code's method of grouping and then computing the mean. Thus, the input code adheres to the same logic and accomplishes the business analytics request correctly.","```python
import pandas as pd

# SQL query to retrieve average order value for 2021
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) /
    COUNT(DISTINCT o.OrderID) AS avg_order_value
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    YEAR(o.OrderDate) = 2021;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['avg_order_value'].iloc[0])
```","The input code and reference implementation yield the same result: the average order value for the year 2021. The input code computes the sum of the order values and divides it by the count of distinct orders directly in the SQL query, whereas the reference implementation calculates each order's value first and then computes the average using Pandas. Both methods are logically equivalent and provide the correct answer.",both
Identify the top 3 products with the most number of orders and illustrate with a bar chart.,"```python
import plotly.express as px

# SQL query to retrieve top 3 products with most orders
sql_query = """"""
SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) AS NumberOfOrders
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY NumberOfOrders DESC
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductName', y='NumberOfOrders', title='Top 3 Products with Most Orders')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the top 3 products with the most number of orders
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrders
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrders DESC
LIMIT 3
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(top_products_df, x='ProductName', y='TotalOrders', 
             title='Top 3 Products with Most Orders', 
             labels={'TotalOrders': 'Number of Orders'})
             
# Show the result to the user
show_to_user(fig)
```","The input code calculates the top products based on 'SUM(od.Quantity)' rather than 'COUNT(od.OrderID)', which is used in the reference code. The task requires the products with the most number of orders, not the total quantity ordered.","```python
import plotly.express as px

# SQL query to get the top 3 products with the most number of orders
sql_query = """"""
SELECT ProductID, COUNT(OrderID) AS OrderCount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY OrderCount DESC 
LIMIT 3;
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(order_data, x='ProductID', y='OrderCount', title='Top 3 Products by Number of Orders')

# Show the visualization
show_to_user(fig)
```","The input Python code does not include joining the products table to retrieve ProductName. It only queries ProductID and uses that in the chart, which deviates from the business analytics request to show product names. Therefore, it doesn't provide a bar chart illustrating the ProductName with the number of orders as required.",None
What are the average monthly sales generated by each region and present with a multi-line chart for each region.,"```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT territories.RegionID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) /
       COUNT(DISTINCT DATE_TRUNC('month', orders.OrderDate)) AS avg_monthly_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
GROUP BY territories.RegionID
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Multi-line chart
fig = px.line(df, x=df.index, y='avg_monthly_sales', color='RegionID', title='Average Monthly Sales by Region')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    customers.Region,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
GROUP BY 
    Month, customers.Region
ORDER BY 
    Month, customers.Region
""""""
sales_data = execute_sql_query(sql_query)

avg_sales_data = sales_data.groupby('Region').mean().reset_index()
fig = px.line(avg_sales_data, x='Region', y='Total_Sales', title='Average Monthly Sales by Region')
show_to_user(fig)
```","The input code calculates the average sales per region across all months and does not present the data as a multi-line chart representing monthly changes. The SQL query in the input code groups by month and region but then aggregates to a single average for each region, whereas the reference code averages across distinct months per region. Additionally, the chart generation logic in the input loops over 'Region' rather than a timeline, which does not adhere to the requirement of depicting average monthly sales over time for each region.","```python
import plotly.express as px

query = """"""
SELECT RegionID, YEAR(OrderDate) AS year, MONTH(OrderDate) AS month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageMonthlySales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY RegionID, YEAR(OrderDate), MONTH(OrderDate);
""""""

df = execute_sql_query(query)

fig = px.line(df, x='month', y='AverageMonthlySales', color='RegionID', 
              title='Average Monthly Sales by Region',
              labels={'month': 'Month', 'AverageMonthlySales': 'Average Monthly Sales'})

show_to_user(fig)
```","The input code calculates total monthly sales for each region instead of average monthly sales. It groups by `RegionID`, `YEAR(OrderDate)`, and `MONTH(OrderDate)`, which results in monthly totals. The reference code groups by `RegionID` and uses the distinct monthly count to calculate the average, which the input code lacks.",None
Find the order with the highest discount applied.,"```python
import pandas as pd

# SQL query to find the order with the highest discount
sql_query = ""SELECT OrderID, MAX(Discount) as MaxDiscount FROM [Order Details] GROUP BY OrderID ORDER BY MaxDiscount DESC LIMIT 1;""

# Execute the SQL query and retrieve the data
order_with_max_discount = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_with_max_discount)
```","```python
sql_query = """"""
SELECT * 
FROM [Order Details]
ORDER BY Discount DESC 
LIMIT 1
""""""
highest_discount_order = execute_sql_query(sql_query)
show_to_user(highest_discount_order)
```","The input Python code finds the specific row with the highest discount by ordering all rows by the 'Discount' column and limiting the results to one. This does not ensure grouping by 'OrderID' to find the order with the highest aggregate discount. The reference code groups by 'OrderID' and then finds the maximum discount per order, which is different from simply finding a single record with the highest discount.","```python
import pandas as pd

sql_query = """"""
SELECT OrderID, MAX(Discount) AS MaxDiscount
FROM [Order Details]
GROUP BY OrderID
ORDER BY MaxDiscount DESC
LIMIT 1;
""""""

result_df = execute_sql_query(sql_query)

show_to_user(result_df)
```","The input code correctly uses an SQL query to find the order with the highest discount. The query groups by OrderID, selects the maximum discount for each order, and orders the results in descending order of MaxDiscount, limiting the result to the top record. This matches the logic of the reference implementation provided. Both implementations execute the query with a function `execute_sql_query` and show the result using `show_to_user`.",Finetuned
Calculate the monthly total sales revenue over the last year and plot with a time series line chart.,"```python
import plotly.express as px

# SQL query to fetch monthly total sales revenue over the last year
sql_query = """"""
SELECT MONTH(o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1
GROUP BY MONTH(o.OrderDate) 
ORDER BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Plot the time series line chart
fig = px.line(df, x='Month', y='TotalSales', labels={'Month': 'Month', 'TotalSales': 'Total Sales Revenue'},
              title='Monthly Total Sales Revenue Over the Last Year')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = '''
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= NOW() - INTERVAL '1 year'
GROUP BY 
    month
ORDER BY 
    month;
'''

monthly_sales = execute_sql_query(sql_query)

fig = px.line(monthly_sales, x='month', y='total_sales', title='Monthly Total Sales Revenue Over the Last Year')
show_to_user(fig)
```","The input code uses `DATE_TRUNC('month', o.OrderDate)` and `o.OrderDate >= NOW() - INTERVAL '1 year'`, which may include current month's data. The reference code uses `MONTH(o.OrderDate)` and `WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1`, which calculates the previous full calendar year, excluding the current month. The time range difference makes the input code incorrect compared to the reference.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY Month;
""""""

# Fetch data
df = execute_sql_query(sql_query)

# Ensure Month is treated as categorical
df['Month'] = pd.to_datetime(df['Month']).dt.to_period('M')

# Plot data
fig = px.line(df.sort_values('Month'), x='Month', y='TotalSales', title='Monthly Total Sales Revenue Over the Last Year')
show_to_user(fig)
```","The input code uses `DATE_FORMAT` to group the orders by year and month, but the SQL `WHERE` clause uses `o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)`, which will include the current date and month from the previous year onward. This potentially includes incomplete months and differs from the reference, which specifically looks at the previous full calendar year using `YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1`. The input code does not guarantee the extraction of data for the entirety of the previous year, affecting the correctness of the time series plot.",None
How many units are currently in stock for each product?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitsInStock FROM products;""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Display the data to user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
""""""
data = execute_sql_query(sql_query)
show_to_user(data)
```","The input Python code correctly implements the business analytics request by querying the ProductName and UnitsInStock from the products table, similar to the reference implementation. It then uses the same function to execute the SQL query and display the result to the user. The logic matches the reference implementation in terms of functionality.","```python
import pandas as pd

# SQL Query to get the required data
sql_query = """"""
SELECT ProductName, UnitsInStock FROM products;
""""""

# Execute the SQL query and get the result in a dataframe
products_in_stock_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(products_in_stock_df)
```","The input Python code correctly executes the SQL query to retrieve 'ProductName' and 'UnitsInStock' from the 'products' table, similar to the reference implementation. The result is assigned to a DataFrame and displayed using 'show_to_user', which is consistent with the reference logic.",both
List employees who have birthdays in the current month.,"```python
from datetime import datetime
import pandas as pd

# Fetch current month
current_month = datetime.now().month

# Define the SQL query
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
WHERE MONTH(e.BirthDate) = {current_month};
""""""

# Execute SQL query
employees_with_birthday = execute_sql_query(sql_query)

# Display the results
show_to_user(employees_with_birthday)
```","```python
import pandas as pd
from datetime import datetime

current_month = datetime.now().month

sql_query = f""""""
SELECT EmployeeID, FirstName, LastName, BirthDate
FROM employees
WHERE MONTH(BirthDate) = {current_month}
""""""

employees_with_birthday_this_month = execute_sql_query(sql_query)
show_to_user(employees_with_birthday_this_month)
```","The input Python code correctly implements the business analytics request by listing employees who have birthdays in the current month. It uses a SQL query that selects EmployeeID, FirstName, LastName, and BirthDate from the 'employees' table where the month of BirthDate matches the current month. This logic is the same as the reference implementation, which also retrieves employee details based on the current month's birthdays. Therefore, the input code is correct.","```python
import pandas as pd
from datetime import datetime

# Get current month
current_month = datetime.now().month

# SQL Query to fetch employees with birthdays in the current month
sql_query = f""""""
SELECT FirstName, LastName, Birthday 
FROM employees 
WHERE MONTH(BirthDate) = {current_month};
""""""

# Execute the SQL query
employee_birthdays_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employee_birthdays_df)
```","The input code retrieves the 'FirstName', 'LastName', and 'Birthday' columns, whereas the reference code retrieves 'EmployeeID', 'FirstName', and 'LastName'. The request is to list employees with birthdays in the current month, not retrieve details of the birthday itself.",Base
What is the total sales revenue for each product and display with a sorted bar chart.,"```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT P.ProductID, SUM(OD.Quantity * OD.UnitPrice) AS TotalSalesRevenue 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY P.ProductID;
""""""

# Execute the SQL query and store the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Sort the dataframe by TotalSalesRevenue in descending order
df_sorted = df.sort_values(by='TotalSalesRevenue', ascending=False)

# Create a bar chart using plotly express
fig = px.bar(df_sorted, x='ProductID', y='TotalSalesRevenue', title='Total Sales Revenue by Product')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalRevenue DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='TotalRevenue', title='Total Sales Revenue for Each Product')
show_to_user(fig)
```","The input code calculates the total sales revenue per product considering discounts, while the reference code calculates it without discounts. Additionally, the input orders the results in SQL, while the reference sorts the result in Python.","```python
import plotly.express as px

query = """"""
SELECT p.ProductID, SUM(od.Quantity * od.UnitPrice) AS TotalSalesRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID 
ORDER BY TotalSalesRevenue DESC;
""""""

data = execute_sql_query(query)
fig = px.bar(data, x='ProductID', y='TotalSalesRevenue', title='Total Sales Revenue by Product')
show_to_user(fig)
```","The input code correctly calculates the total sales revenue for each product and sorts it in descending order, similar to the reference implementation. Both codes generate a bar chart displaying the total sales revenue by product, with the difference only being that the input code sorts the results directly in the SQL query, while the reference does it in pandas. The logic and outcome are consistent with the request.",Finetuned
Who is the highest paid employee and what is their total sales?,"```python
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY e.Salary DESC 
LIMIT 1;
'''

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    e.Salary, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName, e.Salary
ORDER BY 
    e.Salary DESC
LIMIT 1
""""""

highest_paid_employee_df = execute_sql_query(sql_query)
show_to_user(highest_paid_employee_df)
```","The input Python code correctly implements the logic to find the highest paid employee and their total sales. It retrieves the necessary fields, computes the total sales as per the provided business analytics request, and orders by salary in descending order to get the highest paid employee. The addition of 'FirstName' and 'LastName' in the GROUP BY clause does not affect the correctness related to the request, as it still identifies the correct employee with the highest salary. It also includes these fields for additional detail, which aligns with the reference logic and objective.","```python
import pandas as pd

# SQL Query to find the highest paid employee and their total sales
sql_query = """"""
SELECT e.EmployeeID, e.LastName, e.FirstName, e.Salary, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY e.Salary DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The input Python code is correct. Both the input and reference implementations aim to find the highest paid employee based on salary and calculate their total sales. Although the input code includes additional fields (LastName and FirstName), it adheres to the same logic of sorting by salary in descending order and using a limit to get the top record. The core task, finding the employee with the maximum salary and their total sales, is addressed accurately in both versions.",both
What is the average discount given for each supplier's products and visualize with a bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS AvgDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AvgDiscount', title='Average Discount by Supplier')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='SupplierID', y='AverageDiscount', 
             title='Average Discount Given for Each Supplier\'s Products', 
             labels={'SupplierID': 'Supplier ID', 'AverageDiscount': 'Average Discount'})
show_to_user(fig)
```","The input code performs the same logic as the reference implementation. It executes the SQL query to calculate the average discount for each supplier's products and visualizes it using a bar chart. The SQL query, data storage, and visualization steps match the reference. The only differences are minor naming variations ('AverageDiscount' vs. 'AvgDiscount') and the addition of labels in the visualization, which do not affect the correctness of the logic.","```python
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS AvgDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart for average discount by supplier
fig = px.bar(df, x='SupplierID', y='AvgDiscount', title='Average Discount per Supplier')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly executes the required SQL query to calculate the average discount for each supplier's products. It then visualizes the results using a bar chart created with Plotly, aligning with the logic in the reference implementation. Despite minor differences in the chart title, the functionality remains consistent with the business analytics request.",both
Calculate the total sales revenue generated in the last month.,"```python
import pandas as pd

# SQL Query to calculate total sales revenue for the last month
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Display the result
show_to_user(sales_data.iloc[0]['TotalSales'])
```","```python
from datetime import datetime, timedelta

# Calculate the start and end dates for the last month
today = datetime.now()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

sql_query = f""""""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
AND orders.OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}';
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input code correctly calculates the start and end dates for the previous month and constructs a SQL query to sum the total sales from the 'Order Details' table, joined with 'orders', and filters orders based on the specified dates. This logic aligns with the reference implementation by ensuring it selects the last month's data, despite minor differences such as formatting date subtraction and inclusion of end date condition. The approach effectively retrieves the needed total sales revenue for the last month.","```python
import pandas as pd
from datetime import datetime, timedelta

# SQL query to get the total sales revenue for the last month
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= DATE_FORMAT(NOW() - INTERVAL 1 MONTH, '%Y-%m-01')
AND orders.OrderDate < DATE_FORMAT(NOW(), '%Y-%m-01');
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df['TotalSales'].iloc[0])
```","The input code correctly calculates the total sales revenue for the last month. Both implementations query a SQL database to sum the product of UnitPrice, Quantity, and Discount from the 'Order Details' table. The only difference is in the date comparison logic: the input uses the beginning of the last month to the start of the current month, ensuring the same interval but with a different method. The result is logically equivalent to the reference implementation.",both
What is the total sales per employee for each month and illustrate with a stacked bar chart.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT e.EmployeeID, 
       strftime('%Y-%m', o.OrderDate) as OrderMonth, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, OrderMonth;
""""""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Create a stacked bar chart
fig = px.bar(result_df, x='OrderMonth', y='TotalSales', color='EmployeeID', 
             title='Total Sales per Employee for Each Month', 
             labels={'TotalSales': 'Total Sales', 'OrderMonth': 'Order Month'}, 
             barmode='stack')

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, OrderMonth
ORDER BY 
    OrderMonth, e.EmployeeID
""""""

sales_data = execute_sql_query(sql_query)

sales_data_pivot = sales_data.pivot_table(index='OrderMonth', columns=['EmployeeID', 'FirstName', 'LastName'], values='TotalSales', fill_value=0)

fig = px.bar(sales_data_pivot, 
             title=""Total Sales per Employee per Month"",
             labels={'value': 'Total Sales', 'OrderMonth': 'Month'},
             height=400)

show_to_user(fig)
```","The input code deviates from the reference implementation in two major ways. First, it includes additional columns (FirstName and LastName) in the SQL query and the pivot table, which affects the structure and visualization of the data. The reference implementation does not include these columns. Second, the input code uses a multi-indexed pivot table with these additional columns, which Plotly Express might not handle directly as the reference does, potentially leading to different behavior in chart rendering.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    E.EmployeeID, 
    MONTH(O.OrderDate) AS Month, 
    SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales 
FROM employees E 
JOIN orders O ON E.EmployeeID = O.EmployeeID 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
GROUP BY E.EmployeeID, MONTH(O.OrderDate);
""""""

# Read data from the database
df = execute_sql_query(sql_query)

# Pivot the data for a stacked bar chart
pivot_df = df.pivot(index='Month', columns='EmployeeID', values='TotalSales').fillna(0)

# Create a stacked bar chart
fig = px.bar(pivot_df, 
             x=pivot_df.index, 
             y=pivot_df.columns, 
             title='Total Sales per Employee per Month',
             labels={'value': 'Total Sales', 'Month': 'Month'})

# Display the visualization
show_to_user(fig)
```","The input code uses the function MONTH(O.OrderDate) instead of strftime('%Y-%m', O.OrderDate) in the SQL query. This means it groups sales by month only (ignoring the year), which could lead to incorrect results if there are multiple years of data. Additionally, the input code performs a pivot operation, expecting a DataFrame with rows for months and columns for EmployeeIDs, while the reference code does not pivot the data, rather it uses 'OrderMonth' directly. This affects how the data is visualized in the stacked bar chart, making the input code inconsistent with the reference implementation.",None
How does the total number of units sold compare between discontinued and active products and visualize with a comparative bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.Discontinued, 
       SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.Discontinued
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a comparative bar chart using Plotly
fig = px.bar(df, x='Discontinued', y='TotalUnitsSold',
             labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'},
             title='Total Units Sold: Discontinued vs Active Products',
             color='Discontinued')

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.Discontinued,
    SUM(od.Quantity) AS TotalUnitsSold
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.Discontinued
""""""
data = execute_sql_query(sql_query)

fig = px.bar(data, x='Discontinued', y='TotalUnitsSold',
              labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'},
              title='Comparison of Total Units Sold Between Discontinued and Active Products')
show_to_user(fig)
```",The provided input code is functionally equivalent to the reference implementation. Both codes execute a SQL query to aggregate the total quantity sold per product status (Discontinued or Active) by joining 'Order Details' and 'products' tables. They group by 'Discontinued' to determine total units sold for each status. The resulting data is then used to create a bar chart with Plotly. Minor differences in variable names and descriptions do not affect the correctness.,"```python
import pandas as pd
import plotly.express as px

# SQL Queries
sql_query_active = """"""
SELECT SUM(od.Quantity) AS TotalUnitsSold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE p.Discontinued = 0;
""""""

sql_query_discontinued = """"""
SELECT SUM(od.Quantity) AS TotalUnitsSold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE p.Discontinued = 1;
""""""

# Execute SQL Queries
df_active = execute_sql_query(sql_query_active)
df_discontinued = execute_sql_query(sql_query_discontinued)

# Prepare data for plot
data = pd.DataFrame({
    'Product Status': ['Active', 'Discontinued'],
    'Total Units Sold': [df_active['TotalUnitsSold'][0], df_discontinued['TotalUnitsSold'][0]]
})

# Create bar chart
fig = px.bar(data, x='Product Status', y='Total Units Sold', title='Total Units Sold by Product Status')

# Implement the visualization
show_to_user(fig)
```","Both implementations correctly calculate the total units sold for active and discontinued products, though they do so using slightly different methods. The reference code performs this operation with a single SQL query that groups by the 'Discontinued' field, while the input code uses two separate SQL queries filtering by 'Discontinued' status. Despite the difference in SQL query structure, the data for creating the plot is equivalent in both implementations. Additionally, both use Plotly to create and display a bar chart comparing active and discontinued product sales, fulfilling the request.",both
Count the total number of orders placed by each customer.,"```python
import pandas as pd

# Construct the SQL query
sql_query = ""SELECT CustomerID, COUNT(*) AS total_orders FROM orders GROUP BY CustomerID;""

# Execute the SQL query and get the result as a pandas dataframe
df_orders = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_orders)
```","```python
sql_query = """"""
SELECT 
    c.CustomerID, 
    COUNT(o.OrderID) AS TotalOrders
FROM 
    customers c
LEFT JOIN 
    orders o ON c.CustomerID = o.CustomerID
GROUP BY 
    c.CustomerID
ORDER BY 
    TotalOrders DESC
""""""

order_count_df = execute_sql_query(sql_query)
show_to_user(order_count_df)
```","Both implementations aim to count the total number of orders for each customer. The input code joins the customers and orders using a LEFT JOIN, which ensures all customers are included even if they have no orders. It aggregates the count of OrderID for each customer using GROUP BY CustomerID, similar to the reference. Although it uses a LEFT JOIN and orders the results, the counting logic aligns with the reference code.","```python
import pandas as pd

# SQL query to get total number of orders placed by each customer
sql_query = ""SELECT CustomerID, COUNT(OrderID) as TotalOrders FROM orders GROUP BY CustomerID;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","Both the input code and the reference code execute a SQL query to count the number of orders for each customer and group the results by CustomerID. The reference code uses COUNT(*) while the input code uses COUNT(OrderID), but both achieve the same result when grouped by CustomerID. The code logic aligns with the business request to count total orders per customer.",both
Identify the product categories with the lowest total sales revenue and display with a bar chart.,"```python
import plotly.express as px

# SQL query to identify the product category with the lowest total sales revenue
sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
ORDER BY TotalRevenue ASC
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales revenue by the lowest product category
fig = px.bar(df, x='CategoryID', y='TotalRevenue', title='Lowest Total Sales Revenue by Product Category')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY TotalSales ASC
LIMIT 10
""""""

lowest_sales_df = execute_sql_query(sql_query)

fig = px.bar(lowest_sales_df, x='CategoryID', y='TotalSales', title='Product Categories with Lowest Total Sales Revenue')
show_to_user(fig)
```","The input code retrieves the top 10 product categories with the lowest total sales revenue, whereas the reference implementation retrieves only the single category with the lowest total sales revenue. The LIMIT clauses differ (10 in the input vs 1 in the reference), leading to a different output and thus a deviation from the specified business analytics request.","```python
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
ORDER BY TotalSales ASC;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(
    df,
    x='CategoryID',
    y='TotalSales',
    title='Product Categories with Lowest Total Sales Revenue'
)

# Display the chart
show_to_user(fig)
```","The input code orders all product categories by total sales revenue in ascending order but does not limit the results to only the product category with the lowest total sales. The reference code correctly limits the result using 'LIMIT 1', while the input code does not use a limit, resulting in a bar chart for all categories instead of just the one with the lowest revenue.",None
Find the product categories with the highest average unit price.,"```python
import pandas as pd

# SQL query to find the product categories with the highest average unit price
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice
FROM products
GROUP BY CategoryID
ORDER BY AverageUnitPrice DESC;
""""""

# Execute the SQL query
product_categories_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(product_categories_df)
```","```python
sql_query = """"""
SELECT p.CategoryID, AVG(od.UnitPrice) AS AverageUnitPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY AverageUnitPrice DESC
""""""

average_unit_price_df = execute_sql_query(sql_query)
show_to_user(average_unit_price_df)
```","The input code includes a JOIN with the 'Order Details' table, which is unnecessary as the reference implementation calculates the average directly from the 'products' table. This makes the input code more complex and potentially inaccurate, depending on the structure and intended use of 'Order Details'.","```python
import pandas as pd

# SQL query to find the product categories with the highest average unit price.
sql_query = """"""
SELECT categories.CategoryID, AVG(products.UnitPrice) as AvgUnitPrice 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryID 
ORDER BY AvgUnitPrice DESC;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code correctly addresses the business analytics request by calculating the average unit price for each product category. It joins the 'products' and 'categories' tables on 'CategoryID', ensuring all necessary data is considered. The logic aligns with the reference implementation; both group by 'CategoryID' and order by average unit price in descending order. The slight variation in the SQL syntax does not affect the correctness as it achieves the same goal.",Finetuned
How many orders included products with a discount of more than 10%?,"```python
sql_query = """"""
SELECT COUNT(*) as order_count
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0.1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['order_count'][0])
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT o.OrderID) AS OrdersWithDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount > 0.10
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly implements the logic to count the number of unique orders with a discount greater than 10%. Using COUNT(DISTINCT o.OrderID) achieves the same result as the reference code, which counts orders matching the condition. Both codes filter orders with od.Discount > 0.1 and return the count of such orders.","```python
import pandas as pd

# Define the SQL query to count distinct OrderIDs with discount > 10%
sql_query = """"""
SELECT COUNT(DISTINCT o.OrderID) AS OrderCount 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE od.Discount > 0.10;
""""""

# Execute the SQL query
order_count_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_count_df['OrderCount'].iloc[0])
```","The input Python code correctly answers the business analytics request. It calculates the number of orders that included products with a discount of more than 10%. The input code uses COUNT(DISTINCT o.OrderID) to ensure it only counts unique orders, which matches the likely intent of the reference code using COUNT(*). The logic and criteria (i.e., joining orders with Order Details and filtering by Discount > 0.10) are consistent with the reference implementation.",both
What is the performance ranking of products based on sales quantity?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure that the DataFrame is sorted by TotalQuantity in descending order
df = df.sort_values(by='TotalQuantity', ascending=False)

# Display the result
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity) AS TotalSalesQuantity
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    TotalSalesQuantity DESC
""""""

performance_ranking_df = execute_sql_query(sql_query)
show_to_user(performance_ranking_df)
```","The input code correctly follows the logic of the reference implementation. Both queries calculate the total sales quantity for each product and order by the total quantity in descending order. Even though the column for total quantity is named 'TotalSalesQuantity' instead of 'TotalQuantity', it does not affect the correctness. The data is retrieved using the same SQL logic and displayed in the same manner.","```python
import pandas as pd

# SQL query to retrieve product performance ranking
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantitySold DESC
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```",Both the reference and input codes correctly retrieve and rank products based on sales quantity. The input code orders by 'TotalQuantitySold' which is equivalent to 'TotalQuantity' in the reference. The difference in column alias does not impact correctness. The essential logic and order of operations are consistent between the two.,both
List the orders grouped by required dates and their total freight costs.,"```python
import pandas as pd

# SQL query
sql_query = ""SELECT RequiredDate, SUM(Freight) AS TotalFreightCost FROM orders GROUP BY RequiredDate;""

# Execute query and retrieve dataframe
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","```python
sql_query = """"""
SELECT RequiredDate, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY RequiredDate
ORDER BY RequiredDate;
""""""

orders_freight = execute_sql_query(sql_query)
show_to_user(orders_freight)
```","The input Python code correctly implements the business analytics request. It selects the required date and calculates the sum of freight costs from the 'orders' table, grouping by 'RequiredDate'. The additional 'ORDER BY RequiredDate' in the input code doesn't alter the correctness and logically aligns with the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT RequiredDate, SUM(Freight) AS TotalFreight FROM orders GROUP BY RequiredDate;""

# Execute the SQL query
orders_freight_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(orders_freight_df)
```","The input Python code uses the same logic as the reference implementation by grouping orders by 'RequiredDate' and summing the 'Freight' costs. The only difference is the alias for 'SUM(Freight)', which is irrelevant to the correctness of the code. Therefore, the input code correctly implements the business analytics request.",both
"Calculate the month-over-month growth rate of total sales for December 2023, including a line chart to illustrate trends over the months.","```python
import pandas as pd
import plotly.express as px

# SQL query to get relevant data
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') IN ('2023-11', '2023-12')
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query and store the result in a dataframe
sales_data = execute_sql_query(sql_query)

# Calculate Month-over-Month Growth Rate
sales_data['MoM_GrowthRate'] = sales_data['TotalSales'].pct_change()

# Extract December 2023 Growth Rate
december_growth_rate = sales_data[sales_data['OrderMonth'] == '2023-12']['MoM_GrowthRate'].values[0]

# Plotting the trend line chart for Total Sales
fig = px.line(
    sales_data,
    x='OrderMonth',
    y='TotalSales',
    title='Total Sales Trend (Nov - Dec 2023)',
    labels={'TotalSales': 'Total Sales ($)', 'OrderMonth': 'Month'}
)

# Display the plot
show_to_user(fig)

# Display the December Growth Rate
show_to_user(pd.DataFrame({'December 2023 MoM Growth Rate': [december_growth_rate]}))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE OrderDate >= '2023-01-01' AND OrderDate < '2024-01-01'
GROUP BY Month
ORDER BY Month
""""""

sales_data = execute_sql_query(sql_query)

sales_data['TotalSales'] = sales_data['TotalSales'].astype(float)
sales_data['GrowthRate'] = sales_data['TotalSales'].pct_change() * 100

fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales Month-over-Month Growth Rate for 2023')
fig.add_scatter(x=sales_data['Month'], y=sales_data['GrowthRate'], mode='lines+markers', name='Growth Rate (%)')
show_to_user(fig)
```","The input code includes additional months and calculates the growth rate for each month instead of just between November and December 2023. It also includes the full year in the SQL query instead of focusing on the last two months. This deviates from the specific logic implemented in the reference code, which is restricted to November and December 2023 for calculating the MoM growth rate.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales for December 2023 and previous month
sql_query = """"""
SELECT 
    SUM(CASE WHEN MONTH(o.OrderDate) = 12 AND YEAR(o.OrderDate) = 2023 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END) AS Sales_Dec_2023,
    SUM(CASE WHEN MONTH(o.OrderDate) = 11 AND YEAR(o.OrderDate) = 2023 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END) AS Sales_Nov_2023
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Calculate month-over-month growth rate
df['MoM_Growth_Rate'] = (df['Sales_Dec_2023'] - df['Sales_Nov_2023']) / df['Sales_Nov_2023']

# Prepare data for line chart
months = ['November 2023', 'December 2023']
sales_data = [df['Sales_Nov_2023'].values[0], df['Sales_Dec_2023'].values[0]]

# Create DataFrame for line chart
line_chart_df = pd.DataFrame({'Month': months, 'Sales': sales_data})

# Plot the line chart
fig = px.line(line_chart_df, x='Month', y='Sales', title='Monthly Sales Trend')

# Show results
show_toast(f""December 2023 MoM Growth Rate: {df['MoM_Growth_Rate'].values[0]:.2%}"")
show_toast(df[['Sales_Dec_2023', 'Sales_Nov_2023']])
show_toast(fig)
```","The input code calculates total sales for November and December separately, then computes the MoM growth directly using these totals. This approach differs significantly from the reference implementation which calculates monthly totals first and uses the `pct_change()` method on a DataFrame that is grouped by month, providing a more straightforward and reliable calculation. Additionally, the reference code uses the formatted date directly for aggregation, while the input code relies on conditional aggregation within the SQL query, which could lead to different results if the data extraction is not aligned. Moreover, the input code lacks the correct visualization of month labels, using raw strings for the month names, which can misalign with actual data conventions.",None
"How does the average unit price of products vary across categories, using a bar chart to visualize differences?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.CategoryID, AVG(products.UnitPrice) AS AverageUnitPrice
FROM products
GROUP BY products.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title=""Average Unit Price Across Categories"")

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AvgUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data_frame=data, x='CategoryID', y='AvgUnitPrice', 
             labels={'CategoryID': 'Category ID', 'AvgUnitPrice': 'Average Unit Price'},
             title='Average Unit Price of Products Across Categories')
show_to_user(fig)
```","The input code provides the correct answer to the business analytics request. It calculates the average unit price of products grouped by category using a SQL query and then visualizes the results in a bar chart using Plotly Express. The logic adheres to the reference implementation's intent, executing the same SQL query structure and producing a similar visualization, albeit with additional label customization.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT categories.CategoryID, AVG(products.UnitPrice) AS AverageUnitPrice 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Category')

# Display the bar chart
show_to_user(fig)
```","Both the input and reference code calculate the average unit price of products grouped by product categories and visualize the results as a bar chart. The input code includes a JOIN operation to fetch CategoryID, but it follows the same logic as the reference in terms of the aggregation and visualization, thus providing the same business insight.",both
What is the most common shipping city for the current year?,"```python
import pandas as pd

# SQL query to retrieve the most common shipping city for the current year
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(*) as OrderCount
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE())
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1
""""""

most_common_city = execute_sql_query(sql_query)

if not most_common_city.empty:
    show_to_user(most_common_city)
```","The input code correctly follows the same logic as the reference implementation. It executes an SQL query to find the most common shipping city for the current year, grouping by 'ShipCity', counting the orders, and ordering by 'OrderCount' in descending order. Both implementations limit the result to 1, ensuring only the most common city is returned. Additionally, the input code includes a check to ensure the result is not empty before displaying it to the user, which is a reasonable safeguard.","```python
import pandas as pd

query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE()) 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

result_df = execute_sql_query(query)
show_to_user(result_df)
```","The input Python code accurately executes a SQL query to determine the most common shipping city for the current year, matching the logic of the provided reference implementation. It uses 'CURRENT_DATE()' instead of 'CURDATE()', both of which return the current date in MySQL. The rest of the SQL syntax and logic remain consistent, including grouping by 'ShipCity', counting orders, sorting in descending order, and limiting to the top result.",both
How many products have a reorder level of zero?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS ZeroReorderProducts FROM products WHERE ReorderLevel = 0""

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['ZeroReorderProducts'].iloc[0])
```","```python
sql_query = ""SELECT COUNT(*) AS ProductCount FROM products WHERE ReorderLevel = 0""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code displays the entire DataFrame instead of just showing the count of products with a reorder level of zero. It should be showing the specific count, similar to the reference code which does so by accessing 'ZeroReorderProducts' from the result DataFrame.","```python
import pandas as pd

# SQL query to get products with a reorder level of zero
sql_query = ""SELECT ProductName FROM products WHERE ReorderLevel = 0;""

# Execute SQL query
products_df = execute_sql_query(sql_query)

# Count number of products with reorder level of zero
count_reorder_zero = len(products_df)

# Display the result
show_to_user(pd.DataFrame({'Products with Reorder Level = 0': [count_reorder_zero]}))
```","The input code correctly counts the number of products with a reorder level of zero by executing a SQL query that selects products with ReorderLevel = 0 and then getting the length of the resulting DataFrame. Although the reference code directly counts in the SQL query, both implementations achieve the same result by counting the products with ReorderLevel = 0.",Finetuned
"What is the total revenue generated by each product, visualized with a bar chart for comparison?","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')
show_to_user(fig)
```","The input code groups the total revenue by 'ProductName' instead of 'ProductID', which is different from the reference implementation. This results in different groupings and potentially different revenue calculations if multiple products share the same name.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total revenue per product
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

# Display the chart
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by calculating the total revenue for each product and visualizing it with a bar chart. The primary difference between the reference and input implementation is that the input code groups by 'ProductName' instead of 'ProductID'. Since the request is to generate revenue by each product and the logical grouping by product name is used in practice, this difference does not violate the business request. Therefore, it adheres to the required logic.",Finetuned
"Find the total quantity sold for each product, excluding discontinued products.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalQuantitySold 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE products.Discontinued = 0 
GROUP BY products.ProductID, products.ProductName;
""""""

# Execute SQL query and retrieve data into a pandas dataframe
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductID, p.ProductName
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly constructs a SQL query that selects the ProductID, ProductName, and the total Quantity for products that are not discontinued. It joins the 'products' and 'Order Details' tables and groups the results by ProductID and ProductName, which aligns with the logic of the reference implementation. Both implementations achieve the same business objective.","```python
import pandas as pd

# SQL query to find total quantity sold for each product, excluding discontinued products.
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductName
""""""

# Execute the query and get the result in a dataframe.
df = execute_sql_query(sql_query)

# Display the result to the user.
show_to_user(df)
```","The input code groups by 'ProductName' instead of 'ProductID, ProductName' like the reference code. This can lead to issues if there are products with the same name but different IDs.",Base
Determine the average discount applied across all products.,"```python
import pandas as pd

# SQL query to determine the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average discount value from the dataframe
average_discount = result_df['AverageDiscount'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'Average Discount': [average_discount]}))
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
""""""
average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","Both code snippets execute a SQL query to calculate the average discount from the 'Order Details' table. The result is displayed to the user. The primary difference is that the provided code displays the entire resulting dataframe with the average discount, while the reference extracts and creates a new dataframe for display. Despite this difference, the core logic matches and correctly answers the request.","```python
import pandas as pd

# SQL Query to calculate the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL Query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['AverageDiscount'].iloc[0])
```","Both the reference and input implementations execute an SQL query to calculate the average discount and display the result. Although the input code displays the result directly instead of wrapping it in a DataFrame, the core logic and outcome are the same.",both
"How many orders were placed each month in the last year, using a bar chart to show trends over time?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(orders_df, x='Month', y='OrderCount', title='Number of Orders Placed Each Month in the Last Year')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       COUNT(OrderID) AS NumberOfOrders
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY Month
ORDER BY Month;
""""""

orders_data = execute_sql_query(sql_query)

fig = px.bar(orders_data, 
             x='Month', 
             y='NumberOfOrders', 
             title='Number of Orders Placed Each Month in the Last Year',
             labels={'NumberOfOrders': 'Number of Orders', 'Month': 'Month'})

show_to_user(fig)
```","The input code adheres to the same logic as the reference implementation. Both codes execute a SQL query that aggregates orders by month for the past year, then plot the results using Plotly, with only variable naming differences for order count. It correctly displays the number of orders per month via a bar chart.","```python
from datetime import datetime, timedelta
import pandas as pd
import plotly.express as px

# SQL query to get monthly order count for the last year
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, COUNT(*) AS order_count 
FROM orders 
WHERE OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY month;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Convert month to datetime for sorting
df['month'] = pd.to_datetime(df['month'])

# Sort the data for proper plotting
df = df.sort_values('month')

# Create the bar chart
fig = px.bar(df, x='month', y='order_count', title='Monthly Order Count in the Last Year')

# Show the result to the user
show_to_user(fig)
```","The input code correctly retrieves the number of orders placed each month in the last year. It uses a similar SQL query to the reference code, counting orders grouped by month. Both codes format the dates properly for monthly aggregation and use Plotly to create a bar chart. The input code converts the month to a datetime object for sorting, ensuring proper chronological order, which adheres to the purpose and logic of the task.",both
"List the count of products in each category, supplied by supplier.","```python
import pandas as pd

# SQL query to get the count of products in each category, supplied by supplier
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID, s.CompanyName, p.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    s.CompanyName, 
    p.CategoryID, 
    COUNT(p.ProductID) AS ProductCount 
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
GROUP BY 
    s.CompanyName, p.CategoryID
ORDER BY 
    s.CompanyName, p.CategoryID;
""""""

data = execute_sql_query(sql_query)
show_to_user(data)
```","The input code correctly implements the request by counting the number of products in each category supplied by each supplier. The only difference from the reference implementation is the lack of 'SupplierID' in the select and group by clauses, which does not affect the correctness for this specific task. Including 'CompanyName' instead provides the same logical results because the task does not explicitly require grouping by 'SupplierID'. The ORDER BY clause adds sorting but does not affect the correctness of the count operation.","```python
import pandas as pd

query = """"""
SELECT suppliers.CompanyName, products.CategoryID, COUNT(products.ProductID) AS ProductCount 
FROM suppliers 
INNER JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.CompanyName, products.CategoryID;
""""""

df = execute_sql_query(query)
show_to_user(df)
```","The input code produces the same logical output as the reference code. Both codes fetch the count of products in each category by supplier. The input code uses 'CompanyName' in the GROUP BY clause instead of 'SupplierID,' which is a valid alternative if 'CompanyName' is uniquely related to 'SupplierID.' Therefore, for the same dataset, the result will be logically the same.",both
What is the average order fulfillment time for March 2023?,"```python
import pandas as pd

# Define SQL Query to get order dates and shipped dates
sql_query = """"""
SELECT o.ShippedDate, o.OrderDate
FROM orders o
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-03-31';
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Calculate the average fulfillment time
df['ShippedDate'] = pd.to_datetime(df['ShippedDate'])
df['OrderDate'] = pd.to_datetime(df['OrderDate'])
df['FulfillmentTime'] = (df['ShippedDate'] - df['OrderDate']).dt.days
average_fulfillment_time = df['FulfillmentTime'].mean()

# Display result
show_to_user(pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= '2023-03-01' AND OrderDate < '2023-04-01'
""""""

average_fulfillment_time = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time)
```","The input Python code correctly calculates the average order fulfillment time for March 2023. It uses an SQL query to directly calculate the average difference between 'ShippedDate' and 'OrderDate' within the specified date range ('2023-03-01' to '2023-03-31') and accounts for the inclusive date range by using '>= '2023-03-01'' and '< '2023-04-01''. This logic aligns with the reference implementation, which calculates the fulfillment time in Python after retrieving data using SQL. Both methods achieve the same result.","```python
import pandas as pd
from datetime import datetime

# Define the SQL query to get the average order fulfillment time for March 2023
sql_query = """"""
SELECT 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgOrderFulfillmentTime 
FROM orders 
WHERE OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Format the result and show it
result = pd.DataFrame({""AvgOrderFulfillmentTime"": [df['AvgOrderFulfillmentTime'].mean()]})
show_to_user(result)
```","The input code directly calculates the average fulfillment time using SQL's AVG and DATEDIFF functions, which is valid but not equivalent to the reference. The input assumes the SQL execution returns the average directly, which is incorrect as shown in the pandas step with df['AvgOrderFulfillmentTime'].mean(). Also, it should not re-average a single already averaged value.",Base
"Identify the top 3 suppliers based on the total sales value of their products, using a bar chart for visualization.","```python
import plotly.express as px

# SQL query to get the top 3 suppliers by total sales value
sql_query = """"""
SELECT SupplierID, SUM([Order Details].UnitPrice * Quantity) AS TotalSalesValue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY SupplierID 
ORDER BY TotalSalesValue DESC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(df, x='SupplierID', y='TotalSalesValue', title='Top 3 Suppliers by Total Sales Value')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total sales value per supplier
sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalSales DESC
LIMIT 3
""""""

# Execute the SQL query
top_suppliers_df = execute_sql_query(sql_query)

# Create a bar chart for the top 3 suppliers
fig = px.bar(top_suppliers_df, x='SupplierID', y='TotalSales', 
             title='Top 3 Suppliers by Total Sales Value',
             labels={'SupplierID': 'Supplier ID', 'TotalSales': 'Total Sales Value'})

# Show the visualization to the user
show_to_user(fig)
```","The input code includes a discount factor in the calculation of the total sales value (`od.Quantity * od.UnitPrice * (1 - od.Discount)`), whereas the reference implementation does not include this discount in the calculation. This difference means that the input code does not adhere to the same logic as the reference implementation.","```python
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT p.SupplierID, 
       SUM(od.Quantity * od.UnitPrice) AS TotalSalesValue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID 
ORDER BY TotalSalesValue DESC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart for the top 3 suppliers by total sales value
fig = px.bar(df, x='SupplierID', y='TotalSalesValue', labels={'SupplierID': 'Supplier ID', 'TotalSalesValue': 'Total Sales Value'}, title='Top 3 Suppliers by Total Sales Value')

# Show the result to the user
show_to_user(fig)
```","The input code correctly executes an SQL query to fetch the top 3 suppliers by total sales value and uses library functions to visualize the results. It follows the same logic as the reference implementation, albeit with some minor differences in naming conventions and additional label formatting. These differences do not affect the correctness of the solution.",Finetuned
List all products that need reordering.,"```python
import pandas as pd

# SQL Query to find products that need reordering
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the query
df = execute_sql_query(sql_query)

# Display the filtered result to the user; ensure only the 'ProductName' column is shown
show_to_user(df['ProductName'])
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND (UnitsInStock + UnitsOnOrder) < ReorderLevel;
""""""
products_needing_reorder = execute_sql_query(sql_query)
show_to_user(products_needing_reorder)
```","The input code checks if products that are not discontinued and have the sum of UnitsInStock and UnitsOnOrder less than the ReorderLevel should be reordered. The reference code checks only if UnitsInStock is less than or equal to the ReorderLevel for products needing reorder, regardless of their discontinued status. Also, the input returns multiple columns, while the reference implementation only returns 'ProductName'. These differences alter the logic and the criteria for product selection.","```python
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock + UnitsOnOrder < ReorderLevel;""
df = execute_sql_query(sql_query)
show_to_user(df)
```","The input code modifies the condition for reordering by comparing 'UnitsInStock + UnitsOnOrder' with 'ReorderLevel', instead of just 'UnitsInStock'. It also selects 'ProductID' in addition to 'ProductName', and displays the entire DataFrame instead of just the 'ProductName' column. These differences do not adhere to the logic of the reference implementation.",None
"What is the average order fulfillment time by month for 2023, visualized with a line chart to show changes over time?","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY month
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'month' column to datetime
df['month'] = pd.to_datetime(df['month'])

# Create a line chart
fig = px.line(df, x='month', y='avg_fulfillment_time', title='Average Order Fulfillment Time by Month for 2023')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY month
ORDER BY month;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time by Month for 2023',
              labels={'avg_fulfillment_time': 'Average Fulfillment Time (days)', 
                      'month': 'Month'})
show_to_user(fig)
```","Both the input code and the reference code aim to visualize the average order fulfillment time by month for 2023 using a line chart. The key aspects of the SQL query are consistent: they both select month and average fulfillment time, filter by the date range for 2023, and group by month. The input code adds an ORDER BY clause, which does not affect correctness. Both implementations use Plotly Express for visualization, setting 'month' as the x-axis and 'avg_fulfillment_time' as the y-axis. Thus, the input code adheres to the same logic and performs the requested analysis.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get data
query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS order_fulfillment_time 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month
""""""

# Execute query
data = execute_sql_query(query)

# Create line chart
fig = px.line(data, x='month', y='order_fulfillment_time', 
              title='Average Order Fulfillment Time by Month for 2023')

# Show chart
show_to_user(fig)
```","The input code correctly follows the same logic as the reference implementation. It calculates the average order fulfillment time by month for 2023 and visualizes it using a line chart. The SQL query structure, data processing, and plotting aspects match the reference implementation's logic and intent.",both
Which products have less than 10 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query and retrieve the data
products_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
WHERE UnitsInStock < 10;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly identifies products with less than 10 units in stock. Although it includes an additional column ('ProductID') in the query, this difference does not affect the correctness with respect to the business request, which only specifies to retrieve products with less than 10 units in stock. The logic regarding the filtering condition 'UnitsInStock < 10' is consistent with the reference implementation.","```python
import pandas as pd

# SQL query to find products with less than 10 units in stock
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query
products_low_stock_df = execute_sql_query(sql_query)

# Ensure only the ProductName column is displayed
products_low_stock_df = products_low_stock_df[['ProductName']]

# Show results to user
show_to_user(products_low_stock_df)
```","The input Python code only selects the 'ProductName' field from the database. However, the requested task requires retrieving both 'ProductName' and 'UnitsInStock' to identify products with less than 10 units in stock as shown in the reference implementation. Although the input code does filter products correctly, it does not adhere to the same logic in terms of data fields required by the business request.",Base
Which employee processed the most orders?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY TotalOrders DESC 
LIMIT 1;
""""""

# Execute SQL query
order_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(order_data)
```","```python
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The provided code is correct. It uses the same logic as the reference implementation: counting the number of orders processed by each employee, then ordering the count in descending order, and selecting the employee with the highest order count. The SQL query syntax and execution steps closely match those of the reference code.","```python
import pandas as pd

# SQL query to get the employee who processed the most orders
sql_query = """"""
SELECT EmployeeID, COUNT(*) AS NumberOfOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY NumberOfOrders DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input Python code is logically equivalent to the reference implementation. Both codes query the employee who processed the most orders using a SQL query that counts the number of orders handled by each employee and orders the results in descending order, returning the top result. The column names 'TotalOrders' and 'NumberOfOrders' used to label the counts are different but functionally equivalent. Therefore, the input code correctly answers the business analytics request.",both
Identify the customer with the most late shipments.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) AS LateOrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.RequiredDate < o.ShippedDate 
GROUP BY c.CustomerID 
ORDER BY LateOrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS LateShipments
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY c.CustomerID, c.CompanyName
ORDER BY LateShipments DESC
LIMIT 1
""""""

most_late_shipments = execute_sql_query(sql_query)
show_to_user(most_late_shipments)
```","The input code correctly follows the logic of the reference implementation by querying the customer with the most late shipments. Both codes calculate the count of late shipments using a similar logic based on the condition 'ShippedDate > RequiredDate', group the results by CustomerID, and sort in descending order of late shipments to return the top result. The input code includes additional information (CompanyName) in the output, but this does not affect the correctness of the solution concerning the task request.","```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS LateShipments
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY CustomerID
ORDER BY LateShipments DESC
LIMIT 1
""""""

# Execute the SQL query
late_shipments_df = execute_sql_query(sql_query)

# Display the result
show_to_user(late_shipments_df)
```","The input Python code evaluates to find the customer with the most late shipments. It calculates the count of late shipments for each customer by checking where the 'ShippedDate' is later than the 'RequiredDate', groups by 'CustomerID', and orders the results by the count of late shipments in descending order, limiting the result to 1. This logic matches the reference implementation, which uses a similar approach to join orders with customers, filter late shipments, and find the customer with the most late orders.",both
Find the orders placed in the last 30 days and their total freight cost.,"```python
import pandas as pd

# SQL query to find orders in the last 30 days
sql_query = """"""
SELECT o.OrderID, o.OrderDate, o.ShippedDate, o.Freight 
FROM orders o 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 30 DAY);
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate the total freight cost
total_freight_cost = orders_df['Freight'].sum()

# Prepare the result dataframe
result_df = pd.DataFrame({
    'Total Freight Cost': [total_freight_cost]
})

# Show the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta

# Calculate the date 30 days ago from today
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# SQL query to find orders placed in the last 30 days and their total freight cost
sql_query = f""""""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query
result = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result)
```","The input code correctly calculates the total freight cost for orders placed in the last 30 days, similar to the reference implementation. Both solutions construct an SQL query to select order data within 30 days, although the input uses a different function to calculate the date range. The input code computes the total freight cost in the SQL query directly, which is acceptable and aligns logically with the reference code's freight cost summation. Therefore, the input code fulfills the business analytics request correctly.","```python
import pandas as pd

query = ""SELECT OrderID, SUM(Freight) as TotalFreightCost FROM orders WHERE OrderDate >= CURDATE() - INTERVAL 30 DAY GROUP BY OrderID;""
df = execute_sql_query(query)
show_to_user(df)
```","The provided code groups by OrderID and calculates the freight cost for each order separately, rather than computing the total freight cost for all orders as requested. The reference code sums up the freight for all orders placed in the last 30 days to provide a single total, while the input code provides individual totals per order.",Base
Determine the number of discontinued products.,"```python
import pandas as pd

# SQL Query to determine the number of discontinued products
sql_query = ""SELECT COUNT(*) AS DiscontinuedProducts FROM products WHERE Discontinued = 1;""

# Execute the query using the provided utility function
result_df = execute_sql_query(sql_query)

# Extract the count value from the dataframe
discontinued_count = result_df.iloc[0]['DiscontinuedProducts']

# Display the result to the user
show_to_user(discontinued_count)
```","```python
sql_query = ""SELECT COUNT(*) AS DiscontinuedProductCount FROM products WHERE Discontinued = 1""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code correctly constructs a SQL query to count products where 'Discontinued' is 1, aligning with the business request. It uses 'execute_sql_query' to run the query and 'show_to_user' to display the results. Although it does not explicitly extract the count from a DataFrame, the function can directly pass the result, which is logically consistent with the reference implementation.","```python
import pandas as pd

# SQL Query to get the number of discontinued products
sql_query = ""SELECT COUNT(ProductID) AS DiscontinuedProducts FROM products WHERE Discontinued = 1;""

# Execute the SQL query to retrieve the data
discontinued_products_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(discontinued_products_df)
```","The input code directly displays the dataframe to the user instead of extracting the count value. The reference code extracts the count from the dataframe before displaying it. Thus, the input code does not adhere to the same logic as the reference implementation.",Base
What is the average shipping cost per order per month? Include a visualization to show trends over time.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is sorted correctly
df['Month'] = pd.to_datetime(df['Month'])

# Sort the dataframe by the 'Month' column
df = df.sort_values('Month')

# Create a line plot for average shipping cost per month
fig = px.line(df, x='Month', y='AvgShippingCost', title='Average Shipping Cost per Order per Month')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
    SELECT 
        DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
        AVG(Freight) AS AverageShippingCost
    FROM 
        orders
    GROUP BY 
        Month
    ORDER BY 
        Month;
""""""

shipping_costs_df = execute_sql_query(sql_query)

fig = px.line(shipping_costs_df, 
              x='Month', 
              y='AverageShippingCost', 
              title='Average Shipping Cost per Order per Month', 
              labels={'AverageShippingCost': 'Average Shipping Cost', 'Month': 'Month'})
show_to_user(fig)
```","The input code correctly calculates the average shipping cost per order per month, similar to the reference implementation. The SQL query used in the input code aggregates the data by month and calculates the average freight using the 'AVG(Freight)' function, which aligns with the reference implementation logic. Both implementations ensure the data is ordered by 'Month' before creating a line plot. The main differences are that the input code specifies column labels in the plot, which does not affect the correctness of the logic or output. Therefore, the input code is considered correct.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS ShippingCostPerOrder 
FROM orders 
GROUP BY Month;
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Create a plot
fig = px.line(df, x='Month', y='ShippingCostPerOrder', title='Average Shipping Cost per Order per Month')

# Display the visualization
show_to_user(fig)
```","The input code correctly calculates the average shipping cost per order per month using SQL. The column name 'ShippingCostPerOrder' differs from 'AvgShippingCost' in the reference but the calculation and logic remain the same. Both implementations correctly group by month and use AVG(Freight). The plotted result shows trends over time, complying with the business request.",both
Find out how many orders each employee managed in a specific date range. Visualize the employee performance comparison.,"```python
import plotly.express as px

# Define the date range
start_date = '2023-01-01'
end_date = '2023-12-31'

# Create the SQL query
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Employee Order Management Performance')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

start_date = '2023-01-01'
end_date = '2023-12-31'

sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC;
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='OrderCount', y='EmployeeID', 
              labels={'OrderCount': 'Number of Orders', 'EmployeeID': 'Employee'},
              title='Employee Performance Comparison: Number of Orders Managed')
show_to_user(fig)
```","The evaluated code uses a LEFT JOIN, potentially including employees with zero orders, while the reference uses JOIN. This can lead to different results. Additionally, the evaluated code includes 'FirstName' and 'LastName', which are not used in the plot, and orders the results. While these differences do not affect the plotted data, the logic regarding how employees with no orders are handled is different.","```python
import pandas as pd
import plotly.express as px

def employee_orders(date_range):
    # SQL query to fetch order count per employee in the specified date range
    sql_query = f""""""
    SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
    FROM orders 
    WHERE OrderDate BETWEEN '{date_range[0]}' AND '{date_range[1]}' 
    GROUP BY EmployeeID
    """"""
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Create a bar chart to visualize employee performance
    fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Employee Order Management Comparison')
    
    # Display the plot to the user
    show_to_user(fig)

# Example Usage
date_range = ('2023-01-01', '2023-12-31')
employee_orders(date_range)
```","The input code does not include joining the 'employees' table with the 'orders' table as in the reference code, which may lead to incorrect OrderCount if there are missing EmployeeIDs in the 'orders' table. The reference ensures the query includes only employees who have managed orders. Additionally, the input logic assumes 'EmployeeID' exists solely in 'orders', potentially missing employees with zero orders in that range.",None
Which products have been discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query to get the discontinued products
discontinued_products_df = execute_sql_query(sql_query)

# Use the utility function to display the data to the user
show_to_user(discontinued_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName
FROM products
WHERE Discontinued = 1;
""""""

discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code correctly identifies discontinued products by checking where 'Discontinued = 1'. It selects 'ProductID' and 'ProductName', which still fulfills the business request to identify discontinued products. The logic matches the reference implementation, as it retrieves discontinued products from the same table and condition.","```python
import pandas as pd

# SQL query to get products that have been discontinued
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discontinued_products_df)
```",The input Python code correctly implements the business analytics request by executing the same SQL query as in the reference implementation to retrieve products that have been discontinued. It also uses the same logic to display the results to the user.,both
What is the monthly inventory turnover ratio? Use a visualization to highlight changes over time.,"```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATEPART(month, OrderDate) AS Month, 
       SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY DATEPART(month, OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure Month is treated as categorical for correct plotting
df['Month'] = df['Month'].astype(str)

# Sort the dataframe by Month to ensure correct plotting
df = df.sort_values(by='Month')

# Visualize the data
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    SUM(order_details.Quantity * order_details.UnitPrice) AS cogs,
    AVG(products.UnitsInStock) AS avg_inventory
FROM 
    [Order Details] AS order_details
JOIN 
    orders ON order_details.OrderID = orders.OrderID
JOIN 
    products ON order_details.ProductID = products.ProductID
GROUP BY 
    month
""""""

data = execute_sql_query(sql_query)

data['inventory_turnover_ratio'] = data['cogs'] / data['avg_inventory']

fig = px.line(data, x='month', y='inventory_turnover_ratio', title='Monthly Inventory Turnover Ratio', labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio'})
show_to_user(fig)
```","The input Python code correctly calculates the monthly inventory turnover ratio using the same logic as the reference implementation. Both codes aggregate the monthly cost of goods sold (COGS) and average inventory to compute the ratio, then visualize it using a line plot. While the input code uses DATE_FORMAT to format the month and calculates COGS separately before computing the ratio, it still adheres to the business analytics request. Therefore, the logic aligns with the reference implementation.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY month;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Generate the visualization
fig = px.line(df, x='month', y='inventory_turnover_ratio', title='Monthly Inventory Turnover Ratio')

# Show the visualization
show_to_user(fig)
```","The input code calculates the inventory turnover ratio by grouping sales data by month, which aligns with the logic of the reference implementation. The use of `DATE_FORMAT` in the input code to group dates is equivalent to `DATEPART(month, OrderDate)` in terms of dividing data by monthly periods, adapting for potentially different SQL dialects. Both codes then create a line plot to visualize the inventory turnover ratio over time, fulfilling the business request. Despite differences in SQL syntax, the essential logic remains consistent.",both
Which products are associated with the highest total order quantities? Visualize the top products by order quantity.,"```python
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrderedQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalOrderedQuantity DESC;
""""""
data = execute_sql_query(sql_query)

# Visualize the top products by order quantity
fig = px.bar(data, x='ProductName', y='TotalOrderedQuantity', title='Top Products by Order Quantity')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 10
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='TotalQuantity', title='Top Products by Order Quantity', labels={'TotalQuantity': 'Total Order Quantity', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The provided Python code correctly answers the business analytic request by retrieving products and their total order quantities from a database. It uses a SQL query to sum the quantities, groups them by product, and orders the products by total quantities in descending order, similar to the reference implementation. Additionally, it limits the result to the top 10 products, which aligns with the request to visualize top products. The use of Plotly Express to create a bar chart and display it matches the intended visualization, making the code logically equivalent to the reference implementation.","```python
import plotly.express as px

# Define the SQL query to get total order quantities per product
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrderQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalOrderQuantity DESC
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Plot the top products by order quantity
figure = px.bar(df.head(10), x='ProductName', y='TotalOrderQuantity', title='Top Products by Order Quantity')

# Display the plot
show_to_user(figure)
```","The evaluated code correctly follows the logic specified in the business analytics request and the reference implementation. Both codes query for product names and their total ordered quantities using a JOIN between the order details and products tables, ordering the results by total quantities in descending order. Both implementations utilize Plotly Express to create a bar plot, although the evaluated code limits the visualization to the top 10 products, which is still consistent with the business request to show top products. This minor difference does not affect correctness.",both
What are the names of products that are currently discontinued?,"```python
import pandas as pd

# SQL query to find product names that are discontinued
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discontinued_products_df[['ProductName']])
```","```python
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE Discontinued = 1
""""""

discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```",The input code correctly executes a SQL query that retrieves product names where the 'Discontinued' column is set to 1. It then displays the results using the 'show_to_user' function. This logic matches the reference implementation and satisfies the business analytics request.,"```python
import pandas as pd

# SQL query to find discontinued products
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_products = execute_sql_query(sql_query)

# Display the result
show_to_user(discontinued_products)
```","The input code executes the same SQL query as the reference code to select product names where the 'Discontinued' field is set to 1. Both codes execute the query and display the result. The input code may not explicitly select the 'ProductName' column when displaying, but assuming the query results directly correspond to what's shown, the logic aligns with the reference code.",both
What is the total freight cost for all orders made in the year 2022?,"```python
import pandas as pd

# SQL query to get the total freight cost for orders made in 2022
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# As result_df will have a single value DataFrame, extract the value
total_freight_cost = result_df['TotalFreightCost'].iloc[0]

# Display the result to the user
show_to_user(total_freight_cost)
```","```python
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

total_freight_cost_df = execute_sql_query(sql_query)
show_to_user(total_freight_cost_df)
```","The input code does not extract the single value from the DataFrame before calling `show_to_user`. The function is supposed to display a single total value (a number) rather than a DataFrame. The reference implementation extracts the value using `iloc[0]` before displaying it, whereas the input code directly passes the DataFrame `total_freight_cost_df` to `show_to_user`, which is incorrect.","```python
import pandas as pd

# SQL query to execute
sql_query = ""SELECT SUM(Freight) AS TotalFreight FROM orders WHERE YEAR(OrderDate) = 2022;""

# Execute the SQL query
freight_data = execute_sql_query(sql_query)

# Display the result
show_to_user(freight_data)
```","The input code correctly calculates the total freight cost for orders in the year 2022 using SQL. It checks orders with `YEAR(OrderDate) = 2022`, which is logically equivalent to using `BETWEEN '2022-01-01' AND '2022-12-31'` as in the reference implementation. Both methods achieve the same result. The output is appropriately handled and displayed using `show_to_user`.",Finetuned
What is the total sales revenue generated in each month? Include a line chart to show monthly revenue trends.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY month;
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Ensure the month column is treated as a string for proper line chart visualization
df['month'] = df['month'].astype(str)

# Create Line Chart
fig = px.line(df, x='month', y='TotalSales', title='Monthly Sales Revenue Trends')

# Show the result to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

monthly_revenue_df = execute_sql_query(sql_query)

fig = px.line(monthly_revenue_df, x='Month', y='TotalSales', title='Monthly Sales Revenue Trends')
show_to_user(fig)
```","The provided code retrieves the total sales revenue per month, creates a line chart using Plotly Express, and displays it, which matches the logic and intent of the reference implementation. Both codes execute an SQL query to aggregate monthly revenue, convert the month format, and visualize the data as a line chart.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue per month
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Month;
""""""

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Generate the line chart
fig = px.line(monthly_sales_df, x='Month', y='Total_Sales', title='Monthly Sales Revenue Trends')

# Display the line chart
show_to_user(fig)
```","The input Python code correctly matches the logic of the reference implementation. Both codes perform the same SQL query to calculate total sales revenue per month, join the 'orders' and 'Order Details' tables, and sum up the sales. The column naming ('month' vs. 'Month', 'TotalSales' vs. 'Total_Sales') does not affect the correctness. Both codes use Plotly Express to create a line chart of monthly sales revenue trends and then display the chart. Therefore, the input code is correct according to the specified business analytics request.",both
Find the CustomerID and the total number of orders for each customer who has ordered more than 10 times.,"```python
import pandas as pd

# SQL Query to retrieve the data
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS order_count
FROM customers
INNER JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID
HAVING COUNT(orders.OrderID) > 10
""""""

# Execute the SQL query and store the result in a dataframe
customer_orders_df = execute_sql_query(sql_query)

# Display the result
show_to_user(customer_orders_df)
```","```python
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly retrieves CustomerID and the total number of orders for each customer with more than 10 orders. Although it omits joining the 'customers' table, the logic remains valid if 'CustomerID' in 'orders' is unique to the customer, achieving the same result as the reference implementation.","```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) AS NumberOfOrders 
FROM orders o 
GROUP BY o.CustomerID 
HAVING COUNT(o.OrderID) > 10;
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_data)
```","The input code is functionally equivalent to the reference implementation. Both SQL queries calculate the number of orders per customer and filter customers who have more than 10 orders. Although the input code does not explicitly join the 'customers' table, the 'CustomerID' is assumed to be available in the 'orders' table, which still provides the correct data as required by the business analytics request.",both
How many orders were shipped over a week late in August 2023?,"```python
import pandas as pd

# SQL Query to find the number of late orders in August 2023
sql_query = """"""
SELECT COUNT(OrderID) AS LateOrders
FROM orders
WHERE DATEDIFF(ShippedDate, RequiredDate) > 7
AND OrderDate BETWEEN '2023-08-01' AND '2023-08-31';
""""""

# Execute the SQL query and get result in a dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
late_orders_count = df.iloc[0]['LateOrders'] if not df.empty else 0
show_to_user(pd.DataFrame({'Late Orders in August 2023': [late_orders_count]}))
```","```python
sql_query = """"""
SELECT COUNT(*) as LateOrders
FROM orders
WHERE ShippedDate > DATEADD(day, 7, RequiredDate)
AND ShippedDate BETWEEN '2023-08-01' AND '2023-08-31'
""""""

late_orders_df = execute_sql_query(sql_query)
show_to_user(late_orders_df)
```","The input code's logic differs from the reference implementation. The input script checks if the 'ShippedDate' is between '2023-08-01' and '2023-08-31', whereas the correct logic checks 'OrderDate' falls within this range. Additionally, the input script uses 'DATEADD' instead of 'DATEDIFF', which is a different way to calculate the late period but might lead to correct results if implemented correctly. However, the discrepancy in date filtering makes the code incorrect.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT COUNT(*) AS LateOrders 
FROM orders 
WHERE OrderDate BETWEEN '2023-08-01' AND '2023-08-31' 
  AND ShippedDate > RequiredDate + INTERVAL '7 days';
""""""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(late_orders_df)
```","The input code correctly addresses the business analytics request. Both the reference and input codes count orders shipped over a week late in August 2023. The input code uses a different syntax with 'INTERVAL' instead of 'DATEDIFF', but the logic is equivalent with SQL standards. Both check 'OrderDate' within the specified range and ensure 'ShippedDate' is over a week past 'RequiredDate'. Therefore, the input code adheres to the request and reference logic correctly.",Finetuned
Which employee achieved the highest sales in 2022? Use a visualization for employee sales comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch employee sales data for 2022
sql_query = """"""
SELECT o.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY o.EmployeeID
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Get the employee with the highest sales
top_employee = sales_data.iloc[0]

# Visualize the employee sales comparison using a bar chart
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Employee Sales Comparison 2022')

# Display the visualization result
show_to_user(fig)

# Display the top employee with the highest sales
show_to_user(top_employee)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total sales for each employee in 2022
sql_query = """"""
SELECT 
    o.EmployeeID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = 2022
GROUP BY 
    o.EmployeeID
ORDER BY 
    TotalSales DESC
LIMIT 1
""""""

# Execute the SQL query to get the employee with highest sales in 2022
highest_sales_employee = execute_sql_query(sql_query)

# SQL query to get total sales for each employee in 2022 for visualization
sales_comparison_query = """"""
SELECT 
    o.EmployeeID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = 2022
GROUP BY 
    o.EmployeeID
""""""

# Execute the SQL query to get sales comparison data
sales_comparison_data = execute_sql_query(sales_comparison_query)

# Create a bar chart for employee sales comparison
fig = px.bar(sales_comparison_data, x='EmployeeID', y='TotalSales', title='Employee Sales Comparison for 2022')
show_to_user(fig)
```","The input code correctly calculates and visualizes employee sales for 2022. It uses two SQL queries: one to find the employee with the highest sales and another to gather all employee sales data for visualization. This approach logically aligns with the reference code in achieving the same business objective. The use of filtering by year and grouping by EmployeeID, along with displaying the results using a bar chart, mirrors the intent of the reference implementation.","```python
import plotly.express as px

# SQL Queries
employee_sales_query = """"""
SELECT o.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM `orders` o 
JOIN `[Order Details]` od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = 2022 
GROUP BY o.EmployeeID
""""""

# Execute the query
employee_sales_df = execute_sql_query(employee_sales_query)

# Find the employee with the highest sales
highest_sales_df = employee_sales_df.nlargest(1, 'TotalSales')
show_to_user(highest_sales_df)

# Visualization
fig = px.bar(employee_sales_df, x='EmployeeID', y='TotalSales', title='Employee Sales Comparison in 2022')
show_to_user(fig)
```","The input code correctly implements the business request by fetching employee sales data for 2022 and displaying both the highest sales and a visualization for comparison. The logic aligns with the reference implementation: it executes a SQL query to obtain total sales by employee, identifies the employee with the highest sales using nlargest, and visualizes the data with a bar chart. Although there are minor differences in SQL syntax and specific function calls, the overall logic and output are consistent with the reference implementation.",both
What are the top 5 best-selling products? Include a bar chart to show sales figures.,"```python
import plotly.express as px

# SQL query to get top 5 best-selling products
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to show sales figures
fig = px.bar(df, x='ProductName', y='TotalSales', title='Top 5 Best-Selling Products')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='TotalSales', title='Top 5 Best-Selling Products', labels={'TotalSales': 'Sales Figures'})
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It retrieves the top 5 best-selling products by summing the 'Quantity' from the 'Order Details' table and ordering by 'TotalSales' in descending order. The SQL query syntax and logic match the reference implementation. Both codes use Plotly Express to generate a bar chart with 'ProductName' on the x-axis and 'TotalSales' on the y-axis, and both include a title for the chart. Minor differences, such as including labels in the 'px.bar()', do not affect the correctness of the implementation.","```python
import plotly.express as px

# SQL Query to get the top 5 best-selling products
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS SalesCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY SalesCount DESC 
LIMIT 5;
""""""

# Execute the query and get the result as a dataframe
df = execute_sql_query(sql_query)

# Ensure the correct columns are used in the plot
df.columns = ['ProductName', 'SalesCount']

# Create a bar chart to show the sales figures
fig = px.bar(df, x='ProductName', y='SalesCount', title='Top 5 Best-Selling Products')

# Show the chart to the user
show_to_user(fig)
```","The input Python code is correct and adheres to the logic of the reference implementation. Both codes execute an SQL query to fetch the top 5 best-selling products based on the total quantity sold (SUM(od.Quantity)), sort the results in descending order, and limit the output to the top 5 results. Both implementations then use Plotly Express to create a bar chart with the product names on the x-axis and sales count on the y-axis. The only difference is in the naming of a column ('TotalSales' vs 'SalesCount'), but they both represent the same quantity. Thus, the input code satisfies the requirements.",both
Which products have a discount applied in more than 10 orders?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(*) AS OrderCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0.0 
GROUP BY p.ProductName 
HAVING COUNT(*) > 10;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT od.ProductID, COUNT(*) AS OrderCount
FROM [Order Details] od
WHERE od.Discount > 0
GROUP BY od.ProductID
HAVING COUNT(*) > 10
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code does not join the 'products' table to retrieve 'ProductName'. It groups by 'ProductID' instead of 'ProductName', leading to output that won't match the reference which shows product names, not IDs. Both need to count orders with discounts exceeding 10, but comparison fails due to missing join.","```python
import pandas as pd

# SQL query to identify products with a discount applied in more than 10 orders
sql_query = """"""
SELECT ProductID, COUNT(DISTINCT OrderID) AS OrderCount 
FROM [Order Details] 
WHERE Discount > 0 
GROUP BY ProductID 
HAVING COUNT(DISTINCT OrderID) > 10
""""""

# Execute the query using the provided utility function
discounted_products_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discounted_products_df)
```","The input code is counting distinct OrderIDs for each ProductID, whereas the reference code counts the total number of orders per ProductName with a discount greater than 0. Additionally, the input code provides ProductID instead of ProductName as required by the business request.",None
What is the average order value for June 2023?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extracting average order value
avg_order_value = df['avg_order_value'].iloc[0]

# Display the result
show_to_user(avg_order_value)
```","```python
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)
```","The input code executes the SQL query and assigns the result to avg_order_value_df, but it directly passes this DataFrame to show_to_user. This would output the entire DataFrame rather than just the average order value as intended. The reference implementation correctly extracts the value from the DataFrame before displaying it.","```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```",The input code is incorrect because it displays the entire DataFrame 'df' instead of extracting and showing only the 'avg_order_value'. This could result in displaying unnecessary data or the structure of the DataFrame instead of the intended average order value.,None
What is the average value of orders placed in January 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['avg_order_value'].iloc[0])
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
       COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

average_order_value_january_2023 = execute_sql_query(sql_query)
show_to_user(average_order_value_january_2023)
```",The input code does not access 'avg_order_value' correctly from the result of 'execute_sql_query'. It directly passes the result to 'show_to_user' without selecting the correct column or index. The reference implementation specifically accesses 'df['avg_order_value'].iloc[0]' to get the average value.,"```python
import pandas as pd

query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
df = execute_sql_query(query)

# Display the result to the user
show_to_user(df['avg_order_value'].iloc[0])
```","The input Python code is correct as it constructs the SQL query in a way that logically matches the reference implementation. Both scripts calculate the average value of orders placed in January 2023 by joining the 'orders' and 'Order Details' tables and summing the product of UnitPrice, Quantity, and Discount. The only difference is the order of the JOIN and table references but they yield the same result. Thus, it adheres to the same logic and requirements of the business request.",Finetuned
"List the customers along with their total spent amounts, ordered by highest to lowest total spent. Use a bar chart to visualize spending.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY TotalSpent DESC;
""""""

# Execute the query using the provided utility function
dataframe = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(dataframe, x='CustomerID', y='TotalSpent', title='Total Spent by Customer', labels={'TotalSpent': 'Total Spent', 'CustomerID': 'Customer ID'})

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    TotalSpent DESC
""""""

customer_spending = execute_sql_query(sql_query)
fig = px.bar(customer_spending, x='CompanyName', y='TotalSpent', title='Total Spending by Customers', 
              labels={'TotalSpent': 'Total Spent', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The input Python code correctly fulfills the business request by listing customers along with their total spending, ordered from highest to lowest. It also creates a bar chart to visualize the data. Although the input code includes 'CompanyName' alongside 'CustomerID' and uses 'CompanyName' for labeling the x-axis of the chart, this doesn't change the essence of the request nor the correctness since both pieces of information are valid as part of representing customer spending. Thus, it adheres to the same logic as the reference implementation.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSpent 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID, customers.CompanyName 
ORDER BY TotalSpent DESC;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the spending
fig = px.bar(df, x='CompanyName', y='TotalSpent', title='Total Spent by Customers', labels={'TotalSpent': 'Total Spent', 'CompanyName': 'Company Name'})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code uses a similar logic to the reference implementation. It calculates the total spent per customer while including the customer's CompanyName, which is an enhancement but not a deviation from the required logic. Both codes execute an SQL query to compute the total spending and visualize it in a bar chart using Plotly, ordered by descending total spent. Thus, the input code is functionally correct.",both
What is the average order value for Q1 2023?,"```python
import pandas as pd

# SQL query to retrieve necessary data
sql_query = """"""
SELECT
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Extracting the average order value from the dataframe
avg_order_value = df['avg_order_value'][0]

# Display the average order value to the user
show_to_user(avg_order_value)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""
avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)
```","The provided code incorrectly passes the entire dataframe to 'show_to_user', instead of extracting the 'avg_order_value' from it first, similar to the reference implementation where 'avg_order_value' is extracted before being shown.","```python
import pandas as pd

query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

result_df = execute_sql_query(query)
add_to_ui(result_df)
```","The provided code uses 'add_to_ui' to display the result instead of extracting and displaying the actual average order value like the reference using 'show_to_user'. Moreover, it doesn't extract the 'avg_order_value' explicitly from the 'result_df'.",None
List orders where the shipping cost was above average.,"```python
import pandas as pd

# Execute the SQL query to get the average freight value
avg_freight_query = ""SELECT AVG(Freight) AS average_freight FROM orders""
avg_freight_df = execute_sql_query(avg_freight_query)
average_freight = avg_freight_df.iloc[0]['average_freight']

# Query to get orders where the shipping cost is above average
above_avg_orders_query = f""SELECT * FROM orders WHERE Freight > {average_freight}""
above_avg_orders_df = execute_sql_query(above_avg_orders_query)

# Display the result to the user
show_to_user(above_avg_orders_df)
```","```python
# SQL query to get the average shipping cost
avg_freight_query = ""SELECT AVG(Freight) AS avg_freight FROM orders""
avg_freight_df = execute_sql_query(avg_freight_query)
avg_freight = avg_freight_df['avg_freight'].iloc[0]

# SQL query to get orders with shipping cost above average
above_average_orders_query = f""""""
SELECT * FROM orders 
WHERE Freight > {avg_freight}
""""""
above_average_orders_df = execute_sql_query(above_average_orders_query)

show_to_user(above_average_orders_df)
```","The input Python code correctly follows the same logical steps as the reference implementation. Both pieces of code execute a SQL query to calculate the average 'Freight', then use this average to filter and retrieve all orders where the 'Freight' cost is above the average. They finally display this filtered set of orders. Despite minor differences in variable naming and syntax style (e.g., multiline string for the SQL query in the evaluated code), the logic remains consistent with the reference.","```python
import pandas as pd

# Execute SQL query to get orders with above-average shipping costs
df_orders = execute_sql_query(""""""
SELECT * FROM orders WHERE Freight > (SELECT AVG(Freight) FROM orders);
"""""")

# Display the result to the user
show_to_user(df_orders)
```","The input code correctly retrieves orders where the shipping cost is above the average freight. It executes a SQL subquery to calculate the average freight and filters orders with freight greater than this average, which matches the logic of the reference implementation. The use of a single SQL statement achieves the same result without requiring a separate calculation of average freight beforehand.",both
What is the average freight cost for orders shipped to Europe?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(Freight) AS AverageFreightCost 
FROM orders 
WHERE ShipCountry IN ('Austria', 'Belgium', 'Denmark', 'Finland', 'France', 'Germany', 'Greece', 'Ireland', 'Italy', 
'Netherlands', 'Norway', 'Poland', 'Portugal', 'Spain', 'Sweden', 'Switzerland', 'United Kingdom')
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT AVG(Freight) AS AverageFreightCost
FROM orders
WHERE ShipCountry IN ('France', 'Germany', 'Italy', 'Spain', 'United Kingdom', 'Netherlands', 'Belgium', 'Sweden', 'Norway', 'Denmark', 'Finland', 'Austria', 'Switzerland', 'Poland', 'Czech Republic', 'Hungary', 'Portugal', 'Greece', 'Ireland')
""""""
average_freight_cost_df = execute_sql_query(sql_query)
show_to_user(average_freight_cost_df)
```","The input code includes 'Czech Republic' and 'Hungary' in the list of countries, which are not present in the reference implementation. This results in a different set of countries, altering the logic and potential result.","```python
import pandas as pd

sql_query = ""SELECT AVG(Freight) as FreightCost FROM orders WHERE ShipRegion IN ('Europe')""
df = execute_sql_query(sql_query)

show_to_user(df['FreightCost'][0])
```","The input code is incorrect because it checks the 'ShipRegion' being 'Europe', which may not align with the business logic. The reference code checks 'ShipCountry' for specific European countries, ensuring the query targets only the required orders. Also, the input code accesses 'df['FreightCost'][0]' assuming direct indexing, while reference uses the data frame to show the result.",None
What is the average salary of employees by title and visualize the distribution?,"```python
import plotly.express as px

# Execute the SQL query to get the average salary by title
sql_query = ""SELECT Title, AVG(Salary) AS AvgSalary FROM employees GROUP BY Title;""
df = execute_sql_query(sql_query)

# Create and show the visualization of the salary distribution by title
fig = px.bar(df, x='Title', y='AvgSalary', title='Average Salary by Title', labels={'AvgSalary':'Average Salary'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Title, AVG(Salary) AS AverageSalary
FROM employees
GROUP BY Title
""""""

average_salary_df = execute_sql_query(sql_query)

fig = px.bar(average_salary_df, x='Title', y='AverageSalary', title='Average Salary by Title')
show_to_user(fig)
```","The input Python code correctly calculates the average salary by title using a SQL query, then visualizes the distribution using a bar chart. It follows the same logic as the reference implementation, fetching average salaries grouped by title and using Plotly Express for visualization. The variable names slightly differ, but this does not affect the correctness or logic of the code. Thus, the code is correct.","```python
import plotly.express as px

# SQL query to retrieve average salary by title
sql_query = ""SELECT Title, AVG(Salary) AS AvgSalary FROM employees GROUP BY Title""
# Execute the SQL query and get the result as a DataFrame
salary_data = execute_sql_query(sql_query)

# Visualize the distribution of average salaries by title
fig = px.bar(salary_data, x='Title', y='AvgSalary', title='Average Salary by Title')
# Display the visualization to the user
show_to_user(fig)
```","The input Python code correctly executes a SQL query to calculate the average salary by title and visualizes the result using a bar chart, similar to the reference implementation. Key steps including querying the database, creating a DataFrame, and using Plotly Express for bar chart visualization are consistent with the reference logic.",both
Visualize the total number of orders for each product.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(od.OrderID) AS OrderCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(data, x='ProductName', y='OrderCount', title='Total Number of Orders for Each Product')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrders
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrders DESC
""""""

orders_df = execute_sql_query(sql_query)

fig = px.bar(orders_df, x='ProductName', y='TotalOrders', title='Total Number of Orders for Each Product')
show_to_user(fig)
```","The input code calculates `TotalOrders` as `SUM(od.Quantity)`, which sums the quantities for each product rather than counting the number of orders. The reference implementation counts the number of orders using `COUNT(od.OrderID)`. Therefore, the logic does not match the requested task of visualizing the total number of orders for each product.","```python
import pandas as pd
import plotly.express as px

query = """"""
SELECT p.ProductName, COUNT(od.OrderID) AS TotalOrders 
FROM products p 
INNER JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

data = execute_sql_query(query)
fig = px.bar(data, x='ProductName', y='TotalOrders', title='Total Number of Orders for Each Product')
show_to_user(fig)
```","The input code correctly implements the business analytics request and matches the logic of the reference implementation. Both codes execute a SQL query that retrieves the product names and their corresponding order counts, and then visualize the results using a bar chart with Plotly. The naming of the column for order counts ('TotalOrders' vs 'OrderCount') does not affect the correctness as it is consistently used in the plot creation.",Finetuned
List the top 5 products with the highest unit price.,"```python
import pandas as pd

# SQL query to get the top 5 products with the highest unit price
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
    SELECT ProductName, UnitPrice 
    FROM products 
    ORDER BY UnitPrice DESC 
    LIMIT 5
""""""
top_products = execute_sql_query(sql_query)
show_to_user(top_products)
```","The input code correctly follows the logic of the reference implementation. It executes an SQL query to select the top 5 products based on the highest unit price and displays the results, aligning with the business analytics request.","```python
import pandas as pd

query = """"""
SELECT ProductID, ProductName, UnitPrice FROM products
ORDER BY UnitPrice DESC
LIMIT 5;
""""""

top_products_df = execute_sql_query(query)
show_to_user(top_products_df)
```","The input code retrieves the top 5 products with the highest 'UnitPrice' in descending order, similar to the reference code. The only difference is that it also selects 'ProductID', which does not affect the order or number of results and satisfies the business request.",both
Visualize the total freight cost for each shipping company in 2023.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY shippers.CompanyName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar plot of total freight cost for each shipping company
fig = px.bar(df, x='CompanyName', y='total_freight_cost', title='Total Freight Cost by Shipping Company in 2023')

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY shippers.CompanyName
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='CompanyName', y='total_freight_cost', title='Total Freight Cost for Each Shipping Company in 2023', labels={'total_freight_cost': 'Total Freight Cost', 'CompanyName': 'Shipping Company'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It calculates the total freight cost for each shipping company for the year 2023 using a SQL query. The SQL logic, grouping by CompanyName and summing the Freight values, is conceptually identical to the reference implementation. The difference in the date filter—from using '2023-01-01' to '2023-12-31' to using YEAR(orders.OrderDate) = 2023—is logically equivalent. Both codes correctly use Plotly to create a bar plot of the results. Therefore, the input code satisfies the requirements of the request as effectively as the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT o.ShipVia, SUM(o.Freight) AS total_freight_cost 
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY o.ShipVia
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ShipVia', y='total_freight_cost', title='Total Freight Cost for Each Shipping Company in 2023', labels={'ShipVia': 'Shipping Company', 'total_freight_cost': 'Total Freight Cost'})

# Display the result
show_to_user(fig)
```","The input code aggregates data by 'ShipVia' which is an ID, not the company name. It does not perform the necessary JOIN with the 'shippers' table to get the company names like in the reference code. Therefore, it does not provide the required visualization of total freight cost by shipping company name.",Base
What is the percentage of orders that were shipped within 3 days of being placed?,"```python
import pandas as pd

# Define the SQL query to execute
sql_query = """"""
SELECT OrderDate, ShippedDate FROM orders;
""""""

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Calculate the number of orders shipped within 3 days
orders_df['DaysToShip'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days
within_three_days_count = orders_df[orders_df['DaysToShip'] <= 3].shape[0]

# Calculate the total number of orders
total_orders_count = orders_df.shape[0]

# Calculate the percentage
percentage_within_three_days = (within_three_days_count / total_orders_count) * 100

# Prepare the results as a dataframe
result_df = pd.DataFrame({
    ""Percentage of Orders Shipped Within Three Days"": [percentage_within_three_days]
})

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(OrderID) AS total_orders,
    SUM(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 3 THEN 1 ELSE 0 END) AS shipped_within_3_days
FROM 
    orders
""""""

result_df = execute_sql_query(sql_query)
percentage_shipped_within_3_days = (result_df['shipped_within_3_days'].iloc[0] / result_df['total_orders'].iloc[0]) * 100

show_to_user(pd.DataFrame({""Percentage of Orders Shipped Within 3 Days"": [percentage_shipped_within_3_days]}))
```",The input code correctly calculates the percentage of orders shipped within 3 days using SQL. It performs the equivalent logic by counting total orders and those shipped within 3 days using SQL's COUNT and SUM functions. The calculated percentage aligns with the reference logic.,"```python
import pandas as pd

# Query to count orders within 3 days and total orders
query = """"""
SELECT 
    SUM(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 3 THEN 1 ELSE 0 END) AS orders_within_3_days,
    COUNT(*) AS total_orders
FROM 
    orders
""""""

# Execute SQL query
df = execute_sql_query(query)

# Calculate the percentage
df['percentage_within_3_days'] = (df['orders_within_3_days'] / df['total_orders']) * 100

# Show the result to the user
show_to_user(df[['percentage_within_3_days']])
```","Both the input and reference implementations correctly calculate the percentage of orders shipped within 3 days of being placed. The input code utilizes a SQL query to calculate the required values directly, while the reference code does so by processing the data within Python after querying. Importantly, both approaches compute the number of orders shipped within 3 days, the total number of orders, and then the percentage. The logic and outcome are equivalent, even though the methods differ.",both
Which products have been ordered with a discount?,"```python
import pandas as pd

# SQL query to find products ordered with a discount
sql_query = """"""
SELECT DISTINCT p.ProductName 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0;
""""""

# Execute the query
discounted_products_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discounted_products_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, od.Discount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
""""""

discounted_products = execute_sql_query(sql_query)
show_to_user(discounted_products)
```","The input code retrieves all instances of ProductID, ProductName, and Discount for products where a discount is applied, instead of distinct product names as required by the business request and shown in the reference implementation. The input code does not aggregate the results to eliminate duplicates, which is achieved by the DISTINCT keyword in the reference code.","```python
import pandas as pd

query = """"""
SELECT DISTINCT p.ProductID, p.ProductName
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0;
""""""

products_with_discount = execute_sql_query(query)
show_to_user(products_with_discount)
```","The input code is correct because it answers the business analytics request using the same logic as the reference implementation. Both implementations aim to find and display products that were ordered with a discount, using a SQL query to join the 'products' and 'Order Details' tables and filter for discounts greater than 0. While the input code includes 'ProductID' in the select statement, it doesn't affect the correctness as the core logic to identify the products with discounts remains consistent with the request.",Finetuned
What is the total number of orders shipped via each shipping method per month and illustrate the trend?,"```python
import plotly.express as px
import pandas as pd

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, ShipVia, COUNT(OrderID) AS OrdersShipped 
FROM orders 
GROUP BY Month, ShipVia;
""""""

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Pivot the data to have shipping methods in separate columns
pivoted_data = orders_data.pivot(index='Month', columns='ShipVia', values='OrdersShipped').reset_index()

# Create a line plot
fig = px.line(pivoted_data, x='Month', y=pivoted_data.columns[1:], title='Orders Shipped via Each Method per Month',
              labels={'value': 'Orders Shipped', 'variable': 'Shipping Method'}, markers=True)

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS month,
    ShipVia,
    COUNT(OrderID) AS total_orders
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    month, ShipVia
ORDER BY 
    month, ShipVia
""""""

orders_data = execute_sql_query(sql_query)

fig = px.line(orders_data, x='month', y='total_orders', color='ShipVia', 
              title='Total Number of Orders Shipped via Each Shipping Method per Month', 
              labels={'total_orders': 'Total Orders', 'month': 'Month'})
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. Both codes group orders by month and shipping method, and count the number of orders for each. Even though the input code uses the 'ShippedDate' instead of 'OrderDate', it applies a WHERE clause to ensure orders are actually shipped. It also plots the data using Plotly, coloring the lines by the shipping method, which aligns with the intent of the reference code. The business question and trend illustration are accurately addressed by the input code.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total number of orders shipped via each shipping method per month
sql_query = """"""
SELECT strftime('%Y-%m', orders.ShippedDate) AS month, orders.ShipVia, COUNT(orders.OrderID) AS total_orders
FROM orders
GROUP BY month, orders.ShipVia
ORDER BY month, orders.ShipVia;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Ensure column names are correctly interpreted
df.columns = [col.strip() for col in df.columns]

# Create a trend plot
fig = px.line(df, x='month', y='total_orders', color='ShipVia', title='Trend of Orders Shipped via Each Shipping Method')

# Show the plot to the user
show_to_user(fig)
```","Both the reference and input Python code implementations achieve the same goal: they count the total orders shipped via each shipping method per month and display this trend using a line plot. The differences observed, such as using `strftime` vs `DATE_FORMAT` for date formatting, do not affect the outcome since they both yield the desired 'year-month' string. Both codes use `COUNT(OrderID)` and group by month and shipping method, followed by plotting the results using Plotly Express, albeit with slightly different parameters like column names and titles. The result and logic remain consistent.",both
Visualize the total number of products supplied by each supplier.,"```python
import plotly.express as px

# SQL query
sql_query = ""SELECT SupplierID, COUNT(ProductID) AS TotalProducts FROM products GROUP BY SupplierID;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart with plotly
fig = px.bar(df, x='SupplierID', y='TotalProducts', title='Total Products Supplied by Each Supplier')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) AS TotalProducts
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='CompanyName', y='TotalProducts', title='Total Products Supplied by Each Supplier', labels={'TotalProducts': 'Total Products', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly visualizes the total number of products supplied by each supplier using a similar logic to the reference implementation. It uses a JOIN between the 'suppliers' and 'products' tables to count products grouped by 'CompanyName', which corresponds to 'SupplierID' in the reference code. The visualization displays the same information as requested.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT CompanyName, COUNT(*) AS TotalProducts 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY CompanyName;
""""""

# Execute SQL query and get the dataframe
df = execute_sql_query(sql_query)

# Visualize the total number of products supplied by each supplier
fig = px.bar(df, x='CompanyName', y='TotalProducts', title='Total Number of Products Supplied by Each Supplier')
show_to_user(fig)
```","The input code correctly addresses the business analytics request by visualizing the total number of products supplied by each supplier. It uses a JOIN operation to associate products with their suppliers and groups the data by supplier name (CompanyName), which is equivalent to using SupplierID in terms of grouping and counting products. The visualization logic with Plotly is consistent with the reference implementation.",both
Which products need to be reordered?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query
products_to_reorder_df = execute_sql_query(sql_query)

# Display the products that need to be reordered
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND (UnitsInStock + UnitsOnOrder) <= ReorderLevel
""""""

reorder_products_df = execute_sql_query(sql_query)
show_to_user(reorder_products_df)
```","The input code includes additional conditions not present in the reference implementation. It checks for 'Discontinued = 0' and considers 'UnitsOnOrder' in the reorder calculation, whereas the reference considers 'UnitsInStock' to be less than or equal to 'ReorderLevel'. These additional conditions and calculations deviate from the specified logic in the reference code.","```python
import pandas as pd

sql_query = """"""
SELECT ProductID, ProductName FROM products WHERE Discontinued = 0 AND UnitsInStock < ReorderLevel;
""""""
products_to_reorder_df = pd.read_sql_query(sql_query)

show_to_user(products_to_reorder_df)
```","The input code considers only products that are not discontinued (Discontinued = 0), which is not accounted for in the reference code. This introduces a discrepancy between the logic of the input and reference implementations, potentially altering the list of products to reorder.",None
Visualize which products have the highest total sales volume in quantity.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalSalesQuantity DESC;
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Plot
fig = px.bar(data, x='ProductName', y='TotalSalesQuantity', 
             title='Products with Highest Total Sales Volume in Quantity')

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSalesVolume
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalSalesVolume DESC
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSalesVolume', title='Total Sales Volume by Product', labels={'TotalSalesVolume': 'Total Sales Volume', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly implements the business analytics request. It executes a SQL query to retrieve product names and their total sales volume in quantity, joins the 'products' and 'Order Details' tables, groups by product names, and orders the results in descending order based on sales volume. It then visualizes these results using a bar chart with Plotly Express, similar to the reference implementation. The differences in column naming ('TotalSalesVolume' vs. 'TotalSalesQuantity') and plot title do not affect the correctness according to the outlined criteria.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC;
""""""

# Execute SQL query and get the result as a dataframe
df = execute_sql_query(sql_query)

# Create a bar graph of Total Quantity per Product Name
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Total Sales Volume by Product')

# Display the result to the user
show_to_user(fig)
```","The input code correctly implements the requested analytics task. Both the reference and input code calculate the total sales quantity for each product and visualize it using a bar chart. The SQL queries in both codes are equivalent, differing only in the alias used for the sum (TotalSalesQuantity vs TotalQuantity), which does not affect the correctness of the logic. The plotting and display logic are also functionally identical, ensuring that the input code meets the business analytics request.",both
Visualize how many orders were placed and fulfilled in each month of 2023.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       COUNT(orders.OrderID) AS orders_placed, 
       COUNT(CASE WHEN orders.ShippedDate IS NOT NULL THEN 1 END) AS orders_fulfilled 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month 
ORDER BY month
""""""

# Execute the SQL query and retrieve data
df = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(df, x='month', y=['orders_placed', 'orders_fulfilled'], 
             labels={'value': 'Number of Orders', 'variable': 'Order Type'}, 
             title='Orders Placed and Fulfilled in 2023',
             barmode='group')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
    COUNT(OrderID) AS total_orders, 
    SUM(CASE WHEN ShippedDate IS NOT NULL THEN 1 ELSE 0 END) AS fulfilled_orders 
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY 
    month 
ORDER BY 
    month;
""""""

order_data = execute_sql_query(sql_query)

fig = px.line(order_data, x='month', y=['total_orders', 'fulfilled_orders'], 
              labels={'value': 'Number of Orders', 'month': 'Month'},
              title='Orders Placed and Fulfilled per Month in 2023')

show_to_user(fig)
```","The evaluated code uses a line chart instead of a grouped bar chart to visualize the order data, which differs from the reference implementation's use of a bar chart. Additionally, the code uses 'SUM' along with 'CASE WHEN' for counting fulfilled orders, which is logically equivalent to the reference code's 'COUNT(CASE WHEN...END)', but the visualization intent is not adhered to by using a line plot instead of a bar plot.","```python
import pandas as pd

sql_query = """"""
SELECT 
    COUNT(CASE WHEN orders.ShippedDate IS NULL THEN 1 END) AS Num_of_Orders_Placed, 
    COUNT(CASE WHEN orders.ShippedDate IS NOT NULL THEN 1 END) AS Num_of_Orders_Fulfilled,
    MONTH(orders.OrderDate) AS OrderMonth 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY MONTH(orders.OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the dataframe by OrderMonth for correct visualization
df.sort_values(by='OrderMonth', inplace=True)

# Adjust column names for clarity
df.columns = ['Num_of_Orders_Placed', 'Num_of_Orders_Fulfilled', 'OrderMonth']

# Plot the data
plot_data(df, title='Orders Placed and Fulfilled in Each Month of 2023', xlabel='Month', ylabel='Number of Orders', legend=['Placed', 'Fulfilled'])
```","The input code does not correctly visualize the data as requested because it aggregates on 'OrderMonth' using the MONTH() function. This results in labels as 1, 2, 3, etc., instead of 'YYYY-MM' format, which is required for accurate monthly order visualization. The column order is also set incorrectly after the rename operation. Additionally, the alias for 'orders_placed' and 'orders_fulfilled' could be swapped. The plotting function 'plot_data' is assumed but not defined as part of standard libraries.",None
What was the total sales revenue generated in the year 2023?,"```python
import pandas as pd

# SQL query to calculate total sales revenue for the year 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
sales_data_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(sales_data_df)
```
","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input code correctly executes an SQL query to calculate total sales revenue for the year 2023. It joins the [Order Details] and orders tables on OrderID, calculates the revenue using UnitPrice, Quantity, and Discount, and restricts the orders to those within the specified date range. It stores the result in total_sales_df and displays it using show_to_user, aligning with the reference implementation.","```python
import pandas as pd

query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

result_df = execute_sql_query(query)
total_sales = result_df['total_sales'].iloc[0] if not result_df.empty else 0

show_to_user(total_sales)
```","Both implementations use the same SQL query to calculate the total sales revenue for the year 2023. The reference code outputs the entire DataFrame, whereas the input code extracts the total sales as a scalar value and handles the case where the DataFrame might be empty by checking and setting it to 0 if necessary. This additional step in the input code is logically correct and does not deviate from the business requirement.",both
Which supplier supplies the highest number of different products?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SupplierID, COUNT(DISTINCT ProductID) AS ProductCount 
FROM products 
GROUP BY SupplierID 
ORDER BY ProductCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Ensure column names are correct and display the result to the user
result_df.columns = ['SupplierID', 'ProductCount']
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT s.CompanyName, COUNT(DISTINCT p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID
ORDER BY ProductCount DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","Both the reference code and the input code aim to find the supplier with the highest number of different products. The input code uses a JOIN to include the supplier's company name instead of only the SupplierID. This doesn't affect the correctness of identifying the supplier with the most distinct products. Therefore, the core logic remains consistent with the reference implementation, and the result is correct.","```python
import pandas as pd

# SQL query to find the supplier supplying the highest number of different products
sql_query = """"""
SELECT SupplierID, COUNT(DISTINCT ProductID) AS ProductCount
FROM products
GROUP BY SupplierID
ORDER BY ProductCount DESC
LIMIT 1;
""""""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df[['SupplierID', 'ProductCount']])
```","The provided input code correctly implements the business analytics request. It uses the same SQL logic as the reference implementation: selecting SupplierID, counting distinct ProductIDs, and ordering by ProductCount in descending order to determine the supplier with the highest number of different products. The only difference is in how the result is displayed—ensuring only the necessary columns 'SupplierID' and 'ProductCount' are shown—which does not affect the correctness related to fulfilling the analytics request.",both
What is the average shipping cost per order for 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
shipping_cost_df = execute_sql_query(sql_query)

# Ensure that only the average cost is presented
average_cost = shipping_cost_df.iloc[0]['shipping_cost_per_order']

# Convert the average cost to a DataFrame
result_df = pd.DataFrame({'shipping_cost_per_order': [average_cost]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(orders.Freight) AS avg_shipping_cost_per_order 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""
average_shipping_cost_df = execute_sql_query(sql_query)
show_to_user(average_shipping_cost_df)
```","Both the reference and input code calculate the average shipping cost per order for the year 2023 by executing a similar SQL query filtering orders based on the date. The input code directly shows the result of the SQL query, which fulfills the business requirement, even though it lacks additional conversion to a DataFrame. The core logic and outcome remain unchanged.","```python
import pandas as pd

sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31';
""""""

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Extract the average shipping cost and display it
average_shipping_cost = result_df['shipping_cost_per_order'].iloc[0]
show_to_user(pd.DataFrame({'Average Shipping Cost': [average_shipping_cost]}))
```","The input Python code correctly calculates the average shipping cost per order for 2023. It follows the same logic as the reference implementation by using the SQL query to select the average freight cost from the orders table, constrained to the 2023 date range. It extracts the result and presents it similarly, even though the naming convention for the dataframe column differs ('Average Shipping Cost' instead of 'shipping_cost_per_order'). This difference does not impact the correctness of the code, as the key calculations and the conversion to a DataFrame are accurately performed.",both
What is the total value of orders shipped in the first quarter of 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT QUARTER(o.OrderDate) AS OrderQuarter, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = 2023 
GROUP BY OrderQuarter;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Filter for the first quarter and retrieve total value
total_value_q1 = df[df['OrderQuarter'] == 1]['TotalValue'].values[0]

# Prepare the result for display
result = pd.DataFrame({
    'OrderQuarter': [1],
    'TotalValue': [total_value_q1]
})

# Display the result
show_to_user(result)
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.ShippedDate >= '2023-01-01' AND o.ShippedDate < '2023-04-01'
""""""
total_order_value = execute_sql_query(sql_query)
show_to_user(total_order_value)
```","The input code calculates the total value of orders shipped in the first quarter of 2023 by summing up the products of UnitPrice, Quantity, and Discount for orders shipped within the specified date range. This approach aligns with the business request and achieves the same outcome as the reference code. The reference code uses OrderDate, but the business request is satisfied by using ShippedDate, provided it corresponds to the business context. Therefore, the input code is correct for the specific task.","```python
import pandas as pd

# SQL query to retrieve total order value for Q1 2023
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue
FROM [Order Details] od
JOIN orders o ON o.OrderID = od.OrderID
WHERE o.ShippedDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the total value
show_to_user(result_df)
```","The input code checks orders shipped in the first quarter of 2023, but the reference specifies ordered in that quarter. Additionally, the input does not check if the year is 2023 but relies on the shipment date, which might not reflect the order date logic used in the reference code.",Base
What is the Customer Retention Rate for the last 6 months?,"```python
import pandas as pd

# Retrieve customer count for the last 6 months
sql_query_recent = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS customer_count_recent 
FROM orders 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 6 MONTH) AND CURDATE();
""""""
recent_data = execute_sql_query(sql_query_recent)
recent_customers = recent_data['customer_count_recent'].iloc[0]

# Retrieve total customer count for comparison for customer retention
sql_query_previous = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS customer_population_before 
FROM orders 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 12 MONTH) AND DATE_SUB(CURDATE(), INTERVAL 6 MONTH);
""""""
previous_data = execute_sql_query(sql_query_previous)
previous_customers = previous_data['customer_population_before'].iloc[0]

# Calculate Customer Retention Rate
customer_retention_rate = recent_customers / previous_customers if previous_customers != 0 else 0

# Create a DataFrame to display
retention_df = pd.DataFrame({
    'CustomerRetentionRate': [customer_retention_rate]
})

# Use utility function to show the result
show_to_user(retention_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Define start and end dates for the last 6 months
end_date = datetime.now().date()
start_date = end_date - timedelta(days=180)

# SQL query to calculate Customer Retention Rate
sql_query = f""""""
SELECT 
    (COUNT(DISTINCT o1.CustomerID) * 1.0 / NULLIF(COUNT(DISTINCT o2.CustomerID), 0)) AS retention_rate 
FROM 
    orders o1 
LEFT JOIN 
    orders o2 ON o1.CustomerID = o2.CustomerID AND o2.OrderDate < '{start_date}'
WHERE 
    o1.OrderDate BETWEEN '{start_date}' AND '{end_date}'
""""""

# Execute the SQL query and retrieve the results
retention_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(retention_data)
```","The input code does not correctly calculate the customer retention rate based on the reference implementation's logic. It performs a single SQL query using a LEFT JOIN to find customers who ordered in the last 6 months and also existed before, which isn't what retention rate calculation requires. The reference code separately calculates the number of distinct customers in the last 6 months and those 6 months prior to that, then computes the retention rate by dividing the former by the latter. Additionally, the input code incorrectly uses 'NULLIF' which could lead to division issues.","```python
import pandas as pd

# SQL queries to get the number of retained and total customers
query_retained_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS RetainedCustomers
FROM orders
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 6 MONTH) AND CURDATE()
""""""

query_total_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS TotalCustomers
FROM orders
WHERE orders.OrderDate < DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
""""""

# Execute the queries
df_retained = execute_sql_query(query_retained_customers)
df_total = execute_sql_query(query_total_customers)

# Calculate the retention rate
retained_customers = df_retained['RetainedCustomers'].iloc[0]
total_customers = df_total['TotalCustomers'].iloc[0]
customer_retention_rate = (retained_customers / total_customers) * 100 if total_customers != 0 else 0

# Prepare the result as a DataFrame
result_df = pd.DataFrame({
    'Customer Retention Rate (%)': [customer_retention_rate]
})

# Display the result
show_to_user(result_df)
```","The input code calculates the retention rate by dividing the count of customers in the last 6 months by the count of all customers who ordered before 6 months ago. This does not match the reference code's logic, which divides the count of customers in the last 6 months by the count of customers from 6 to 12 months ago. The input code does not properly define the 'total customers' for retention calculation as it considers all previous customers regardless of whether they are from the relevant 6-12 month period.",None
What is the most common job title among the employees?,"```python
import pandas as pd

# SQL query to get the most common job title
sql_query = """"""
SELECT Title, COUNT(*) AS TitleCount
FROM employees
GROUP BY Title
ORDER BY TitleCount DESC
LIMIT 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
job_title_df = execute_sql_query(sql_query)

# Extract the most common job title and display it to the user
most_common_title = job_title_df.iloc[0]['Title']
show_to_user(most_common_title)
```","```python
sql_query = """"""
SELECT Title, COUNT(*) as count
FROM employees
GROUP BY Title
ORDER BY count DESC
LIMIT 1
""""""

most_common_title = execute_sql_query(sql_query)
show_to_user(most_common_title)
```","The input code incorrectly attempts to display the query result. It directly assigns the query result to `most_common_title` and then displays it using `show_to_user()`. However, the query returns a DataFrame, not a single value. It needs to extract the 'Title' from the first row of the result, like in the reference implementation.","```python
import pandas as pd

# SQL query to find the most common job title
sql_query = """"""
SELECT Title, COUNT(*) AS count 
FROM employees 
GROUP BY Title 
ORDER BY count DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input code does execute an SQL query to find the most common job title, but it directly shows the entire result dataframe to the user instead of extracting and showing only the job title. The reference implementation specifically extracts the title from the first row before displaying it, which ensures only the most common job title is shown to the user. The input code does not adhere to this part of the logic.",None
Find the difference in days between the hire date and the birthdate of employees.,"```python
import pandas as pd

# SQL query to get employee data
sql_query = """"""
SELECT EmployeeID, HireDate, BirthDate FROM employees;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the difference in days between hire date and birth date
df['HireDate'] = pd.to_datetime(df['HireDate'])
df['BirthDate'] = pd.to_datetime(df['BirthDate'])
df['DaysDifference'] = (df['HireDate'] - df['BirthDate']).dt.days

# Select necessary columns
result_df = df[['EmployeeID', 'DaysDifference']]

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
from datetime import datetime

sql_query = ""SELECT EmployeeID, BirthDate, HireDate FROM employees""
employees_df = execute_sql_query(sql_query)

employees_df['BirthDate'] = pd.to_datetime(employees_df['BirthDate'])
employees_df['HireDate'] = pd.to_datetime(employees_df['HireDate'])
employees_df['DifferenceInDays'] = (employees_df['HireDate'] - employees_df['BirthDate']).dt.days

show_to_user(employees_df[['EmployeeID', 'DifferenceInDays']])
```",The input code correctly calculates the difference in days between the hire date and birthdate for each employee. It follows the same logic as the reference implementation by converting the dates to datetime objects and computing the difference. The final output correctly selects and displays 'EmployeeID' and 'DifferenceInDays'.,"```python
import pandas as pd

query = """"""
SELECT e.LastName, e.FirstName, 
DATEDIFF(e.HireDate, e.BirthDate) AS DaysBetweenHireAndBirthDate 
FROM employees e;
""""""

df = execute_sql_query(query)
show_to_user(df)
```","The input Python code uses SQL's DATEDIFF function, which returns the difference in days between two dates directly within the SQL query. However, it includes 'LastName' and 'FirstName' from the employees table, which are not part of the business request or the reference code, and doesn't match the logic of calculating this difference in Python using pandas, as demonstrated in the reference implementation. The result dataframe should only contain 'EmployeeID' and 'DaysDifference', not names.",Base
How many products are discontinued?,"```python
import pandas as pd

# SQL query to find the number of discontinued products
sql_query = ""SELECT COUNT(*) AS discontinued_products FROM products WHERE products.Discontinued = 1""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Extract the count of discontinued products
discontinued_products_count = discontinued_products_df.iloc[0]['discontinued_products']

# Display the result
show_to_user(discontinued_products_count)
```","```python
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE Discontinued = 1""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code executes a SQL query to count discontinued products correctly, but it directly passes the result of 'execute_sql_query', which is likely a DataFrame, to 'show_to_user'. It should extract the count from the DataFrame, as shown in the reference code, by accessing the specific column and row containing the count value.","```python
import pandas as pd

query = ""SELECT COUNT(*) AS DiscontinuedCount FROM products WHERE Discontinued = 1;""
result_df = execute_sql_query(query)

show_to_user(result_df['DiscontinuedCount'][0])
```","The input code correctly counts the number of discontinued products using a SQL query similar to the reference implementation. Both codes utilize a SQL query to count rows where the 'Discontinued' column equals 1, and both extract and display the count, although with slight differences in variable names and DataFrame access methods.",Finetuned
List all orders that took more than 10 days to fulfill in 2021.,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT OrderID 
FROM orders 
WHERE YEAR(OrderDate) = 2021 
AND DATEDIFF(ShippedDate, OrderDate) > 10;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT OrderID, OrderDate, ShippedDate,
       DATEDIFF(ShippedDate, OrderDate) AS FulfillmentDays
FROM orders
WHERE YEAR(OrderDate) = 2021 AND DATEDIFF(ShippedDate, OrderDate) > 10;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly captures orders from 2021 where the difference between ShippedDate and OrderDate exceeds 10 days, which aligns with the business request. It includes additional columns (OrderDate, ShippedDate, FulfillmentDays) in the result, but this does not affect the correctness as the main logic of filtering orders is maintained against the reference code.","```python
import pandas as pd

# SQL Query to list all orders that took more than 10 days to fulfill in 2021
sql_query = """"""
SELECT * FROM orders 
WHERE DATEDIFF(ShippedDate, OrderDate) > 10 
AND OrderDate BETWEEN '2021-01-01' AND '2021-12-31';
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the result
show_to_user(orders_df)
```","The input code correctly implements the requested functionality. It selects orders from 2021 where the difference between 'ShippedDate' and 'OrderDate' is greater than 10 days. It uses 'OrderDate BETWEEN' to filter by year rather than 'YEAR(OrderDate)', but this achieves the same result. The logic aligns with the reference code's intent.",both
What was the total sales revenue generated each month in the year 2022? Please include a time series chart to visualize monthly trends.,"```python
import plotly.express as px

# SQL query as provided
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(OrderDate) = 2022 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Convert 'Month' column to a datetime object for sorting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Sort the dataframe by 'Month'
sales_data = sales_data.sort_values(by='Month')

# Create the time series chart
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Sales Revenue for 2022')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    orders.OrderDate >= '2022-01-01' AND orders.OrderDate < '2023-01-01'
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.line(total_sales_df, x='Month', y='Total_Sales', title='Total Sales Revenue Each Month in 2022')
show_to_user(fig)
```",The input code correctly calculates the total sales revenue for each month in 2022 and creates a time series chart to visualize the trends. The logic aligns with the reference implementation by using a SQL query to extract monthly sales data and plotting it using Plotly. Both implementations utilize a similar date format and ordering method and produce an equivalent visualization.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS order_month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY 
    order_month
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure 'order_month' is treated as a datetime object for proper plotting
df['order_month'] = pd.to_datetime(df['order_month'])

# Create time series chart
fig = px.line(df, x='order_month', y='total_sales', title='Total Sales Revenue Per Month in 2022')

# Display the chart
show_to_user(fig)
```","The input Python code accurately implements the logic of the business analytics request. It selects and sums the total sales revenue for each month in 2022, using appropriate SQL statements, and visualizes the data with a time series chart using Plotly. The differences in column naming conventions between the input and reference code do not affect the correctness of the logic or the results.",both
What was the total sales revenue for the month of January 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-01';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales value
total_sales = result_df.iloc[0, 0]

# Display the result
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
""""""

total_sales_january = execute_sql_query(sql_query)
show_to_user(total_sales_january)
```","The input code correctly calculates the total sales revenue for January 2023. It uses a SQL query to sum up the sales by multiplying unit price, quantity, and discount, similar to the reference code. The date range condition in the WHERE clause from '2023-01-01' to '2023-02-01' effectively filters for January 2023, matching the logic of the reference implementation using DATE_FORMAT.","```python
import pandas as pd

query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
total_sales_df = execute_sql_query(query)

# Display the result
show_to_user(total_sales_df.iloc[0]['TotalSales'])
```","Both implementations calculate the total sales revenue for January 2023. The main difference is the method of filtering the date range. The reference code uses DATE_FORMAT to match '2023-01', while the input code uses BETWEEN to specify the start and end dates explicitly. Both methods are logically equivalent in filtering data from January 2023. Therefore, the input code correctly addresses the request.",both
"What is the average order value for orders placed between January 1, 2023, and December 31, 2023?","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and retrieve the data in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Extract the average order value
avg_order_value = result_df['avg_order_value'].iloc[0]

# Display the result to the user
show_to_user(avg_order_value)
```","```python
sql_query = """"""
SELECT
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM
    [Order Details]
JOIN
    orders ON [Order Details].OrderID = orders.OrderID
WHERE
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","The input code uses the `show_to_user` function to display `average_order_value_df`, which contains a DataFrame. However, it should extract and display only the average order value, similar to the reference code, which accesses `avg_order_value` using `iloc[0]` before displaying it. This extraction step is missing in the input code.","```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The input code does not extract the 'avg_order_value' from the 'result_df' as the reference code does. Instead, it directly displays 'result_df', which is a DataFrame. The correct approach is to access the specific value in the DataFrame using 'result_df['avg_order_value'].iloc[0]' before displaying it to the user.",None
Which city has received the highest number of orders?,"```python
import pandas as pd

# SQL query to find the city with the highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) as TotalOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY TotalOrders DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1
""""""
highest_city = execute_sql_query(sql_query)
show_to_user(highest_city)
```","The input code correctly follows the logic of the reference implementation. Both codes use a SQL query to select the city with the highest number of orders, grouping by ShipCity, and ordering by the count of orders in descending order. The column names 'TotalOrders' and 'OrderCount' differ, but this does not affect the logic or outcome. Both use LIMIT 1 to get only the top city, execute the SQL query with execute_sql_query, and display the result using show_to_user.","```python
import pandas as pd

# Execute the SQL query to get the data
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code correctly answers the business request. It finds the city with the highest number of orders by selecting 'ShipCity' and counting the number of orders grouped by 'ShipCity'. It then orders by the count in descending order and limits the result to 1, matching the logic of the reference code.",both
Which product category has the highest total sales in 2023? Use a bar chart to visualize sales by category.,"```python
import plotly.express as px

# SQL query to get total sales by product category in 2023
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName 
ORDER BY total_sales DESC
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CategoryName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY c.CategoryName
ORDER BY total_sales DESC
""""""

result = execute_sql_query(sql_query)

fig = px.bar(result, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')
show_to_user(fig)
```","The input code is correct because it follows the same logic as the reference implementation. It queries the total sales by product category for 2023 using the same SQL logic, including the correct joins and filtering by order date within 2023. The code then generates a bar chart with Plotly showing the sales by category, just as the reference code does.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT categories.CategoryName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName
""""""

# Execute the query and get the dataframe
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')

# Show the figure
show_to_user(fig)
```","The input code aligns with the reference implementation logic. Both solutions execute an SQL query to calculate total sales by product category for the year 2023, use plotly to create a bar chart, and display the chart. The only difference is that the input code does not explicitly order the results by total sales, but this does not affect the correctness of the solution as it still answers the business analytics request.",both
What is the average reorder level across all products?,"```python
sql_query = ""SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products;""
result_df = execute_sql_query(sql_query)
average_reorder_level = result_df['AverageReorderLevel'].iloc[0]
show_to_user(average_reorder_level)
```","```python
sql_query = ""SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products""
average_reorder_level_df = execute_sql_query(sql_query)
show_to_user(average_reorder_level_df)
```","The input code directly passes the entire DataFrame to show_to_user, rather than extracting the value from the DataFrame and passing only the calculated average reorder level to the function. This differs from the reference implementation, which extracts the value with iloc[0] before displaying it.","```python
import pandas as pd

# SQL query to calculate average reorder level
sql_query = ""SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products;""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```",The input code displays the entire DataFrame 'result_df' instead of specifically extracting and displaying the 'AverageReorderLevel' value. The reference implementation extracts the first entry of the 'AverageReorderLevel' column with 'result_df['AverageReorderLevel'].iloc[0]'.,None
What is the total inventory value of products currently in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT SUM(UnitsInStock * UnitPrice) AS TotalInventoryValue FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the total inventory value from the dataframe
total_inventory_value = df.loc[0, 'TotalInventoryValue']

# Prepare a dataframe to display
result_df = pd.DataFrame({'TotalInventoryValue': [total_inventory_value]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products
WHERE Discontinued = 0
""""""
total_inventory_value_df = execute_sql_query(sql_query)
show_to_user(total_inventory_value_df)
```","The input code filters products by 'Discontinued = 0', meaning it only considers non-discontinued products for the inventory value calculation. The reference code does not apply this filter, thus calculating the total inventory value for all products in stock. This difference in logic means the input code does not implement the request in the same way as the reference code.","```python
import pandas as pd

sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS InventoryValue FROM products;
""""""

# Execute the SQL query to retrieve the inventory value
inventory_value_df = execute_sql_query(sql_query)

# Display the retrieved data directly to the user
show_to_user(inventory_value_df['InventoryValue'][0])
```","The input Python code correctly calculates the total inventory value by summing the product of UnitPrice and UnitsInStock from the 'products' table, matching the logic of the reference implementation. Both approaches correctly retrieve and display the total inventory value, despite minor differences in dataframe handling and display methods.",Finetuned
Find the average quantity of products ordered per order.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(Quantity) AS AverageQuantityPerOrder
FROM [Order Details]
GROUP BY OrderID
""""""

average_quantity_per_order = execute_sql_query(sql_query)
show_to_user(average_quantity_per_order)
```","The input code calculates an average of the quantity of products per order by grouping data using `GROUP BY OrderID`. This means it averages quantities for each order separately, but doesn't provide a single average across all orders. The reference code calculates the overall average quantity of products ordered per line item, not per order.","```python
import pandas as pd

# SQL query
sql_query = ""SELECT AVG(Quantity) AS AvgQuantityPerOrder FROM [Order Details];""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df[['AvgQuantityPerOrder']])
```",The input code correctly calculates the average quantity of products ordered per order by using the SQL command `AVG(Quantity)`. The difference in naming `AvgQuantityPerOrder` instead of `AverageQuantity` as the alias does not affect the logic or outcome of the query. Both the input code and the reference perform the same SQL operation to achieve the business analytics request. The result is correctly displayed using `show_to_user`.,Finetuned
What is the percentage of orders shipped within the same country as the customer?,"```python
import pandas as pd

# SQL query to get the number of orders shipped within the same country as the customer
sql_query_same_country = """"""
SELECT COUNT(*) as count_same_country 
FROM orders o 
JOIN customers c ON o.CustomerID = c.CustomerID 
WHERE o.ShipCountry = c.Country;
""""""

# SQL query to get the total number of orders
sql_query_total_orders = """"""
SELECT COUNT(*) as total_orders 
FROM orders;
""""""

# Execute the SQL queries
result_same_country = execute_sql_query(sql_query_same_country)
result_total_orders = execute_sql_query(sql_query_total_orders)

# Calculate the percentage of orders shipped within the same country
percentage_same_country = (result_same_country['count_same_country'][0] / result_total_orders['total_orders'][0]) * 100

# Prepare the result for display
result_df = pd.DataFrame({'percent_same_country': [percentage_same_country]})

# Use the show_to_user function to display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(CASE WHEN c.Country = o.ShipCountry THEN 1 END) AS ShippedSameCountry,
    COUNT(*) AS TotalOrders
FROM 
    customers AS c
JOIN 
    orders AS o ON c.CustomerID = o.CustomerID
""""""

result_df = execute_sql_query(sql_query)

percentage_shipped_same_country = (result_df['ShippedSameCountry'].iloc[0] / result_df['TotalOrders'].iloc[0]) * 100

percentage_df = pd.DataFrame({'Percentage Shipped Same Country': [percentage_shipped_same_country]})
show_to_user(percentage_df)
```",The input Python code correctly computes the percentage of orders shipped within the same country as the customer by using a SQL query that counts orders where the shipping country matches the customer's country. It then calculates the percentage using the counts of these orders and the total orders. This approach is logically consistent with the reference implementation.,"```python
import pandas as pd

# SQL Queries
total_orders_query = ""SELECT COUNT(*) AS total_orders FROM orders;""
domestic_orders_query = """"""
SELECT COUNT(*) AS domestic_orders 
FROM orders 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE orders.ShipCountry = customers.Country;
""""""

# Execute SQL Queries
total_orders_df = execute_sql_query(total_orders_query)
domestic_orders_df = execute_sql_query(domestic_orders_query)

# Calculate the percentage
total_orders = total_orders_df['total_orders'][0]
domestic_orders = domestic_orders_df['domestic_orders'][0]

percentage_domestic_orders = (domestic_orders / total_orders) * 100

# Create a DataFrame for display
result_df = pd.DataFrame({'Percentage of Domestic Orders': [percentage_domestic_orders]})

# Display the result
show_to_user(result_df)
```","Both the provided code and the reference implementation correctly calculate the percentage of orders shipped within the same country as the customer. They both execute SQL queries to obtain the total number of orders and orders shipped domestically, and then compute the percentage. The logic and end goal align with the business analytics request.",both
List all employees who were hired this year.,"```python
from datetime import datetime
import pandas as pd

# Construct the SQL query
current_year = datetime.now().year
sql_query = f""SELECT * FROM employees WHERE YEAR(HireDate) = {current_year};""

# Execute the SQL query and retrieve data
employees_hired_this_year = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_hired_this_year)
```","```python
from datetime import datetime

current_year = datetime.now().year
sql_query = f""""""
SELECT * 
FROM employees 
WHERE YEAR(HireDate) = {current_year}
""""""
employees_this_year = execute_sql_query(sql_query)
show_to_user(employees_this_year)
```",The input code correctly implements the same logic as the reference code. Both codes construct an SQL query to select employees hired in the current year and display the results using the 'execute_sql_query' and 'show_to_user' functions. The SQL query construction and execution are consistent with the reference implementation.,"```python
import pandas as pd
from datetime import datetime

# SQL Query
sql_query = ""SELECT EmployeeID, FirstName, LastName FROM employees WHERE YEAR(HireDate) = YEAR(CURDATE())""

# Execute the query
employees_hired_this_year = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(employees_hired_this_year)
```","The input code correctly lists employees hired this year. It uses the SQL function CURDATE() to get the current date, which is equivalent to getting the current year. It filters based on the year of HireDate, just like the reference implementation. The difference in selected columns (EmployeeID, FirstName, LastName) versus all columns does not affect the correctness as it adheres to the business goal of listing employees hired this year.",both
What is the total revenue generated each year? Visualize the trends with a line graph.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS YearlyRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Year 
ORDER BY Year;
""""""

# Execute the SQL query
dataframe = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(dataframe, x='Year', y='YearlyRevenue', title='Total Revenue Generated Each Year', labels={'YearlyRevenue': 'Revenue'})

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    YEAR(o.OrderDate) AS Year, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    YEAR(o.OrderDate)
ORDER BY 
    Year;
""""""

revenue_data = execute_sql_query(sql_query)
fig = px.line(revenue_data, x='Year', y='TotalRevenue', title='Total Revenue Generated Each Year')
show_to_user(fig)
```","The input code correctly follows the business analytics request. It extracts the year from the OrderDate, calculates total revenue using the same formula to determine YearlyRevenue, groups by the year, and orders by the year. The visualization using plotly.express is consistent with the reference implementation. Although the SQL syntax differences (YEAR vs EXTRACT) and column naming (TotalRevenue vs YearlyRevenue) exist, they do not affect the functionality or logic of the code.","```python
import plotly.express as px

sql_query = """"""
SELECT YEAR(OrderDate) AS year, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_revenue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY YEAR(OrderDate);
""""""

df = execute_sql_query(sql_query)
fig = px.line(df, x='year', y='total_revenue', title='Total Revenue Per Year')
show_to_user(fig)
```","Both implementations address the request to calculate the total revenue per year and visualize it with a line graph. They use similar SQL logic: extracting the year from OrderDate, calculating the total revenue using UnitPrice, Quantity, and Discount, and aggregating results by year. Though there are minor differences in syntax (like `YEAR(OrderDate)` vs. `EXTRACT(YEAR FROM OrderDate)`), these accomplish the same task. The visualization logic also correctly uses Plotly to create a line graph with appropriate labels and titles.",both
Find the total quantity ordered for each product. Use a bar chart for better visualization.,"```python
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, SUM(Quantity) AS total_quantity FROM [Order Details] GROUP BY ProductID;""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='total_quantity', title='Total Quantity Ordered by Product')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.Quantity) AS TotalQuantity
FROM 
    [Order Details] od
GROUP BY 
    od.ProductID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductID', y='TotalQuantity', title='Total Quantity Ordered for Each Product')
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. Both the reference and input codes execute an SQL query to sum the quantity ordered for each product and group by ProductID. They then use Plotly to create a bar chart with ProductID on the x-axis and the total quantity on the y-axis. The differences in variable names and SQL formatting do not affect the correctness, and the core logic is maintained.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantityOrdered 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='ProductName', y='TotalQuantityOrdered', title='Total Quantity Ordered for Each Product')

# Display the chart
show_to_user(fig)
```","The input code differs from the reference in that it uses 'ProductName' instead of 'ProductID' in the GROUP BY clause. The request is to find the total quantity ordered for each product by ProductID as per the reference implementation. Although both the code and reference generate a bar chart, the input code groups and labels by 'ProductName', not 'ProductID', which alters the logic required by the business request.",Base
How many orders have been placed by customers in Germany in the year 2023?,"```python
import pandas as pd

# SQL query to fetch order count
sql_query = """"""
SELECT COUNT(o.OrderID) as OrderCount 
FROM orders o 
JOIN customers c ON o.CustomerID = c.CustomerID 
WHERE c.Country = 'Germany' 
AND o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
order_count_df = execute_sql_query(sql_query)

# Display the result
show_to_user(order_count_df['OrderCount'][0])
```","```python
sql_query = """"""
SELECT COUNT(orders.OrderID) AS total_orders
FROM orders
JOIN customers ON orders.CustomerID = customers.CustomerID
WHERE customers.Country = 'Germany' AND YEAR(orders.OrderDate) = 2023
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```",The input code correctly follows the logic of the reference implementation. It selects the count of orders where the customer is from Germany and the order date is in the year 2023. The use of the YEAR function to filter the date is equivalent to using the BETWEEN clause. The result is correctly fetched and displayed.,"```python
import pandas as pd

# SQL query to retrieve the number of orders placed by customers in Germany in 2023
sql_query = """"""
SELECT COUNT(orders.OrderID) as order_count
FROM orders
JOIN customers ON orders.CustomerID = customers.CustomerID
WHERE customers.Country = 'Germany' 
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Prepare data for display
result_to_display = result_df.rename(columns={""order_count"": ""Number of Orders in Germany in 2023""}).head(1)

# Show the result to user
show_to_user(result_to_display)
```","The input Python code accurately replicates the logic of the reference implementation. Both codes execute an SQL query that counts the orders placed by customers from Germany within the specified date range in 2023. The SQL structure and conditions are consistent. Additionally, both codes execute the query and display the result to the user, with only minor differences in variable naming and presentation, which do not affect the correctness of the logic.",both
Calculate the average age of employees.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT BirthDate FROM employees;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the average age
df['Age'] = (pd.to_datetime('today') - pd.to_datetime(df['BirthDate'])) / pd.Timedelta(days=365.25)
avg_age = df['Age'].mean()

# Display the result to the user
show_to_user(pd.DataFrame({'AvgAge': [avg_age]}))
```","```python
sql_query = ""SELECT AVG(YEAR(CURDATE()) - YEAR(BirthDate)) AS AverageAge FROM employees""
average_age_df = execute_sql_query(sql_query)
show_to_user(average_age_df)
```","The input code calculates the average age via an SQL query using integer subtraction for year differences, which doesn't account for the exact age by considering months and days. The reference code calculates precise ages using the current date and exact birth date comparisons, providing a more accurate result.","```python
import pandas as pd

# SQL query to calculate average age of employees
sql_query = """"""
SELECT AVG(DATEDIFF(CURRENT_DATE, BirthDate) / 365.25) AS AverageAge FROM employees;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the result
average_age = df['AverageAge'].iloc[0]

# Present the result
show_to_user(pd.DataFrame({'AverageAge': [average_age]}))
```","The input code correctly calculates the average age of employees in a different way by using a SQL query. It calculates the age using the DATEDIFF function divided by 365.25 to account for leap years, which aligns with the logic in the reference code. Both approaches achieve the same result of computing the average age and display it to the user.",Finetuned
What is the total discount given on orders placed in 2022?,"```python
import pandas as pd

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract total_discount from the dataframe
total_discount = result_df['total_discount'].iloc[0]

# Show the result to the user
show_to_user(total_discount)
```","```python
sql_query = """"""
SELECT SUM([Order Details].Discount) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

total_discount_df = execute_sql_query(sql_query)
show_to_user(total_discount_df)
```","The input code outputs the entire DataFrame resulting from the SQL query, while the reference code extracts a single value ('total_discount') from the DataFrame and then outputs it. The input code should also extract this single value before displaying it to match the logic of the reference implementation.","```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
""""""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Retrieve the total discount value
total_discount = result_df['TotalDiscount'].iloc[0]

# Show result
show_to_user(pd.DataFrame({'Total Discount': [total_discount]}))
```","The input code correctly calculates the total discount given on orders placed in 2022 by summing the product of UnitPrice, Quantity, and Discount from the 'Order Details' table for orders in the specified date range. It adheres to the logic of extracting the total discount from the resulting dataframe and displaying it, consistent with the reference code.",Finetuned
Which customer region had the highest average order fulfillment time in the past month? Include a heat map for regional comparison.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
WHERE OrderDate >= CURDATE() - INTERVAL 1 MONTH 
GROUP BY ShipRegion 
ORDER BY AvgFulfillmentTime DESC;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a heat map for regional comparison
fig = px.density_heatmap(df, x='ShipRegion', y='AvgFulfillmentTime', 
                         z='AvgFulfillmentTime',
                         color_continuous_scale='Viridis', 
                         title='Average Order Fulfillment Time by Region')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve average order fulfillment time by region for the last month
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
GROUP BY ShipRegion
""""""

# Execute the SQL query 
data = execute_sql_query(sql_query)

# Identify the region with the highest average order fulfillment time
max_region = data[data['AvgFulfillmentTime'] == data['AvgFulfillmentTime'].max()]

# Create a heatmap for regional comparison
fig = px.imshow(data.pivot(index='ShipRegion', columns='AvgFulfillmentTime'), 
                color_continuous_scale='Viridis', 
                labels=dict(x=""Average Fulfillment Time"", y=""Region""),
                title=""Regional Comparison of Average Order Fulfillment Time"")

# Show the heatmap and the region with the highest fulfillment time to the user
show_to_user(fig)
show_to_user(max_region)
```","The input code and reference implementation differ in key areas. The input code incorrectly visualizes the data using a pivot table without aggregating by 'AvgFulfillmentTime,' causing potential errors in visualization. Additionally, 'px.imshow' is not suitable since it requires a square matrix, whereas the reference uses 'px.density_heatmap' for continuous heat maps. The input code fails to sort or select the highest region from the heat map or the query results, as required. Also, 'show_to_user(max_region)' is not present in reference, focusing on heatmap visualization only.","```python
import pandas as pd
import plotly.express as px

# SQL query to get fulfillment time by region
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
GROUP BY ShipRegion;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Find the region with the highest average fulfillment time
max_region = df.loc[df['AvgFulfillmentTime'].idxmax()]

# Create a heat map for regional comparison
fig = px.density_heatmap(df, x='ShipRegion', y='AvgFulfillmentTime', z='AvgFulfillmentTime', color_continuous_scale='Viridis')

# Show the result to the user
show_to_user(max_region)
show_to_user(fig)
```","The input code does not produce the same output as the reference implementation. It calculates the region with the highest average fulfillment time, `max_region`, and outputs this alongside the heat map. The reference code only plots a heat map sorted in descending order of average fulfillment time. The logic of displaying `max_region` separately is not aligned with the request or the reference.",None
What is the average price per unit of all products?,"```python
import pandas as pd

# SQL query to calculate the average price per unit of all products
sql_query = ""SELECT AVG(UnitPrice) AS AveragePrice FROM products;""

# Execute the SQL query and get the result in a dataframe
df = execute_sql_query(sql_query)

# Display the average price to the user
average_price = df.at[0, 'AveragePrice']
show_to_user(pd.DataFrame({'Average Price': [average_price]}))
```","```python
sql_query = """"""
SELECT AVG(UnitPrice) AS AveragePricePerUnit
FROM products
WHERE Discontinued = 0
""""""

average_price_df = execute_sql_query(sql_query)
show_to_user(average_price_df)
```","The evaluated code includes a WHERE clause that filters out discontinued products (`WHERE Discontinued = 0`), which is not present in the reference code. The reference code calculates the average price per unit for all products without any filtering conditions. Therefore, the logic of the input code does not match the reference implementation, as it only considers non-discontinued products.","```python
import pandas as pd

# SQL Query to get average price per unit
sql_query = ""SELECT AVG(UnitPrice) AS AverageUnitPrice FROM products;""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['AverageUnitPrice'][0])
```","The input code correctly calculates the average price per unit of all products using a SQL query similar to the reference implementation. It executes the SQL query, retrieves the result in a dataframe, and then displays the value to the user. The logic and outcome are consistent with the reference implementation, even though the labeling of the column differs ('AverageUnitPrice' vs 'AveragePrice').",Finetuned
Find the average order value for each customer. Use a histogram to visualize the distribution.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT c.CustomerID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) as average_order_value 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute SQL query to get data
df = execute_sql_query(sql_query)

# Create histogram to visualize distribution of average order value
fig = px.histogram(df, x='average_order_value', nbins=30, title=""Distribution of Average Order Value per Customer"")

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID
""""""

customer_spending = execute_sql_query(sql_query)
customer_spending['AverageOrderValue'] = customer_spending['TotalSpent'] / customer_spending.groupby('CustomerID')['TotalSpent'].transform('count')

fig = px.histogram(customer_spending, x='AverageOrderValue', title='Distribution of Average Order Value per Customer')
show_to_user(fig)
```","The input code calculates the 'TotalSpent' for each customer but divides it by the count of 'TotalSpent' for each customer to get 'AverageOrderValue'. This is incorrect because it doesn't average based on orders but rather divides by the count of total spending entries, which is always 1 due to aggregation. The reference implementation correctly calculates the average order value by averaging each order's total cost, which considers multiple orders associated with a customer. Thus, the logic in the input code does not match the reference implementation.","```python
import plotly.express as px

query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(o.OrderID) AS AverageOrderValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

df = execute_sql_query(query)

fig = px.histogram(df, x='AverageOrderValue', title='Histogram of Average Order Value per Customer')
show_to_user(fig)
```","Both implementations calculate the average order value per customer by multiplying unit price, quantity, and applying discounts. The reference uses AVG, while the input code uses SUM divided by COUNT, which effectively achieves the same result under correct data assumptions. The histogram creation and visualization logic are also consistent. Hence, the input code meets the requirements.",Finetuned
What is the on-time delivery rate for the month of April 2023? Visualize the results with a pie chart.,"```python
import plotly.express as px

# The SQL query to get the on-time delivery rate
sql_query = """"""
SELECT COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Extract the on-time delivery rate from the dataframe
on_time_delivery_rate = df.loc[0, 'on_time_delivery_rate']

# Create a pie chart to visualize the on-time delivery rate
data = {'On-Time': on_time_delivery_rate, 'Late': 1 - on_time_delivery_rate}
labels = list(data.keys())
values = list(data.values())

fig = px.pie(names=labels, values=values, title=""On-Time Delivery Rate for April 2023"")

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS on_time,
    COUNT(OrderID) AS total_orders
FROM 
    orders
WHERE 
    OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
""""""

data = execute_sql_query(sql_query)
on_time_delivery_rate = data['on_time'].iloc[0] / data['total_orders'].iloc[0] * 100

labels = ['On-time Delivery', 'Delayed Delivery']
values = [on_time_delivery_rate, 100 - on_time_delivery_rate]

fig = px.pie(values=values, names=labels, title='On-time Delivery Rate for April 2023')
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate for April 2023 by counting the number of on-time orders and dividing it by the total orders, similar to the reference implementation. Although the methods for calculating the on-time orders differ (using a CASE statement instead of PostgreSQL FILTER), the result is equivalent. Both implementations visualize the on-time delivery rate with a pie chart using Plotly, adhering to the business analytics request.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM orders
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
""""""

# Execute SQL query to get data
df = execute_sql_query(sql_query)

# Since the result is a single value, we need to create a DataFrame for visualization
on_time_rate = df.iloc[0]['on_time_delivery_rate']
visual_data = pd.DataFrame({'Status': ['On-time', 'Late'], 'Values': [on_time_rate, 1 - on_time_rate]})

# Create a pie chart
fig = px.pie(visual_data, names='Status', values='Values', title=""On-time Delivery Rate for April 2023"")

# Display the result
show_to_user(fig)
```","The input Python code and the reference code both calculate the on-time delivery rate for April 2023 correctly. The key filtering logic to count orders delivered on time is present in both codes, using different but equivalent SQL approaches. The calculation of on-time rate and its visualization using a pie chart is also consistent across both implementations.",both
What is the on-time delivery rate for each month in 2023? Represent findings using a line chart to observe trends over the months.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE NULL END) * 1.0 / COUNT(*) AS on_time_delivery_rate 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the dataframe by month to ensure correct order in the plot
df['month'] = pd.to_datetime(df['month'], format='%Y-%m')
df = df.sort_values(by='month')

# Create a line chart to represent on-time delivery rate over the months
fig = px.line(df, x='month', y='on_time_delivery_rate', title='On-Time Delivery Rate for Each Month in 2023', labels={'on_time_delivery_rate': 'On-Time Delivery Rate', 'month': 'Month'})

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    COUNT(OrderID) AS total_orders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS on_time_orders
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2023
GROUP BY 
    month
ORDER BY 
    month;
""""""

delivery_data = execute_sql_query(sql_query)

delivery_data['on_time_rate'] = delivery_data['on_time_orders'] / delivery_data['total_orders'] * 100

fig = px.line(delivery_data, x='month', y='on_time_rate', title='On-time Delivery Rate per Month in 2023', labels={'on_time_rate': 'On-time Delivery Rate (%)'})
show_to_user(fig)
```","The input code calculates the on-time delivery rate for each month in 2023 using the logic: dividing the count of on-time orders by the total orders, similar to the reference implementation. Both implementations generate a line chart of on-time delivery rates over the months. The input code also includes an ORDER BY clause to ensure the correct order for visualization, aligning with the sorting step of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get on-time delivery rate for each month in 2023
sql_query = """"""
SELECT 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(*) AS on_time_delivery_rate,
    EXTRACT(MONTH FROM OrderDate) AS month
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY month
""""""

# Execute the SQL query
on_time_delivery_df = execute_sql_query(sql_query)

# Correcting the month column to ensure proper ordering
on_time_delivery_df['month'] = on_time_delivery_df['month'].astype(int)

# Generate line chart for on-time delivery rate
fig = px.line(on_time_delivery_df, x='month', y='on_time_delivery_rate', title='On-Time Delivery Rate for 2023')
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate for each month in 2023, similar to the reference code. Both codes use SQL to retrieve the data where 'ShippedDate' is less than or equal to 'RequiredDate' and group the results by month. The input code extracts the month directly using the 'EXTRACT' method and ensures proper ordering of months by casting them to integers. It uses Plotly Express to generate a line chart, which satisfies the requirement. In summary, although there are differences in SQL and data processing, the core logic and final output of monthly on-time delivery rates are consistent with the reference implementation.",both
Visualize the total number of units on order for each product in 2022 using a bar chart to compare across products.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].UnitsOnOrder) AS units_on_order
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ProductID', y='units_on_order', title='Units on Order for Each Product in 2022', labels={'units_on_order':'Units on Order'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_units_on_order 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, products.ProductName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='total_units_on_order', 
              title='Total Units on Order for Each Product in 2022',
              labels={'total_units_on_order': 'Total Units on Order', 'ProductName': 'Product'})
show_to_user(fig)
```","The input code uses a different column ('Quantity') to calculate 'total_units_on_order' instead of 'UnitsOnOrder' as used in the reference implementation. This changes the logic of the computation, making the codes not logically equivalent.","```python
import plotly.express as px

sql_query = """"""
SELECT products.ProductName, SUM(products.UnitsOnOrder) as TotalUnitsOnOrder 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE YEAR([Order Details].OrderDate) = 2022 
GROUP BY products.ProductName;
""""""

df = execute_sql_query(sql_query)
fig = px.bar(df, x='ProductName', y='TotalUnitsOnOrder', title='Total Units on Order in 2022')
show_to_user(fig)
```","The input code uses 'products.UnitsOnOrder', which is incorrect because 'UnitsOnOrder' should be sourced from '[Order Details]'. Additionally, it selects 'ProductName' instead of 'ProductID'. The date filter in the input code uses 'YEAR(OrderDate) = 2022', which could be inefficient compared to the 'BETWEEN' clause in the reference code that correctly handles date ranges for the entire year.",None
What are the names and prices of products that have less than 20 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""

# Execute the query and retrieve the results in a dataframe
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)
```","```python
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
WHERE UnitsInStock < 20
""""""
results = execute_sql_query(sql_query)
show_to_user(results)
```","The input Python code correctly executes an SQL query that selects products with less than 20 units in stock, retrieving their names and prices. It matches the logic of the reference implementation, as it constructs and executes the same SQL query and displays the results using `show_to_user`.","```python
import pandas as pd

query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""
df = execute_sql_query(query)
show_to_user(df)
```",The input code is correct because it constructs the same SQL query and executes it using the same method as the reference code. It retrieves product names and prices for products with less than 20 units in stock and displays the results similarly.,both
Calculate the total quantity of products sold per product category. Use a pie chart to display the proportion of sales across categories.,"```python
import plotly.express as px

# SQL query to calculate total quantity sold per product category
sql_query = '''
SELECT CategoryID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY CategoryID
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a pie chart
fig = px.pie(df, names='CategoryID', values='TotalQuantity', title='Total Quantity Sold per Product Category')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
""""""

data = execute_sql_query(sql_query)

fig = px.pie(data, names='CategoryID', values='TotalQuantity', title='Total Quantity Sold per Product Category')
show_to_user(fig)
```","The evaluated code correctly calculates the total quantity of products sold per product category and uses a pie chart to display proportions, matching the logic of the reference code. Despite slight differences in SQL syntax and join order, both implementations adhere to the business request.","```python
import pandas as pd
import plotly.express as px

query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalQuantitySold 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.CategoryID;
""""""

data = execute_sql_query(query)
fig = px.pie(data, values='TotalQuantitySold', names='CategoryID', title='Total Quantity of Products Sold per Category')
show_to_user(fig)
```","The input Python code accurately performs the task as described in the business analytics request. It computes the total quantity sold per product category using an SQL query, similar to the reference implementation. The SQL query joins the 'products' and 'Order Details' tables on ProductID and groups the results by CategoryID. It then uses Plotly Express to create a pie chart with the same logic as the reference implementation. The chart displays the total quantity sold per category using 'TotalQuantitySold' as values and 'CategoryID' as names. Therefore, the code is correct.",both
List all orders that were shipped to Germany.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT * FROM orders WHERE ShipCountry = 'Germany';""

# Execute the query and get the data
orders_to_germany_df = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(orders_to_germany_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE ShipCountry = 'Germany'
""""""
orders_shipped_to_germany = execute_sql_query(sql_query)
show_to_user(orders_shipped_to_germany)
```","The input Python code and the reference implementation both execute a SQL query to select all orders where the ShipCountry is set to 'Germany'. They utilize the same logical approach to querying and displaying the data. Differences in string formatting or variable names do not impact the correctness, as the core logic aligns with the business request.","```python
import pandas as pd

query = ""SELECT * FROM orders WHERE ShipCountry = 'Germany';""
orders_df = execute_sql_query(query)
show_to_user(orders_df)
```","The input code and the reference implementation perform exactly the same task. Both form SQL queries to select all records from the 'orders' table where 'ShipCountry' is 'Germany', execute these queries via 'execute_sql_query', and then display the result with 'show_to_user'. The logic matches the business request, which is to list orders shipped to Germany.",both
Who are the top 3 employees based on total sales generated? Use a bar chart to compare their performance.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 employees by total sales
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Top 3 Employees by Total Sales')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
ORDER BY 
    TotalSales DESC
LIMIT 3;
""""""

top_employees = execute_sql_query(sql_query)

fig = px.bar(top_employees, x='EmployeeName', y='TotalSales', title='Top 3 Employees Based on Total Sales', labels={'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The code correctly answers the business analytics request by identifying the top 3 employees based on total sales. The SQL query is slightly extended to include employee names, which makes the chart more informative, but does not alter the logical requirement of the task. The bar chart visualization effectively compares their performance by showing 'EmployeeName' instead of 'EmployeeID'. Both implementations align in function and purpose.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3
""""""

# Execute the query and retrieve data into a dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 employees based on total sales
fig = px.bar(df, 
             x=['FirstName', 'LastName'], 
             y='TotalSales',
             title='Top 3 Employees by Total Sales',
             labels={'x': 'Employee', 'TotalSales': 'Total Sales'})

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly implements the business analytics request by identifying the top 3 employees based on total sales. It follows the same logic as the reference code, calculating the total sales using SQL and visualizing the results with a bar chart. The differences, such as including the employee's first and last names, do not affect the correctness of the analysis or the visualization goal.",both
What are the total sales for each product? Visualize with a bar chart for easy comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName;
""""""

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Visualize the results with a bar chart
fig = px.bar(df, x='ProductName', y='TotalSales', title='Total Sales per Product')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.bar(total_sales_df, x='ProductName', y='TotalSales', title='Total Sales for Each Product')
show_to_user(fig)
```","The input Python code is correct as it matches the logic of the reference implementation. Both implementations perform the same SQL query to calculate total sales per product by joining the 'Order Details' and 'products' tables, grouping by product name, and summing the sales calculated as 'UnitPrice * Quantity * (1 - Discount)'. Finally, both codes create a bar chart using Plotly Express to visualize total sales per product, and both use 'show_to_user' to display the visualization. Differences in variable names do not affect functionality or logic.","```python
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

df = execute_sql_query(sql_query)
fig = px.bar(df, x='ProductName', y='TotalSales', title='Total Sales for Each Product')
show_to_user(fig)
```","The provided code does not account for the discount when calculating total sales. The reference implementation includes a calculation of total sales as 'UnitPrice * Quantity * (1 - Discount)', which considers product discounts in the total sales amount. The evaluated code only multiplies 'Quantity' and 'UnitPrice', ignoring any discounts, thus not adhering to the same business logic.",Base
List the orders that have not been shipped within the required date.,"```python
import pandas as pd

# Define the SQL query to get the orders that have not been shipped within the required date
sql_query = """"""
SELECT orders.OrderID, orders.RequiredDate, orders.ShippedDate
FROM orders
WHERE orders.ShippedDate IS NULL OR orders.ShippedDate > orders.RequiredDate;
""""""

# Execute the query and get the result in a pandas DataFrame
orders_df = execute_sql_query(sql_query)

# Use the show_to_user function to display the result
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE ShippedDate IS NULL AND RequiredDate < CURRENT_DATE
""""""
unshipped_orders = execute_sql_query(sql_query)
show_to_user(unshipped_orders)
```","The input code only checks for orders with a NULL ShippedDate and a RequiredDate that is past the current date. The reference code also considers orders where ShippedDate is greater than RequiredDate, which is not checked in the input code.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT * FROM orders WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)
```","The input code does not handle the case where the ShippedDate is NULL, which should also be considered as not shipped within the required date. The reference code includes the condition 'orders.ShippedDate IS NULL' to address this, whereas the input code only checks if ShippedDate is greater than RequiredDate.",None
How many products have been discontinued?,"```python
import pandas as pd

# SQL query to count discontinued products
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE products.Discontinued = 1""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df.iloc[0])
```","```python
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE Discontinued = 1""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input Python code and the reference implementation both execute a SQL query to count the number of discontinued products from the 'products' table where 'Discontinued' equals 1. The logic used to query, execute, and display the result is the same in both implementations, ensuring correctness.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE Discontinued = 1""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The provided code does not properly format the output for display. The reference code uses 'df.iloc[0]' to show the first element, which is the discontinued count. The input code shows the entire DataFrame, which will not match the expected output format.",Base
What are the total units ordered for each supplier? Show with a bar chart to highlight key suppliers.,"```python
import plotly.express as px

# SQL query as per the business request
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered for Each Supplier')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='SupplierID', y='TotalUnitsOrdered', 
             title='Total Units Ordered by Supplier',
             labels={'SupplierID': 'Supplier ID', 'TotalUnitsOrdered': 'Total Units Ordered'})

show_to_user(fig)
```","The input Python code correctly calculates the total units ordered for each supplier by joining the 'products' and 'Order Details' tables, which aligns with the reference implementation logic. The SQL query, although structured slightly differently, effectively achieves the same result by grouping by 'SupplierID' and summing the 'Quantity'. The resultant data is then visualized using a Plotly bar chart, which conforms to the request.","```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT products.SupplierID, SUM([Order Details].Quantity) AS TotalUnitsOrdered 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.SupplierID;
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered by Supplier', labels={'TotalUnitsOrdered': 'Total Units Ordered', 'SupplierID': 'Supplier ID'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates the total units ordered for each supplier and creates a bar chart. Although it uses a different SQL query structure, the logic aligns with the reference implementation by joining 'products' with '[Order Details]' and grouping by 'SupplierID'. The chart creation using Plotly and the display command are also consistent with the reference.",both
Identify the orders that were placed but never shipped in 2022.,"```python
import pandas as pd

# SQL query to find orders placed but never shipped in 2022
sql_query = """"""
SELECT OrderID FROM orders WHERE ShippedDate IS NULL AND YEAR(OrderDate) = 2022
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT OrderID, OrderDate, RequiredDate, ShipName, ShipAddress, ShipCity, ShipRegion, ShipPostalCode, ShipCountry
FROM orders
WHERE ShippedDate IS NULL
AND OrderDate >= '2022-01-01' 
AND OrderDate < '2023-01-01'
""""""
orders_not_shipped = execute_sql_query(sql_query)
show_to_user(orders_not_shipped)
```","The input code correctly identifies orders that were placed in 2022 and have not been shipped. Both the input and reference implementations ensure the ShippedDate is NULL and filter orders by the date range of 2022. The input code includes additional columns in the SELECT clause, but the primary logic aligns with the reference query.","```python
import pandas as pd

query = """"""
SELECT OrderID FROM orders 
WHERE ShippedDate IS NULL AND YEAR(OrderDate) = 2022;
""""""

orders_df = execute_sql_query(query)
show_to_user(orders_df)
```","The input code correctly replicates the logic of the reference implementation. It selects orders from the 'orders' table where 'ShippedDate' is NULL and 'OrderDate' is in 2022. The SQL query structure and conditions match exactly, meeting the business analytics requirement.",both
What is the total revenue generated by each customer? Visualize using a bar chart to identify key customers.,"```python
import plotly.express as px

# SQL query to get total revenue by customer
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the query to get the data
revenue_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(revenue_df, x='CustomerID', y='TotalRevenue', title='Total Revenue by Customer')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    TotalRevenue DESC
""""""

revenue_data = execute_sql_query(sql_query)
fig = px.bar(revenue_data, x='CompanyName', y='TotalRevenue', title='Total Revenue by Customer', labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The input code provides the same functionality as the reference code with minor differences. It calculates the total revenue generated by each customer using a SQL query and visualizes the data with a bar chart using Plotly. The addition of 'CompanyName' in the query and chart provides more context, which does not alter the overall task requirement. The primary aggregation and visualization logic remains consistent with the reference implementation.","```python
import plotly.express as px

# SQL Query to get total revenue by customer
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID;
""""""

# Execute query and get data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CustomerID', y='TotalRevenue', title='Total Revenue by Customer')

# Show the result to the user
show_to_user(fig)
```","The input Python code is correct as it follows the same logic as the reference implementation. Both codes perform the same SQL query to calculate the total revenue for each customer, join the same tables, and group by CustomerID. They also use Plotly to create a bar chart for visualization.",both
What is the total sales revenue generated in the month of January 2023?,"```python
import pandas as pd

# SQL query to get the total sales revenue for January 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the total sales only
total_sales = result_df['TotalSales'].iloc[0]
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
""""""

total_sales_january = execute_sql_query(sql_query)
show_to_user(total_sales_january)
```","The input code correctly calculates the total sales revenue for January 2023 by joining the orders and order details tables, calculating the sales with discounts applied, and filtering the order dates to include all of January 2023. The logic matches the reference implementation, even though it uses a slightly different date filtering method by going up to '2023-02-01' instead of ending on '2023-01-31'. This approach is equivalent and inclusive of all January dates.","```python
import pandas as pd

# Calculate total sales for January 2023
sales_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    [Order Details] 
JOIN 
    orders 
ON 
    [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
sales_data = execute_sql_query(sales_query)

# Display the result
show_to_user(sales_data)
```","The input code correctly calculates the total sales revenue generated in January 2023. Both codes perform a SQL query that sums up the sales, considering unit prices, quantities, and discounts from the 'Order Details' after joining with the 'orders' based on OrderID. The date range filter is also correctly applied. The output is presented from the query result, which adheres to the same logic as the reference implementation.",both
What is the total quantity of each product sold? Use a bar chart to compare quantities sold per product.,"```python
import plotly.express as px

# SQL query to get the total quantity of each product sold
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure column names are correctly referenced
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity Sold per Product')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='TotalQuantity', title='Total Quantity Sold per Product')
show_to_user(fig)
```","The input code correctly answers the business analytics request by calculating the total quantity sold for each product and visualizing these quantities using a bar chart. It retrieves the product name in addition to the product ID, which provides clearer labels for the bar chart. This does not alter the correctness, as it adheres to the same logic as the reference code, grouping by product ID and summing quantities sold per product.","```python
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) as TotalSold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

df = execute_sql_query(sql_query)
fig = px.bar(df, x='ProductName', y='TotalSold', title='Total Quantity of Each Product Sold')
show_to_user(fig)
```","The input code correctly executes a SQL query to sum the quantities of products sold, grouped by product name. The reference code groups by ProductID, while the input code uses ProductName, which yields equivalent results in contexts where each ProductID corresponds uniquely to a ProductName. Both implementations use Plotly Express to create bar charts comparing the total quantities sold. The logic and outcome align with the business request.",both
What are the top 5 customers by order value? Represent using a bar chart to see the top contributors.,"```python
import plotly.express as px

# SQL Query
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalOrderValue 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5;
'''

# Execute SQL Query
df = execute_sql_query(sql_query)

# Create Bar Chart
fig = px.bar(df, x='CustomerID', y='TotalOrderValue', title='Top 5 Customers by Order Value')

# Display to User
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    OrderValue DESC
LIMIT 5;
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, 
              x='CompanyName', 
              y='OrderValue', 
              title='Top 5 Customers by Order Value', 
              labels={'OrderValue': 'Order Value', 'CompanyName': 'Company'})
show_to_user(fig)
```","The input Python code fulfills the business analytics request and follows the same logical steps as the reference code. Both implementations execute a SQL query to retrieve data for the top 5 customers by order value, using similar calculations for the order value. The input code additionally retrieves 'CompanyName' for better bar chart labeling, but this does not change the correctness of the logic. Both scripts use Plotly for bar chart visualization and display the chart. Therefore, the input code is considered correct.","```python
import pandas as pd
import plotly.express as px

query = """"""
SELECT o.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5
""""""

top_customers_df = execute_data_query(query)
fig = px.bar(top_customers_df, x='CustomerID', y='TotalOrderValue', title='Top 5 Customers by Order Value')
show_to_user(fig)
```","The provided code accomplishes the same task as the reference implementation by calculating the total order value for each customer and selecting the top 5 customers. It uses an SQL query that joins orders with order details, calculates the total order value similarly, and groups by CustomerID. The results are sorted in descending order of total order value and limited to the top 5. The resultant DataFrame is used to create a bar chart with Plotly Express, which is then displayed. Despite differences in variable names and minor structural changes, the logic aligns with the reference code.",both
How many products are in each category? Use a pie chart to show distribution across categories.,"```python
import plotly.express as px

# Execute the SQL query to get the data
sql_query = ""SELECT CategoryID, COUNT(ProductID) AS ProductCount FROM products GROUP BY CategoryID;""
df = execute_sql_query(sql_query)

# Create a pie chart to show distribution across categories
fig = px.pie(df, names='CategoryID', values='ProductCount', title='Product Distribution Across Categories')

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS ProductCount
FROM products
GROUP BY CategoryID
""""""

category_counts = execute_sql_query(sql_query)

fig = px.pie(category_counts, names='CategoryID', values='ProductCount', title='Product Distribution Across Categories')
show_to_user(fig)
```","The input code correctly executes a SQL query to count the number of products in each category, groups them by CategoryID, and uses Plotly Express to create a pie chart showing the distribution. The code matches the logic and output requirements of the reference implementation, using the same SQL query, data processing, and visualization steps.","```python
import plotly.express as px

# SQL query to get count of products in each category
sql_query = """"""
SELECT c.CategoryID, COUNT(p.ProductID) AS ProductCount 
FROM products p 
JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryID;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Create a pie chart
fig = px.pie(df, names='CategoryID', values='ProductCount', title='Product Distribution Across Categories')

# Show the result
show_to_user(fig)
```","The input code correctly answers the business analytics request by counting the number of products in each category and displaying it as a pie chart. It uses a different SQL query that includes a JOIN with the 'categories' table. However, this does not affect the correctness since both queries produce the same result: a count of products per category. The visualization logic is also aligned with the reference implementation.",both
Identify the employees who report to each manager.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    Manager.LastName AS ManagerLastName, 
    Manager.FirstName AS ManagerFirstName, 
    Subordinate.LastName AS EmployeeLastName, 
    Subordinate.FirstName AS EmployeeFirstName 
FROM employees AS Subordinate 
JOIN employees AS Manager 
ON Subordinate.ReportsTo = Manager.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    e1.EmployeeID AS ManagerID,
    CONCAT(e1.FirstName, ' ', e1.LastName) AS ManagerName,
    e2.EmployeeID AS EmployeeID,
    CONCAT(e2.FirstName, ' ', e2.LastName) AS EmployeeName
FROM 
    employees e1
LEFT JOIN 
    employees e2 ON e1.EmployeeID = e2.ReportsTo
ORDER BY 
    e1.EmployeeID;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code uses a LEFT JOIN instead of an inner JOIN. This means it will include managers without subordinates, which is not consistent with the reference implementation. The reference logic only includes entries where employees report to a manager (inner JOIN). Additionally, the input includes 'EmployeeID' fields, which aren't specified as necessary in the request.","```python
import pandas as pd

# SQL query to get employees reporting to each manager
sql_query = """"""
SELECT 
    e1.FirstName AS EmployeeFirstName, 
    e1.LastName AS EmployeeLastName, 
    e2.FirstName AS ManagerFirstName, 
    e2.LastName AS ManagerLastName 
FROM employees e1 
JOIN employees e2 ON e1.ReportsTo = e2.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","Both the input and reference Python code execute a SQL query to identify the employees who report to each manager by joining the employees table on the 'ReportsTo' and 'EmployeeID' fields. The difference lies in the aliasing and ordering of selected columns, but the logic and objective of finding the reporting structure are maintained.",Finetuned
Which employee generated the most sales in the last year? Use a bar chart for clearer comparison.,"```python
import plotly.express as px

# SQL query to get total sales for each employee for the last year
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC LIMIT 1;
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to display the sales comparison
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Total Sales by Employee for the Last Year')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

last_year = pd.to_datetime(""now"") - pd.DateOffset(years=1)
sql_query = f""""""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '{last_year.strftime(""%Y-%m-%d"")}'
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)
fig = px.bar(sales_data, x='EmployeeName', y='TotalSales', 
             title='Employee Sales in the Last Year', 
             labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee'},
             text='TotalSales')
show_to_user(fig)
```","The input code calculates sales for the last 365 days, not necessarily for the previous calendar year, which may differ from the reference logic. The input code also includes names in the output, while the reference focuses solely on EmployeeID.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales for each employee in the last year
sql_query = """"""
SELECT e.EmployeeID, e.LastName, e.FirstName,
  SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE()
GROUP BY e.EmployeeID;
""""""

# Execute query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart for clearer comparison
fig = px.bar(df, x='EmployeeID', y='TotalSales', text='TotalSales', barmode='group',
             hover_data=['LastName', 'FirstName'], title='Total Sales by Employee in the Last Year')

# Show the visualization to the user
show_to_user(fig)
```","The input code does not correctly identify the employee with the highest total sales. It retrieves sales data for all employees over the past year without ordering or limiting the results to the employee with the maximum sales. The logic in the reference code orders and limits the data to get the top employee, which is missing in the input code.",None
Which products need to be reordered soon?,"```python
import pandas as pd

# SQL Query to retrieve products that need to be reordered
sql_query = """"""
SELECT ProductName
FROM products
WHERE UnitsInStock <= ReorderLevel;
""""""

# Execute the SQL query
reorder_products_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(reorder_products_df)
```","```python
import pandas as pd

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    p.UnitsInStock, 
    p.ReorderLevel 
FROM 
    products p 
WHERE 
    p.UnitsInStock <= p.ReorderLevel AND 
    p.Discontinued = 0
""""""

reorder_products = execute_sql_query(sql_query)
show_to_user(reorder_products)
```","The input code includes an additional condition (`p.Discontinued = 0`) which is not present in the reference implementation. This means that the input code filters out discontinued products, potentially yielding a different result from the reference implementation, which checks only for `UnitsInStock <= ReorderLevel`.","```python
import pandas as pd

# SQL query to get products that need to be reordered soon
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE Discontinued = 0 
AND UnitsInStock + UnitsOnOrder <= ReorderLevel;
""""""

# Execute the SQL query using the provided util function
products_to_reorder = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(products_to_reorder)
```","The input code adds checks for 'Discontinued = 0' and considers 'UnitsOnOrder' in the condition with 'UnitsInStock + UnitsOnOrder <= ReorderLevel', which differs from the reference logic. The reference implementation only checks 'UnitsInStock <= ReorderLevel' to determine reorders without the discontinued status or 'UnitsOnOrder' consideration.",None
How many orders did each employee handle in the first quarter of this year? Use a bar chart for easy comparison.,"```python
import plotly.express as px

# SQL query
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID;
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Orders Handled by Each Employee in Q1 2023', labels={'EmployeeID':'Employee ID', 'OrderCount':'Order Count'})

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count the number of orders handled by each employee in Q1 of this year
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get the data
order_data = execute_sql_query(sql_query)

# Create a bar chart for the number of orders handled by each employee
fig = px.bar(order_data, x='EmployeeName', y='OrderCount', title='Number of Orders Handled by Each Employee (Q1 2023)', 
             labels={'OrderCount': 'Number of Orders', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input Python code correctly implements the logic to count the orders each employee handled in Q1. The difference between the input and reference implementations is the inclusion of the employee's name in the input code, which enhances the data presentation but does not affect the correctness of the outcome. The use of 'LEFT JOIN' instead of 'JOIN' ensures employees with zero orders are also displayed, complying with the requirement to show all relevant employees. The date range is equivalent, and the bar chart correctly visualizes the data. Therefore, the provided code adheres to the same logical requirements as the reference implementation.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT o.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM orders o
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY o.EmployeeID;
""""""

# Execute SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Each Employee in Q1 2023')

# Show the bar chart
show_to_user(fig)
```","The input code correctly answers the business analytics request by counting the number of orders each employee handled in the first quarter of 2023. While the SQL query differs slightly by not joining with the employees table, the logic remains the same as long as each order is uniquely associated with an employee in the orders table. The bar chart is created using Plotly, similar to the reference code, and the result is displayed properly.",both
"What is the total sales for each product category this year, and can it be visualized using a bar chart?","```python
import plotly.express as px

# SQL Query provided
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY categories.CategoryName
""""""

# Execute SQL query to get the data
sales_data_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(sales_data_df, x='CategoryName', y='TotalSales', title='Total Sales for Each Product Category This Year')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    YEAR(o.OrderDate) = YEAR(CURDATE())
GROUP BY 
    p.CategoryID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Total Sales for Each Product Category This Year')
show_to_user(fig)
```","The input code aggregates sales by CategoryID instead of CategoryName, whereas the reference implementation uses CategoryName, which is more descriptive for visualization. Additionally, the input code does not join with the 'categories' table to retrieve CategoryName.","```python
import pandas as pd
import plotly.express as px

df = execute_query(""""""
SELECT categories.CategoryName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
INNER JOIN categories ON p.CategoryID = categories.CategoryID 
WHERE od.OrderID IN (SELECT OrderID FROM orders WHERE YEAR(OrderDate) = YEAR(CURDATE())) 
GROUP BY categories.CategoryName
"""""")

fig = px.bar(df, x='CategoryName', y='TotalSales', title='Total Sales by Product Category This Year')
show_to_user(fig)
```","The input Python code adheres to the logic of the reference implementation despite minor variations. It correctly computes the total sales for each product category for the current year by joining the necessary tables and applying a filter on the order date. The SQL query calculates the total sales accurately using the same logic as the reference code, and the data is visualized using a plotly bar chart, fulfilling the business request.",Finetuned
Find the total freight cost for all orders shipped via each shipping method in 2022 and illustrate it with a pie chart.,"```python
import plotly.express as px

# Execute the SQL query to get the data
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2022 
GROUP BY ShipVia;
""""""
data = execute_sql_query(sql_query)

# Create a pie chart of the total freight cost by shipping method
fig = px.pie(data_frame=data, names='ShipVia', values='TotalFreight', title='Total Freight Cost by Shipping Method (2022)')

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
WHERE YEAR(OrderDate) = 2022
GROUP BY ShipVia
""""""

freight_data = execute_sql_query(sql_query)

fig = px.pie(freight_data, names='ShipVia', values='TotalFreight', title='Total Freight Cost by Shipping Method in 2022')
show_to_user(fig)
```","The input Python code correctly executes the same SQL query as the reference implementation to retrieve the total freight costs for each shipping method in 2022. Both codes then use Plotly to create a pie chart with the same parameters, showing the distribution by 'ShipVia' and 'TotalFreight'. The differences in the variable names and some formatting do not affect the logic or correctness of the code.","```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2022 
GROUP BY ShipVia;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a pie chart using plotly
fig = px.pie(data, values='TotalFreight', names='ShipVia', title='Total Freight Cost by Shipping Method in 2022')

# Display the pie chart
show_to_user(fig)
```","The input Python code accurately replicates the logic of the reference implementation. It correctly executes the SQL query to aggregate total freight costs by shipping method for orders placed in 2022, and uses Plotly Express to create a pie chart with the same labels and values. Both implementations query the same data, create the chart, and display it to the user. Differences in title wording do not affect functionality.",both
What are the five cities with the highest total sales and present them in a ranked bar chart?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCity, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipCity 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not df.empty:
    # Create a ranked bar chart using plotly
    fig = px.bar(df, x='ShipCity', y='TotalSales', 
                 title=""Top 5 Cities by Total Sales"", 
                 labels={'ShipCity': 'City', 'TotalSales': 'Total Sales'})
    
    # Show the figure using the provided utility function
    show_to_user(fig)
else:
    show_to_user(""No data available to display."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.City, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.City
ORDER BY TotalSales DESC
LIMIT 5
""""""

top_cities_sales = execute_sql_query(sql_query)

fig = px.bar(top_cities_sales, x='City', y='TotalSales', title='Top 5 Cities by Total Sales', labels={'TotalSales': 'Total Sales', 'City': 'City'})
show_to_user(fig)
```","The reference code calculates total sales by 'ShipCity', while the input code calculates by employees' 'City'. The logic differs in terms of grouping the sales data, leading to different outputs.","```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT ShipCity, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ShipCity
ORDER BY TotalSales DESC
LIMIT 5;
""""""

# Execute query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ShipCity', y='TotalSales', title='Top 5 Cities by Total Sales', labels={'TotalSales': 'Total Sales', 'ShipCity': 'City'})

# Display the chart
show_to_user(fig)
```","The input Python code performs the same operations as the reference code. It retrieves the top five cities with the highest total sales by executing an equivalent SQL query on the orders and order details tables, correctly summing up the sales amounts while considering discounts. It then generates and displays a ranked bar chart using Plotly. Minor differences such as the order of dictionary entries in the labels do not impact the final output or its correctness in fulfilling the request.",Finetuned
Calculate the total number of units ordered for each product category and visualize it with a histogram.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT c.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
INNER JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryID;
""""""

# Execute SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart of total units ordered for each product category
fig = px.bar(df, x='CategoryID', y='TotalUnitsOrdered', title='Total Units Ordered per Product Category')

# Display the plotly figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
""""""

data = execute_sql_query(sql_query)

fig = px.histogram(data, x='CategoryID', y='TotalUnitsOrdered', 
                   title='Total Units Ordered by Product Category',
                   labels={'TotalUnitsOrdered': 'Total Units Ordered', 'CategoryID': 'Product Category'},
                   text_auto=True)

show_to_user(fig)
```","The input code does not join the 'categories' table, which means it does not ensure categories are being correctly aggregated. The usage of 'px.histogram' instead of 'px.bar' is also a deviation from the requested histogram visualization, which is more accurately represented by 'px.bar'. The reference uses 'c.CategoryID', while the input uses 'p.CategoryID' without joining to ensure that each product category's total units are effectively calculated. Thus, it does not fully adhere to the logic of the reference code.","```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.CategoryID;
""""""

# Execute SQL Query
data = execute_sql_query(sql_query)

# Create a histogram
fig = create_histogram(data, x='CategoryID', y='TotalUnitsOrdered', title='Total Units Ordered by Category')

# Show the result
show_to_user(fig)
```","Both the reference and provided implementations correctly calculate the total number of units ordered for each product category using an SQL query. The main difference is the order of the JOIN operation, which does not affect the result. Also, the provided code creates and displays a histogram using different plotting functions, but still achieves the intended visualization. Thus, it adheres to the same logic as the reference implementation.",Finetuned
"What is the monthly trend of order placements for the current year, and how can a line chart be used to represent it?","```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT MONTH(OrderDate) AS Month, COUNT(*) AS NumberOfOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY MONTH(OrderDate);
""""""

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Sort the DataFrame by Month to ensure the line chart is ordered correctly
orders_df = orders_df.sort_values(by='Month')

# Create line chart using plotly
fig = px.line(orders_df, x='Month', y='NumberOfOrders', title='Monthly Trend of Order Placements')

# Display plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly order counts for the current year
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
WHERE 
    YEAR(OrderDate) = YEAR(CURDATE())
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
monthly_orders_df = execute_sql_query(sql_query)

# Create a line chart to visualize the trend of order placements
fig = px.line(monthly_orders_df, x='Month', y='OrderCount', 
              title='Monthly Trend of Order Placements for Current Year', 
              labels={'Month': 'Month', 'OrderCount': 'Number of Orders'})

# Show the plot to the user
show_to_user(fig)
```","The input code correctly addresses the business requirement of displaying the monthly trend of order placements for the current year. It uses a SQL query to fetch the data, counting orders by month for the current year, and then uses Plotly to create a line chart. It groups by and orders results by month, ensuring correct chronological order. The approach is logically equivalent to the reference implementation because both versions use SQL to aggregate the data by month, create a line plot with Plotly, and display it. The differences in label specification and SQL date formatting do not affect the correctness of the trend analysis and visualization.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the monthly trend of orders for the current year
sql_query = """"""
SELECT strftime('%Y-%m', OrderDate) AS order_month, COUNT(OrderID) AS order_count 
FROM orders 
WHERE strftime('%Y', OrderDate) = strftime('%Y', 'now') 
GROUP BY order_month 
ORDER BY order_month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a line chart using plotly
fig = px.line(df, x='order_month', y='order_count', title='Monthly Trend of Order Placements')

# Display the chart to the user
show_to_user(fig)
```","The provided code achieves the same goal as the reference code. It queries the monthly number of orders for the current year, sorts the results, and visualizes them using a line chart in Plotly. Although the SQL syntax differs due to the use of SQLite functions like strftime, it logically mirrors the reference implementation. Both codes group the orders by month for the current year and order the results appropriately for the chart.",both
How long has each employee been working at the company?,"```python
import pandas as pd

# SQL query to get the employee duration
sql_query = ""SELECT employees.EmployeeID, DATEDIFF(CURDATE(), employees.HireDate) AS DaysWorked FROM employees;""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
import pandas as pd
from datetime import datetime

sql_query = """"""
SELECT EmployeeID, FirstName, LastName, HireDate
FROM employees
""""""

employees_df = execute_sql_query(sql_query)

current_date = datetime.now().date()
employees_df['Tenure'] = (current_date - pd.to_datetime(employees_df['HireDate'])).dt.days

show_to_user(employees_df[['EmployeeID', 'FirstName', 'LastName', 'Tenure']])
```","The input code correctly calculates the duration each employee has worked at the company by subtracting the 'HireDate' from the current date to obtain the 'Tenure' in days. Although it retrieves additional columns (FirstName, LastName), it adheres to the primary logic of the reference implementation by calculating the number of days worked ('DaysWorked' in the reference code, 'Tenure' in the input code). The additional columns do not affect the correctness related to the task's core requirement.","```python
import pandas as pd
from datetime import datetime

# Define the SQL query
sql_query = """"""
SELECT EmployeeID, DATEDIFF(CURDATE(), HireDate) AS TenureInDays FROM employees;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Assuming the user wishes to see the dataframe
show_to_user(df)
```","The provided code and the reference code implement the same logic. Both execute an SQL query that calculates the difference in days between the current date and the employees' hire dates, effectively determining how long each employee has been with the company. The result is then stored in a DataFrame and shown to the user. The variable names and SQL query text differ slightly but do not alter the logic or functionality.",both
Which products need reordering?,"```python
import pandas as pd

# SQL query to identify products that need reordering
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query and retrieve the data
products_to_reorder_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel, UnitsOnOrder
FROM products
WHERE Discontinued = 0 AND (UnitsInStock + UnitsOnOrder) <= ReorderLevel
""""""
products_needing_reorder = execute_sql_query(sql_query)
show_to_user(products_needing_reorder)
```","The provided code filters products based on whether they are not discontinued and checks if the sum of UnitsInStock and UnitsOnOrder is less than or equal to the ReorderLevel. The reference code only checks if UnitsInStock is less than or equal to ReorderLevel without considering Discontinued status or UnitsOnOrder. Thus, the logic differs from the reference implementation.","```python
import pandas as pd

# SQL query to select products that need reordering
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock + UnitsOnOrder < ReorderLevel AND Discontinued = 0""

# Execute the query
products_to_reorder = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(products_to_reorder)
```","The input code evaluates products needing reorder based on 'UnitsInStock + UnitsOnOrder < ReorderLevel' and excludes discontinued products, while the reference checks 'UnitsInStock <= ReorderLevel' without considering 'UnitsOnOrder' or the 'Discontinued' status. The logic differs from the reference implementation.",None
How many products have a reorder level higher than 20?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT * FROM products WHERE ReorderLevel > 20;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Count the number of rows (products) with ReorderLevel > 20
high_reorder_products_count = result_df.shape[0]

# Create a DataFrame to hold the count
count_df = pd.DataFrame({'HighReorderProducts': [high_reorder_products_count]})

# Display the result using the provided utility function
show_to_user(count_df)
```","```python
sql_query = ""SELECT COUNT(*) AS ProductCount FROM products WHERE ReorderLevel > 20""
result = execute_sql_query(sql_query)
show_to_user(result)
```",The input code correctly counts the number of products with a reorder level higher than 20 by using a SQL query with COUNT(*). It then displays the result using the same utility function as the reference implementation. The logic matches the reference as it produces the count of rows where ReorderLevel > 20.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) as count FROM products WHERE ReorderLevel > 20;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['count'][0])
```","The provided input code correctly addresses the business analytics request by executing an SQL query to count the number of products with a reorder level greater than 20. This aligns with the reference implementation logic, although the counting operation is performed directly in the SQL query instead of using DataFrame operations. Both methods achieve the same result.",both
Find the customers who have not placed any orders in the current year.,"```python
import pandas as pd

# Define the SQL queries
query_customers = ""SELECT CustomerID FROM customers;""
query_orders_current_year = ""SELECT DISTINCT CustomerID FROM orders WHERE OrderDate >= DATE_FORMAT(NOW(), '%Y-01-01');""

# Execute the SQL queries
customers_df = execute_sql_query(query_customers)
orders_df = execute_sql_query(query_orders_current_year)

# Find customers who have not placed any orders in the current year
inactive_customers_df = customers_df[~customers_df['CustomerID'].isin(orders_df['CustomerID'])]

# Show result to the user
show_to_user(inactive_customers_df)
```","```python
import pandas as pd

current_year = pd.to_datetime(""now"").year

sql_query = f""""""
SELECT DISTINCT CustomerID
FROM orders
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID
    FROM orders
    WHERE YEAR(OrderDate) = {current_year}
)
""""""

no_orders_customers = execute_sql_query(sql_query)
show_to_user(no_orders_customers)
```","The input code successfully identifies customers who have not placed any orders in the current year. It uses a subquery to find customers who have placed orders in the current year and selects those who are not in this list. This is logically equivalent to the reference implementation, which uses the `isin` method to filter out customers present in the orders. Both approaches achieve the same goal using different methods.","```python
import pandas as pd

query = """"""
SELECT customers.CustomerID 
FROM customers 
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.CustomerID IS NULL OR orders.OrderDate < '2023-01-01'
""""""

df = execute_sql_query(query)

show_to_user(df)
```","The input code attempts to find customers who have not placed any orders in the current year by checking if the orders.CustomerID is NULL or if the order date is before '2023-01-01'. This approach fails if a customer has orders before the current year and none in the current year, as they would still be included in the result (despite having ordered in the past). The reference code correctly extracts order data for the current year and compares it against all customers, ensuring that only customers with no orders in the current year are listed.",Base
Identify the top 5 customers who have incurred the highest total freight costs and display in a ranked list.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CustomerID, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY CustomerID 
ORDER BY TotalFreight DESC 
LIMIT 5;
""""""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Ensure the result is sorted and ranked properly
df = df.sort_values(by='TotalFreight', ascending=False).reset_index(drop=True)

# Display the ranked list of top 5 customers by total freight costs
show_to_user(df)
```","```python
sql_query = """"""
SELECT CustomerID, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY CustomerID
ORDER BY TotalFreight DESC
LIMIT 5;
""""""

top_customers = execute_sql_query(sql_query)
show_to_user(top_customers)
```","The input code performs the same logic as the reference implementation: it computes the total freight for each customer, orders the results in descending order, and limits the result to the top 5 customers. The sorting and ranking logic is handled within the SQL query, making the additional sorting step in the reference implementation redundant. Therefore, the input code is correct.","```python
import pandas as pd

sql_query = """"""
SELECT CustomerID, SUM(Freight) as TotalFreight 
FROM orders 
GROUP BY CustomerID 
ORDER BY TotalFreight DESC 
LIMIT 5;
""""""

data = execute_sql_query(sql_query)
show_to_user(data)
```","The input Python code executes an SQL query that selects the top 5 customers by total freight costs, ordered by 'TotalFreight' in descending order and limits the results to 5. This logic matches the reference implementation. Although the input code doesn't sort and reset the index explicitly in Python, it's unnecessary since the SQL `ORDER BY` and `LIMIT` already ensure the data is sorted and limited correctly before being shown to the user.",both
"How many units of each product were sold in the first quarter of 2023, and can this be shown in a grouped bar chart?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
    SELECT products.ProductID, SUM([Order Details].Quantity) AS units_sold 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
    GROUP BY products.ProductID
""""""

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Create a grouped bar chart using plotly
fig = px.bar(df, x='ProductID', y='units_sold', title='Units Sold Per Product in Q1 2023', barmode='group')

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ProductName', y='total_quantity', title='Units Sold per Product in Q1 2023',
              labels={'total_quantity': 'Total Units Sold', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly answers the business analytics request by calculating the total quantity sold for each product in the first quarter of 2023, just like the reference code. It also creates a grouped bar chart, adhering to the required logic. The differences, such as including 'ProductName' in the query and showing it on the chart's x-axis, do not affect the correctness as the primary goal is achieved, which is showing the units sold per product in Q1 2023 in a bar chart.","```python
import pandas as pd
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS UnitsSold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY products.ProductID;
""""""

# Execute the SQL query and get the result in a pandas dataframe
results_df = execute_sql_query(sql_query)

# Create a bar chart using plotly express
fig = px.bar(results_df, x='ProductID', y='UnitsSold', title='Units Sold per Product in Q1 2023')

# Display the result to user
show_to_user(fig)
```",The input code accurately executes a SQL query to retrieve the sum of quantities sold for each product in the first quarter of 2023. It then generates a bar chart using Plotly Express. The logic and query are consistent with the reference implementation. The use of 'UnitsSold' instead of 'units_sold' is a minor naming difference and does not affect the functionality. Both implementations meet the business analytics request.,both
"How many orders were shipped via each shipping method in 2023, and illustrate it with a bar chart?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
    SELECT ShipVia, COUNT(OrderID) AS OrderCount
    FROM orders
    WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
    GROUP BY ShipVia
""""""

# Execute the SQL query and retrieve data as a pandas dataframe
order_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(order_data, x='ShipVia', y='OrderCount', title='Orders Shipped Via Each Method in 2023')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrdersShipped
FROM orders
WHERE YEAR(ShippedDate) = 2023
GROUP BY ShipVia
ORDER BY ShipVia;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ShipVia', y='OrdersShipped', 
             title='Number of Orders Shipped via Each Shipping Method in 2023',
             labels={'ShipVia': 'Shipping Method', 'OrdersShipped': 'Number of Orders'},
             text='OrdersShipped')

show_to_user(fig)
```","The evaluated code uses 'YEAR(ShippedDate) = 2023' to filter the data, while the reference code uses 'OrderDate BETWEEN 2023-01-01 AND 2023-12-31'. This could lead to different results if 'OrderDate' and 'ShippedDate' are not the same or if orders are placed in 2023 but shipped in a different year. Additionally, the evaluated code includes 'ORDER BY ShipVia', which is not present in the reference code but does not affect the correctness.","```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS order_count 
FROM orders 
WHERE YEAR(ShippedDate) = 2023 
GROUP BY ShipVia
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='ShipVia', y='order_count', title='Orders Shipped via Each Shipping Method in 2023')

# Show the plot
show_to_user(fig)
```",The input code uses 'YEAR(ShippedDate) = 2023' which filters based on 'ShippedDate' not 'OrderDate' as in the reference code. This can yield different results if the order and shipping dates differ.,None
How many orders were placed each month in the current year and visualize with a line chart?,"```python
import plotly.express as px

# SQL query to get the number of orders placed each month in the current year
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY OrderMonth 
ORDER BY OrderMonth;
""""""

# Execute the query and retrieve the data as a pandas dataframe
orders_data = execute_sql_query(sql_query)

# Create a line chart using plotly
fig = px.line(orders_data, x='OrderMonth', y='TotalOrders', title='Monthly Orders in Current Year', labels={'OrderMonth': 'Month', 'TotalOrders': 'Number of Orders'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_year = datetime.now().year
sql_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS TotalOrders 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = {current_year}
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

order_counts = execute_sql_query(sql_query)

fig = px.line(order_counts, x='Month', y='TotalOrders', title='Monthly Order Counts for {current_year}', labels={'TotalOrders': 'Number of Orders', 'Month': 'Month'}, markers=True)
show_to_user(fig)
```","The provided code correctly implements the business analytics request. It constructs an SQL query that retrieves the number of orders placed each month in the current year, similar to the reference implementation. Both codes use the `DATE_FORMAT` function to group the orders by month and count the total orders. The visualization is handled by Plotly to create a line chart, and the use of `markers=True` is an additional style choice that doesn't affect correctness. The use of the current year is dynamic in both implementations, ensuring they reflect the current year automatically.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, COUNT(*) AS order_count 
FROM orders 
WHERE OrderDate BETWEEN CURDATE() - INTERVAL 1 YEAR AND CURDATE() 
GROUP BY month;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Create a line chart
fig = px.line(df, x='month', y='order_count', title='Monthly Orders')

# Display the result
dashboard_display(fig)
```","The input code's SQL query uses a date range that covers the last 12 months, not the current year alone. It should use 'YEAR(OrderDate) = YEAR(CURDATE())' to match the reference. Additionally, 'dashboard_display' is used instead of 'show_to_user', which is minor but worth noting.",Base
Which product had the highest average discount and illustrate it with a bar chart?,"```python
import plotly.express as px

# SQL query to get the product with the highest average discount
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AvgDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY AvgDiscount DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not df.empty:
    # Create a bar chart to illustrate the product with the highest average discount
    fig = px.bar(df, x=""ProductID"", y=""AvgDiscount"", title=""Product with the Highest Average Discount"")

    # Show the result to the user
    show_to_user(fig)
else:
    print(""No data returned from the query."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, AVG(od.Discount) AS AvgDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY AvgDiscount DESC
LIMIT 1
""""""

highest_discount_product = execute_sql_query(sql_query)
highest_discount_product_id = highest_discount_product['ProductID'].iloc[0]

sql_query_details = f""""""
SELECT od.ProductID, AVG(od.Discount) AS AvgDiscount
FROM [Order Details] od
WHERE od.ProductID = {highest_discount_product_id}
GROUP BY od.ProductID
""""""

avg_discount_data = execute_sql_query(sql_query_details)

fig = px.bar(avg_discount_data, x='ProductID', y='AvgDiscount', title='Product with Highest Average Discount')
show_to_user(fig)
```","The input Python code correctly executes a SQL query to find the product with the highest average discount using `AVG(Discount)`, similar to the reference implementation. It then visualizes the result with a bar chart using Plotly Express. The extra SQL query filtering by `ProductID` doesn't alter the outcome as it still provides the necessary data for plotting. Despite some differences in implementation, the logic and result align with the reference code's requirement to illustrate the product with the highest average discount.","```python
import plotly.express as px

# SQL query to get the highest average discount by product
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AverageDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY AverageDiscount DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the result
fig = px.bar(df, x='ProductID', y='AverageDiscount', title='Product with Highest Average Discount')

# Display the chart
show_to_user(fig)
```","Both implementations correctly query the database to find the product with the highest average discount and create a bar chart using Plotly to illustrate the result. The SQL query structure, chart creation, and display logic are equivalent, and the differences in variable naming ('AvgDiscount' vs 'AverageDiscount') do not affect the correctness of the output.",both
"What percentage of total stock does each product contribute, and can this be visualized in a pie chart?","```python
import plotly.express as px

# SQL query to retrieve the required data
sql_query = """"""
SELECT p.ProductID, 
ROUND(p.UnitsInStock / (SELECT SUM(UnitsInStock) FROM products) * 100, 2) AS StockPercentage 
FROM products p;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Ensure that 'ProductID' and 'StockPercentage' are treated as strings and numeric
df['ProductID'] = df['ProductID'].astype(str)
df['StockPercentage'] = df['StockPercentage'].astype(float)

# Generate a pie chart using Plotly
fig = px.pie(df, names='ProductID', values='StockPercentage', title='Percentage Contribution of Total Stock by Product')

# Display the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get product names and their corresponding stock quantities
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query and retrieve the data
product_data = execute_sql_query(sql_query)

# Calculate the total stock
total_stock = product_data['UnitsInStock'].sum()

# Calculate the percentage contribution of each product
product_data['PercentageContribution'] = (product_data['UnitsInStock'] / total_stock) * 100

# Create a pie chart visualization
fig = px.pie(product_data, 
             names='ProductName', 
             values='PercentageContribution', 
             title='Percentage Contribution of Each Product to Total Stock')

# Display the visualization to the user
show_to_user(fig)
```","The provided code includes a condition to filter products where 'Discontinued = 0', which is not present in the reference code. This leads to a discrepancy in the set of products considered for calculating the percentage contribution of total stock. The business request and reference code do not specify this condition, making it inconsistent with the intended logic.","```python
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT ProductID, (UnitsInStock * 100.0 / (SELECT SUM(UnitsInStock) FROM products)) AS PercentageOfTotalStock FROM products
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create pie chart
fig = px.pie(df, names='ProductID', values='PercentageOfTotalStock', title='Percentage of Total Stock by Product')

# Display the chart
show_to_user(fig)
```","The input code correctly calculates the percentage of total stock each product contributes by dividing 'UnitsInStock' by the total stock sum, multiplied by 100. It uses a similar SQL logic as the reference by performing this calculation within a SELECT statement. Both implementations then visualize the data using a pie chart in Plotly, effectively addressing the business analytics request.",Finetuned
Which employee processed the highest number of orders last month?,"```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate last month's year and month
today = datetime.today()
first_day_of_current_month = today.replace(day=1)
last_month_end = first_day_of_current_month - timedelta(days=1)
last_month_year = last_month_end.year
last_month = last_month_end.month

# Define SQL query
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE YEAR(o.OrderDate) = {last_month_year} 
AND MONTH(o.OrderDate) = {last_month} 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and fetch the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Define the date for last month
today = datetime.today()
first_day_of_this_month = today.replace(day=1)
last_month_start = (first_day_of_this_month - timedelta(days=1)).replace(day=1)
last_month_end = first_day_of_this_month - timedelta(days=1)

# SQL query to find the employee who processed the highest number of orders last month
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= '{last_month_start.strftime('%Y-%m-%d')}' 
AND o.OrderDate <= '{last_month_end.strftime('%Y-%m-%d')}'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input code correctly determines the employee who processed the highest number of orders last month. It calculates the previous month's start and end dates accurately and uses them in the SQL query. The logic of joining the employees and orders tables, counting orders per employee, ordering by count in descending order, and limiting the result to one matches the reference implementation. The inclusion of employee names does not affect the primary logic and adds value by providing more information.","```python
import pandas as pd
import datetime

# Calculate last month's year and month
last_month = datetime.datetime.now().month - 1
last_year = datetime.datetime.now().year
if last_month == 0:
    last_month = 12
    last_year -= 1

# SQL query to find the employee who processed the highest number of orders last month
sql_query = f""""""
SELECT EmployeeID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
WHERE YEAR(OrderDate) = {last_year} AND MONTH(OrderDate) = {last_month} 
GROUP BY EmployeeID 
ORDER BY NumberOfOrders DESC 
LIMIT 1;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input code does not join the 'employees' table with the 'orders' table which is required by the reference code to identify the EmployeeID accurately. The input code only queries the 'orders' table, assuming 'EmployeeID' is directly available without confirming the relationship with the 'employees' table. This deviates from the reference implementation, which correctly joins the tables to ensure the EmployeeID corresponds accurately to an employee.",Base
"Determine the month with the highest total sales, and visualize the monthly sales trend with a line chart.","```python
import plotly.express as px

# SQL query to get monthly sales data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as order_month, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as total_sales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY order_month 
ORDER BY total_sales DESC;
""""""

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Determine the month with the highest total sales
highest_sales_row = monthly_sales_df.iloc[0]

# Visualize the monthly sales trend with a line chart
monthly_sales_df_sorted = monthly_sales_df.sort_values(by='order_month')
fig = px.line(monthly_sales_df_sorted, x='order_month', y='total_sales', title='Monthly Sales Trend')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    TotalSales DESC
""""""

monthly_sales = execute_sql_query(sql_query)

highest_sales_month = monthly_sales.iloc[0]

line_chart = px.line(monthly_sales, x='Month', y='TotalSales', title='Monthly Sales Trend')
show_to_user(line_chart)
```","The provided code correctly executes a SQL query to retrieve the monthly sales data, determines the month with the highest total sales, and creates a line chart visualization of the monthly sales trend. The logic is consistent with the reference implementation. Differences in variable names and formatting are acceptable as they do not affect the execution logic or the outcome.","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly sales
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Month;
""""""

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Calculate total sales to find the month with highest sales
max_sales_month = monthly_sales_df.loc[monthly_sales_df['TotalSales'].idxmax()]

# Visualize the monthly sales trend
fig = px.line(monthly_sales_df, x='Month', y='TotalSales', title='Monthly Sales Trend')
show_to_user(fig)

# Show the month with the highest total sales
show_to_user(pd.DataFrame(max_sales_month).T)
```","The input code correctly implements the business analytics request. It queries monthly sales data using SQL, groups by month, computes total sales, identifies the month with the highest sales, and generates a line chart to visualize the monthly sales trend. The method of finding the month with the highest sales using idxmax is correct and equivalent to the reference implementation's use of iloc[0] after sorting. Both implementations correctly display the chart and the month with the highest sales.",both
Identify the top 5 suppliers based on the total sales revenue and show this in a ranked bar chart.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT p.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID, s.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the query
top_suppliers_df = execute_sql_query(sql_query)

# Create a ranked bar chart
fig = px.bar(top_suppliers_df, x='CompanyName', y='TotalRevenue', 
             title='Top 5 Suppliers by Total Sales Revenue', 
             text='TotalRevenue', 
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier Name'})

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    s.SupplierID, 
    s.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    s.SupplierID, s.CompanyName
ORDER BY 
    TotalSales DESC
LIMIT 5
""""""

top_suppliers_df = execute_sql_query(sql_query)

fig = px.bar(top_suppliers_df, 
              x='CompanyName', 
              y='TotalSales', 
              title='Top 5 Suppliers by Total Sales Revenue', 
              labels={'TotalSales': 'Total Sales Revenue', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code meets the business analytics request by correctly identifying the top 5 suppliers based on total sales revenue. It executes a SQL query to calculate the total revenue generated by each supplier and orders them in descending order to select the top 5. The only notable difference is in column naming, where 'TotalSales' is used instead of 'TotalRevenue', but this does not affect the correctness of the analysis or visualization. Both implementations use Plotly to generate a ranked bar chart, adhering to the requested logic and task requirements.","```python
import plotly.express as px

sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSalesRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.CompanyName 
ORDER BY TotalSalesRevenue DESC 
LIMIT 5
""""""

# Execute the SQL query
top_suppliers_df = execute_sql_query(sql_query)

# Create a ranked bar chart
fig = px.bar(top_suppliers_df, x='CompanyName', y='TotalSalesRevenue', 
             title='Top 5 Suppliers by Total Sales Revenue',
             labels={'TotalSalesRevenue': 'Total Sales Revenue', 'CompanyName': 'Supplier Name'},
             text_auto=True)

# Display the bar chart
show_to_user(fig)
```","Both implementations perform the same task: they calculate the total sales revenue for each supplier and rank them in descending order to identify the top 5 suppliers. The SQL query structure is equivalent, with essential parts like the JOIN operations and calculations remaining consistent. The visualization with Plotly Express is also similar, using a bar chart to display the ranked results. Although variable names differ slightly, the logic and processing are equivalent, making the input code correct as per the business analytics request.",both
Which customer generated the highest lifetime value?,"```python
import pandas as pd

# SQL query to find the customer with the highest lifetime value
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS CustomerLifetimeValue
FROM customers
INNER JOIN orders ON customers.CustomerID = orders.CustomerID
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY customers.CustomerID
ORDER BY CustomerLifetimeValue DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    LifetimeValue DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code correctly answers the business analytics request. It calculates the lifetime value per customer by summing up the total for each order, similar to the reference code. Although the input code also selects the 'CompanyName', it doesn't affect the logic or purpose of the query, which is to find the customer with the highest lifetime value. The order of operations and groupings are consistent with the reference implementation, ensuring correctness.","```python
import pandas as pd

# Execute SQL query to get customer lifetime value 
sql_query = """"""
SELECT c.CustomerID,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as CustomerLifetimeValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY CustomerLifetimeValue DESC
LIMIT 1;
""""""

df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input Python code accurately implements the same logic as the reference implementation. Both codes perform a SQL query to calculate the customer lifetime value by summing up the total earnings from each customer's orders, considering unit price, quantity, and discount, and finally sorting the customers to find the maximum lifetime value. The `JOIN` operations and `GROUP BY` clauses are consistent between both implementations. Order and limit clauses are also identical. Therefore, the input code is correct according to the specified business analytics request.",both
How many employees live in each country and illustrate it with a map or bar chart?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT Country, COUNT(EmployeeID) AS EmployeeCount 
FROM employees 
GROUP BY Country;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Country', y='EmployeeCount', title='Number of Employees by Country')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Country, COUNT(EmployeeID) AS EmployeeCount FROM employees GROUP BY Country;""
employee_counts = execute_sql_query(sql_query)

fig = px.bar(employee_counts, x='Country', y='EmployeeCount', title='Number of Employees by Country')
show_to_user(fig)
```","The input code correctly queries the number of employees in each country and uses Plotly to create a bar chart, matching the logic of the reference implementation. Both use an SQL query to count employees by country and display the results in a bar chart using Plotly.","```python
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT Country, COUNT(*) AS EmployeeCount FROM employees GROUP BY Country;""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the number of employees by country
fig = px.bar(df, x='Country', y='EmployeeCount', title='Number of Employees by Country')

# Display the result to the user
show_to_user(fig)
```","The input code correctly implements the required functionality. Both the reference and input code use an SQL query to select the country and count the number of employees grouped by country, and then they create a bar chart using Plotly to visualize the data. The logic and output of the input code are consistent with the reference implementation.",both
Visualize the total sales revenue for the month of January 2023 to identify trends or patterns using time-series or bar charts.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales, 
       DAY(OrderDate) as SaleDay
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE MONTH(OrderDate) = 1 AND YEAR(OrderDate) = 2023
GROUP BY DAY(OrderDate)
ORDER BY SaleDay;
""""""

# Execute the query
sales_data = execute_sql_query(sql_query)

# Visualize the data with a time-series line chart
fig = px.line(sales_data, x='SaleDay', y='TotalSales', title='Total Sales Revenue - January 2023', labels={'SaleDay': 'Day of January', 'TotalSales': 'Total Sales Revenue'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m-%d') AS OrderDate,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
GROUP BY 
    OrderDate
ORDER BY 
    OrderDate
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='OrderDate', y='TotalSales', title='Total Sales Revenue for January 2023')
show_to_user(fig)
```","Both code implementations correctly calculate the total sales revenue for each day in January 2023, applying the same logic to compute the sum of sales. The difference lies in the visualization: the reference uses a time-series line chart while the input code uses a bar chart. Both are valid visualizations for the business request, as they effectively display trends or patterns in sales revenue for January 2023.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT MONTH(orders.OrderDate) AS OrderMonth,
  SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY MONTH(orders.OrderDate);
""""""

# Execute SQL query and get data
january_sales_df = execute_sql_query(sql_query)

# Plot data
fig = px.bar(january_sales_df, x='OrderMonth', y='TotalSales', title='Total Sales Revenue for January 2023')
show_to_user(fig)
```","The input code groups the data by month, summarizing sales for the whole month of January 2023 as a single data point, and uses a bar chart for visualization. The reference code, however, groups data by each day of January, showing trends over time in a line chart. Thus, the input code does not match the logic and granularity of the reference implementation and does not meet the requirements of identifying daily trends or patterns.",Base
Find and visualize the top 5 cities with the highest average shipping cost to compare differences using a bar chart or map.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageFreight 
FROM orders 
GROUP BY ShipCity 
ORDER BY AverageFreight DESC 
LIMIT 5;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ShipCity', y='AverageFreight', title='Top 5 Cities with Highest Average Shipping Cost', labels={'AverageFreight':'Average Freight'})

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AvgShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AvgShippingCost DESC
LIMIT 5
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='ShipCity', y='AvgShippingCost', title='Top 5 Cities with Highest Average Shipping Cost', labels={'AvgShippingCost': 'Average Shipping Cost', 'ShipCity': 'City'})
show_to_user(fig)
```","The input code is correct. It matches the logic and objectives of the reference code. Both codes execute a SQL query to find the top 5 cities with the highest average shipping cost, group by ShipCity, order by the average, and limit to 5. They both use Plotly Express to create a bar chart to visualize the results. The variable names and label strings differ slightly, but these are not essential to the logic of fulfilling the analytics request.","```python
import plotly.express as px

# SQL query to retrieve the data
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageShippingCost 
FROM orders 
GROUP BY ShipCity 
ORDER BY AverageShippingCost DESC 
LIMIT 5;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(data, x='ShipCity', y='AverageShippingCost', title='Top 5 Cities by Average Shipping Cost')

# Display the result
show_to_user(fig)
```","The provided code fragment correctly executes a SQL query to find the top 5 cities with the highest average shipping cost, similar to the reference implementation. Both implementations use SQL to calculate the average freight cost per city, order the results in descending order, and limit the output to the top 5 cities. Additionally, both codes use Plotly to generate a bar chart to visualize these results. The differences in labels and variable names do not change the logical flow or outcome of the task.",both
Which products need to be reordered (units in stock less than reorder level)?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_to_reorder_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""

reorder_products = execute_sql_query(sql_query)
show_to_user(reorder_products)
```","The input code includes an extra condition 'AND Discontinued = 0', filtering out any discontinued products. The reference does not include this condition, meaning it intends to include all products with units in stock less than the reorder level, regardless of whether they are discontinued. The input code adds additional logic not present in the reference code, making it incorrect according to the specification.","```python
import pandas as pd

# SQL Query to find products that need to be reordered
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute query
products_to_reorder_df = execute_sql_query(sql_query)

# Display result
show_to_user(products_to_reorder_df)
```","The provided code only selects 'ProductName', while the reference implementation selects both 'ProductID' and 'ProductName'. Thus, it does not fully adhere to the logic of the reference implementation.",None
Visualize the top 5 products by sales revenue using a bar chart for comparative analysis.,"```python
import plotly.express as px

# SQL query to retrieve top 5 products by sales revenue
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query using provided utility function
sales_data = execute_sql_query(sql_query)

# Ensure ProductID is treated as a categorical variable for plotting
sales_data['ProductID'] = sales_data['ProductID'].astype(str)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue')

# Display the bar chart using provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalSales DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue', labels={'ProductID': 'Product ID', 'TotalSales': 'Sales Revenue'})
show_to_user(fig)
```","The input code correctly implements the business analytics request, matching the logical flow of the reference implementation. Both codes execute a SQL query to extract the top 5 products by sales revenue from the database. The difference, such as joining the 'orders' table in the input code, doesn't affect the outcome as it doesn't alter the final aggregation or logic needed for the task. The visualization part using Plotly is consistent with the reference. Thus, the code correctly answers the analytics request.","```python
import plotly.express as px

# SQL query to get top 5 products by sales revenue
sql_query = """"""
SELECT p.ProductID, p.ProductName, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductName', y='TotalSales', title='Top 5 Products by Sales Revenue')

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly implements the task of visualizing the top 5 products by sales revenue using a bar chart. It adheres to the logic specified in the reference implementation. Both versions aggregate sales revenue by multiplying 'UnitPrice', 'Quantity', and accounting for 'Discount', sorting in descending order, and limiting the results to the top 5 products. The key difference is that the input code includes 'ProductName' in the SQL query and uses it for the x-axis on the bar chart, whereas the reference uses 'ProductID'. Both approaches fulfill the business requirement of visualizing the top products by sales revenue.",both
Analyze and visualize the correlation between employee hire date and performance using scatter plots or correlation matrices.,"```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT employees.EmployeeID, employees.HireDate, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, employees.HireDate 
ORDER BY employees.HireDate;
""""""

# Execute SQL query to retrieve data
df = execute_sql_query(sql_query)

# Ensure HireDate is in datetime format
df['HireDate'] = pd.to_datetime(df['HireDate'])

# Calculate performance metric (e.g., using TotalSales as a proxy for performance)
# Assuming we want to standardize it
df['Performance'] = (df['TotalSales'] - df['TotalSales'].mean()) / df['TotalSales'].std()

# Visualize the correlation between HireDate and Performance
fig = px.scatter(df, x='HireDate', y='Performance', 
                 title='Correlation between Hire Date and Performance',
                 labels={'HireDate': 'Hire Date', 'Performance': 'Performance'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.HireDate, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.HireDate
ORDER BY e.HireDate
""""""

data = execute_sql_query(sql_query)
fig = px.scatter(data, x='HireDate', y='TotalSales', title='Correlation Between Employee Hire Date and Performance',
                 labels={'HireDate': 'Hire Date', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code plots 'TotalSales' directly against 'HireDate' without normalizing it like the reference code. The reference implementation transforms 'TotalSales' into a standardized 'Performance' metric, which is crucial for assessing correlation. Additionally, the input code groups by 'HireDate' instead of 'EmployeeID' and 'HireDate', ignoring the potential for multiple employees per hire date, potentially skewing the data.","```python
import plotly.express as px

# SQL query to fetch required data
sql_query = """"""
SELECT e.HireDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.HireDate
""""""

# Execute the SQL query and load the data into a pandas dataframe
data = execute_sql_query(sql_query)

# Create a scatter plot to analyze the correlation
fig = px.scatter(data, x='HireDate', y='TotalSales', title='Correlation between Hire Date and Total Sales')

# Display the plot to the user
show_to_user(fig)
```","The input code directly plots TotalSales against HireDate without standardizing or transforming TotalSales into a performance metric. In contrast, the reference implementation calculates a 'Performance' metric by standardizing TotalSales. The input code also groups data by HireDate alone, while the reference groups by both EmployeeID and HireDate. The correlation analysis in the input code does not reflect the individual employee's performance over time, as the reference implementation suggests.",None
How many new customers were acquired in May 2023?,"```python
import pandas as pd

# SQL query to count distinct new customers acquired in May 2023
sql_query = """"""
SELECT COUNT(DISTINCT customers.CustomerID) AS new_customers 
FROM customers 
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
AND customers.CustomerID NOT IN (
    SELECT CustomerID 
    FROM orders 
    WHERE OrderDate < '2023-05-01')
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS new_customers
FROM orders
WHERE orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""
new_customers_df = execute_sql_query(sql_query)
show_to_user(new_customers_df)
```","The input code only counts distinct customers who made orders in May 2023 without checking whether those customers were new. The reference implementation ensures that the customers did not make any purchases before May 2023, which is essential to determine if they are indeed new. The input code lacks this logic, so it does not accurately fulfill the business requirement.","```python
import pandas as pd

sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS NewCustomers 
FROM orders 
WHERE OrderDate BETWEEN '2023-05-01' AND '2023-05-31';
""""""

result_df = execute_sql_query(sql_query)
new_customers = result_df['NewCustomers'].iloc[0]
show_to_user(pd.DataFrame({'NewCustomers': [new_customers]}))
```","The input code counts the distinct CustomerIDs with orders in May 2023, but it does not ensure these customers did not have orders before May 2023. The reference code checks for new customers by excluding those who ordered prior to May 2023 using an additional SQL subquery.",None
Which suppliers provide products that are currently in stock?,"```python
import pandas as pd

# SQL Query to get suppliers with products currently in stock
sql_query = ""SELECT DISTINCT SupplierID FROM products WHERE UnitsInStock > 0""

# Execute the SQL query
supplier_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(supplier_df)
```","```python
sql_query = """"""
SELECT DISTINCT p.SupplierID
FROM products p
WHERE p.UnitsInStock > 0 AND p.Discontinued = 0
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code includes an additional condition to check if the product is not discontinued ('p.Discontinued = 0'), which is not present in the reference implementation. This additional condition changes the logic by potentially excluding suppliers of discontinued products that are still in stock, which may not align with the intended business analytics request.","```python
import pandas as pd

# SQL query to get suppliers of products currently in stock
sql_query = """"""
SELECT DISTINCT p.SupplierID 
FROM products p 
WHERE p.UnitsInStock > 0;
""""""

# Execute query and fetch data
suppliers_in_stock_df = execute_sql_query(sql_query)

# Display the result
show_to_user(suppliers_in_stock_df)
```","The input Python code correctly answers the business analytics request by selecting distinct SupplierIDs from the products table where UnitsInStock is greater than zero. It matches the logic of the reference implementation, specifically retrieving suppliers with currently in-stock products. The use of an alias for the products table (p) does not alter the outcome and still aligns with the request and reference implementation.",Finetuned
Visualize the number of employees in each country to identify distribution using a map or bar chart.,"```python
import plotly.express as px

# Execute the SQL query and fetch data
sql_query = ""SELECT Country, COUNT(*) AS NumEmployees FROM employees GROUP BY Country;""
employees_df = execute_sql_query(sql_query)

# Create a map visualization using Plotly
fig_bar = px.bar(employees_df, x='Country', y='NumEmployees', title='Number of Employees per Country')

# Show the bar chart to the user
show_to_user(fig_bar)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Country, COUNT(EmployeeID) AS EmployeeCount FROM employees GROUP BY Country""
employee_data = execute_sql_query(sql_query)

fig = px.bar(employee_data, x='Country', y='EmployeeCount', title='Number of Employees by Country', labels={'EmployeeCount': 'Number of Employees', 'Country': 'Country'})
show_to_user(fig)
```","The input code is correct as it achieves the same business goal as the reference implementation. It performs the same SQL query to count the number of employees per country, then uses Plotly to create a bar chart with the data. The differences, such as counting 'EmployeeID' instead of '*' and additional labels parameter in the Plotly function, do not affect the correctness or essential logic of the task.","```python
import plotly.express as px

query = ""SELECT Country, COUNT(EmployeeID) AS Num_Employees FROM employees GROUP BY Country;""
df = execute_sql_query(query)

fig = px.bar(df, x='Country', y='Num_Employees', title='Number of Employees per Country')
show_to_user(fig)
```","The input code correctly executes the SQL query to count employees per country and stores the result in a DataFrame. It uses Plotly Express to create a bar chart with the number of employees per country, similar to the reference code. Both codes use column aliases (NumEmployees vs Num_Employees) but achieve the same result. The chart is then displayed using 'show_to_user', matching the reference implementation logic.",both
Visualize the average fulfillment time for orders by month to identify seasonal trends using a line chart.,"```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
    SELECT EXTRACT(MONTH FROM OrderDate) AS Month, 
    AVG(DATEDIFF(DAY, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
    FROM orders 
    GROUP BY EXTRACT(MONTH FROM OrderDate)
""""""

# Execute the SQL query to get a dataframe
data = execute_sql_query(sql_query)

# Convert the Month column to integer in case it's not already
data['Month'] = data['Month'].astype(int)

# Sort the dataframe by Month to ensure correct order in the visualization
data = data.sort_values('Month')

# Create a line chart
fig = px.line(data, x='Month', y='AvgFulfillmentTime', 
              title='Average Fulfillment Time by Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'Month': 'Month'})

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='OrderMonth', y='AvgFulfillmentTime', 
              title='Average Fulfillment Time for Orders by Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)', 'OrderMonth': 'Month'})

show_to_user(fig)
```","The input code and the reference code don't align in terms of the time frames they analyze. The reference code uses `EXTRACT(MONTH FROM OrderDate)` implying analysis by month across multiple years, whereas the input code uses `DATE_FORMAT(OrderDate, '%Y-%m')`, indicating analysis that's precise to month and year (monthly within each specific year). This could lead to different numbers of months analyzed and different ordering of results. Therefore, the input code does not follow the same logic as the reference implementation.","```python
import plotly.express as px

# SQL query as per provided business metric definition
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Sort the DataFrame by 'Month' to ensure correct line chart order
df.sort_values(by='Month', inplace=True)

# Create a line chart using plotly
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Average Fulfillment Time by Month')

# Show the line chart
show_to_user(fig)
```","The input Python code calculates the average fulfillment time grouped by year and month (YYYY-MM format), whereas the reference code groups by month only (MM format). This discrepancy means the input doesn't align with the reference implementation's logic, which focuses solely on monthly trends irrespective of the year.",None
How many days on average does it take to fulfill an order?,"```python
import pandas as pd

# Execute SQL query and retrieve data
df = execute_sql_query(""SELECT OrderDate, ShippedDate FROM orders"")

# Calculate average fulfillment time
df['FulfillmentTime'] = (pd.to_datetime(df['ShippedDate']) - pd.to_datetime(df['OrderDate'])).dt.days
avg_fulfillment_time = df['FulfillmentTime'].mean()

# Create a DataFrame to display the result
result_df = pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]})

# Display result to user
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentDays
FROM orders
WHERE ShippedDate IS NOT NULL AND OrderDate IS NOT NULL
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly calculates the average fulfillment time by using an SQL query that computes the average difference in days between 'OrderDate' and 'ShippedDate'. This achieves the same result as the reference code by leveraging the database's DATEDIFF function to calculate the fulfillment days and averaging them. Both methods provide the average days needed to fulfill an order, thus adhering to the business analytics request.","```python
import pandas as pd

sql_query = ""SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS FulfillmentDays FROM orders""
result_df = execute_sql_query(sql_query)

avg_fulfillment_days = result_df['FulfillmentDays'].iloc[0]
show_to_user(pd.DataFrame({'Average Fulfillment Days': [avg_fulfillment_days]}))
```","Both the reference and input code aim to calculate the average number of days it takes to fulfill an order. The reference code computes this by calculating the difference in days between 'ShippedDate' and 'OrderDate' for each order, then taking the mean of these differences. The input code achieves the same end by directly using the SQL `DATEDIFF` function to calculate the difference in days within the query itself and then averaging these values. Both approaches yield the same business insight, adhering to the logic to determine the average fulfillment duration, hence the input is correct.",both
What is the average discount applied per product?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute SQL query and retrieve data as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the average discount result to the user
average_discount = df['AverageDiscount'].iloc[0]
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))
```","```python
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY ProductID
""""""
average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code calculates the average discount per product by grouping the data by ProductID, resulting in a separate average for each product. The reference implementation calculates a single overall average discount across all products, which is not the same requirement.","```python
import pandas as pd

sql_query = ""SELECT ProductID, AVG(Discount) as AverageDiscount FROM [Order Details] GROUP BY ProductID;""
df = execute_sql_query(sql_query)

show_to_user(df)
```","The input code calculates the average discount for each product (GROUP BY ProductID), whereas the reference implementation calculates the overall average discount across all products. These are different operations and the input code does not adhere to the same logic as the reference implementation.",None
Which suppliers have supplied the most products?,"```python
import pandas as pd

# SQL query to get suppliers and the count of products they supplied
sql_query = """"""
SELECT s.SupplierID, COUNT(p.ProductID) AS TotalProductsSupplied 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID 
ORDER BY TotalProductsSupplied DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.SupplierID, COUNT(p.ProductID) AS ProductCount
FROM products p
GROUP BY p.SupplierID
ORDER BY ProductCount DESC
""""""

supplier_products_df = execute_sql_query(sql_query)
show_to_user(supplier_products_df)
```","The input code correctly retrieves the suppliers and the count of products they supplied. Both the input and reference implementations group by SupplierID and count ProductID, then order the results by the count descending. The key difference is that the input code doesn't explicitly join 'suppliers' and 'products' tables but achieves the same result by using 'SupplierID' directly from 'products', assuming this column is available in 'products'. As it adheres to the business request logic, it is considered correct.","```python
import pandas as pd

sql_query = """"""
SELECT p.SupplierID, COUNT(*) as ProductCount 
FROM products p 
GROUP BY p.SupplierID 
ORDER BY ProductCount DESC;
""""""

result_df = execute_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly answers the business analytics request by grouping products by SupplierID and counting them, which aligns with the reference logic. Both codes output the suppliers with the highest product counts, even though the join with the suppliers table is omitted in the input code. As long as SupplierID exists in the products table, the result will be consistent.",both
Visualize which regions have the highest on-time delivery rates using a bar chart or heat map.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipRegion, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID)) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipRegion', y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rates by Region',
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'ShipRegion': 'Region'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID) AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipRegion
ORDER BY OnTimeDeliveryRate DESC
""""""

delivery_data = execute_sql_query(sql_query)

fig = px.bar(delivery_data, x='ShipRegion', y='OnTimeDeliveryRate',
             title='On-Time Delivery Rates by Region',
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate', 'ShipRegion': 'Region'})
show_to_user(fig)
```","The input Python code correctly implements the requested task. It executes a SQL query to calculate the on-time delivery rate for each region by dividing the count of on-time deliveries by the total orders. This matches the logic in the reference implementation. The calculated on-time delivery rates are then visualized using a bar chart with Plotly, which aligns with the business analytics request. The minor difference in the calculation does not affect the correctness, as both implementations provide equivalent results.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve on-time delivery rates by region
sql_query = """"""
SELECT ShipRegion, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart for on-time delivery rates by region
fig = px.bar(df, x='ShipRegion', y='OnTimeDeliveryRate', title='On-Time Delivery Rate by Region')

# Display the result
show_to_user(fig)
```","The input code correctly follows the same logic as the reference code. It retrieves on-time delivery rates by region using a similar SQL query and visualizes the data with a bar chart. Although the input query does not explicitly order the results, both accomplish the task of visualizing on-time delivery rates by region, fulfilling the business analytics request.",both
How many orders were handled by employees who were hired in the year 2020?,"```python
sql_query = """"""
    SELECT COUNT(orders.OrderID) AS TotalOrders
    FROM employees
    JOIN orders ON employees.EmployeeID = orders.EmployeeID
    WHERE YEAR(HireDate) = 2020;
""""""

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(o.OrderID) AS TotalOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE YEAR(e.HireDate) = 2020
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code matches the logic of the reference implementation. It selects the count of OrderID from the orders table joined with the employees table where the hire date is in the year 2020. The only differences are in aliasing (using 'e' and 'o') and formatting, which do not affect the correctness of the query logic.","```python
import pandas as pd

# Execute the SQL queries
df2020 = execute_sql_query(""SELECT EmployeeID FROM employees WHERE YEAR(HireDate) = 2020"")
df_orders = execute_sql_query(""SELECT EmployeeID FROM orders"")

# Find employees hired in 2020 who handled orders
df_merged = pd.merge(df2020, df_orders, on='EmployeeID')

# Count distinct orders
order_count = df_merged['EmployeeID'].nunique()

# Display the result
show_to_user(pd.DataFrame({'OrderCount': [order_count]}))
```","The input code calculates the count of unique employees who handled orders, not the total count of orders handled by employees hired in 2020. It fails to match the logic of the reference code, which counts total orders.",Base
Visualize the average discount applied to products per month using a line chart to identify trends.,"```python
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       AVG(Discount) AS AverageDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Convert 'month' column to string if needed (ensure consistent data type)
data['month'] = data['month'].astype(str)

# Create a line chart using plotly
fig = px.line(data, x='month', y='AverageDiscount', title='Average Discount per Month')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    AVG(od.Discount) AS Average_Discount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.line(average_discount_df, x='Month', y='Average_Discount', title='Average Discount Applied to Products per Month', labels={'Average_Discount': 'Average Discount', 'Month': 'Month'})
show_to_user(fig)
```","The input Python code correctly visualizes the average discount per month using a line chart, just like the reference implementation. The SQL query structure and logic match, joining 'orders' and 'Order Details' tables, formatting OrderDate to month, and calculating the average discount using 'AVG()'. The result is grouped and ordered by month, similar to the reference. The plotting part uses Plotly to create a line chart displaying the average discount over time, which also follows the reference’s intent to identify trends over months. Therefore, despite differences in variable names and some syntactic differences, the input code is logically consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

query = """"""
SELECT MONTH(o.OrderDate) AS Month, AVG(od.Discount) AS AvgDiscount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY MONTH(o.OrderDate);
""""""

data = run_sql_query(query)

fig = px.line(data, x='Month', y='AvgDiscount', title='Average Discount Per Month')
show_to_user(fig)
```","The input code queries the month using 'MONTH(o.OrderDate)' which extracts only the month number, whereas the reference code uses 'DATE_FORMAT(OrderDate, '%Y-%m')' to get year-month format. This difference means the input code does not consider the year, which can lead to incorrect trend analysis over multiple years.",Base
What is the average time between order date and required date?,"```python
import pandas as pd

# SQL query to calculate average time between order date and required date
sql_query = """"""
SELECT OrderDate, RequiredDate FROM orders;
""""""

# Execute the SQL query and get the result in a dataframe
df = execute_sql_query(sql_query)

# Calculate the average time between order date and required date
df['OrderDate'] = pd.to_datetime(df['OrderDate'])
df['RequiredDate'] = pd.to_datetime(df['RequiredDate'])
df['LeadTime'] = (df['RequiredDate'] - df['OrderDate']).dt.days
average_lead_time = df['LeadTime'].mean()

# Display the result to the user
show_to_user(pd.DataFrame({'AverageLeadTime': [average_lead_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(RequiredDate, OrderDate)) AS AverageTime
FROM orders
""""""

average_time_df = execute_sql_query(sql_query)
show_to_user(average_time_df)
```","The input code correctly calculates the average time between the order date and the required date using SQL. It directly uses the SQL function DATEDIFF and AVG to compute the average difference in days between RequiredDate and OrderDate, which matches the logic of the reference implementation. Therefore, the input code fulfills the business analytics request.","```python
import pandas as pd

# SQL query to calculate the average time between OrderDate and RequiredDate
sql_query = ""SELECT AVG(DATEDIFF(RequiredDate, OrderDate)) AS AvgTimeToShip FROM orders;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The input code directly calculates the average difference in days between RequiredDate and OrderDate using SQL's DATEDIFF function. This approach might be correct in some contexts, as it simplifies the process into a single SQL query. However, the logic differs from the reference implementation, which explicitly converts dates and calculates the average in Python. The distinction matters if there are nuances in date handling between SQL and Python, such as time zones or handling of NULL values. Without explicit confirmation of equivalent results, the input can't be judged correct just based on structural similarity.",Base
How many products have a stock level below their reorder level?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(ProductName) as NumProductsBelowReorder FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the query and get the result as a Pandas DataFrame
products_below_reorder = execute_sql_query(sql_query)

# Prepare the result to show to user
result_df = pd.DataFrame({'Number of Products Below Reorder Level': products_below_reorder['NumProductsBelowReorder']})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS LowStockCount
FROM products
WHERE UnitsInStock < ReorderLevel
""""""
low_stock_count = execute_sql_query(sql_query)
show_to_user(low_stock_count)
```","The input Python code correctly implements the business analytics request. Both the input and reference implementations execute a SQL query to count the number of products where 'UnitsInStock' is less than 'ReorderLevel'. The input code uses 'COUNT(*)' instead of 'COUNT(ProductName)', which is functionally equivalent for counting rows. The input then displays the result using 'show_to_user', matching the reference functionality.","```python
import pandas as pd

sql_query = ""SELECT COUNT(*) AS LowStockProductCount FROM products WHERE UnitsInStock < ReorderLevel;""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly counts products with stock levels below their reorder level using the SQL query. It uses 'COUNT(*)' similar to the reference's 'COUNT(ProductName)', which is equivalent here since it counts the number of rows, i.e., products satisfying the condition. The logic aligns with the reference implementation, fulfilling the business analytics request.",both
Which orders were delayed more than five days past the required date?,"```python
import pandas as pd

# Retrieve all orders
all_orders_df = execute_sql_query(""SELECT OrderID, ShippedDate, RequiredDate FROM orders"")

# Calculate the delay in days
all_orders_df['DelayDays'] = (all_orders_df['ShippedDate'] - all_orders_df['RequiredDate']).dt.days

# Filter orders delayed more than 5 days
delayed_orders_df = all_orders_df[all_orders_df['DelayDays'] > 5][['OrderID']]

# Display the result to the user
show_to_user(delayed_orders_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE DATEDIFF(ShippedDate, RequiredDate) > 5
""""""
delayed_orders_df = execute_sql_query(sql_query)
show_to_user(delayed_orders_df)
```","The input code correctly identifies orders delayed by more than five days by using the SQL DATEDIFF function to calculate the difference between ShippedDate and RequiredDate. This matches the logic of the reference implementation, which also calculates delay in days and filters orders where the delay is greater than five days.","```python
import pandas as pd

sql_query = """"""
SELECT OrderID FROM orders WHERE DATEDIFF(ShippedDate, RequiredDate) > 5
""""""

# Execute SQL query
orders_delayed_df = execute_sql_query(sql_query)

# Show the results to user
show_to_user(orders_delayed_df)
```","The evaluated code correctly identifies orders delayed more than five days past the required date using an SQL query. The business requirement is satisfied by filtering orders based on the difference between 'ShippedDate' and 'RequiredDate', which matches the logic of the reference implementation, although it calculates the delay directly in SQL instead of using Pandas.",both
What is the average time taken to fulfill an order?,"```python
import pandas as pd

# SQL query to get the average fulfillment time
sql_query = """"""
SELECT AVG(DATE_PART('day', ShippedDate::timestamp - OrderDate::timestamp)) AS AverageFulfillmentTime FROM orders;
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Extract the average fulfillment time from the dataframe
average_fulfillment_time = df.loc[0, 'AverageFulfillmentTime']

# Display the result to the user
show_to_user(pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL AND OrderDate IS NOT NULL;
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time_df)
```","The provided implementation correctly calculates the average time taken to fulfill an order using SQL to compute the difference between 'ShippedDate' and 'OrderDate'. The logic matches the reference implementation's objective of averaging these differences, even though the date difference functions (DATE_PART vs. DATEDIFF) differ. Both implementations ensure that only non-null dates are considered, maintaining the correctness of the result. Moreover, the final result is displayed using the 'show_to_user' function, aligning with the reference requirement.","```python
import pandas as pd

# SQL query to calculate the average fulfillment time
sql_query = """"""
SELECT AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS FulfillmentTime FROM orders;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input Python code and the reference implementation both compute the average fulfillment time from the 'orders' table. In the input code, the `DATEDIFF` function calculates the difference in days between ShippedDate and OrderDate, which aligns with `DATE_PART('day', ShippedDate::timestamp - OrderDate::timestamp)` used in the reference code. The SQL logic and end results are equivalent, and both codes display the result to the user.",both
Calculate and visualize the total value of current inventory (UnitPrice * UnitsInStock) for all products using a pie chart or bar chart for better understanding.,"```python
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT UnitPrice, UnitsInStock FROM products;""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Calculate the total inventory value
total_inventory_value = (df['UnitPrice'] * df['UnitsInStock']).sum()

# Create a bar chart to visualize the total inventory value
fig = px.bar(x=['Total Inventory Value'], y=[total_inventory_value], 
             title='Total Value of Current Inventory', labels={'x': 'Category', 'y': 'Value'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitPrice, UnitsInStock, (UnitPrice * UnitsInStock) AS TotalInventoryValue 
FROM products 
WHERE Discontinued = 0
""""""
inventory_data = execute_sql_query(sql_query)

fig = px.pie(inventory_data, names='ProductName', values='TotalInventoryValue', title='Total Value of Current Inventory')
show_to_user(fig)
```","The input code calculates and visualizes the total inventory value for each product separately using a pie chart, which is different from the reference implementation that calculates a single total inventory value for all products using a bar chart. The business request is to calculate the overall total inventory value, not per product.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ProductName, UnitPrice * UnitsInStock AS TotalInventoryValue FROM products;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ProductName', y='TotalInventoryValue', title=""Total Value of Current Inventory by Product"")

# Show the result to the user
show_to_user(fig)
```","The input code computes and visualizes the total inventory value per product, using 'ProductName', which differs from the reference implementation that calculates and visualizes the total inventory value across all products. The logic and the question addressed are different.",None
What is the average lead time for each supplier? Visualize the average lead time using a bar chart to compare suppliers effectively.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY products.SupplierID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Ensure 'AverageLeadTime' is treated as a float for plotting
df['AverageLeadTime'] = df['AverageLeadTime'].astype(float)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', 
             title='Average Lead Time for Each Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (days)'}, 
             height=400)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN orders ON products.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = orders.OrderID)
GROUP BY suppliers.SupplierID, suppliers.CompanyName
""""""

average_lead_time_df = execute_sql_query(sql_query)

fig = px.bar(average_lead_time_df, x='CompanyName', y='AverageLeadTime', 
             title='Average Lead Time Per Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly computes the average lead time for each supplier. While it includes the 'CompanyName' in the grouping and visualization, which is not required by the reference code, this addition does not alter the correctness of the result. Both implementations calculate the average lead time using a similar SQL logic and visualize it with a bar chart, fulfilling the business analytics request.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT suppliers.SupplierID, CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, CompanyName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(df, x='CompanyName', y='AverageLeadTime', 
             title='Average Lead Time by Supplier', 
             labels={'AverageLeadTime': 'Average Lead Time (days)', 'CompanyName': 'Supplier'})

# Show the visualization to the user
show_to_user(fig)
```","The input code successfully calculates the average lead time for each supplier based on the same logic as the reference implementation. While the input code includes additional information (CompanyName) to enhance the visualization by displaying the company name instead of the SupplierID, it still meets the requirements of calculating and visualizing the average lead time by supplier. The SQL query, data manipulation, and visualization logic aligned with the reference task, making the implementation valid.",both
List all orders including the details of the employee who handled them.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT orders.OrderID, orders.CustomerID, orders.OrderDate, 
       employees.LastName, employees.FirstName 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT o.OrderID, o.CustomerID, o.OrderDate, o.RequiredDate, o.ShippedDate, 
       o.ShipVia, o.Freight, o.ShipName, o.ShipAddress, o.ShipCity, 
       o.ShipRegion, o.ShipPostalCode, o.ShipCountry, 
       e.EmployeeID, e.FirstName, e.LastName, e.Title
FROM orders o
JOIN employees e ON o.EmployeeID = e.EmployeeID
""""""

orders_with_employee_details = execute_sql_query(sql_query)
show_to_user(orders_with_employee_details)
```","The input code correctly fulfills the business analytics request by listing all orders along with the details of the employee who handled them. It includes all necessary fields, even more than the reference code. The logic of joining the 'orders' table with the 'employees' table on 'EmployeeID' matches that of the reference implementation, which ensures the core requirement is met.","```python
import pandas as pd

query = """"""
SELECT o.*, e.FirstName, e.LastName, e.Title 
FROM orders o 
JOIN employees e ON o.EmployeeID = e.EmployeeID
""""""

df = execute_sql_query(query)
show_to_user(df)
```","The input code retrieves all orders and includes employee details (FirstName, LastName), similar to the reference implementation. The input code also retrieves additional details (Title), which does not affect correctness as it still meets the business analytics request. The core logic of joining orders with employee details is preserved.",both
What is the total quantity of products ordered from each employee? Use a pie chart to illustrate the proportion of total orders handled by each employee.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalQuantity 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and retrieve the data into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a pie chart using plotly express
fig = px.pie(df, names='EmployeeID', values='TotalQuantity', 
             title='Proportion of Total Orders Handled by Each Employee')

# Display the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

data = execute_sql_query(sql_query)

fig = px.pie(data, names=data['FirstName'] + ' ' + data['LastName'], values='TotalQuantity',
             title='Total Quantity of Products Ordered by Employee')
show_to_user(fig)
```","The input code has the same core logic as the reference code. It calculates the total quantity of products ordered for each employee and uses this data to generate a pie chart. The difference is in the inclusion of employee names to make the pie chart labels more informative, but the end result still illustrates the proportion of total orders handled by each employee.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute SQL query and get the data
df = execute_sql_query(sql_query)

# Create a pie chart
fig = px.pie(df, names='EmployeeID', values='TotalQuantity', title='Total Quantity Ordered by Each Employee')

# Show the pie chart
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It uses a SQL query to sum the quantities ordered for each employee, groups the results by employee, and creates a pie chart using Plotly Express to show the proportion of total orders by each employee. This aligns with the logic and purpose of the reference implementation, which also calculates the total quantities ordered per employee and visualizes it using a similar pie chart.",both
How many orders were shipped late in the last month?,"```python
import pandas as pd
from datetime import datetime

# Calculate the last month details
today = datetime.today()
first_day_of_this_month = today.replace(day=1)
last_month = first_day_of_this_month - pd.DateOffset(days=1)
last_month_year = last_month.year
last_month_number = last_month.month

# SQL query to count late orders in the last month
sql_query = f""""""
SELECT COUNT(orders.OrderID) AS Late_Orders
FROM orders
WHERE orders.RequiredDate < orders.ShippedDate
AND MONTH(orders.OrderDate) = {last_month_number}
AND YEAR(orders.OrderDate) = {last_month_year};
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate the date range for the last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to count late shipped orders
sql_query = f""""""
SELECT COUNT(OrderID) AS LateOrdersCount
FROM orders
WHERE ShippedDate > RequiredDate
AND OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
AND OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query and retrieve the result
late_orders_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(late_orders_df)
```",Both implementations correctly determine the number of orders shipped late in the previous month. They compute the date range for the last month and execute an SQL query to count orders where the 'ShippedDate' is after the 'RequiredDate' within the correct time frame. The logic and purpose align with the reference implementation despite some differences in how dates are calculated and presented.,"```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate last month
today = datetime.today()
first_day_of_current_month = datetime(today.year, today.month, 1)
last_month_end = first_day_of_current_month - timedelta(days=1)
last_month = last_month_end.month % 12 or 12
last_month_year = last_month_end.year if last_month_end.month != 12 else last_month_end.year - 1

# SQL query to count late orders in the last month
late_orders_query = f""""""
SELECT COUNT(*)
FROM orders
WHERE MONTH(OrderDate) = {last_month} AND YEAR(OrderDate) = {last_month_year}
AND ShippedDate > RequiredDate;
""""""

# Execute the query and retrieve the result
late_orders_df = execute_sql_query(late_orders_query)

# Show the count of late orders
count_late_orders = late_orders_df.iloc[0, 0]
show_to_user(pd.DataFrame({'Late Orders': [count_late_orders]}))
```","Both implementations determine the previous month and year correctly, accounting for the start of a new year. They also use correct SQL logic to count orders where the 'ShippedDate' is later than the 'RequiredDate' for orders placed in the last month. Both also execute the query and show the result to the user similarly.",both
"How many orders were shipped late (i.e., shipped after the required date)?","```python
import pandas as pd

# SQL query to count late orders
sql_query = ""SELECT COUNT(*) AS LateOrders FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(late_orders_df['LateOrders'][0])
```","```python
sql_query = """"""
SELECT COUNT(*) AS LateOrders 
FROM orders 
WHERE ShippedDate > RequiredDate
""""""

late_orders_df = execute_sql_query(sql_query)
show_to_user(late_orders_df)
```","The input code returns the entire DataFrame instead of extracting and displaying the specific count of late orders. The reference implementation uses 'late_orders_df['LateOrders'][0]' to access and display the count value, while the input code directly passes the DataFrame to 'show_to_user'.","```python
import pandas as pd

# SQL query to count late shipments
sql_query = """"""
SELECT COUNT(*) AS late_shipments 
FROM orders 
WHERE ShippedDate > RequiredDate;
""""""

# Execute SQL query
late_shipments_df = execute_sql_query(sql_query)

# Extract the count of late shipments
late_shipments_count = late_shipments_df['late_shipments'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'late_shipments': [late_shipments_count]}))
```",Both implement the same logic: executing a SQL query to count orders where the ShippedDate is later than the RequiredDate. The difference in variable naming and the method used to display results (an additional DataFrame in the input code) does not affect correctness.,Finetuned
Which employee has the most orders shipped on time? Display the comparison using a bar chart.,"```python
import plotly.express as px

# SQL query to get employee IDs and count of on-time orders
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OnTimeOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate <= o.RequiredDate
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using plotly express
fig = px.bar(df, x='EmployeeID', y='OnTimeOrders', title='On-Time Orders by Employee')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       COUNT(o.OrderID) AS OnTimeOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate <= o.RequiredDate
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OnTimeOrders DESC
LIMIT 10
""""""

employee_data = execute_sql_query(sql_query)

fig = px.bar(employee_data, 
              x='EmployeeName', 
              y='OnTimeOrders', 
              title='Employees with the Most Orders Shipped On Time',
              labels={'OnTimeOrders': 'Number of On Time Orders', 'EmployeeName': 'Employee Name'})
show_to_user(fig)
```","The input code fulfills the business analytics request by correctly identifying employees with the most orders shipped on time and displaying the data in a bar chart. It performs a similar SQL query to fetch the data, including joining employees and orders on EmployeeID and filtering by on-time shipping. Although it includes additional employee name fields and limits the output to the top 10 employees, the logic adheres to the request as it visualizes employees based on the number of on-time orders. The use of Plotly to create a bar chart is consistent with the reference implementation. Therefore, the code is considered correct.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OnTimeOrders 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShippedDate <= orders.RequiredDate 
GROUP BY employees.EmployeeID 
ORDER BY OnTimeOrders DESC;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Plot
fig = px.bar(df, x='EmployeeID', y='OnTimeOrders', title='On-Time Orders per Employee', labels={'OnTimeOrders':'On-Time Orders', 'EmployeeID':'Employee ID'})
show_to_user(fig)
```","The input code correctly implements the same logic as the reference code. It counts the on-time orders for each employee using a JOIN between 'employees' and 'orders' tables. The WHERE clause ensures only on-time orders are counted, and the result is grouped by 'EmployeeID'. It also orders the results by 'OnTimeOrders DESC', which doesn't affect correctness. The bar chart is generated using Plotly Express in both cases and displayed to the user.",both
What is the most frequently ordered product? Use a bar chart to show frequency counts for the top ordered products.,"```python
import plotly.express as px

# Define the SQL query to get the frequency of ordered products
sql_query = """"""
SELECT p.ProductName, COUNT(od.ProductID) AS OrderCount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY OrderCount DESC
""""""

# Execute the SQL query and retrieve the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Correcting the code: Select only the top products
df_top = df.head(10)  # Assuming we want to display top 10 products

# Create a bar chart using plotly to visualize the frequency counts for the top ordered products
fig = px.bar(df_top, x='ProductName', y='OrderCount', title='Top Ordered Products by Frequency')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
LIMIT 10
""""""
top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductID', y='TotalQuantity', title='Top Ordered Products', labels={'TotalQuantity': 'Frequency Count', 'ProductID': 'Product ID'})
show_to_user(fig)
```","The input code is not correct because it calculates the frequency of products based on the total quantity ordered, not the count of orders per product. Additionally, it doesn't join with the 'products' table to obtain product names, which is required to match the reference implementation logic. The SQL query should focus on counting the number of orders for each product, rather than summing quantities, and should include the product names for clear labeling.","```python
import plotly.express as px

# SQL query to get frequency counts of top ordered products
sql_query = """"""
SELECT ProductID, COUNT(*) AS OrderCount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart of the top ordered products
fig = px.bar(df, x='ProductID', y='OrderCount', title='Top Ordered Products')

# Display the result to the user
show_to_user(fig)
```","The provided code does not join the 'Order Details' and 'products' tables, thus it visualizes 'ProductID' instead of 'ProductName'. This leads to a mismatch with the business request which asks for product names. It also does not limit the number of products displayed, while the reference code shows the top 10.",None
Which products have a unit price greater than 50?,"```python
sql_query = ""SELECT ProductName FROM products WHERE UnitPrice > 50;""
products_df = execute_sql_query(sql_query)
show_to_user(products_df)
```","```python
sql_query = ""SELECT ProductID, ProductName, UnitPrice FROM products WHERE UnitPrice > 50;""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code retrieves more columns (ProductID, ProductName, UnitPrice) than the requested ProductName. While it includes the relevant information, it does not adhere strictly to the request for only ProductName, as demonstrated in the reference implementation.","```python
import pandas as pd

# SQL query to retrieve products with UnitPrice greater than 50
sql_query = ""SELECT ProductName FROM products WHERE UnitPrice > 50""

# Execute SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The provided code retrieves and displays products with a UnitPrice greater than 50, matching the logic of the reference implementation. The syntax and SQL logic are consistent, and the difference in variable naming (products_df vs. df) does not affect the correctness.",Finetuned
How many units of each product were ordered last month? Visualize the data using a bar chart for a clear comparison.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].Quantity) AS UnitsOrderedLastMonth 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderDate >= DATEADD(month, -1, GETDATE()) 
GROUP BY products.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='UnitsOrderedLastMonth', 
             title='Units Ordered Last Month by Product', 
             labels={'UnitsOrderedLastMonth':'Units Ordered', 'ProductID':'Product ID'})

# Display the plot to the user
show_to_user(fig)
```","```python
from datetime import datetime, timedelta
import pandas as pd
import plotly.express as px

# Calculate the first and last day of the last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to get the units of each product ordered last month
sql_query = f""""""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN Orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
  AND o.OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
GROUP BY p.ProductName
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(order_data, x='ProductName', y='TotalOrdered', title='Total Units Ordered Last Month', labels={'TotalOrdered': 'Units Ordered'})
show_to_user(fig)
```","The input code correctly calculates the number of units ordered for each product last month and visualizes the data with a bar chart. It computes the date range for last month accurately and uses similar logic to join tables and sum the quantities grouped by each product. The distinction between 'ProductID' and 'ProductName' in the grouping and visualization is the only difference, which is acceptable given it meets the business requirement of comparing products' order quantities.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS UnitsOrdered 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE DATE_FORMAT(od.OrderDate, '%Y-%m') = DATE_FORMAT(CURRENT_DATE - INTERVAL 1 MONTH, '%Y-%m') 
GROUP BY p.ProductName;
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(data, x='ProductName', y='UnitsOrdered', title='Units of Each Product Ordered Last Month')

# Show the result
show_to_user(fig)
```","The input code uses different logic for determining the last month's orders compared to the reference implementation. The reference code uses DATEADD and GETDATE functions aligned with MS SQL Server, whereas the input code uses DATE_FORMAT with CURRENT_DATE - INTERVAL for a MySQL-compatible approach. Additionally, the input code uses 'ProductName' instead of 'ProductID' for grouping and plotting, which alters the criteria for product identification.",Base
Which shipping company has the highest on-time delivery rate? A bar chart can show the on-time delivery rates for easy comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the data
sql_query = """"""
SELECT shippers.CompanyName, 
    COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / 
    CAST(COUNT(orders.OrderID) AS float) AS on_time_delivery_rate 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY on_time_delivery_rate DESC
""""""

# Execute the SQL query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the company with the highest on-time delivery rate
top_company = df.iloc[0]
show_to_user(top_company)

# Create a bar chart for on-time delivery rates
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate', 
             title='On-Time Delivery Rates by Shipping Company')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, 
       COUNT(orders.OrderID) AS total_orders,
       COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) AS on_time_orders
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

delivery_data = execute_sql_query(sql_query)
delivery_data['on_time_delivery_rate'] = delivery_data['on_time_orders'] / delivery_data['total_orders'] * 100

fig = px.bar(delivery_data, 
              x='CompanyName', 
              y='on_time_delivery_rate', 
              title='On-time Delivery Rate by Shipping Company',
              labels={'on_time_delivery_rate': 'On-time Delivery Rate (%)'},
              text='on_time_delivery_rate')

show_to_user(fig)
```",The input code does not display the company with the highest on-time delivery rate as specified in the business request. It only calculates and plots the rates without identifying or displaying the top company.,"```python
import plotly.express as px

# SQL Query to get the on-time delivery rate by shipping company
sql_query = """"""
SELECT shippers.CompanyName,
    COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
ORDER BY on_time_delivery_rate DESC
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart for the on-time delivery rates of each shipping company
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate', 
             title='On-time Delivery Rates by Shipping Company',
             labels={'on_time_delivery_rate': 'On-time Delivery Rate'},
             color='CompanyName')

# Show the figure to the user
show_to_user(fig)
```","The input code does not display the company with the highest on-time delivery rate, which is a part of the task as outlined in the reference implementation. The reference code shows the top company explicitly using `show_to_user(top_company)`, but this step is missing in the input code.",None
What is the total discount amount given for each product? Use a bar chart to display the total discount amounts.,"```python
import plotly.express as px

# SQL query to retrieve total discount amount for each product
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to display the total discount amounts
fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Total Discount Amount for Each Product')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Discount) AS TotalDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductName', y='TotalDiscount', title='Total Discount Amount per Product')
show_to_user(fig)
```","The input code calculates the total discount as the sum of discounts (SUM(od.Discount)), which is incorrect. The reference code calculates the total discount amount by multiplying the unit price, quantity, and discount (SUM(od.UnitPrice * od.Quantity * od.Discount)). The input code does not incorporate unit price and quantity, making it incorrect.","```python
import plotly.express as px

# SQL Query to get data
sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM 
    [Order Details] od 
GROUP BY 
    od.ProductID;
""""""

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(discount_data, x='ProductID', y='TotalDiscount', title='Total Discount Amount per Product')

# Show the figure to the user
show_to_user(fig)
```","The input code calculates total discounts by ProductID instead of ProductName. It doesn't join the 'products' table to retrieve ProductName, which is necessary for matching the reference logic.",None
Calculate the total number of products sold by each employee. Represent the data using a bar chart.,"```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].Quantity) AS TotalProductsSold
FROM employees
INNER JOIN orders ON employees.EmployeeID = orders.EmployeeID
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='EmployeeID', y='TotalProductsSold', title='Total Products Sold by Each Employee')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.Quantity) AS TotalProductsSold 
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, EmployeeName
ORDER BY TotalProductsSold DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='EmployeeName', y='TotalProductsSold', 
             title='Total Products Sold by Each Employee',
             labels={'TotalProductsSold': 'Total Products Sold', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code correctly calculates the total number of products sold by each employee by joining the employees, orders, and order details tables. It goes further by enhancing the SQL query to include the employee names and ordering the results by descending total products sold, which is a valid extension for better chart labeling and visibility. It finally uses Plotly to create and display a bar chart similar to the reference implementation. The logic aligns with the business request and the reference code.","```python
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalProductsSold 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID
""""""

df = execute_sql_query(sql_query)
fig = px.bar(df, x='EmployeeID', y='TotalProductsSold', title='Total Products Sold by Each Employee')
show_to_user(fig)
```","The input code is correct as it implements the same logic as the reference code. It effectively calculates the total number of products sold by each employee using SQL and represents the result using a bar chart. The SQL query correctly joins the employees, orders, and order details tables, and groups by EmployeeID to sum up the products sold. The differences, such as using table aliases (e, o, od) in the input code, do not affect the logic or output.",both
List customers who have not placed any orders in the last year.,"```python
import pandas as pd

# SQL query to list customers who have not placed any orders in the last year
sql_query = """"""
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderID IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
""""""

# Execute SQL query and retrieve data as a pandas dataframe
customer_data = execute_sql_query(sql_query)

# Remove duplicates to ensure unique customer results
unique_customer_data = customer_data.drop_duplicates()

# Display the result to the user
show_to_user(unique_customer_data)
```","```python
from datetime import datetime, timedelta

one_year_ago = (datetime.now() - timedelta(days=365)).date()

sql_query = f""""""
SELECT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID AND o.OrderDate >= '{one_year_ago}'
WHERE o.OrderID IS NULL
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly identifies customers who have not placed any orders in the last year by joining the 'customers' and 'orders' tables and filtering for NULL order IDs when the order date is within the last year. This logic matches the intent of the reference implementation, even though it uses a different method to filter dates (using the date in the JOIN clause instead of the WHERE clause). Both implementations achieve the same result.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CompanyName, ContactName, ContactTitle 
FROM customers 
WHERE CustomerID NOT IN (
    SELECT CustomerID 
    FROM orders 
    WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
);
""""""

# Execute the SQL query
customers_df = execute_sql_query(sql_query)

# Display the result
show_to_user(customers_df)
```","The input code correctly identifies customers who have not placed any orders in the last year. It uses a subquery to exclude customers with orders within the last year. This aligns with the business request and logical intention of the reference implementation, even though the SQL syntax differs slightly.",both
Identify products with a unit price greater than the average unit price across all products.,"```python
import pandas as pd

# Execute the SQL query to fetch the product data
products_df = execute_sql_query(""SELECT ProductID, ProductName, UnitPrice FROM products"")

# Calculate the average unit price
average_price = products_df['UnitPrice'].mean()

# Filter products with a unit price greater than the average
filtered_products_df = products_df[products_df['UnitPrice'] > average_price][['ProductID', 'ProductName']]

# Display the result to user
show_to_user(filtered_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice
FROM products
WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products)
""""""

products_above_average_price = execute_sql_query(sql_query)
show_to_user(products_above_average_price)
```","The input code executes an SQL query to select products with a unit price greater than the average unit price directly from the database. This achieves the same result as the reference code, which calculates the average in Python and then filters the products. Both methods correctly identify the desired products according to the business analytics request.","```python
import pandas as pd

# SQL query to identify products with a unit price greater than the average unit price
sql_query = '''
SELECT ProductName FROM products 
WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products);
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The provided code implementation uses a single SQL query to directly filter products with a unit price greater than the average, but it only selects `ProductName`. The reference implementation calculates the average price in Python and retains both `ProductID` and `ProductName` for the filtered products. Therefore, the input code does not meet the criteria for correctness as it does not adhere to the same logic as the reference implementation, specifically regarding the output structure.",Base
What is the most frequently ordered product in 2023? Use a bar chart to compare the frequencies.,"```python
import plotly.express as px

# Define SQL query to get order counts for 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, COUNT([Order Details].OrderID) AS order_count 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE YEAR([Order Details].OrderDate) = 2023
GROUP BY products.ProductID, products.ProductName 
ORDER BY order_count DESC
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ProductName', y='order_count', title='Most Frequently Ordered Products in 2023')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS order_count
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY products.ProductName
ORDER BY order_count DESC
LIMIT 10
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='ProductName', y='order_count', title='Most Frequently Ordered Products in 2023')
show_to_user(fig)
```","The input code calculates the most frequently ordered products by summing the quantities of items ordered, while the reference code counts the number of orders containing each product. This results in two different perspectives on frequency, leading to potentially different answers. Additionally, the input code limits the result to the top 10 products, which is not part of the reference code.","```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT [Order Details].ProductID, SUM([Order Details].Quantity) as total_quantity 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY [Order Details].ProductID 
ORDER BY total_quantity DESC 
LIMIT 1
""""""

# Execute query and get data
data = execute_sql_query(sql_query)

# Extract product ID and total quantity
data.columns = ['ProductID', 'TotalQuantity']
most_frequent_product = data.iloc[0]

# Create a bar chart for the most frequently ordered product
fig = px.bar(x=[most_frequent_product['ProductID']], y=[most_frequent_product['TotalQuantity']], 
             labels={'x': 'ProductID', 'y': 'TotalQuantity'}, title='Most Frequently Ordered Product in 2023')

# Show the result to user
show_to_user(fig)
```","The input code calculates the total quantity of the orders for each product, whereas the reference implementation calculates the number of orders for each product. The business request asks for the most frequently ordered product, which should be based on order counts, not total quantity ordered. Therefore, the input code does not adhere to the same logic as the reference implementation.",None
What are the names and IDs of all products that are currently out of stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;""

# Execute the SQL query to retrieve the data
out_of_stock_products = execute_sql_query(sql_query)

# Display the result
show_to_user(out_of_stock_products)
```","```python
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE UnitsInStock = 0 AND Discontinued = 0
""""""
out_of_stock_products = execute_sql_query(sql_query)
show_to_user(out_of_stock_products)
```","The evaluated code has an additional filter in the SQL query: 'AND Discontinued = 0'. This filter excludes discontinued products from the result, which differs from the reference implementation that doesn't account for the 'Discontinued' status. As a result, the two implementations do not adhere to the same logic.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE UnitsInStock = 0 AND Discontinued = 0;
""""""

# Execute the SQL query to get data
products_out_of_stock = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(products_out_of_stock)
```","The input Python code adds an additional condition in the SQL query: 'AND Discontinued = 0'. This condition filters out products that are discontinued, which is not present in the reference implementation. Therefore, the input code provides a different result and does not match the logic of the reference implementation.",None
How many products were low on stock (below reorder level) in August 2023?,"```python
import pandas as pd

# Define the SQL Query
sql_query = """"""
SELECT products.ProductID 
FROM products 
WHERE products.UnitsInStock < products.ReorderLevel 
AND MONTH(products.RecordDate) = 8 
AND YEAR(products.RecordDate) = 2023
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Count the number of products low on stock
low_stock_count = df['ProductID'].nunique()  # Use nunique to count distinct ProductIDs

# Create a result dataframe to show the count
result_df = pd.DataFrame({""LowStockCount"": [low_stock_count]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS low_stock_products
FROM products
WHERE UnitsInStock < ReorderLevel AND 
      (UnitsInStock > 0 OR UnitsOnOrder > 0)
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code does not filter by the date (August 2023), and it uses a different condition: '(UnitsInStock > 0 OR UnitsOnOrder > 0)' which is not part of the reference logic. The logic in the input code does not match the reference implementation, as it counts all products where UnitsInStock is less than ReorderLevel without considering the specific month and year.","```python
import pandas as pd

# SQL Query to find products low on stock in August 2023
sql_query = """"""
SELECT COUNT(*) as low_stock_count 
FROM products 
WHERE UnitsInStock < ReorderLevel 
AND ProductID IN (
    SELECT ProductID 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-08-01' AND '2023-08-31'
);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code counts products with low stock that were mentioned in orders during August 2023, whereas the reference implementation checks all products regardless of order activity. The input code uses an SQL subquery to filter products based on order details in August, which differs from the reference logic of checking stock levels directly by date.",None
What is the total number of products available in the inventory?,"```python
import pandas as pd

# SQL query to get the total number of products
sql_query = ""SELECT COUNT(*) as total_products FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['total_products'].iloc[0])
```","```python
sql_query = ""SELECT SUM(UnitsInStock) AS TotalProducts FROM products""
total_products_df = execute_sql_query(sql_query)
show_to_user(total_products_df)
```","The input Python code uses `SUM(UnitsInStock)` which calculates the total units in stock, not the total count of unique product entries. The reference implementation uses `COUNT(*)` which gives the number of distinct product entries. These are different computations.","```python
import pandas as pd

query = ""SELECT SUM(UnitsInStock) as TotalUnitsInStock FROM products;""
result_df = execute_sql_query(query)
total_units_in_stock = result_df.iloc[0]['TotalUnitsInStock']

show_to_user(total_units_in_stock)
```","The input code calculates the total units in stock by summing the 'UnitsInStock' values in the 'products' table, which does not directly equate to counting the number of distinct products. Instead, the reference code counts the number of products by issuing a SQL 'COUNT(*)' query, which returns the number of product entries. Therefore, the input code does not adhere to the business analytics request.",None
Which shipping company has the highest on-time delivery rate? Display the rates using a bar chart for a better comparison.,"```python
import plotly.express as px

# SQL query to retrieve the shipping company's on-time delivery data
sql_query = """"""
SELECT ShipVia, 
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipVia 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query using the provided function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly for better comparison
fig = px.bar(df, x='ShipVia', y='OnTimeDeliveryRate', title='On-Time Delivery Rate by Shipping Company', labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-Time Delivery Rate'})

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipVia, 
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    ShipVia
""""""

data = execute_sql_query(sql_query)

data['OnTimeDeliveryRate'] = data['OnTimeDeliveries'] / data['TotalOrders'] * 100

fig = px.bar(data, x='ShipVia', y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rate by Shipping Company',
             labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'})

show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate for each shipping company by dividing the count of on-time deliveries by the total orders per company. It then displays a bar chart with rates in percentage format using Plotly. The logic matches the reference implementation, even though the SQL queries differ in detail, achieving the same result.","```python
import plotly.express as px

sql_query = """"""
SELECT 
    o.ShipVia, 
    COUNT(O.OrderID) FILTER (WHERE o.ShippedDate <= o.RequiredDate) * 1.0 / COUNT(O.OrderID) AS OnTimeDeliveryRate 
FROM 
    orders o 
GROUP BY 
    o.ShipVia 
ORDER BY 
    OnTimeDeliveryRate DESC;
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='ShipVia', y='OnTimeDeliveryRate', title='On-time Delivery Rate by Shipping Company', labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-time Delivery Rate'})
show_to_user(fig)
```","The input code correctly calculates the 'OnTimeDeliveryRate' for each shipping company using a SQL query similar to the reference implementation. It uses the SQL FILTER clause instead of CASE WHEN but achieves the same filtering logic. The code plots the data using Plotly's bar chart and labels the axes correctly, matching the required output format. Therefore, it adheres to both the logic and display criteria specified in the request.",both
What are the top 5 products in terms of total units sold? Visualize the top products using a bar chart for better insights.,"```python
import plotly.express as px

# SQL query to retrieve top 5 products by total units sold
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalUnitsSold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
'''

# Execute the SQL query
df_top_products = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df_top_products, x='ProductName', y='TotalUnitsSold',
             title='Top 5 Products by Total Units Sold',
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='TotalUnitsSold', title='Top 5 Products by Total Units Sold', labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly implements the business analytics request. It executes a SQL query to retrieve the top 5 products by total units sold, groups them by product name, and orders them in descending order of total units sold. It then uses Plotly to create a bar chart for visualization. This aligns with the logic and functionality of the reference implementation.","```python
import plotly.express as px

# SQL query to get the top 5 products in terms of total units sold
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalUnitsSold DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the result as a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top products
fig = px.bar(top_products_df, x='ProductName', y='TotalUnitsSold', 
             title='Top 5 Products by Total Units Sold', 
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the business analytics request by retrieving the top 5 products based on total units sold using an SQL query. It joins the 'products' and '[Order Details]' tables, groups and orders the results by total units sold, and limits the output to the top 5 products. Furthermore, it uses Plotly Express to create and display a bar chart with the necessary labels and title, matching the steps and logic of the reference implementation, despite minor differences in variable names and SQL syntax formatting.",both
What is the monthly average shipping cost?,"```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve monthly average shipping cost
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Plot the result
fig = px.line(df, x='Month', y='AvgShippingCost', title='Monthly Average Shipping Cost')

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month,
    AVG(Freight) AS AverageShippingCost
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

average_shipping_cost_df = execute_sql_query(sql_query)
fig = px.line(average_shipping_cost_df, x='Month', y='AverageShippingCost', title='Monthly Average Shipping Cost')
show_to_user(fig)
```","The provided Python code correctly calculates the monthly average shipping cost, similarly to the reference implementation. Although it uses 'DATE_TRUNC' instead of 'DATE_FORMAT' for date manipulation, the logic remains equivalent, as both functions group by month. The SQL query and data visualization produce the expected results matching the business request.","```python
import pandas as pd

# SQL Query
sql_query = ""SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS MonthlyAvgShippingCost FROM orders GROUP BY Month;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The input code correctly executes the SQL query to calculate the monthly average shipping cost and uses a similar SQL query as the reference code. Although it does not use Plotly for visualization, it retrieves the same data required for analysis. The request for analysis is fulfilled by showing the data to the user in a tabular format, which is sufficient based on the request requirements.",both
Which employee has the highest sales in Q1 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID 
ORDER BY employee_sales DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC 
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly identifies the employee with the highest sales in Q1 2023. It includes additional details (FirstName and LastName), but this does not affect the correctness of the logic. Both the input and reference implementations calculate the total sales using the same formula and restrict the results to the specified date range. The ordering and limit ensure only the top employee by sales is returned.","```python
import pandas as pd

query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID 
ORDER BY employee_sales DESC 
LIMIT 1
""""""

df = execute_query(query)
show_to_user(df)
```","The input code performs the same task as the reference implementation. Both codes define an SQL query to calculate the total sales per employee for Q1 2023 and retrieve the employee with the highest sales. The structure and logic of the query are identical, including joining the necessary tables, calculating sales, filtering by date, grouping, ordering, and limiting the result to the top employee. The slight differences, such as function names 'execute_query' vs 'execute_sql_query', and minor formatting differences do not affect the overall correctness or logic of the implementation.",both
What is the total revenue generated from each product sold in 2022? Visualize the revenue distribution across products.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    products.ProductID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID
""""""

# Execute the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Ensure ProductID is treated as a string for visualization purposes
data['ProductID'] = data['ProductID'].astype(str)

# Visualize the revenue distribution across products
fig = px.bar(data, x='ProductID', y='total_revenue', title='Total Revenue by Product in 2022')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID, products.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='total_revenue', 
             title='Total Revenue per Product in 2022', 
             labels={'total_revenue': 'Total Revenue', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly calculates the total revenue for each product sold in 2022 and provides a visualization similar to the reference implementation. The main difference is the inclusion of the 'ProductName' in the query and visualization, but this does not alter the correctness of the logic. Both implementations correctly sum the revenue by ProductID for the specified time period and visualize the results using a bar chart.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT [Order Details].ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN orders 
ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY [Order Details].ProductID;
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Visualize the revenue distribution across products
fig = px.bar(data, x='ProductID', y='total_revenue', title='Revenue Distribution Across Products in 2022')
show_to_user(fig)
```","The input Python code produces a similar plot but has an inconsistency with the reference code. It does not join the 'products' table, which could affect the aggregation and produce incorrect total revenues for each ProductID. Without joining the 'products' table, there could be inconsistencies if ProductID labels differ between tables.",Base
What is the most ordered product in terms of quantity?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
    SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantityOrdered 
    FROM [Order Details] 
    JOIN products 
    ON [Order Details].ProductID = products.ProductID 
    GROUP BY products.ProductName 
    ORDER BY TotalQuantityOrdered DESC 
    LIMIT 1;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

most_ordered_product = execute_sql_query(sql_query)
show_to_user(most_ordered_product)
```","The input Python code correctly implements the request as it matches the reference implementation's logic. Both codes query the necessary tables to find the most ordered product by summing quantities and ordering the results in descending order, then selecting the top result. The syntax and logic in the input code align with the reference code, meaning it satisfies the business analytics requirement.","```python
import pandas as pd

# SQL query to find the most ordered product in terms of quantity
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalQuantity DESC 
LIMIT 1;
""""""

# Execute the SQL query
most_ordered_product_df = execute_sql_query(sql_query)

# Display the result
show_to_user(most_ordered_product_df)
```","The input code does not correctly implement the logic of the reference code. The input version only retrieves the ProductID with the highest total quantity but fails to join with the products table to obtain the ProductName, hence not identifying the product by name as required by the business analytics request and the reference implementation.",Base
How many products have less than 10 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID FROM products WHERE UnitsInStock < 10;""

# Execute the query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Count the number of products with less than 10 units in stock
product_count = len(df)

# Display the result to the user
show_to_user(product_count)
```","```python
sql_query = ""SELECT COUNT(*) AS ProductsWithLowStock FROM products WHERE UnitsInStock < 10""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly implements the logic to count the products with less than 10 units in stock. It uses a SQL query to count the number of products directly in the database and then uses `show_to_user` to display the results. Although the reference implementation retrieves IDs and counts them in Python, the input code achieves the same goal more efficiently by using SQL's COUNT function.","```python
import pandas as pd

# SQL query to select products with less than 10 units in stock
query = ""SELECT ProductName FROM products WHERE UnitsInStock < 10;""

# Execute the query
df = execute_sql_query(query)

# Display the dataframe or the product names
show_to_user(df)
```","The input code does not count the number of products with less than 10 units in stock. It fetches the product names and displays the DataFrame, rather than counting the entries as done in the reference implementation.",Base
List the top 5 products with the highest total sales revenue. Visualize the sales revenue comparison among these products.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID, products.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Visualize the sales revenue comparison among the top 5 products
fig = px.bar(top_products_df, 
             x='ProductName', 
             y='TotalSales', 
             title='Top 5 Products by Total Sales Revenue', 
             labels={'TotalSales': 'Total Sales Revenue', 'ProductName': 'Product Name'})

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 5
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x=""ProductName"", y=""TotalSales"", 
             title=""Top 5 Products by Total Sales Revenue"", 
             labels={""TotalSales"": ""Total Sales Revenue"", ""ProductName"": ""Product Name""})
show_to_user(fig)
```","The input code is correct as it follows the same logic as the reference implementation. Both codes perform an SQL query to select the top 5 products by total sales revenue, using the same calculation method for TotalSales. The visualization part also uses Plotly to create a bar chart with the same parameters. The use of variable names in the SQL query and subsequent steps are consistent and achieve the requested business analytics task.","```python
import plotly.express as px

# SQL query to fetch top 5 products with the highest total sales revenue
sql_query = """"""
SELECT od.ProductID, p.ProductName, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY od.ProductID 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the data as a DataFrame
top_products_df = execute_sql_query(sql_query)

# Visualize the sales revenue comparison among these products
fig = px.bar(top_products_df, x='ProductName', y='TotalSales', title='Top 5 Products by Total Sales Revenue')
show_to_user(fig)
```","The input code's SQL query groups by 'od.ProductID' but not by 'p.ProductName', which can lead to incorrect results if multiple products have the same ID but different names in the 'products' table. The reference code groups by both 'ProductID' and 'ProductName', ensuring each product is uniquely identified by both fields. Therefore, the input code does not adhere to the same logical structure as the reference code.",Base
Which products have the highest and lowest inventory turnover ratio? Visualize the turnover ratios for comparison.,"```python
import plotly.express as px

# Define the SQL query to get inventory turnover ratios
sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    p.ProductName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort to find the highest and lowest inventory turnover ratios
sorted_df = df.sort_values(by='InventoryTurnoverRatio', ascending=False)

# Filter for products with the highest and lowest inventory turnover ratios
highest_df = sorted_df.head(1)
lowest_df = sorted_df.tail(1)
comparison_df = highest_df.append(lowest_df)

# Visualize the turnover ratios for comparison
fig = px.bar(comparison_df, x='ProductName', y='InventoryTurnoverRatio', title='Highest and Lowest Inventory Turnover Ratios for Products')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName,
    SUM(od.Quantity * od.UnitPrice) AS Sales,
    AVG(p.UnitsInStock) AS Average_Inventory,
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS Inventory_Turnover_Ratio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

turnover_data = execute_sql_query(sql_query)

highest_turnover = turnover_data.loc[turnover_data['Inventory_Turnover_Ratio'].idxmax()]
lowest_turnover = turnover_data.loc[turnover_data['Inventory_Turnover_Ratio'].idxmin()]

turnover_data['Turnover_Status'] = turnover_data['Inventory_Turnover_Ratio'].apply(lambda x: 'High' if x == highest_turnover['Inventory_Turnover_Ratio'] else ('Low' if x == lowest_turnover['Inventory_Turnover_Ratio'] else 'Medium'))

fig = px.bar(turnover_data, x='ProductName', y='Inventory_Turnover_Ratio', color='Turnover_Status', title='Inventory Turnover Ratios Comparison')
show_to_user(fig)
```","The input code computes and visualizes all inventory turnover ratios with color distinctions for high, low, and medium. The reference code focuses only on visualizing the highest and lowest ratios. The input provides a broader analysis by making distinctions between the turnover statuses for all products, differing in the visualization logic from the reference code.","```python
import plotly.express as px

# SQL queries
sql_turnover = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID;
""""""
sql_extremes = """"""
SELECT ProductName, InventoryTurnoverRatio 
FROM (
    SELECT ProductName, InventoryTurnoverRatio, 
    ROW_NUMBER() OVER (ORDER BY InventoryTurnoverRatio DESC) as Rank 
    FROM (SELECT p.ProductName, 
                 SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
          FROM products p 
          JOIN [Order Details] od ON p.ProductID = od.ProductID 
          GROUP BY p.ProductID) x
) y 
WHERE Rank = 1 OR Rank = (SELECT COUNT(*) FROM products)
""""""

# Execute SQL query to get data
turnover_df = execute_sql_query(sql_turnover)
extreme_df = execute_sql_query(sql_extremes)

# Find highest and lowest turnover products
highest_lowest_df = extreme_df.sort_values(by='InventoryTurnoverRatio').head(2)

# Visualize inventory turnover ratios for comparison
fig = px.bar(turnover_df, x='ProductName', y='InventoryTurnoverRatio', 
             title=""Inventory Turnover Ratios by Product"",
             labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

# Display the results
show_to_user(fig)
show_to_user(highest_lowest_df)
```","The input code uses two queries: one for calculating turnover ratios and another for finding the extremes, using window functions and separate queries. The reference code combines these into one query and sorts results directly. Additionally, the input code visualizes the entire dataset instead of just the highest and lowest products. Visualization of 'extreme_df' in the input code should match the comparison in the reference code, which it currently does not.",None
Identify employees with the highest and lowest order counts. Visualize the order counts for each employee.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1 
UNION 
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount ASC 
LIMIT 1;
""""""

# Execute the query
employees_df = execute_sql_query(sql_query)

# Adjust FirstName for proper visualization if multiple employees have the same name
employees_df['FullName'] = employees_df['FirstName'] + ' ' + employees_df['LastName']

# Generate a bar plot for order counts
fig = px.bar(employees_df, x='FullName', y='OrderCount', color='OrderCount', 
             title='Order Counts for Employees with Highest and Lowest Orders')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC;
""""""

employee_order_counts = execute_sql_query(sql_query)

highest_order_count = employee_order_counts.iloc[0]
lowest_order_count = employee_order_counts.iloc[-1]

fig = px.bar(employee_order_counts, x='FirstName', y='OrderCount', 
              title='Order Counts by Employee',
              labels={'FirstName': 'Employee', 'OrderCount': 'Number of Orders'})

show_to_user(fig)

print(f""Employee with highest order count: {highest_order_count.FirstName} {highest_order_count.LastName} - {highest_order_count.OrderCount} orders"")
print(f""Employee with lowest order count: {lowest_order_count.FirstName} {lowest_order_count.LastName} - {lowest_order_count.OrderCount} orders"")
```","The input code retrieves all employees' order counts and visualizes all of them, while the reference code only retrieves and visualizes the highest and lowest order counts. Additionally, the input code uses LEFT JOIN instead of JOIN which could result in showing employees with zero orders, deviating from the reference implementation intent.","```python
import pandas as pd
import matplotlib.pyplot as plt

# SQL query to get order counts per employee
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
""""""

# Execute the query and get the data
df = execute_sql_query(sql_query)

# Identify employees with highest and lowest order counts
highest_order_count = df['OrderCount'].max()
lowest_order_count = df['OrderCount'].min()
employees_high_low = df[(df['OrderCount'] == highest_order_count) | (df['OrderCount'] == lowest_order_count)]

# Display the result
show_to_user(employees_high_low)

# Visualize the order counts for each employee
plt.figure(figsize=(10, 6))
plt.bar(df['EmployeeID'].astype(str), df['OrderCount'], color='skyblue')
plt.xlabel('Employee ID')
plt.ylabel('Order Count')
plt.title('Order Counts per Employee')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()
```","The provided code does not correctly identify employees with the highest and lowest order counts as required. The code aggregates order counts per employee and visualizes all counts but doesn't specifically fetch the highest and lowest order counts in one result set like the reference. The visualization also differs slightly, as it should only show employees with the highest and lowest order counts, not all employees. Lastly, there's no adjustment for handling multiple employees with the same name, which the reference code does consider.",None
Which employee handled the most orders?,"```python
import pandas as pd

# SQL query to get the EmployeeID with the most orders
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Since we need only EmployeeID, extract it from the dataframe
most_orders_employee = result_df['EmployeeID'].iloc[0]

# Display the EmployeeID to the user
show_to_user(most_orders_employee)
```","```python
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
""""""

most_orders_employee = execute_sql_query(sql_query)
show_to_user(most_orders_employee)
```","The input code doesn't extract the 'EmployeeID' from the result of the SQL query. In the reference implementation, there is a step to extract 'EmployeeID' using 'iloc[0]', which is missing in the input code. Without this step, 'most_orders_employee' may contain a DataFrame or structure instead of just the 'EmployeeID' value.","```python
import pandas as pd

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1
""""""

df = execute_sql_query(sql_query)

show_to_user(df)
```","The input code outputs the entire DataFrame, whereas the reference code extracts only the 'EmployeeID' from the result. The input code does not specifically retrieve and display only the EmployeeID that handled the most orders, which is required to meet the business request as per the reference implementation.",None
Calculate the average lead time for each supplier in delivered products. Visualize the lead times to compare suppliers.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT suppliers.SupplierID, CompanyName, 
AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, CompanyName;
""""""

# Execute SQL query and get the data
data = execute_sql_query(sql_query)

# Create a bar plot of average lead time per supplier
fig = px.bar(data, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    s.SupplierID,
    s.CompanyName,
    AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    s.SupplierID, s.CompanyName
""""""

lead_time_df = execute_sql_query(sql_query)

fig = px.bar(lead_time_df, x='CompanyName', y='AverageLeadTime', 
             title='Average Lead Time by Supplier', 
             labels={'AverageLeadTime':'Average Lead Time (Days)', 'CompanyName':'Supplier Company'})
show_to_user(fig)
```","The input code correctly calculates the average lead time for each supplier using the same logic as the reference implementation. It uses a similar SQL query to retrieve the data by joining the necessary tables and calculating the average lead time. The visualization uses Plotly to create a bar chart that displays average lead time by supplier, which aligns with the reference implementation's approach. Differences, such as the usage of aliases for table names and labels in the visualization, do not affect the correctness of the logic.","```python
import plotly.express as px
import pandas as pd

sql_query = """"""
SELECT s.SupplierID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS LeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON o.OrderID = od.OrderID
GROUP BY s.SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the lead times to compare suppliers
fig = px.bar(df, x='SupplierID', y='LeadTime', title='Average Lead Time per Supplier', labels={'LeadTime': 'Average Lead Time'})
show_to_user(fig)
```","The input code does not include the 'CompanyName' in the SQL query, unlike the reference code, which uses it in both the SELECT statement and the GROUP BY clause. This results in a plot indexing by 'SupplierID' instead of 'CompanyName', which deviates from the requested and reference logic of visualizing lead times by supplier name.",Base
What is the average discount given in orders for the year 2023?,"```python
sql_query = """"""
SELECT AVG([Order Details].Discount) AS avg_discount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute SQL query to get the average discount
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT AVG([Order Details].Discount) AS average_discount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```",The input Python code is conceptually and logically equivalent to the reference implementation. It correctly calculates the average discount on orders placed in 2023 by executing an SQL query that matches the reference logic with only minor differences in aliasing (using 'average_discount' instead of 'avg_discount'). These differences do not affect the correctness of the code. Both implementations execute the query and display the result properly.,"```python
import pandas as pd

# SQL query to get the average discount for orders in 2023
sql_query = """"""
SELECT AVG(discount) AS avg_discount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['avg_discount'].iloc[0])
```","The input code correctly computes the average discount for orders in 2023 using the same SQL logic as the reference code. Both codes perform the required JOIN operation and filter orders by the specified date range. The input code goes further to extract and display the average discount value, which adheres to the business request.",both
What is the average order fulfillment time by month? Visualize the monthly fulfillment times.,"```python
import plotly.express as px

# SQL query to fetch required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgOrderFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'Month' to string to ensure proper sorting by month
df['Month'] = df['Month'].astype(str)

# Create line plot using Plotly
fig = px.line(df, x='Month', y='AvgOrderFulfillmentTime', title='Average Order Fulfillment Time by Month')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='Month', y='AverageFulfillmentTime', 
              title='Average Order Fulfillment Time by Month', 
              labels={'AverageFulfillmentTime': 'Average Fulfillment Time (Days)', 
                      'Month': 'Month'})
show_to_user(fig)
```","The input Python code correctly implements the requested business analytics task. It retrieves the average order fulfillment time by month using an SQL query, and visualizes the result using Plotly. The logic of grouping by 'Month' and calculating the average difference between 'ShippedDate' and 'OrderDate' matches the reference implementation. The use of labels in the plot enhances readability but does not change the correctness of the logic.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Visualize the monthly fulfillment times
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Month')
show_to_user(fig)
```","The input code correctly executes a SQL query to calculate the average order fulfillment time by month, similar to the reference code. It uses DATE_FORMAT to group by month and calculates the difference between ShippedDate and OrderDate using AVG and DATEDIFF. The visualization is created using Plotly with the correct axes and title, matching the logic and purpose of the reference code.",both
What is the total revenue generated by each employee? Visualize employee contribution to revenue.,"```python
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY EmployeeID;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using plotly to visualize employee contribution to revenue
fig = px.bar(df, x='EmployeeID', y='TotalRevenue', title='Employee Contribution to Revenue')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = '''
SELECT 
    o.EmployeeID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.EmployeeID
'''

# Execute the SQL query
employee_revenue_df = execute_sql_query(sql_query)

# Visualize employee contribution to revenue
fig = px.bar(employee_revenue_df, x='EmployeeID', y='TotalRevenue', 
             title='Total Revenue Generated by Each Employee', 
             labels={'EmployeeID': 'Employee ID', 'TotalRevenue': 'Total Revenue'})
show_to_user(fig)
```","Both implementations perform the same SQL query to calculate the total revenue generated by each employee and visualize the result using a bar chart. They join the 'orders' table with the 'Order Details' table, calculate revenue with SUM(UnitPrice * Quantity * (1 - Discount)), group by EmployeeID, and use Plotly to create a bar chart. Despite minor differences in variable names and label enhancements, the logic aligns perfectly with the reference.","```python
import plotly.express as px

# SQL query to get the total revenue generated by each employee
sql_query = """"""
SELECT 
    o.EmployeeID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY 
    o.EmployeeID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Visualize employee contribution to revenue
fig = px.bar(data, x='EmployeeID', y='TotalRevenue', title='Total Revenue by Employee')

# Display the result using the provided utility function
show_to_user(fig)
```",The input code correctly calculates the total revenue generated by each employee using the same logic as the reference code. Both codes execute a SQL query to aggregate revenue data by EmployeeID and utilize Plotly to create a bar chart visualizing the results. The differences in table aliasing ('o' and 'od') and chart title do not affect functionality or correctness with respect to the business analytics request.,both
Find the total freight cost incurred in the year 2023.,"```python
import pandas as pd

# Execute the SQL query to get the data
result_df = execute_sql_query(""SELECT SUM(Freight) AS TotalFreightCost2023 FROM orders WHERE YEAR(OrderDate) = 2023;"")

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE YEAR(OrderDate) = 2023
""""""

total_freight_cost = execute_sql_query(sql_query)
show_to_user(total_freight_cost)
```",The input code and the reference implementation both execute a SQL query to calculate the total freight cost for the year 2023 using the SUM function and apply a filter on the OrderDate. The logic and the functionality are the same as requested. The output is then shown using a similar display function.,"```python
import pandas as pd

# SQL query to calculate total freight cost for 2023
sql_query = """"""
SELECT SUM(o.Freight) AS TotalFreight 
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","Both the reference code and the input code aim to calculate the total freight cost for the year 2023. The reference code uses the `YEAR(OrderDate) = 2023` condition, while the input code uses a date range `BETWEEN '2023-01-01' AND '2023-12-31'`. Both approaches are logically correct for extracting orders within the year 2023. Therefore, the input code is correct relative to the reference implementation for the given task.",both
Identify which month has the highest number of orders historically. Visualize the order count by month.,"```python
import plotly.express as px

# SQL query to get order counts by month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Visualize order count by month
fig = px.bar(order_data, x='Month', y='OrderCount', title='Order Count by Month')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS year, EXTRACT(MONTH FROM OrderDate) AS month, COUNT(OrderID) AS order_count
FROM orders
GROUP BY year, month
ORDER BY year, month;
""""""

order_counts = execute_sql_query(sql_query)

monthly_order_counts = order_counts.groupby(['year', 'month']).sum().reset_index()

fig = px.bar(monthly_order_counts, x='month', y='order_count', title='Order Count by Month', labels={'order_count': 'Number of Orders', 'month': 'Month'})
show_to_user(fig)

highest_month = monthly_order_counts.loc[monthly_order_counts['order_count'].idxmax()]
highest_month_info = f""Year: {highest_month['year']}, Month: {highest_month['month']}, Orders: {highest_month['order_count']}""
highest_month_info
```","The input code does not directly align with the reference implementation. It extracts and groups by both year and month, instead of just formatting the date to aggregate by month. This results in incorrect aggregation, splitting same-month data across different years. Furthermore, the calculation of the month with the highest order count is performed differently—it combines data across multiple years, which deviates from the business request to identify the single month historically with the most orders regardless of year. The visualization also labels the x-axis as 'month' when it should represent distinct 'Year-Month' combinations.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get order count by month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY OrderMonth
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query
order_count_df = execute_sql_query(sql_query)

# Identify the month with the highest number of orders
max_order_month = order_count_df.iloc[0]

# Display the month with the highest number of orders
show_to_user(max_order_month)

# Visualize the order count by month
fig = px.bar(order_count_df, x='OrderMonth', y='OrderCount', title='Order Count by Month')
show_to_user(fig)
```","The input code correctly addresses the business analytics request by identifying the month with the highest number of orders using the SQL query that sorts the result in descending order. This ensures that the month with the highest order count is selected correctly. The code also visualizes the order count by month using Plotly Express, which is consistent with the reference implementation's logic. Despite slight differences, such as ordering and explicit identification of the max month, the logic and purpose align with the reference.",Finetuned
Calculate the average number of products per order.,"```python
import pandas as pd

# Define the SQL query to calculate the average number of products per order
sql_query = ""SELECT AVG(od.Quantity) AS AverageProductsPerOrder FROM [Order Details] od;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Correctly extract the average products per order from the result dataframe
average_products_per_order = result_df['AverageProductsPerOrder'][0]

# Display the result
show_to_user(pd.DataFrame({'Average Products Per Order': [average_products_per_order]}))
```","```python
sql_query = """"""
SELECT AVG(product_count) AS average_products_per_order
FROM (
    SELECT o.OrderID, COUNT(od.ProductID) AS product_count
    FROM orders o
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    GROUP BY o.OrderID
) AS product_counts
""""""

average_products_per_order = execute_sql_query(sql_query)
show_to_user(average_products_per_order)
```","The input Python code correctly calculates the average number of products per order. It first calculates the number of products per order by counting distinct ProductIDs for each OrderID, then calculates the average of these counts, which aligns with the logic of the reference implementation, despite a different SQL query structure.","```python
import pandas as pd

# SQL query to execute
sql_query = """"""
SELECT COUNT([Order Details].ProductID) / COUNT(orders.OrderID) AS AverageProductsPerOrder
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID;
""""""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Extract the average value from the result dataframe
average_products_per_order = df_result.iloc[0, 0]

# Display the average number of products per order to the user
show_to_user(pd.DataFrame({'AverageProductsPerOrder': [average_products_per_order]}))
```","The input code calculates the average by dividing the total number of products by the total number of distinct orders, which is not the same logic as the reference implementation. The reference code computes the average quantity per order line directly.",Base
Which product has the highest total sales in 2022?,"```python
import pandas as pd

# SQL Query to retrieve the product with the highest total sales in 2022
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID 
ORDER BY total_sales DESC 
LIMIT 1
""""""

# Execute the SQL query and retrieve the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = 2022
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The provided code does not join '[Order Details]' with 'products,' which is necessary to identify products by 'ProductID.' As a result, it does not adhere to the same logic as the reference implementation. The omission of this join may lead to errors or incorrect outputs since 'ProductName' is selected and grouped but not linked from the 'products' table.","```python
import pandas as pd

query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN orders o ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = 2022 
GROUP BY od.ProductID 
ORDER BY TotalSales DESC 
LIMIT 1;
""""""

result_df = execute_sql_query(query)
show_to_user(result_df)
```","The provided code correctly retrieves the product with the highest total sales in 2022. It mirrors the logic of the reference implementation by joining the 'Order Details' with 'orders' to filter for the year 2022, calculating total sales, grouping by ProductID, and ordering by total sales in descending order to select the highest. The use of YEAR function to filter by date and the SQL structure is correct, despite syntactical differences from the reference SQL query.",Finetuned
How many orders were placed in each quarter of 2022? Visualize the quarterly order distribution.,"```python
import plotly.express as px

# SQL query to get the number of orders per quarter for 2022
sql_query = """"""
SELECT QUARTER(orders.OrderDate) AS order_quarter, COUNT(orders.OrderID) AS total_orders
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY order_quarter
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the dataframe by order_quarter to ensure the correct order in visualization
df = df.sort_values(by='order_quarter')

# Create a bar chart to visualize the quarterly order distribution
fig = px.bar(df, x='order_quarter', y='total_orders', title='Quarterly Orders Distribution in 2022',
             labels={'order_quarter': 'Quarter', 'total_orders': 'Total Orders'})

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATEPART(QUARTER, OrderDate) AS quarter, 
    COUNT(OrderID) AS order_count 
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY 
    DATEPART(QUARTER, OrderDate) 
ORDER BY 
    quarter
""""""

order_data = execute_sql_query(sql_query)

fig = px.bar(order_data, x='quarter', y='order_count', 
             labels={'quarter': 'Quarter', 'order_count': 'Number of Orders'},
             title='Quarterly Order Distribution in 2022')
show_to_user(fig)
```","The input Python code correctly answers the business analytics request. It uses a SQL query to count the number of orders per quarter for the year 2022, just like the reference implementation. The logical steps align with the reference: it selects orders within the specified date range, groups them by quarter, and counts them. The 'DATEPART(QUARTER, OrderDate)' function is equivalent to 'QUARTER(orders.OrderDate)' in the reference. The data visualization part uses Plotly to display a bar chart of quarterly distribution, which also matches the reference implementation. The order of operations and overall logic are consistent between both implementations, leading to correct results despite slight differences in SQL syntax due to possible differences in SQL dialects.","```python
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT QUARTER(OrderDate) AS Quarter, COUNT(OrderID) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = 2022
GROUP BY QUARTER(OrderDate);
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Create a visualization of the quarterly order distribution
fig = px.bar(df_orders, x='Quarter', y='OrderCount', title='Quarterly Order Distribution for 2022')

# Show the result to the user
show_to_user(fig)
```","Both implementations accurately count the number of orders per quarter for the year 2022. The input code uses 'YEAR(OrderDate) = 2022' which is equivalent to specifying the date range in the reference code. The visualization part is correct in structure and intent, displaying the quarterly distribution using a bar chart. Both codes sort or inherently keep the quarters in order within the visualization process.",both
How many unique customers placed orders in the last quarter?,"```python
import pandas as pd

# Define the SQL query to get unique customer IDs
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders
WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE());
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Count the unique customers
unique_customers_count = len(result_df['CustomerID'].unique())

# Display the result to the user
show_to_user(pd.DataFrame({'unique_customers': [unique_customers_count]}))
```","```python
import pandas as pd

# Define the start and end dates for the last quarter
end_date = pd.to_datetime('today').normalize()
start_date = (end_date - pd.DateOffset(months=3)).normalize()

# SQL query to get the count of unique customers who placed orders in the last quarter
sql_query = f""""""
SELECT COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM orders
WHERE OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}'
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input Python code correctly calculates the number of unique customers who placed orders in the last quarter. It defines the date range for the last quarter using pandas, constructs an SQL query to count distinct customer IDs within that range, and executes it. Although it uses COUNT(DISTINCT CustomerID) within the SQL query, this is equivalent to the reference implementation, which counts unique customer IDs after retrieving them. Both approaches yield the same result, fulfilling the business request.","```python
import pandas as pd

sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) as unique_customers 
FROM orders 
WHERE OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 3 MONTH) AND CURDATE();
""""""

df = execute_sql_query(sql_query)
show_to_user(df['unique_customers'].iloc[0])
```","Both implementations correctly identify the number of unique customers who placed orders in the last quarter. The provided code uses SQL to count distinct CustomerID entries directly, which is equivalent to calculating the length of unique CustomerIDs as in the reference code. The use of `DATE_SUB(CURDATE(), INTERVAL 3 MONTH) AND CURDATE()` is equivalent to `DATEADD(MONTH, -3, GETDATE())` in terms of functionality in SQL, ensuring it's computing over the last three months correctly. Therefore, the logic is consistent with the request and the reference.",both
What are the top three products that generate the most sales revenue? Visualize their sales revenue for comparison.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the query to get data
data = execute_sql_query(sql_query)

# Ensure the dataframe has columns in the correct case
data.columns = ['ProductID', 'TotalRevenue']

# Create a bar chart for visualization
fig = px.bar(data, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalRevenue DESC
LIMIT 3
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue', labels={'TotalRevenue':'Sales Revenue', 'ProductID':'Product ID'})
show_to_user(fig)
```","The input code replicates the same logic as the reference code by calculating the top three products with the highest sales revenue from the 'Order Details' table. It selects ProductID and calculates TotalRevenue using the same formula. While it includes a join with the 'orders' table, this does not affect the result as long as 'OrderID' is consistent. Finally, the visualization part is handled similarly, producing a bar chart of the top products by sales revenue.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Visualization
fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Top 3 Products by Sales Revenue')
show_to_user(fig)
```","The input code correctly determines the top three products based on sales revenue, similar to the reference code. The key difference is that the input code includes a join with the 'products' table to retrieve 'ProductName' instead of 'ProductID'. This alteration doesn't affect the correctness of the task, as the request was for the top products by revenue, which the input code achieves. Both codes sum the total revenue from sales, sort them in descending order, and limit the results to the top 3, which aligns with the business analytics request.",both
What are the names of products that have been discontinued?,"```python
import pandas as pd

# SQL Query to get discontinued products
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query to retrieve the dataframe
discontinued_products_df = execute_sql_query(sql_query)

# Display the names of products that have been discontinued
show_to_user(discontinued_products_df['ProductName'])
```","```python
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE Discontinued = 1
""""""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code correctly retrieves the names of products that have been discontinued by querying the database for products where the 'Discontinued' field is 1. It then shows this information to the user. The logic and purpose align with the reference implementation, despite the difference in display code. Both use a potential function like 'show_to_user()' to show the data.","```python
import pandas as pd

sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code uses 'show_to_user(discontinued_products)' instead of 'show_to_user(discontinued_products['ProductName'])'. The reference implementation specifically extracts the 'ProductName' column, while the input code may not isolate this column correctly if the 'execute_sql_query' returns a DataFrame containing more than one column.",Base
Which supplier has supplied the most quantity of products?,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT SupplierID, SUM(UnitsOnOrder) AS TotalQuantitySupplied 
FROM products 
GROUP BY SupplierID 
ORDER BY TotalQuantitySupplied DESC 
LIMIT 1;
""""""

# Execute SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Correctly display just the SupplierID
max_supplier_id = result_df['SupplierID'].iloc[0]

# Display the SupplierID to the user
show_to_user(max_supplier_id)
```","```python
sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The business request asks for the supplier with the most quantity of products supplied, which should be based on `UnitsOnOrder` from the `products` table. However, the input code calculates the sum of `Quantity` from the `[Order Details]` table after joining with `products`. This does not adhere to the reference implementation's logic, which only considers the `UnitsOnOrder` from `products`. Therefore, the logic is not equivalent.","```python
import pandas as pd

# SQL Query to fetch the supplier with the most quantity supplied
sql_query = """"""
SELECT products.SupplierID, 
       SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.SupplierID 
ORDER BY TotalQuantity DESC 
LIMIT 1;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input code uses a different table and column 'Order Details.Quantity' for summing up the total quantity, as opposed to 'products.UnitsOnOrder' in the reference code. This suggests a different data source or logical approach, hence not directly comparable to the reference logic.",None
Determine the average discount given by each employee.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, 
       e.FirstName, 
       e.LastName, 
       AVG od.Discount AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code calculates the average discount given by each employee by grouping on EmployeeID, FirstName, and LastName. Although the input code includes additional columns (FirstName, LastName) compared to the reference code, it follows the same logic and answers the requested task of determining the average discount per employee. The inclusion of these columns does not affect the correctness regarding the business request.","```python
import pandas as pd

sql_query = """"""
SELECT e.EmployeeID, AVG(od.Discount) AS AverageDiscount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code uses the same SQL query as the reference implementation to calculate the average discount by employee. It selects EmployeeID and calculates the average discount from joined tables 'employees', 'orders', and 'Order Details'. Both scripts execute the query, store the result in a DataFrame, and display it using the 'show_to_user' function. The logic and outcome of the input code are the same as the reference, so the code is correct.",both
Which month had the highest number of orders placed? Provide a visualization to compare monthly order volumes.,"```python
import plotly.express as px

# Query to get monthly order counts
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
ORDER BY Month
""""""

# Execute the SQL query
monthly_order_data = execute_sql_query(sql_query)

# Find the month with the highest number of orders
highest_order_month = monthly_order_data.loc[monthly_order_data['OrderCount'].idxmax()]

# Visualize monthly order volumes
fig = px.bar(monthly_order_data, x='Month', y='OrderCount', 
             title=f""Monthly Order Volumes (Highest: {highest_order_month['Month']})"", 
             labels={'OrderCount': 'Number of Orders'})

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY OrderCount DESC
""""""

monthly_orders = execute_sql_query(sql_query)
highest_month = monthly_orders.iloc[0]

fig = px.bar(monthly_orders, x='Month', y='OrderCount', title='Monthly Order Volumes')
show_to_user(fig)
```","The input code is incorrect because it orders the SQL query results by 'OrderCount DESC', selecting the month with the highest orders as the first entry. However, it does not annotate the chart with this information, unlike the reference code that annotates the title with the highest month. Additionally, the input code does not ensure the visualization's x-axis (Month) is ordered chronologically. The reference code orders by 'Month' to maintain logical sequence of time.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, COUNT(OrderID) as OrderCount
FROM orders
GROUP BY Month;
""""""

# Execute SQL query
order_data = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(order_data, x='Month', y='OrderCount', title='Monthly Order Volume')
show_to_user(fig)
```","The input code is missing the identification of the month with the highest number of orders, which is part of the business request. It also doesn't dynamically update the title with this information, unlike the reference code.",None
Retrieve the contact information for all suppliers located in a specific region.,"```python
import pandas as pd

# Define the specific region
specified_region = 'specified_region'

# Create the SQL query
sql_query = f""""""
SELECT SupplierID, CompanyName, ContactName, Phone, City, Region
FROM suppliers
WHERE Region = '{specified_region}';
""""""

# Execute the SQL query and retrieve the data
suppliers_df = execute_sql_query(sql_query)

# Display the retrieved data
show_to_user(suppliers_df)
```","```python
region = ""specific_region""  # Replace with the desired region
sql_query = f""""""
SELECT CompanyName, ContactName, ContactTitle, Address, City, Region, PostalCode, Country, Phone, Fax, HomePage 
FROM suppliers 
WHERE Region = '{region}';
""""""
supplier_data = execute_sql_query(sql_query)
show_to_user(supplier_data)
```","The evaluated code fulfills the business analytics request by querying suppliers from a specific region. It retrieves similar contact information, albeit with more columns compared to the reference code. The core operation and logic of querying suppliers by region remain consistent with the reference implementation.","```python
import pandas as pd

# Define parameter for the region
region = 'specific_region'

# SQL query to retrieve contact information for all suppliers located in a specific region
sql_query = f""SELECT CompanyName, ContactName, Phone FROM suppliers WHERE Region = '{region}';""

# Execute SQL query
suppliers_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(suppliers_data)
```","The input code defines the region variable differently ('specific_region' instead of 'specified_region'). Additionally, the input code does not select the SupplierID, City, and Region fields which are included in the reference implementation. This means an incomplete dataset is retrieved compared to what is defined in the reference code.",Base
Calculate the discount amount for each order in January 2023.,"```python
import pandas as pd

# SQL query to fetch the required data
sql_query = """"""
SELECT o.OrderID, SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY o.OrderID;
""""""

# Execute the SQL query to get the results in a dataframe
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    o.OrderID,
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
GROUP BY 
    o.OrderID
""""""

discount_data = execute_sql_query(sql_query)
show_to_user(discount_data)
```","The provided input code correctly calculates the discount amount for each order in January 2023. It uses a SQL query similar to the reference implementation, with the only difference being the boundary condition in the WHERE clause. Instead of using 'BETWEEN', the input code uses '>=' and '<', which is logically equivalent for the date range specified. Thus, the logic adheres to the business analytics request.","```python
import pandas as pd

# SQL query to retrieve discount information for orders in January 2023
sql_query = """"""
SELECT [Order Details].OrderID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS DiscountAmount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31' 
GROUP BY [Order Details].OrderID;
""""""

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discount_data)
```","Both the input and reference code successfully calculate the discount amount for each order in January 2023 by joining the 'Order Details' and 'orders' tables, applying the same filtering and aggregation logic. The column sorting in the inputs does not affect the logic or outcome.",both
What are the total sales by month? Use a line or bar chart to illustrate monthly sales trends.,"```python
import plotly.express as px

# SQL query to get the total sales by month
sql_query = """"""
SELECT 
    YEAR(o.OrderDate) AS Year, 
    MONTH(o.OrderDate) AS Month, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM 
    orders o 
INNER JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
GROUP BY 
    YEAR(o.OrderDate), 
    MONTH(o.OrderDate) 
ORDER BY 
    Year, 
    Month;
""""""

# Execute the query and get the dataframe
sales_data = execute_sql_query(sql_query)

# Ensure we use the 'Year' and 'Month' columns combined for correct x-axis
sales_data['YearMonth'] = sales_data['Year'].astype(str) + '-' + sales_data['Month'].astype(str).str.zfill(2)

# Create a line chart to illustrate monthly sales trends
fig = px.line(sales_data, x='YearMonth', y='TotalSales', title='Monthly Sales Trends', labels={'YearMonth': 'Month', 'TotalSales': 'Total Sales'}, markers=True)

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_TRUNC('month', o.OrderDate) AS Month,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM ""Order Details"" od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY Month
ORDER BY Month;
""""""

monthly_sales = execute_sql_query(sql_query)
fig = px.line(monthly_sales, x='Month', y='TotalSales', title='Total Sales by Month')
show_to_user(fig)
```","Both implementations correctly calculate total sales by month and plot them. The main differences are the way dates are handled: the input code uses DATE_TRUNC for monthly grouping, while the reference code extracts year and month separately. Both achieve the same outcome, meeting the request.","```python
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') as Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY Month;
""""""

df = execute_sql_query(sql_query)
fig = px.bar(df, x='Month', y='TotalSales', title='Total Sales by Month')
show_to_user(fig)
```","Both implementations correctly compute the total sales by month using SQL aggregation, and both use plotly for visualization (the first uses a line chart and the second uses a bar chart). The logic of grouping by month and summing sales is consistent in both. The SQL query structure differs slightly (using DATE_FORMAT vs YEAR and MONTH), but they achieve the same goal. Thus, the input code is considered correct in response to the business analytics request.",both
Which category has the highest number of products?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS NumberOfProducts 
FROM products 
GROUP BY CategoryID 
ORDER BY NumberOfProducts DESC 
LIMIT 1;
""""""

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.CategoryID, COUNT(p.ProductID) AS ProductCount
FROM products p
GROUP BY p.CategoryID
ORDER BY ProductCount DESC
LIMIT 1
""""""

highest_category = execute_sql_query(sql_query)
show_to_user(highest_category)
```","The input Python code correctly implements the business analytics request to find the category with the highest number of products. It uses a SQL query to count products per category and orders them in descending order by the count, limiting the result to one. This logic is consistent with the reference implementation.","```python
import pandas as pd

# SQL query to find the category with the highest number of products
sql_query = """"""
SELECT CategoryID, COUNT(*) AS ProductCount
FROM products
GROUP BY CategoryID
ORDER BY ProductCount DESC
LIMIT 1;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The input Python code uses the same logic as the reference code to find the category with the highest number of products. Both perform a SQL query that groups products by CategoryID, counts the products, orders by count in descending order, and limits the result to one. The column alias 'ProductCount' in input code is functionally equivalent to 'NumberOfProducts' in reference code.",both
Which products received the highest total discount? Present this data with a bar chart for better comparison.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Discount) AS TotalDiscount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalDiscount DESC;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Correct column names for Plotly
df.columns = ['ProductName', 'TotalDiscount']

# Create a bar chart
fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Products with the Highest Total Discount')

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Discount) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalDiscount DESC
LIMIT 10
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ProductName', y='TotalDiscount',
             title='Top 10 Products by Total Discount',
             labels={'TotalDiscount': 'Total Discount', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly calculates the total discount per product and uses a similar logic to the reference code. Although it limits the result to the top 10 products, this does not deviate from the task's core requirement of identifying products with the highest total discount. The bar chart creation and plotting are also consistent with the reference implementation.","```python
import plotly.express as px

# SQL Query to get total discount per product
sql_query = """"""
SELECT p.ProductName, SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalDiscount DESC;
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(data, x='ProductName', y='TotalDiscount', title='Total Discount by Product')

# Show the chart
show_to_user(fig)
```","The input code calculates the total discount for each product by multiplying the discount with quantity and unit price, which implies it calculates the total discount amount in money terms. The reference code sums the discount directly, suggesting it calculates total discount as a percentage. Since the logic differs, the input code does not align with the reference code.",Base
Which regions have the highest average order value? Use a bar chart to compare average order values across regions.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipRegion, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * 
       (1 - [Order Details].Discount)) AS AverageOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipRegion 
ORDER BY AverageOrderValue DESC
""""""

# Execute SQL query to get the data
data = execute_sql_query(sql_query)

# Create a bar chart to compare average order values across regions
fig = px.bar(data, x='ShipRegion', y='AverageOrderValue', 
             title='Average Order Value by Region',
             labels={'ShipRegion': 'Region', 'AverageOrderValue': 'Average Order Value'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.ShipRegion, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.ShipRegion
ORDER BY 
    AverageOrderValue DESC
""""""

average_order_values = execute_sql_query(sql_query)

fig = px.bar(average_order_values, x='ShipRegion', y='AverageOrderValue', 
             title='Average Order Value by Region',
             labels={'ShipRegion': 'Region', 'AverageOrderValue': 'Average Order Value'},
             color='AverageOrderValue')
show_to_user(fig)
```","The input Python code uses a different method to calculate the average order value. It divides the total order value by the count of distinct orders, which may lead to incorrect results if an order has more than one item. The reference implementation calculates the average by directly averaging the extended prices per line item, which is the correct approach for this task.","```python
import plotly.express as px

df = execute_sql_query(""""""
SELECT ShipRegion, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
       COUNT(DISTINCT orders.OrderID) AS AvgOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipRegion 
ORDER BY AvgOrderValue DESC;
"""""")

fig = px.bar(df, x='ShipRegion', y='AvgOrderValue', title='Average Order Value by Region')
show_to_user(fig)
```","Both the reference code and the input code aim to calculate the average order value by region. The reference code uses 'AVG' to directly compute the average per line item, whereas the input code calculates the total order value per region and divides it by the number of distinct orders, which should give the same result in terms of average order value. Both codes group by 'ShipRegion' and create a bar chart using Plotly Express, showing consistency with the business request.",Finetuned
Identify the top 3 customers by revenue in the last quarter. Include a bar chart to visualize customer revenue comparison.,"```python
import plotly.express as px

# Execute the SQL query using the provided utility function
sql_query = """"""
SELECT customers.CustomerID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as Revenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate > DATE_SUB(NOW(), INTERVAL 3 MONTH) 
GROUP BY customers.CustomerID 
ORDER BY Revenue DESC 
LIMIT 3;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart to visualize customer revenue comparison
fig = px.bar(df, x='CustomerID', y='Revenue', title='Top 3 Customers by Revenue in the Last Quarter')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the last quarter date range
import datetime
now = datetime.datetime.now()
first_day_of_quarter = (now - pd.DateOffset(months=now.month % 3)).replace(day=1)
last_day_of_quarter = (first_day_of_quarter + pd.DateOffset(months=3) - pd.DateOffset(days=1))

# SQL query to retrieve customer revenues for the last quarter
sql_query = f""""""
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM customers AS c
JOIN orders AS o ON c.CustomerID = o.CustomerID
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '{first_day_of_quarter.date()}' AND '{last_day_of_quarter.date()}'
GROUP BY c.CustomerID, c.CompanyName
ORDER BY Revenue DESC
LIMIT 3
""""""

# Execute the SQL query and get the data
top_customers = execute_sql_query(sql_query)

# Create a bar chart to visualize customer revenue comparison
fig = px.bar(top_customers, x='CompanyName', y='Revenue', title='Top 3 Customers by Revenue in Last Quarter')
show_to_user(fig)
```","The input code correctly calculates the top 3 customers by revenue in the last quarter. It constructs the date range for the last quarter accurately using the current date and offsets, similar to the reference implementation's simpler use of 3-month subtraction. Both codes execute an SQL query to sum revenues from order details joined with customers and orders tables, grouping by customer ID and ordering by revenue. The input code includes 'CompanyName' in the SQL query, which does not affect the core logic and adds more context to the visualization. The chart is created using Plotly Express and displayed, matching the requested visualization task.","```python
import plotly.express as px

# SQL query to get top 3 customers by revenue in the last quarter
sql_query = """"""
SELECT 
    c.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 3 MONTH) AND CURDATE() 
GROUP BY c.CustomerID 
ORDER BY TotalRevenue DESC 
LIMIT 3
""""""

# Execute SQL query
df_top_customers = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(df_top_customers, x='CustomerID', y='TotalRevenue', title='Top 3 Customers by Revenue')

# Show results and visualization
show_to_user(df_top_customers)
show_to_user(fig)
```","The input code differs in the date comparison logic. The reference code uses 'orders.OrderDate > DATE_SUB(NOW(), INTERVAL 3 MONTH)', but the input code uses 'orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 3 MONTH) AND CURDATE()', which may include today's date causing a potential discrepancy in date range. Additionally, the input code displays the dataframe explicitly, whereas the reference focuses only on the chart.",Base
What percentage of orders were delivered before the required date in 2022?,"```python
import pandas as pd

# Execute the SQL query using the utility function
orders_df = execute_sql_query(""SELECT OrderDate, ShippedDate, RequiredDate FROM orders"")

# Filter orders for the year 2022
orders_2022 = orders_df[pd.to_datetime(orders_df['OrderDate']).dt.year == 2022]

# Calculate the number of orders delivered on or before the required date
delivered_on_time = orders_2022[orders_2022['ShippedDate'] <= orders_2022['RequiredDate']].shape[0]

# Calculate the percentage
before_required_date_rate = (delivered_on_time / orders_2022.shape[0]) * 100

# Create a DataFrame to display the result
result_df = pd.DataFrame({'BeforeRequiredDateRate': [before_required_date_rate]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate < RequiredDate THEN 1 ELSE 0 END) AS DeliveredEarly
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2022
""""""

result = execute_sql_query(sql_query)
percentage_delivered_early = (result['DeliveredEarly'][0] / result['TotalOrders'][0]) * 100

show_to_user(pd.DataFrame({'Percentage Delivered Early': [percentage_delivered_early]}))
```","The input code calculates the percentage of orders delivered before the required date for orders in the year 2022, using SQL aggregation. It correctly filters for the year 2022, counts total orders, and sums orders where the shipped date is before the required date. The logic matches the reference implementation's intention, even though it aggregates in SQL instead of pandas.","```python
import pandas as pd

# SQL Query to get the metric value
sql_query = """"""
SELECT COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(*) as OnTimeDeliveryRate
FROM orders
WHERE YEAR(OrderDate) = 2022
""""""

# Execute the SQL query and fetch the data
result_df = execute_sql_query(sql_query)

# Display the on-time delivery rate
show_to_user(pd.DataFrame(result_df))
```","The provided code calculates the percentage of orders delivered on time in 2022 using an SQL query. The logic matches the reference implementation; it considers orders where 'ShippedDate' is on or before 'RequiredDate'. Both methodologies focus on filtering orders from 2022 and calculating the on-time delivery rate, thus adhering to the same logic despite different implementations.",both
Which supplier has the shortest average lead time in April 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY products.SupplierID
ORDER BY supplier_lead_time ASC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time
FROM orders
JOIN products ON orders.OrderID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY suppliers.SupplierID
ORDER BY average_lead_time ASC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code joins `orders` to `products` incorrectly on `OrderID` and `ProductID` instead of the correct join on `OrderID` in `orders` and `[Order Details]`. This mismatch means the calculation of average lead times may not include correct order-product relationships. Additionally, the reference code directly targets `SupplierID` without involving `suppliers.CompanyName`, which suggests that `CompanyName` is not necessary for fulfilling the request.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.SupplierID, 
AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY products.SupplierID 
ORDER BY supplier_lead_time ASC 
LIMIT 1
""""""

# Execute the SQL query and get the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Ensure only the SupplierID of the supplier with the shortest lead time is returned
shortest_lead_time_supplier = result_df[['SupplierID']].drop_duplicates()

# Display the result
show_to_user(shortest_lead_time_supplier)
```","The input Python code correctly answers the business analytics request, adhering to the logic of the reference implementation. Both implementations execute a SQL query to determine which supplier has the shortest average lead time in April 2023. The SQL query logic is identical in both implementations—using the same joins, date filter, and ordering by the lead time, with a limit of one to find the supplier with the shortest lead time. The input code adds another step to ensure only the 'SupplierID' is returned, which does not alter the correctness of the result. Therefore, the input code is considered correct.",Finetuned
Who are the employees reporting to each manager?,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT m.EmployeeID AS ManagerID, 
       m.LastName AS ManagerLastName, 
       m.FirstName AS ManagerFirstName, 
       e.EmployeeID AS EmployeeID, 
       e.LastName AS EmployeeLastName, 
       e.FirstName AS EmployeeFirstName 
FROM employees e 
JOIN employees m ON e.ReportsTo = m.EmployeeID;
""""""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Display the results
show_to_user(df)
```","```python
sql_query = """"""
SELECT e1.FirstName AS EmployeeFirstName, e1.LastName AS EmployeeLastName, 
       e2.FirstName AS ManagerFirstName, e2.LastName AS ManagerLastName
FROM employees e1
JOIN employees e2 ON e1.ReportsTo = e2.EmployeeID
ORDER BY e2.LastName, e1.LastName;
""""""

employee_manager_df = execute_sql_query(sql_query)
show_to_user(employee_manager_df)
```","The provided code correctly identifies employees and their respective managers by joining the employees table on their 'ReportsTo' and 'EmployeeID' fields. It also selects the appropriate columns for employees' and managers' first and last names. The difference in the order and naming of output columns does not affect the core logic of retrieving who reports to whom. Additionally, the 'ORDER BY' clause is not present in the reference but does not alter the correctness of the query as it is an additional refinement for displaying the data.","```python
import pandas as pd

query = """"""
SELECT e1.FirstName, e1.LastName, e1.EmployeeID, e2.FirstName AS ManagerFirstName, e2.LastName AS ManagerLastName 
FROM employees e1 
JOIN employees e2 ON e1.ReportsTo = e2.EmployeeID;
""""""

result_df = execute_sql_query(query)

show_to_user(result_df)
```","The input code correctly answers the business analytics request by identifying employee-manager relationships. Both the input and reference implementations retrieve the same essential information, with minor differences in column names and order. The input code selects the employee's first name, last name, and ID, along with the manager's first and last names, which fulfills the requirement to identify employees reporting to each manager.",both
Find the average discount applied to orders in January 2023.,"```python
import pandas as pd

# SQL Query to find average discount
sql_query = """"""
SELECT AVG(od.Discount) AS AvgDiscount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input Python code correctly calculates the average discount for orders placed in January 2023. It uses a SQL query that filters OrderDate from the 1st of January 2023 up to but not including the 1st of February 2023, effectively covering all of January. The logic matches the reference implementation, where a similar WHERE clause ensures the date range. Both implementations join the 'orders' and 'Order Details' tables on OrderID and compute the average discount.","```python
import pandas as pd

sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

df = execute_sql_query(sql_query)
show_to_user(df['AverageDiscount'])
```","The provided code and the reference implementation both perform the same operation: calculating the average discount for orders placed in January 2023. The SQL queries in both implementations join the 'Order Details' and 'orders' tables on 'OrderID', and filter the 'OrderDate' for January 2023. The difference in querying style (e.g., table aliasing 'od' vs using full table names) doesn't affect the outcome, and the key task—calculating the average discount—is correctly handled in both.",both
Calculate the total sales for employees located in a specific region.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = 'specific region'
GROUP BY e.EmployeeID;
""""""

# Execute the query and get the result as a dataframe
sales_data_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_data_df)
```","```python
region = ""SpecificRegion""  # Replace with the desired region

sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = '{region}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly calculates the total sales for employees located in a specific region. While it includes additional SELECT fields (FirstName, LastName) and adjusts the GROUP BY clause accordingly, these changes do not affect the core logic. The calculation of TotalSales and the filtering by region are performed correctly, consistent with the reference code’s intent.","```python
import pandas as pd

# Define the region for which sales are calculated
region = ""'SpecificRegion'""

# SQL query to retrieve total sales for the specified region
sql_query = f""""""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE e.Region = {region} 
GROUP BY e.EmployeeID;
""""""

# Execute the query
sales_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(sales_df)
```","The input code correctly implements the logic to calculate total sales for employees located in a specific region. Both the input code and the reference implementation use a similar SQL query template to join 'employees', 'orders', and 'Order Details' tables, and calculate sales for a given region. The input code dynamically defines the region as 'SpecificRegion', which is consistent with the requirement, albeit slightly different in presentation.",both
What are the names of all suppliers who are located in Germany?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""

# Execute the query
suppliers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(suppliers_df)
```","```python
sql_query = """"""
SELECT CompanyName 
FROM suppliers 
WHERE Country = 'Germany';
""""""

suppliers_germany = execute_sql_query(sql_query)
show_to_user(suppliers_germany)
```","The input code correctly executes a SQL query to select 'CompanyName' from the 'suppliers' table where the 'Country' is 'Germany'. This aligns with the logic of the reference code. Both implementations achieve the same outcome, which is retrieving the names of suppliers located in Germany using a SQL query and displaying the results.","```python
import pandas as pd

# Execute the SQL query to get the suppliers in Germany
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""
suppliers_in_germany = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(suppliers_in_germany)
```","The input code correctly constructs and executes the SQL query to retrieve the names of suppliers located in Germany, just like the reference implementation. Both use the same query and function calls, achieving the requested business goal.",both
What was the average order value in June 2023?,"```python
import pandas as pd

# SQL query to calculate average order value in June 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-06';
""""""

# Execute the query and retrieve the result in a dataframe
df = execute_sql_query(sql_query)

# Display the average order value to the user
show_to_user(df['AvgOrderValue'].iloc[0])
```","```python
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-06-01' AND o.OrderDate < '2023-07-01'
""""""

average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","Both the reference implementation and the input code correctly calculate the average order value for June 2023. The input code uses a different method to filter the dates (using a range from '2023-06-01' to '2023-07-01'), which is logically equivalent to the reference code's use of 'DATE_FORMAT'. Both codes accurately compute the average by dividing the total sales value by the count of distinct orders. The key components remain consistent, resulting in similar output.","```python
import pandas as pd

# SQL to get average order value for June 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    o.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

# Execute the query
avg_order_value_df = execute_sql_query(sql_query)

# Display the result
show_to_user(avg_order_value_df['AverageOrderValue'])
```","Both implementations correctly calculate the average order value for June 2023. The reference implementation uses the DATE_FORMAT function to filter dates, while the input code uses a BETWEEN clause to specify the date range. Both methods accurately target the month of June and handle calculations by summing the product of unit price, quantity, and discount, divided by the count of distinct orders. The minor difference in SQL syntax doesn't affect the correctness of the logic, making the provided code correct.",both
Calculate the average freight cost for each customer. Use a bar chart to compare freight costs across customers.,"```python
import plotly.express as px

# Execute the SQL query to retrieve the data
sql_query = ""SELECT CustomerID, AVG(Freight) AS AvgFreight FROM orders GROUP BY CustomerID;""
df = execute_sql_query(sql_query)

# Create a bar chart to compare freight costs across customers
fig = px.bar(df, x='CustomerID', y='AvgFreight', title='Average Freight Cost per Customer', labels={'AvgFreight': 'Average Freight Cost', 'CustomerID': 'Customer ID'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, AVG(Freight) AS AverageFreight
FROM orders
GROUP BY CustomerID
""""""
freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='CustomerID', y='AverageFreight', 
             title='Average Freight Cost per Customer', 
             labels={'CustomerID': 'Customer ID', 'AverageFreight': 'Average Freight Cost'})
show_to_user(fig)
```","The input code correctly executes an SQL query to calculate the average freight cost for each customer and produces a bar chart using Plotly Express. It matches the logic of the reference implementation by grouping data by CustomerID and calculating the average freight ('AverageFreight'). The variable names differ slightly, but the logic and output are consistent with the reference code.","```python
import plotly.express as px

# SQL query to calculate average freight cost for each customer
sql_query = ""SELECT CustomerID, AVG(Freight) AS AverageFreight FROM orders GROUP BY CustomerID""

# Execute the query
df = execute_sql_query(sql_query)

# Create a bar chart to compare freight costs across customers
fig = px.bar(df, x='CustomerID', y='AverageFreight', title='Average Freight Cost per Customer')

# Show the result to the user
show_to_user(fig)
```",The input code performs the same task as the reference implementation. Both codes execute a SQL query to calculate the average freight per customer and then use Plotly to create a bar chart to visualize the data. The difference in label naming (AvgFreight vs AverageFreight) does not affect the correctness of the business logic or the resulting visualization. The input code satisfies the business analytics request effectively.,both
How many orders were placed on weekends in the last three months? Present the data with a bar chart for each weekend.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders placed on weekends in the last three months
sql_query = """"""
SELECT DAY(OrderDate) AS Day, MONTH(OrderDate) AS Month, YEAR(OrderDate) AS Year, COUNT(OrderID) AS WeekendOrders 
FROM orders 
WHERE DAYOFWEEK(OrderDate) IN (1, 7) 
AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
GROUP BY Year, Month, Day
""""""

# Execute the SQL query and get the dataframe
df = execute_sql_query(sql_query)

# Combine the day, month, and year into a single date column
df['OrderDate'] = pd.to_datetime(df[['Year', 'Month', 'Day']])

# Create a bar chart with Plotly
fig = px.bar(df, x='OrderDate', y='WeekendOrders', title='Weekend Orders in the Last 3 Months')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch orders placed on weekends in the last three months
sql_query = """"""
SELECT
    DATE(OrderDate) AS OrderDate,
    COUNT(OrderID) AS OrderCount
FROM
    orders
WHERE
    OrderDate >= CURRENT_DATE - INTERVAL '3 months' AND
    EXTRACT(DOW FROM OrderDate) IN (0, 6)  -- 0 = Sunday, 6 = Saturday
GROUP BY
    OrderDate
ORDER BY
    OrderDate;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for orders placed on weekends
fig = px.bar(data, x='OrderDate', y='OrderCount', title='Weekend Orders in the Last Three Months',
             labels={'OrderDate': 'Weekend Date', 'OrderCount': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by counting the number of orders placed on weekends within the last three months and visualizing them in a bar chart. It uses SQL to filter orders by date and day of the week, mirroring the logic in the reference code. It then plots the results accurately using Plotly, following the same purpose as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m-%d') AS OrderDate, COUNT(*) AS OrderCount 
FROM orders 
WHERE OrderDate >= CURDATE() - INTERVAL 3 MONTH 
AND (WEEKDAY(OrderDate) = 5 OR WEEKDAY(OrderDate) = 6) 
GROUP BY OrderDate
""""""

# Execute the query to retrieve data
weekend_orders_df = execute_sql_query(sql_query)

# Sort data for consistent bar chart representation
weekend_orders_df.sort_values(by='OrderDate', inplace=True)

# Create a bar chart
fig = px.bar(weekend_orders_df, x='OrderDate', y='OrderCount', title='Weekend Orders in the Last Three Months')

# Show the result to the user
show_to_user(fig)
```","The input code accurately captures and evaluates the number of weekend orders in the last three months by using the WEEKDAY function, which correctly identifies weekends (Saturday and Sunday as 5, 6). The reference code uses DAYOFWEEK for the same purpose but with adjusted indices (1, 7) to map to Sunday and Saturday respectively. Both approaches are valid for selecting weekends. Additionally, the final output of both codes is a bar chart displaying the number of orders per weekend day, fulfilling the business request.",both
What is the total sales revenue generated in the year 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
total_sales = df['total_sales'].iloc[0]
show_to_user(total_sales)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The provided code does not extract the total sales value from the DataFrame. It directly passes the entire DataFrame `total_sales_df` to `show_to_user`, whereas the reference code selects the specific value from the `total_sales` column using `iloc[0]`. This means the code may not display the correct result as it doesn't access the summed sales revenue correctly.","```python
import pandas as pd

# SQL query to get total sales in 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute SQL query
total_sales_df = execute_sql_query(sql_query)

# Display the result
total_sales = total_sales_df['total_sales'].iloc[0]
show_to_user(pd.DataFrame({'Total Sales 2023': [total_sales]}))
```","The input Python code accurately reflects the logic and intent of the reference implementation. Both implementations construct and execute an identical SQL query to calculate the total sales revenue for 2023, based on orders and their details. The slight variation in the display method, where the result is shown as a DataFrame, does not affect the correctness of the computation and aligns with the business analytics request.",Finetuned
How many products have been ordered but not yet shipped?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT COUNT(orders.OrderID) AS Products_Not_Shipped FROM orders WHERE orders.ShippedDate IS NULL;""

# Execute the query
df_orders_not_shipped = execute_sql_query(sql_query)

# Prepare result to show
result_df = pd.DataFrame({'Products_Not_Shipped': [df_orders_not_shipped['Products_Not_Shipped'].iloc[0]]})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS ProductsOnOrderNotShipped
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.ShippedDate IS NULL
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly counts the number of products that have been ordered but not shipped by using a SQL JOIN with the 'orders' and 'Order Details' tables and checking for NULL 'ShippedDate'. The logic aligns with the reference implementation, focusing on counting orders with NULL 'ShippedDate'.","```python
import pandas as pd

sql_query = """"""
SELECT products.ProductName 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderID NOT IN (SELECT OrderID FROM orders WHERE ShippedDate IS NOT NULL);
""""""

# Execute the SQL query to get the products
products_df = execute_sql_query(sql_query)

# Count the distinct products that have been ordered but not yet shipped
ordered_not_shipped_count = products_df['ProductName'].nunique()

# Display the result
show_to_user(pd.DataFrame({'OrderedNotShippedCount': [ordered_not_shipped_count]}))
```","The provided code counts the distinct product names that have been ordered but not yet shipped. The reference code counts the number of orders that have not been shipped, not distinct products. Thus, the logic differs between the two implementations.",Base
Which products are low in stock and need reordering?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE UnitsInStock <= ReorderLevel 
AND Discontinued = 0;
""""""

# Execute the SQL query to get the data
low_stock_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(low_stock_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""

low_stock_products = execute_sql_query(sql_query)
show_to_user(low_stock_products)
```","Both implementations correctly identify products that need reordering based on their current stock levels (UnitsInStock) compared to their reorder levels (ReorderLevel) and check the Discontinued status. The condition '<' is logically equivalent to '<=' for identifying low stock, ensuring the correct set of products are identified. Additional columns in the input code do not affect correctness.","```python
import pandas as pd

# SQL query to find products low in stock and need reordering
sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0;
""""""

# Execute the query to get data
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)
```",The input code checks for 'UnitsInStock < ReorderLevel' instead of 'UnitsInStock <= ReorderLevel' as in the reference code. This results in different behavior for products where 'UnitsInStock' is exactly equal to 'ReorderLevel'.,Base
How many orders were shipped but not yet delivered by the required date?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS Count FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result['Count'][0])
```","```python
sql_query = """"""
SELECT COUNT(OrderID) AS Orders_Not_Delivered_On_Time
FROM orders
WHERE ShippedDate IS NOT NULL AND ShippedDate > RequiredDate;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly answers the question by counting the number of orders where the ShippedDate is later than the RequiredDate, implying they were shipped but not delivered on time. The additional condition 'ShippedDate IS NOT NULL' ensures that only shipped orders are considered, which is consistent with the business request. The logic matches the reference implementation.","```python
import pandas as pd

sql_query = """"""
SELECT COUNT(*) AS OrdersNotDeliveredOnTime 
FROM orders 
WHERE ShippedDate > RequiredDate;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The output of the input code will be a DataFrame and directly displaying it using show_to_user will not return the exact count as an integer. In the reference code, the count is extracted directly using df_result['Count'][0] before displaying it.",Base
Determine the average number of products per order.,"```python
import pandas as pd

# SQL query to determine the average number of products per order
sql_query = """"""
SELECT AVG(ProductCount) AS AverageProductsPerOrder 
FROM (
    SELECT OrderID, COUNT(ProductID) AS ProductCount 
    FROM [Order Details] 
    GROUP BY OrderID
) AS ProductCounts;
""""""

# Execute the SQL query
average_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_df['AverageProductsPerOrder'])
```","```python
sql_query = """"""
SELECT AVG(ProductCount) AS AverageProductsPerOrder
FROM (
    SELECT OrderID, COUNT(ProductID) AS ProductCount
    FROM [Order Details]
    GROUP BY OrderID
) AS OrderProductCounts
""""""

average_products_per_order = execute_sql_query(sql_query)
show_to_user(average_products_per_order)
```","The input Python code correctly implements the business analytics request. It calculates the average number of products per order by selecting the average of counts of ProductID grouped by OrderID, which matches the logic of the reference implementation. The minor differences in alias naming ('OrderProductCounts' vs 'ProductCounts') do not affect the correctness of the query.","```python
import pandas as pd

# SQL query to retrieve the necessary data
sql_query = """"""
SELECT COUNT(od.ProductID) / COUNT(DISTINCT od.OrderID) AS AvgProductsPerOrder
FROM [Order Details] od;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the average number of products per order
show_to_user(result_df.loc[0, 'AvgProductsPerOrder'])
```","Both implementations aim to calculate the average number of products per order. The reference implementation uses a subquery to first count the products per order and then average these counts. The input implementation simplifies this by dividing the total number of products by the total number of orders, which mathematically yields the same result. Thus, both implementations achieve the same outcome using different approaches.",both
Which suppliers provide products that are currently discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.SupplierID
FROM products p
WHERE p.Discontinued = 1
""""""

discontinued_products = execute_sql_query(sql_query)

show_to_user(discontinued_products)
```","The input code retrieves only products that are discontinued, providing columns for ProductID, ProductName, and SupplierID. It does not identify distinct suppliers or their company names as required and as performed in the reference code, which joins the suppliers and products tables to list unique suppliers with discontinued products.","```python
import pandas as pd

sql_query = """"""
SELECT DISTINCT SupplierID
FROM products
WHERE Discontinued = 1;
""""""

discontinued_suppliers_df = execute_query(sql_query)
show_to_user(discontinued_suppliers_df)
```","The evaluated code only selects the SupplierID from the products table, ignoring the CompanyName and the relationship with the suppliers table. This does not fulfill the request to identify suppliers by both SupplierID and CompanyName. The logic deviates from the reference implementation which joins the suppliers and products tables.",None
What are the most commonly ordered product quantities?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS MostCommonQuantities 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID 
ORDER BY MostCommonQuantities DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT Quantity, COUNT(*) AS Frequency
FROM [Order Details]
GROUP BY Quantity
ORDER BY Frequency DESC
LIMIT 10
""""""

most_commonly_ordered_quantities = execute_sql_query(sql_query)
show_to_user(most_commonly_ordered_quantities)
```","The input code is not implementing the same logic as the reference implementation. The reference code calculates the total quantity ordered per product and sorts by the highest total quantity. In contrast, the input code counts the frequency of each ordered quantity and sorts by that frequency, limited to the top 10. These are different analytics requests.","```python
import pandas as pd

# SQL query to fetch most commonly ordered product quantities
sql_query = '''
SELECT Quantity, COUNT(*) AS OrderCount 
FROM [Order Details] 
GROUP BY Quantity 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the query and retrieve the data into a dataframe
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input code is querying for the most frequently ordered quantity (how many orders had the same quantity), rather than summing up the quantities ordered per product like the reference code. The business request asks for the total quantities ordered per product, not the most frequently occurring order quantities.",None
Find the most expensive product by unit price.,"```python
import pandas as pd

sql_query = ""SELECT ProductName FROM products ORDER BY UnitPrice DESC LIMIT 1;""
df = execute_sql_query(sql_query)

most_expensive_product = df['ProductName'].iloc[0]

result_df = pd.DataFrame({'Most Expensive Product': [most_expensive_product]})
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE Discontinued = 0 
ORDER BY UnitPrice DESC 
LIMIT 1
""""""
most_expensive_product = execute_sql_query(sql_query)
show_to_user(most_expensive_product)
```","The input code includes an additional condition `WHERE Discontinued = 0`, which filters out discontinued products. This imposes a different logic compared to the reference implementation that considers all products regardless of their discontinued status.","```python
sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
ORDER BY UnitPrice DESC 
LIMIT 1;
""""""

df = execute_sql_query(sql_query)
show_to_user(df)
```","The input code correctly retrieves the most expensive product by ordering the products by UnitPrice in descending order and limiting the result to the top entry. Although it does not create a separate DataFrame like the reference code, it satisfies the business objective by showing the relevant information to the user.",Finetuned
Find the top 5 highest priced products with a visualization to compare prices.,"```python
import plotly.express as px

# Define SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Generate a bar chart to compare prices
fig = px.bar(df, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 5 highest priced products
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
ORDER BY UnitPrice DESC
LIMIT 5
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 highest priced products
fig = px.bar(top_products_df, 
             x='ProductName', 
             y='UnitPrice', 
             title='Top 5 Highest Priced Products',
             labels={'UnitPrice': 'Price', 'ProductName': 'Product Name'},
             color='UnitPrice')

# Show the visualization to the user
show_to_user(fig)
```","The provided code correctly implements the business analytics request by executing an SQL query to retrieve the top 5 highest priced products from a database. It then uses Plotly Express to generate a bar chart that visualizes these products' prices, similar to the reference implementation. While the evaluated code includes additional parameters like labeling and coloring the bars based on the price, these do not alter the fundamental logic of the request. Therefore, it correctly matches the intended analysis and visualization described in the reference code.","```python
import plotly.express as px

# SQL query to get the top 5 highest priced products
sql_query = """"""
SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;
""""""

# Execute SQL query
product_data = execute_sql_query(sql_query)

# Generate a bar chart to visualize the top 5 highest priced products
fig = px.bar(product_data, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products')

# Display the visualization
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. Both execute the same SQL query to retrieve the top 5 highest priced products and generate a bar chart using Plotly to compare prices. The function names and parameters used are identical, ensuring the output will be equivalent.",both
"List customers with their respective regions and count of orders placed, visualizing order counts geographically.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    customers.CustomerID, 
    customers.Region, 
    COUNT(orders.OrderID) AS total_orders 
FROM 
    customers 
LEFT JOIN 
    orders 
ON 
    customers.CustomerID = orders.CustomerID 
GROUP BY 
    customers.CustomerID, customers.Region;
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Aggregate total_orders by region
aggregated_data = data.groupby('Region', as_index=False)['total_orders'].sum()

# Visualize order counts geographically
fig = px.bar(aggregated_data, x='Region', y='total_orders', color='Region', 
             title='Order Counts by Region')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    c.Region, 
    COUNT(o.OrderID) AS OrderCount
FROM 
    customers c
LEFT JOIN 
    orders o ON c.CustomerID = o.CustomerID
GROUP BY 
    c.CustomerID, c.CompanyName, c.Region
""""""

customer_orders_df = execute_sql_query(sql_query)

fig = px.choropleth(customer_orders_df, 
                    locations='Region', 
                    locationmode='USA-states', 
                    color='OrderCount', 
                    hover_name='CompanyName',
                    title='Customer Order Counts by Region',
                    color_continuous_scale=px.colors.sequential.Plasma)

show_to_user(fig)
```","The input Python code diverges from the reference implementation in terms of logic and output. First, it includes 'CompanyName' in the SQL query grouping, which leads to a greater number of groups than necessary. The reference code only groups by CustomerID and Region. Additionally, the input code uses a choropleth map while the reference uses a bar chart to visualize data. Finally, the input aggregates individual customer records instead of regional totals as in the reference, effectively altering the focus of the analysis.","```python
import plotly.express as px

query = """"""
SELECT c.Region, COUNT(o.OrderID) AS TotalOrders
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.Region;
""""""

data = execute_sql_query(query)
fig = px.choropleth(data, locations='Region', locationmode='country names', color='TotalOrders', title='Total Orders by Region')
show_to_user(fig)
```","The input code does not list customers with their respective regions and count of orders placed. It only aggregates the total number of orders by region, not by customer and region as required. Also, the visualization is a choropleth map, not a bar chart as in the reference implementation.",None
"Find the top 5 cities with the highest number of orders, using a bar chart for comparison.","```python
import plotly.express as px

# Execute the SQL query to get the top 5 cities with highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 5
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders')
show_to_user(fig)
```","The input Python code correctly follows the logic and steps outlined in the reference implementation. Both codes execute a SQL query to select the top 5 cities with the highest number of orders, group the results by city, order by order count, and limit the output to 5 results. Both implementations then create a bar chart using Plotly Express and display the result. Although the input code imports pandas (which is not used), its logic conforms to the reference code's requirements.","```python
import plotly.express as px

# SQL query to retrieve top 5 cities with the highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ShipCity', y='OrderCount', title='Top 5 Cities with the Highest Number of Orders')

# Show the bar chart to the user
show_to_user(fig)
```","The provided code is correct because it follows the same logic as the reference implementation. It executes a SQL query to get the top 5 cities based on the number of orders and creates a bar chart with Plotly to display the results. The SQL query, dataframe construction, and visualization steps match the reference implementation.",both
"What is the total quantity of each product sold, visualized with a bar chart?","```python
import plotly.express as px

# SQL query to get the total quantity of each product sold
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity Sold by Product')

# Show the result to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='ProductID', y='TotalQuantity', title='Total Quantity of Each Product Sold', labels={'TotalQuantity': 'Quantity Sold', 'ProductID': 'Product ID'})
show_to_user(fig)
```","The code correctly answers the business analytics request by calculating the total quantity of each product sold. The SQL query in the input code selects ProductID and sums the Quantity from the 'Order Details' table, which matches the logic of the reference implementation. The bar chart is created with the same fields and additional labels, which don't affect the correctness. Both implementations use plotly to visualize the results correctly.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT [Order Details].ProductID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY [Order Details].ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity of Each Product Sold')

# Display the chart
show_to_user(fig)
```","The provided code correctly answers the business analytics request. It uses a SQL query to retrieve the total quantity of each product sold, grouping by ProductID. It executes this query similarly to the reference code and uses Plotly Express to create a bar chart showing the total quantity sold by product. Despite minor differences, such as including table names in the SQL query, the logic aligns with the reference implementation.",both
Find the total sales and the number of orders for each customer in March 2023 with a bar chart for comparison.,"```python
import plotly.express as px

# The SQL query to execute
sql_query = """"""
SELECT O.CustomerID, SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales, 
COUNT(O.OrderID) AS OrderCount 
FROM orders O 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
WHERE DATE_FORMAT(O.OrderDate, '%Y-%m') = '2023-03' 
GROUP BY O.CustomerID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for comparison
fig = px.bar(data, x='CustomerID', y=['TotalSales', 'OrderCount'], 
             barmode='group', 
             title='Total Sales and Number of Orders for Each Customer in March 2023')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.CustomerID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
    COUNT(o.OrderID) AS NumberOfOrders
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-03-01' AND o.OrderDate < '2023-04-01'
GROUP BY 
    o.CustomerID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CustomerID', y=['TotalSales', 'NumberOfOrders'],
              title='Total Sales and Number of Orders per Customer in March 2023',
              labels={'variable': 'Metrics', 'value': 'Amount'},
              barmode='group')

show_to_user(fig)
```","The provided Python code correctly calculates the total sales and number of orders for each customer in March 2023. It uses a different date filter approach than the reference code but achieves the same result. The bar chart is configured to display the required metrics, and therefore, the input implementation is consistent with the reference logic.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT o.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales, 
       COUNT(o.OrderID) AS NumberOfOrders 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY o.CustomerID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart for comparison
fig = px.bar(df, x='CustomerID', y=['TotalSales', 'NumberOfOrders'], 
             title=""Total Sales and Number of Orders per Customer in March 2023"",
             labels={'value': 'Count', 'variable': 'Metrics'},
             barmode='group')

# Show the bar chart
show_to_user(fig)
```","The input Python code correctly executes a SQL query to find total sales and the number of orders for each customer in March 2023, just like the reference implementation. The logic is consistent: both codes group by CustomerID and calculate TotalSales and OrderCount. The SQL syntax differs slightly but achieves the same result, using a date range in the input and a date format check in the reference. The plotting function is implemented similarly, creating a grouped bar chart to compare TotalSales and order count.",both
"How many units have been sold for each product, grouped by supplier, visualized with a stacked bar chart?","```python
import plotly.express as px

# SQL query to retrieve the required data
sql_query = '''
SELECT s.SupplierName, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierName, p.ProductName;
'''

# Execute the SQL query to get the data in a dataframe
df = execute_sql_query(sql_query)

# Create the stacked bar chart using plotly
fig = px.bar(df, x='SupplierName', y='TotalQuantitySold', color='ProductName', 
             title='Units Sold for Each Product by Supplier', 
             labels={'TotalQuantitySold': 'Total Quantity Sold', 'SupplierName': 'Supplier'})

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, p.SupplierID, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductName, p.SupplierID
ORDER BY p.SupplierID, p.ProductName;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, 
              x='SupplierID', 
              y='TotalUnitsSold', 
              color='ProductName', 
              title='Units Sold per Product Grouped by Supplier', 
              labels={'TotalUnitsSold': 'Units Sold', 'SupplierID': 'Supplier'},
              text='TotalUnitsSold')
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(barmode='stack', xaxis_title='Supplier', yaxis_title='Units Sold')
show_to_user(fig)
```","The input Python code does not correctly match the reference implementation. The reference implementation groups data by SupplierName and ProductName, while the input code groups by ProductName and SupplierID. Additionally, the input code filters discontinued products, which is not specified in the reference. The supplier information in the input is directly from SupplierID instead of using a join to get SupplierName.","```python
import plotly.express as px

# Query to get the required data
query = """"""
SELECT products.ProductName, products.SupplierID, SUM([Order Details].Quantity) AS TotalSold 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName, products.SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(query)

# Create a stacked bar chart
fig = px.bar(df, x='ProductName', y='TotalSold', color='SupplierID', title='Units Sold by Product and Supplier', 
             labels={'TotalSold': 'Total Units Sold', 'ProductName': 'Product Name'})

# Show the figure to user
show_to_user(fig)
```","The input code does not match the business analytics request or the logic of the reference implementation. The reference implementation groups sales data by 'SupplierName' and 'ProductName', while the input code groups by 'ProductName' and 'SupplierID'. Additionally, the input uses 'ProductName' as the x-axis and 'SupplierID' for color, instead of using 'SupplierName' for both x-axis and grouping (color in the chart). This results in a different visualization that doesn't answer the specified question correctly.",None
Calculate the percentage of orders shipped within 5 days of the order date.,"```python
import pandas as pd

# Execute query to retrieve all orders data
orders_df = execute_sql_query(""SELECT OrderID, OrderDate, ShippedDate FROM orders"")

# Calculate percentage of orders shipped within 5 days
orders_df['DaysDifference'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days
within_5_days = orders_df['DaysDifference'] <= 5
percentage_within_5_days = within_5_days.sum() * 100.0 / len(orders_df)

# Prepare the result as a dataframe
result_df = pd.DataFrame({
    'PercentageWithin5Days': [percentage_within_5_days]
})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(*) AS TotalOrders,
    COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 5 THEN 1 END) AS OrdersShippedWithin5Days
FROM 
    orders
""""""

results = execute_sql_query(sql_query)
percentage_shipped_within_5_days = (results['OrdersShippedWithin5Days'].iloc[0] / results['TotalOrders'].iloc[0]) * 100

import pandas as pd

summary_df = pd.DataFrame({
    'Metric': ['Percentage of Orders Shipped Within 5 Days'],
    'Value': [percentage_shipped_within_5_days]
})

show_to_user(summary_df)
```","The input Python code correctly calculates the percentage of orders shipped within 5 days of the order date, following the logic of the reference implementation. The SQL query effectively counts all orders and those shipped within 5 days. The percentage is computed as the ratio of these counts, multiplied by 100. The result is then presented in a DataFrame, similar to the reference implementation.","```python
import pandas as pd

# SQL Query to calculate the percentage of orders shipped within 5 days
sql_query = """"""
SELECT (COUNT(*) FILTER (WHERE DATEDIFF(orders.ShippedDate, orders.OrderDate) <= 5) / COUNT(*)) AS five_day_shipping_rate FROM orders;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the five_day_shipping_rate directly
five_day_shipping_rate = df.iloc[0]['five_day_shipping_rate']

# Display the result to the user
show_to_user(pd.DataFrame({'five_day_shipping_rate': [five_day_shipping_rate]}))
```","The input Python code calculates the percentage of orders shipped within 5 days using a SQL query with the DATEDIFF function and a FILTER clause. This logic is equivalent to the reference implementation. Both correctly compute the percentage by counting shipments within 5 days and dividing by the total. The result is displayed similarly, making the implementation correct.",both
"What is the total quantity ordered across all products by month, with a line chart to show trends?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT MONTH(OrderDate) AS OrderMonth, 
       YEAR(OrderDate) AS OrderYear, 
       SUM(Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
GROUP BY YEAR(OrderDate), MONTH(OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort data by year and month for proper trend visualization
df.sort_values(by=['OrderYear', 'OrderMonth'], inplace=True)

# Concatenate year and month for the x-axis
df['YearMonth'] = df['OrderYear'].astype(str) + '-' + df['OrderMonth'].astype(str)

# Create a line chart using Plotly
fig = px.line(df, x='YearMonth', y='TotalQuantityOrdered', 
              labels={'YearMonth': 'Year-Month', 'TotalQuantityOrdered': 'Total Quantity Ordered'},
              title='Monthly Total Quantity Ordered Across All Products')

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    SUM(Quantity) AS total_quantity
FROM 
    [Order Details] od
JOIN 
    Orders o ON od.OrderID = o.OrderID
GROUP BY 
    month
ORDER BY 
    month;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='month', y='total_quantity', title='Total Quantity Ordered by Month')
show_to_user(fig)
```","The input code correctly calculates total quantities ordered across all products by month using similar logic to the reference implementation. It queries the data to sum quantities grouped by month, formats the month-year and sums the quantities, and uses Plotly for creating a line chart. Despite minor differences, such as SQL syntax (DATE_FORMAT vs MONTH/YEAR) and structure (ordering in SQL vs sorting in Pandas), the core output and functionality are consistent with the original request.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, SUM(Quantity) AS total_quantity 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY month;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Create a line chart using the retrieved data
figure = px.line(data, x='month', y='total_quantity', title='Total Quantity Ordered by Month')

# Show the line chart to the user
show_to_user(figure)
```","Both implementations calculate the total quantity ordered by month, albeit using slightly different SQL querying approaches. The reference code uses separate functions for YEAR and MONTH with concatenation, while the input code uses DATE_FORMAT to achieve a similar result. Both sort the data by month-year and generate a line chart using Plotly. Thus, the logic aligns with the business analytics request, and the input code adheres to the required logic.",both
"Which product has generated the highest revenue, and visualize this with a bar chart?","```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS Revenue
FROM [Order Details]
GROUP BY ProductID
ORDER BY Revenue DESC;
""""""

# Execute the SQL query and get the data in a pandas DataFrame
data_df = execute_sql_query(sql_query)

# Visualize the revenue of each product
fig = px.bar(data_df, x='ProductID', y='Revenue', title='Product Revenue')

# Show the visualization
show_to_user(fig)

# Determine the product with the highest revenue
highest_revenue_product = data_df.iloc[0]
show_to_user(highest_revenue_product)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalRevenue DESC
LIMIT 1
""""""

highest_revenue_product = execute_sql_query(sql_query)

sql_query_products = """"""
SELECT ProductID, ProductName FROM products WHERE ProductID = {product_id}
"""""".format(product_id=highest_revenue_product['ProductID'].iloc[0])

product_name = execute_sql_query(sql_query_products)

fig = px.bar(x=[product_name['ProductName'].iloc[0]], y=[highest_revenue_product['TotalRevenue'].iloc[0]], 
             labels={'x': 'Product Name', 'y': 'Total Revenue'},
             title='Highest Revenue Generating Product')

show_to_user(fig)
```","The input code fetches only the product with the highest revenue directly using SQL with a LIMIT clause, resulting in a single product being returned. In contrast, the reference code fetches revenue for all products and allows the sorting and visualization of their revenues in a bar chart. The reference code visualizes the revenue of each product, not just the highest revenue-generating product. The input code does not fully meet the requirement to visualize the revenues of all products in a bar chart as the reference implementation does.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS RevenueGenerated 
FROM [Order Details] od 
GROUP BY ProductID 
ORDER BY RevenueGenerated DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if df is not empty and contains the correct columns
if not df.empty and 'ProductID' in df.columns and 'RevenueGenerated' in df.columns:
    # Create the bar chart
    fig = px.bar(df, x='ProductID', y='RevenueGenerated', title='Highest Revenue Generating Product')

    # Show the result
    show_to_user(fig)
```","The input code includes a SQL `LIMIT 1` clause, which restricts the data to only the product with the highest revenue. This prevents a full comparison visualization like in the reference code, which displays all products. The task is to visualize revenue for each product and determine the highest revenue generator. The provided input code only visualizes the top product, missing this requirement.",None
Calculate the average order value for each customer with a bar chart for comparison.,"```python
import plotly.express as px

# SQL query to calculate average order value for each customer
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM customers c 
INNER JOIN orders o ON c.CustomerID = o.CustomerID 
INNER JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly to visualize average order value for each customer
fig = px.bar(df, x='CustomerID', y='AverageOrderValue', title='Average Order Value per Customer')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent,
    COUNT(DISTINCT o.OrderID) AS OrderCount,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID
""""""

customer_avg_order_value = execute_sql_query(sql_query)

fig = px.bar(customer_avg_order_value, 
              x='CustomerID', 
              y='AverageOrderValue', 
              title='Average Order Value per Customer', 
              labels={'AverageOrderValue': 'Average Order Value', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```","The input code correctly calculates the average order value per customer using the same logic as the reference implementation. Both codes join the customers, orders, and order details tables, and calculate the total spent and order count to derive the average order value. Additionally, both implementations use Plotly to create a bar chart for the visualization. The additional calculated columns (TotalSpent and OrderCount) in the input code do not affect the correctness of the AverageOrderValue calculation and can be considered extraneous but harmless.","```python
import plotly.express as px

sql_query = """"""
SELECT CustomerID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY CustomerID
""""""

df = execute_sql_query(sql_query)
fig = px.bar(df, x='CustomerID', y='AverageOrderValue', title='Average Order Value per Customer')
show_to_user(fig)
```",The input Python code uses the AVG function instead of calculating the total order value divided by the number of unique orders. This results in a different computation of the average order value and does not match the logic of the reference implementation.,Base
"What is the average lead time for orders delivered by each supplier, visualized with a bar chart?","```python
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID
""""""
data = execute_sql_query(sql_query)

# Create the bar chart
fig = px.bar(data, x='SupplierID', y='avg_lead_time', title='Average Lead Time by Supplier')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time
FROM orders 
JOIN products ON orders.OrderID = products.ProductID
GROUP BY products.SupplierID
""""""

supplier_lead_time_df = execute_sql_query(sql_query)

fig = px.bar(supplier_lead_time_df, x='SupplierID', y='supplier_lead_time', 
             title='Average Lead Time for Orders Delivered by Each Supplier',
             labels={'supplier_lead_time': 'Average Lead Time (Days)', 'SupplierID': 'Supplier ID'})

show_to_user(fig)
```","The provided code does not implement the same logic as the reference implementation. Specifically, there is an error in the SQL query JOIN: the code joins 'orders' and 'products' directly on 'OrderID' and 'ProductID', whereas the reference code correctly involves '[Order Details]' to join orders and products. This could result in incorrect lead time calculations due to missing linkage through '[Order Details]', which connects 'orders' and 'products'.","```python
import plotly.express as px

sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID;
""""""

df = execute_sql_query(sql_query)
df.columns = ['SupplierID', 'Average_Lead_Time']

fig = px.bar(df, x='SupplierID', y='Average_Lead_Time', title='Average Lead Time by Supplier')
show_to_user(fig)
```","The input code correctly computes and visualizes the average lead time for orders delivered by each supplier, following the same logic as the reference implementation. The SQL query is identical, thus ensuring the same data retrieval and calculation. The column name is adjusted after fetching the data, which does not alter the logic or result. The final visualization step using Plotly Express to create a bar chart also matches the intended functionality.",Finetuned
Which suppliers provide products that are currently out of stock?,"```python
import pandas as pd

# SQL query to find suppliers providing out-of-stock products
sql_query = """"""
SELECT s.SupplierName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.UnitsInStock = 0;
""""""

# Execute the SQL query
out_of_stock_suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(out_of_stock_suppliers_df)
```","```python
sql_query = """"""
SELECT DISTINCT p.SupplierID, p.ProductName 
FROM products p 
WHERE p.UnitsInStock = 0
""""""

out_of_stock_suppliers = execute_sql_query(sql_query)
show_to_user(out_of_stock_suppliers)
```","The provided code lists distinct suppliers and products that are out of stock, but it does not join with the suppliers table to obtain the supplier names. The requirement is to list supplier names, which the provided code does not achieve. It only lists SupplierID and ProductName.","```python
import pandas as pd

# SQL query to find suppliers providing out-of-stock products
sql_query = """"""
SELECT DISTINCT p.SupplierID 
FROM products p 
WHERE p.UnitsInStock = 0 AND p.Discontinued = 0;
""""""

# Execute the SQL query
suppliers_out_of_stock = execute_sql_query(sql_query)

# Display the result
show_to_user(suppliers_out_of_stock)
```","The input code checks for suppliers with products that are both out of stock and not discontinued, which is not part of the reference request. Additionally, it returns SupplierID instead of SupplierName, which differs from the reference logic that focuses on the supplier names. There is also no join with the suppliers table as in the reference implementation, which might lead to incorrect or incomplete information.",None
How many units on order are there for each product?,"```python
import pandas as pd

# SQL query
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitsOnOrder
FROM products p
""""""
units_on_order_df = execute_sql_query(sql_query)
show_to_user(units_on_order_df)
```","The input Python code retrieves the 'ProductID' along with 'ProductName' and 'UnitsOnOrder'. The reference implementation only retrieves 'ProductName' and 'UnitsOnOrder'. The inclusion of 'ProductID' in the SELECT clause is not aligned with the reference implementation and the business request, which specifies focusing on 'UnitsOnOrder' per product name.","```python
import pandas as pd

# SQL query to get units on order for each product
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products;""

# Execute the SQL query
units_on_order_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(units_on_order_df)
```",The input Python code executes the same SQL query as the reference implementation to retrieve 'ProductName' and 'UnitsOnOrder' from the 'products' table. It then displays the DataFrame containing the results. The logic and outcome are equivalent to the reference implementation.,Finetuned
How many units of each product are currently in stock?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT ProductID, ProductName, UnitsInStock FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsInStock 
FROM products
""""""
units_in_stock_df = execute_sql_query(sql_query)
show_to_user(units_in_stock_df)
```","The input code retrieves the ProductName and UnitsInStock from the products table, which fulfills the business request for displaying the stock of each product. The reference code includes ProductID, but it is not necessary for satisfying the question. The logic of getting the product names and their units in stock is consistent with the reference, so the input code is considered correct.","```python
import pandas as pd

# SQL query to get how many units of each product are currently in stock
sql_query = ""SELECT ProductName, UnitsInStock FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input Python code answers the question by retrieving the product names and units in stock from the database, which aligns with the business analytics request. The main difference between the input and reference code is that the input code does not select 'ProductID'. However, it is not a critical requirement for the request itself, as the primary focus is on retrieving product names and stock counts.",both
Which product has the highest unit price but lowest sales quantity?,"```python
import pandas as pd

# SQL query to find the product with the highest unit price but lowest sales quantity
sql_query = """"""
SELECT products.ProductID, products.ProductName 
FROM products 
WHERE products.UnitPrice = (SELECT MAX(products.UnitPrice) FROM products) 
AND products.ProductID NOT IN (
    SELECT ProductID 
    FROM [Order Details] 
    WHERE Quantity > 0
)
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
# SQL query to find the product with the highest unit price but lowest sales quantity
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitPrice, SUM(od.Quantity) AS total_sales_quantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName, p.UnitPrice
ORDER BY p.UnitPrice DESC, total_sales_quantity ASC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show result to the user
show_to_user(result_df)
```","The input code does not accurately implement the logic outlined in the reference code. The reference implementation retrieves the product with the highest unit price and ensures that it has zero sales by utilizing a WHERE clause and a NOT IN subquery to exclude products with any sales quantity greater than zero. Conversely, the input code simply sorts products by descending unit price and ascending sales quantity, returning the first result. This does not guarantee zero sales for the product unless explicitly set in the data. Therefore, the input code fails to replicate the business rule of fetching a product with the highest price and zero sales.","```python
import pandas as pd

# SQL query to find the product with the highest unit price and lowest sales quantity
sql_query = """"""
SELECT ProductName, UnitPrice, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY ProductName, UnitPrice 
ORDER BY UnitPrice DESC, TotalQuantity ASC 
LIMIT 1;
""""""

# Execute the query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The input code aims to find the product with the highest unit price and the lowest total sales quantity, while the reference code identifies a product with the highest unit price but zero sales quantity. The logic differs: the reference seeks a product that's expensive and not sold at all, whereas the input looks for the product with the highest price and least sales.",None
Which product had the highest sales in terms of quantity in March 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
    SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
    GROUP BY products.ProductName 
    ORDER BY total_quantity DESC 
    LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductID
ORDER BY total_quantity DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code is incorrect because it selects 'products.ProductID' instead of 'products.ProductName'. The task requires finding which product had the highest sales in terms of quantity, which should be based on the product name for clarity. Additionally, the input code does not join with the 'products' table, which is necessary to retrieve the product names.","```python
import pandas as pd

sql_query = """"""
SELECT [Order Details].ProductID, SUM([Order Details].Quantity) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY [Order Details].ProductID 
ORDER BY TotalSales DESC 
LIMIT 1;
""""""

highest_sales_product_df = execute_sql_query(sql_query)
show_to_user(highest_sales_product_df)
```","The input Python code selects the ProductID with the highest quantity sold, but does not join with the products table to retrieve the ProductName. Therefore, it does not adhere to the same logic as the reference implementation, which provides the product name with the highest sales quantity.",None
What is the total sales generated by each employee for the past year?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)
```","```python
import pandas as pd

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    e.EmployeeID
""""""

sales_data = execute_sql_query(sql_query)
show_to_user(sales_data)
```","The input Python code is correct. It follows the same SQL logic as the reference implementation for calculating total sales by each employee over the past year. Both snippets use the same SQL query structure, joining the same tables with the same conditions and groupings.","```python
import pandas as pd

query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY e.EmployeeID;
""""""

sales_data = execute_sql_query_to_df(query)
show_to_user(sales_data)
```","The input Python code correctly implements the logic specified in the business analytics request. It executes an SQL query that calculates the total sales for each employee over the past year, similar to the reference implementation. Both codes use joins on employees, orders, and order details tables and apply the same logic to compute total sales, ensuring the results align with the request, despite differences in function naming.",both
Visualize the average number of days between order placement and order shipping by customer.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageDaysToShip
FROM orders
GROUP BY CustomerID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average days to ship by customer
fig = px.bar(data, x='CustomerID', y='AverageDaysToShip', 
             title='Average Days to Ship by Customer',
             labels={'CustomerID': 'Customer ID', 'AverageDaysToShip': 'Average Days to Ship'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgDaysToShip
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY CustomerID
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='CustomerID', y='AvgDaysToShip', title='Average Days Between Order Placement and Shipment by Customer', labels={'AvgDaysToShip': 'Average Days', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It calculates the average days between order placement and shipping by customer using an SQL query. The only difference from the reference implementation is the addition of a WHERE clause to exclude null ShippedDate, which is logical to ensure calculations are based on available data. Moreover, the visualization logic matches the reference implementation, with consistent use of Plotly for creating a bar chart. Therefore, the logic aligns with the reference and fulfills the request.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_days_to_ship FROM orders GROUP BY CustomerID;
""""""

df = execute_sql_query(sql_query)
fig = px.bar(df, x='CustomerID', y='avg_days_to_ship', title='Average Days to Ship by Customer', labels={'avg_days_to_ship': 'Avg Days to Ship'})

show_to_user(fig)
```","The input code is correct because it executes a SQL query to calculate the average days between order placement and shipping by customer, as specified in the business request. It then uses Plotly Express to create a bar chart of these averages. The logic, using DATEDIFF and grouping by CustomerID, is consistent with the reference implementation.",both
Visualize the total sales revenue generated by each product category in the last year.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by product
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY ProductID;
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Assuming we have a separate table to get ProductID to Category mapping
product_category_query = """"""
SELECT ProductID, CategoryName 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID;
""""""
product_category_data = execute_sql_query(product_category_query)

# Merge the data to include CategoryName
merged_data = pd.merge(data, product_category_data, on='ProductID')

# Calculate total sales by Category
category_sales = merged_data.groupby('CategoryName', as_index=False)['TotalSales'].sum()

# Visualize using plotly
fig = px.bar(category_sales, x='CategoryName', y='TotalSales', title='Total Sales Revenue by Product Category in Last Year')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.Category AS ProductCategory,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    p.Category
""""""
sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductCategory', y='TotalSales', title='Total Sales Revenue by Product Category (Last Year)')
show_to_user(fig)
```","The input code performs the same task as the reference code: it calculates the total sales revenue by product category for the last year. Instead of merging data post-query, the input code achieves this by joining the relevant tables in the SQL query itself. This approach is valid and outputs the same result. The visualization part also matches the reference code, using Plotly to generate a bar chart.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.CategoryID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY products.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='CategoryID', y='TotalSales', title=""Total Sales Revenue by Product Category (Last Year)"")

# Show the result to the user
show_to_user(fig)
```","The input code aggregates sales by 'CategoryID' directly, without mapping it to 'CategoryName' using the categories table. The reference implementation merges the product IDs with category names to label the axes with recognizable names. The input code lacks this mapping step, resulting in a less informative visualization.",Base
Identify suppliers that have not supplied any products in the last year.,"```python
import pandas as pd

# SQL query to identify suppliers not active in last year
sql_query = """"""
SELECT suppliers.CompanyName 
FROM suppliers 
LEFT JOIN (
    SELECT products.SupplierID, COUNT(*) AS ProductCount 
    FROM products 
    JOIN ""Order Details"" ON products.ProductID = ""Order Details"".ProductID 
    JOIN orders ON ""Order Details"".OrderID = orders.OrderID 
    WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY products.SupplierID
) AS recent_products 
ON suppliers.SupplierID = recent_products.SupplierID 
WHERE recent_products.ProductCount IS NULL;
""""""

# Execute the query
inactive_suppliers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(inactive_suppliers_df)
```","```python
from datetime import datetime, timedelta

one_year_ago = (datetime.now() - timedelta(days=365)).date()

sql_query = f""""""
SELECT s.SupplierID, s.CompanyName
FROM suppliers s
LEFT JOIN products p ON s.SupplierID = p.SupplierID
LEFT JOIN orders o ON p.ProductID = o.ProductID
WHERE o.OrderDate < '{one_year_ago}' OR o.OrderDate IS NULL
GROUP BY s.SupplierID, s.CompanyName
HAVING MAX(o.OrderDate) < '{one_year_ago}' OR MAX(o.OrderDate) IS NULL
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The provided code incorrectly includes suppliers whose last supply was before a year, instead of those who have supplied no products in the last year purely. It uses LEFT JOIN on orders without limiting it correctly to the past year supplies, allowing suppliers with past supplies still be included. MAX(o.OrderDate) alone does not confirm zero activity within the past year if the latest order is older than a year. The reference code correctly identifies suppliers with zero count of supplies in the last year using JOIN and WHERE conditions with order date check for the last year only and allows suppliers with NULL product count, indicating no supplies.","```python
import pandas as pd

query = """"""
SELECT CompanyName 
FROM suppliers s 
WHERE s.SupplierID NOT IN (
    SELECT DISTINCT p.SupplierID 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    JOIN orders o ON od.OrderID = o.OrderID 
    WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
)
""""""

df = execute_sql_query(query)
show_to_user(df)
```","The given code correctly identifies suppliers that have not supplied any products in the last year. It uses a subquery to find SupplierIDs from the 'products' table that are linked to orders from the past year and selects suppliers not in this list. This matches the logic of the reference implementation, ensuring that only suppliers with no products ordered in the last year are returned.",Finetuned
Which products have stock levels below their reorder level?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
products_below_reorder_level = execute_sql_query(sql_query)
show_to_user(products_below_reorder_level)
```","The input code introduces an additional condition (Discontinued = 0) that is not present in the reference implementation. This means it will exclude products that are discontinued, potentially leading to different results. To match the reference implementation, this condition should not be included.","```python
import pandas as pd

# SQL Query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_below_reorder = execute_sql_query(sql_query)

# Display the result
show_to_user(products_below_reorder)
```",The input Python code is correct as it uses the same SQL query to check for products with stock levels below their reorder level and executes it using the same logic. The query and data processing are consistent with the reference implementation.,Finetuned
How many units of each product are currently on order?,"```python
import pandas as pd

# SQL query to get units on order for each product
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products;""

# Execute SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsOnOrder 
FROM products 
WHERE Discontinued = 0
""""""
data = execute_sql_query(sql_query)
show_to_user(data)
```","The input code adds a condition in the SQL query to exclude discontinued products (WHERE Discontinued = 0), whereas the reference implementation does not include such a condition. Therefore, the input code does not fully adhere to the logic of the reference implementation.","```python
import pandas as pd

sql_query = ""SELECT ProductName, UnitsOnOrder FROM products;""
df = execute_sql_query(sql_query)
show_to_user(df)
```","The input Python code faithfully replicates the logic and intent of the reference implementation. Both codes perform the same SQL query to retrieve the 'ProductName' and 'UnitsOnOrder' from the 'products' table, execute this query to obtain a DataFrame, and display this result to the user. Therefore, the input code correctly addresses the business analytics request.",Finetuned
What is the monthly sales trend for each product over the last year?,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM') AS Month, 
SUM([Order Details].Quantity) AS MonthlySales
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
WHERE [Order Details].OrderDate >= DATEADD(year, -1, GETDATE()) 
GROUP BY products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM');
""""""

# Execute the query and retrieve data as a dataframe
df = execute_sql_query(sql_query)

# Sort the dataframe by Month to ensure the trend line is accurate
df = df.sort_values(by='Month')

# Create a line plot for the monthly sales trend of each product
fig = px.line(df, x='Month', y='MonthlySales', color='ProductID', title='Monthly Sales Trend for Each Product')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductName,
    DATE_FORMAT(od.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
WHERE 
    od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    p.ProductName, Month
ORDER BY 
    p.ProductName, Month
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='Month', y='TotalSales', color='ProductName', 
              title='Monthly Sales Trend for Each Product Over the Last Year',
              labels={'TotalSales': 'Total Sales', 'Month': 'Month'})
show_to_user(fig)
```","Both implementations fulfill the business analytics request by generating a monthly sales trend for each product over the last year. The main differences are the SQL syntax and slight changes in column names (e.g., ProductID vs. ProductName, MonthlySales vs. TotalSales) due to possibly different database systems (T-SQL vs. MySQL or similar). These changes do not affect the correctness as the logic remains equivalent: grouping by product and month, summing quantities, and using Plotly Express for visualization.","```python
import pandas as pd

# SQL Query to get monthly sales trend for each product over the last year
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_FORMAT(od.OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity) AS MonthlySales 
FROM 
    products p 
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
WHERE 
    od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY 
    p.ProductID, 
    Month;
""""""

# Execute SQL Query
sales_data = execute_sql_query(sql_query)

# Display data
show_to_user(sales_data)
```","The input code retrieves and displays the sales data but does not include logic to visualize the trend using a line plot as in the reference implementation. It also queries the ProductName, which is not used in the trend analysis. Moreover, the timestamp function for formatting the date differs (DATE_FORMAT vs. FORMAT), but that's not critical. The missing visualization component is a key divergence from the requested analysis.",Base
Find the average discount provided per order.,"```python
import pandas as pd

# SQL query to get order discounts
sql_query = ""SELECT Discount FROM [Order Details];""

# Execute the SQL query
order_details_df = execute_sql_query(sql_query)

# Calculate the average discount per order
avg_discount = order_details_df['Discount'].mean()

# Prepare the result in a DataFrame for display
result_df = pd.DataFrame({'AvgDiscount': [avg_discount]})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID
""""""
average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code calculates the average discount per order ID using SQL's GROUP BY clause and then computes an average over those grouped results, which can produce a different value than the intended logic. The reference code calculates a simple average over all discount values without grouping by order. Therefore, the logic of the input code does not match the reference implementation.","```python
import pandas as pd

# SQL query to get the average discount per order
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount 
FROM [Order Details];
""""""

# Execute the query
discount_df = execute_sql_query(sql_query)

# Show the result to user
show_to_user(discount_df)
```","Both implementations correctly calculate the average discount provided per order. The reference code calculates the average after fetching all discounts, while the input code directly uses SQL to calculate it. Both achieve the same goal and logic.",Finetuned
Visualize the average quantity per unit for products supplied by each supplier.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT s.SupplierID, s.SupplierName, AVG(CAST(p.QuantityPerUnit AS DECIMAL)) AS AverageQuantityPerUnit
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.SupplierName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(df, x='SupplierName', y='AverageQuantityPerUnit',
             title='Average Quantity Per Unit by Supplier',
             labels={'AverageQuantityPerUnit': 'Average Quantity Per Unit', 'SupplierName': 'Supplier Name'})

# Show to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.SupplierID, 
    AVG(CAST(p.QuantityPerUnit AS DECIMAL)) AS AverageQuantityPerUnit
FROM 
    products p
GROUP BY 
    p.SupplierID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='SupplierID', y='AverageQuantityPerUnit', 
             title='Average Quantity Per Unit by Supplier', 
             labels={'AverageQuantityPerUnit': 'Average Quantity Per Unit', 'SupplierID': 'Supplier ID'})

show_to_user(fig)
```","The input code does not correctly aggregate the data by supplier because it misses joining the suppliers table to include the supplier names, unlike the reference code. The reference code joins the suppliers and products tables to use SupplierName in the visualization, which is a part of the business request to visualize by supplier.","```python
import plotly.express as px

# SQL query to extract required data
sql_query = """"""
SELECT p.SupplierID, AVG(CAST(SUBSTRING_INDEX(p.QuantityPerUnit, ' ', 1, 1) AS DECIMAL)) AS AverageQuantityPerUnit 
FROM products p 
GROUP BY p.SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the data using plotly
fig = px.bar(df, x='SupplierID', y='AverageQuantityPerUnit', 
             title='Average Quantity Per Unit by Supplier',
             labels={'SupplierID': 'Supplier ID', 'AverageQuantityPerUnit': 'Average Quantity Per Unit'})

# Show the visualization to the user
show_to_user(fig)
```","The input code does not correctly implement the specified business analytics request. It calculates the average quantity per unit for products but does not correctly join the suppliers to get the supplier name. Additionally, it uses an incorrect SQL logic with SUBSTRING_INDEX, assuming the quantity format is consistent, which the reference implementation does not. The lack of joining suppliers and using supplier names leads to incomplete results compared to the reference implementation.",None
Visualize the average shipping cost per order for the current year.,"```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# SQL query to get the average shipping cost per order for the current year
sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order 
FROM orders 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE())
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a DataFrame to use for plotting
current_year = datetime.now().year
plot_df = pd.DataFrame({
    'Year': [current_year],
    'Average Shipping Cost': df['shipping_cost_per_order']
})

# Visualize the result
fig = px.bar(plot_df, x='Year', y='Average Shipping Cost',
             labels={'Year': 'Year', 'Average Shipping Cost': 'Average Shipping Cost'},
             title='Average Shipping Cost Per Order for the Current Year')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT AVG(orders.Freight) AS average_shipping_cost_per_order 
FROM orders 
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE());
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='average_shipping_cost_per_order', title='Average Shipping Cost per Order for Current Year')
show_to_user(fig)
```","The input code does not correctly create the DataFrame or use it properly for visualization. The reference implementation constructs a DataFrame with 'Year' and 'Average Shipping Cost' columns, then uses these for plotting. The input code directly attempts to plot from the query result without correctly structuring the data into a DataFrame with a 'Year' column.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get average shipping cost per order for the current year
sql_query = """"""
SELECT AVG(Freight) AS ShippingCostPerOrder 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE());
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Visualize the shipping cost per order
fig = px.bar(df, x=df.index, y='ShippingCostPerOrder', title='Average Shipping Cost per Order for Current Year')
show_to_user(fig)
```","The input code directly uses the result from the SQL query for visualization, without organizing it into a DataFrame with a 'Year' column for x-axis labeling. Unlike the reference implementation, it does not explicitly set the current year as a label and uses index which is not correctly structured. Thus, it lacks the step where the data is explicitly organized for proper visualization labeling, resulting in a potential mismatch in plot labeling.",None
Visualize the top 3 regions by total sales revenue.,"```python
import plotly.express as px

# SQL query to retrieve the top 3 regions by total sales revenue
sql_query = """"""
SELECT customers.Region, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSalesRevenue 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.Region 
ORDER BY TotalSalesRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Visualize the data using plotly
fig = px.bar(df, x='Region', y='TotalSalesRevenue', title='Top 3 Regions by Total Sales Revenue')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
ORDER BY TotalRevenue DESC
LIMIT 3;
""""""

top_regions = execute_sql_query(sql_query)
fig = px.bar(top_regions, x='Region', y='TotalRevenue', title='Top 3 Regions by Total Sales Revenue')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. Both the reference and the input code perform the same SQL query to compute the total sales revenue for each region, order the result in descending order, and select the top 3 regions. They then both use Plotly to create a bar chart to visualize the data and present it to the user. The difference in variable names does not impact functionality as it retains the same logic and outcome.","```python
import pandas as pd

# SQL query to get top 3 regions by total sales revenue
sql_query = """"""
SELECT ShipRegion, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY ShipRegion
ORDER BY TotalRevenue DESC
LIMIT 3
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Visualize the top 3 regions by total sales revenue
visualize_data(data)
```","The input code groups sales revenue by 'ShipRegion' instead of 'Region' as in the reference implementation. This changes the logic and potentially the results, making it inconsistent with the business analytics request.",Base
Visualize how many orders were placed each month.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY OrderMonth;
""""""

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders placed each month
fig = px.bar(df, x='OrderMonth', y='TotalOrders', title='Monthly Orders Count', labels={'OrderMonth': 'Order Month', 'TotalOrders': 'Total Orders'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY Month
""""""

orders_per_month = execute_sql_query(sql_query)

fig = px.line(orders_per_month, x='Month', y='OrderCount', title='Monthly Orders Count', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})
show_to_user(fig)
```","The input code correctly retrieves data for the number of orders placed each month, similar to the reference code. It uses an equivalent SQL query to group orders by month and count them. Although the visualization uses a line chart instead of a bar chart, it still achieves the goal of showing monthly order counts, which adheres to the business request. The choice of a line chart is a minor difference and doesn't deviate from the business analytics request's intent.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create the visualization
fig = px.line(data, x='Month', y='OrderCount', title='Number of Orders Placed Each Month', markers=True)

# Show the result
show_to_user(fig)
```","The input Python code uses a line chart instead of a bar chart as in the reference implementation. Although the logic behind obtaining the data is the same, the request specifies visualizing the data, which is not identical to the given reference, as it uses different visualization types.",Base
Which product has the highest cumulative discount in terms of dollar value?,"```python
# Define the SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Discount * od.UnitPrice * od.Quantity) AS TotalDiscount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalDiscount DESC LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.Discount) AS CumulativeDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY CumulativeDiscount DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code calculates the cumulative discount as the sum of 'od.Quantity * od.Discount', which does not account for the unit price. The reference code multiplies the discount by both the unit price and quantity ('od.Discount * od.UnitPrice * od.Quantity') to get the total dollar value of the discount. Therefore, the logic in the input does not match the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, SUM(od.Discount * od.UnitPrice * od.Quantity) AS total_discount
FROM [Order Details] od
GROUP BY od.ProductID
ORDER BY total_discount DESC
LIMIT 1;
""""""

# Execute SQL query
discount_data = execute_sql_query(sql_query)

# Display the result
show_to_user(discount_data)
```","The input code fetches the ProductID with the highest total discount but does not retrieve the ProductName, unlike the reference code. This means it doesn't fully address the business request to identify the product by name.",None
How many different suppliers are there?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT COUNT(DISTINCT SupplierID) as distinct_suppliers FROM products;""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Extract the count from the dataframe and display
distinct_suppliers_count = result_df['distinct_suppliers'][0]
show_to_user(pd.DataFrame({'Distinct Suppliers Count': [distinct_suppliers_count]}))
```","```python
sql_query = ""SELECT COUNT(DISTINCT SupplierID) AS UniqueSuppliers FROM products""
unique_suppliers_df = execute_sql_query(sql_query)
show_to_user(unique_suppliers_df)
```","The input code correctly counts distinct suppliers by executing a SQL query that counts distinct 'SupplierID'. The query is executed, and the result is displayed to the user, which matches the logic of the reference implementation. The only difference is in how the result is shown, but it still answers the business request accurately.","```python
import pandas as pd

sql_query = ""SELECT DISTINCT SupplierID FROM products;""
df = execute_sql_query(sql_query)
result_count = pd.DataFrame({'SupplierCount': [df['SupplierID'].nunique()]})

show_to_user(result_count)
```","The input code correctly calculates the number of distinct suppliers by executing a query to retrieve unique SupplierIDs, then it counts the number of unique entries using 'nunique()'. This approach results in the same outcome as the reference code which directly counts distinct SupplierIDs in the SQL query. Both implementations result in the correct count of distinct suppliers.",both
Visualize the correlation between freight cost and fulfillment time.,"```python
import plotly.express as px

# SQL query
sql_query = ""SELECT Freight, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders;""

# Execute the query and retrieve data
df = execute_sql_query(sql_query)

# Create a scatter plot to visualize the correlation
fig = px.scatter(df, x='Freight', y='FulfillmentTime', 
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (days)'})

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS FulfillmentTime,
    AVG(Freight) AS FreightCost
FROM 
    orders
GROUP BY 
    YEAR(OrderDate), MONTH(OrderDate)
""""""

data = execute_sql_query(sql_query)

fig = px.scatter(data, x='FreightCost', y='FulfillmentTime', 
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'FreightCost': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (Days)'})

show_to_user(fig)
```","The input code calculates average freight cost and fulfillment time on a monthly basis, which changes the granularity and potentially the observed correlation. The reference code calculates the fulfillment time per order without aggregation, providing a direct scatter plot of individual data points. The approach in the input code does not match the logic of the reference implementation.","```python
import plotly.express as px

# SQL query to get freight cost and fulfillment time
sql_query = """"""
SELECT orders.Freight, DATEDIFF(orders.RequiredDate, orders.OrderDate) as FulfillmentTime FROM orders
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a scatter plot to show the correlation
fig = px.scatter(df, x='Freight', y='FulfillmentTime', title='Correlation between Freight Cost and Fulfillment Time', labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (Days)'})

# Show the plot to the user
show_to_user(fig)
```","The input code uses 'RequiredDate' instead of 'ShippedDate' to calculate 'FulfillmentTime'. This deviates from the reference code logic, which uses 'ShippedDate', indicating a potential difference in the data's meaning and how fulfillment time is defined.",None
Which employee made the highest sales on a specific date?,"```python
from datetime import datetime
import pandas as pd

# Define the date for which we want to find the highest sales
target_date = 'YYYY-MM-DD'

# SQL query to find the employee with the highest sales on the specific date
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate = '{target_date}' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC LIMIT 1;
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
date_query = ""2023-10-01""  # Specify the date you want to look at

sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate = '{date_query}'
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1
""""""

highest_sales_employee = execute_sql_query(sql_query)
show_to_user(highest_sales_employee)
```","The input Python code correctly executes an SQL query based on the business analytics request, similar to the reference implementation. Both codes specify a date for filtering orders, join the necessary tables, calculate total sales per employee, and retrieve the employee with the highest sales on that specific date. The query semantics and logic, including aggregation and ordering, match the reference code precisely, fulfilling the business requirement.","```python
import pandas as pd
from datetime import datetime

# Define the specific date
specific_date = 'YOUR_SPECIFIC_DATE_HERE'

# SQL Query
query = f""""""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE DATE(orders.OrderDate) = '{specific_date}'
GROUP BY employees.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the query
result_df = execute_sql_query(query)

# Display the result
show_to_user(result_df)
```","The provided code and the reference implementation both correctly find the employee with the highest sales on a specific date by executing similar SQL queries. They join the same tables, apply the same calculations for TotalSales, filter by the date, group by EmployeeID, and limit the result to the top record. The query format and logic are equivalent, ensuring correctness.",both
What is the average unit price of products in each category? (Consider visualizing the average unit prices by category using a bar chart for easier comparison.),"```python
import plotly.express as px

# SQL query to execute
sql_query = ""SELECT CategoryID, AVG(UnitPrice) AS AveragePrice FROM products GROUP BY CategoryID;""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit prices by category
fig = px.bar(df, x='CategoryID', y='AveragePrice', title='Average Unit Price by Category')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_prices_df = execute_sql_query(sql_query)
fig = px.bar(average_prices_df, x='CategoryID', y='AverageUnitPrice', 
             title='Average Unit Price by Category', 
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})
show_to_user(fig)
```","The input Python code is logically equivalent to the reference implementation. It calculates the average unit price for each product category using an SQL query, stores the results in a dataframe, and visualizes these results using a bar chart. Although the SQL query uses slightly different column aliases and the Plotly visualization has additional labels for clarity, the core functionality and logic align with the reference code.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice 
FROM products 
GROUP BY CategoryID;
""""""

# Execute query
df = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Category')

# Display the figure
show_to_user(fig)
```","The input Python code correctly calculates the average unit price of products in each category by executing the SQL query that groups by CategoryID and aggregates the UnitPrice using AVG. It matches the logic of the reference implementation. While the alias 'AverageUnitPrice' is slightly different from 'AveragePrice', it doesn't affect the outcome, as the generated dataframe and visualization logic remain consistent, resulting in the same analysis and bar chart.",both
Which product had the highest sales revenue in 2022?,"```python
import pandas as pd

# SQL query to find the product with highest sales revenue in 2022
sql_query = """"""
SELECT products.ProductID, 
       products.ProductName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, products.ProductName
ORDER BY product_sales DESC 
LIMIT 1
""""""

# Execute the SQL query and retrieve the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = 2022
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 1
""""""

highest_sales_product = execute_sql_query(sql_query)
show_to_user(highest_sales_product)
```","The input Python code correctly calculates the highest sales revenue for a product in 2022. Both the input and reference queries join the necessary tables, aggregate the sales correctly accounting for discounts, and filter the results for the year 2022. The input code uses a slightly different approach with the YEAR function, but it effectively achieves the same filtering as the reference code, which uses a BETWEEN condition for the dates. Both queries group by ProductID and ProductName, sort by the total sales in descending order, and limit the results to the top entry. Hence, the input code adheres to the same logic as the reference implementation.","```python
import pandas as pd

query = """"""
SELECT [Order Details].ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS sales_revenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY [Order Details].ProductID 
ORDER BY sales_revenue DESC 
LIMIT 1
""""""

revenue_data = execute_sql_query(query)
show_to_user(revenue_data)
```","The input code accurately calculates the product with the highest sales revenue by the same logic as the reference code by summing the product of UnitPrice, Quantity, and (1 - Discount) for 2022 orders. However, it does not join with the products table and thus lacks the ProductName in the output, which is part of the required output according to the reference implementation.",Base
How many orders have been placed by each customer? (A bar chart can be used to visualize the number of orders per customer.),"```python
import plotly.express as px

# SQL query to get the order count per customer
sql_query = ""SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Creating a bar chart using plotly
fig = px.bar(orders_df, x='CustomerID', y='OrderCount', title='Number of Orders per Customer')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
""""""

order_data = execute_sql_query(sql_query)

fig = px.bar(order_data, x='CustomerID', y='OrderCount', title='Number of Orders per Customer')
show_to_user(fig)
```","The input Python code accurately executes the SQL query to count the number of orders per customer and generates the same bar chart visualization as the reference implementation using Plotly. Both the structure and logic align perfectly with the reference implementation, achieving the same business analytics request.","```python
import plotly.express as px

# SQL query
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID;
'''

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df_orders, x='CustomerID', y='OrderCount', title='Orders by Customer')

# Show the bar chart
show_to_user(fig)
```","The input code correctly executes a SQL query to count the number of orders per customer and groups the results by 'CustomerID'. The result is then visualized as a bar chart using Plotly, with 'CustomerID' on the x-axis and 'OrderCount' on the y-axis. This matches the logic and intent of the reference implementation.",both
Which employee generated the most sales in Q4 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 1
""""""

# Execute the SQL query using the utility function
sales_data_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_data_df)
```","```python
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC 
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code and the reference implementation both aim to identify the employee with the highest sales in Q4 2023. They use similar logic in their SQL queries, aggregating sales based on 'UnitPrice', 'Quantity', and 'Discount', while filtering for the specified date range. The primary difference is that the input code includes employee first and last names in the output, which does not alter the correctness of answering the business request: identifying which employee achieved the most sales during the specified period. The additional fields do not change the logic or outcome of determining the top performer.","```python
import pandas as pd

# SQL query to find the employee with the highest sales in Q4 2023
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY employee_sales DESC 
LIMIT 1
""""""

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input Python code performs the same SQL query as the reference implementation. It calculates the total sales for each employee in Q4 2023, groups by EmployeeID, orders by total sales in descending order, and limits the result to one employee with the highest sales. Both snippets use the same logic and return the same result. Variable names differ but do not affect functionality.",both
"What is the maximum, minimum, and average salary of the employees? (A box plot can visualize salary distribution effectively.)","```python
import plotly.express as px

# Define SQL query
sql_query = ""SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees;""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Display max, min, and average salary
show_to_user(result_df)

# Query to get salary data for box plot
salary_query = ""SELECT Salary FROM employees;""

# Execute query to get all salaries
salary_df = execute_sql_query(salary_query)

# Create box plot for salary distribution
fig = px.box(salary_df, y='Salary', title='Salary Distribution')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees""
salary_stats = execute_sql_query(sql_query)

salaries = execute_sql_query(""SELECT Salary FROM employees"")

fig = px.box(salaries, y='Salary', title='Salary Distribution of Employees')
show_to_user(salary_stats)
show_to_user(fig)
```","The input code correctly calculates the maximum, minimum, and average salary using an SQL query. It then uses another query to retrieve all salaries to create a box plot, similar to the reference implementation. Both the salary statistics and the plot are displayed to the user. The order of execution and logic align with the reference code, even though the function names and structure might slightly differ.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = ""SELECT Salary FROM employees;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate statistics
max_salary = df['Salary'].max()
min_salary = df['Salary'].min()
avg_salary = df['Salary'].mean()

# Display the salaries using a box plot
fig = px.box(df, y='Salary')
show_to_user(fig)

# Display the metrics
metrics_df = pd.DataFrame({'MaxSalary': [max_salary], 'MinSalary': [min_salary], 'AvgSalary': [avg_salary]})
show_to_user(metrics_df)
```","The input Python code appropriately calculates the maximum, minimum, and average salaries and displays this information along with a box plot visualizing the salary distribution. It adheres to the same logic as the reference implementation, although it calculates these statistics in-memory after retrieving all salary data instead of using SQL aggregation functions. Both approaches effectively fulfill the business analytics request.",both
What is the average discount given per order in the last week?,"```python
import pandas as pd

# SQL query to retrieve average discount per order in the last week
sql_query = """"""
SELECT AVG([Order Details].Discount) AS Average_Discount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 WEEK);
""""""

# Execute SQL query and get the result as a dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['Average_Discount'][0])
```","```python
import pandas as pd

# SQL query to get the average discount given per order in the last week
last_week_query = """"""
SELECT AVG([Order Details].Discount) AS AverageDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
""""""

# Execute the SQL query
average_discount_df = execute_sql_query(last_week_query)

# Display the result to the user
show_to_user(average_discount_df)
```","The input code differs from the reference implementation when it comes to displaying the result. The input directly displays 'average_discount_df', which is likely a DataFrame, whereas the reference code accesses the specific 'Average_Discount' value. This means the input might show more than just the average discount value, possibly including column names or additional metadata.","```python
import pandas as pd

# SQL query to find the average discount given per order in the last week
sql_query = """"""
SELECT AVG([Order Details].Discount) AS AvgDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= CURRENT_DATE - INTERVAL '7 days'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df['AvgDiscount'].iloc[0])
```","Both the input and reference SQL queries correctly calculate the average discount for the last week by joining the 'orders' and 'Order Details' tables. They use similar logic: selecting the average of the 'Discount' field, joining on 'OrderID', and filtering by 'OrderDate' for the past week. The result retrieval and display steps are also equivalent, with minor differences in column naming, which don't impact correctness.",Finetuned
What is the average order value for the year 2022?,"```python
import pandas as pd

# SQL query to calculate average order value for the year 2022
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) 
       / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the average order value from the DataFrame
average_order_value = df['avg_order_value'].iloc[0]

# Display the result to user
show_to_user(average_order_value)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)
```","The input code does not extract the average order value from the DataFrame before displaying it. Instead, it directly shows the entire DataFrame, whereas the reference implementation extracts the 'avg_order_value' and shows only the extracted value.","```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) as avg_order_value 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","The input Python code correctly computes the average order value for the year 2022 by selecting and joining the same tables, applying the same calculations, and using the same date range as the reference code. The difference in how the result is displayed (showing the whole DataFrame instead of extracting a single value) does not affect its correctness regarding the analytics request.",Finetuned
How many orders were placed by each customer in the last quarter of 2022? (Consider visualizing this using a bar chart for better insights.),"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
  SELECT CustomerID, COUNT(OrderID) AS OrderCount 
  FROM orders 
  WHERE OrderDate BETWEEN '2022-10-01' AND '2022-12-31' 
  GROUP BY CustomerID
""""""

# Execute the SQL query and get the result as a dataframe
orders_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(orders_data, x='CustomerID', y='OrderCount', title='Orders by Customer in Q4 2022')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= '2022-10-01' AND OrderDate < '2023-01-01'
GROUP BY CustomerID
ORDER BY OrderCount DESC;
""""""

order_counts = execute_sql_query(sql_query)

fig = px.bar(order_counts, x='CustomerID', y='OrderCount', title='Orders Placed by Each Customer in Q4 2022',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input code correctly retrieves the number of orders placed by each customer in the last quarter of 2022. The SQL query uses a valid date range ('2022-10-01' to '2023-01-01'), equivalent to the reference implementation ('2022-10-01' to '2022-12-31'). Both group the data by CustomerID and count the orders. The input code orders the results by OrderCount, which doesn't affect correctness. It then uses Plotly to create a bar chart similar to the reference code and shows it to the user.","```python
import plotly.express as px

# Execute SQL query
sql_query = """"""
SELECT CustomerID, COUNT(*) AS NumberOfOrders 
FROM orders 
WHERE OrderDate BETWEEN '2022-10-01' AND '2022-12-31' 
GROUP BY CustomerID;
""""""
df = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(df, x='CustomerID', y='NumberOfOrders', title='Number of Orders per Customer in Q4 2022')

# Show the result to the user
show_to_user(fig)
```","The input code correctly follows the business analytics request and logic of the reference implementation. Both codes query the orders for the last quarter of 2022, grouping by CustomerID to count orders per customer, and create a similar bar chart visualization using Plotly. The differences in column alias names do not affect the correctness.",both
What is the total quantity of products ordered in each month of the current year? (A line chart or bar chart can illustrate monthly totals.),"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(od.Quantity) AS TotalQuantityOrdered 
FROM `Order Details` od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY Month;
""""""

# Execute SQL query and get data
df = execute_sql_query(sql_query)

# Create a line chart to represent the total quantity ordered each month
fig = px.line(df, x='Month', y='TotalQuantityOrdered', title='Total Quantity of Products Ordered Each Month in Current Year', labels={'TotalQuantityOrdered': 'Total Quantity Ordered'})

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_year = datetime.now().year

sql_query = f""""""
SELECT 
    MONTH(OrderDate) AS Month, 
    SUM(OrderDetails.Quantity) AS TotalQuantity
FROM 
    orders 
JOIN 
    [Order Details] AS OrderDetails ON orders.OrderID = OrderDetails.OrderID
WHERE 
    YEAR(OrderDate) = {current_year}
GROUP BY 
    MONTH(OrderDate)
ORDER BY 
    Month;
""""""

monthly_totals = execute_sql_query(sql_query)

fig = px.bar(monthly_totals, x='Month', y='TotalQuantity', labels={'Month': 'Month', 'TotalQuantity': 'Total Quantity Ordered'}, title='Total Quantity of Products Ordered Each Month')
show_to_user(fig)
```","The input code correctly implements the SQL query to calculate the total quantity of products ordered per month in the current year. It computes the monthly totals, groups by month, and correctly utilizes the `MONTH()` function for grouping. The result is displayed using a bar chart, which is an acceptable way to present this data, aligning with the request for a monthly breakdown of totals. The logic aligns with the reference implementation, though it uses a different chart type.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, SUM([Order Details].Quantity) as TotalQuantity 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='Month', y='TotalQuantity', title='Total Quantity of Products Ordered Per Month')

# Show the chart to user
show_to_user(fig)
```","The input code correctly answers the business analytics request by calculating the total quantity of products ordered in each month of the current year. Although it uses square brackets and a bar chart instead of a line chart, the logic and output are consistent with the reference implementation. Both codes execute a similar SQL query to aggregate monthly totals and visualize the result.",both
How many orders included products with more than a 10% discount?,"```python
import pandas as pd

# Define SQL query to count distinct orders with more than 10% discount
sql_query = """"""
SELECT COUNT(DISTINCT od.OrderID) as NumberOfOrders 
FROM [Order Details] od 
WHERE od.Discount > 0.10
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df['NumberOfOrders'][0])
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT od.OrderID) AS OrdersWithDiscount
FROM [Order Details] od
WHERE od.Discount > 0.10
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code executes a similar SQL query to the reference, correctly counting distinct orders with more than a 10% discount. However, it displays the entire 'result_df' DataFrame instead of extracting and showing only the relevant count, potentially leading to a format mismatch.","```python
import pandas as pd

query = """"""
SELECT COUNT(DISTINCT od.OrderID) AS NumberOfOrdersWithHighDiscount 
FROM [Order Details] od 
WHERE od.Discount > 0.1
""""""

# Execute the SQL query
result_df = execute_sql_query(query)

# Display the result to the user
show_to_user(result_df)
```","The input code is mostly correct, but it doesn't match the reference implementation in how the result is displayed. Instead of extracting the specific value using 'result_df['NumberOfOrders'][0]', it shows the entire dataframe using 'show_to_user(result_df)'. This could lead to an incorrect display of results depending on the implementation of 'show_to_user'.",None
What is the inventory turnover ratio for the past month?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 MONTH')
AND EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '1 MONTH');
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to calculate the Inventory Turnover Ratio
sql_query = """"""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) AS COGS,
    AVG(products.UnitsInStock) AS Average_Inventory
FROM 
    products
JOIN 
    [Order Details]
ON 
    products.ProductID = [Order Details].ProductID
WHERE 
    [Order Details].OrderID IN (
        SELECT OrderID 
        FROM Orders 
        WHERE OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' 
        AND OrderDate < DATE_TRUNC('month', CURRENT_DATE)
    )
""""""

# Execute the SQL query and retrieve the data
inventory_data = execute_sql_query(sql_query)

# Calculate Inventory Turnover Ratio
if not inventory_data.empty:
    inventory_turnover_ratio = inventory_data['COGS'].iloc[0] / inventory_data['Average_Inventory'].iloc[0]
else:
    inventory_turnover_ratio = None

# Display the result to the user
result_df = pd.DataFrame({'Inventory Turnover Ratio': [inventory_turnover_ratio]})
show_to_user(result_df)
```","The input code calculates the Inventory Turnover Ratio using a SQL query and applies the same logic as the reference implementation. It calculates the cost of goods sold (COGS) and the average inventory for the past month, matching the filtering on the year and month of the orders. Although the query structure differs slightly, the essential logic and filtering criteria are the same. The inventory turnover ratio is then derived by dividing COGS by the average inventory, similar to the reference code.","```python
import pandas as pd

# SQL query to get data for the last month
sql_query = """"""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / 
    AVG(products.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    products 
JOIN 
    [Order Details] 
ON 
    products.ProductID = [Order Details].ProductID 
WHERE 
    DATE([Order Details].OrderDate) BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 MONTH) AND CURDATE()
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Select the InventoryTurnoverRatio column and display it
show_to_user(result_df[['InventoryTurnoverRatio']])
```","The input code is incorrect because it calculates the Inventory Turnover Ratio using an incorrect date filter. The reference implementation accurately filters orders from the past month using the EXTRACT and CURRENT_DATE functions, while the input code uses DATE_SUB, which might not correctly filter for just the past calendar month. Additionally, the input query doesn't correctly join the orders table, which is necessary to filter the OrderDate properly. Lastly, the reference uses specific filtering for year and month, which ensures accuracy for any month change, while 'DATE_SUB' and 'CURDATE' could result in an incorrect calculation.",Base
Find the top 3 cities with the most orders placed. (A bar chart can be useful to visualize and compare the top cities.),"```python
import plotly.express as px

# SQL query to get the top 3 cities with the most orders placed
sql_query = """"""
SELECT ShipCity, COUNT(*) AS total_orders 
FROM orders 
GROUP BY ShipCity 
ORDER BY total_orders DESC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top cities
fig = px.bar(df, x='ShipCity', y='total_orders', title='Top 3 Cities with Most Orders', labels={'ShipCity': 'City', 'total_orders': 'Total Orders'})

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.City, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.City
ORDER BY OrderCount DESC
LIMIT 3
""""""

top_cities_df = execute_sql_query(sql_query)

fig = px.bar(top_cities_df, x='City', y='OrderCount', title='Top 3 Cities with Most Orders', labels={'OrderCount': 'Number of Orders', 'City': 'City'})
show_to_user(fig)
```","Both implementations fulfill the requirement to find the top 3 cities with the most orders and subsequently visualize them using a bar chart. The input code uses a JOIN clause to obtain city names via the 'customers' table and groups by city, similar to the reference code's approach which directly uses the 'ShipCity' from 'orders'. The aggregation and ordering logic remain consistent, ensuring correctness in solving the business request.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT City, COUNT(OrderID) AS OrderCount 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
GROUP BY City 
ORDER BY OrderCount DESC 
LIMIT 3;
""""""

# Execute the SQL query
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart for the top 3 cities with the most orders placed
fig = px.bar(top_cities_df, x='City', y='OrderCount', 
             title='Top 3 Cities with Most Orders',
             labels={'City': 'City', 'OrderCount': 'Orders Placed'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code is querying data from the customers table and using a JOIN on the orders table. It counts orders based on the city from the customers table instead of the shipping city from the orders table, which may not align with business analytics requests focusing on 'ShipCity'. The sql query should target the orders table directly, analogous to the reference implementation.",Base
What is the average shipping cost per order for orders shipped to 'Canada'?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Freight) AS AverageShippingCost FROM orders WHERE ShipCountry = 'Canada';""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Since the result is a single value in a DataFrame, extract and print it.
average_shipping_cost = df['AverageShippingCost'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'AverageShippingCost': [average_shipping_cost]}))
```","```python
import pandas as pd

sql_query = """"""
SELECT AVG(Freight) AS AverageShippingCost
FROM orders
WHERE ShipCountry = 'Canada'
""""""

average_shipping_cost_df = execute_sql_query(sql_query)
show_to_user(average_shipping_cost_df)
```","The input code correctly captures the business requirement of calculating the average shipping cost for orders shipped to 'Canada'. It uses the same SQL logic as the reference code by querying the database for the average 'Freight' where 'ShipCountry' is 'Canada'. The key difference is that the input code directly passes the resulting DataFrame to the 'show_to_user' function without extracting the value. However, this adjustment doesn't affect the correctness as long as 'show_to_user' can handle DataFrames, which is implied by the reference code.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Freight) AS avg_shipping_cost FROM orders WHERE ShipCountry = 'Canada';""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df['avg_shipping_cost'].item())
```","Both implementations execute the same SQL query to calculate the average freight cost for orders shipped to Canada. The only difference is that the input code directly displays the result using 'df['avg_shipping_cost'].item()' rather than wrapping it in a DataFrame. This approach still correctly displays the average shipping cost as requested. Therefore, the input code correctly answers the business analytics request following the same logic as the reference implementation.",both
What is the retention rate of customers comparing the first half of 2023 to the previous year? (A line graph could help show changes in retention rates over time.),"```python
import pandas as pd
import plotly.express as px

# Define SQL queries
first_half_2023_query = """"""
SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_2023_1H
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
""""""

previous_year_query = """"""
SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_prev_year
FROM orders o 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute queries
first_half_2023_df = execute_sql_query(first_half_2023_query)
previous_year_df = execute_sql_query(previous_year_query)

# Calculate retention rate
customer_retention_rate = (first_half_2023_df['customer_count_2023_1H'][0] / 
                           previous_year_df['customer_count_prev_year'][0])

# Create DataFrame for visualization
retention_data = pd.DataFrame({
    'Period': ['First Half 2023'],
    'Retention Rate': [customer_retention_rate]
})

# Visualize retention rate
fig = px.line(retention_data, x='Period', y='Retention Rate', 
              title='Customer Retention Rate: First Half 2023 vs Previous Year')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query_2022 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS returning_customers
FROM orders 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-06-30'
AND orders.CustomerID IN (SELECT CustomerID FROM orders WHERE OrderDate < '2022-01-01')
""""""

sql_query_2023 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS returning_customers
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
AND orders.CustomerID IN (SELECT CustomerID FROM orders WHERE OrderDate < '2023-01-01')
""""""

sql_query_total_customers_2022 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS total_customers
FROM orders 
WHERE orders.OrderDate < '2022-01-01'
""""""

sql_query_total_customers_2023 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS total_customers
FROM orders 
WHERE orders.OrderDate < '2023-01-01'
""""""

retention_2022 = execute_sql_query(sql_query_2022)['returning_customers'][0] / execute_sql_query(sql_query_total_customers_2022)['total_customers'][0]
retention_2023 = execute_sql_query(sql_query_2023)['returning_customers'][0] / execute_sql_query(sql_query_total_customers_2023)['total_customers'][0]

retention_df = pd.DataFrame({
    'Year': ['2022', '2023'],
    'Retention Rate': [retention_2022, retention_2023]
})

fig = px.line(retention_df, x='Year', y='Retention Rate', title='Customer Retention Rate (2022 vs 2023)', markers=True)
show_to_user(fig)
```","The provided input code calculates the retention rate based on customers returning within a half-year period of each respective year, whereas the reference code calculates the retention rate based on the total number of distinct customers from the full previous year compared to the first half of 2023. Additionally, the input code calculates the retention for 2022 using the same period from the previous year's data for comparison to 2023, which is not consistent with the business request focused exclusively on comparing the first half of 2023 with the entire previous year.","```python
import pandas as pd
import plotly.express as px

# SQL Queries
query_retention_2023 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) * 1.0 / 
(SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate < '2023-01-01') 
FROM orders WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
""""""

query_retention_2022 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) * 1.0 / 
(SELECT COUNT(DISTINCT orders.CustomerID) FROM orders WHERE orders.OrderDate < '2022-01-01') 
FROM orders WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-06-30'
""""""

# Execute SQL Queries
df_2023 = execute_sql_query(query_retention_2023)
df_2022 = execute_sql_query(query_retention_2022)

# Prepare Data for Visualization
df = pd.DataFrame({
    'Year': ['2022', '2023'],
    'Retention Rate': [df_2022.iloc[0, 0], df_2023.iloc[0, 0]]
})

# Plot the Data
fig = px.line(df, x='Year', y='Retention Rate', title='Customer Retention Rate: 2023 vs 2022')

# Show the Plot
show_to_user(fig)
```","The input code calculates the retention rate for the first half of each year (2022 and 2023) as a ratio of customers in that half-year to all customers before the respective year. The reference implementation calculates the retention rate as the number of unique customers in the first half of 2023 over all unique customers in the entirety of 2022. Hence, the input code's logic diverges from the reference implementation.",None
How many distinct products have been ordered?,"```python
import pandas as pd

# SQL query to get the distinct product IDs
sql_query = ""SELECT DISTINCT ProductID FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate the count of distinct products
distinct_product_count = len(result_df)

# Display the result to the user
show_to_user(pd.DataFrame({'DistinctProducts': [distinct_product_count]}))
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT ProductID) AS distinct_product_count
FROM [Order Details]
""""""

distinct_products_df = execute_sql_query(sql_query)
show_to_user(distinct_products_df)
```","The input code and the reference code both determine the number of distinct products from the 'Order Details' table. The input code uses SQL to directly count the distinct ProductIDs and returns the count, which is functionally equivalent to retrieving distinct IDs and then counting them as in the reference. Both methods yield the same result.","```python
import pandas as pd

# SQL query to find distinct products ordered
sql_query = ""SELECT DISTINCT ProductID FROM [Order Details];""

# Execute the query
distinct_products_df = execute_sql_query(sql_query)

# Count the number of distinct products
distinct_product_count = len(distinct_products_df)

# Display the result
show_to_user(pd.DataFrame({
    'count': [distinct_product_count]
}))
```","The input code correctly follows the same logic as the reference implementation. Both execute a SQL query to select distinct 'ProductID' from the 'Order Details' and then count the number of distinct products using the length of the resulting DataFrame. Although the final DataFrame column name differs ('DistinctProducts' vs 'count'), it doesn't affect the logical correctness regarding the business request.",both
How many orders were placed each month by each customer? (A stacked bar chart might provide a clear visual representation.),"```python
import plotly.express as px

# Step 1: Execute SQL Query
sql_query = """"""
SELECT c.CustomerID, DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth, 
COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID, OrderMonth;
""""""
df = execute_sql_query(sql_query)

# Step 2: Create a stacked bar chart
fig = px.bar(df, x='OrderMonth', y='OrderCount', color='CustomerID', 
             title='Monthly Orders by Customer', 
             labels={'OrderMonth':'Order Month', 
                     'OrderCount':'Order Count', 
                     'CustomerID':'Customer ID'}, 
             barmode='stack')

# Step 3: Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    C.CustomerID, 
    C.CompanyName,
    DATE_FORMAT(O.OrderDate, '%Y-%m') AS OrderMonth, 
    COUNT(O.OrderID) AS OrderCount
FROM 
    customers AS C
JOIN 
    orders AS O ON C.CustomerID = O.CustomerID
GROUP BY 
    C.CustomerID, OrderMonth
ORDER BY 
    C.CustomerID, OrderMonth;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, 
             x='OrderMonth', 
             y='OrderCount', 
             color='CompanyName', 
             title='Monthly Orders by Customer',
             labels={'OrderCount': 'Number of Orders', 'OrderMonth': 'Month'},
             barmode='stack')

show_to_user(fig)
```","The input Python code fulfills the business analytics request by counting the number of orders placed each month by each customer. Although it uses 'CompanyName' for coloring the chart instead of 'CustomerID', the logic of summing orders per customer per month is consistent with the reference implementation. The addition of 'CompanyName' improves the chart's readability without altering the desired outcome. Both implementations achieve the same analytical objective.","```python
import plotly.express as px

# SQL query to retrieve the data
sql_query = """"""
SELECT 
    CustomerID, 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
    COUNT(OrderID) AS OrdersCount 
FROM orders 
GROUP BY CustomerID, OrderMonth;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a stacked bar chart
fig = px.bar(df, x='OrderMonth', y='OrdersCount', color='CustomerID', 
             title='Monthly Orders per Customer', 
             labels={'OrderMonth': 'Month', 'OrdersCount': 'Number of Orders'})

# Show the visualization
show_to_user(fig)
```","The input Python code effectively implements the business analytics request by calculating the number of orders placed each month per customer using a SQL query. It then visualizes the data with a stacked bar chart. The key differences are the names of the columns ('OrdersCount' vs 'OrderCount') and that the customers table is not explicitly joined in the input code. However, assuming the 'orders' table inherently includes 'CustomerID', the logic remains equivalent to the reference implementation regarding grouping and visualization. Thus, the code is correct in answering the request.",both
What is the hire date of the oldest employee?,"```python
import pandas as pd

# Execute the SQL query to get the oldest employee's hire date
sql_query = ""SELECT e.FirstName, e.LastName, e.HireDate FROM employees e ORDER BY e.HireDate ASC LIMIT 1""
oldest_employee_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(oldest_employee_df)
```","```python
sql_query = """"""
SELECT HireDate 
FROM employees 
ORDER BY HireDate ASC 
LIMIT 1;
""""""

oldest_employee_hire_date = execute_sql_query(sql_query)
show_to_user(oldest_employee_hire_date)
```","The input code correctly queries the hire date of the oldest employee by ordering by the hire date in ascending order and limiting the result to one, which matches the logic of the reference implementation. Both implementations focus on obtaining the earliest hire date. The minor variation in the query selecting only the 'HireDate' column does not impact the correctness with respect to the specified task.","```python
import pandas as pd

# SQL Query
sql_query = ""SELECT HireDate FROM employees ORDER BY BirthDate ASC LIMIT 1;""

# Execute SQL Query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```",The input code queries the 'HireDate' but orders by 'BirthDate' instead of 'HireDate'. This doesn't fulfill the requirement to find the hire date of the oldest employee based on hire date. The reference code orders by 'HireDate' to find the earliest hire date.,Base
How many order details entries have a discount greater than 10%?,"```python
import pandas as pd

# The SQL query to get the count of order details entries with a discount greater than 10%
sql_query = ""SELECT COUNT(*) as count FROM [Order Details] WHERE Discount > 0.1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the count result to the user
show_to_user(result_df['count'][0])
```","```python
sql_query = """"""
SELECT COUNT(*) AS discount_count
FROM [Order Details]
WHERE Discount > 0.10
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly calculates the count of order details entries with a discount greater than 10%. However, it does not access and display the specific count value like the reference implementation, which calls `result_df['count'][0]`. Instead, it displays the entire DataFrame `result_df`, which is not identical in logic and output formatting.","```python
import pandas as pd

# SQL query to get the count of order details with discount > 10%
sql_query = ""SELECT COUNT(*) as DiscountedOrders FROM [Order Details] WHERE Discount > 0.1;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['DiscountedOrders'][0])
```",The input code correctly implements the business logic requested. It executes a SQL query to count entries in [Order Details] with a discount greater than 10%. The SQL query and execution logic match the reference implementation. The final display function also shows the correct value from the query result.,Finetuned
Which supplier has the highest average lead time? (A bar chart can highlight differences among suppliers.),"```python
import plotly.express as px

# SQL query to retrieve data on suppliers and their average lead time
sql_query = """"""
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY s.CompanyName 
ORDER BY AverageLeadTime DESC
""""""

# Execute the SQL query and get the data in a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to highlight differences among suppliers
fig = px.bar(df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    s.CompanyName,
    AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
GROUP BY 
    s.CompanyName
ORDER BY 
    AverageLeadTime DESC
""""""

lead_time_df = execute_sql_query(sql_query)

fig = px.bar(lead_time_df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier')
show_to_user(fig)
```","The input code uses a different approach in the SQL query's JOIN logic. The reference code correctly joins 'Order Details' directly with 'orders' using 'OrderID'. In contrast, the input code uses a subquery in the WHERE clause of the JOIN condition, which is not equivalent. This difference may lead to incorrect or inefficient results. Additionally, 'orders' is not joined with 'Order Details'; instead, a subquery is used, which is redundant and potentially incorrect.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.CompanyName;
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier')
show_to_user(fig)
```","Both implementations effectively address the business analytics request by calculating the average lead time for each supplier and generating a bar chart to visualize these averages. Despite slight syntactical differences, the logic of the input code aligns with the reference implementation. Both use SQL queries to perform the required calculations and utilize Plotly to visualize the results. The ordering clause in the reference code is not essential to meet the initial request, as it requires identifying the supplier with the highest average lead time using visual analysis. Therefore, the input code is considered correct.",Finetuned
Identify employees whose orders had the highest average discount applied. (Consider using a bar chart to visualize discounts by employee.),"```python
import plotly.express as px

# SQL query to retrieve required data
sql_query = """"""
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY AvgDiscount DESC;
""""""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Visualize the average discount by employee using a bar chart
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', title='Average Discount by Employee')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY AverageDiscount DESC
""""""

result_df = execute_sql_query(sql_query)
fig = px.bar(result_df, x=""FirstName"", y=""AverageDiscount"", color=""LastName"", title=""Average Discount by Employee"")
show_to_user(fig)
```","The input code correctly retrieves and visualizes average discounts by employee. It extends the reference by including first and last names in the query and bar chart, but the logic matches: calculating average discounts per employee and visualizing them. The orders are still grouped by EmployeeID correctly, and sorted by average discount.","```python
import plotly.express as px

query = """"""
SELECT EmployeeID, AVG([Order Details].Discount) AS AvgDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY EmployeeID 
ORDER BY AvgDiscount DESC;
""""""

df = execute_sql_query(query)
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', title='Average Discount by Employee')
show_to_user(fig)
```","The input code is incorrect because it does not join the 'employees' table. It only joins 'Order Details' and 'orders', leading to the aggregation of discounts without associating them with employees. Hence, it cannot identify which employees had the highest average discount.",Base
What is the average unit price of products within each category? Show this using a bar chart of categories along with their average unit prices.,"```python
import plotly.express as px

# SQL Query to get average unit price per category
sql_query = ""SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice FROM products GROUP BY CategoryID;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the data type for CategoryID is string for proper categorical display
df['CategoryID'] = df['CategoryID'].astype(str) 

# Create a bar chart using plotly
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price per Category')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_prices_df = execute_sql_query(sql_query)

fig = px.bar(average_prices_df, x='CategoryID', y='AverageUnitPrice', 
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'},
             title='Average Unit Price of Products by Category')

show_to_user(fig)
```","The input code fulfills the business analytics request by calculating the average unit price for each product category and visualizing the results using a bar chart. It executes a SQL query that groups products by CategoryID and calculates the average UnitPrice, similar to the reference implementation. It also uses plotly to create and display the bar chart, which matches the reference implementation's intent.","```python
import plotly.express as px

sql_query = """"""
SELECT categories.CategoryName, AVG(products.UnitPrice) AS AverageUnitPrice 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName;
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='CategoryName', y='AverageUnitPrice', title='Average Unit Price by Category')
show_to_user(fig)
```","Both implementations calculate the average unit price per category and present it in a bar chart. The input code joins the 'products' and 'categories' tables to display category names instead of IDs, aligning with common presentation preferences. This still satisfies the business requirement as the main calculation and visualization are correct.",both
List the employees who have never made a sale.,"```python
import pandas as pd

# SQL query to retrieve employees who have never made a sale
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o 
ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL
""""""

# Execute the SQL query
employees_without_sales_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(employees_without_sales_df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.EmployeeID IS NULL
""""""
employees_with_no_sales = execute_sql_query(sql_query)
show_to_user(employees_with_no_sales)
```","The input Python code incorrectly uses 'WHERE o.EmployeeID IS NULL', which will not identify employees who have never made a sale. The reference implementation correctly uses 'WHERE o.OrderID IS NULL' to check for this condition by ensuring there are no matching orders for an employee.","```python
import pandas as pd

# SQL query to get employees who never made a sale
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL;
""""""

# Execute the SQL query
employees_no_sales_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_no_sales_df)
```","The input Python code follows the same logic as the reference implementation. Both scripts contain a SQL query that retrieves employees who have never made a sale by using a LEFT JOIN between the employees table and the orders table, and filtering where the OrderID is NULL. The execution and display functions are also the same, indicating the code correctly answers the business analytics request.",Finetuned
How many orders were shipped but not yet delivered?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT OrderID FROM orders WHERE ShippedDate IS NOT NULL AND RequiredDate IS NULL;""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Count the number of orders shipped but not yet delivered
shipped_not_delivered_count = orders_df.shape[0]

# Create a result DataFrame to display
result_df = pd.DataFrame({
    ""Shipped but Not Delivered Count"": [shipped_not_delivered_count]
})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS TotalShippedNotDelivered
FROM orders
WHERE ShippedDate IS NOT NULL AND (DeliveredDate IS NULL OR DeliveredDate > CURRENT_DATE);
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code differs in logic from the reference code. The reference code filters orders where 'ShippedDate' is not null and 'RequiredDate' is null, implying the requirement date is not yet met. In contrast, the input code counts orders with 'ShippedDate' not null and either no 'DeliveredDate' or a 'DeliveredDate' in the future, which doesn't match the required logic.","```python
import pandas as pd

# SQL query to get shipped but not yet delivered orders based on ShippedDate
sql_query = ""SELECT OrderID FROM orders WHERE ShippedDate IS NOT NULL AND ShippedDate > CURRENT_DATE()""

# Execute the query
df = execute_sql_query(sql_query)

# Calculate the count of orders
order_count = pd.DataFrame({'OrderCount': [df.shape[0]]})

# Display the result
show_to_user(order_count)
```","The input code incorrectly filters for orders based on 'ShippedDate > CURRENT_DATE()', which includes only orders shipped after the current date. Instead, it should check for 'RequiredDate IS NULL' to identify orders that are shipped but not yet delivered. The reference code uses the correct filter conditions.",None
Which orders have the highest discounts applied? Visualize the top orders with the highest discounts using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get order discounts
sql_query = """"""
SELECT orders.OrderID, MAX([Order Details].Discount) AS MaxDiscount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY orders.OrderID 
ORDER BY MaxDiscount DESC 
LIMIT 10
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the top orders with the highest discounts
fig = px.bar(df, x='OrderID', y='MaxDiscount', title='Top Orders with Highest Discounts')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.OrderID, SUM(od.Discount) AS TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderID
ORDER BY TotalDiscount DESC
LIMIT 10
""""""

top_discounts = execute_sql_query(sql_query)

fig = px.bar(top_discounts, x='OrderID', y='TotalDiscount', title='Top 10 Orders with Highest Discounts', labels={'TotalDiscount': 'Total Discount', 'OrderID': 'Order ID'})
show_to_user(fig)
```","The input code calculates 'TotalDiscount' with SUM, while the reference code calculates 'MaxDiscount' with MAX. The logic differs as one sums discounts per order and the other selects the maximum discount per order.","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, SUM(Discount) as TotalDiscount 
FROM [Order Details] 
GROUP BY OrderID 
ORDER BY TotalDiscount DESC;
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='OrderID', y='TotalDiscount', title='Top Orders with Highest Discounts')
show_to_user(fig)
```","The input code calculates the total discount per order by summing up the discounts on each order from the 'Order Details' table. It orders them by the total discount and visualizes this. The reference code, however, calculates the highest individual discount applied to each order, regardless of the accumulated discount, and visualizes the top ones with the highest individual discount. Thus, the input code does not adhere to the same logic requested.",None
What is the average time taken to ship an order? Use a histogram to visualize the distribution of shipping times.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get the shipping times
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) as ShippingTime FROM orders;
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Calculate the average shipping time
average_shipping_time = df['ShippingTime'].mean()

# Display the average shipping time to the user
average_df = pd.DataFrame({'AverageShippingTime': [average_shipping_time]})
show_to_user(average_df)

# Create a histogram to visualize the distribution of shipping times
fig = px.histogram(df, x='ShippingTime', title='Distribution of Shipping Times')

# Display the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate shipping times
sql_query = """"""
SELECT 
    DATEDIFF(ShippedDate, OrderDate) AS ShippingTime 
FROM 
    orders 
WHERE 
    ShippedDate IS NOT NULL;
""""""

# Execute the query and get the data
shipping_times_df = execute_sql_query(sql_query)

# Calculate the average shipping time
average_shipping_time = shipping_times_df['ShippingTime'].mean()

# Create a histogram to visualize the distribution of shipping times
fig = px.histogram(shipping_times_df, x='ShippingTime', title='Distribution of Shipping Times',
                   labels={'ShippingTime': 'Shipping Time (Days)'})

# Show the results to the user
show_to_user(fig)

# Print the average shipping time for reference
print(f'Average Shipping Time: {average_shipping_time} days')
```","The input Python code correctly calculates the average shipping time and creates a histogram to visualize the distribution of shipping times, just like the reference implementation. The minor difference in filtering out null 'ShippedDate' values does not affect the correctness of the primary logic or the result.","```python
import pandas as pd
import plotly.express as px

# SQL query to get shipping times
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS shipping_time FROM orders;
""""""

# Execute the SQL query
shipping_df = execute_sql_query(sql_query)

# Calculate the average shipping time
average_shipping_time = shipping_df['shipping_time'].mean()

# Create a histogram for the distribution of shipping times
fig = px.histogram(shipping_df, x='shipping_time', title='Distribution of Shipping Times',
                   labels={'shipping_time': 'Shipping Time (Days)'})

# Display the average and histogram
show_to_user(pd.DataFrame({'average_shipping_time': [average_shipping_time]}))
show_to_user(fig)
```","The input code correctly answers the business analytics request by calculating the average shipping time and visualizing the distribution using a histogram. It mirrors the logic of the reference code: executing the SQL query, calculating the mean of shipping times, and displaying this information along with a histogram. The minor differences, such as variable names and label additions, do not deviate from the required functionality or logic.",both
List the top 5 products by sales for Q2 2023. Represent these top products using a bar chart for better insight.,"```python
import plotly.express as px

# SQL query to list top 5 products by sales for Q2 2023
sql_query = """"""
SELECT products.ProductID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY products.ProductID 
ORDER BY total_sales DESC 
LIMIT 5
""""""

# Execute the SQL query
df_top_products = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df_top_products, x='ProductID', y='total_sales', title='Top 5 Products by Sales for Q2 2023')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get top 5 products by sales for Q2 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 5
""""""

# Execute SQL query
top_products = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(top_products, x='ProductName', y='total_sales', 
             title='Top 5 Products by Sales for Q2 2023', 
             labels={'total_sales': 'Total Sales', 'ProductName': 'Product Name'})

# Show to user
show_to_user(fig)
```","The input code meets the requirements of the business analytics request by listing the top 5 products by sales for Q2 2023 and displaying them using a bar chart. Although the input code includes the 'ProductName' in the SQL query and bar chart, it adheres to the same logic as the reference implementation for extracting and visualizing the top-selling products. Both implementations calculate total sales correctly and order by total sales to select the top 5 products. The addition of 'ProductName' provides more detailed insight without affecting correctness.","```python
import plotly.express as px

# SQL Query to retrieve top 5 products by sales for Q2 2023
sql_query = """"""
SELECT p.ProductID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY p.ProductID 
ORDER BY TotalSales DESC 
LIMIT 5
""""""

# Execute SQL query and get the result in a pandas DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(top_products_df, x='ProductID', y='TotalSales', title='Top 5 Products by Sales for Q2 2023')

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly calculates the top 5 products by sales for Q2 2023, matching the logic of the reference implementation. It selects product IDs and their total sales, filters by the same date range, groups by product, and orders the results by total sales in descending order, limiting the output to 5 entries. The chart creation and display use the same methods as the reference. Despite minor differences in naming conventions and formatting, the input code produces the same output as the reference.",both
Which products from each supplier have not been discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, products.ProductName 
FROM suppliers 
INNER JOIN products 
ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 0;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, p.ProductID, p.ProductName
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.Discontinued = 0
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The evaluated code returns additional columns (SupplierID, ProductID) not present in the reference code, which only returns CompanyName and ProductName. Thus, the evaluated code does not strictly adhere to the same logic as the reference implementation.","```python
import pandas as pd

query = """"""
SELECT p.ProductName, s.CompanyName 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
WHERE p.Discontinued = 0;
""""""

data = execute_sql_query(query)
show_to_user(data)
```","The input code correctly joins products and suppliers using SupplierID, filters products that have not been discontinued (WHERE p.Discontinued = 0), and retrieves the ProductName and CompanyName. The order of columns is different, but the logic and output are consistent with the reference implementation.",Finetuned
What is the total number of orders where the quantity ordered exceeded 50 units in 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT COUNT(orders.OrderID) AS large_orders 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Quantity > 50 
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and get the result in a dataframe
df_large_orders = execute_sql_query(sql_query)

# Extract the count value from the dataframe
large_orders_count = df_large_orders.iloc[0]['large_orders']

# Display the result to the user
show_to_user(pd.DataFrame({'Large Orders Count': [large_orders_count]}))
```","```python
sql_query = """"""
SELECT COUNT(*) AS total_orders
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Quantity > 50 
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code constructs a SQL query that counts orders where the quantity exceeds 50 and the order date is within 2023, matching the logic and intent of the reference code. Both codes use similar JOIN and WHERE clauses. The difference is cosmetic, with variable names and output formatting differing slightly but not affecting the core logic or business requirement fulfillment.","```python
import pandas as pd

# SQL Query to get the total number of orders exceeding 50 units in 2023
sql_query = """"""
SELECT COUNT(DISTINCT OrderID) AS TotalOrders 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Quantity > 50 
AND YEAR(orders.OrderDate) = 2023;
""""""

# Execute the SQL query
result = execute_sql_query(sql_query)

# Display the result
show_to_user(result)
```","The input code is using 'COUNT(DISTINCT OrderID)' which could potentially lead to a different count than 'COUNT(orders.OrderID)' used in the reference if there are duplicate OrderID entries. Additionally, the query checks 'YEAR(orders.OrderDate) = 2023;' instead of using a date range, which is logically correct but deviates from the date range used in the reference implementation.",Base
What is the average quantity of products ordered per order?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG([Order Details].Quantity) AS AverageQuantity FROM [Order Details]""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Extract the average quantity and display it
average_quantity = df_result['AverageQuantity'].iloc[0]
show_to_user(pd.DataFrame({'AverageQuantity': [average_quantity]}))
```","```python
sql_query = """"""
SELECT AVG(Quantity) AS AverageQuantityPerOrder
FROM [Order Details]
GROUP BY OrderID
""""""
average_quantity_df = execute_sql_query(sql_query)
show_to_user(average_quantity_df)
```","The input code groups by 'OrderID' before calculating the average, meaning it finds the average quantity per order and shows all those averages, rather than just the overall average across all orders like the reference implementation.","```python
import pandas as pd

# Execute the SQL query
result_df = execute_sql_query(""SELECT Quantity, OrderID FROM [Order Details]"")

# Calculate the average quantity per order
average_quantity_per_order = result_df.groupby('OrderID')['Quantity'].mean().mean()

# Display the result
show_to_user(pd.DataFrame({'AverageQuantityPerOrder': [average_quantity_per_order]}))
```","The reference implementation calculates the average quantity of all products ordered across all orders. In contrast, the input code calculates the average quantity per order first, then averages these per-order averages, which is not an equivalent calculation.",None
What is the performance of each product based on sales quantities in Q1 2023? Use a line or bar chart to illustrate product performance.,"```python
import plotly.express as px

# SQL query to retrieve the sales quantities for each product in Q1 2023
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS product_performance
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate product performance
fig = px.bar(df, x='ProductID', y='product_performance', title='Product Performance in Q1 2023')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
""""""

product_performance_df = execute_sql_query(sql_query)

fig = px.bar(product_performance_df, x='ProductName', y='total_quantity',
              title='Product Performance Based on Sales Quantities in Q1 2023',
              labels={'total_quantity': 'Sales Quantity', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly answers the business analytics request by querying the total sales quantities for each product in Q1 2023 and visualizes the data using a bar chart. It includes product names in the visualization, which provides additional clarity. Despite slight differences, such as including product names and label customization, the input code adheres to the logical requirements of the reference implementation.","```python
import plotly.express as px

query = """"""
SELECT p.ProductID, SUM(od.Quantity) AS Performance
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY p.ProductID;
""""""

df = execute_sql_query(query)
fig = px.bar(df, x='ProductID', y='Performance', title='Product Performance in Q1 2023')
show_to_user(fig)
```","The input code correctly retrieves and aggregates sales quantities for each product in Q1 2023, matching the logic of the reference implementation. Both the SQL query and the use of Plotly for visualization are consistent with the reference. The differences in variable names ('Performance' vs. 'product_performance') do not affect the correctness of the logic.",both
Find the top 5 customers by the number of orders placed. Show results using a bar chart.,"```python
import plotly.express as px

# Define SQL query to retrieve top 5 customers by number of orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Top 5 Customers by Number of Orders')

# Display the result using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    customers.CustomerID, 
    customers.CompanyName, 
    COUNT(orders.OrderID) AS OrderCount
FROM 
    customers
JOIN 
    orders ON customers.CustomerID = orders.CustomerID
GROUP BY 
    customers.CustomerID, customers.CompanyName
ORDER BY 
    OrderCount DESC
LIMIT 5;
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, 
             x='CompanyName', 
             y='OrderCount', 
             title='Top 5 Customers by Number of Orders', 
             labels={'CompanyName': 'Customer', 'OrderCount': 'Number of Orders'}
            )
show_to_user(fig)
```","The input code correctly executes an SQL query to find the top 5 customers by the number of orders placed. It joins the 'customers' and 'orders' tables to retrieve the customer name and order count, groups by CustomerID and CompanyName, sorts by OrderCount in descending order, and limits the results to the top 5 records. The code then uses Plotly Express to create a bar chart with customer names on the x-axis and order counts on the y-axis, which satisfies the business request. Although it includes an additional field (CompanyName) compared to the reference implementation, this does not affect the fulfillment of the request.","```python
import plotly.express as px

query = """"""
SELECT customers.CustomerID, customers.CompanyName, COUNT(orders.OrderID) AS OrderCount 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
GROUP BY customers.CustomerID, customers.CompanyName 
ORDER BY OrderCount DESC 
LIMIT 5
""""""

df = execute_sql_query(query)
fig = px.bar(df, x='CompanyName', y='OrderCount', title='Top 5 Customers by Number of Orders', labels={'CompanyName':'Customer', 'OrderCount':'Order Count'})
show_to_user(fig)
```","The input code and the reference implementation both correctly retrieve the top 5 customers based on the number of orders placed. The input code uses an additional JOIN to include the CompanyName but ultimately displays the top 5 customers in a bar chart ordered by order count, adhering to the request's requirements. This logic is consistent with the reference code, which only uses CustomerID. The display method using Plotly and the execution of the SQL query are also correct.",both
What is the average shipping time for orders shipped to a specific country in the current month?,"```python
import pandas as pd
from datetime import datetime

# Set the specified country
specified_country = 'specified_country'

# Execute the SQL query to get the average shipping time
# Use a parameterized query to avoid SQL injection
query = """"""
    SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime 
    FROM orders 
    WHERE DATE_FORMAT(OrderDate, '%%Y-%%m') = DATE_FORMAT(CURDATE(), '%%Y-%%m') 
    AND ShipCountry = %s;
""""""
result_df = execute_sql_query(query, (specified_country,))

# Show the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime
import pandas as pd

current_month = datetime.now().strftime(""%Y-%m"")

country = ""YourCountryName""  # Replace with the specific country

sql_query = f""""""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime
FROM orders
WHERE ShipCountry = '{country}' AND DATE_FORMAT(OrderDate, '%Y-%m') = '{current_month}'
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code lacks parameterization for the SQL query, making it vulnerable to SQL injection. The reference implementation uses a parameterized query. Also, the input code uses hard-coded string formatting directly in the query, which is not considered a safe practice.","```python
import pandas as pd

country = input(""Enter the country: "")
sql_query = f""""""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime
FROM orders 
WHERE DATE_FORMAT(OrderDate, '%Y-%m') = DATE_FORMAT(NOW(), '%Y-%m') 
AND ShipCountry = '{country}';
""""""

df = execute_sql_query(sql_query)
show_to_user(df)
```","The evaluated code uses an unparameterized SQL query with direct insertion of user input, which could lead to SQL injection vulnerabilities. Additionally, the input code uses 'NOW()' function instead of 'CURDATE()', both functions provide current date-time but 'NOW()' includes time, possibly affecting the accuracy same-day queries depending on the time executed. The reference code uses parameterized queries, adhering to better security practices.",None
Which customers have purchased more than 5 different products?,"```python
sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY customers.CustomerID, customers.CompanyName
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
""""""

# Execute the SQL query
df_customers = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_customers)
```","```python
sql_query = """"""
SELECT orders.CustomerID, COUNT(DISTINCT [Order Details].ProductID) AS product_count
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.CustomerID
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```",The provided code does not include the 'customers' table to retrieve both CustomerID and CompanyName. It only selects CustomerID from the 'orders' table and lacks the JOIN with 'customers'. The result will not include the CompanyName as requested.,"```python
import pandas as pd

# SQL query to find customers who have purchased more than 5 different products
sql_query = """"""
SELECT CustomerID
FROM [Order Details]
GROUP BY CustomerID
HAVING COUNT(DISTINCT ProductID) > 5;
""""""

# Execute SQL query
customer_data = execute_sql_query(sql_query)

# Display result
show_to_user(customer_data)
```","The input code only selects the CustomerID from the [Order Details] table, which doesn't join with the customers and orders tables. This misses retrieving customer information like the CompanyName and may not correctly associate CustomerID with the individual customer. The reference code correctly joins tables to ensure comprehensive and accurate data retrieval.",None
Which region has the highest on-time delivery rate? Present this information with a pie chart or bar chart.,"```python
import plotly.express as px

# Define the SQL query to execute.
sql_query = """"""
SELECT ShipRegion, (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS on_time_rate
FROM orders
GROUP BY ShipRegion
ORDER BY on_time_rate DESC
LIMIT 1;
""""""

# Execute the SQL query using the provided utility function.
df = execute_sql_query(sql_query)

# Visualize the data with a bar chart to show the on-time delivery rates by region.
fig = px.bar(df, x='ShipRegion', y='on_time_rate', title='On-Time Delivery Rate by Region')

# Display the result to the user.
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipRegion,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    ShipRegion
""""""

df = execute_sql_query(sql_query)

df['OnTimeDeliveryRate'] = df['OnTimeDeliveries'] / df['TotalOrders'] * 100

fig = px.pie(df, names='ShipRegion', values='OnTimeDeliveryRate', title='On-time Delivery Rate by Region')
show_to_user(fig)
```","The input code calculates the on-time delivery rate for all regions and displays it in a pie chart, whereas the reference code calculates it only for the region with the highest rate and uses a bar chart. The business request specifies identifying which region has the highest rate, which the input code does not isolate or identify.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipRegion, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(*) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Select the region with the highest on-time delivery rate
highest_on_time_delivery_region = df.iloc[0:1]

# Create a bar chart
fig = px.bar(highest_on_time_delivery_region, x='ShipRegion', y='OnTimeDeliveryRate', title='Highest On-Time Delivery Rate by Region')

# Show the visualization
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate by region, selects the region with the highest on-time delivery rate, and visualizes it with a bar chart, aligning with the requirement to display the highest rate region. The logic matches the reference implementation, which also calculates on-time rates and orders them to find the highest.",Finetuned
How many orders were placed in the current year?,"```python
from datetime import datetime
import pandas as pd

# SQL query
sql_query = f""""""
SELECT COUNT(*) AS TotalOrders FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the total orders to the user
show_to_user(result_df)
```","```python
from datetime import datetime
import pandas as pd

current_year = datetime.now().year

sql_query = f""""""
SELECT COUNT(OrderID) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = {current_year}
""""""

order_count_df = execute_sql_query(sql_query)
show_to_user(order_count_df)
```","The input Python code is functionally equivalent to the reference implementation. Both codes count the number of orders placed in the current year using `YEAR(OrderDate) = YEAR(CURRENT_DATE)` in the reference and `YEAR(OrderDate) = {current_year}` in the input, where `current_year` is dynamically retrieved using `datetime.now().year`. The SQL query logic and intention are consistent in both cases, meeting the business analytics request.","```python
import pandas as pd
from datetime import datetime

# Define the SQL query
current_year = datetime.now().year
sql_query = f""SELECT COUNT(*) as total_orders FROM orders WHERE YEAR(OrderDate) = {current_year};""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['total_orders'].iloc[0])
```","Both the input and reference implementations correctly construct an SQL query to count the number of orders placed in the current year. They use the current year to filter the 'OrderDate' values. Although they differ slightly in variable names and method of accessing the result, the logic and outcome remain consistent with the reference implementation.",both
Calculate the total discount given on all orders in the last month.,"```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate the start date for the last month
start_date_last_month = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1).strftime('%Y-%m-%d')

# SQL query to calculate the total discount
sql_query = f""""""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS TotalDiscount 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate >= '{start_date_last_month}';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta

# Calculate the start and end date for the last month
today = datetime.now()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

sql_query = f""""""
SELECT SUM(Discount) AS TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN '{first_day_last_month.strftime('%Y-%m-%d')}' AND '{last_day_last_month.strftime('%Y-%m-%d')}'
""""""

total_discount_df = execute_sql_query(sql_query)
show_to_user(total_discount_df)
```","The input code calculates the sum of the 'Discount' column directly from '[Order Details]', not accounting for quantity and unit price, which is required to compute the total discount as per the reference implementation. The reference implementation correctly calculates the discount by multiplying 'Quantity', 'UnitPrice', and 'Discount' for each order detail.","```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * od.Discount) as TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= DATE_FORMAT(NOW() - INTERVAL 1 MONTH, '%Y-%m-01') 
AND o.OrderDate < DATE_FORMAT(NOW(), '%Y-%m-01');
""""""

# Execute the SQL query
total_discount_df = execute_sql_query(sql_query)

# Display the result
show_to_user(total_discount_df)
```","The input code calculates the total discount for the last month's orders, similar to the reference code. Both use SQL to sum discounts based on order details after joining the orders. The input code uses the current date to dynamically determine the start and end dates for the previous month, which is a valid approach and equivalent to the reference implementation's methodology.",Finetuned
Which products have a stock level below their reorder level?,"```python
import pandas as pd

# Define the SQL query to find products with stock below reorder level
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user using the provided utility function
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
products_below_reorder_level = execute_sql_query(sql_query)
show_to_user(products_below_reorder_level)
```","The input code includes an additional condition 'AND Discontinued = 0', which filters out discontinued products. This condition is not present in the reference implementation. Therefore, the logic does not fully adhere to the reference code, making the input code incorrect based on the criteria.","```python
sql_query = """"""
SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;
""""""

df = execute_sql_query(sql_query)
show_to_user(df)
```","The input Python code effectively reproduces the same logic as the reference implementation by defining the same SQL query and using the `execute_sql_query` and `show_to_user` functions to execute the query and display the result. Thus, the code is correct and answers the business analytics request.",Finetuned
Which month had the highest number of orders placed? Show this with a bar chart of months and their corresponding order numbers.,"```python
import plotly.express as px

# SQL query to get the number of orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY Month
ORDER BY NumberOfOrders DESC
""""""

# Execute the SQL query and get the result as a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Create a bar chart showing the number of orders per month
fig = px.bar(orders_df, x=""Month"", y=""NumberOfOrders"", title=""Number of Orders per Month"")

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
    COUNT(OrderID) AS OrderCount
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='OrderMonth', y='OrderCount', title='Number of Orders per Month')
show_to_user(fig)
```","The input code orders the results by OrderMonth rather than by OrderCount in descending order. This does not fulfill the business requirement to determine which month had the highest number of orders, as it does not ensure that the month with the most orders appears first.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY Month 
ORDER BY OrderCount DESC;
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Bar chart of months and their corresponding order numbers
fig = px.bar(df, x='Month', y='OrderCount', title='Order Counts by Month')

# Show the bar chart
show_to_user(fig)
```","The input Python code is correct as it mirrors the logic of the reference implementation. Both codes execute an SQL query to obtain the number of orders per month, use the same SQL function DATE_FORMAT for grouping by month, and create a bar chart using Plotly Express. The variable and column names are slightly different ('NumberOfOrders' vs. 'OrderCount'), but the functionality and output remain the same. The bar chart displays the number of orders per month, aligning precisely with the business analytics request.",Finetuned
Determine the employee with the largest average order size. Visualize this using a bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderSize 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY AvgOrderSize DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the dataframe is empty
if df.empty:
    raise ValueError(""No data returned from the query."")

# Create a bar chart to visualize the result
fig = px.bar(df, x='EmployeeID', y='AvgOrderSize', title='Employee with Largest Average Order Size')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderSize
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, EmployeeName
ORDER BY 
    AverageOrderSize DESC
LIMIT 1;
""""""

employee_avg_order_size = execute_sql_query(sql_query)

fig = px.bar(employee_avg_order_size, 
             x='EmployeeName', 
             y='AverageOrderSize', 
             title='Employee with Largest Average Order Size',
             labels={'AverageOrderSize': 'Average Order Size', 'EmployeeName': 'Employee'})

show_to_user(fig)
```","The evaluated code correctly executes the same logic as the reference code. It calculates the average order size for each employee and identifies the employee with the largest average order size using the specified SQL query. Both implementations use the AVG function on the product of UnitPrice, Quantity, and discount. The grouping and ordering logic are consistent between the reference and evaluated codes. The visualization also aligns in terms of presenting a bar chart with appropriate titles and labels. An additional improvement in the evaluated code is the inclusion of employee names, which enhances the chart's readability without affecting the correctness of the logic.","```python
import pandas as pd
import plotly.express as px

query = """"""
SELECT employees.EmployeeID, 
       employees.FirstName, 
       employees.LastName, 
       AVG([Order Details].Quantity) AS AvgOrderSize 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY AvgOrderSize DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(query)

# Check if the dataframe is not empty
if not df.empty:
    # Prepare data for visualization
    data = pd.DataFrame({
        'Employee': df['FirstName'] + ' ' + df['LastName'],
        'AvgOrderSize': df['AvgOrderSize']
    })

    # Create a bar chart
    fig = px.bar(data, x='Employee', y='AvgOrderSize', title='Employee with Largest Average Order Size', labels={'Employee': 'Employee', 'AvgOrderSize': 'Average Order Size'})

    # Show the visualization
    show_to_user(fig)
```","The input code calculates 'AvgOrderSize' as the average quantity of orders instead of using 'UnitPrice', 'Quantity', and 'Discount' to compute the actual average order size. This deviates from the logic specified in the request and the reference implementation.",Base
How many distinct customers placed orders each month? Use a line chart to show trends over the months.,"```python
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT DATE_TRUNC('month', o.OrderDate) AS Month, 
       COUNT(DISTINCT o.CustomerID) AS UniqueCustomers 
FROM orders o 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure 'Month' column is recognized as a date
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart using the data
fig = px.line(df, x='Month', y='UniqueCustomers', title='Distinct Customers Placing Orders Each Month', labels={'Month': 'Month', 'UniqueCustomers': 'Number of Unique Customers'})

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    COUNT(DISTINCT CustomerID) AS DistinctCustomers
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

df = execute_sql_query(sql_query)

fig = px.line(df, x='OrderMonth', y='DistinctCustomers', title='Distinct Customers Placed Orders Each Month', labels={'OrderMonth': 'Month', 'DistinctCustomers': 'Distinct Customers'})
show_to_user(fig)
```","Both implementations address the same business analytics request of counting distinct customer orders per month and producing a line chart. The SQL query in the input uses `DATE_FORMAT(OrderDate, '%Y-%m')` to truncate the date to a month level which is equivalent to `DATE_TRUNC('month', o.OrderDate)` in terms of logic. The input code also orders the results by month, which aligns with producing a trend line chart. Moreover, both scripts use Plotly Express to generate a line chart and display it. The logic and outcome of the input code are consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(DISTINCT CustomerID) AS DistinctCustomers 
FROM orders 
GROUP BY Month;
""""""

df = pd.read_sql_query(query, connection)

fig = px.line(df, x='Month', y='DistinctCustomers', title='Distinct Customers Per Month')
show_to_user(fig)
```","The input code answers the business question correctly and follows the same logic as the reference implementation. It calculates the number of distinct customers per month using a similar SQL query and visualizes the data with a line chart. The main difference is the use of 'DATE_FORMAT' in the input code instead of 'DATE_TRUNC', which is appropriate for different SQL dialects. Both codes generate a plot displaying the distinct customers each month, adhering to the business request.",both
What are the average discounts applied per order?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT OrderID, AVG(Discount) AS AverageDiscount FROM [Order Details] GROUP BY OrderID;""

# Execute the SQL query using the provided utility function
order_discounts_df = execute_sql_query(sql_query)

# Display the data analysis result
show_to_user(order_discounts_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID
""""""
average_discounts_df = execute_sql_query(sql_query)

fig = px.bar(average_discounts_df, x='OrderID', y='AverageDiscount', title='Average Discounts per Order')
show_to_user(fig)
```","The input code correctly uses the same SQL query to calculate the average discounts per order by grouping on OrderID. It uses the function `execute_sql_query` to execute this query, similar to the reference code. The only difference is that it visualizes the result using Plotly's bar chart instead of just displaying the DataFrame. The business logic to compute the average discount per order is unchanged, thereby making the input code correct.","```python
import pandas as pd

# SQL query to execute
sql_query = """"""
SELECT AVG(od.Discount) AS AvgDiscount FROM [Order Details] od;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df['AvgDiscount'])
```","The input code calculates the average discount across all orders, whereas the reference code calculates the average discount per individual order. The input code does not group by OrderID, which is necessary to get the average discount per order, as demonstrated in the reference implementation.",Base
What is the average order fulfillment time for orders made in February 2023?,"```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT DATEDIFF(o.ShippedDate, o.OrderDate) AS FulfillmentTime 
FROM orders o 
WHERE MONTH(o.OrderDate) = 2 AND YEAR(o.OrderDate) = 2023;
""""""

# Execute the query and retrieve data
orders_df = execute_sql_query(sql_query)

# Calculate the average fulfillment time
avg_fulfillment_time = orders_df['FulfillmentTime'].mean()

# Display the result
show_to_user(pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= '2023-02-01' AND OrderDate < '2023-03-01'
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time_df)
```","The input code correctly calculates the average order fulfillment time for orders made in February 2023. It uses a SQL query to calculate the average DATEDIFF between the ShippedDate and OrderDate. The WHERE clause filters the orders to include only those made between February 1, 2023, and March 1, 2023, matching calendar February 2023. The result is then displayed using 'show_to_user', similar to the reference code.","```python
import pandas as pd

query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS order_fulfillment_time 
FROM orders 
WHERE OrderDate BETWEEN '2023-02-01' AND '2023-02-28';
""""""

df = execute_sql_query(query)
show_to_user(df)
```","The input Python code correctly calculates the average order fulfillment time for orders made in February 2023. It uses the SQL function AVG on the datediff between ShippedDate and OrderDate for orders within February 2023, matching the intention and logic of the reference implementation. Although it uses a slightly different SQL syntax, it achieves the same result by using a BETWEEN clause to select dates in February, which is functionally equivalent to filtering by month and year. The code also correctly retrieves the data and displays the result.",both
Get a list of employees and the number of orders they have handled.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code uses a LEFT JOIN instead of an INNER JOIN, which might include employees without orders, differing from the reference implementation. It also doesn't group by FirstName and LastName, potentially leading to incorrect aggregation if those fields are not unique per EmployeeID.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrdersHandled 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The evaluated code uses a LEFT JOIN while the reference code uses an INNER JOIN. This means the evaluated code will include employees with no orders, which differs from the reference logic. Moreover, the GROUP BY clauses differ; the evaluated code doesn't include the employee's FirstName and LastName, which can result in incorrect aggregation if there are employees with the same FirstName and LastName.",None
What is the inventory turnover ratio for the product 'Chai' in May 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.ProductName = 'Chai'
AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the inventory turnover ratio value
inventory_turnover_ratio = df.iloc[0]['inventory_turnover_ratio']

# Display the result
show_to_user(inventory_turnover_ratio)
```","```python
import pandas as pd

# Define the SQL query to calculate Inventory Turnover Ratio for 'Chai' in May 2023
sql_query = """"""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM 
    [Order Details] 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    products.ProductName = 'Chai' 
    AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to user
show_to_user(result_df)
```",The input code calculates the inventory turnover ratio correctly but displays the entire DataFrame instead of extracting and showing just the 'inventory_turnover_ratio' value as in the reference implementation.,"```python
import pandas as pd

sql_query = """"""
SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE p.ProductName = 'Chai' AND od.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""

df = pd.read_sql_query(sql_query, your_database_connection)
display(df['InventoryTurnoverRatio'].iloc[0])
```","The input code incorrectly filters by 'od.OrderDate', which assumes 'OrderDate' is in the [Order Details] table. It should filter using 'orders.OrderDate' after joining with the orders table, as in the reference code. This error means the query logic does not align with the reference implementation.",None
Which shipping method has the shortest average order fulfillment time?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AverageFulfillmentTime ASC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY ShipVia
ORDER BY AverageFulfillmentTime ASC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code is correct. It constructs an SQL query that selects the shipping method with the shortest average order fulfillment time, matching the logic of the reference implementation. The query calculates the average difference between 'ShippedDate' and 'OrderDate', groups the results by 'ShipVia', orders them ascending by the average time, and limits the output to one record. It also uses 'execute_sql_query' and 'show_to_user' functions as in the reference implementation.","```python
import pandas as pd

# SQL Query to identify the shipping method with the shortest average order fulfillment time
sql_query = """"""
SELECT orders.ShipVia, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY orders.ShipVia 
ORDER BY AvgFulfillmentTime ASC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The provided Python code matches the reference implementation in terms of logic. Both queries calculate the average order fulfillment time for each shipping method by using the DATEDIFF function on the ShippedDate and OrderDate columns, group by ShipVia, and order the results to find the method with the shortest average time. The difference in the SQL syntax, mainly in the explicit table prefix (orders.), doesn't change the core functionality and purpose of the code.",both
What is the number of products sold with discounts?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductID 
FROM [Order Details] 
WHERE Discount > 0;
""""""

# Execute the query to retrieve data
result_df = execute_sql_query(sql_query)

# Count distinct ProductID
products_with_discount = result_df['ProductID'].nunique()

# Send the result to the user
show_to_user(pd.DataFrame({'ProductsWithDiscount': [products_with_discount]}))
```","```python
sql_query = """"""
SELECT COUNT(*) AS ProductsSoldWithDiscount
FROM [Order Details]
WHERE Discount > 0
""""""
discounted_products_df = execute_sql_query(sql_query)
show_to_user(discounted_products_df)
```","The input code counts all order details with a discount applied, but does not count distinct ProductIDs, which the reference implementation does. The task requires counting the number of unique products that had a discount, not the total count of discounted transactions.","```python
import pandas as pd

sql_query = """"""SELECT SUM(Quantity) AS ProductsWithDiscounts FROM [Order Details] WHERE Discount > 0;""""""
result_df = execute_sql_query(sql_query)

show_to_user(result_df)
```","The input code calculates the total quantity sold for products with discounts using SUM(Quantity), while the reference code counts the distinct 'ProductID' with discounts. The business requirement is to count the number of products, not the total quantity sold. Therefore, the input code does not adhere to the same logic as the reference implementation.",None
What is the average order fulfillment time per employee?,"```python
import pandas as pd

# Execute the SQL query
df = execute_sql_query(""""""
SELECT EmployeeID, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY EmployeeID;
"""""")

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY EmployeeID
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time_df)
```","The input code uses 'DATEDIFF(ShippedDate, OrderDate)', while the reference code uses 'DATEDIFF(day, OrderDate, ShippedDate)'. The order of the date parameters in DATEDIFF is reversed, which results in negative values instead of positive ones. The logic doesn't match because the average will be incorrect due to the sign change in day differences.","```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS FulfillmentTimePerEmployee 
FROM orders 
GROUP BY EmployeeID;
""""""

# Execute the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(data)
```","The input code uses DATEDIFF in the wrong order: DATEDIFF(ShippedDate, OrderDate) instead of DATEDIFF(day, OrderDate, ShippedDate). This would result in negative or incorrect fulfillment times, unlike the reference code.",None
What is the average number of units ordered per order?,"```python
import pandas as pd

# SQL Query to execute
sql_query = ""SELECT AVG(Quantity) AS AvgQuantityPerOrder FROM [Order Details];""

# Execute the query and get the result in a dataframe
result_df = execute_sql_query(sql_query)

# Since the result is a single value, extract and display it
avg_quantity_per_order = result_df['AvgQuantityPerOrder'].iloc[0]

# Create a dataframe to display the result
display_df = pd.DataFrame({'AvgQuantityPerOrder': [avg_quantity_per_order]})

# Show the result to the user
show_to_user(display_df)
```","```python
sql_query = """"""
SELECT AVG(OrderDetails.Quantity) AS AverageUnitsOrdered
FROM [Order Details] AS OrderDetails
GROUP BY OrderDetails.OrderID
""""""
average_units_ordered = execute_sql_query(sql_query)
show_to_user(average_units_ordered)
```","The input code groups data by OrderID before averaging, leading to an average at the order level, not across all orders as required. The reference code calculates the overall average without grouping, providing the correct business answer.","```python
import pandas as pd

# SQL query to get average units ordered
sql_query = """"""
SELECT AVG(Quantity) AS AverageUnitsOrdered 
FROM [Order Details];
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The input code accurately implements the logic needed to calculate the average number of units ordered per order. It uses a SQL query to calculate the average ('AVG(Quantity)') from the 'Order Details' table, as does the reference implementation. Both versions of the code execute the query and display the result using 'show_to_user'. Therefore, functionally, both implementations achieve the same outcome.",Finetuned
Determine the total revenue generated from orders shipped to Germany.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.ShipCountry = 'Germany';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
total_revenue = result_df['TotalRevenue'][0] if not result_df.empty else 0
show_to_user(pd.DataFrame({'TotalRevenue': [total_revenue]}))
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE c.Country = 'Germany'
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","Both implementations correctly compute the total revenue from orders shipped to Germany by summing up the product of UnitPrice, Quantity, and the discount factor (1 - Discount). The difference in the input code is using customers' table to determine the country, which is functionally equivalent assuming that the customers.Country effectively represents the orders.ShipCountry. The result is fetched, processed, and eventually displayed similarly in both implementations.","```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.ShipCountry = 'Germany';
""""""

# Execute SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code accurately follows the logic of the reference code. It calculates the total revenue from orders shipped to Germany by aggregating over the product of `UnitPrice`, `Quantity`, and `(1 - Discount)` from the `Order Details` table, which is joined with the `orders` table on `OrderID`. The SQL query and aggregation logic are consistent with the reference implementation. The result is then displayed using `show_to_user(result_df)`, which fulfills the requirement of showing the correct total revenue.",both
Determine the freights cost totals for each month in 2023 and visualize them to identify trends.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Freight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY Month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Convert Month to datetime for proper sorting
data['Month'] = pd.to_datetime(data['Month'])

# Visualize the results
fig = px.line(data, x='Month', y='TotalFreight', title='Monthly Freight Costs in 2023', markers=True)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(Freight) AS TotalFreight
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2023
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

freight_costs = execute_sql_query(sql_query)

fig = px.line(freight_costs, x='Month', y='TotalFreight', title='Monthly Freight Cost Totals for 2023')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request as described. It executes an SQL query that sums freight costs for each month in 2023 and groups them by month, which matches the logic of the reference implementation. The query results are then used to create a line plot visualizing these monthly freight costs. The primary difference is the explicit use of 'ORDER BY Month;' in the input code, which ensures that the results are ordered, although the reference assumes order is maintained after the GROUP BY. Overall, the core functionality and intent are preserved, making the input code correct.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Freight) AS FreightCostTotal 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY Month;
""""""

# Execute the SQL query and retrieve the data
freight_data = execute_sql_query(sql_query)

# Visualize the freight costs to identify trends
fig = px.line(freight_data, x='Month', y='FreightCostTotal', title='Freight Cost Totals for Each Month in 2023')
show_to_user(fig)
```","The input code fails to convert the 'Month' column to a datetime format. This can affect the proper sorting of the data when plotting the line chart, especially if the 'Month' column is treated as a string. The reference code includes a line to ensure the 'Month' column is correctly converted using pd.to_datetime. This step is crucial for accurate visualization, so the input code should be corrected to match the reference logic.",Base
Which categories have an average unit price above $20?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CategoryName 
FROM categories c 
JOIN products p ON c.CategoryID = p.CategoryID 
GROUP BY c.CategoryName 
HAVING AVG(p.UnitPrice) > 20;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AvgUnitPrice
FROM products p
GROUP BY p.CategoryID
HAVING AVG(p.UnitPrice) > 20;
""""""

average_price_df = execute_sql_query(sql_query)
show_to_user(average_price_df)
```","The input code calculates the average unit price for each CategoryID from the 'products' table, but it does not join with the 'categories' table to retrieve the CategoryName. The reference code correctly joins 'categories' and 'products' to filter and display categories with an average unit price above $20. Therefore, the input code does not fully meet the business requirement of returning the CategoryName.","```python
import pandas as pd

query = """"""
SELECT DISTINCT products.CategoryID 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.CategoryID 
HAVING AVG([Order Details].UnitPrice) > 20;
""""""

categories_df = execute_sql_query(query)
show_to_user(categories_df)
```","The evaluated code is incorrect because it queries the wrong table structure and logic. It uses 'products.CategoryID', but the question requires 'CategoryName' from the categories table. The reference code joins 'categories' with 'products', whereas the evaluated code joins 'products' with 'Order Details'. Additionally, the evaluated code calculates the average based on 'Order Details.UnitPrice', not 'products.UnitPrice' as in the reference.",None
Who are the suppliers for orders placed in the first quarter of this year?,"```python
import pandas as pd

# SQL query to find suppliers for orders placed in the first quarter of 2023
sql_query = """"""
SELECT DISTINCT s.CompanyName
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
suppliers_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(suppliers_df)
```","```python
import pandas as pd

# Define the SQL query to get suppliers for orders placed in the first quarter of this year
sql_query = """"""
SELECT DISTINCT s.SupplierID, s.CompanyName, s.ContactName, s.ContactTitle, s.Address, s.City, s.Region, s.PostalCode, s.Country, s.Phone
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT od.ProductID FROM [Order Details] od WHERE od.OrderID = o.OrderID)
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
""""""

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(supplier_data)
```","The evaluated code retrieves more columns than the reference, which may not align with the business request focusing only on 'CompanyName'. Additionally, the SQL logic differs as the evaluated code uses a subquery for 'Order Details', potentially impacting performance or results.","```python
import pandas as pd

query = """"""
SELECT DISTINCT s.CompanyName 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
WHERE EXTRACT(QUARTER FROM o.OrderDate) = 1;
""""""

suppliers_df = execute_sql_query(query)
show_to_user(suppliers_df)
```","The input code correctly identifies suppliers for orders placed in the first quarter. It joins the necessary tables and filters the order dates to the first quarter using 'EXTRACT(QUARTER FROM o.OrderDate) = 1', which aligns with the logic of the reference code that checks dates between '2023-01-01' and '2023-03-31'.",Finetuned
What is the total sales quantity for each product and visualize to compare performance across products?,"```python
import plotly.express as px

# Execute the SQL query to retrieve the data
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalSales FROM [Order Details] GROUP BY ProductID;""
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales quantity for each product
fig = px.bar(df, x='ProductID', y='TotalSales', title='Total Sales Quantity for Each Product')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Total Sales Quantity for Each Product', labels={'TotalSales': 'Total Sales Quantity', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code correctly calculates the total sales quantity for each product by joining the products and order details tables, similar to the reference implementation. Although it includes additional information (ProductName), this does not affect the correctness in terms of calculating 'TotalSales' and visualizing with a bar chart, satisfying the business analytics request.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the query and get the data
data = execute_sql_query(sql_query)

# Visualize the total sales quantity for each product
fig = px.bar(data, x='ProductName', y='TotalSalesQuantity', title='Total Sales Quantity by Product')
show_to_user(fig)
```","The input code correctly implements the request by calculating the total sales quantity for each product and visualizing it. Although the column names differ ('ProductName' vs 'ProductID'), this does not affect the correctness as both result in a meaningful comparison across products.",both
Which city has the highest number of orders?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) as NumberOfOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC 
LIMIT 1;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1
""""""

highest_city_orders = execute_sql_query(sql_query)
show_to_user(highest_city_orders)
```","The input code accurately replicates the reference implementation's logic. Both versions use SQL queries to retrieve the city with the highest number of orders by grouping by 'ShipCity', counting 'OrderID', and ordering the results in descending order of the count, limiting the output to the top result. The differences in naming ('NumberOfOrders' vs 'OrderCount') do not affect the correctness for answering the business request.","```python
import pandas as pd

# SQL Query to execute
sql_query = """"""
SELECT ShipCity, COUNT(*) AS NumberOfOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The provided Python code correctly answers the business analytics request. It counts the number of orders ('OrderID') grouped by 'ShipCity' and orders the results to find the city with the highest number of orders, limiting the output to the top result. This aligns with the reference implementation, despite minor differences in syntax (using COUNT(*) instead of COUNT(OrderID)). Both approaches achieve the same outcome.",both
What is the average order fulfillment time for each shipping method and visualize to compare performance?,"```python
import plotly.express as px

# SQL query to fetch the relevant data
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY ShipVia;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Rename columns if necessary
df.columns = ['ShipVia', 'AverageFulfillmentTime']

# Create a visualization to compare average fulfillment times
fig = px.bar(df, x='ShipVia', y='AverageFulfillmentTime', title='Average Order Fulfillment Time by Shipping Method')

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipVia, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM 
    orders
GROUP BY 
    ShipVia
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.bar(fulfillment_data, x='ShipVia', y='AverageFulfillmentTime', 
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'})

show_to_user(fig)
```","The input code uses `DATEDIFF(ShippedDate, OrderDate)` which differs from the reference implementation's `DATEDIFF(day, OrderDate, ShippedDate)`. This changes the order of the dates in the DATEDIFF function, potentially altering the calculation of the 'AverageFulfillmentTime'. The reference uses the correct syntax for computing difference in days.","```python
import plotly.express as px

# SQL query to retrieve data
sql_query = """"""
SELECT ShipVia, 
AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY ShipVia
""""""

# Execute the SQL query and get the data as a pandas dataframe
df = execute_sql_query(sql_query)

# Visualize the average order fulfillment time for each shipping method
fig = px.bar(df, x='ShipVia', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Avg Fulfillment Time (days)'})

# Show the visualization to the user
show_to_user(fig)
```",The input code correctly follows the business analytics request and the logic of the reference implementation. The SQL query accurately calculates the average order fulfillment time for each shipping method using the correct date difference calculation with DATEDIFF. The result of the query is visualized using Plotly express with a bar plot that compares the average fulfillment times by shipping method. The only difference in column naming ('AvgFulfillmentTime' instead of 'AverageFulfillmentTime') does not affect the correctness of the logic or the analysis outcome.,Finetuned
Which customers have placed orders in the last month?,"```python
import pandas as pd

# Define the SQL query to get customers who placed orders in the last month.
sql_query = ""SELECT CustomerID FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);""

# Execute the SQL query and retrieve the data.
df_customers = execute_sql_query(sql_query)

# Remove duplicate CustomerIDs if any.
df_unique_customers = df_customers.drop_duplicates()

# Display the customer data to the user.
show_to_user(df_unique_customers)
```","```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate the date range for the last month
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# SQL query to fetch customers who placed orders in the last month
sql_query = f""""""
SELECT DISTINCT CustomerID
FROM orders
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query
customers_last_month = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(customers_last_month)
```","Both implementations achieve the same outcome: retrieving distinct CustomerIDs for orders placed in the last month. The reference code uses `DATE_SUB(CURDATE(), INTERVAL 1 MONTH)` while the evaluated code calculates the date range using `datetime` and `timedelta`. Both methods effectively cover a one-month period prior to the current date. The evaluated code uses `DISTINCT` in the SQL query to remove duplicates, comparable to the `drop_duplicates()` method in the reference implementation. Thus, the evaluated code is correct.","```python
import pandas as pd

query = """"""
SELECT * FROM customers 
WHERE CustomerID IN (
    SELECT CustomerID FROM orders 
    WHERE OrderDate > DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
)
""""""

df = execute_query(query)
show_to_user(df)
```","The input code retrieves customers who have placed orders in the last month, similar to the reference implementation. The main logic is consistent: both check for CustomerIDs from the 'orders' table in the last month. While the input code retrieves the whole customer records instead of just IDs, it fulfills the business request despite not using 'drop_duplicates'.",both
List customers who have placed orders within the last 30 days.,"```python
import pandas as pd

# SQL query to get customers who have placed orders in the last 30 days
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders 
WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY);
""""""

# Execute the SQL query
customers_last_30_days = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_last_30_days)
```","```python
from datetime import datetime, timedelta

# Calculate the date 30 days ago from today
thirty_days_ago = (datetime.now() - timedelta(days=30)).date()

# SQL query to fetch customers who have placed orders in the last 30 days
sql_query = f""""""
SELECT DISTINCT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, 
                c.City, c.Region, c.PostalCode, c.Country, c.Phone, c.Fax
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate >= '{thirty_days_ago}'
""""""

# Execute the SQL query and retrieve the data
customers_last_30_days = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(customers_last_30_days)
```","The input code retrieves additional customer details by joining the customers and orders tables, whereas the reference implementation only retrieves distinct CustomerIDs from the orders table. The input code does not strictly adhere to the same logic as the reference implementation.","```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate date 30 days ago
thirty_days_ago = (datetime.now() - timedelta(days=30)).date()

# Execute query to list customers who have placed orders within the last 30 days
query = f""""""
SELECT DISTINCT customers.CustomerID, CompanyName 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate >= '{thirty_days_ago}';
""""""
df_customers_last_30_days = pd.read_sql_query(query, conn)

# Display the result
show_to_user(df_customers_last_30_days)
```","The input code includes a JOIN operation with the 'customers' table and retrieves both 'CustomerID' and 'CompanyName', which is not present in the reference implementation. The reference code only selects 'CustomerID' from the 'orders' table.",None
What are the names and unit prices of all products?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products;""

# Execute the query and get the results in a DataFrame
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)
```","```python
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
""""""
products_data = execute_sql_query(sql_query)
show_to_user(products_data)
```","Both the provided and reference implementations define an SQL query to select 'ProductName' and 'UnitPrice' from the 'products' table, execute the query, and display the results. The logic is consistent and meets the business analytics request.","```python
import pandas as pd
import json

# Retrieve data
sql_query = ""SELECT ProductName, UnitPrice FROM products;""
df = execute_sql_query(sql_query)

# Display data to user
show_to_user(df)
```",The input Python code performs the same functionality as the reference implementation. It uses the same SQL query to select the ProductName and UnitPrice from the 'products' table and then displays the result using the 'show_to_user' function. Both pieces of code have the same logic and achieve the same end result.,both
Find the monthly sales performance for each product and visualize to identify sales trends.,"```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    EXTRACT(MONTH FROM o.OrderDate) AS Month, 
    SUM(od.Quantity) AS MonthlySales 
FROM [Order Details] od 
JOIN products p 
ON od.ProductID = p.ProductID 
JOIN orders o 
ON od.OrderID = o.OrderID 
GROUP BY p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as an integer for correct x-axis ordering
df['Month'] = df['Month'].astype(int)

# Create the visualization
fig = px.line(
    df, 
    x='Month', 
    y='MonthlySales', 
    color='ProductName',
    labels={'MonthlySales': 'Monthly Sales', 'Month': 'Month'},
    title='Monthly Sales Performance for Each Product'
)

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity) AS TotalSold,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, Month
ORDER BY 
    Month, p.ProductID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='Month', y='TotalSales', color='ProductName', 
              title='Monthly Sales Performance by Product', 
              labels={'TotalSales': 'Total Sales', 'Month': 'Month'})

show_to_user(fig)
```","The input code calculates 'TotalSales' using both quantity and pricing, whereas the reference focuses on 'MonthlySales' based on quantity only. Additionally, the reference uses EXTRACT to group by month, leading to potential differences in monthly calculations. The input uses a different date format, which might not match the reference granularity.","```python
import plotly.express as px

# SQL query for the monthly sales performance
sql_query = """"""
SELECT 
    p.ProductName, 
    DATE_FORMAT(od.OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity) AS TotalQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName, Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the monthly sales performance
fig = px.line(df, x='Month', y='TotalQuantity', color='ProductName', title='Monthly Sales Performance for Each Product')

# Display the visualization
show_to_user(fig)
```","The input code does not correctly match the reference implementation, as it uses a different approach to calculate the month and does not join the orders table to get order dates. The 'DATE_FORMAT' function used in the input code is incorrect for this task; it should use 'EXTRACT(MONTH FROM o.OrderDate)' and include order date in the 'Order Details' join. Additionally, the input code assumes 'OrderDate' is in 'Order Details' rather than in 'orders', leading to potential data discrepancies.",None
What is the total sales revenue generated last month?,"```python
# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales_Revenue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH)
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales revenue from the result
total_sales_revenue = result_df.loc[0, 'Total_Sales_Revenue']

# Show the result to the user
show_to_user(total_sales_revenue)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate first and last day of last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# Prepare SQL query
sql_query = f""""""
SELECT SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales
FROM orders O
JOIN [Order Details] OD ON O.OrderID = OD.OrderID
WHERE O.OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
AND O.OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query
total_sales_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(total_sales_df)
```","The input code extracts the total sales revenue but returns the entire result as a DataFrame instead of a single value. In the reference code, the result is a single value extracted from the DataFrame. Both codes calculate the correct total revenue, but the format shown to the user differs.","```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate last month
today = datetime.today()
first_day_of_this_month = datetime(today.year, today.month, 1)
last_month_end = first_day_of_this_month - timedelta(days=1)
last_month = last_month_end.month
last_year = last_month_end.year

# SQL Query to get total sales revenue for the last month
sql_query = f""""""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE MONTH(orders.OrderDate) = {last_month} AND YEAR(orders.OrderDate) = {last_year}
""""""

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(results_df)
```","The input Python code correctly implements the logic required to calculate the total sales revenue for the last month. It calculates the last month and year accurately, constructs an SQL query similar to the reference implementation, executes it, and displays the result. The differences in variable names and slight variations in formatting and the way last month is computed do not affect the correctness of the implementation.",Finetuned
"Which employees have handled the most orders, and can this be illustrated using a bar chart to compare the number of orders handled by each employee?","```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrdersHandled
FROM orders
GROUP BY EmployeeID
ORDER BY OrdersHandled DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='EmployeeID', y='OrdersHandled', title='Number of Orders Handled by Each Employee')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) as OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='EmployeeID', y='OrderCount', 
             title='Number of Orders Handled by Each Employee',
             labels={'OrderCount': 'Number of Orders', 'EmployeeID': 'Employee ID'})

show_to_user(fig)
```","The input code matches the logic of the reference implementation. It performs a SQL query to count the number of orders each employee has handled, orders them by count in descending order, and then uses Plotly to create a bar chart illustrating these counts. The minor differences, such as the use of 'OrderCount' instead of 'OrdersHandled', do not affect the correctness as they semantically represent the same concept. Additionally, the use of labels in the Plotly function enhances the chart's clarity without altering the intended functionality.","```python
import plotly.express as px

# SQL query to get the order count per employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC;
""""""

# Execute SQL query
df_orders = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(df_orders, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Each Employee', labels={'OrderCount':'Number of Orders'})

# Show the chart
show_to_user(fig)
```","The input code correctly implements the same logic as the reference code. It executes an SQL query to count the number of orders handled by each employee and orders them in descending order. The variable names 'OrderCount' and 'OrdersHandled' are different, but they serve the same purpose. Additionally, the bar chart creation and display are consistent with the reference, with an extra 'labels' parameter for clarity on the y-axis, which does not impact functionality or correctness.",both
