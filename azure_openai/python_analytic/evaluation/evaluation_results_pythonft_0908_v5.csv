Business Analytic Request,Ground Truth Code,Generated Code by Base Model,Base Model Explanation,Generated Code by Finetuned Model,Finetuned Model Explanation,Model that got it right
What was the average order value in Q1 of 2023?,"```python
import pandas as pd

# SQL query to get the relevant data
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalValue,
    COUNT(DISTINCT orders.OrderID) AS OrderCount
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Calculate the average order value
data['AvgOrderValue'] = data['TotalValue'] / data['OrderCount']

# Display the result to the user
show_to_user(data[['AvgOrderValue']])
```","```python
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
""""""
average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","The input code correctly calculates the average order value by dividing the total value of orders by the count of distinct orders. The SQL query logic matches the reference implementation, and the date range for Q1 2023 is accurately defined. The output is displayed as expected.","```python
# Assuming the utility function execute_sql_query is available
import pandas as pd

# SQL query to calculate the average order value
sql_query = """"""
SELECT AVG(OrderValue) AS AverageOrderValue
FROM (
    SELECT (o.UnitPrice * oi.Quantity * (1 - oi.Discount)) AS OrderValue
    FROM orders o
    JOIN [Order Details] oi ON o.OrderID = oi.OrderID
    WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
) AS OrderValues;
""""""

# Execute the SQL query and get the result in a DataFrame
df_result = execute_sql_query(sql_query)

# Display the average order value
show_to_user(df_result)
```","The input code calculates the average of individual order item values, not the average order value. This approach differs from the reference, which aggregates total order value by OrderID before averaging, capturing the true average order value across orders.",Base
Which products have the lowest units in stock?,"```python
import pandas as pd

# SQL query to get the products with the lowest units in stock
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products 
ORDER BY UnitsInStock ASC 
LIMIT 1;
""""""

# Execute the SQL query
lowest_stock_product_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(lowest_stock_product_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
ORDER BY UnitsInStock ASC
LIMIT 10
""""""
lowest_stock_products = execute_sql_query(sql_query)
show_to_user(lowest_stock_products)
```","The input Python code retrieves 10 products with the lowest units in stock, as indicated by 'LIMIT 10'. The reference implementation only retrieves the product with the single lowest unit in stock using 'LIMIT 1'. Therefore, the input code does not adhere to the same logic as the reference implementation.","```python
import pandas as pd

# Execute the SQL query to retrieve the products with the lowest units in stock
request_query = """"""
SELECT ProductName FROM products WHERE UnitsInStock < 10;
""""""

# Use the provided utility function to execute the query
low_stock_products_df = execute_sql_query(request_query)

# Display the results to the user
show_to_user(low_stock_products_df)
```","The reference code retrieves the product with the absolute lowest units in stock, ordering by 'UnitsInStock' and limiting the result to 1. The input code retrieves all products with 'UnitsInStock' less than 10, which may not necessarily be the lowest. Thus, the logic differs from the reference.",None
Which customers placed the highest number of orders last year?,"```python
import pandas as pd

# Define the SQL query to retrieve customers with highest orders last year
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY CustomerID 
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_orders)
```","```python
import pandas as pd

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= '2022-01-01' AND OrderDate < '2023-01-01'
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 10;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly identifies customers with the highest number of orders for the specified year. While it uses explicit date ranges ('2022-01-01' to '2023-01-01') instead of a dynamic year calculation, it follows the same grouping and ordering logic as the reference implementation. The use of 'LIMIT 10' suggests it only retrieves the top 10 customers, which is additional functionality but does not invalidate correctness.","```python
import pandas as pd

# SQL Query to get the customer with highest number of orders last year
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS NumberOfOrders
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) - 1
GROUP BY customers.CustomerID
ORDER BY NumberOfOrders DESC;
""""""

# Execute SQL query and store the result in a DataFrame
orders_data = execute_sql_query(sql_query)

# Display the DataFrame to the user
show_to_user(orders_data)
```","The input Python code correctly retrieves the customers who placed the highest number of orders last year. It uses a SQL query that selects CustomerID and the count of orders for each customer from the 'orders' table, filters orders based on the last year's date, groups by CustomerID, and orders the result by the count of orders in descending order. This aligns with the reference implementation which also counts orders per customer for the previous year, groups by CustomerID, and sorts by order count. The usage of the `JOIN` clause does not change the logic as it matches CustomerID across the tables correctly.",both
Calculate the total revenue generated by each product and visualize it using a bar chart to compare easily.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM 
    [Order Details] od 
INNER JOIN 
    products p ON od.ProductID = p.ProductID 
GROUP BY 
    p.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalRevenue DESC;
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', 
             title='Total Revenue Generated by Each Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code adds a discount factor in the revenue calculation (`(1 - od.Discount)`), which is not present in the reference implementation. This changes the logic of how the total revenue is computed, making it incompatible with the reference request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total revenue generated by each product
sql_query = """"""
SELECT ProductID, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalRevenue 
FROM [Order Details] 
GROUP BY ProductID;
""""""

# Execute the SQL query and read the results into a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart to visualize total revenue by product
fig = px.bar(data, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Display the bar chart using the given utility function
show_to_user(fig)
```","The input code calculates total revenue by 'ProductID' without joining with the 'products' table to retrieve 'ProductName'. The reference implementation calculates revenue per product using 'ProductName' obtained by joining 'products' and 'Order Details' tables, which allows for human-readable product names in the bar chart. This means the logic differs as the input code does not match the business analytics request using product names for clarity.",None
Which customers are from the United States?,"```python
sql_query = ""SELECT CustomerID FROM orders WHERE ShipCountry = 'USA'""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders
WHERE ShipCountry = 'United States'
""""""

customer_data = execute_sql_query(sql_query)
show_to_user(customer_data)
```","The input code checks for 'United States' in the ShipCountry column, while the reference code checks for 'USA'. These represent the same country but may not match depending on the database content and how countries are listed. The logic differs due to the specified ShipCountry value.","```python
# Utility function to execute an SQL query and get results as a DataFrame
def execute_sql_query(sql_query: str):
    # This function is assumed to connect to a database, execute the query, and return a DataFrame.
    pass

# Utility function to display data to the user
def show_to_user(data):
    # This function is assumed to render the data in an appropriate format
    pass

# SQL query to identify customers from the United States
query = """"""
SELECT FirstName, LastName 
FROM customers 
WHERE Country = 'USA';
""""""

# Execute the query and retrieve the result as a DataFrame
us_customers_df = execute_sql_query(query)

# Display the resulting DataFrame to the user
show_to_user(us_customers_df)

```","The provided code checks for customers in the 'customers' table with the 'Country' column set to 'USA', while the reference implementation queries the 'orders' table where 'ShipCountry' is 'USA'. This implies the input code does not follow the same logic as the reference implementation, as it targets a different table and field to determine United States customers.",None
List the products that are being sold at a discount (UnitPrice in orders < UnitPrice in products).,"```python
import pandas as pd

# SQL query to get products sold at a discount
sql_query = """"""
SELECT p.ProductName 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
WHERE od.UnitPrice < p.UnitPrice;
""""""

# Execute the SQL query
discounted_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discounted_products_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitPrice AS OriginalPrice, od.UnitPrice AS DiscountedPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.UnitPrice < p.UnitPrice
""""""

discounted_products = execute_sql_query(sql_query)
show_to_user(discounted_products)
```","The provided code correctly implements the logic to find products sold at a discount by comparing UnitPrice in the orders with UnitPrice in the products. It retrieves similar results by selecting the necessary fields and uses the correct SQL join and condition. Although it includes additional fields, it adheres to the business request and logic of the reference code.","```python
import pandas as pd

# SQL Query to find products sold at a discount
sql_query = """"""
SELECT p.ProductID, p.ProductName, o.UnitPrice AS DiscountedPrice
FROM products p
JOIN [Order Details] o ON p.ProductID = o.ProductID
WHERE o.UnitPrice < p.UnitPrice;
""""""

# Execute the SQL query using the utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function. The actual implementation may vary.
    # In a real-world scenario, it would connect to a database and fetch data.
    # Here, we simulate this with an empty DataFrame for demonstration purposes.
    # Replace with actual database query execution code.
    return pd.DataFrame()  # Simulated data

# Fetch the data
discounted_products_df = execute_sql_query(sql_query)

# Check if any products are being sold at a discount
if not discounted_products_df.empty:
    # Display the results
    discounted_products_df  # This will show the DataFrame with discounted products
else:
    # Inform the user if no discounted products were found
    print(""No products are currently being sold at a discount."")
```","The input Python code correctly identifies products sold at a discount by comparing the UnitPrice in the 'Order Details' table to the UnitPrice in the 'products' table, following the same logical conditions as the reference implementation. The primary difference is in the set of columns selected (including additional columns like ProductID and DiscountedPrice), which do not affect the logic pertaining to finding discounted products. Moreover, both implementations utilize a SQL query to achieve the task, which maintains consistency with the business request.",both
Which employees generated the highest sales revenue in April 2023 and visualize with a bar chart for comparison?,"```python
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.FirstName, employees.LastName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC
'''

# Execute SQL query and get data
data = execute_sql_query(sql_query)

# Create a full name column for ease of visualization
data['FullName'] = data['FirstName'] + ' ' + data['LastName']

# Create the bar chart using Plotly
fig = px.bar(data, x='FullName', y='total_sales', 
             title='Top Employees by Sales Revenue in April 2023',
             labels={'total_sales': 'Total Sales Revenue', 'FullName': 'Employee Name'})

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY employee_sales DESC
LIMIT 10
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, 
              x='FirstName + LastName', 
              y='employee_sales', 
              title='Top Employees by Sales Revenue in April 2023', 
              labels={'FirstName + LastName': 'Employee Name', 'employee_sales': 'Sales Revenue'},
              text='employee_sales')
show_to_user(fig)
```","The input code attempts to concatenate 'FirstName' and 'LastName' directly in the `px.bar` function, which will not work as expected because Plotly expects column names from the DataFrame. The reference code creates a new column 'FullName' for this purpose. Additionally, the input code includes a 'LIMIT 10' in the SQL query, which restricts the results to the top 10 employees, whereas the reference implementation does not have this limit. Thus, the input code does not fully adhere to the logic of the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Define the utility function (assuming it's already implemented elsewhere in your environment)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function executes the SQL query and returns the result as a DataFrame
    pass  # Replace with actual implementation

def show_to_user(data):
    # This function displays the data or visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get sales by employee for April 2023
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Sales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY e.EmployeeID 
ORDER BY Sales DESC;
""""""

# Execute the SQL query and obtain the results
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='Sales', title='Sales Revenue by Employee - April 2023', 
             labels={'Sales': 'Total Sales Revenue', 'EmployeeID': 'Employee ID'})

# Show the plot
show_to_user(fig)
```","The input code does not retrieve first and last names of employees, which are necessary for identifying them in the visualization. It only groups by EmployeeID, whereas the reference code groups by first and last names. Additionally, the input code's visualization axis uses 'EmployeeID', while the reference code uses 'FullName'. These discrepancies result in not fulfilling the request correctly.",None
What is the average order value handled by each employee and visualize with a bar chart for employee comparison?,"```python
import plotly.express as px

# Step 1: Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderValue 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Step 2: Execute the SQL query and retrieve the result as a DataFrame
df = execute_sql_query(sql_query)

# Step 3: Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='AvgOrderValue', title='Average Order Value by Employee', labels={'AvgOrderValue': 'Average Order Value', 'EmployeeID': 'Employee ID'})

# Step 4: Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
""""""

average_order_value_data = execute_sql_query(sql_query)

fig = px.bar(average_order_value_data, 
             x='EmployeeName', 
             y='AverageOrderValue', 
             title='Average Order Value by Employee',
             labels={'AverageOrderValue': 'Average Order Value', 'EmployeeName': 'Employee'},
             color='AverageOrderValue')

show_to_user(fig)
```","The input code correctly calculates the average order value for each employee using a similar approach to the reference implementation. While the query and visualization details differ slightly, the logic remains consistent. The input code includes employee names for labels and uses an average calculation based on distinct orders, which aligns with the intent of calculating average order values per employee. Additionally, it utilizes Plotly for visualization, meeting the requirement to create a bar chart for employee comparison.","```python
import pandas as pd
import plotly.express as px

# Assume the utility functions are defined elsewhere
# from utilities import execute_sql_query, show_to_user

# SQL query to fetch average order value per employee
sql_query = """"""
SELECT e.EmployeeID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize average order value per employee
fig = px.bar(df, x='EmployeeID', y='AverageOrderValue',
             title='Average Order Value Handled by Each Employee',
             labels={'AverageOrderValue': 'Average Order Value', 'EmployeeID': 'Employee ID'})

# Display the bar chart using the utility function
show_to_user(fig)
```","The input Python code implementation correctly follows the same logic specified in the business analytics request and the reference implementation. It accurately computes the average order value per employee by joining the relevant tables and using the correct aggregation. The code then visualizes the data with a bar chart using Plotly, matching the output format of the reference implementation.",both
Find the total revenue generated by each product and illustrate using a bar chart.,"```python
import plotly.express as px

# Execute the SQL query to retrieve data
sql_query = """"""
SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue 
FROM [Order Details] 
GROUP BY ProductID;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)
fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')
show_to_user(fig)
```","The input code calculates total revenue by 'ProductName' instead of 'ProductID'. Additionally, it includes a discount factor in the revenue calculation, which is not present in the reference implementation. These differences in logic and grouping criterion make the input code not fully correct according to the specified business request.","```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalRevenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    data, 
    x='ProductName', 
    y='TotalRevenue', 
    title='Total Revenue by Product',
    labels={'ProductName': 'Product Name', 'TotalRevenue': 'Total Revenue'}
)

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code generates total revenue by 'ProductName' instead of 'ProductID' as requested in the business analytics task. Additionally, the reference implementation uses 'ProductID' directly from '[Order Details]' without joining the 'products' table or using 'ProductName'.",None
Calculate the inventory turnover ratio for each month and represent it with a line chart to observe trends.,"```python
import plotly.express as px

# SQL query defined
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) as InventoryTurnoverRatio 
FROM `Order Details` od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Convert Month to datetime for proper plotting
data['Month'] = pd.to_datetime(data['Month'])

# Generate line chart
fig = px.line(data, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ORDER_DATE, '%Y-%m') AS Month,
    SUM(od.Quantity * od.UnitPrice) AS COGS,
    AVG(p.UnitsInStock) AS Avg_Inventory
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

data = execute_sql_query(sql_query)

data['Inventory_Turnover_Ratio'] = data['COGS'] / data['Avg_Inventory']
fig = px.line(data, x='Month', y='Inventory_Turnover_Ratio', title='Monthly Inventory Turnover Ratio')
show_to_user(fig)
```","The input code calculates the inventory turnover ratio using the same logic as the reference code. It computes the cost of goods sold (COGS) and the average inventory for each month, which eventually results in a similar turnover ratio calculation as the reference. Both codes then create a line chart to display monthly inventory turnover trends, fulfilling the business request.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to calculate inventory turnover ratio
sql_query = """"""
SELECT 
    MONTH(OrderDate) AS Month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / NULLIF(AVG(products.UnitsInStock), 0) AS InventoryTurnover
FROM 
    [Order Details]
INNER JOIN 
    products ON [Order Details].ProductID = products.ProductID
GROUP BY 
    MONTH(OrderDate)
ORDER BY 
    Month;
""""""

# Execute the SQL query and fetch the data into a DataFrame
data = execute_sql_query(sql_query)

# Create a line chart to visualize the inventory turnover over each month
fig = px.line(data, x='Month', y='InventoryTurnover', title='Inventory Turnover Ratio by Month')

# Display the line chart to the user
show_to_user(fig)
```","The evaluated code uses 'MONTH(OrderDate)' instead of 'DATE_FORMAT(OrderDate, '%Y-%m')' which only extracts the month, not the full year-month format needed to observe monthly trends. This can cause aggregation of different years' months into a single month, leading to incorrect results. Additionally, 'NULLIF(AVG(products.UnitsInStock), 0)' is cautious against division by zero, which is a good practice, but the key issue is with the grouping logic.",Base
Visualize the performance of products based on sales and inventory levels for each month in 2022 using a combination chart.,"```python
import plotly.graph_objects as go
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, 
       MONTH(orders.OrderDate) AS order_month, 
       SUM([Order Details].Quantity) AS product_performance 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, order_month
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Prepare the data for visualization
pivot_df = df.pivot(index=""order_month"", columns=""ProductID"", values=""product_performance"").fillna(0)

# Create a combination chart
fig = go.Figure()

# Add traces for each product
for product_id in pivot_df.columns:
    fig.add_trace(go.Bar(x=pivot_df.index, y=pivot_df[product_id], name=f'Product {product_id}'))

# Set chart title and labels
fig.update_layout(
    title='Product Performance Based on Sales (2022)',
    xaxis_title='Month',
    yaxis_title='Quantity Sold',
    xaxis=dict(tickmode='linear'),
    barmode='stack'
)

# Show the combination chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.graph_objects as go

sql_query_sales = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY 
    month 
ORDER BY 
    month;
""""""

sql_query_inventory = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
    SUM(products.UnitsInStock) AS total_inventory 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY 
    month 
ORDER BY 
    month;
""""""

sales_data = execute_sql_query(sql_query_sales)
inventory_data = execute_sql_query(sql_query_inventory)

combined_data = pd.merge(sales_data, inventory_data, on='month', how='outer', suffixes=('_sales', '_inventory'))

fig = go.Figure()

fig.add_trace(go.Bar(x=combined_data['month'], y=combined_data['total_sales'], name='Total Sales', yaxis='y1'))
fig.add_trace(go.Scatter(x=combined_data['month'], y=combined_data['total_inventory'], name='Total Inventory', yaxis='y2', mode='lines+markers'))

fig.update_layout(
    title='Product Performance in 2022',
    yaxis=dict(title='Total Sales'),
    yaxis2=dict(title='Total Inventory', overlaying='y', side='right'),
    xaxis_title='Month',
    barmode='group'
)

show_to_user(fig)
```","The input code differs significantly from the reference code in terms of logic and output. The reference code visualizes product performance based on a quantity sold per product, grouped by month, whereas the input code calculates total sales based on the price and discount, and total inventory, grouped by month. The input code uses a bar chart for sales and a line chart for inventory, while the reference uses a stacked bar chart for quantities of different products. The input code does not address the product-level performance required in the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Function for executing SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation; replace with actual database connection and query execution
    pass

# Function for displaying the visualization
def show_to_user(figure):
    # Dummy implementation; replace with actual display logic
    pass

# SQL query for retrieving the desired data
sql_query = """"""
SELECT 
    MONTH( invoices.InvoiceDate ) AS Month,
    SUM( [Order Details].Quantity ) AS Sales,
    AVG( products.UnitsInStock ) AS AverageInventory
FROM invoices
JOIN [Order Details] ON [Order Details].OrderID = invoices.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE invoices.InvoiceDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY MONTH( invoices.InvoiceDate )
""""""

# Execute query and store result in DataFrame
df = execute_sql_query(sql_query)

# Create the combination chart using Plotly
fig = px.line(
    df, 
    x='Month', 
    y='Sales', 
    title='Product Performance: Sales & Inventory Levels (2022)',
    labels={'Sales': 'Total Sales', 'AverageInventory': 'Average Inventory'},
    markers=True, 
    line_shape='linear'
)

# Add the average inventory as a secondary y-axis
fig.add_trace(
    px.bar(
        df,
        x='Month',
        y='AverageInventory'
    ).data[0]
)

# Show the combined figure to the user
show_to_user(fig)
```","The input code differs significantly from the reference implementation in both the query structure and visualization logic. The reference code selects ProductID and summarizes quantity for each month, visualizing it using stacked bar charts per product. The input code aggregates sales and average inventory by month using a line plot for sales and a secondary bar trace for inventory. This differs from the reference focus and method, hence does not adhere to the same logic requested.",None
What is the total sales revenue generated by each customer and represent it with a bar chart for comparison?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY CustomerID 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='TotalSales', title='Total Sales Revenue by Customer', labels={'CustomerID': 'Customer ID', 'TotalSales': 'Total Sales Revenue'})

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.bar(total_sales_df, x='CustomerID', y='TotalSales', 
             title='Total Sales Revenue by Customer', 
             labels={'TotalSales': 'Total Sales Revenue', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```","The input code correctly calculates the total sales revenue by each customer using a SQL query similar to the reference implementation. Both codes execute the SQL query to get customer sales data, then use Plotly to create a bar chart comparing total sales revenue by customer. Minor differences, like aliases for tables in the SQL query, do not impact the correctness of the output.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the sales revenue for each customer
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID
""""""

# Execute the SQL query and get the pandas DataFrame
df = execute_sql_query(sql_query)

# Create the bar chart for total sales revenue by customer
fig = px.bar(df, x='CustomerID', y='total_sales', title='Total Sales Revenue by Customer')

# Display the bar chart to the user
show_to_user(fig)
```","The input code is correct because it calculates the total sales revenue per customer using a SQL query with a similar logic to the reference implementation. It joins the necessary tables correctly and groups by 'CustomerID'. The bar chart is created using Plotly, similar to the reference, and displays the 'CustomerID' against calculated 'total_sales'. The difference in SQL query structure does not affect the outcome, and labeling differences are negligible.",both
Which employee has processed the most orders for customers in the USA and visualize the results using a bar chart?,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShipCountry = 'USA' 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC
LIMIT 1;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create bar chart with Plotly
fig = px.bar(df, x='FirstName', y='OrderCount', text='OrderCount', title='Top Employee Processing USA Orders')
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS TotalOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShipCountry = 'USA'
GROUP BY e.EmployeeID
ORDER BY TotalOrders DESC
LIMIT 1
""""""

employee_data = execute_sql_query(sql_query)

fig = px.bar(employee_data, x='EmployeeID', y='TotalOrders', 
             title='Employee with Most Orders in the USA',
             labels={'EmployeeID': 'Employee ID', 'TotalOrders': 'Total Orders'},
             text='TotalOrders')

show_to_user(fig)
```","The input code follows the same logic as the reference code. It queries the database to identify the employee with the most orders from customers in the USA. The SQL query structure is consistent with the reference implementation—joining employees and orders tables, filtering by USA, grouping by employee, and ordering by the count. Both codes then visualize the result as a bar chart using Plotly. Although there are minor differences in the labels and text template details, these do not affect the correctness of the logic or the outcome.","```python
import pandas as pd
import plotly.express as px

# Execute the provided SQL query to get the data
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OrderCount
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE orders.ShipCountry = 'USA'
GROUP BY employees.EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
""""""

# Fetch the data into a DataFrame
df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Top Employee by Order Count in the USA')
show_to_user(fig)
```","The input code does not include the employees' first and last names, which are part of the output in the reference code. The input code only selects EmployeeID, whereas the reference code selects FirstName and LastName to display in the bar chart. Therefore, it does not adhere to the logic of the reference implementation.",Base
Which product had the highest sales quantity in the last month and use a bar chart to compare top-selling products?,"```python
import plotly.express as px

# SQL query to get top-selling products
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Find the product with the highest sales quantity
top_product = data.head(1)

# Display the top product details
show_to_user(top_product)

# Create a bar chart to compare top-selling products
fig = px.bar(data.head(10), x='ProductName', y='TotalQuantity', title='Top-Selling Products in the Last Month')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last month
end_date = datetime.now().replace(day=1) - timedelta(days=1)
start_date = end_date.replace(day=1)

# SQL query to get sales data for the last month
sql_query = f""""""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) as TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID FROM Orders 
    WHERE OrderDate >= '{start_date.strftime('%Y-%m-%d')}' 
    AND OrderDate <= '{end_date.strftime('%Y-%m-%d')}'
)
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
""""""

# Execute the query and get the data
sales_data = execute_sql_query(sql_query)

# Find the product with the highest sales quantity
top_product = sales_data.iloc[0]

# Create a bar chart for top-selling products
fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Top Selling Products Last Month')

# Show the result to the user
show_to_user(fig)

top_product
```","Both implementations correctly query the database to find products with the highest sales quantity within the last month and present the data using a bar chart. The main differences lie in how the date range is calculated and SQL query execution, but these do not affect the end result. The primary logic for determining the top-selling product and creating the bar chart is maintained, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Assuming these utility functions are defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation
    pass

def show_to_user(data):
    # Placeholder for actual implementation
    pass

# Define the SQL query
sql_query = """"""
SELECT 
    ProductID, 
    SUM([Order Details].Quantity) AS TotalQuantity 
FROM 
    [Order Details] 
INNER JOIN 
    orders 
ON 
    [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate >= DATEADD(month, -1, CURRENT_DATE) 
GROUP BY 
    ProductID 
ORDER BY 
    TotalQuantity DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Display the top-selling product and all products compared
top_product = df.head(1)
show_to_user(top_product)

# Create a bar chart to compare sales quantities
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Top-Selling Products in Last Month')

# Show the bar chart using the provided utility function
show_to_user(fig)
```","The input code does not fetch ProductName, only ProductID, making it unclear which products are top-sellers. It also uses 'DATEADD' which is a SQL Server function, while the reference uses 'DATE_SUB', a MySQL function. The input code plots ProductID on the x-axis, whereas the reference used ProductName, providing clearer insights. Additionally, the input chart includes all products instead of the top 10. Finally, there's no handling for the possibility of missing ProductName, which is necessary for proper comparison in business analytics.",Base
"For each employee, what is the average number of orders handled per month in 2023 and visualize the results with a bar chart?","```python
import plotly.express as px

# SQL query to get the average number of orders per month per employee in 2023
sql_query = """"""
SELECT employees.EmployeeID, AVG(order_count) AS avg_orders_per_month 
FROM (
    SELECT employees.EmployeeID, COUNT(orders.OrderID) AS order_count, 
    MONTH(orders.OrderDate) AS order_month 
    FROM employees 
    LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID 
    WHERE YEAR(orders.OrderDate) = 2023
    GROUP BY employees.EmployeeID, MONTH(orders.OrderDate)
) AS temp 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='avg_orders_per_month', 
             title='Average Number of Orders per Month for Each Employee in 2023', 
             labels={'avg_orders_per_month': 'Avg Orders per Month', 'EmployeeID': 'Employee ID'})

# Show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    employees.EmployeeID,
    CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName,
    COUNT(orders.OrderID) / 12 AS AvgOrdersPerMonth
FROM
    orders
JOIN
    employees ON orders.EmployeeID = employees.EmployeeID
WHERE
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY
    employees.EmployeeID
ORDER BY
    AvgOrdersPerMonth DESC
""""""

avg_orders_df = execute_sql_query(sql_query)

fig = px.bar(avg_orders_df, x='EmployeeName', y='AvgOrdersPerMonth', 
              title='Average Orders Handled per Month in 2023',
              labels={'AvgOrdersPerMonth': 'Average Orders per Month',
                      'EmployeeName': 'Employee Name'},
              color='AvgOrdersPerMonth')

show_to_user(fig)
```","The input code calculates average orders per employee by simply dividing the total order count by 12, assuming equal distribution across months, rather than calculating monthly averages first and then averaging those. This approach does not account for variations in order counts per month.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the average orders handled per month by each employee in 2023
sql_query = """"""
SELECT EmployeeID, AVG(OrderCount) AS AvgOrdersPerMonth
FROM (
    SELECT employees.EmployeeID, 
           COUNT(orders.OrderID) AS OrderCount,
           EXTRACT(MONTH FROM orders.OrderDate) AS Month
    FROM employees
    JOIN orders ON employees.EmployeeID = orders.EmployeeID
    WHERE EXTRACT(YEAR FROM orders.OrderDate) = 2023
    GROUP BY employees.EmployeeID, EXTRACT(MONTH FROM orders.OrderDate)
) AS MonthlyOrderCount
GROUP BY EmployeeID
""""""

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(df, x='EmployeeID', y='AvgOrdersPerMonth', title='Avg Number of Orders Handled Per Month by Employee in 2023')

show_to_user(fig)
```","The input Python code correctly executes an SQL query to calculate the average number of orders handled per month for each employee in 2023 and visualizes the results with a bar chart. It follows the same logic as the reference implementation, properly grouping by both EmployeeID and month, and averaging the order count. While the SQL syntax style and the chart labels are slightly different, these differences do not affect the overall correctness in answering the specified business analytics request.",Finetuned
How many discontinued products are still in stock?,"```python
import pandas as pd

# SQL query to find discontinued products still in stock
sql_query = ""SELECT COUNT(*) AS DiscontinuedInStock FROM products WHERE Discontinued = 1 AND UnitsInStock > 0;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Extract the count from the dataframe
discontinued_in_stock = df['DiscontinuedInStock'].iloc[0]

# Display the result to the user
show_to_user(discontinued_in_stock)
```","```python
sql_query = """"""
SELECT SUM(UnitsInStock) AS TotalDiscontinuedInStock
FROM products
WHERE Discontinued = 1
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code calculates the total sum of 'UnitsInStock' for discontinued products, whereas the reference implementation counts the number of discontinued products that are still in stock. The logic differs as the business request requires counting products, not summing their stock.","```python
# Assuming the existence of the required utility functions

# SQL query to retrieve the count of discontinued products that are still in stock
sql_query = """"""
SELECT COUNT(*) AS DiscontinuedInStock 
FROM products 
WHERE Discontinued = 1 AND UnitsInStock > 0;
""""""

# Execute the SQL query and retrieve the result as a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input Python code displays the entire DataFrame result_df instead of extracting the count and displaying the specific value of 'DiscontinuedInStock'. The reference implementation extracts the count using df['DiscontinuedInStock'].iloc[0] before displaying it, while the input code does not.",None
Determine the most frequently used shipping method.,"```python
import pandas as pd

# SQL query to get the most frequently used shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UseCount
FROM orders
GROUP BY ShipVia
ORDER BY UseCount DESC
LIMIT 1;
""""""

# Execute SQL query
most_used_shipping_method_df = execute_sql_query(sql_query)

# Display the result
show_to_user(most_used_shipping_method_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS frequency
FROM orders
GROUP BY ShipVia
ORDER BY frequency DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","Both implementations use a SQL query to count the frequency of each shipping method and order the results in descending order based on the count. They then limit the result to the top entry, which is the most frequently used shipping method. The logic and outcome are identical, making the input code correct.","```python
import pandas as pd

# SQL query to get the most frequently used shipping method
sql_query = """"""
SELECT orders.ShipVia, COUNT(orders.OrderID) AS usage_count
FROM orders
GROUP BY orders.ShipVia
ORDER BY usage_count DESC
LIMIT 1
""""""

# Execute the SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code correctly implements the logic to find the most frequently used shipping method. It uses a SQL query to count the occurrences of each shipping method in the 'orders' table, orders by the count in descending order, and limits the result to the top one. This matches the logic of the reference implementation.",both
Which products have not been ordered in the last three months?,"```python
import pandas as pd

# Define the correct SQL query
sql_query = """"""
SELECT ProductName FROM products 
WHERE ProductID NOT IN (
  SELECT DISTINCT ProductID 
  FROM `Order Details` 
  WHERE OrderID IN (
    SELECT OrderID 
    FROM orders 
    WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
  )
);
""""""

# Execute the SQL query
products_not_ordered_df = execute_sql_query(sql_query)

# Display the result
show_to_user(products_not_ordered_df)
```","```python
from datetime import datetime, timedelta

current_date = datetime.now()
three_months_ago = current_date - timedelta(days=90)
three_months_ago_str = three_months_ago.strftime('%Y-%m-%d')

sql_query = f""""""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IS NULL OR od.OrderID NOT IN (
    SELECT DISTINCT OrderID 
    FROM [Order Details] 
    WHERE OrderDate >= '{three_months_ago_str}'
)
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The evaluated Python code has a logic inconsistency. It incorrectly combines a LEFT JOIN with a condition checking for NULL or orders not in the last three months, which would mistakenly include products that have been ordered but not in the specific timeframe. The reference implementation correctly uses a subquery to find products not ordered at all during the last three months, excluding any with recent orders. The evaluated code also references 'OrderDate' in 'Order Details', which isn't in the provided schema as per the reference implementation where 'OrderDate' is in the 'orders' table.","```python
# Import necessary libraries
import pandas as pd
import plotly.express as px

# Execute the provided SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName 
FROM products p 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
LEFT JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate < DATEADD(month, -3, CURRENT_DATE) OR o.OrderID IS NULL;
""""""
data_frame = execute_sql_query(sql_query)

# Display results using Plotly
if not data_frame.empty:
    fig = px.bar(data_frame, x='ProductName', title='Products Not Ordered in Last Three Months')
    show_to_user(fig)
```
","The input code uses LEFT JOINs to find products not ordered in the last three months. It includes products with any order older than three months or no order at all, resulting in incorrect filtering. The reference implementation correctly checks for products never ordered or ordered outside the last three months by ensuring the absence of recent orders. The input logic could include products that have been ordered, just not recently.",None
What is the average Inventory Turnover Ratio for each month and visualize it using a line chart to show trends?,"```python
import plotly.express as px

# SQL query to calculate Inventory Turnover Ratio
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'Month' to datetime for proper plotting
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart to visualize the trend of Inventory Turnover Ratio
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Average Inventory Turnover Ratio per Month')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS Inventory_Turnover_Ratio
FROM 
    [Order Details] AS od
JOIN 
    products AS p ON od.ProductID = p.ProductID
JOIN 
    orders AS o ON od.OrderID = o.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

inventory_turnover_df = execute_sql_query(sql_query)

fig = px.line(inventory_turnover_df, x='Month', y='Inventory_Turnover_Ratio', title='Average Inventory Turnover Ratio per Month')
show_to_user(fig)
```","The input code correctly calculates the average Inventory Turnover Ratio per month and creates a line chart for the trends. It follows the same logic as the reference implementation by joining the necessary tables, computing the ratio using the provided formula, and grouping by month. The minor differences, such as aliasing and order of operations in SQL, don't affect the correctness as the logic and operations are consistent with the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(orderDate, '%Y-%m') AS order_month, 
    AVG((SUM(Quantity) / COUNT(DISTINCT ProductID))) AS avg_inventory_turnover_ratio 
FROM mddx 
WHERE orderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY order_month;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Convert order_month to datetime for proper plotting
df['order_month'] = pd.to_datetime(df['order_month'])

# Create a line chart to visualize the trend of average Inventory Turnover Ratio over months
fig = px.line(df, x='order_month', y='avg_inventory_turnover_ratio', title='Average Inventory Turnover Ratio per Month (2022)', markers=True)

# Display the line chart to the user
show_to_user(fig)
```","The input Python code does not align with the reference logic for calculating Inventory Turnover Ratio. The reference code computes it as the ratio of total sales value to average units in stock, while the input code seems to use average of a ratio of sum of quantity to number of distinct products. Additionally, the date range restriction in the input is not present in the reference code.",Base
List the top 5 employees with the highest salaries.,"```python
import pandas as pd

# SQL Query to get the top 5 employees with the highest salaries
sql_query = """"""
SELECT EmployeeID, FirstName, LastName, Salary 
FROM employees 
ORDER BY Salary DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_employees_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(top_employees_df)
```","```python
sql_query = """"""
SELECT EmployeeID, FirstName, LastName, Salary 
FROM employees 
ORDER BY Salary DESC 
LIMIT 5
""""""
top_employees = execute_sql_query(sql_query)
show_to_user(top_employees)
```",The provided code is correct as it matches the logic of the reference implementation. Both codes execute an SQL query to fetch the top 5 employees with the highest salaries and then display the results. The absence of a semicolon at the end of the query in the input code does not affect its correctness in this context.,"```python
import pandas as pd

# Business analytic request
def execute_business_analytic_request_to_dataframe(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration purposes
    # In practice, this would execute the SQL query and return a DataFrame
    data = [
        {'FirstName': 'John', 'LastName': 'Doe', 'Salary': 90000},
        {'FirstName': 'Jane', 'LastName': 'Smith', 'Salary': 85000},
        {'FirstName': 'Emily', 'LastName': 'Jones', 'Salary': 80000},
        {'FirstName': 'Michael', 'LastName': 'Brown', 'Salary': 75000},
        {'FirstName': 'Emily', 'LastName': 'Davis', 'Salary': 70000},
    ]
    return pd.DataFrame(data)

def show_to_user(data: pd.DataFrame):
    # Assuming this function simply prints the DataFrame
    print(data)

# SQL query to get the top 5 employees with the highest salaries
sql_query = """"""
SELECT employees.FirstName, employees.LastName, employees.Salary
FROM employees
ORDER BY employees.Salary DESC
LIMIT 5
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_business_analytic_request_to_dataframe(sql_query)

# Display the result
show_to_user(df)
```","The input code provides a static mock implementation rather than executing the SQL query. The mock data in 'execute_business_analytic_request_to_dataframe' does not necessarily reflect the top 5 employees with the highest salaries from a database. This diverges from the reference implementation, which implies querying a database directly to retrieve and order the data.",Base
What's the average discount applied to products?,"```python
import pandas as pd

# SQL query to get the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the average discount
average_discount = result_df['AverageDiscount'].iloc[0]
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))
```","```python
sql_query = """"""
SELECT AVG(Discount) as AverageDiscount
FROM [Order Details]
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code follows the same logic as the reference implementation. It executes an SQL query to calculate the average discount and displays the result using the 'show_to_user' function. Both implementations have equivalent functionality, although the input code streamlines the process by directly passing the result to 'show_to_user' without explicitly isolating the average discount value.","```python
# Given utility function import
from utility import execute_sql_query

# SQL query to calculate the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL query and obtain the result
result = execute_sql_query(sql_query)

# Display the average discount
print(result)
```","The input code executes the SQL query correctly to calculate the average discount, but it uses 'print(result)' instead of following the logic of the reference implementation, which involves extracting the 'AverageDiscount' value from the result DataFrame and displaying it using a formatted DataFrame via 'show_to_user'.",Base
Calculate the total sales revenue generated each month and illustrate with a line chart.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
GROUP BY Month;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Ensure 'Month' is in datetime format for correct plotting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Create a line chart
fig = px.line(sales_data, x='Month', y='MonthlySales', title='Monthly Sales Revenue', labels={'MonthlySales': 'Sales Revenue', 'Month': 'Month'})

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    `orders` o
JOIN 
    `[Order Details]` od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Total Sales Revenue')
show_to_user(fig)
```","The input code does not convert the 'Month' column into datetime format before plotting. For accurate timeline plotting, especially for line charts, date columns should be in a datetime format. This is a key step present in the reference code but missing in the input code.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT 
    TO_CHAR(orders.OrderDate, 'YYYY-MM') AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY TO_CHAR(orders.OrderDate, 'YYYY-MM')
""""""

# Execute the SQL query and get the data in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(
    sales_data,
    x='month',
    y='total_sales',
    title='Total Sales Revenue Generated Each Month',
    labels={'total_sales': 'Total Sales Revenue', 'month': 'Month'}
)

# Display the line chart to the user
show_to_user(fig)
```","The input code queries total monthly sales revenue using SQL and plots a line chart similarly to the reference code. While the input code uses TO_CHAR for formatting and square brackets for column names, the logic and output are equivalent.",Finetuned
What percentage of orders were shipped after the required date each month and visualize the trends with a bar chart.,"```python
import plotly.express as px

# SQL query to get the percentage of late deliveries each month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) / COUNT(OrderID) AS LateDeliveryRate 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure LateDeliveryRate is in percentage format for plotting
df['LateDeliveryRate'] *= 100

# Create a bar chart to visualize the trend of late delivery rates
fig = px.bar(df, x='Month', y='LateDeliveryRate', 
             title='Monthly Late Delivery Rate',
             labels={'LateDeliveryRate': 'Late Delivery Rate (%)', 'Month': 'Month'})

# Use the defined utility function to display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(*) AS TotalOrders,
    SUM(CASE WHEN ShippedDate > RequiredDate THEN 1 ELSE 0 END) AS LateShipments
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

order_data = execute_sql_query(sql_query)

order_data['LateShipmentPercentage'] = (order_data['LateShipments'] / order_data['TotalOrders']) * 100

fig = px.bar(order_data, x='Month', y='LateShipmentPercentage', 
             title='Percentage of Orders Shipped Late Each Month',
             labels={'LateShipmentPercentage': 'Percentage of Late Shipments'})
show_to_user(fig)
```","The input code correctly calculates the percentage of orders shipped late each month by dividing the number of late shipments by the total number of orders, similar to the reference implementation. Both approaches use SQL to extract the necessary fields and compute the percentage in pandas (the input code) or SQL (the reference code). They both then visualize the result using a bar chart with Plotly, showing the percentage of late shipments per month, effectively satisfying the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Provided utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation for executing the SQL query.
    return pd.DataFrame()

def show_to_user(data):
    # Placeholder implementation for displaying data or visualization.
    pass

# Define the SQL query
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) as Month, 
    COUNT(OrderID) FILTER (WHERE ShippedDate > RequiredDate) * 100.0 / COUNT(OrderID) AS LatePercentage 
FROM 
    orders 
GROUP BY 
    Month;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Month', y='LatePercentage', title='Late Shipment Percentage by Month')

# Display the bar chart
show_to_user(fig)
```","The provided code correctly computes the percentage of orders shipped late each month and visualizes the data using a bar chart. Although it uses a slightly different SQL syntax (DATE_TRUNC and FILTER), it achieves the same result as the reference implementation. The SQL calculates the percentage correctly, and the visualization format aligns with the reference.",both
Which shipping method was used most frequently?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount
FROM orders
GROUP BY ShipVia
ORDER BY UsageCount DESC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if result_df is not empty before showing to user
if not result_df.empty:
    show_to_user(result_df)
else:
    show_to_user(pd.DataFrame({""Message"": [""No data found""]}))
```","```python
sql_query = """"""
SELECT ShipVia, COUNT(*) AS Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code executes a SQL query that counts the number of times each shipping method is used, groups by 'ShipVia', orders by the count in descending order, and limits the result to the top entry. This matches the logic of the reference implementation, which also selects the most frequently used shipping method based on the count of OrderID. The column alias difference ('Frequency' vs 'UsageCount') does not affect the correctness. Additionally, the reference implementation's check for an empty DataFrame is a safeguard but does not change the core logic in determining the most used shipping method.","```python
def execute_sql_query(sql_query: str):
    # Simulated database execution and return for illustration purposes
    pass

def display_to_user(data):
    # Display the results to the user
    pass

# SQL query to find the most frequently used shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount 
FROM orders 
GROUP BY ShipVia 
ORDER BY UsageCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and fetch the results
most_frequent_shipping_method = execute_sql_query(sql_query)

# Display the result to the user
display_to_user(most_frequent_shipping_method)
```","The provided code correctly implements the logic to determine the most frequently used shipping method. It constructs an SQL query to select the shipping method with the highest usage count, based on the 'ShipVia' column, and orders the results in descending order to limit the result to the top entry. Additionally, the code fetches the query result and displays it to the user, similar to the reference implementation.",both
What is the customer retention rate from January 2022 to January 2023 and visualize retention trend with a line graph.,"```python
import plotly.express as px
import pandas as pd

# SQL queries to get unique customer counts
query_retained_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS retained_customers_count
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2023-01-01'
AND orders.CustomerID IN (
    SELECT DISTINCT CustomerID
    FROM orders
    WHERE orders.OrderDate < '2022-01-01'
)
""""""

query_existing_customers = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS existing_customers_count
FROM orders
WHERE orders.OrderDate < '2022-01-01'
""""""

# Execute the queries
retained_customers_df = execute_sql_query(query_retained_customers)
existing_customers_df = execute_sql_query(query_existing_customers)

# Calculate retention rate
retained_customers = retained_customers_df['retained_customers_count'].iloc[0]
existing_customers = existing_customers_df['existing_customers_count'].iloc[0]
retention_rate = retained_customers / existing_customers if existing_customers != 0 else 0

# Create a pandas DataFrame for visualization
data = {
    'Date Range': ['2022-01 to 2023-01'],
    'Retention Rate': [retention_rate]
}
retention_df = pd.DataFrame(data)

# Visualization using Plotly
fig = px.line(retention_df, x='Date Range', y='Retention Rate', title='Customer Retention Rate Trend')

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query_retention = """"""
WITH retention AS (
    SELECT
        DATE_TRUNC('month', OrderDate) AS order_month,
        COUNT(DISTINCT CustomerID) AS total_customers
    FROM
        orders
    WHERE
        OrderDate BETWEEN '2022-01-01' AND '2023-01-31'
    GROUP BY 1
),
previous_customers AS (
    SELECT
        COUNT(DISTINCT CustomerID) AS returning_customers
    FROM
        orders
    WHERE
        OrderDate < '2022-01-01'
)
SELECT
    order_month,
    total_customers,
    (SELECT returning_customers FROM previous_customers) AS returning_customers,
    (total_customers * 1.0 / (SELECT returning_customers FROM previous_customers)) * 100 AS retention_rate
FROM
    retention
ORDER BY 
    order_month;
""""""

retention_data = execute_sql_query(sql_query_retention)
fig = px.line(retention_data, x='order_month', y='retention_rate', title='Customer Retention Rate (Jan 2022 - Jan 2023)', labels={'retention_rate': 'Retention Rate (%)'})
show_to_user(fig)
```","The evaluated code estimates the customer retention rate by comparing the number of unique customers per month from January 2022 to January 2023 with the total number of unique customers before January 2022. However, this method misrepresents retention since it calculates monthly customers as 'retained,' assuming all monthly customers existed before January 2022, which is incorrect. The reference implementation directly computes customers retained by identifying those who existed before 2022 and placed orders in 2022-2023, resulting in a more accurate retention measure.","```python
import pandas as pd
import plotly.express as px

# Function to retrieve data based on given SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function: replace with actual database connection and execution logic
    pass

# Function to display data or a plot to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Define the SQL query for customer retention data
sql_query = """"""
WITH monthly_purchases AS (
    SELECT 
        c.CustomerID, 
        EXTRACT(MONTH FROM o.OrderDate) AS month 
    FROM 
        customers c 
    JOIN 
        orders o ON c.CustomerID = o.CustomerID 
    WHERE 
        o.OrderDate BETWEEN '2021-12-01' AND '2023-01-31'
)
SELECT 
    month,
    COUNT(DISTINCT CASE WHEN month <= 12 THEN CustomerID END) AS cohort_size,
    COUNT(DISTINCT CustomerID) AS retained_customers
FROM 
    monthly_purchases
GROUP BY 
    month
ORDER BY 
    month;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Calculate retention rate and add it to the dataframe
df['retention_rate'] = df['retained_customers'] / df['cohort_size']

# Plotting the retention trend
fig = px.line(df, x='month', y='retention_rate', title='Customer Retention Rate (Jan 2022 - Jan 2023)',
              labels={'retention_rate': 'Retention Rate', 'month': 'Month'})

# Display the plot
show_to_user(fig)
```","The input code uses a CTE to generate monthly customer data for the period '2021-12-01' to '2023-01-31'. It attempts to calculate monthly retention rates which differs from the reference code that calculates a single retention rate for the entire year (from January 2022 to January 2023). Furthermore, the input code divides 'retained_customers' by 'cohort_size' which is calculated incorrectly, as the logic for 'cohort_size' does not match the reference code's approach. The reference code compares customers from a year prior to 2022 to those retained up to 2023, focusing only on customers existing before 2022.",None
What is the average order value for the year 2021?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) AS OrderValue,
    orders.OrderID
FROM 
    orders 
JOIN 
    [Order Details] 
ON 
    orders.OrderID = [Order Details].OrderID 
WHERE 
    YEAR(orders.OrderDate) = 2021;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate average order value
average_order_value = result_df.groupby('OrderID')['OrderValue'].sum().mean()

# Show the result to the user
show_to_user(pd.DataFrame({'AverageOrderValue': [average_order_value]}))
```","```python
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AverageOrderValue
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    YEAR(orders.OrderDate) = 2021
""""""

average_order_value = execute_sql_query(sql_query)
show_to_user(average_order_value)
```",Both implementations correctly calculate the average order value for the year 2021. The input code uses SQL to directly compute the average order value by dividing the total order value sum by the distinct number of orders. The reference code does it by first calculating the order values and then averaging them. Both approaches yield the same result.,"```python
import pandas as pd

# Assuming the necessary function is defined elsewhere in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the actual implementation
    pass

def display_to_user(data):
    # Placeholder for the actual implementation
    pass

# SQL query to get the average order value for the year 2021
sql_query = """"""
SELECT AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue2021 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = 2021;
""""""

# Execute the SQL query using the utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
display_to_user(result_df)
```",The input code calculates the average of all individual line items directly via SQL without aggregating them by Order ID. The reference code first calculates the total order value by grouping line items by Order ID and then computes the average of these sums. These two approaches yield different results if orders have multiple items.,Base
Identify the top 3 products with the most number of orders and illustrate with a bar chart.,"```python
import plotly.express as px

# SQL query to retrieve top 3 products with most orders
sql_query = """"""
SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) AS NumberOfOrders
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY NumberOfOrders DESC
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductName', y='NumberOfOrders', title='Top 3 Products with Most Orders')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrders
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrders DESC
LIMIT 3;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='TotalOrders', title='Top 3 Products with Most Orders')
show_to_user(fig)
```","The input code calculates the top 3 products based on the sum of quantities (TotalOrders) instead of the number of orders. The business request and reference implementation require counting OrderID occurrences to determine the product ranking by the number of orders, not the quantity of items ordered.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT products.ProductName, COUNT([Order Details].OrderID) AS NumOrders
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductName
ORDER BY NumOrders DESC
LIMIT 3;
""""""

# Execute SQL query to get the data
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 products with most orders
fig = px.bar(top_products_df, x='ProductName', y='NumOrders', title='Top 3 Products by Number of Orders')

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request. It retrieves the top 3 products based on the number of orders and visualizes the results using a bar chart. The SQL query logic matches the reference implementation: it joins the 'products' and 'Order Details' tables, counts the number of orders per product, sorts the results in descending order, and limits the output to the top 3. The visualization using Plotly is consistent with the reference code. Although the input code labels the order count as 'NumOrders' instead of 'NumberOfOrders', this does not affect correctness since it still defines the count appropriately.",Finetuned
What are the average monthly sales generated by each region and present with a multi-line chart for each region.,"```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT territories.RegionID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) /
       COUNT(DISTINCT DATE_TRUNC('month', orders.OrderDate)) AS avg_monthly_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
GROUP BY territories.RegionID
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Multi-line chart
fig = px.line(df, x=df.index, y='avg_monthly_sales', color='RegionID', title='Average Monthly Sales by Region')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS month,
    customers.Region,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
GROUP BY 
    month, customers.Region
ORDER BY 
    month, customers.Region
""""""

monthly_sales_df = execute_sql_query(sql_query)

average_sales_df = monthly_sales_df.groupby('Region').agg({'total_sales': 'mean'}).reset_index()
average_sales_df['average_sales'] = average_sales_df['total_sales']

fig = px.line(average_sales_df, x='Region', y='average_sales', title='Average Monthly Sales by Region', markers=True)
show_to_user(fig)
```","The input code is incorrect because it calculates the average monthly sales incorrectly. It first aggregates sales by month and region, then calculates the mean total sales per region, rather than dividing by distinct months as in the reference. Additionally, the plot differs; it uses 'Region' for the x-axis incorrectly instead of plotting over time, and the chart type should be a multi-line chart, where each region has its own line.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT
    regions.RegionDescription,
    DATE_TRUNC('month', orders.OrderDate) AS OrderMonth,
    AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageMonthlySales
FROM
    [Order Details]
JOIN
    orders ON [Order Details].OrderID = orders.OrderID
JOIN
    employees ON orders.EmployeeID = employees.EmployeeID
JOIN
    territories ON employees.EmployeeID = territories.EmployeeID
JOIN
    regionTerritory ON territories.TerritoryID = regionTerritory.TerritoryID
JOIN
    regions ON regionTerritory.RegionID = regions.RegionID
GROUP BY
    regions.RegionDescription, OrderMonth
ORDER BY
    regions.RegionDescription, OrderMonth
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Convert OrderMonth to datetime for proper plotting
df['OrderMonth'] = pd.to_datetime(df['OrderMonth'])

# Group by RegionDescription for plotting
fig = px.line(
    df,
    x='OrderMonth',
    y='AverageMonthlySales',
    color='RegionDescription',
    title=""Average Monthly Sales by Region"",
    labels={'AverageMonthlySales': 'Average Monthly Sales', 'OrderMonth': 'Order Month'}
)

# Display the multi-line chart
show_to_user(fig)
```","The input code computes the average monthly sales incorrectly. The reference code calculates the average sales per month by dividing the total sales by the count of distinct months, ensuring accumulation of sales over counted periods per region ID. The input code averages sales per month directly, without aggregating distinct months, leading to a potential difference in results. Also, it uses region descriptions instead of IDs, which might not align analytically with the reference requirement.",None
Find the order with the highest discount applied.,"```python
import pandas as pd

# SQL query to find the order with the highest discount
sql_query = ""SELECT OrderID, MAX(Discount) as MaxDiscount FROM [Order Details] GROUP BY OrderID ORDER BY MaxDiscount DESC LIMIT 1;""

# Execute the SQL query and retrieve the data
order_with_max_discount = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_with_max_discount)
```","```python
sql_query = """"""
SELECT TOP 1 OrderID, SUM(Quantity * Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY OrderID
ORDER BY TotalDiscount DESC
""""""

highest_discount_order = execute_sql_query(sql_query)
show_to_user(highest_discount_order)
```","The reference code finds the order with the highest single discount value using MAX(Discount) and groups by OrderID. The input code calculates the total discount per order by summing Quantity * Discount, and then orders by this sum. These are different approaches: one looks for the maximum individual discount, the other for the highest total discount across all items in an order.","
```python
import pandas as pd

# Assuming the execute_sql_query function is implemented elsewhere
# and returns a pandas DataFrame.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is a placeholder for executing SQL queries
    pass  # Implementation would go here

def show_to_user(data: pd.DataFrame)):
    # Placeholder for displaying the data
    pass  # Implementation would go here

# SQL query to find the order with the highest discount
sql_query = """"""
SELECT OrderID, Discount
FROM [Order Details]
ORDER BY Discount DESC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```
","The input code fetches the row with the single highest discount, but it doesn't consider multiple discounts per order and selects based directly on the discount value. The reference code logically groups discounts by OrderID and selects the order with the highest maximum discount. Hence, the input code might not return the correct order if the largest discount is not representative of an order's overall highest discount.",None
Calculate the monthly total sales revenue over the last year and plot with a time series line chart.,"```python
import plotly.express as px

# SQL query to fetch monthly total sales revenue over the last year
sql_query = """"""
SELECT MONTH(o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1
GROUP BY MONTH(o.OrderDate) 
ORDER BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Plot the time series line chart
fig = px.line(df, x='Month', y='TotalSales', labels={'Month': 'Month', 'TotalSales': 'Total Sales Revenue'},
              title='Monthly Total Sales Revenue Over the Last Year')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= NOW() - INTERVAL '1 year'
GROUP BY 
    month
ORDER BY 
    month;
""""""

sales_data = execute_sql_query(sql_query)
fig = px.line(sales_data, x='month', y='total_sales', title='Monthly Total Sales Revenue Over the Last Year')
show_to_user(fig)
```","The code snippet calculates monthly total sales revenue, but it uses DATE_TRUNC and INTERVAL '1 year', which includes revenues from one year prior to the current date up to today, rather than strictly the last calendar year as done in the reference code. The reference code specifically filters orders from the last calendar year using YEAR(CURRENT_DATE) - 1.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', orders.OrderDate) AS Month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS MonthlySales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '1 year'
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query using the utility function
sales_data = execute_sql_query(sql_query)

# Plot the results using Plotly
fig = px.line(sales_data, x='Month', y='MonthlySales', title='Monthly Total Sales Revenue',
              labels={'MonthlySales': 'Total Sales Revenue', 'Month': 'Month'},
              markers=True)

# Display the plot
show_to_user(fig)
```","The input code correctly calculates the monthly total sales revenue over the last year. It uses a SQL query to select the truncated order date by month and sums the total sales for each month. The filter condition ensures the data is from the last year, similar to the reference code. The Plotly line chart also plots the monthly sales revenue correctly. Minor differences in SQL syntax and plotting parameters do not affect correctness.",Finetuned
How many units are currently in stock for each product?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitsInStock FROM products;""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Display the data to user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0;
""""""
product_stock = execute_sql_query(sql_query)
show_to_user(product_stock)
```","The input code includes an additional condition 'WHERE Discontinued = 0;' which is not present in the reference implementation. This means it filters out discontinued products, leading to potentially different results from the reference code that retrieves all products' stock without additional filtering.","```python
import pandas as pd

# Assuming execute_sql_query and display_to_user are pre-defined functions.

# SQL query to get the current stock for each product
sql_query = ""SELECT ProductID, UnitsInStock FROM products;""

# Execute the SQL query and store the result in a DataFrame
stock_data = execute_sql_query(sql_query)

# Display the resulting DataFrame to the user
display_to_user(stock_data)
```","The input code retrieves 'ProductID' instead of 'ProductName' as specified in the reference implementation. While both codes correctly fetch 'UnitsInStock', the requirement according to the reference is to display the 'ProductName' for clarity to the user. Thus, the input code does not fully adhere to the logic specified in the reference implementation.",None
List employees who have birthdays in the current month.,"```python
from datetime import datetime
import pandas as pd

# Fetch current month
current_month = datetime.now().month

# Define the SQL query
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
WHERE MONTH(e.BirthDate) = {current_month};
""""""

# Execute SQL query
employees_with_birthday = execute_sql_query(sql_query)

# Display the results
show_to_user(employees_with_birthday)
```","```python
from datetime import datetime

current_month = datetime.now().month
sql_query = f""""""
SELECT EmployeeID, FirstName, LastName, BirthDate 
FROM employees 
WHERE MONTH(BirthDate) = {current_month}
""""""
employees_with_birthdays = execute_sql_query(sql_query)
show_to_user(employees_with_birthdays)
```","The input code correctly retrieves employees with birthdays in the current month by using the same logic as the reference implementation. It constructs a SQL query that filters employees based on their birth month matching the current month. The slight differences in the query (outputting 'BirthDate' as well) do not affect the correctness regarding the business request, which focuses on listing employees with birthdays in the current month.","
```python
import pandas as pd
from datetime import datetime

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for database execution logic
    pass

def show_to_user(data: pd.DataFrame):
    # Placeholder for displaying the data
    pass

# SQL Query to fetch employees with birthdays in the current month
sql_query = """"""
SELECT 
    EmployeeID, 
    CONCAT(FirstName, ' ', LastName) AS FullName 
FROM 
    employees 
WHERE 
    MONTH(BirthDate) = MONTH(CURRENT_DATE);
""""""

# Execute the query and get the result as a DataFrame
employees_birthday_this_month = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(employees_birthday_this_month)
```","The input code correctly fetches employees who have birthdays in the current month by using a SQL query that compares the birth month to the current month. The logic matches the reference implementation, as both aim to achieve the same result using SQL and display the data. Minor differences, like concatenating first and last names in the input code, do not affect the correctness in terms of the main goal.",both
What is the total sales revenue for each product and display with a sorted bar chart.,"```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT P.ProductID, SUM(OD.Quantity * OD.UnitPrice) AS TotalSalesRevenue 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY P.ProductID;
""""""

# Execute the SQL query and store the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Sort the dataframe by TotalSalesRevenue in descending order
df_sorted = df.sort_values(by='TotalSalesRevenue', ascending=False)

# Create a bar chart using plotly express
fig = px.bar(df_sorted, x='ProductID', y='TotalSalesRevenue', title='Total Sales Revenue by Product')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSalesRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalSalesRevenue DESC;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, 
             x='ProductName', 
             y='TotalSalesRevenue', 
             title='Total Sales Revenue for Each Product', 
             labels={'TotalSalesRevenue': 'Total Sales Revenue', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code calculates total sales revenue per product, considering discounts, and sorts them directly in the SQL query, whereas the reference code calculates total sales revenue without discounts and sorts the data using pandas. Additionally, the input uses product names instead of IDs, which deviates from the reference logic.","```python
import plotly.express as px
import pandas as pd

# Business Intelligence Detail
# This request is about calculating total sales revenue for each product and displaying it using a sorted bar chart.

# SQL Query Definition
sql_query = """"""
SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue
FROM [Order Details]
GROUP BY ProductID
""""""

# Function call to execute the SQL query and return a DataFrame
df = execute_sql_query(sql_query)

# Sort the DataFrame by TotalRevenue in descending order
sorted_df = df.sort_values(by='TotalRevenue', ascending=False)

# Create a bar chart to display the total sales revenue for each product
fig = px.bar(sorted_df, 
             x='ProductID', 
             y='TotalRevenue', 
             title='Total Sales Revenue for Each Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductID': 'Product ID'})

# Display the sorted bar chart to the user
show_to_user(fig)
```","The input Python code correctly calculates the total sales revenue for each product by summing the product of 'Quantity' and 'UnitPrice' from the 'Order Details' table. It uses an SQL query to group by 'ProductID', executes the query to retrieve a DataFrame, and sorts it by 'TotalRevenue' in descending order. Finally, the code creates and displays a bar chart using Plotly Express, similar to what is done in the reference code. Although the reference code joins with 'products', since the query groups by 'ProductID', the result remains logically the same. Therefore, the input code is correct.",Finetuned
Who is the highest paid employee and what is their total sales?,"```python
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY e.Salary DESC 
LIMIT 1;
'''

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
LEFT JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Salary
ORDER BY e.Salary DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly identifies the highest paid employee and calculates their total sales, adhering to the same logic as the reference code. Both queries order employees by salary in descending order and limit the result to one employee, ensuring the highest salary is selected. The small differences, such as the use of LEFT JOIN and inclusion of FirstName and LastName in the GROUP BY clause, do not affect the correctness of the solution to the business question.","
```python
import pandas as pd

# SQL query to find the highest paid employee and their total sales
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Salary 
ORDER BY e.Salary DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```
","The input code correctly follows the logic of the reference implementation. Both queries aim to identify the highest paid employee and calculate their total sales by using similar aggregation and ordering logic. The two differences are: including 'FirstName' and 'LastName' fields in the input code, which are irrelevant to solving the core business question, and having the same GROUP BY and LIMIT logic as the reference. Therefore, the input code is considered correct.",both
What is the average discount given for each supplier's products and visualize with a bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS AvgDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AvgDiscount', title='Average Discount by Supplier')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='SupplierID', y='AverageDiscount', 
             title='Average Discount by Supplier', 
             labels={'SupplierID': 'Supplier ID', 'AverageDiscount': 'Average Discount'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It uses the same SQL query logic to calculate the average discount per supplier and visualizes the result using a bar chart, similar to the reference implementation. The differences, such as the label customization in the bar chart, do not affect the fundamental logic, thus making it correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to get data
sql_query = """"""
SELECT suppliers.SupplierID, AVG([Order Details].Discount) AS AvgDiscount
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY suppliers.SupplierID
""""""

# Execute the SQL query to obtain the data in a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discount per supplier
fig = px.bar(data, x='SupplierID', y='AvgDiscount',
             title='Average Discount by Supplier',
             labels={'AvgDiscount': 'Average Discount', 'SupplierID': 'Supplier ID'})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request to calculate the average discount per supplier and visualize it as a bar chart. The main difference from the reference implementation is the starting table for the SQL query (using 'suppliers' directly instead of 'products'). However, the logic remains consistent as both join the necessary tables to get the average discount by SupplierID. The visualization component is also implemented correctly using Plotly, matching the essential criteria of the reference code.",both
Calculate the total sales revenue generated in the last month.,"```python
import pandas as pd

# SQL Query to calculate total sales revenue for the last month
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Display the result
show_to_user(sales_data.iloc[0]['TotalSales'])
```","```python
from datetime import datetime, timedelta
import pandas as pd

last_month_start = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1)
last_month_end = last_month_start + timedelta(days=31)
last_month_end = last_month_end.replace(day=1) - timedelta(days=1)

sql_query = f""""""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '{last_month_start.strftime(""%Y-%m-%d"")}' 
AND orders.OrderDate <= '{last_month_end.strftime(""%Y-%m-%d"")}'
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input code calculates the total sales revenue for the last month, similar to the reference implementation. It defines the start and end date of the last month, constructs the SQL query to sum the revenue using the same logic of multiplying unit price, quantity, and applying the discount, and executes it. Although the date logic differs slightly (handling end of the month), it achieves the same result: calculating total sales revenue for the last month.","```python
# Import necessary libraries
import pandas as pd

# Define the SQL query to calculate total sales revenue for the last month
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate >= DATEADD(month, -1, CURRENT_DATE)
""""""

# Execute the query and obtain results in a DataFrame
sales_data = execute_sql_query(sql_query)

# Display the total sales revenue
show_to_user(sales_data)
```","The input code uses DATEADD instead of DATE_SUB or equivalent to determine the date from one month ago. The SQL dialect and function used (CURRENT_DATE, DATEADD) suggest the possibility of syntax errors if not supported by the database engine. Additionally, the 'show_to_user' function in the input is called with the entire DataFrame instead of accessing the 'TotalSales' value directly, which may lead to incorrect output formatting.",Base
What is the total sales per employee for each month and illustrate with a stacked bar chart.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT e.EmployeeID, 
       strftime('%Y-%m', o.OrderDate) as OrderMonth, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, OrderMonth;
""""""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Create a stacked bar chart
fig = px.bar(result_df, x='OrderMonth', y='TotalSales', color='EmployeeID', 
             title='Total Sales per Employee for Each Month', 
             labels={'TotalSales': 'Total Sales', 'OrderMonth': 'Order Month'}, 
             barmode='stack')

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, OrderMonth
ORDER BY 
    OrderMonth, e.EmployeeID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='OrderMonth', y='TotalSales', color='EmployeeName', 
             title='Total Sales per Employee for Each Month',
             labels={'TotalSales': 'Total Sales', 'OrderMonth': 'Month'},
             text='TotalSales')

fig.update_traces(texttemplate='%{text:,.2f}', textposition='outside')
fig.update_layout(barmode='stack')
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request. It calculates the total sales per employee for each month using a SQL query, similar to the reference implementation. Although it differs slightly by including employee names and sorting the result, this does not affect the correctness in terms of calculation and plotting. The stacked bar chart is also created using Plotly Express with appropriate labels and configurations, aligning with the reference implementation's logic.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS OrderMonth, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * 
        (1 - [Order Details].Discount)) AS TotalSales
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    employees.EmployeeID, DATE_FORMAT(orders.OrderDate, '%Y-%m');
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create the stacked bar chart
fig = px.bar(
    df, 
    x='OrderMonth', 
    y='TotalSales', 
    color='EmployeeID',
    title='Total Sales Per Employee for Each Month',
    labels={'TotalSales': 'Total Sales', 'OrderMonth': 'Order Month'},
    text_auto=True
)

# Show the plot using the utility function
show_to_user(fig)
```
","The input Python code correctly implements the business analytics request following the specified logic. It executes a SQL query to calculate total sales per employee for each month and uses Plotly to create a stacked bar chart, similar to the reference implementation. The key differences, such as using 'DATE_FORMAT' instead of 'strftime', are due to potential differences in SQL dialects and do not affect the correctness. The chart creation, grouping, and label parameters align with the reference implementation.",both
How does the total number of units sold compare between discontinued and active products and visualize with a comparative bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.Discontinued, 
       SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.Discontinued
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a comparative bar chart using Plotly
fig = px.bar(df, x='Discontinued', y='TotalUnitsSold',
             labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'},
             title='Total Units Sold: Discontinued vs Active Products',
             color='Discontinued')

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.Discontinued, 
    SUM(od.Quantity) AS TotalUnitsSold
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.Discontinued
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='Discontinued', y='TotalUnitsSold', 
              labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'},
              title='Comparison of Total Units Sold between Discontinued and Active Products')
show_to_user(fig)
```","The input code executes an SQL query to retrieve the total units sold grouped by product status (discontinued or active). It then uses Plotly to create a bar chart that compares this data, following the same logic and achieving the same outcome as the reference implementation. The variable names and labeling are consistent, and the SQL query structure is equivalent.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT p.Status, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
INNER JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.Status;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a comparative bar chart using Plotly
fig = px.bar(df, x='Status', y='TotalUnitsSold', title='Total Units Sold by Product Status', 
             labels={'TotalUnitsSold': 'Total Units Sold', 'Status': 'Product Status'})

# Display the plot
show_to_user(fig)
```","The input code performs the same logical operations as the reference code. Both codes execute a SQL query to sum 'Quantity' from the 'Order Details' table grouped by product status (discontinued or not), although the specific column name 'Discontinued' in the reference is labeled as 'Status' in the input. Both then use Plotly to visualize the results with a bar chart. Therefore, the input code answers the business analytics request correctly by comparing total units sold for discontinued and active products and visualizes the comparison with a bar chart.",both
Count the total number of orders placed by each customer.,"```python
import pandas as pd

# Construct the SQL query
sql_query = ""SELECT CustomerID, COUNT(*) AS total_orders FROM orders GROUP BY CustomerID;""

# Execute the SQL query and get the result as a pandas dataframe
df_orders = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_orders)
```","```python
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) AS TotalOrders
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly counts the total number of orders placed by each customer. The use of LEFT JOIN ensures all customers are included, even if they haven't placed any orders, which aligns logically with counting orders per customer. The GROUP BY ensures counts are aggregated by customer. The result is similar to the reference implementation, which counts orders per customer using only the orders table. Both methods achieve the intended business request.","```python
import pandas as pd

# SQL query to get the number of orders placed by each customer
sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) as OrderCount
FROM orders o
GROUP BY o.CustomerID
""""""

# Execute the SQL query and get the results as a DataFrame
order_counts_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_counts_df)
```","The input code fulfills the business analytics request by correctly counting the total number of orders for each customer using similar logic to the reference code. Both implementations use SQL queries to group by CustomerID and count the number of orders, albeit with slight differences in aliasing and column naming. The order of operations and final output structure are consistent with the reference.",both
Identify the product categories with the lowest total sales revenue and display with a bar chart.,"```python
import plotly.express as px

# SQL query to identify the product category with the lowest total sales revenue
sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
ORDER BY TotalRevenue ASC
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales revenue by the lowest product category
fig = px.bar(df, x='CategoryID', y='TotalRevenue', title='Lowest Total Sales Revenue by Product Category')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY TotalSales ASC
LIMIT 10
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Lowest Total Sales Revenue by Product Category')
show_to_user(fig)
```","The input Python code retrieves the bottom 10 product categories by total sales revenue, whereas the business request and reference code specify retrieving only the single category with the lowest revenue. The logic differs in the number of categories that are processed and displayed.","```python
import pandas as pd
import plotly.express as px

# Step 1: SQL Query
sql_query = """"""
SELECT c.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID
ORDER BY TotalSales ASC;
""""""

# Step 2: Execute the query
df = execute_sql_query(sql_query)

# Step 3: Create a bar chart
fig = px.bar(df, x='CategoryID', y='TotalSales', title='Product Categories with Lowest Total Sales Revenue')

# Step 4: Display the result
show_to_user(fig)
```","The input code does not limit the result to only the lowest product category but instead retrieves all categories sorted by sales. The reference code uses 'LIMIT 1' to return only the category with the lowest total sales, while the input code displays all categories.",None
Find the product categories with the highest average unit price.,"```python
import pandas as pd

# SQL query to find the product categories with the highest average unit price
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice
FROM products
GROUP BY CategoryID
ORDER BY AverageUnitPrice DESC;
""""""

# Execute the SQL query
product_categories_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(product_categories_df)
```","```python
sql_query = """"""
SELECT p.CategoryID, AVG(od.UnitPrice) AS AverageUnitPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY AverageUnitPrice DESC
""""""
average_unit_price_df = execute_sql_query(sql_query)
show_to_user(average_unit_price_df)
```","The input Python code incorrectly joins the 'products' table with 'Order Details' on 'ProductID', which deviates from the reference implementation's logic. The reference code calculates the average unit price directly from the 'products' table without considering order details. The input code might change the average by including data from orders rather than using only product pricing data.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT categories.CategoryID, 
       AVG(products.UnitPrice) AS AverageUnitPrice 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryID 
ORDER BY AverageUnitPrice DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The evaluated code correctly identifies the product categories with the highest average unit price. It performs an average calculation on the 'UnitPrice' field, groups by 'CategoryID', and sorts the result in descending order by average unit price. Although it joins the 'categories' table, it still adheres to the logic of the reference implementation by focusing on category IDs and average prices.",Finetuned
How many orders included products with a discount of more than 10%?,"```python
sql_query = """"""
SELECT COUNT(*) as order_count
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0.1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['order_count'][0])
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT o.OrderID) AS OrdersWithDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount > 0.10
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly follows the business analytics request to count the number of orders with a discount greater than 10%. It uses COUNT(DISTINCT o.OrderID) to ensure each order is counted only once, which aligns with the reference implementation logic that counts orders with such discounts. The core logic to join the 'orders' and 'Order Details' tables and apply the discount condition is correctly implemented.","```python
import pandas as pd

# Define the SQL Query
sql_query = """"""
SELECT COUNT(DISTINCT OrderID) AS NumberOfDiscountedOrders 
FROM [Order Details] 
WHERE Discount > 0.10;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
discounted_orders_df = execute_sql_query(sql_query)

# Print the result
print(discounted_orders_df)
```","The input code counts distinct orders from the 'Order Details' table alone, whereas the reference code joins 'orders' and 'Order Details' tables and counts orders with discounts over 10%. The two approaches could lead to different results if there are anomalies like missing order entries in the 'orders' table.",Base
What is the performance ranking of products based on sales quantity?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure that the DataFrame is sorted by TotalQuantity in descending order
df = df.sort_values(by='TotalQuantity', ascending=False)

# Display the result
show_to_user(df)
```","```python
# SQL query to get performance ranking of products based on sales quantity
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    TotalSales DESC
""""""

# Execute the SQL query to retrieve the data
product_sales_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(product_sales_df)
```","The input code is correct as it successfully ranks the products based on sales quantity. It uses a SQL query to join 'products' and 'Order Details' tables, groups by 'ProductID' and 'ProductName', sums the 'Quantity', and orders by 'TotalSales' in descending order. This logic matches the reference implementation. The sorting using SQL eliminates the need for additional sorting in pandas. Both implementations achieve the intended result.","```python
import pandas as pd

# SQL Query to retrieve performance ranking of products based on sales quantity
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalSales 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query and store the results in a DataFrame
df_sales_ranking = execute_sql_query(sql_query)

# Display the top 10 products by sales quantity
show_to_user(df_sales_ranking.head(10))
```","The input code does not include the 'ProductName' which is part of the performance ranking in the reference code. Without 'ProductName', the output does not match the context and requirement laid out in the reference implementation.",Base
List the orders grouped by required dates and their total freight costs.,"```python
import pandas as pd

# SQL query
sql_query = ""SELECT RequiredDate, SUM(Freight) AS TotalFreightCost FROM orders GROUP BY RequiredDate;""

# Execute query and retrieve dataframe
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","```python
sql_query = """"""
SELECT RequiredDate, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY RequiredDate
ORDER BY RequiredDate;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly answers the business analytics request by grouping the orders by 'RequiredDate' and calculating their total freight costs. It performs the same operations as the reference implementation, with an additional 'ORDER BY RequiredDate' clause, which does not affect correctness. Both implementations use a similar SQL query and fetch the result using 'execute_sql_query', followed by displaying with 'show_to_user'.","```python
import pandas as pd

# Define utility function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function will have the implementation to connect to the database,
    # execute the query, and return the results as a pandas DataFrame
    # Implement the actual database connection and execution logic here
    pass

# Define utility function to display data to the user
def show_to_user(data: pd.DataFrame):
    # This function should be implemented to display a pandas DataFrame
    # It could be printing to console or showing in a UI based on the environment
    # Implement display logic here
    print(data)  # Simple print for console

# SQL query to group orders by required date and calculate total freight cost
sql_query = """"""
SELECT RequiredDate, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY RequiredDate;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","The input code correctly implements the requested functionality by executing an SQL query that groups orders by RequiredDate and calculates the total freight cost, similar to the reference implementation. The logic and query are equivalent, achieving the same analytical outcome.",both
"Calculate the month-over-month growth rate of total sales for December 2023, including a line chart to illustrate trends over the months.","```python
import pandas as pd
import plotly.express as px

# SQL query to get relevant data
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') IN ('2023-11', '2023-12')
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query and store the result in a dataframe
sales_data = execute_sql_query(sql_query)

# Calculate Month-over-Month Growth Rate
sales_data['MoM_GrowthRate'] = sales_data['TotalSales'].pct_change()

# Extract December 2023 Growth Rate
december_growth_rate = sales_data[sales_data['OrderMonth'] == '2023-12']['MoM_GrowthRate'].values[0]

# Plotting the trend line chart for Total Sales
fig = px.line(
    sales_data,
    x='OrderMonth',
    y='TotalSales',
    title='Total Sales Trend (Nov - Dec 2023)',
    labels={'TotalSales': 'Total Sales ($)', 'OrderMonth': 'Month'}
)

# Display the plot
show_to_user(fig)

# Display the December Growth Rate
show_to_user(pd.DataFrame({'December 2023 MoM Growth Rate': [december_growth_rate]}))
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve monthly total sales data
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    month
ORDER BY 
    month
""""""
monthly_sales_df = execute_sql_query(sql_query)

# Step 2: Calculate Month-over-Month Growth Rate
monthly_sales_df['growth_rate'] = monthly_sales_df['total_sales'].pct_change() * 100

# Step 3: Filter for December 2023 and visualize
december_sales_df = monthly_sales_df[monthly_sales_df['month'] <= '2023-12']

fig = px.line(december_sales_df, x='month', y='growth_rate', title='Month-over-Month Sales Growth Rate',
              labels={'growth_rate': 'Growth Rate (%)'})
show_to_user(fig)
```","The input code calculates and plots the month-over-month growth rate for all months, not specifically for November and December 2023 as required. It does not isolate the MoM growth rate for December 2023 specifically, and it incorrectly plots the growth rate instead of total sales. The reference code calculates the MoM growth rate, isolates it for December 2023, and plots total sales.","To fulfill the request, we will utilize the existing MDDX data warehouse to calculate the month-over-month growth rate of total sales for December 2023. Additionally, we'll visualize the trends over the months with a line chart.

Below is a Python code snippet that accomplishes these tasks:

```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate SQL query execution.
    pass  # Replace with actual implementation.

def show_to_user(data):
    # Placeholder function to simulate displaying data.
    pass  # Replace with actual implementation.

def sales_growth_and_trend():
    # SQL query to fetch monthly sales data for 2023
    sql_query = """"""
    SELECT MONTH(orders.OrderDate) AS month, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * 
               (1 - [Order Details].Discount)) AS total_sales 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
    GROUP BY MONTH(orders.OrderDate)
    """"""
    
    # Execute SQL query and get the results in a Pandas DataFrame
    sales_data = execute_sql_query(sql_query)
    
    # Calculate the month-over-month growth rate
    sales_data['previous_month_sales'] = sales_data['total_sales'].shift(1)
    sales_data['month_over_month_growth'] = (
        (sales_data['total_sales'] - sales_data['previous_month_sales']) /
        sales_data['previous_month_sales']
    ) * 100

    # Visualize the sales trend and growth rate
    fig = px.line(
        sales_data, 
        x='month', 
        y='total_sales', 
        title='Monthly Sales Trend for 2023',
        labels={'total_sales': 'Total Sales', 'month': 'Month'},
        markers=True
    )
    
    # Optionally add growth rate as a secondary line
    fig.add_scatter(
        x=sales_data['month'],
        y=sales_data['month_over_month_growth'],
        mode='lines+markers',
        name='MoM Growth Rate (%)',
        yaxis='y2'
    )
    
    # Adjust layout to accommodate dual y-axes
    fig.update_layout(
        yaxis2=dict(
            title='Growth Rate (%)',
            overlaying='y',
            side='right'
        ),
        xaxis_title='Month',
        yaxis_title='Total Sales'
    )
    
    # Display the graph
    show_to_user(fig)

# Call the function to execute
sales_growth_and_trend()
```

### Explanation of the Code:

1. **SQL Execution**: We use an `execute_sql_query` function to obtain monthly sales data for 2023.

2. **Growth Rate Calculation**: We calculate the month-over-month growth rate using the difference between current and previous month sales, normalized by previous month sales.

3. **Visualization with Plotly**:
   - The sales data is plotted over months.
   - A secondary y-axis is added to represent the month-over-month growth rate.
   - The `show_to_user` function is used to display the visualization.

### Assumptions:
- `execute_sql_query` and `show_to_user` are predefined as per the environment's requirements.
- The SQL query structure and database connectivity are correctly implemented since they would need a proper database environment to function. 
- The code assumes proper handling of missing data where no previous month exists (for January).","The input Python code does not correctly address the business analytics request due to differences in SQL logic and growth calculation specifics. The reference code calculates the month-over-month growth specifically for November and December of 2023, while the input code covers monthly sales data for the entire year and incorrectly calculates percentage growth rather than using `pct_change()`. Additionally, the reference code displays the growth rate specifically for December 2023, which the input does not accommodate. The visualization and growth calculation do not align with the reference implementation.",None
"How does the average unit price of products vary across categories, using a bar chart to visualize differences?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.CategoryID, AVG(products.UnitPrice) AS AverageUnitPrice
FROM products
GROUP BY products.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title=""Average Unit Price Across Categories"")

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_price_df = execute_sql_query(sql_query)

fig = px.bar(average_price_df, x='CategoryID', y='AverageUnitPrice',
             title='Average Unit Price of Products by Category',
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})
show_to_user(fig)
```",The given code correctly calculates the average unit price of products by category and visualizes it using a bar chart. The SQL query is identical in logic to the reference implementation. The differences in variable naming and chart labeling do not affect correctness. Both implementations use Plotly Express to create a bar chart and present the results in a similar manner.,"```python
import pandas as pd
import plotly.express as px

# Function stubs for the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to interface with the database
    return pd.DataFrame()  # Placeholder for actual implementation

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get average unit price by category
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AvgUnitPrice
FROM products
GROUP BY CategoryID
""""""

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='AvgUnitPrice',
             title='Average Unit Price per Category',
             labels={'AvgUnitPrice': 'Average Unit Price', 'CategoryID': 'Category ID'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly follows the business analytics request and the logic of the reference code. The SQL query computes the average unit price grouped by 'CategoryID', which is the same operation in both codes. The bar chart is created with category IDs on the x-axis and average unit prices on the y-axis, similar to the reference. The axis labels differ slightly, but the visualization purpose and data representation are aligned with the reference implementation.",both
What is the most common shipping city for the current year?,"```python
import pandas as pd

# SQL query to retrieve the most common shipping city for the current year
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

current_year = pd.to_datetime(""today"").year
sql_query = f""""""
SELECT ShipCity, COUNT(*) as OrderCount
FROM orders
WHERE YEAR(OrderDate) = {current_year}
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1;
""""""

most_common_city = execute_sql_query(sql_query)
show_to_user(most_common_city)
```","The input code correctly determines the most common shipping city for the current year, similar to the reference implementation. Both implementations construct an SQL query to count orders per city for the current year, order by the count, and limit the result to the top city. The current year is fetched similarly using pandas and the CURDATE function. Results are fetched with `execute_sql_query` and displayed with `show_to_user`, maintaining functional parity with the reference.","```python
import pandas as pd

# SQL query to find the most common shipping city for the current year
sql_query = """"""
SELECT ShipCity, COUNT(*) as Count 
FROM orders 
WHERE EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
GROUP BY ShipCity 
ORDER BY Count DESC 
LIMIT 1;
""""""

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the most common shipping city
show_to_user(result_df)
```","The input code correctly follows the same logic as the reference implementation. Both use SQL queries to select the most common shipping city for orders made in the current year by comparing the year of 'OrderDate' with the current year, and both group results by 'ShipCity' and order by count in descending order, limiting the output to the top result. The difference in functions used (YEAR vs EXTRACT) is syntactical and does not affect the logic or correctness of the query.",both
How many products have a reorder level of zero?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS ZeroReorderProducts FROM products WHERE ReorderLevel = 0""

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['ZeroReorderProducts'].iloc[0])
```","```python
sql_query = ""SELECT COUNT(*) AS ProductCount FROM products WHERE ReorderLevel = 0""
result = execute_sql_query(sql_query)
show_to_user(result)
```",The input code attempts to display the entire result object 'result' instead of extracting and displaying the count value like the reference code. The reference code correctly extracts and displays the count using 'result_df['ZeroReorderProducts'].iloc[0]'.,"```python
import pandas as pd

# SQL query to count products with a reorder level of zero
sql_query = ""SELECT COUNT(*) AS ProductCount FROM products WHERE ReorderLevel = 0;""

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Show the resulting DataFrame to the user
show_to_user(result_df)
```","The input code and the reference implementation both perform the same operation: counting products with a reorder level of zero using the SQL query. Both store the result in a DataFrame and use an equivalent method to display the result. Although the reference code directly extracts the count from the DataFrame, while the input code shows the entire DataFrame, the logic and functionality are identical in terms of obtaining the count.",Finetuned
"What is the total revenue generated by each product, visualized with a bar chart for comparison?","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', 
             title='Total Revenue Generated by Each Product', 
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly calculates the total revenue for each product using SQL and visualizes it with a bar chart. The difference in the code is that it uses 'ProductName' instead of 'ProductID'. However, this change in grouping attribute doesn't alter the correctness regarding the business request, as both depict the total revenue by product. The visualization and data processing logic remain consistent with the provided task requirements.","```python
import pandas as pd
import plotly.express as px

def execute_business_query(sql_query: str) -> pd.DataFrame:
    # Mock function to return a DataFrame based on the SQL query
    # Replace with actual database connection and execution code
    data = {
        'ProductID': [1, 2, 3],
        'TotalRevenue': [1500.0, 2000.0, 2500.0]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock function to display data
    data.show()

# SQL query to execute
sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM order_details od
GROUP BY od.ProductID
""""""

# Execute SQL query and get results as a DataFrame
df = execute_business_query(sql_query)

# Create a bar chart for total revenue by product
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product')

# Show the plot
show_to_user(fig)
```","The input code does not match the logic of the reference implementation. The SQL query calculates TotalRevenue using SUM(od.Quantity * od.UnitPrice), but it omits the discount calculation (1 - od.Discount) as seen in the reference code. This discrepancy leads to incorrect total revenue calculations per product.",Base
"Find the total quantity sold for each product, excluding discontinued products.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalQuantitySold 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE products.Discontinued = 0 
GROUP BY products.ProductID, products.ProductName;
""""""

# Execute SQL query and retrieve data into a pandas dataframe
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductID, p.ProductName
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code implementation is functionally equivalent to the reference implementation. Both codes execute a SQL query that joins 'products' and 'Order Details' tables, selects the necessary fields, filters out discontinued products, and groups results by ProductID and ProductName. Despite differences in alias naming and spacing, the logic remains consistent with the business request.","```python
# Define the SQL query as per specifications
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE p.Discontinued = 0 
GROUP BY p.ProductName;
""""""

# Use the utility function to execute the query and retrieve results
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating database execution
    # Replace with actual implementation
    return pd.DataFrame({
        'ProductName': ['Product A', 'Product B'],
        'TotalQuantitySold': [150, 200]
    })

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
def display_to_user(df: pd.DataFrame):
    # Simulating display
    print(df)

# Display the result to the user
display_to_user(df)
```","The evaluated code does not include 'ProductID' in the SELECT and GROUP BY clauses as in the reference implementation, potentially causing inaccurate results if multiple products share the same name. The reference includes both 'ProductID' and 'ProductName' to ensure distinct grouping and accurate summation.",Base
Determine the average discount applied across all products.,"```python
import pandas as pd

# SQL query to determine the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average discount value from the dataframe
average_discount = result_df['AverageDiscount'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'Average Discount': [average_discount]}))
```","```python
sql_query = """"""
    SELECT AVG(Discount) AS AverageDiscount
    FROM [Order Details]
""""""
average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code correctly executes the SQL query to calculate the average discount from the 'Order Details' table. It then uses `show_to_user` to display the resulting DataFrame. Although it does not explicitly extract the value from the DataFrame as done in the reference code, the logic to acquire and display the average discount is effectively the same.","
import pandas as pd

# Function to execute the SQL query and return the result
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing SQL query
    # This should connect to the database and execute the query
    # Return a pandas DataFrame
    # Here, it's assumed to return a DataFrame for demonstration purposes
    pass

# Function to display results to the user
def show_to_user(data: pd.DataFrame):
    # Placeholder for displaying data analysis results
    # Assuming it handles displaying the DataFrame appropriately
    pass

# SQL query to find the average discount
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM OrderDetails;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
","The input code is mostly correct but has a minor discrepancy in the SQL query from the reference implementation. The table name in the input code is 'OrderDetails', whereas the reference implementation uses '[Order Details]'. This difference may lead to an incorrect execution if the table name is not properly matched. Otherwise, the logic and structure of the code are consistent with the reference.",Base
"How many orders were placed each month in the last year, using a bar chart to show trends over time?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(orders_df, x='Month', y='OrderCount', title='Number of Orders Placed Each Month in the Last Year')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last year
end_date = datetime.now()
start_date = end_date - timedelta(days=365)

sql_query = f""""""
SELECT 
    DATE_TRUNC('month', OrderDate) AS OrderMonth, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
WHERE 
    OrderDate >= '{start_date.strftime(""%Y-%m-%d"")}' 
GROUP BY 
    OrderMonth 
ORDER BY 
    OrderMonth;
""""""

orders_per_month = execute_sql_query(sql_query)

fig = px.bar(orders_per_month, x='OrderMonth', y='OrderCount', 
             title='Monthly Orders in the Last Year', 
             labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","Both implementations correctly calculate the monthly order counts for the last year and display a bar chart. The main differences lie in their use of SQL: the reference implementation uses DATE_FORMAT and assumes the current date function CURDATE(), while the input code explicitly calculates date bounds and uses DATE_TRUNC. Both satisfy the business request without logical errors.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function to simulate SQL query execution
    # In practice, connect to a database and execute the query
    # Return the result as a pandas DataFrame
    pass

def show_to_user(data):
    # Mock function to simulate displaying data
    # In practice, ensure the function correctly outputs a DataFrame or Plotly figure
    pass

sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM OrderDate) AS year, 
    EXTRACT(MONTH FROM OrderDate) AS month, 
    COUNT(OrderID) AS number_of_orders 
FROM 
    orders 
WHERE 
    OrderDate BETWEEN DATE_TRUNC('YEAR', CURRENT_DATE) - INTERVAL '1 year' AND CURRENT_DATE 
GROUP BY 
    year, month 
ORDER BY 
    year, month;
""""""

# Execute the SQL query and fetch the data
orders_df = execute_sql_query(sql_query)

# Convert year and month into a datetime object for easier plotting
orders_df['date'] = pd.to_datetime(orders_df['year'].astype(str) + '-' + orders_df['month'].astype(str) + '-01')

# Create the bar chart using Plotly
fig = px.bar(orders_df, x='date', y='number_of_orders', title='Monthly Orders Overview', labels={'number_of_orders': 'Number of Orders', 'date': 'Date'})

# Show the plot to the user
show_to_user(fig)
```","The input code correctly answers the business request by counting the number of orders each month for the past year and plotting the results in a bar chart. The SQL query uses EXTRACT to get year and month, groups by these, and orders them accordingly, similar to the reference code. The transformation of 'year' and 'month' into a 'date' column for easier plotting is a valid approach and does not change the logic significantly. The use of Plotly for visualization, with appropriate labeling and display, matches the intent of the reference implementation.",both
"List the count of products in each category, supplied by supplier.","```python
import pandas as pd

# SQL query to get the count of products in each category, supplied by supplier
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID, s.CompanyName, p.CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY s.CompanyName, p.CategoryID
ORDER BY s.CompanyName, p.CategoryID;
""""""

data = execute_sql_query(sql_query)
show_to_user(data)
```","The input code does not include 'SupplierID' in the SELECT and GROUP BY clauses, while the reference implementation includes it. This could lead to different groupings, which might not be acceptable if 'SupplierID' is required in business analytics.","
import pandas as pd

# Sample execute_sql_query function for demonstration purposes
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assuming the function executes an SQL query and returns a DataFrame
    # Replace this with actual database connection and query execution code
    data = {
        'CategoryID': [1, 1, 2, 2],
        'SupplierID': [101, 102, 201, 202],
        'product_count': [5, 7, 3, 4]
    }
    return pd.DataFrame(data)

# Sample show_to_user function for demonstration purposes
def show_to_user(data):
    # Display the data (assumed to be a DataFrame)
    print(data)

# SQL query
sql_query = """"""
SELECT categories.CategoryID, suppliers.SupplierID, COUNT(products.ProductID) AS product_count
FROM products
JOIN categories ON products.CategoryID = categories.CategoryID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
GROUP BY categories.CategoryID, suppliers.SupplierID;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
","The input code performs the GROUP BY operation correctly to calculate the product count by category and supplier. However, it differs from the reference implementation in the columns returned and their order. The reference code lists 'SupplierID', 'CompanyName', 'CategoryID', and 'ProductCount', whereas the input code lists 'CategoryID', 'SupplierID', and 'product_count'. The 'CompanyName' is missing, so the input code does not fully replicate the logic of the reference implementation.",None
What is the average order fulfillment time for March 2023?,"```python
import pandas as pd

# Define SQL Query to get order dates and shipped dates
sql_query = """"""
SELECT o.ShippedDate, o.OrderDate
FROM orders o
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-03-31';
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Calculate the average fulfillment time
df['ShippedDate'] = pd.to_datetime(df['ShippedDate'])
df['OrderDate'] = pd.to_datetime(df['OrderDate'])
df['FulfillmentTime'] = (df['ShippedDate'] - df['OrderDate']).dt.days
average_fulfillment_time = df['FulfillmentTime'].mean()

# Display result
show_to_user(pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= '2023-03-01' AND OrderDate < '2023-04-01'
""""""
average_fulfillment_time_df = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time_df)
```","The input code correctly computes the average order fulfillment time for March 2023 using SQL. It selects orders from March 1 to March 31 and calculates the average of the date difference between 'ShippedDate' and 'OrderDate'. The logic matches the reference implementation, which computes the same difference using pandas after filtering for March orders.","```python
import pandas as pd

# Given SQL query to calculate the average order fulfillment time
sql_query = """"""
SELECT AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE MONTH(orders.OrderDate) = 3 AND YEAR(orders.OrderDate) = 2023;
""""""

# Execute the query using the provided utility function to get the result in a DataFrame
df_result = execute_sql_query(sql_query)

# Assuming the required output needs to show the average fulfillment time
# Display the average fulfillment time to the user
show_to_user(df_result)
```","Both implementations calculate the average order fulfillment time for March 2023, albeit through different methods. The reference code fetches data and computes the difference between ShippedDate and OrderDate in days, and then calculates the average. The input code uses SQL's DATEDIFF function to directly compute and average the differences between the two dates for the specified month and year, which is efficient and correct. Both approaches address the business request correctly.",both
"Identify the top 3 suppliers based on the total sales value of their products, using a bar chart for visualization.","```python
import plotly.express as px

# SQL query to get the top 3 suppliers by total sales value
sql_query = """"""
SELECT SupplierID, SUM([Order Details].UnitPrice * Quantity) AS TotalSalesValue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY SupplierID 
ORDER BY TotalSalesValue DESC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(df, x='SupplierID', y='TotalSalesValue', title='Top 3 Suppliers by Total Sales Value')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalSales DESC
LIMIT 3;
""""""

top_suppliers_df = execute_sql_query(sql_query)

fig = px.bar(top_suppliers_df, x='SupplierID', y='TotalSales', title='Top 3 Suppliers by Total Sales Value')
show_to_user(fig)
```","The input code correctly executes a SQL query to calculate the total sales for each supplier, sorting by descending order and limiting to the top 3 suppliers, just like the reference code. Both the reference and input code use a similar logic of aggregating sales by multiplying quantity and unit price and then grouping by SupplierID. The code then visualizes the results using a bar chart generated by Plotly Express, which matches the business analytics request and the reference implementation's intention.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales value per supplier
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID
ORDER BY TotalSales DESC
LIMIT 3;
""""""

# Execute the SQL query and get the results as a DataFrame
df_top_suppliers = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 3 suppliers by total sales
fig = px.bar(
    df_top_suppliers,
    x='SupplierID',
    y='TotalSales',
    title='Top 3 Suppliers by Total Sales Value',
    labels={'TotalSales': 'Total Sales', 'SupplierID': 'Supplier ID'}
)

# Display the bar chart
show_to_user(fig)
```","The input Python code achieves the same result as the reference code. Both implementations execute a SQL query to calculate the total sales value per supplier and then order by total sales value to select the top 3 suppliers. The differences in table aliasing ('od' instead of '[Order Details]') and summing expressions are semantically equivalent. The visualization part also matches, creating a bar chart with Plotly using the 'SupplierID' and corresponding sales value, with an appropriate title. Thus, the logic and final output remain consistent with the requirement.",both
List all products that need reordering.,"```python
import pandas as pd

# SQL Query to find products that need reordering
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the query
df = execute_sql_query(sql_query)

# Display the filtered result to the user; ensure only the 'ProductName' column is shown
show_to_user(df['ProductName'])
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0
""""""

products_needing_reorder = execute_sql_query(sql_query)
show_to_user(products_needing_reorder)
```","The input code adds an extra condition 'Discontinued = 0' which is not present in the reference implementation. This means the input code excludes discontinued products, while the reference does not. Also, the input code displays all columns instead of only 'ProductName'.","```python
# Utility function to execute SQL queries and fetch results
def execute_sql_query(sql_query: str):
    # Mock implementation for executing SQL query
    # Returns a list of tuples with sample data for demonstration
    return [('Product1',), ('Product2',), ('Product3',)]

# Utility function to display data
def show_to_user(data):
    # Mock implementation for displaying data
    for item in data:
        print(item)

# SQL query to list all products needing reordering
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE UnitsInStock < ReorderLevel;
""""""

# Execute the SQL query and get the result
products_to_reorder = execute_sql_query(sql_query)

# Display the products that need reordering
show_to_user(products_to_reorder)
```","The input code's SQL query uses 'UnitsInStock < ReorderLevel', whereas the reference implementation uses 'UnitsInStock <= ReorderLevel'. The logic differs, affecting which products are selected based on whether 'UnitsInStock' equaling 'ReorderLevel' should trigger reordering.",None
"What is the average order fulfillment time by month for 2023, visualized with a line chart to show changes over time?","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY month
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'month' column to datetime
df['month'] = pd.to_datetime(df['month'])

# Create a line chart
fig = px.line(df, x='month', y='avg_fulfillment_time', title='Average Order Fulfillment Time by Month for 2023')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY month
ORDER BY month
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time by Month (2023)', 
              labels={'avg_fulfillment_time': 'Average Fulfillment Time (days)', 'month': 'Month'})
show_to_user(fig)
```","The input code correctly answers the business analytics request. The main logic in both implementations is to compute the average order fulfillment time by month for the year 2023 and visualize it in a line chart. Both codes execute a SQL query to perform this calculation, with the input code using a slightly different date filtering condition (YEAR(OrderDate) = 2023 vs. BETWEEN '2023-01-01' AND '2023-12-31'), which is functionally equivalent. The visualization also adheres to the requirements, and appropriate labels are used in the input code.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve average order fulfillment time by month for 2023
sql_query = """"""
SELECT 
    MONTH(OrderDate) AS Month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = 2023 
GROUP BY 
    MONTH(OrderDate)
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a line chart to visualize the average order fulfillment time by month
fig = px.line(
    df, 
    x='Month', 
    y='AvgFulfillmentTime', 
    title='Average Order Fulfillment Time by Month in 2023',
    labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'Month': 'Month'},
    markers=True
)

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly calculates the average order fulfillment time by month for 2023. It fetches the data using a SQL query that matches the logic of the reference implementation, focusing specifically on the year 2023 and grouping by month. The visualization part also aligns by creating a line chart with Plotly to display the changes over time. Although the labels and method to convert month are slightly different, the core logic and output intention are the same, fulfilling the business analytics request.",both
Which products have less than 10 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query and retrieve the data
products_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(products_df)
```","```python
sql_query = ""SELECT ProductID, ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly retrieves products with less than 10 units in stock, aligning with the business request. Although it includes 'ProductID' in the SQL query, this does not invalidate the logic. It still fetches the necessary 'ProductName' and 'UnitsInStock' fields required by the task. Therefore, it adheres to the same logic as the reference implementation.","```python
# Predefined function to execute the SQL query and display the results
def execute_sql_query(sql_query: str):
    # Simulated execution of an SQL query
    print(f""Executing SQL query: {sql_query}"")
    # Simulated result for demonstration purposes
    results = [
        {""ProductID"": 1, ""ProductName"": ""Product A"", ""UnitsInStock"": 5},
        {""ProductID"": 2, ""ProductName"": ""Product B"", ""UnitsInStock"": 8}
    ]
    print(""Query executed successfully. Displaying results:"")
    for row in results:
        print(row)

# SQL query to find products with less than 10 units in stock
sql_query = ""SELECT ProductID, ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query using the predefined function
execute_sql_query(sql_query)
```","The input code includes 'ProductID' in the SQL query, which is not required based on the reference implementation. The reference query specifically selects only 'ProductName' and 'UnitsInStock'. Therefore, the input code does not adhere to the same logic as the reference implementation.",Base
Which employee processed the most orders?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY TotalOrders DESC 
LIMIT 1;
""""""

# Execute SQL query
order_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(order_data)
```","```python
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
""""""
most_orders_employee = execute_sql_query(sql_query)
show_to_user(most_orders_employee)
```","The input code correctly implements the SQL query to find the employee who processed the most orders. It counts the number of orders grouped by EmployeeID, orders the result in descending order by the count, and limits the output to one record, which matches the logic in the reference code.","```python
import pandas as pd

# SQL query to get the employee who processed the most orders
sql_query = """"""
SELECT employees.EmployeeID, 
       COUNT(orders.OrderID) AS OrderCount 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Assuming execute_sql_query is a provided utility function that returns a pandas DataFrame
top_employee_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(top_employee_df)
```","The input Python code correctly implements the business request to find the employee who processed the most orders. It uses a SQL query to count orders per employee, orders by the count in descending order, and limits the result to one employee, similar to the reference implementation. Both queries ultimately achieve the same outcome.",both
Identify the customer with the most late shipments.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) AS LateOrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.RequiredDate < o.ShippedDate 
GROUP BY c.CustomerID 
ORDER BY LateOrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS LateShipments
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY c.CustomerID, c.CompanyName
ORDER BY LateShipments DESC
LIMIT 1
""""""

late_shipments_df = execute_sql_query(sql_query)
show_to_user(late_shipments_df)
```","The logic of the input Python code matches that of the reference implementation. Both codes calculate the number of late shipments for each customer by comparing the 'ShippedDate' to the 'RequiredDate'. They then identify the customer with the most late shipments using an ORDER BY clause followed by a LIMIT 1 clause. The input code additionally selects 'CompanyName', which does not affect the correctness in terms of identifying the customer with the most late shipments.","```python
import pandas as pd

# SQL query to find the customer with the most late shipments
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS LateShipments
FROM orders
JOIN customers ON orders.CustomerID = customers.CustomerID
WHERE orders.RequiredDate < orders.ShippedDate
GROUP BY customers.CustomerID
ORDER BY LateShipments DESC
LIMIT 1;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Display the customer with the most late shipments
show_to_user(result_df)
```","The input Python code correctly follows the logic of the reference implementation. Both versions select the 'CustomerID' and count the 'OrderID' for orders where the 'RequiredDate' is earlier than the 'ShippedDate'. They both group by 'CustomerID', order the results by the count of late shipments in descending order, and limit the result to 1, identifying the customer with the most late shipments. The column names and table order in the SQL query differ, but this does not affect the logic or the final result.",both
Find the orders placed in the last 30 days and their total freight cost.,"```python
import pandas as pd

# SQL query to find orders in the last 30 days
sql_query = """"""
SELECT o.OrderID, o.OrderDate, o.ShippedDate, o.Freight 
FROM orders o 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 30 DAY);
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate the total freight cost
total_freight_cost = orders_df['Freight'].sum()

# Prepare the result dataframe
result_df = pd.DataFrame({
    'Total Freight Cost': [total_freight_cost]
})

# Show the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta

# Calculate the date 30 days ago from today
date_30_days_ago = datetime.now() - timedelta(days=30)
date_30_days_ago_str = date_30_days_ago.strftime('%Y-%m-%d')

# SQL query to find orders placed in the last 30 days and their total freight cost
sql_query = f""""""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE OrderDate >= '{date_30_days_ago_str}'
""""""

# Execute the query and get the data
freight_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(freight_data)
```","The input code correctly retrieves orders from the last 30 days and calculates the total freight cost using an SQL query. It compares the OrderDate against the date 30 days ago, similar to the reference code's logic. Both codes use SQL to filter the relevant records and aggregate the Freight values, achieving the same business goal.","```python
import pandas as pd
from datetime import datetime, timedelta

def execute_sql_query(sql_query: str):
    # Simulating a function that executes an SQL query and returns a DataFrame
    # Replace with actual database connection and query execution logic
    pass

def show_to_user(data):
    # Simulating a function that displays the DataFrame or result
    pass

# Define the current date
current_date = datetime.now()

# Define the date range for the last 30 days
start_date = current_date - timedelta(days=30)
end_date = current_date

# SQL query to find orders placed in the last 30 days
sql_query = f""""""
SELECT OrderID, OrderDate, Freight 
FROM orders 
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}'
AND '{end_date.strftime('%Y-%m-%d')}';
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Calculate the total freight cost for those orders
total_freight_cost = df_orders['Freight'].sum()

# Create a DataFrame to display the result
result_df = pd.DataFrame({
    'Total Freight Cost': [total_freight_cost]
})

# Show the result to the user
show_to_user(result_df)
```","Both the reference code and the evaluated code aim to retrieve orders from the last 30 days and calculate the total freight cost. The reference code uses `DATE_SUB(CURDATE(), INTERVAL 30 DAY)` in its SQL query for filtering, while the evaluated code computes the date range using Python's `datetime` and `timedelta`, resulting in a similar date range. Both approaches correctly calculate the total freight cost from the retrieved DataFrame. Hence, the implementation logic is aligned with the reference.",both
Determine the number of discontinued products.,"```python
import pandas as pd

# SQL Query to determine the number of discontinued products
sql_query = ""SELECT COUNT(*) AS DiscontinuedProducts FROM products WHERE Discontinued = 1;""

# Execute the query using the provided utility function
result_df = execute_sql_query(sql_query)

# Extract the count value from the dataframe
discontinued_count = result_df.iloc[0]['DiscontinuedProducts']

# Display the result to the user
show_to_user(discontinued_count)
```","```python
sql_query = ""SELECT COUNT(*) AS DiscontinuedProducts FROM products WHERE Discontinued = 1""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code executes a query correctly, but it does not extract the count from the result dataframe correctly. It tries to display the entire result object instead of extracting and displaying the count value, which is done in the reference implementation using result_df.iloc[0]['DiscontinuedProducts'].","```python
def execute_sql_query(sql_query: str):
    # Simulated execution of the SQL query
    # In practice, this will communicate with a database to execute the provided SQL
    # and return the resulting data.
    return {'discontinued_products': 42}  # Dummy response for demonstration

    
def display_to_user(data):
    # Simulated display of data to the user
    # This function will present the data in an appropriate format.
    print(data)


# SQL query to fetch the count of discontinued products
sql_query = ""SELECT COUNT(*) AS DiscontinuedCount FROM products WHERE Discontinued = 1;""

# Execute the query and retrieve the result
result = execute_sql_query(sql_query)

# Extract the count of discontinued products
discontinued_count = result['discontinued_products']

# Display the result to the user
display_to_user({'DiscontinuedCount': discontinued_count})
```","The input code differs from the reference implementation because it returns a dictionary with a key 'discontinued_products' instead of a DataFrame. The reference implementation expects a DataFrame from the SQL execution, uses 'DiscontinuedProducts' as the key, and displays an integer. The input code returns and displays a dictionary with 'DiscontinuedCount' as the key, which doesn't match the expected format.",None
What is the average shipping cost per order per month? Include a visualization to show trends over time.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is sorted correctly
df['Month'] = pd.to_datetime(df['Month'])

# Sort the dataframe by the 'Month' column
df = df.sort_values('Month')

# Create a line plot for average shipping cost per month
fig = px.line(df, x='Month', y='AvgShippingCost', title='Average Shipping Cost per Order per Month')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS month,
    AVG(Freight) AS avg_shipping_cost
FROM 
    orders
GROUP BY 
    month
ORDER BY 
    month;
""""""

shipping_costs_df = execute_sql_query(sql_query)

fig = px.line(shipping_costs_df, x='month', y='avg_shipping_cost', title='Average Shipping Cost per Order per Month', labels={'avg_shipping_cost': 'Average Shipping Cost', 'month': 'Month'})
show_to_user(fig)
```","The provided code correctly implements the requested analysis. Both the input and reference code calculate the average shipping cost per order per month using an SQL query. The input code uses DATE_TRUNC to extract the month, which is equivalent to the DATE_FORMAT function used in the reference code. Additionally, the input code includes sorting by month in the SQL query, whereas the reference code sorts the DataFrame after executing the query. This difference in implementation does not impact the correctness of the result. Both codes use Plotly Express to create a line plot to visualize the trend over time, fulfilling the business request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to extract the average shipping cost per order per month
sql_query = """"""
SELECT DATE_TRUNC('month', orders.OrderDate) AS Month, 
       AVG(orders.Freight / COUNT(orders.OrderID)) AS AvgShippingCostPerOrder 
FROM orders 
GROUP BY Month;
""""""

# Use the run_sql_query function to execute the SQL and get the result as a DataFrame
df = run_sql_query(sql_query)

# Ensure the 'Month' column is of datetime type for plotting
df['Month'] = pd.to_datetime(df['Month'])

# Use Plotly to create a line chart showing the trend of average shipping cost per order over time
fig = px.line(df, x='Month', y='AvgShippingCostPerOrder', title='Average Shipping Cost Per Order Per Month')

# Display the resulting visualization to the user
show_to_user(fig)
```","The provided implementation incorrectly divides the Freight by the COUNT of OrderID in the AVG function, which doesn't align with the logic of the reference code. The reference implementation calculates the average Freight directly per month, not per order within each month. The syntax of DATE_TRUNC is also not compatible with the initial code, which uses DATE_FORMAT for MySQL. These differences suggest the input code does not produce the same result as the reference implementation.",Base
Find out how many orders each employee managed in a specific date range. Visualize the employee performance comparison.,"```python
import plotly.express as px

# Define the date range
start_date = '2023-01-01'
end_date = '2023-12-31'

# Create the SQL query
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Employee Order Management Performance')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

start_date = '2023-01-01'
end_date = '2023-12-31'

sql_query = f""""""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS TotalOrders
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY e.EmployeeID
ORDER BY TotalOrders DESC
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='EmployeeName', y='TotalOrders', 
             title='Number of Orders Managed by Each Employee',
             labels={'TotalOrders': 'Total Orders', 'EmployeeName': 'Employee Name'})
show_to_user(fig)
```","The input code uses a LEFT JOIN between employees and orders, unlike the INNER JOIN in the reference code. This means it includes employees with zero orders, whereas the reference only includes those who managed orders within the date range. Additionally, the input code orders the results by TotalOrders, which is not part of the original logic. These differences affect the business logic, making the input code incorrect relative to the provided reference.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31' 
GROUP BY EmployeeID;
""""""

# Execute the SQL query and get the result as a DataFrame
def execute_sql_query(sql_query: str):
    # This function needs to be defined to execute the SQL and get a DataFrame
    # A placeholder for demonstration (assuming you already have your implementation)
    # return pd.read_sql(sql_query, connection)
    pass

# Function to display output
def show_to_user(data):
    # This function should handle displaying DataFrames and Plotly figures
    # Placeholder function implementation
    pass

# Fetch the data
data_df = execute_sql_query(sql_query)

# Create a bar chart to visualize employee performance
fig = px.bar(data_df, x='EmployeeID', y='NumberOfOrders', 
             title='Employee Order Management Comparison',
             labels={'NumberOfOrders': 'Number of Orders'}

)

# Show the visualization
show_to_user(fig)
```","The input Python code's SQL query has an incorrect date range ('2023-01-01' to '2023-01-31'), which is different from the specified date range in the reference code ('2023-01-01' to '2023-12-31'). This results in a possible mismatch in the orders count per employee.",None
Which products have been discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query to get the discontinued products
discontinued_products_df = execute_sql_query(sql_query)

# Use the utility function to display the data to the user
show_to_user(discontinued_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE Discontinued = 1
""""""

discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input code correctly answers the question by retrieving products that have been discontinued using a similar logic as the reference implementation. While the input retrieves both 'ProductID' and 'ProductName', this additional data does not conflict with the business request to identify discontinued products.","```python
# Utility function to execute the SQL query and fetch the results
def execute_sql_query(sql_query: str):
    # Simulated database connection and execution (placeholder)
    # In practice, this would interact with an actual database
    # For this demonstration, we'll simulate some results
    class MockCursor:
        def fetchall(self):
            return [
                {""ProductName"": ""Old Chair"", ""DiscontinuedDate"": ""2022-01-15""},
                {""ProductName"": ""Vintage Clock"", ""DiscontinuedDate"": ""2023-03-20""},
            ]
    
    class MockConnection:
        def cursor(self):
            return MockCursor()
        
        def close(self):
            pass
            
    # Simulating execution and fetching results
    connection = MockConnection()
    cursor = connection.cursor()
    results = cursor.fetchall()
    connection.close()
    return results

# Given SQL query to find discontinued products
sql_query = '''
SELECT ProductName, DiscontinuedDate FROM products WHERE Discontinued = 1;
'''

# Execute the query and get the results
discontinued_products = execute_sql_query(sql_query)

# Display the results
for product in discontinued_products:
    print(f""Product Name: {product['ProductName']}, Discontinued Date: {product['DiscontinuedDate']}"")
```","The input code correctly retrieves products that have been discontinued by executing a SQL query. It simulates a database call and fetches product names where the 'Discontinued' attribute equals 1. Although the input code includes a 'DiscontinuedDate', it does not affect the primary task of identifying discontinued products. The logic matches the reference implementation, which also retrieves product names from discontinued items.",both
What is the monthly inventory turnover ratio? Use a visualization to highlight changes over time.,"```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATEPART(month, OrderDate) AS Month, 
       SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY DATEPART(month, OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure Month is treated as categorical for correct plotting
df['Month'] = df['Month'].astype(str)

# Sort the dataframe by Month to ensure correct plotting
df = df.sort_values(by='Month')

# Visualize the data
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS month,
    SUM(od.Quantity * od.UnitPrice) AS cost_of_goods_sold,
    AVG(p.UnitsInStock) AS average_inventory,
    (SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)) AS inventory_turnover_ratio
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    month
ORDER BY 
    month;
""""""

inventory_turnover_data = execute_sql_query(sql_query)

fig = px.line(inventory_turnover_data, x='month', y='inventory_turnover_ratio', title='Monthly Inventory Turnover Ratio', labels={'inventory_turnover_ratio':'Inventory Turnover Ratio', 'month':'Month'})
show_to_user(fig)
```","The provided code uses 'DATE_FORMAT(o.OrderDate, '%Y-%m')' to format the date, which aggregates by year and month, whereas the reference implementation uses 'DATEPART(month, OrderDate)' aggregating only by month. Therefore, the data aggregation logic does not strictly match the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Business Analytic Request: What is the monthly inventory turnover ratio?
# Query Execution
query = """"""
SELECT 
      EXTRACT(YEAR FROM orders.OrderDate) AS year,
      EXTRACT(MONTH FROM orders.OrderDate) AS month, 
      SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio 
FROM 
      orders 
JOIN 
      [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
      products ON [Order Details].ProductID = products.ProductID 
GROUP BY 
      year, month;
""""""

# Execute the query and store the result in a DataFrame
df = execute_sql_query(query)

# Create a new column for year-month to facilitate plotting
df['year_month'] = df['year'].astype(str) + '-' + df['month'].astype(str)

# Sort the DataFrame by year and month
df = df.sort_values(by=['year', 'month'])

# Visualization
fig = px.line(
    df, 
    x='year_month', 
    y='inventory_turnover_ratio', 
    title='Monthly Inventory Turnover Ratio',
    labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio'},
    markers=True,
)

# Display the visualization
show_to_user(fig)
```","The input code calculates the inventory turnover ratio using both year and month for grouping, introducing additional granularity by including the year. The reference implementation groups solely by month. This could result in different turnover ratios if the dataset spans multiple years. Therefore, the logic differs from the reference code.",None
Which products are associated with the highest total order quantities? Visualize the top products by order quantity.,"```python
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrderedQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalOrderedQuantity DESC;
""""""
data = execute_sql_query(sql_query)

# Visualize the top products by order quantity
fig = px.bar(data, x='ProductName', y='TotalOrderedQuantity', title='Top Products by Order Quantity')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products AS p
JOIN [Order Details] AS od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 10
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalQuantity', title='Top Products by Order Quantity', labels={'TotalQuantity': 'Order Quantity', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request, which is to calculate and visualize the products associated with the highest total order quantities. Both the reference and input codes query the database to get the product names and their total order quantities, group by necessary fields, and order by total order quantity in descending order. The visualization uses a bar chart in both cases, showing the products with the highest quantities. The input adds a 'LIMIT 10' in the SQL query to show the top 10 products, which is a valid interpretation of 'top products.'","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalOrdered
FROM [Order Details]
GROUP BY ProductID
ORDER BY TotalOrdered DESC;
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Visualize the top products by order quantity
# Select the top N products for visualization (e.g., top 10)
top_n = 10
top_products = order_data.head(top_n)

# Create a bar chart using Plotly
fig = px.bar(top_products, x='ProductID', y='TotalOrdered', 
             title='Top Products by Order Quantity', 
             labels={'ProductID': 'Product ID', 'TotalOrdered': 'Total Order Quantity'})

# Show the visualization to the user
show_to_user(fig)
```","The input code queries total quantities by ProductID without joining to include ProductName, unlike the reference code. It also selects just top N products arbitrarily, which is not specified in the business request.",Base
What are the names of products that are currently discontinued?,"```python
import pandas as pd

# SQL query to find product names that are discontinued
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discontinued_products_df[['ProductName']])
```","```python
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The input Python code achieves the same objective as the reference code by selecting product names from a database table where the products are discontinued, as indicated by 'Discontinued = 1'. Both codes use a similar SQL query and the same functions 'execute_sql_query' and 'show_to_user', ensuring that the result is displayed correctly. The absence of double square brackets in 'show_to_user' in the input code does not affect functionality since 'discontinued_products' already contains the relevant column.","```python
# SQL query to find names of discontinued products
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query using the provided utility function
discontinued_products = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discontinued_products)
```","The input code correctly executes the SQL query to select the product names of discontinued products and displays them to the user. The reference implementation focuses on displaying only the 'ProductName' column, which the input code effectively does by passing the query result to 'show_to_user' function. While the input code does not explicitly subset the DataFrame, it still adheres to the same logical steps required by the task.",both
What is the total freight cost for all orders made in the year 2022?,"```python
import pandas as pd

# SQL query to get the total freight cost for orders made in 2022
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# As result_df will have a single value DataFrame, extract the value
total_freight_cost = result_df['TotalFreightCost'].iloc[0]

# Display the result to the user
show_to_user(total_freight_cost)
```","```python
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""
total_freight_cost = execute_sql_query(sql_query)
show_to_user(total_freight_cost)
```","The input code is incorrect because it does not extract the single value from the result dataframe. The result of `execute_sql_query(sql_query)` is expected to be a dataframe with a column named 'TotalFreightCost'. The correct approach, as shown in the reference code, is to access the value using `result_df['TotalFreightCost'].iloc[0]`. The input code directly passes the dataframe to `show_to_user`, which would not correctly present the total freight cost.","```python
import pandas as pd

# SQL query to fetch the total freight cost for all orders made in the year 2022
sql_query = """"""
SELECT 
    SUM(OrderFreight) AS TotalFreight 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = 2022;
""""""

# Execute the SQL query using the provided utility function
freight_cost_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(freight_cost_df)
```","Both implementations aim to calculate the total freight cost for orders made in 2022. The input code uses the function YEAR(OrderDate) = 2022, which correctly filters the orders for the year 2022. While it results in a DataFrame (freight_cost_df) instead of a single value, the intention and logic align with the reference code. Both codes ensure the freight sum for the specified year is retrieved and displayed.",Finetuned
What is the total sales revenue generated in each month? Include a line chart to show monthly revenue trends.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY month;
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Ensure the month column is treated as a string for proper line chart visualization
df['month'] = df['month'].astype(str)

# Create Line Chart
fig = px.line(df, x='month', y='TotalSales', title='Monthly Sales Revenue Trends')

# Show the result to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

monthly_revenue = execute_sql_query(sql_query)

fig = px.line(monthly_revenue, x='Month', y='TotalSales', title='Monthly Sales Revenue Trends')
show_to_user(fig)
```","The input code correctly calculates the total sales revenue per month by summing the product of UnitPrice, Quantity, and Discount for each order, grouped by month. It uses a similar SQL query structure and logic as the reference code. Both codes use Plotly Express to create a line chart of the monthly revenue trends. Small differences such as SQL alias naming and column names (e.g., 'Month' vs. 'month') do not impact the overall logic and correctness of the output.","```python
import pandas as pd
import plotly.express as px

# Mocking execute_sql_query and show_to_user functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder: Simulate database execution
    # Replace with actual database connection and execution logic
    return pd.DataFrame({
        'OrderDate': ['2023-01-15', '2023-02-20', '2023-03-05'],
        'TotalRevenue': [1500, 2300, 1800]
    })

def show_to_user(data):
    # Placeholder: Display the data/figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch monthly sales revenue
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS OrderDate, 
       SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY DATE_TRUNC('month', OrderDate)
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Convert OrderDate to datetime for plotting
df['OrderDate'] = pd.to_datetime(df['OrderDate'])

# Create a line chart using Plotly to show monthly revenue trends
fig = px.line(df, x='OrderDate', y='TotalRevenue', title='Monthly Sales Revenue Trends')

# Display the line chart
show_to_user(fig)
```","The input code uses DATE_TRUNC in the SQL query to group by month, resulting in a different field type ('OrderDate' as datetime) than the reference code's formatted string ('month'). Although similar in logic, the reference implementation uses DATE_FORMAT to ensure string format for the x-axis, while the input code converts 'OrderDate' to datetime after fetching the data. This discrepancy could affect the ordering or format of the data in some SQL dialects, causing differences in line chart trends.",Base
Find the CustomerID and the total number of orders for each customer who has ordered more than 10 times.,"```python
import pandas as pd

# SQL Query to retrieve the data
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS order_count
FROM customers
INNER JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID
HAVING COUNT(orders.OrderID) > 10
""""""

# Execute the SQL query and store the result in a dataframe
customer_orders_df = execute_sql_query(sql_query)

# Display the result
show_to_user(customer_orders_df)
```","```python
sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) AS total_orders
FROM orders o
GROUP BY o.CustomerID
HAVING COUNT(o.OrderID) > 10
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","Both implementations correctly retrieve the CustomerID and count of orders for customers who have ordered more than 10 times. The provided code uses a slightly different SQL structure by selecting directly from 'orders' instead of performing an INNER JOIN with 'customers', which is valid if all required data is available in 'orders'. The key logic, computing the order count and applying a HAVING clause, matches the reference implementation.","```python
import pandas as pd

# Define the SQL query to find CustomerID and order counts for customers with more than 10 orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
HAVING COUNT(OrderID) > 10;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
customer_order_data = execute_sql_query(sql_query)

# Display or return the resulting DataFrame
show_to_user(customer_order_data)
```","The provided code retrieves CustomerID and order counts solely from the orders table, assuming CustomerID exists there. The reference code performs a join between customers and orders tables to ensure customers who have orders exceeding the threshold are identified correctly. If orders doesn't directly mirror the customer base, this could lead to discrepancies.",Base
How many orders were shipped over a week late in August 2023?,"```python
import pandas as pd

# SQL Query to find the number of late orders in August 2023
sql_query = """"""
SELECT COUNT(OrderID) AS LateOrders
FROM orders
WHERE DATEDIFF(ShippedDate, RequiredDate) > 7
AND OrderDate BETWEEN '2023-08-01' AND '2023-08-31';
""""""

# Execute the SQL query and get result in a dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
late_orders_count = df.iloc[0]['LateOrders'] if not df.empty else 0
show_to_user(pd.DataFrame({'Late Orders in August 2023': [late_orders_count]}))
```","```python
sql_query = """"""
SELECT COUNT(*) AS LateOrders
FROM orders
WHERE ShippedDate > DATEADD(DAY, 7, RequiredDate)
AND MONTH(OrderDate) = 8
AND YEAR(OrderDate) = 2023
""""""

late_orders = execute_sql_query(sql_query)
show_to_user(late_orders)
```","The input code correctly calculates the number of orders shipped over a week late in August 2023. It uses the DATEADD function to check if 'ShippedDate' is more than 7 days after 'RequiredDate', and it filters 'OrderDate' for August 2023. This logic matches the reference implementation, which uses DATEDIFF for the same comparison.","```python
import pandas as pd

# Utility function stubs (assuming these are defined elsewhere)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing given SQL and returning as DataFrame
    pass

def show_to_user(data: pd.DataFrame):
    # Placeholder for displaying the DataFrame
    pass

# SQL query to get orders shipped over a week late in August 2023
sql_query = """"""
SELECT COUNT(OrderID) as LateOrders
FROM orders
WHERE ShippedDate > ADDDATE(ExpectedDeliveryDate, 7)
AND MONTH(ShippedDate) = 8
AND YEAR(ShippedDate) = 2023;
""""""

# Execute the SQL query and fetch the results as a DataFrame
late_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(late_orders_df)
```","The input code uses 'ExpectedDeliveryDate' instead of 'RequiredDate' to determine if an order is over a week late. Additionally, it calculates lateness by checking if 'ShippedDate' is more than 7 days past 'ExpectedDeliveryDate', differing from the reference implementation's logic by not considering 'OrderDate' constraints.",Base
Which employee achieved the highest sales in 2022? Use a visualization for employee sales comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch employee sales data for 2022
sql_query = """"""
SELECT o.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY o.EmployeeID
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Get the employee with the highest sales
top_employee = sales_data.iloc[0]

# Visualize the employee sales comparison using a bar chart
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Employee Sales Comparison 2022')

# Display the visualization result
show_to_user(fig)

# Display the top employee with the highest sales
show_to_user(top_employee)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.EmployeeID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = 2022
GROUP BY 
    o.EmployeeID
ORDER BY 
    TotalSales DESC
LIMIT 1
""""""

highest_sales_employee = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT 
    o.EmployeeID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = 2022
GROUP BY 
    o.EmployeeID
""""""

employee_sales = execute_sql_query(sql_query_all)

fig = px.bar(employee_sales, x='EmployeeID', y='TotalSales', title='Employee Sales Comparison in 2022')
show_to_user(fig)
```","The provided code correctly achieves the analysis request and aligns with the logic of the reference implementation. It identifies the employee with the highest sales in 2022 and generates a bar chart for sales comparison. The main difference is the handling of the SQL query to fetch the top employee separately, but the code ultimately results in the same business conclusion as the reference.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve employee sales data for 2022
sql_query = """"""
SELECT employees.lastname AS Employee, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY employees.lastname 
ORDER BY TotalSales DESC;
""""""

# Execute the query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Display the employee with the highest sales
if not sales_data.empty:
    top_employee = sales_data.iloc[0]
    top_employee_df = pd.DataFrame([top_employee])

    # Display the top employee
    show_to_user(top_employee_df)

    # Visualize overall employee sales comparison
    fig = px.bar(sales_data, 
                 x='Employee', 
                 y='TotalSales', 
                 title='Employee Sales Comparison for 2022',
                 labels={'TotalSales': 'Total Sales ($)', 'Employee': 'Employee Name'},
                 text='TotalSales')
    
    # Optionally, customize the plot's layout
    fig.update_traces(textposition='outside')
    
    # Show the visualization to the user
    show_to_user(fig)
else:
    show_to_user(""No sales data available for 2022."")
```","The input code achieves the same goal as the reference implementation by calculating the highest sales per employee for 2022 and visualizing the results. Both versions use an SQL query to fetch the data, joining the same tables and filtering for the same year. The input code additionally provides employee last names and customizes the visualization but still calculates top sales correctly and uses a bar chart to compare employee sales. The logic aligns with the reference implementation.",both
What are the top 5 best-selling products? Include a bar chart to show sales figures.,"```python
import plotly.express as px

# SQL query to get top 5 best-selling products
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to show sales figures
fig = px.bar(df, x='ProductName', y='TotalSales', title='Top 5 Best-Selling Products')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS total_sales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY total_sales DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='total_sales', 
             title='Top 5 Best-Selling Products', 
             labels={'total_sales': 'Sales Quantity', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly answers the business analytics request by querying the top 5 best-selling products, using product name, and creating a bar chart to display sales figures. It adheres to the logic of the reference implementation, despite slight differences in SQL field naming and additional labels for the chart.","```python
import plotly.express as px

# SQL query to fetch top 5 best-selling products
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalSales 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query and store the result in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductID', y='TotalSales', title='Top 5 Best-Selling Products', labels={'TotalSales': 'Sales Quantity'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly calculates the top 5 best-selling products by total sales quantity, but it differs from the reference code in a key aspect: it retrieves 'ProductID' instead of 'ProductName'. The business analytics request specifies listing product names, which potentially makes the chart less informative to users if only IDs are displayed.",Base
Which products have a discount applied in more than 10 orders?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(*) AS OrderCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0.0 
GROUP BY p.ProductName 
HAVING COUNT(*) > 10;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT od.ProductID, COUNT(od.OrderID) as OrderCount
FROM [Order Details] od
WHERE od.Discount > 0
GROUP BY od.ProductID
HAVING COUNT(od.OrderID) > 10
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code groups results by ProductID instead of ProductName, unlike the reference implementation. This leads to a mismatch in the final output because ProductID is used in the output instead of joining to retrieve ProductName.","```python
import pandas as pd

# Assuming the function `execute_sql_query` and `show_to_user` are already defined

# Define the SQL query
sql_query = """"""
SELECT product_id 
FROM [Order Details]
WHERE Discount > 0 
GROUP BY product_id 
HAVING COUNT(order_id) > 10;
""""""

# Execute the query and get the results in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)
```","The input code selects `product_id` instead of `ProductName` and does not join with the `products` table, missing out on retrieving the product names. It filters orders with discounts and groups by `product_id`, but the reference code also counts orders with discounts grouped by `ProductName`, resulting in potentially different outputs if product IDs are needed instead of names.",None
What is the average order value for June 2023?,"```python
import pandas as pd

# SQL query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extracting average order value
avg_order_value = df['avg_order_value'].iloc[0]

# Display the result
show_to_user(avg_order_value)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
       COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

average_order_value = execute_sql_query(sql_query)
show_to_user(average_order_value)
```","The input code does not extract the value of 'avg_order_value' from the result set correctly. The SQL query itself is correct, but the handling of the result is missing the step to isolate the 'avg_order_value' from the DataFrame's first row and column as shown in the reference implementation.","```python
from utilities import execute_sql_query, construct_sql_query

# SQL query template for getting the average order value for June 2023
sql_query_template = """"""
SELECT AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

# Execute the SQL query to retrieve the average order value
result_df = execute_sql_query(sql_query_template)

# Display the result to the user
show_to_user(result_df)
```","The input code calculates the average of all line items' values instead of the average order value. The reference code calculates the total order values divided by the count of distinct orders, which correctly represents the average order value.",None
What is the average value of orders placed in January 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['avg_order_value'].iloc[0])
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

average_order_value = execute_sql_query(sql_query)
show_to_user(average_order_value)
```","The input code directly uses 'average_order_value' variable which is supposed to contain the result of the query. However, it should access the 'avg_order_value' column from the DataFrame returned by 'execute_sql_query', similar to df['avg_order_value'].iloc[0] in the reference code. This adjustment is required to correctly extract and display the single average value from the query execution result.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(Orders.OrderValue) AS AvgJanuaryOrderValue 
FROM Orders 
WHERE MONTH(Orders.OrderDate) = 1 AND YEAR(Orders.OrderDate) = 2023;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code is incorrect because it calculates the average by first computing 'Orders.OrderValue', which does not follow the column manipulations in the reference code. In the reference code, the average is derived from summing specific calculated values per order and dividing by the count of distinct orders. The input code assumes 'OrderValue' already exists, whereas the reference calculates it on the fly using detailed logic based on 'UnitPrice', 'Quantity', and 'Discount'.",None
"List the customers along with their total spent amounts, ordered by highest to lowest total spent. Use a bar chart to visualize spending.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY TotalSpent DESC;
""""""

# Execute the query using the provided utility function
dataframe = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(dataframe, x='CustomerID', y='TotalSpent', title='Total Spent by Customer', labels={'TotalSpent': 'Total Spent', 'CustomerID': 'Customer ID'})

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, 
       c.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalSpent DESC
""""""

customer_spending = execute_sql_query(sql_query)

fig = px.bar(customer_spending, 
             x='CompanyName', 
             y='TotalSpent', 
             title='Total Amount Spent by Customers',
             labels={'CompanyName': 'Customer', 'TotalSpent': 'Total Spent'},
             text='TotalSpent')

show_to_user(fig)
```","The input code correctly calculates the total spent by each customer and orders them in descending order. It matches the logic of the reference implementation, grouping by CustomerID and adding a CompanyName for display purposes. The use of the bar chart with the same ordering and labeling achieves the same analytical goal. The inclusion of 'CompanyName' does not affect the correctness as it serves only as an additional label without altering the intended analysis.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch customers and their total spent amounts
sql_query = """"""
SELECT o.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.CustomerID 
ORDER BY TotalSpent DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total spending of each customer
fig = px.bar(df, 
             x='CustomerID', 
             y='TotalSpent', 
             title='Customer Total Spending',
             labels={'TotalSpent': 'Total Spent', 'CustomerID': 'Customer ID'},
             text='TotalSpent')

# Show the bar chart to the user
show_to_user(fig)
```
","The input code does not join with the 'customers' table, which may result in missing customer names if there are orders without a matching customer. The reference code explicitly includes the customers table to ensure all customers are considered. Additionally, the input code uses 'orders.CustomerID' instead of explicitly from 'customers'. This could lead to errors in scenarios where database design requires checking 'customers' table for valid IDs.",Base
What is the average order value for Q1 2023?,"```python
import pandas as pd

# SQL query to retrieve necessary data
sql_query = """"""
SELECT
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Extracting the average order value from the dataframe
avg_order_value = df['avg_order_value'][0]

# Display the average order value to the user
show_to_user(avg_order_value)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

avg_order_value = execute_sql_query(sql_query)
show_to_user(avg_order_value)
```","The input code does not extract the average order value from the result dataframe before displaying it. It directly attempts to show the result of execute_sql_query, which will likely not match the expected output format.","```python
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing the SQL query
    # This function should interface with the datawarehouse to fetch results
    # Replace the return statement with actual database interaction logic
    pass

def show_to_user(data):
    # Placeholder for displaying the data
    # Format and show the pandas DataFrame or value as required
    pass

# SQL query to calculate the average order value for Q1 2023
sql_query = """"""
SELECT 
    SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) / COUNT(DISTINCT O.OrderID) AS AverageOrderValue 
FROM 
    orders O 
JOIN 
    [Order Details] OD ON O.OrderID = OD.OrderID 
WHERE 
    O.OrderDate BETWEEN '2023-01-01' AND '2023-03-31';
""""""

# Execute the SQL query and fetch the result as a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code does not extract the average order value from the DataFrame before displaying it to the user. In the reference code, 'avg_order_value' is extracted from the DataFrame using 'df['avg_order_value'][0]', ensuring the specific value is shown. The input code directly shows the DataFrame, which could lead to displaying the entire DataFrame or incorrect formatting. Thus, it does not fully match the logic expected from the reference.",None
List orders where the shipping cost was above average.,"```python
import pandas as pd

# Execute the SQL query to get the average freight value
avg_freight_query = ""SELECT AVG(Freight) AS average_freight FROM orders""
avg_freight_df = execute_sql_query(avg_freight_query)
average_freight = avg_freight_df.iloc[0]['average_freight']

# Query to get orders where the shipping cost is above average
above_avg_orders_query = f""SELECT * FROM orders WHERE Freight > {average_freight}""
above_avg_orders_df = execute_sql_query(above_avg_orders_query)

# Display the result to the user
show_to_user(above_avg_orders_df)
```","```python
# SQL query to calculate the average shipping cost
avg_shipping_cost_query = ""SELECT AVG(Freight) AS avg_freight FROM orders""
avg_shipping_cost_df = execute_sql_query(avg_shipping_cost_query)
average_shipping_cost = avg_shipping_cost_df['avg_freight'].iloc[0]

# SQL query to list orders where the shipping cost was above average
above_average_shipping_query = f""""""
SELECT * FROM orders
WHERE Freight > {average_shipping_cost}
""""""
above_average_shipping_df = execute_sql_query(above_average_shipping_query)

show_to_user(above_average_shipping_df)
```",The input Python code follows the same logic and steps as the reference implementation. It calculates the average shipping cost from the 'orders' dataset and then retrieves orders where the freight costs are greater than this average. Both implementations use similar SQL queries and present the results to the user. The slight differences in variable names do not affect the correctness of the logic.,"```python
import pandas as pd

# Step 1: Compute the average shipping cost
average_shipping_cost_query = ""SELECT AVG(ShipCost) AS avg_ship_cost FROM orders;""
avg_ship_cost_df = execute_sql_query(average_shipping_cost_query)

# Extract the average shipping cost
avg_ship_cost = avg_ship_cost_df['avg_ship_cost'][0]

# Step 2: Find orders with shipping cost above the average
above_avg_shipping_cost_query = f""""""
SELECT OrderID, ShipCost 
FROM orders 
WHERE ShipCost > {avg_ship_cost};
""""""

# Execute the query and display results
above_avg_ship_cost_df = execute_sql_query(above_avg_shipping_cost_query)
show_to_user(above_avg_ship_cost_df)
```","The input code uses the column 'ShipCost' instead of 'Freight'. If 'ShipCost' represents a different metric than 'Freight', the logic differs from the reference implementation, which uses 'Freight' to compute the average and check against it.",Base
What is the average freight cost for orders shipped to Europe?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(Freight) AS AverageFreightCost 
FROM orders 
WHERE ShipCountry IN ('Austria', 'Belgium', 'Denmark', 'Finland', 'France', 'Germany', 'Greece', 'Ireland', 'Italy', 
'Netherlands', 'Norway', 'Poland', 'Portugal', 'Spain', 'Sweden', 'Switzerland', 'United Kingdom')
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT AVG(Freight) AS average_freight_cost
FROM orders
WHERE ShipCountry IN ('Germany', 'France', 'United Kingdom', 'Italy', 'Spain', 'Sweden', 'Netherlands', 'Belgium', 'Austria', 'Switzerland', 'Norway', 'Finland', 'Ireland', 'Denmark', 'Portugal', 'Greece', 'Poland', 'Czech Republic', 'Hungary', 'Romania', 'Slovakia', 'Bulgaria', 'Croatia', 'Slovenia', 'Lithuania', 'Latvia', 'Estonia')
""""""
average_freight_cost_df = execute_sql_query(sql_query)
show_to_user(average_freight_cost_df)
```","The input Python code's SQL query includes additional countries such as 'Czech Republic', 'Hungary', 'Romania', 'Slovakia', 'Bulgaria', 'Croatia', 'Slovenia', 'Lithuania', 'Latvia', 'Estonia' that are not listed in the reference implementation. These countries aren't specified in the reference implementation, which only includes specific Western European countries. Thus, the input code does not adhere to the same logic regarding which countries are considered part of Europe for this specific analysis.","```python
# Import necessary libraries
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(Freight) AS average_freight 
FROM orders 
WHERE ShipCountry IN ('UK', 'France', 'Germany', 'Italy', 'Spain');
""""""

# Execute the query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code only includes 5 countries (UK, France, Germany, Italy, Spain) compared to the broader list of 18 European countries in the reference implementation. Thus, it does not correctly compute the average freight cost for all orders shipped to Europe as defined in the reference code.",None
What is the average salary of employees by title and visualize the distribution?,"```python
import plotly.express as px

# Execute the SQL query to get the average salary by title
sql_query = ""SELECT Title, AVG(Salary) AS AvgSalary FROM employees GROUP BY Title;""
df = execute_sql_query(sql_query)

# Create and show the visualization of the salary distribution by title
fig = px.bar(df, x='Title', y='AvgSalary', title='Average Salary by Title', labels={'AvgSalary':'Average Salary'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the average salary by job title
sql_query = """"""
SELECT Title, AVG(Salary) AS AverageSalary
FROM employees
GROUP BY Title
""""""
average_salary_df = execute_sql_query(sql_query)

# Visualization of the average salary distribution by title
fig = px.bar(average_salary_df, x='Title', y='AverageSalary',
             title='Average Salary of Employees by Title',
             labels={'Title': 'Job Title', 'AverageSalary': 'Average Salary'})
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request. It executes a similar SQL query to calculate the average salary for each title, closely resembling the logic in the reference implementation. Additionally, the code uses Plotly Express to create a bar chart and labels it correctly, just as the reference does. The minor differences in label names do not affect the correctness of the solution.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT Title, AVG(Salary) AS AverageSalary FROM employees GROUP BY Title;
""""""

# Execute the query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Visualize the distribution using a bar plot
fig = px.bar(df, x='Title', y='AverageSalary', title='Average Salary by Title',
             labels={'AverageSalary': 'Average Salary', 'Title': 'Title'},
             template='plotly_dark')

# Display the result
show_to_user(fig)
```","The input code correctly executes an SQL query to compute the average salary by employee title and creates a bar plot to visualize this data. It matches the logic of the reference implementation by grouping over the 'Title' and calculating the average salary. The small differences, such as naming the column 'AverageSalary' and using the 'plotly_dark' template, are inconsequential to the correctness regarding business requirements.",both
Visualize the total number of orders for each product.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(od.OrderID) AS OrderCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(data, x='ProductName', y='OrderCount', title='Total Number of Orders for Each Product')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrders
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

order_data = execute_sql_query(sql_query)
fig = px.bar(order_data, x='ProductName', y='TotalOrders', title='Total Number of Orders for Each Product')
show_to_user(fig)
```","The provided code calculates the total quantity of products ordered using SUM(od.Quantity) as TotalOrders, while the reference code counts the number of orders using COUNT(od.OrderID). These are different metrics. The provided code does not adhere to the same logic as the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Assume this function is defined elsewhere and correctly fetches the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation not shown
    pass

def show_to_user(data):
    # Implementation not shown
    pass

# SQL Query to fetch data from the database
sql_query = """"""
SELECT ProductID, COUNT(OrderID) AS OrderCount
FROM [Order Details]
GROUP BY ProductID;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='OrderCount', title='Total Number of Orders for Each Product')

# Display the visualization
show_to_user(fig)
```","The input code uses 'ProductID' for grouping instead of 'ProductName', which may not correctly reflect the product names. The reference code uses product names for the visualization, which is more intuitive. Furthermore, the SQL query in the original input code queries '[Order Details]' without joining 'products' to get the product names. This deviates from the logic of the reference implementation.",None
List the top 5 products with the highest unit price.,"```python
import pandas as pd

# SQL query to get the top 5 products with the highest unit price
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
ORDER BY UnitPrice DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)
show_to_user(top_products)
```","The input Python code correctly executes a SQL query that selects the top 5 products with the highest unit price, ordering them in descending order, which matches the logic of the reference implementation. Both implementations use the same SQL query structure and functions (execute_sql_query and show_to_user) to achieve the requested business analytics task.","```python
# Import necessary libraries
import pandas as pd

# Define utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented elsewhere
    pass

# Define utility function to display the results
def show_to_user(data: pd.DataFrame) -> None:
    # This function is assumed to be implemented elsewhere
    pass

# SQL query to fetch the top 5 products with the highest unit price
sql_query = """"""
SELECT products.ProductName, products.UnitPrice 
FROM products 
ORDER BY products.UnitPrice DESC 
LIMIT 5;
""""""

# Execute the SQL query and store result in a DataFrame
top_products = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(top_products)
```","The provided code correctly implements the SQL query to select the top 5 products based on the highest unit price, similar to the reference implementation. Both versions use a SQL query to fetch the desired information and utilize `execute_sql_query` and `show_to_user` utility functions to process and display the results. The logic and the end goal of both implementations are aligned.",both
Visualize the total freight cost for each shipping company in 2023.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY shippers.CompanyName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar plot of total freight cost for each shipping company
fig = px.bar(df, x='CompanyName', y='total_freight_cost', title='Total Freight Cost by Shipping Company in 2023')

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY shippers.CompanyName
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='CompanyName', y='total_freight_cost', title='Total Freight Cost for Each Shipping Company in 2023', labels={'total_freight_cost': 'Total Freight Cost'})
show_to_user(fig)
```",The input code correctly follows the logic of the reference implementation. It executes the same SQL query to retrieve the total freight cost for each shipping company in 2023. It uses Plotly Express to create a bar plot with the same data fields and logic. The minor differences in labels and titles do not affect the overall correctness and adherence to the request.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get total freight costs per shipping company for 2023
sql_query = """"""
SELECT shippers.CompanyName, 
       SUM(orders.Freight) AS total_freight_cost 
FROM orders 
JOIN shippers ON orders.ShipperID = shippers.ShipperID 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY shippers.CompanyName;
""""""

# Execute the SQL query and get the result as a DataFrame
data_frame = execute_sql_query(sql_query)

# Visualize the results using Plotly
fig = px.bar(
    data_frame, 
    x='CompanyName', 
    y='total_freight_cost', 
    title='Total Freight Cost per Shipping Company in 2023',
    labels={'CompanyName': 'Shipping Company', 'total_freight_cost': 'Total Freight Cost'},
    template='plotly_dark'
)

# Display the visualization to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request to visualize the total freight cost for each shipping company in 2023. Although it uses a different SQL condition for the date filter (`YEAR(orders.OrderDate) = 2023` instead of `BETWEEN '2023-01-01' AND '2023-12-31'`), both conditions are logically equivalent. The code also groups by the shipping company's name and sums the freight cost as required. Additionally, the visualization is created and displayed using Plotly, adhering to the request. The use of labels and a template in the plot are enhancements that do not alter the core logic. Therefore, the implementation meets the requirements fully.",both
What is the percentage of orders that were shipped within 3 days of being placed?,"```python
import pandas as pd

# Define the SQL query to execute
sql_query = """"""
SELECT OrderDate, ShippedDate FROM orders;
""""""

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Calculate the number of orders shipped within 3 days
orders_df['DaysToShip'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days
within_three_days_count = orders_df[orders_df['DaysToShip'] <= 3].shape[0]

# Calculate the total number of orders
total_orders_count = orders_df.shape[0]

# Calculate the percentage
percentage_within_three_days = (within_three_days_count / total_orders_count) * 100

# Prepare the results as a dataframe
result_df = pd.DataFrame({
    ""Percentage of Orders Shipped Within Three Days"": [percentage_within_three_days]
})

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 3 THEN 1 ELSE 0 END) AS ShippedWithin3Days
FROM 
    orders
""""""

result = execute_sql_query(sql_query)

total_orders = result['TotalOrders'][0]
shipped_within_3_days = result['ShippedWithin3Days'][0]

percentage_shipped_within_3_days = (shipped_within_3_days / total_orders) * 100

show_to_user(pd.DataFrame({'Percentage Shipped Within 3 Days': [percentage_shipped_within_3_days]}))
```","The input code retrieves the total number of orders and the number of orders shipped within 3 days directly from the SQL query. It uses these values to compute the percentage, which matches the intent and logic of the reference implementation. Both codes calculate the time difference and derive the percentage, though the input code calculates this directly in SQL, while the reference performs it in Python.","```python
import pandas as pd

# Utility functions assumed to be defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation
    pass

def show_to_user(data):
    # Placeholder for actual implementation
    pass

# SQL query to fetch the total number of orders and on-time shipments
sql_query = """"""
SELECT (COUNT(CASE WHEN ShippedDate <= OrderDate + INTERVAL '3 days' THEN 1 END) * 100.0 / COUNT(*)) AS OnTimeShipPercentage
FROM orders;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code correctly calculates the percentage of orders shipped within 3 days by using a SQL query to count the relevant entries and compute the percentage directly in the query. This approach aligns with the logic of the reference implementation, which performs the calculation in Python after retrieving the order data. Both methods achieve the same end result, making the input code correct.",both
Which products have been ordered with a discount?,"```python
import pandas as pd

# SQL query to find products ordered with a discount
sql_query = """"""
SELECT DISTINCT p.ProductName 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0;
""""""

# Execute the query
discounted_products_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discounted_products_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, od.Discount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
""""""

discounted_products = execute_sql_query(sql_query)
show_to_user(discounted_products)
```","The provided code correctly identifies products ordered with a discount but does not filter to show only distinct product names. Unlike the reference implementation, it includes additional columns (ProductID and Discount), rather than returning only the unique ProductName.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductID, ProductName
FROM products
WHERE ProductID IN (SELECT DISTINCT ProductID FROM [Order Details] WHERE Discount > 0);
""""""

# Execute the SQL query and retrieve the results as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)
```","The input code is correct as it successfully retrieves the products that have been ordered with a discount. It does this by selecting `ProductID` and `ProductName` from the `products` table where `ProductID` matches any `ProductID` found with a discount in the `[Order Details]` table. Although it uses a different approach than the reference by fetching all matching products using an `IN` clause, the logic is consistent with the reference implementation, which uses a `JOIN`. Both approaches effectively determine which products were ordered with a discount.",Finetuned
What is the total number of orders shipped via each shipping method per month and illustrate the trend?,"```python
import plotly.express as px
import pandas as pd

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, ShipVia, COUNT(OrderID) AS OrdersShipped 
FROM orders 
GROUP BY Month, ShipVia;
""""""

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Pivot the data to have shipping methods in separate columns
pivoted_data = orders_data.pivot(index='Month', columns='ShipVia', values='OrdersShipped').reset_index()

# Create a line plot
fig = px.line(pivoted_data, x='Month', y=pivoted_data.columns[1:], title='Orders Shipped via Each Method per Month',
              labels={'value': 'Orders Shipped', 'variable': 'Shipping Method'}, markers=True)

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    ShipVia,
    COUNT(OrderID) AS TotalOrders
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    Month, ShipVia
ORDER BY 
    Month, ShipVia;
""""""

orders_data = execute_sql_query(sql_query)

fig = px.line(orders_data, x='Month', y='TotalOrders', color='ShipVia', 
              labels={'TotalOrders': 'Total Orders Shipped', 'ShipVia': 'Shipping Method'},
              title='Total Orders Shipped via Each Shipping Method per Month')
show_to_user(fig)
```","The input code counts orders based on the 'ShippedDate' with a condition 'WHERE ShippedDate IS NOT NULL', while the reference code uses 'OrderDate'. This difference changes the set of orders being analyzed. Additionally, the input code orders the results in SQL by 'Month, ShipVia', which is not done in the reference implementation. However, this last change does not affect the correctness regarding the question since it is related to ordering, not grouping.","```python
import plotly.express as px
import pandas as pd

# SQL query to aggregate the total number of orders shipped via each method per month
sql_query = """"""
SELECT
    MONTH(o.OrderDate) AS OrderMonth,
    o.ShipVia,
    COUNT(o.OrderID) AS TotalOrders
FROM
    orders o
GROUP BY
    OrderMonth, o.ShipVia;
""""""

# Execute the SQL query and return the results as a DataFrame
df = execute_sql_query(sql_query)

# Convert OrderMonth to datetime for better plotting
df['OrderMonth'] = pd.to_datetime(df['OrderMonth'].astype(str) + '/1', format='%m/%d')

# Create a line plot to illustrate the trend
fig = px.line(
    df,
    x='OrderMonth',
    y='TotalOrders',
    color='ShipVia',
    title='Trend of Total Orders Shipped via Each Method Per Month',
    labels={'TotalOrders': 'Total Orders', 'OrderMonth': 'Order Month'}
)

# Display the line plot
show_to_user(fig)
```","The input code and reference code differ in how they handle the month data and group the results. The reference code generates 'Month' in 'YYYY-MM' format whereas the input uses the month as an integer. This affects the plot's x-axis. Additionally, the input code does not pivot the data, resulting in possible misrepresentation in the line plot as 'ShipVia' is used directly in 'color', contrasting with the reference's method of distinct lines per shipping method using pivot. These differences affect both the data structure and final visualization.",None
Visualize the total number of products supplied by each supplier.,"```python
import plotly.express as px

# SQL query
sql_query = ""SELECT SupplierID, COUNT(ProductID) AS TotalProducts FROM products GROUP BY SupplierID;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart with plotly
fig = px.bar(df, x='SupplierID', y='TotalProducts', title='Total Products Supplied by Each Supplier')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) AS TotalProducts
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
""""""

supplier_products_df = execute_sql_query(sql_query)

fig = px.bar(supplier_products_df, x='CompanyName', y='TotalProducts', 
             title='Total Number of Products Supplied by Each Supplier',
             labels={'CompanyName': 'Supplier', 'TotalProducts': 'Total Products'})
show_to_user(fig)
```","The input Python code correctly answers the business request and matches the logic of the reference implementation. It uses a SQL query to count the number of products by supplier, groups by the supplier's name (which is equivalent to SupplierID in terms of grouping results), and visualizes this data using a bar chart. Both implementations aggregate product count by supplier and visualize it appropriately. The use of 'CompanyName' instead of 'SupplierID' for visualization provides a more user-friendly output but maintains the same logical structure as the reference.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve product counts per supplier
sql_query = """"""
SELECT products.SupplierID, COUNT(*) AS TotalProducts
FROM products
GROUP BY products.SupplierID;
""""""

# Execute the SQL query and store the result in a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implement the function to execute the query using the correct database connection
    # For demonstration purposes, assuming this function is already implemented
    pass

def show_to_user(data):
    # Implement this to display the data or plot
    # For demonstration purposes, assuming this function is already implemented
    pass

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar plot using Plotly
fig = px.bar(df, x='SupplierID', y='TotalProducts', title='Total Products per Supplier')

# Display the plot
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It performs the SQL query to count the number of products supplied by each supplier and groups them by SupplierID, similar to the reference code. The resulting DataFrame is used to create a bar plot with Plotly, displaying the total products per supplier, and the end result is shown to the user. While some function implementations are assumed as existing and the code styling slightly differs, the core logic and intent are equivalent.",both
Which products need to be reordered?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query
products_to_reorder_df = execute_sql_query(sql_query)

# Display the products that need to be reordered
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND (UnitsInStock + UnitsOnOrder) <= ReorderLevel
""""""

reorder_products = execute_sql_query(sql_query)
show_to_user(reorder_products)
```","The input code adds extra conditions by checking that 'Discontinued = 0' and includes 'UnitsOnOrder' in its stock calculation, which deviates from the reference code. The reference implementation only considers 'UnitsInStock <= ReorderLevel', making the logic of the input code incorrect according to the given task.","```python
import pandas as pd

# SQL Query to find products that need to be reordered
sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel;
""""""

# Fetching data from the database
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function is implemented to connect to the database and execute the given SQL query
    # Returns the result as a pandas DataFrame
    pass

# Executing the SQL query and getting the result as a DataFrame
reorder_products_df = execute_sql_query(sql_query)

# Displaying the results to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        print(""Invalid Data"")

show_to_user(reorder_products_df)
```","The input code is not correct because it uses a strict less-than comparison (`UnitsInStock < ReorderLevel`), while the reference implementation uses a less-than-or-equal-to comparison (`UnitsInStock <= ReorderLevel`). This difference means the input code will not correctly identify all products that need to be reordered according to the specified business request.",None
Visualize which products have the highest total sales volume in quantity.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalSalesQuantity DESC;
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Plot
fig = px.bar(data, x='ProductName', y='TotalSalesQuantity', 
             title='Products with Highest Total Sales Volume in Quantity')

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSalesVolume
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSalesVolume DESC
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSalesVolume',
             title='Total Sales Volume by Product',
             labels={'TotalSalesVolume': 'Total Sales Volume (Quantity)', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly follows the logic of the reference code. Both scripts execute SQL queries to calculate the total sales volume by summing quantities grouped by product, and order the results in descending order. Both implementations then visualize this data using Plotly to produce a bar chart. The difference in ordering of the JOIN clause or GROUP BY fields does not affect correctness. The label enhancement in the input code is acceptable as it does not alter the logic or the outcome of the analysis.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch product sales data
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity) AS TotalSales 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query and get the results in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the logic to execute the provided SQL query
    # and return the result as a pandas DataFrame.
    ...
    # Example placeholder data for demonstration purposes
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'TotalSales': [1000, 800, 650]
    }
    return pd.DataFrame(data)

# Display visualization to user
def show_to_user(data):
    # This function should display the data or Plotly figure.
    ...
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Fetch data from the database
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ProductName', y='TotalSales',
             title='Total Sales Volume by Product',
             labels={'TotalSales': 'Total Sales Volume', 'ProductName': 'Product Name'})

# Display the figure to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request by visualizing products with the highest total sales volume in quantity. It constructs a SQL query that calculates the total sales quantities per product, executes it, and creates a bar chart using Plotly Express. Although the function definitions and labels vary, they do not alter the logic or outcome of the analysis. Thus, it adheres to the same logic as the reference implementation.",both
Visualize how many orders were placed and fulfilled in each month of 2023.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       COUNT(orders.OrderID) AS orders_placed, 
       COUNT(CASE WHEN orders.ShippedDate IS NOT NULL THEN 1 END) AS orders_fulfilled 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month 
ORDER BY month
""""""

# Execute the SQL query and retrieve data
df = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(df, x='month', y=['orders_placed', 'orders_fulfilled'], 
             labels={'value': 'Number of Orders', 'variable': 'Order Type'}, 
             title='Orders Placed and Fulfilled in 2023',
             barmode='group')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    COUNT(OrderID) AS orders_placed,
    COUNT(CASE WHEN ShippedDate IS NOT NULL THEN 1 END) AS orders_fulfilled
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY month
ORDER BY month;
""""""

orders_data = execute_sql_query(sql_query)

fig = px.line(orders_data, x='month', y=['orders_placed', 'orders_fulfilled'], 
              labels={'value': 'Number of Orders', 'month': 'Month'},
              title='Orders Placed and Fulfilled in Each Month of 2023')
show_to_user(fig)
```","The input Python code visualizes the data using a line plot instead of a bar plot. The business analytics request specifies visualizing the number of orders placed and fulfilled, and the reference code uses `px.bar` for this purpose. The use of `px.line` changes how the data trends are represented. While the SQL logic is the same, the visualization method does not adhere to the logic used in the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve data for fulfilled and unfulfilled orders each month in 2023
sql_query = """"""
SELECT 
    MONTH(O.OrderDate) AS Month, 
    COUNT(O.OrderID) AS OrdersPlaced,
    SUM(CASE WHEN O.Fulfilled = 1 THEN 1 ELSE 0 END) AS OrdersFulfilled
FROM 
    orders O
WHERE 
    YEAR(O.OrderDate) = 2023
GROUP BY 
    MONTH(O.OrderDate)
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a new DataFrame to have one entry per month with counts for placed and fulfilled
monthly_data = pd.DataFrame({
    'Month': df['Month'],
    'OrdersPlaced': df['OrdersPlaced'],
    'OrdersFulfilled': df['OrdersFulfilled']
})

# Sort by Month to ensure correct plotting order
monthly_data.sort_values('Month', inplace=True)

# Visualize the data using a bar chart
fig = px.bar(
    monthly_data,
    x='Month',
    y=['OrdersPlaced', 'OrdersFulfilled'],
    title='Monthly Orders: Placed vs Fulfilled in 2023',
    labels={'value': 'Number of Orders', 'variable': 'Order Status'},
    barmode='group'
)

# Display the chart to the user
show_to_user(fig)
```","The input code correctly retrieves the orders placed and fulfilled for each month in 2023 using SQL, similar to the reference implementation. It makes use of a CASE statement to count fulfilled orders, which aligns logically with the reference's use of a conditional aggregation for shipped orders. Both codes use Plotly to create a grouped bar chart, and the data is visually represented similarly in both instances. The input code fulfills the business analytics request with an appropriate structure and logic.",Finetuned
What was the total sales revenue generated in the year 2023?,"```python
import pandas as pd

# SQL query to calculate total sales revenue for the year 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
sales_data_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(sales_data_df)
```
","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""
total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input code is functionally equivalent to the reference code. Both scripts generate the total sales revenue for the year 2023 by executing an identical SQL query and displaying the result. The only difference is variable naming, which does not affect the correctness of the code.","```python
import pandas as pd

# SQL Query to fetch total sales revenue for 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the total sales revenue
show_to_user(result_df)
```","The input Python code correctly calculates and retrieves the total sales revenue for the year 2023 by executing an SQL query that sums the product of UnitPrice, Quantity, and (1 - Discount) from the Order Details table, joined with the orders table using OrderID, and filtering by OrderDate within the specified range. It adheres to the same logic as the reference implementation, although it assigns the result to a variable named 'result_df' instead of 'sales_data_df'. The display function 'show_to_user' is used in both implementations. These differences do not affect the correctness regarding the business analytics request.",both
Which supplier supplies the highest number of different products?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SupplierID, COUNT(DISTINCT ProductID) AS ProductCount 
FROM products 
GROUP BY SupplierID 
ORDER BY ProductCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Ensure column names are correct and display the result to the user
result_df.columns = ['SupplierID', 'ProductCount']
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(DISTINCT p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY ProductCount DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code correctly implements the logic of determining which supplier supplies the highest number of different products. It uses a SQL query to count distinct products per supplier and orders by that count in descending order, limiting the result to 1. Although it includes additional information (CompanyName), the core logic for ProductCount is the same as the reference.","```python
import pandas as pd

# SQL query to get the supplier with the highest number of distinct products
sql_query = """"""
SELECT suppliers.CompanyName, 
       COUNT(DISTINCT products.ProductID) AS product_count 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.CompanyName 
ORDER BY product_count DESC 
LIMIT 1;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would typically execute the SQL and return a DataFrame
    # Here, we mock it to return a sample DataFrame for demonstration
    # In practice, implement actual database connection and execution logic
    # Returning a placeholder DataFrame for the purpose of this simulation
    return pd.DataFrame({
        'CompanyName': ['Supplier X'],
        'product_count': [150]
    })

def show_to_user(data: pd.DataFrame):
    # Simulated function to display the result
    print(data)

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The provided code correctly answers the business analytics request by returning the supplier with the highest number of distinct products. It uses a SQL query that counts distinct product IDs per supplier, orders by this count, and limits the result to one, aligning with the logic in the reference implementation. The use of supplier names instead of IDs does not affect the correctness of the logic, as it is still identifying the correct supplier based on product count.",both
What is the average shipping cost per order for 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
shipping_cost_df = execute_sql_query(sql_query)

# Ensure that only the average cost is presented
average_cost = shipping_cost_df.iloc[0]['shipping_cost_per_order']

# Convert the average cost to a DataFrame
result_df = pd.DataFrame({'shipping_cost_per_order': [average_cost]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(orders.Freight) AS average_shipping_cost_per_order 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly executes a SQL query to calculate the average shipping cost per order for 2023. It matches the logic of the reference implementation, which uses the AVG function on the Freight column filtered by OrderDate for the year 2023. Although the input code does not explicitly convert the result to a DataFrame, it is effectively equivalent because it directly uses 'execute_sql_query' to obtain and display the result.","```python
import pandas as pd

# Function to execute a SQL query and return the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented elsewhere
    pass

# Function to display the result to the user
def show_to_user(data: pd.DataFrame):
    # This function is assumed to be implemented elsewhere
    pass

# SQL query to calculate average shipping cost per order for 2023
sql_query = """"""
SELECT AVG(Freight) AS avg_shipping_cost 
FROM orders 
WHERE YEAR(OrderDate) = 2023;
""""""

# Execute the query and store the result
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The input code correctly calculates the average shipping cost per order for 2023. The SQL query in the input code uses `YEAR(OrderDate) = 2023`, which is equivalent to the reference code's `BETWEEN '2023-01-01' AND '2023-12-31'` condition. Both methods correctly filter the OrderDate to only include orders from 2023 and compute the average using the `AVG(Freight)` function. The code also correctly assumes execution and displaying of the result. Therefore, the logic and objective align with the reference implementation.",both
What is the total value of orders shipped in the first quarter of 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT QUARTER(o.OrderDate) AS OrderQuarter, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = 2023 
GROUP BY OrderQuarter;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Filter for the first quarter and retrieve total value
total_value_q1 = df[df['OrderQuarter'] == 1]['TotalValue'].values[0]

# Prepare the result for display
result = pd.DataFrame({
    'OrderQuarter': [1],
    'TotalValue': [total_value_q1]
})

# Display the result
show_to_user(result)
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.ShippedDate >= '2023-01-01' AND o.ShippedDate < '2023-04-01'
""""""

total_value_df = execute_sql_query(sql_query)
show_to_user(total_value_df)
```","The input code calculates the total value of orders shipped in Q1 2023, whereas the reference code calculates the total value of orders placed in Q1 2023. The task asks for the total value of orders shipped, so the SQL query logic differs from the reference code.","```python
import pandas as pd

# SQL query to get the total value of orders shipped in Q1 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    o.ShippedDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Executing the SQL query and storing the result in a DataFrame
total_value_df = execute_sql_query(sql_query)

# Displaying the total value
show_to_user(total_value_df)
```","The input code calculates the total value of orders shipped in Q1 2023 based on the 'ShippedDate', not the 'OrderDate' as the reference code does. This approach does not adhere to the same logic as the reference implementation, which uses 'OrderDate' to define the quarter.",None
What is the Customer Retention Rate for the last 6 months?,"```python
import pandas as pd

# Retrieve customer count for the last 6 months
sql_query_recent = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS customer_count_recent 
FROM orders 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 6 MONTH) AND CURDATE();
""""""
recent_data = execute_sql_query(sql_query_recent)
recent_customers = recent_data['customer_count_recent'].iloc[0]

# Retrieve total customer count for comparison for customer retention
sql_query_previous = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS customer_population_before 
FROM orders 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 12 MONTH) AND DATE_SUB(CURDATE(), INTERVAL 6 MONTH);
""""""
previous_data = execute_sql_query(sql_query_previous)
previous_customers = previous_data['customer_population_before'].iloc[0]

# Calculate Customer Retention Rate
customer_retention_rate = recent_customers / previous_customers if previous_customers != 0 else 0

# Create a DataFrame to display
retention_df = pd.DataFrame({
    'CustomerRetentionRate': [customer_retention_rate]
})

# Use utility function to show the result
show_to_user(retention_df)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last 6 months
end_date = datetime.now()
start_date = end_date - timedelta(days=6*30)

# SQL query to get the Customer Retention Rate
sql_query = f""""""
SELECT 
    (COUNT(DISTINCT CASE WHEN OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}' THEN CustomerID END) * 1.0) /
    NULLIF(COUNT(DISTINCT CustomerID WHERE OrderDate < '{start_date.date()}'), 0) AS RetentionRate
FROM 
    orders
""""""

# Execute the SQL query and store the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The evaluated code calculates the retention rate by dividing the count of current customers by the count of previous customers who had any transaction before six months ago, instead of between 6 to 12 months ago as in the reference code. Furthermore, the evaluated code uses a fixed 30-day month calculation which can lead to errors if the current month or earlier months have different days (e.g., using calendar months instead would be more accurate). Additionally, the reference code checks if previous customers count is zero to avoid division errors, which is not handled in the evaluated code that uses NULLIF instead. Thus, the logic and time calculation differ from the reference implementation.","```python
import pandas as pd

# Assuming execute_sql_query and show_to_user are defined as per the environment

def calculate_customer_retention_rate():
    # Define the SQL query
    sql_query = """"""
    SELECT 
        c1.CustomerID,
        MIN(o1.OrderDate) AS FirstOrder,
        MAX(o1.OrderDate) AS LastOrder
    FROM 
        customers c1 
    JOIN 
        orders o1 ON c1.CustomerID = o1.CustomerID 
    GROUP BY 
        c1.CustomerID
    HAVING 
        MAX(o1.OrderDate) >= DATEADD(MONTH, -6, CURRENT_DATE)
    """"""

    # Execute the SQL query and get the result in a DataFrame
    df = execute_sql_query(sql_query)

    # Ensure 'FirstOrder' and 'LastOrder' are datetime
    df['FirstOrder'] = pd.to_datetime(df['FirstOrder'])
    df['LastOrder'] = pd.to_datetime(df['LastOrder'])

    # Define the cut-off date for retention calculation
    retention_cutoff = pd.to_datetime(""YYYY-MM-DD"")  # Replace with the specific date or logic

    # Calculate total customers who placed orders in the last 6 months
    total_customers_last_6_months = df['CustomerID'].nunique()

    # Calculate the number of customers who made a repeat purchase
    retained_customers = df[df['FirstOrder'] < retention_cutoff]

    # Calculate the retention rate
    retention_rate = (len(retained_customers) / total_customers_last_6_months) * 100

    # Convert the retention rate to a DataFrame for display
    result_df = pd.DataFrame({
        'Retention Rate (%)': [retention_rate]
    })

    # Show the result to the user
    show_to_user(result_df)

# Call the function
calculate_customer_retention_rate()
```","The input code does not calculate the retention rate correctly as per the reference implementation. The reference code determines the number of distinct customers in the last 6 months and compares it to the distinct number of customers in the previous 6-12 month period. The reference code uses SQL queries to get distinct customer counts for specific timeframes. However, the provided input code calculates the retention rate based on customers who made a repeat purchase after their first order, which is a different logic. Additionally, it doesn't have the correct logic to determine the cut-off date or calculate customers from 6-12 months ago.",None
What is the most common job title among the employees?,"```python
import pandas as pd

# SQL query to get the most common job title
sql_query = """"""
SELECT Title, COUNT(*) AS TitleCount
FROM employees
GROUP BY Title
ORDER BY TitleCount DESC
LIMIT 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
job_title_df = execute_sql_query(sql_query)

# Extract the most common job title and display it to the user
most_common_title = job_title_df.iloc[0]['Title']
show_to_user(most_common_title)
```","```python
sql_query = """"""
SELECT Title, COUNT(*) as Count
FROM employees
GROUP BY Title
ORDER BY Count DESC
LIMIT 1
""""""

most_common_title = execute_sql_query(sql_query)
show_to_user(most_common_title)
```","The input code executes the SQL query but does not correctly extract and display the 'Title'. Instead, it passes the entire resulting query output to 'show_to_user'. In comparison, the reference code extracts only the 'Title' value from the top row and then displays it.","
import pandas as pd

# Define the SQL query to find the most common job title
sql_query = """"""
SELECT JobTitle, COUNT(*) AS Count 
FROM employees 
GROUP BY JobTitle 
ORDER BY Count DESC 
LIMIT 1;
""""""

# Execute the SQL query
most_common_job_title_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(most_common_job_title_df)
","The input code structure is similar to the reference code, but there is a mismatch in the column name used in the SQL query ('JobTitle' vs. 'Title'). Both should reference the same column name in the database. Additionally, the input code outputs the entire dataframe instead of extracting and displaying just the job title as the reference code does. This could lead to a difference in output format.",None
Find the difference in days between the hire date and the birthdate of employees.,"```python
import pandas as pd

# SQL query to get employee data
sql_query = """"""
SELECT EmployeeID, HireDate, BirthDate FROM employees;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the difference in days between hire date and birth date
df['HireDate'] = pd.to_datetime(df['HireDate'])
df['BirthDate'] = pd.to_datetime(df['BirthDate'])
df['DaysDifference'] = (df['HireDate'] - df['BirthDate']).dt.days

# Select necessary columns
result_df = df[['EmployeeID', 'DaysDifference']]

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd

sql_query = """"""
SELECT EmployeeID, 
       DATEDIFF(HireDate, BirthDate) AS DaysDifference
FROM employees
""""""
employee_days_diff = execute_sql_query(sql_query)
show_to_user(employee_days_diff)
```","The input code uses the SQL function DATEDIFF to calculate the difference in days between hire date and birth date directly in the SQL query. This is equivalent to the reference implementation, which computes the difference in Python after retrieving the data. Both approaches achieve the same result by providing the days difference for each employee.","```python
from datetime import datetime

# Execute the SQL query to get all employees with their birthdates and hire dates
sql_query = ""SELECT BirthDate, HireDate FROM employees;""
employee_data = execute_sql_query(sql_query)

# Define a function to calculate the difference in days
def calculate_days_difference(birthdate_str, hiredate_str):
    # Parse the date strings to datetime objects
    birthdate = datetime.strptime(birthdate_str, ""%Y-%m-%d"")
    hiredate = datetime.strptime(hiredate_str, ""%Y-%m-%d"")
    # Calculate the difference in days
    return (hiredate - birthdate).days

# Calculate the difference in days for each employee
for employee in employee_data:
    days_difference = calculate_days_difference(employee['BirthDate'], employee['HireDate'])
    # Store or display the days difference as per the requirement
    print(f""Days difference for employee: {days_difference}"")

# Note: The above assumes execute_sql_query returns a list of dictionaries.
```","The input code calculates the difference in days between hire date and birth date, similar to the reference code. However, it does not create a DataFrame or preserve the EmployeeID, which is present in the reference implementation. Furthermore, the input code directly prints the result instead of storing it in a structured format like `result_df`. Thus, it does not fully meet the logic of the reference implementation.",Base
How many products are discontinued?,"```python
import pandas as pd

# SQL query to find the number of discontinued products
sql_query = ""SELECT COUNT(*) AS discontinued_products FROM products WHERE products.Discontinued = 1""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Extract the count of discontinued products
discontinued_products_count = discontinued_products_df.iloc[0]['discontinued_products']

# Display the result
show_to_user(discontinued_products_count)
```","```python
sql_query = ""SELECT COUNT(*) AS discontinued_products FROM products WHERE Discontinued = 1""
discontinued_products_df = execute_sql_query(sql_query)
show_to_user(discontinued_products_df)
```","The input code does not extract the count of discontinued products from the DataFrame before displaying it with 'show_to_user'. It directly displays the DataFrame, which is not the same logic as the reference implementation that extracts the specific count value.","```python
# SQL query to retrieve the count of discontinued products
sql_query = ""SELECT COUNT(ProductID) FROM products WHERE Discontinued = 1;""

# Execute the SQL query and store the result
discontinued_count = execute_sql_query(sql_query)

# Display the count of discontinued products
show_to_user(discontinued_count)
```","The input code correctly queries the database to count discontinued products by selecting the count where the 'Discontinued' column equals 1. While the input code doesn't alias the count, it properly executes the SQL query and presumably processes the result in 'discontinued_count'. The logic matches the reference code's intent to count discontinued products.",Finetuned
List all orders that took more than 10 days to fulfill in 2021.,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT OrderID 
FROM orders 
WHERE YEAR(OrderDate) = 2021 
AND DATEDIFF(ShippedDate, OrderDate) > 10;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE DATEDIFF(ShippedDate, OrderDate) > 10
AND YEAR(OrderDate) = 2021
""""""
orders_over_ten_days = execute_sql_query(sql_query)
show_to_user(orders_over_ten_days)
```","The input code correctly implements the logic needed to fulfill the business analytics request. It queries orders from the 'orders' table where the difference between 'ShippedDate' and 'OrderDate' is more than 10 days and the 'OrderDate' is in 2021. The difference is that the input code selects all columns (*) instead of just 'OrderID', but this does not affect correctness in terms of identifying the orders. Both codes use the same filter conditions, hence the result will be equivalent in terms of identifying which orders to list.","```python
import pandas as pd

# Placeholder for SQL query execution
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to execute the SQL and return a DataFrame
    pass

# Placeholder for displaying the data
def show_to_user(data: pd.DataFrame):
    # This function should be implemented to display the DataFrame to the user
    pass

# SQL query to fetch orders that took more than 10 days to fulfill in 2021
sql_query = """"""
SELECT orders.OrderID 
FROM orders 
WHERE DATEDIFF(orders.ShippedDate, orders.OrderDate) > 10 
AND YEAR(orders.OrderDate) = 2021;
""""""

# Execute the query and receive a DataFrame
orders_df = execute_sql_query(sql_query)

# Display the resulting DataFrame to the user
show_to_user(orders_df)
```",The input code correctly mirrors the logic of the reference implementation. Both codes query for orders from the 'orders' table where the year of 'OrderDate' is 2021 and the difference between 'ShippedDate' and 'OrderDate' is greater than 10 days. The SQL syntax and logic used in the input code match that of the reference implementation.,both
What was the total sales revenue generated each month in the year 2022? Please include a time series chart to visualize monthly trends.,"```python
import plotly.express as px

# SQL query as provided
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(OrderDate) = 2022 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Convert 'Month' column to a datetime object for sorting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Sort the dataframe by 'Month'
sales_data = sales_data.sort_values(by='Month')

# Create the time series chart
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Sales Revenue for 2022')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = 2022
GROUP BY 
    Month
ORDER BY 
    Month
""""""

monthly_sales = execute_sql_query(sql_query)

fig = px.line(monthly_sales, x='Month', y='TotalSales', title='Total Sales Revenue Each Month in 2022', labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})
show_to_user(fig)
```","The provided code correctly implements the logic from the reference implementation. Both scripts use an SQL query to calculate total sales for each month in 2022, and utilize Plotly to create a line chart. The minor differences such as the use of aliases and the ordering within the SQL query do not affect the functional outcome, ensuring both implementations align with the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get the total sales revenue each month in 2022
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = 2022
GROUP BY Month
ORDER BY Month
""""""

# Execute the SQL query and fetch the results into a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a time series line chart to visualize the monthly sales trends
fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales Revenue Each Month in 2022', labels={'TotalSales': 'Sales Revenue', 'Month': 'Month'})

# Display the visualization to the user
show_to_user(fig)
```","The input code correctly calculates the total sales revenue per month for 2022 using a SQL query that aggregates data by month, accounting for discounts in sales. It uses DATE_TRUNC for monthly grouping which is functionally equivalent to DATE_FORMAT in the reference code. The resulting data is then visualized with a Plotly line chart similar to the reference code. Both implementations produce and visualize the same expected result.",both
What was the total sales revenue for the month of January 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-01';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales value
total_sales = result_df.iloc[0, 0]

# Display the result
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01';
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","Both implementations correctly calculate the total sales revenue for January 2023. The logic in both queries achieves the same result. The reference code uses DATE_FORMAT to filter by month, while the input code uses an inequality to check date range, which is equivalent. Both methodologies correctly fetch and sum the sales for the correct month.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales_revenue 
FROM 
    [Order Details] 
JOIN 
    orders 
ON 
    [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';
""""""

# Execute the SQL query and store the result in a DataFrame
sales_revenue_df = execute_sql_query(sql_query)

# Display the total sales revenue
show_to_user(sales_revenue_df)
```","The input Python code and the reference implementation both calculate the total sales revenue for January 2023 using SQL queries. The difference is in the SQL syntax: the reference code uses `DATE_FORMAT` to filter dates, while the input code uses `BETWEEN` for date filtering. Both achieve the same goal of filtering for January 2023. The calculation of total sales revenue is identical, multiplying UnitPrice, Quantity, and adjusting for Discount. Therefore, the logic aligns with the reference implementation.",both
"What is the average order value for orders placed between January 1, 2023, and December 31, 2023?","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and retrieve the data in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Extract the average order value
avg_order_value = result_df['avg_order_value'].iloc[0]

# Display the result to the user
show_to_user(avg_order_value)
```","```python
import pandas as pd

sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)
```","The input code retrieves the query result as a dataframe but directly displays the dataframe to the user. It does not extract the 'avg_order_value' from the dataframe before displaying, which is required to match the logic of the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(OrderValue) AS AverageOrderValue
FROM (
    SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue
    FROM orders o
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
    GROUP BY o.OrderID
) AS OrderSums
""""""

# Execute the SQL query using the provided utility function
average_order_value_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_order_value_df)
```","Both implementations correctly calculate the average order value for orders in the given date range using SQL queries. The reference code computes the sum of order values divided by the number of distinct orders, while the input code uses a subquery to first calculate the sum for each order, then averages these sums. Although they use different approaches, the logic and resulting calculation are equivalent.",Finetuned
Which city has received the highest number of orders?,"```python
import pandas as pd

# SQL query to find the city with the highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) as TotalOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY TotalOrders DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1
""""""

highest_city = execute_sql_query(sql_query)
show_to_user(highest_city)
```","The input code correctly addresses the business analytics request. It constructs an SQL query that counts the number of orders per city, groups by city, orders the results in descending order by the order count, and limits the result to the top entry. This logic aligns with the reference implementation, which also retrieves the city with the highest number of orders using similar SQL operations.","
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and fetch the result
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)
",The input Python code is consistent with the logic of the reference implementation. Both queries aim to find the city with the highest number of orders by counting 'OrderID' occurrences grouped by 'ShipCity'. They both then order the results in descending order by the count and limit the selection to the top result. The difference in naming the count as 'OrderCount' instead of 'TotalOrders' does not affect the correctness in the context of SQL execution.,both
Which product category has the highest total sales in 2023? Use a bar chart to visualize sales by category.,"```python
import plotly.express as px

# SQL query to get total sales by product category in 2023
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName 
ORDER BY total_sales DESC
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY categories.CategoryName
ORDER BY total_sales DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')
show_to_user(fig)
```","The input code is correct because it performs the same operations as the reference implementation. It calculates total sales by joining the necessary tables, filters for orders in 2023, groups by category, and orders by total sales. It then uses Plotly to create and display a bar chart of total sales by category. Any differences in table join order or column references do not affect the correctness, as they logically achieve the same outcome.","```python
import plotly.express as px
import pandas as pd

# Given SQL query to obtain sales data by product category
sql_query = """"""
SELECT CategoryID, SUM(OrderDetails.UnitPrice * OrderDetails.Quantity) AS TotalSales 
FROM categories 
JOIN products ON categories.CategoryID = products.CategoryID 
JOIN OrderDetails ON products.ProductID = OrderDetails.ProductID 
JOIN orders ON OrderDetails.OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY CategoryID 
ORDER BY TotalSales DESC
""""""

# Execute the query and get the result as a pandas DataFrame
category_sales_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(category_sales_df, x='CategoryID', y='TotalSales', title='Total Sales by Product Category in 2023')

# Display the visualization to the user
show_to_user(fig)
```","The input code provided does not calculate the discount, unlike the reference code. The reference code multiplies by (1 - [Order Details].Discount) when calculating the total sales, which accounts for any discounts applied to sales. The logic deviates from the reference code as the input code uses CategoryID for grouping and display, while the reference uses CategoryName. Additionally, missing the discount calculation means the sales figures may be overstated in the input code.",Base
What is the average reorder level across all products?,"```python
sql_query = ""SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products;""
result_df = execute_sql_query(sql_query)
average_reorder_level = result_df['AverageReorderLevel'].iloc[0]
show_to_user(average_reorder_level)
```","```python
sql_query = ""SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products""
average_reorder_level_df = execute_sql_query(sql_query)
show_to_user(average_reorder_level_df)
```","The input code does not extract the average reorder level value from the DataFrame before displaying it to the user. It passes the entire DataFrame to the show_to_user function, whereas the reference extracts a scalar value using iloc[0].","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(ReorderLevel) as AverageReorderLevel FROM products;""

# Execute the query using the provided utility function
average_reorder_level_df = execute_sql_query(sql_query)

# Extract the average reorder level from the DataFrame and convert it to a numeric value for display
average_reorder_level = average_reorder_level_df['AverageReorderLevel'].iloc[0]

# Display the result
show_to_user(pd.DataFrame({'Average Reorder Level': [average_reorder_level]}))
```","The input Python code correctly calculates the average reorder level by executing the same SQL query as the reference implementation. It extracts the result and displays it using a DataFrame, which is a valid presentation format. The logic and end result are consistent with the reference implementation.",Finetuned
What is the total inventory value of products currently in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT SUM(UnitsInStock * UnitPrice) AS TotalInventoryValue FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the total inventory value from the dataframe
total_inventory_value = df.loc[0, 'TotalInventoryValue']

# Prepare a dataframe to display
result_df = pd.DataFrame({'TotalInventoryValue': [total_inventory_value]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue 
FROM products 
WHERE Discontinued = 0
""""""
total_inventory_value = execute_sql_query(sql_query)
show_to_user(total_inventory_value)
```","The input code adds a WHERE condition filtering by 'Discontinued = 0', which is not present in the reference code. This restriction alters the result by excluding products that are discontinued from the total inventory value.","```python
# Given utility functions assumed to be available in the environment
def execute_sql_query(sql_query: str):
    # Simulated function to execute the SQL query
    # In practice, this function would interface with a database
    # Here, it's just a placeholder with no implementation
    pass

def display_to_user(data):
    # Simulated function to display the data
    # In practice, this might print, display in a GUI, etc.
    pass

# SQL query to calculate total inventory value
sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products;
""""""

# Execute the SQL query and get total inventory value
total_inventory_value = execute_sql_query(sql_query)

# Display the result to the user
display_to_user(total_inventory_value)
```","The provided code does not extract the total inventory value from a dataframe like the reference code. 'execute_sql_query' directly assigns the result to 'total_inventory_value', whereas the reference code uses a dataframe to extract and format the result before displaying it.",None
Find the average quantity of products ordered per order.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(od.Quantity) AS AverageQuantityPerOrder
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
""""""
average_quantity_per_order = execute_sql_query(sql_query)
show_to_user(average_quantity_per_order)
```","The input code calculates the average quantity per order by joining Order Details with Orders, which is not necessary for computing the overall average quantity of products ordered. The reference implementation directly computes this average from the Order Details table alone. Therefore, the logic deviates from the reference.","```python
import pandas as pd

# Function to execute an SQL query and return the results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function for executing an SQL query and returning a DataFrame
    # In a real environment, this would interface with a database
    # For now, it's assumed that this function is implemented elsewhere
    # and we have a pandas DataFrame as output
    pass

def show_to_user(data):
    # Display a single value or a DataFrame
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        print(""Result:"", data)

# SQL query to find the average quantity of products ordered per order
sql_query = """"""
    SELECT AVG(Quantity) AS AverageQuantityPerOrder
    FROM [Order Details];
""""""

# Execute the SQL query and get the results
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input Python code correctly constructs and executes an SQL query that calculates the average quantity of products ordered per order. The SQL statement uses the AVG function on the 'Quantity' column from the '[Order Details]' table, which matches the reference implementation. Additionally, the function 'show_to_user' is used to display the result, consistent with the reference implementation logic. Thus, the code correctly fulfills the business analytics request.",Finetuned
What is the percentage of orders shipped within the same country as the customer?,"```python
import pandas as pd

# SQL query to get the number of orders shipped within the same country as the customer
sql_query_same_country = """"""
SELECT COUNT(*) as count_same_country 
FROM orders o 
JOIN customers c ON o.CustomerID = c.CustomerID 
WHERE o.ShipCountry = c.Country;
""""""

# SQL query to get the total number of orders
sql_query_total_orders = """"""
SELECT COUNT(*) as total_orders 
FROM orders;
""""""

# Execute the SQL queries
result_same_country = execute_sql_query(sql_query_same_country)
result_total_orders = execute_sql_query(sql_query_total_orders)

# Calculate the percentage of orders shipped within the same country
percentage_same_country = (result_same_country['count_same_country'][0] / result_total_orders['total_orders'][0]) * 100

# Prepare the result for display
result_df = pd.DataFrame({'percent_same_country': [percentage_same_country]})

# Use the show_to_user function to display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(*) AS total_orders,
    SUM(CASE WHEN customers.Country = orders.ShipCountry THEN 1 ELSE 0 END) AS domestic_shipments
FROM 
    orders
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
""""""

result_df = execute_sql_query(sql_query)

percentage_domestic = (result_df['domestic_shipments'].iloc[0] / result_df['total_orders'].iloc[0]) * 100
percentage_df = pd.DataFrame({'Percentage of Domestic Shipments': [percentage_domestic]})

show_to_user(percentage_df)
```","The input code correctly calculates the percentage of orders shipped within the same country as the customers. It joins the orders and customers tables, counts the total orders, and sums the orders where the customer's country matches the shipment country. Then, it computes the percentage using these counts, which aligns logically with the reference code's intent.","```python
def execute_sql_query(sql_query: str):
    # Placeholder for executing the SQL query and returning the result
    # This function should be implemented to connect to the database,
    # execute the query and fetch the result.
    pass

def show_to_user(data):
    # Placeholder for displaying the data
    # This function should be implemented to show the results
    pass

# SQL query to get the percentage of orders shipped within the same country
sql_query = """"""
SELECT 
    (COUNT(orderID) * 100.0 / (SELECT COUNT(*) FROM orders)) AS percentInCountry 
FROM 
    orders 
WHERE 
    ShipCountry = ShipAddressCountry
""""""

# Execute the SQL query and store the result
result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result)
```","The input Python code assumes that there is a column 'ShipAddressCountry' in the 'orders' table, which is not present in the reference implementation where 'ShipCountry' is compared to 'Country' from the 'customers' table. Furthermore, the input code misses the JOIN operation between 'orders' and 'customers' to access the 'Country' field. Thus, it does not adhere to the same logic as the reference implementation.",Base
List all employees who were hired this year.,"```python
from datetime import datetime
import pandas as pd

# Construct the SQL query
current_year = datetime.now().year
sql_query = f""SELECT * FROM employees WHERE YEAR(HireDate) = {current_year};""

# Execute the SQL query and retrieve data
employees_hired_this_year = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_hired_this_year)
```","```python
from datetime import datetime
import pandas as pd

current_year = datetime.now().year
sql_query = f""""""
SELECT EmployeeID, FirstName, LastName, HireDate 
FROM employees 
WHERE YEAR(HireDate) = {current_year}
""""""

employees_hired_this_year = execute_sql_query(sql_query)
show_to_user(employees_hired_this_year)
```",The input Python code correctly implements the business request by selecting employees who were hired this year. The logic aligns with the reference implementation as it constructs a SQL query to filter employees based on the current year of the hire date. The minor difference in selecting specific columns instead of all columns does not affect the correctness regarding the business request.,"```python
import pandas as pd
from datetime import datetime

# Assuming this is already defined in your environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function body
    pass

# Assuming this is already defined in your environment
def show_to_user(data: pd.DataFrame):
    # Placeholder function body
    pass

# Define the current year
current_year = datetime.now().year

# SQL query to fetch employees hired this year
sql_query = f""""""
SELECT *
FROM employees
WHERE YEAR(hire_date) = {current_year};
""""""

# Execute the SQL query
employees_hired_this_year = execute_sql_query(sql_query)

# Display the results
show_to_user(employees_hired_this_year)
```","The provided Python code correctly implements the required functionality of listing all employees hired this year. It constructs a SQL query that selects all records from the 'employees' table where the year of the 'hire_date' matches the current year. This logic aligns with that of the reference implementation, despite minor syntactical differences such as using a multiline string for the SQL query.",both
What is the total revenue generated each year? Visualize the trends with a line graph.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS YearlyRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Year 
ORDER BY Year;
""""""

# Execute the SQL query
dataframe = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(dataframe, x='Year', y='YearlyRevenue', title='Total Revenue Generated Each Year', labels={'YearlyRevenue': 'Revenue'})

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    YEAR(o.OrderDate) AS OrderYear,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    YEAR(o.OrderDate)
ORDER BY 
    OrderYear;
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.line(revenue_data, x='OrderYear', y='TotalRevenue', title='Total Revenue Generated Each Year')
show_to_user(fig)
```","The input code correctly implements the business analytics request by calculating the total revenue generated each year using a SQL query and visualizing it with a line graph using Plotly. Similar to the reference code, it extracts the year from the order date, computes the revenue by multiplying unit price, quantity, and applying the discount, then groups and orders the results by year. Both implementations produce a line graph to visualize the data. The differences in table aliasing or column naming in the SQL query do not affect the overall logic or output.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT EXTRACT(YEAR FROM orders.OrderDate) AS OrderYear, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Revenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY EXTRACT(YEAR FROM orders.OrderDate);
""""""

# Execute the SQL query and get the results into a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a line graph to visualize the trends over the years
fig = px.line(df, x='OrderYear', y='Revenue', title='Total Revenue Generated Each Year')

# Display the line graph using the provided utility function
show_to_user(fig)
```",The provided input code correctly calculates the total revenue generated each year using SQL to extract the year from the OrderDate and calculates the revenue using the same logic as the reference. It also generates a line plot using Plotly to visualize the trends. The differences in variable names ('OrderYear' vs 'Year' and 'Revenue' vs 'YearlyRevenue') do not affect the correctness of the logic or output. Both implementations achieve the same business analytics requirement effectively.,both
Find the total quantity ordered for each product. Use a bar chart for better visualization.,"```python
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, SUM(Quantity) AS total_quantity FROM [Order Details] GROUP BY ProductID;""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='total_quantity', title='Total Quantity Ordered by Product')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.Quantity) AS TotalQuantity
FROM 
    [Order Details] od
GROUP BY 
    od.ProductID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductID', y='TotalQuantity', title='Total Quantity Ordered for Each Product')
show_to_user(fig)
```","The input code correctly implements the business analytics request. It executes an SQL query to sum the quantities for each product, groups by ProductID, and uses Plotly to create a bar chart. The logic and intent align with the reference, despite minor differences in variable naming (e.g., `TotalQuantity` vs. `total_quantity`).","```python
import plotly.express as px

# Given utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function; in an actual scenario, this would execute the SQL query.
    pass

def show_to_user(data):
    # Placeholder function; would display a DataFrame or Plotly figure.
    pass

# SQL query to get the total quantity ordered for each product
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
GROUP BY ProductID
""""""

# Execute the given SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalQuantityOrdered', 
             title='Total Quantity Ordered for Each Product', 
             labels={'TotalQuantityOrdered': 'Total Quantity Ordered', 'ProductID': 'Product ID'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly follows the logic and business requirement outlined in the reference code. Both implementations execute a SQL query to retrieve the total quantity ordered for each product, group the results by 'ProductID', create a bar chart using Plotly, and display it. Minor differences in variable names or chart label customization do not affect the overall functionality and correctness of the implementation.",both
How many orders have been placed by customers in Germany in the year 2023?,"```python
import pandas as pd

# SQL query to fetch order count
sql_query = """"""
SELECT COUNT(o.OrderID) as OrderCount 
FROM orders o 
JOIN customers c ON o.CustomerID = c.CustomerID 
WHERE c.Country = 'Germany' 
AND o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
order_count_df = execute_sql_query(sql_query)

# Display the result
show_to_user(order_count_df['OrderCount'][0])
```","```python
sql_query = """"""
SELECT COUNT(orders.OrderID) AS order_count 
FROM orders 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE customers.Country = 'Germany' 
AND YEAR(orders.OrderDate) = 2023
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","Both the input code and the reference implementation correctly count the number of orders placed by customers in Germany during 2023. The input code uses the SQL function `YEAR(orders.OrderDate) = 2023` to filter orders, while the reference code uses `BETWEEN '2023-01-01' AND '2023-12-31'`, but both approaches correctly filter for the same year. Additionally, the result is correctly displayed using `show_to_user` in both implementations.","```python
import pandas as pd

# Sample execution function to demonstrate the request handling
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This would be your database connection and query execution logic
    # Here, we'll simulate it with a sample DataFrame
    data = {'OrderCount': [120]}  # Simulated result
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        print(data)

# SQL query to count the number of orders from Germany in 2023
sql_query = """"""
SELECT COUNT(o.OrderID) AS OrderCount 
FROM orders o 
JOIN customers c ON o.CustomerID = c.CustomerID 
WHERE c.Country = 'Germany' AND YEAR(o.OrderDate) = 2023;
""""""

# Executing the SQL query using the provided function
order_count_df = execute_sql_query(sql_query)

# Showing the result to the user
show_to_user(order_count_df)
```","The evaluated Python code uses the condition 'YEAR(o.OrderDate) = 2023;' which may lead to performance issues compared to 'BETWEEN '2023-01-01' AND '2023-12-31''. Additionally, the `show_to_user` function checks if the input is a DataFrame, but the reference implementation directly accesses and displays the 'OrderCount' value.",Base
Calculate the average age of employees.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT BirthDate FROM employees;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the average age
df['Age'] = (pd.to_datetime('today') - pd.to_datetime(df['BirthDate'])) / pd.Timedelta(days=365.25)
avg_age = df['Age'].mean()

# Display the result to the user
show_to_user(pd.DataFrame({'AvgAge': [avg_age]}))
```","```python
import pandas as pd

sql_query = """"""
SELECT AVG(DATEDIFF(CURDATE(), BirthDate) / 365.25) AS AverageAge
FROM employees
""""""

average_age_df = execute_sql_query(sql_query)
show_to_user(average_age_df)
```","The input code calculates the average age directly using an SQL query that employs DATEDIFF to calculate the difference between the current date and BirthDate, dividing by 365.25 to convert it to years. This is equivalent to the logic applied in the reference code, which performs the age calculation in Python after retrieving the data. Both methods calculate the average age of employees correctly and adhere to the same logic.","
```python
import pandas as pd

# Simulated function to execute an SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for the sake of this example
    # Replace with actual database connection and execution logic
    return pd.DataFrame({
        'birth_date': [
            pd.Timestamp('1980-01-01'),
            pd.Timestamp('1990-06-15'),
            pd.Timestamp('1975-03-22')
        ]
    })

# Simulated function to display data or result
def show_to_user(data):
    print(data)

# SQL query to fetch employee birth dates
sql_query = ""SELECT birth_date FROM employees WHERE birth_date IS NOT NULL""

# Execute the query and get a DataFrame
df_employees = execute_sql_query(sql_query)

# Calculate average age
current_date = pd.Timestamp.now()
df_employees['age'] = (current_date - df_employees['birth_date']).dt.days / 365.25
average_age = df_employees['age'].mean()

# Display the average age to the user
show_to_user(pd.DataFrame({'Average Age': [average_age]}))
```","Both the provided code and the reference implementation calculate the average age of employees by fetching birth dates, computing the age using the difference from the current date, and averaging these values. The differences such as column name ('birth_date' vs 'BirthDate') and methods (e.g., `pd.Timestamp.now()` vs `pd.to_datetime('today')`) do not affect the logic. Therefore, the code is correct as it implements the same logic as the reference.",both
What is the total discount given on orders placed in 2022?,"```python
import pandas as pd

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract total_discount from the dataframe
total_discount = result_df['total_discount'].iloc[0]

# Show the result to the user
show_to_user(total_discount)
```","```python
sql_query = """"""
SELECT SUM([Order Details].Discount) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

total_discount_df = execute_sql_query(sql_query)
show_to_user(total_discount_df)
```","The input code fetches the result of the SQL query and directly shows the entire DataFrame to the user, while the reference code extracts a specific value ('total_discount') before displaying it. The input code does not correctly extract and display just the total discount amount.","
```python
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function to simulate SQL execution
    # Dummy implementation, replace with actual database connection and execution
    # Assuming the function returns a DataFrame
    pass

def show_to_user(data):
    # Mock function to simulate displaying data
    # Replace with actual display logic
    pass

def calculate_total_discount():
    # SQL query to execute
    sql_query = """"""
    SELECT SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscount
    FROM orders o
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    WHERE YEAR(o.OrderDate) = 2022;
    """"""
    
    # Execute the SQL query and get the result in a DataFrame
    discount_df = execute_sql_query(sql_query)
    
    # Ensure TotalDiscount is available and show to user
    if not discount_df.empty:
        show_to_user(discount_df)
    else:
        print(""No data available"")

# Execute the function
calculate_total_discount()
```
","The input code correctly calculates the total discount for orders placed in 2022. However, it fails to extract and display just the 'TotalDiscount' value. Instead, it displays the entire DataFrame 'discount_df', which is inconsistent with the reference implementation that extracts and shows only 'total_discount'.",None
Which customer region had the highest average order fulfillment time in the past month? Include a heat map for regional comparison.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
WHERE OrderDate >= CURDATE() - INTERVAL 1 MONTH 
GROUP BY ShipRegion 
ORDER BY AvgFulfillmentTime DESC;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a heat map for regional comparison
fig = px.density_heatmap(df, x='ShipRegion', y='AvgFulfillmentTime', 
                         z='AvgFulfillmentTime',
                         color_continuous_scale='Viridis', 
                         title='Average Order Fulfillment Time by Region')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve order fulfillment time by region for the past month
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
GROUP BY ShipRegion
ORDER BY AvgFulfillmentTime DESC
""""""

# Execute the SQL query
fulfillment_data = execute_sql_query(sql_query)

# Identify the region with the highest average order fulfillment time
highest_region = fulfillment_data.iloc[0]

# Create a heatmap for regional comparison
fig = px.imshow(
    fulfillment_data.pivot(index='ShipRegion', values='AvgFulfillmentTime'),
    labels=dict(x=""Regions"", y=""Average Fulfillment Time (days)"", color=""Average Fulfillment Time""),
    title=""Average Order Fulfillment Time by Region (Last Month)""
)

# Display the heat map
show_to_user(fig)

# Print the region with the highest average order fulfillment time
highest_region
```","The input Python code uses `px.imshow` for creating a heatmap, which is not appropriate for handling the dataset as `imshow` is designed for image-like data. The reference uses `px.density_heatmap`, tailored for density plots which is more suitable here. Also, the input code involves a pivot operation on a series without a complete pivot table creation, potentially leading to an error. The logic for displaying data is incorrect, leading to visualization issues.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT c.Region, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgFulfillmentTime
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE)
GROUP BY c.Region
""""""

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# Find the region with the highest average order fulfillment time
highest_region = data.loc[data['AvgFulfillmentTime'].idxmax()]

# Display the region with the highest average fulfillment time
highest_region_df = pd.DataFrame([highest_region])
show_to_user(highest_region_df)

# Create a heatmap for regional comparison
fig = px.imshow(data.pivot(index='Region', columns='AvgFulfillmentTime', values='AvgFulfillmentTime'),
                color_continuous_scale='YlGnBu', 
                title='Average Order Fulfillment Time by Region')

# Show the heatmap
show_to_user(fig)
```","The input code and the reference code are similar in their goal but differ in several key aspects: 1) The input code uses a JOIN to include customer regions, which implies regions are stored separately, unlike the direct use of ShipRegion in the reference. This assumes different schema or additional tables. 2) The input code lacks ordering by AvgFulfillmentTime, which is essential for deriving the 'highest' region if not explicitly found otherwise. 3) The heatmap implementation improperly pivots on AvgFulfillmentTime, which is incorrect compared to the density heatmap used in the reference code. Correct logic and visualizations need alignment with the reference implementation for accurate results.",None
What is the average price per unit of all products?,"```python
import pandas as pd

# SQL query to calculate the average price per unit of all products
sql_query = ""SELECT AVG(UnitPrice) AS AveragePrice FROM products;""

# Execute the SQL query and get the result in a dataframe
df = execute_sql_query(sql_query)

# Display the average price to the user
average_price = df.at[0, 'AveragePrice']
show_to_user(pd.DataFrame({'Average Price': [average_price]}))
```","```python
sql_query = """"""
SELECT AVG(UnitPrice) AS AveragePricePerUnit
FROM products
WHERE Discontinued = 0
""""""

average_price_per_unit = execute_sql_query(sql_query)
show_to_user(average_price_per_unit)
```","The input code filters the products by `Discontinued = 0`, which restricts the calculation to non-discontinued products. The reference code calculates the average for all products without applying this filter.","```python
# Given that execute_sql_query and show_to_user are predefined functions, here is the implementation:

# SQL query to retrieve the average price per unit of all products
sql_query = ""SELECT AVG(UnitPrice) AS AveragePricePerUnit FROM products;""

# Execute the SQL query
average_price_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_price_df)
```",The input code correctly calculates the average unit price using an SQL query that is equivalent to the reference implementation. It retrieves the average price with a column name 'AveragePricePerUnit' and displays the result using the predefined function 'show_to_user'. The different naming of the column does not affect the correctness of the logic.,Finetuned
Find the average order value for each customer. Use a histogram to visualize the distribution.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT c.CustomerID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) as average_order_value 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute SQL query to get data
df = execute_sql_query(sql_query)

# Create histogram to visualize distribution of average order value
fig = px.histogram(df, x='average_order_value', nbins=30, title=""Distribution of Average Order Value per Customer"")

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue
FROM 
    customers AS c
JOIN 
    orders AS o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID
""""""

customer_order_values = execute_sql_query(sql_query)

average_order_value = customer_order_values['TotalOrderValue'].mean()

histogram = px.histogram(customer_order_values, x='TotalOrderValue', title='Distribution of Total Order Values', 
                         labels={'TotalOrderValue': 'Total Order Value'})

show_to_user(histogram)
```","The provided input code calculates and visualizes the total order value rather than the average order value per customer. The reference implementation averages the order values per customer before creating the histogram, which aligns with the requested business analytics task.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT c.CustomerID, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query to get the DataFrame
customer_avg_order_df = execute_sql_query(sql_query)

# Create a histogram to visualize the distribution of average order values
fig = px.histogram(customer_avg_order_df, x='AverageOrderValue', nbins=20, 
                   title='Distribution of Average Order Value by Customer', 
                   labels={'AverageOrderValue': 'Average Order Value'})

# Show the histogram to the user
show_to_user(fig)
```","The input code correctly executes a SQL query to calculate the average order value for each customer, similar to the reference implementation. Both scripts use an SQL query to aggregate `UnitPrice`, `Quantity`, and `Discount` to compute the average order value per customer. The histogram is created using Plotly Express in both cases, only differing in some parameters like the number of bins and labels, which do not affect the correctness relative to the business request. The main logical operations are consistent between the two pieces of code.",Finetuned
What is the on-time delivery rate for the month of April 2023? Visualize the results with a pie chart.,"```python
import plotly.express as px

# The SQL query to get the on-time delivery rate
sql_query = """"""
SELECT COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Extract the on-time delivery rate from the dataframe
on_time_delivery_rate = df.loc[0, 'on_time_delivery_rate']

# Create a pie chart to visualize the on-time delivery rate
data = {'On-Time': on_time_delivery_rate, 'Late': 1 - on_time_delivery_rate}
labels = list(data.keys())
values = list(data.values())

fig = px.pie(names=labels, values=values, title=""On-Time Delivery Rate for April 2023"")

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the on-time delivery rate for April 2023
sql_query = """"""
SELECT 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS on_time,
    COUNT(OrderID) AS total_orders
FROM 
    orders
WHERE 
    OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
""""""

# Execute the SQL query
delivery_data = execute_sql_query(sql_query)

# Calculate on-time delivery rate
on_time_rate = delivery_data['on_time'][0] / delivery_data['total_orders'][0] if delivery_data['total_orders'][0] > 0 else 0
not_on_time_rate = 1 - on_time_rate

# Data for pie chart
labels = ['On-time Deliveries', 'Late Deliveries']
values = [on_time_rate, not_on_time_rate]

# Create pie chart
fig = px.pie(values=values, names=labels, title='On-time Delivery Rate for April 2023')

# Show the result to user
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate for April 2023. It uses a SQL query to count on-time and total orders, calculates the rate, and then uses Plotly to create a pie chart. This aligns with the logic in the reference implementation, though the approach differs slightly by using a CASE statement instead of FILTER in SQL.","import pandas as pd
import plotly.express as px

# Business Analysis Request
def calculate_on_time_delivery_rate():
    # Define the SQL query
    sql_query = """"""
    SELECT 
        (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) /
        COUNT(OrderID)) * 100 AS OnTimeDeliveryRate
    FROM orders
    WHERE EXTRACT(MONTH FROM ShippedDate) = 4 AND EXTRACT(YEAR FROM ShippedDate) = 2023;
    """"""
    
    # Execute the SQL query and get the result as a DataFrame
    result_df = execute_sql_query(sql_query)
    
    # Extracting the on-time delivery rate value
    on_time_rate = result_df['OnTimeDeliveryRate'].iloc[0]
    
    # Calculating the late delivery rate
    late_rate = 100 - on_time_rate
    
    # Creating a DataFrame for visualization
    rate_df = pd.DataFrame({
        'Delivery Status': ['On-Time', 'Late'],
        'Rate': [on_time_rate, late_rate]
    })
    
    # Create a pie chart using Plotly
    fig = px.pie(rate_df, names='Delivery Status', values='Rate',
                 title='On-Time Delivery Rate for April 2023',
                 color_discrete_sequence=['blue', 'red'])
    
    # Display the pie chart to the user
    show_to_user(fig)

# Assuming this utility function exists
calculate_on_time_delivery_rate()","Both the reference and input code correctly calculate the on-time delivery rate and visualize it using a pie chart. The reference code uses a SQL filter operation while the input code uses a CASE statement, but both effectively count on-time and total orders correctly. The input code multiplies by 100 for percentage, aligning with the visualization that uses whole numbers. The visualization logic matches, using the same delivery status categories.",both
What is the on-time delivery rate for each month in 2023? Represent findings using a line chart to observe trends over the months.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE NULL END) * 1.0 / COUNT(*) AS on_time_delivery_rate 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the dataframe by month to ensure correct order in the plot
df['month'] = pd.to_datetime(df['month'], format='%Y-%m')
df = df.sort_values(by='month')

# Create a line chart to represent on-time delivery rate over the months
fig = px.line(df, x='month', y='on_time_delivery_rate', title='On-Time Delivery Rate for Each Month in 2023', labels={'on_time_delivery_rate': 'On-Time Delivery Rate', 'month': 'Month'})

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeDeliveries
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2023
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

data = execute_sql_query(sql_query)
data['OnTimeDeliveryRate'] = data['OnTimeDeliveries'] / data['TotalOrders'] * 100

fig = px.line(data, x='Month', y='OnTimeDeliveryRate', title='On-Time Delivery Rate for Each Month in 2023')
show_to_user(fig)
```","Both implementations aim to calculate the on-time delivery rate for each month in 2023 by checking if the ShippedDate is less than or equal to the RequiredDate. The input code calculates the total orders and on-time deliveries separately, then computes the delivery rate by dividing these two counts, which is equivalent in logic to the reference implementation. The resulting plot, a line chart showing the delivery rate over months, is also consistent between both codes.","```python
import pandas as pd
import plotly.express as px

# Given SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month,
       (SUM(ShippedDate <= RequiredDate) / COUNT(OrderID)) * 100 AS on_time_rate
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a line chart to observe trends
fig = px.line(df, x='month', y='on_time_rate', title='On-Time Delivery Rate for Each Month in 2023')

# Display the chart
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate by using a similar logic as the reference code. Both codes group the data by month for the year 2023 and calculate the on-time delivery rate by comparing ShippedDate to RequiredDate. The difference in calculation method (using SUM() vs. COUNT(CASE WHEN)) achieves the same result, which is a rate representing on-time deliveries. The data is then visualized using a line chart with Plotly Express, observing trends over the months. Therefore, the input code is consistent with the reference implementation's logic and business analytics request.",both
Visualize the total number of units on order for each product in 2022 using a bar chart to compare across products.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].UnitsOnOrder) AS units_on_order
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ProductID', y='units_on_order', title='Units on Order for Each Product in 2022', labels={'units_on_order':'Units on Order'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total units on order for each product in 2022
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_units_on_order
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID, products.ProductName
""""""

# Execute the SQL query and store the result in a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ProductName', y='total_units_on_order', title='Total Units on Order for Each Product in 2022')

# Show the figure to the user
show_to_user(fig)
```","The code to evaluate uses 'SUM([Order Details].Quantity)' instead of 'SUM([Order Details].UnitsOnOrder)', which is the measure used in the reference code. This results in a different calculation since the business request specifies units on order, not quantity. Additionally, while it adds 'ProductName' for the x-axis, which may help readability, the queried column should remain consistent with the reference to ensure the correct metric is visualized.","```python
import pandas as pd
import plotly.express as px

# Utility Function Definitions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function body
    # In a real environment, this would connect to a database and execute the query
    pass

def show_to_user(data):
    # Placeholder function body
    # In a real environment, this would display a DataFrame or Plotly figure to the user
    pass

# SQL Query
sql_query = """"""
SELECT ProductID, SUM(UnitsOnOrder) AS Totals 
FROM products 
WHERE YEAR(OrderDate) = 2022 
GROUP BY ProductID
""""""

# Execute the query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='Totals', title='Total Units on Order per Product in 2022')

# Display the chart
show_to_user(fig)
```","The input code's SQL query does not correctly implement the business analytics request. It fails to join the 'Order Details' and 'orders' tables, which are necessary to sum the 'UnitsOnOrder' based only on orders placed in the year 2022. The input code incorrectly applies the 'WHERE' condition directly to the 'products' table without considering the 'OrderDate' from the 'orders' table, missing important filtering from the reference implementation.",None
What are the names and prices of products that have less than 20 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""

# Execute the query and retrieve the results in a dataframe
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)
```","```python
sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE UnitsInStock < 20
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly follows the logic of the reference implementation. It constructs and executes the same SQL query to select the 'ProductName' and 'UnitPrice' from 'products' where 'UnitsInStock' is less than 20, and then displays the result. The implementations differ only in formatting style, not in logic or functionality.","```python
# SQL query to fetch product names and prices with less than 20 units in stock
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""

# Execute the query using the utility function and store the result in a DataFrame
df_products_low_stock = execute_sql_query(sql_query)

# Display the result
show_to_user(df_products_low_stock)
```","The input code correctly follows the logic of the reference implementation. It uses the same SQL query to select product names and prices with less than 20 units in stock, executes this query, and displays the results. The variable names differ but do not affect the correctness of the implementation.",both
Calculate the total quantity of products sold per product category. Use a pie chart to display the proportion of sales across categories.,"```python
import plotly.express as px

# SQL query to calculate total quantity sold per product category
sql_query = '''
SELECT CategoryID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY CategoryID
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a pie chart
fig = px.pie(df, names='CategoryID', values='TotalQuantity', title='Total Quantity Sold per Product Category')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductCategory, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductCategory
""""""

data = execute_sql_query(sql_query)

fig = px.pie(data, values='TotalQuantity', names='ProductCategory', title='Total Quantity of Products Sold per Category')
show_to_user(fig)
```","The input code and reference code both correctly calculate the total quantity of products sold per product category and display a pie chart of the results. The input code uses different table aliases and a different chart library, but logically it performs the same operations: executing an SQL query to sum product quantities by category and displaying the result using a pie chart. The differences do not affect the correctness concerning the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch product sales per category
sql_query = """"""
SELECT c.CategoryID, SUM(od.Quantity) AS TotalProductSold
FROM products p
INNER JOIN [Order Details] od ON p.ProductID = od.ProductID
INNER JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID;
""""""

# Execute the SQL query and get the results into a DataFrame
category_sales_df = execute_sql_query(sql_query)

# Create a pie chart using Plotly
fig = px.pie(
    category_sales_df,
    names='CategoryID',
    values='TotalProductSold',
    title='Proportion of Total Products Sold by Category',
    hover_data=['TotalProductSold'],
)

# Display the pie chart
show_to_user(fig)
```","The input Python code correctly computes the total quantity of products sold per category by making a similar SQL query as in the reference. It uses two INNER JOINs to link products, order details, and categories, which aligns with the reference code's logic. The resulting DataFrame is used to create a pie chart displaying the proportion of sales across categories. The pie chart implementation (using Plotly) and the display mechanism (show_to_user) are consistent with the reference example.",both
List all orders that were shipped to Germany.,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT * FROM orders WHERE ShipCountry = 'Germany';""

# Execute the query and get the data
orders_to_germany_df = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(orders_to_germany_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE ShipCountry = 'Germany'
""""""
orders_shipped_to_germany = execute_sql_query(sql_query)
show_to_user(orders_shipped_to_germany)
```","The input code correctly executes a SQL query that selects all columns from the 'orders' table where 'ShipCountry' is 'Germany'. It matches the logic of the reference implementation by retrieving and displaying the relevant orders, despite differences in format and variable names.","```python
import pandas as pd

# Define the SQL query to select orders shipped to Germany
sql_query = """"""
SELECT OrderID 
FROM orders 
WHERE ShipCountry = 'Germany';
""""""

# Execute the query using the utility function to get the result as a DataFrame
germany_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(germany_orders_df)
```","The input code selects only the 'OrderID' column, while the reference code selects all columns using '*'. The input does not match the logic of the reference implementation because it's not retrieving the complete order details.",Base
Who are the top 3 employees based on total sales generated? Use a bar chart to compare their performance.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 employees by total sales
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Top 3 Employees by Total Sales')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales generated by each employee
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, EmployeeName
ORDER BY TotalSales DESC
LIMIT 3
""""""

# Execute the SQL query and retrieve the data
top_employees_sales = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 employees based on total sales
fig = px.bar(top_employees_sales, x='EmployeeName', y='TotalSales', 
             title='Top 3 Employees Based on Total Sales', 
             labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code and the reference code are both executing a SQL query to determine the top 3 employees by total sales and then creating a bar chart to visualize it. Although the input code includes an additional column 'EmployeeName' and uses it for labeling the chart, it adheres to the same logic of calculating and sorting by 'TotalSales'. Therefore, the input code correctly satisfies the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 3 employees based on total sales
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 3;
""""""

# Execute the SQL query and fetch the result into a DataFrame
top_employees_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 3 employees' sales
fig = px.bar(top_employees_df, 
             x='EmployeeID', 
             y='total_sales', 
             title='Top 3 Employees by Total Sales',
             labels={'total_sales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Show the bar chart
show_to_user(fig)
```","The input code accurately follows the logic and intent of the reference implementation. Both SQL queries select the top 3 employees based on total sales by joining 'Order Details', 'orders', and 'employees' tables, summing up the product of unit price, quantity, and discount, grouping by EmployeeID, and ordering by total sales in descending order. They also each use Plotly Express to create a bar chart visualizing the results, ensuring consistency with titles and axis labels. Therefore, the input code is deemed correct.",both
What are the total sales for each product? Visualize with a bar chart for easy comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName;
""""""

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Visualize the results with a bar chart
fig = px.bar(df, x='ProductName', y='TotalSales', title='Total Sales per Product')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales for each product
sql_query = """"""
SELECT 
    p.ProductName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
GROUP BY 
    p.ProductName
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Visualize the total sales with a bar chart
fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Total Sales for Each Product', labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly executes an SQL query to calculate total sales for each product by joining the 'Order Details' and 'products' tables, groups by product name, and sums the sales as per the business logic. It uses Plotly Express to create a bar chart similar to the reference code, achieving the same result and visualization. The syntax differences in aliases and function calls (like labels) do not affect the correctness of the solution.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales for each product
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalSales
FROM orders
GROUP BY ProductID;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalSales', 
             title='Total Sales for Each Product', 
             labels={'TotalSales': 'Total Sales', 'ProductID': 'Product ID'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code calculates total sales by summing quantities per ProductID directly from an 'orders' table, which does not account for unit prices and discounts as done in the reference. The reference code calculates total sales by joining 'Order Details' with 'products', then multiplying unit prices, quantities, and discount factors. The input SQL logic is thus incorrect as it does not implement the same computation for sales.",Base
List the orders that have not been shipped within the required date.,"```python
import pandas as pd

# Define the SQL query to get the orders that have not been shipped within the required date
sql_query = """"""
SELECT orders.OrderID, orders.RequiredDate, orders.ShippedDate
FROM orders
WHERE orders.ShippedDate IS NULL OR orders.ShippedDate > orders.RequiredDate;
""""""

# Execute the query and get the result in a pandas DataFrame
orders_df = execute_sql_query(sql_query)

# Use the show_to_user function to display the result
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE ShippedDate IS NULL AND RequiredDate < CURRENT_DATE
""""""
unshipped_orders = execute_sql_query(sql_query)
show_to_user(unshipped_orders)
```","The provided code only checks for orders where 'ShippedDate' is NULL and 'RequiredDate' is less than the current date, which captures orders that are late but not all unshipped ones. It misses orders where 'ShippedDate' is greater than 'RequiredDate' indicating they were shipped late. The reference code handles both situations—unshipped orders and orders shipped after the required date.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT orders.OrderID 
FROM orders 
WHERE orders.RequiredDate < orders.ShippedDate;
""""""

# Execute the query and retrieve the data
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)
```","The input code only considers orders where 'RequiredDate' is less than 'ShippedDate', missing the case where 'ShippedDate' is NULL. The reference code correctly handles both conditions by including orders with 'ShippedDate' as NULL or greater than 'RequiredDate'.",None
How many products have been discontinued?,"```python
import pandas as pd

# SQL query to count discontinued products
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE products.Discontinued = 1""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df.iloc[0])
```","```python
sql_query = ""SELECT COUNT(*) AS discontinued_count FROM products WHERE Discontinued = 1""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","The provided code constructs a SQL query that counts products marked as 'Discontinued' and executes this query using 'execute_sql_query'. The logic and intent are consistent with the reference code, as both generate and execute a query to count discontinued products in the 'products' table. The result is then displayed using 'show_to_user', just like in the reference implementation.","```python
# Given SQL query to find discontinued products
sql_query = ""SELECT COUNT(*) FROM products WHERE Discontinued = 1;""

# Execute the SQL query using the provided utility function
result = execute_sql_query(sql_query)

# Extract the count of discontinued products
discontinued_count = result.iloc[0, 0]

# Display the count to the user
show_to_user(discontinued_count)
```","The input code constructs and executes an SQL query to count the discontinued products, using the Discontinued flag equals 1. It then extracts the result and displays it to the user. This logic aligns with the reference implementation.",both
What are the total units ordered for each supplier? Show with a bar chart to highlight key suppliers.,"```python
import plotly.express as px

# SQL query as per the business request
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered for Each Supplier')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalUnitsOrdered DESC
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered by Supplier', labels={'TotalUnitsOrdered': 'Total Units Ordered', 'SupplierID': 'Supplier ID'})
show_to_user(fig)
```","The input Python code correctly calculates the total units ordered for each supplier and creates a bar chart to display the results. It uses the same logic as the reference code: joining the 'products' and 'Order Details' tables to aggregate quantities by 'SupplierID'. The order of results (using DESC) doesn't affect the correctness of the bar chart. Hence, the input code fulfills the business analytics request and follows the logical steps of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the data
sql_query = """"""
SELECT suppliers.CompanyName, SUM([Order Details].Quantity) AS TotalUnitsOrdered 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.CompanyName;
""""""

# Fetch data using the utility function
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(
    data, 
    x='CompanyName', 
    y='TotalUnitsOrdered',
    title='Total Units Ordered for Each Supplier',
    labels={'TotalUnitsOrdered': 'Total Units Ordered', 'CompanyName': 'Supplier'},
    color='TotalUnitsOrdered',
    color_continuous_scale=px.colors.sequential.Viridis
)

# Show the bar chart
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. Both codes calculate the total units ordered for each supplier by summing the quantities from the 'Order Details' table and grouping by supplier identifier. The input code groups by 'CompanyName' instead of 'SupplierID', which is valid as it still represents the suppliers. Both implementations visualize the results in a bar chart using Plotly. Thus, the input code adheres to the business request and reference logic.",both
Identify the orders that were placed but never shipped in 2022.,"```python
import pandas as pd

# SQL query to find orders placed but never shipped in 2022
sql_query = """"""
SELECT OrderID FROM orders WHERE ShippedDate IS NULL AND YEAR(OrderDate) = 2022
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT *
FROM orders
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
AND ShippedDate IS NULL
""""""
unshipped_orders = execute_sql_query(sql_query)
show_to_user(unshipped_orders)
```","The input code identifies orders placed in 2022 with a null shipping date, matching the logic of the reference implementation. The difference in date filtering (BETWEEN vs. YEAR function) does not affect correctness.","```python
import pandas as pd

# SQL query to find orders that were placed but never shipped in 2022
sql_query = """"""
SELECT o.OrderID, o.OrderDate FROM orders o
LEFT JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.ShippedDate IS NULL AND YEAR(o.OrderDate) = 2022;
""""""

# Execute the SQL query
orders_not_shipped = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_not_shipped)
```","The provided code correctly identifies orders that were placed but never shipped in 2022. It joins the 'orders' table with '[Order Details]' using a LEFT JOIN; however, the 'ShippedDate' is checked against 'od' (Order Details) when it should be directly against the 'orders' table. Despite this, it maintains the intended logic as it still filters records with a null 'ShippedDate' and 'OrderDate' in 2022, aligning with the reference implementation's purpose.",both
What is the total revenue generated by each customer? Visualize using a bar chart to identify key customers.,"```python
import plotly.express as px

# SQL query to get total revenue by customer
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the query to get the data
revenue_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(revenue_df, x='CustomerID', y='TotalRevenue', title='Total Revenue by Customer')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalRevenue DESC
""""""

revenue_df = execute_sql_query(sql_query)

fig = px.bar(revenue_df, x='CompanyName', y='TotalRevenue', 
             title='Total Revenue Generated by Each Customer', 
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The evaluated code correctly calculates the total revenue per customer using the SQL query. It includes an additional ‘CompanyName’ field, which does not affect the key calculation of 'TotalRevenue'. The bar chart uses 'CompanyName' instead of 'CustomerID' but still fulfills the business requirement to visualize revenue per customer. Thus, the code's logic aligns with the reference implementation's intent.","```python
import plotly.express as px
import pandas as pd

#SQL Query
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
INNER JOIN orders o ON c.CustomerID = o.CustomerID 
INNER JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID
""""""

# Execute the SQL query and get the results in a DataFrame
data_frame = execute_sql_query(sql_query)

# Create a bar chart to visualize total revenue by customer
fig = px.bar(data_frame, x='CustomerID', y='TotalRevenue', title='Total Revenue by Customer')

# Display the bar chart
show_to_user(fig)
```","The input Python code evaluates the total revenue generated by each customer using SQL, just like the reference implementation. Both codes perform the same SQL query to calculate revenue and utilize Plotly to create a bar chart visualizing revenue by customer. The input uses 'INNER JOIN' while the reference uses 'JOIN', but both are equivalent in this context. The functions to execute the SQL query and display the figure are identical in purpose and usage.",both
What is the total sales revenue generated in the month of January 2023?,"```python
import pandas as pd

# SQL query to get the total sales revenue for January 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the total sales only
total_sales = result_df['TotalSales'].iloc[0]
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input code and the reference implementation both correctly calculate the total sales revenue for January 2023. They use the same logic of summing the product of UnitPrice, Quantity, and discount factor from the [Order Details] table, joined with orders by OrderID. The date filtering logic is equivalent: the reference code uses BETWEEN for the whole month of January, while the input code uses '>= 2023-01-01' and '< 2023-02-01', which covers the same date range. Both then show the result using the `show_to_user` function.","```python
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to the database and execute the provided query
    # For now, it's just a placeholder since actual database configurations are not provided
    # Replace this with actual database connection and query execution logic
    pass

def show_to_user(data):
    # This function displays the DataFrame or result to the user
    print(data)

# SQL query to retrieve total sales revenue in January 2023
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS [Total Sales]
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the query and retrieve the result
sales_data = execute_sql_query(sql_query)

# Display the total sales revenue to the user
show_to_user(sales_data)
```","The input code correctly constructs an SQL query to calculate the total sales revenue for January 2023 by joining the `[Order Details]` and `orders` tables and summing up the product of `UnitPrice`, `Quantity`, and the discount factor. The execution of this SQL query and the display of its result are conceptually the same as the reference implementation. The slight difference in naming the result column as `[Total Sales]` instead of `TotalSales` does not affect functionality or correctness.",both
What is the total quantity of each product sold? Use a bar chart to compare quantities sold per product.,"```python
import plotly.express as px

# SQL query to get the total quantity of each product sold
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure column names are correctly referenced
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity Sold per Product')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='TotalQuantity', title='Total Quantity Sold per Product', labels={'TotalQuantity': 'Quantity Sold', 'ProductName': 'Product'})
show_to_user(fig)
```","The evaluated code correctly fulfills the business analytics request to determine and visualize the total quantity of each product sold. It uses an SQL query to calculate the sum of quantities for each product and correctly prepares the data for visualization with Plotly Express. Although it includes 'ProductName' in the query and groups by both 'ProductID' and 'ProductName', the logic aligns with the reference implementation since adding 'ProductName' does not affect the requested aggregation, but enhances the visualization by displaying product names instead of IDs. Therefore, the logic is consistent with the reference code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY ProductID
""""""

# Execute the SQL query using the provided utility functions
product_sales_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    product_sales_df,
    x='ProductID',
    y='TotalQuantity',
    title='Total Quantity of Each Product Sold',
    labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity Sold'}
)

# Display the bar chart to the user
show_to_user(fig)
```","Both implementations perform the same task of calculating the total quantity of each product sold and visualizing it using a bar chart. While the input code directly queries the 'Order Details' table for the product quantities, the reference code joins 'products' with 'Order Details'. However, the alignment of the intended outcome remains consistent. Both codes group by 'ProductID' and sum 'Quantity', creating equivalent data outputs for visualization. Hence, the input code is correct as per the requirements.",both
What are the top 5 customers by order value? Represent using a bar chart to see the top contributors.,"```python
import plotly.express as px

# SQL Query
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalOrderValue 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5;
'''

# Execute SQL Query
df = execute_sql_query(sql_query)

# Create Bar Chart
fig = px.bar(df, x='CustomerID', y='TotalOrderValue', title='Top 5 Customers by Order Value')

# Display to User
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    TotalOrderValue DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='TotalOrderValue', title='Top 5 Customers by Order Value')
show_to_user(fig)
```","The input code correctly executes a SQL query to find the top 5 customers by total order value, grouping by CustomerID and CompanyName, which is consistent with the reference implementation that groups by CustomerID. The addition of CompanyName does not alter the logic related to identifying the top contributors by order value. The result is then visualized using a bar chart, as requested, with customer names on the x-axis. Thus, functionally, the two implementations adhere to the same logic.","```python
import pandas as pd
import plotly.express as px

# Assume this utility function is defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for database query execution
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    pass

# SQL query to get top 5 customers by order value
sql_query = """"""
SELECT customers.CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS order_value
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN customers ON orders.CustomerID = customers.CustomerID
GROUP BY customers.CustomerID
ORDER BY order_value DESC
LIMIT 5
""""""

# Execute the query and get a DataFrame
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_customers_df, x='CustomerID', y='order_value', 
             title='Top 5 Customers by Order Value',
             labels={'CustomerID': 'Customer ID', 'order_value': 'Order Value'})

# Display the bar chart
show_to_user(fig)
```","The input Python code is correct and aligns with the logic of the reference implementation. Both codes execute a SQL query to retrieve the top 5 customers ordered by order value using a SUM aggregation on the order details. The group-by and order clauses are consistent in both scripts. Both scripts generate and show a bar chart using Plotly. The minor difference in naming conventions (e.g., 'order_value' vs. 'TotalOrderValue') does not affect the correctness of the solution. The end result is the same: visualizing the top 5 customers by order value.",both
How many products are in each category? Use a pie chart to show distribution across categories.,"```python
import plotly.express as px

# Execute the SQL query to get the data
sql_query = ""SELECT CategoryID, COUNT(ProductID) AS ProductCount FROM products GROUP BY CategoryID;""
df = execute_sql_query(sql_query)

# Create a pie chart to show distribution across categories
fig = px.pie(df, names='CategoryID', values='ProductCount', title='Product Distribution Across Categories')

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CategoryID, COUNT(ProductID) as ProductCount
FROM products
GROUP BY CategoryID
""""""

category_counts = execute_sql_query(sql_query)

fig = px.pie(category_counts, values='ProductCount', names='CategoryID', title='Product Distribution Across Categories')
show_to_user(fig)
```","The provided input code correctly implements the business analytics request. It executes a SQL query that groups products by 'CategoryID' and counts the 'ProductID' for each category, similarly to the reference code. It then uses Plotly Express to create a pie chart with 'CategoryID' as the labels and 'ProductCount' as the values, and calls 'show_to_user(fig)' to display the chart. This matches the logic and outcome of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the product count per category
sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS ProductCount 
FROM products 
GROUP BY CategoryID;
""""""

# Executing the SQL query
df = execute_sql_query(sql_query)

# Creating a pie chart to show distribution across categories
fig = px.pie(df, names='CategoryID', values='ProductCount', title='Product Distribution Across Categories')

# Displaying the pie chart to the user
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It executes a SQL query to count products by category, aggregates the data, and uses Plotly Express to create a pie chart representing the product distribution across categories. Both implementations display the chart using 'show_to_user(fig)', fulfilling the business requirement.",both
Identify the employees who report to each manager.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    Manager.LastName AS ManagerLastName, 
    Manager.FirstName AS ManagerFirstName, 
    Subordinate.LastName AS EmployeeLastName, 
    Subordinate.FirstName AS EmployeeFirstName 
FROM employees AS Subordinate 
JOIN employees AS Manager 
ON Subordinate.ReportsTo = Manager.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)
```","```python
sql_query = """"""
SELECT e1.EmployeeID AS ManagerID, 
       CONCAT(e1.FirstName, ' ', e1.LastName) AS ManagerName, 
       e2.EmployeeID AS EmployeeID, 
       CONCAT(e2.FirstName, ' ', e2.LastName) AS EmployeeName
FROM employees e1
LEFT JOIN employees e2 ON e1.EmployeeID = e2.ReportsTo
WHERE e1.Title IN ('Manager', 'Senior Manager')
ORDER BY e1.EmployeeID;
""""""

employees_reporting_to_managers = execute_sql_query(sql_query)
show_to_user(employees_reporting_to_managers)
```","The input code's query includes a condition on the Title of managers, limiting it to 'Manager' and 'Senior Manager', whereas the reference does not impose such restrictions. Consequently, the input code may omit managers not holding these titles, resulting in potentially omitted employees from the results. Additionally, the input uses a LEFT JOIN which will return all managers regardless of whether they have subordinates, but the reference uses INNER JOIN to only show managers with subordinates, which changes the result set logic.","
```python
import pandas as pd

# Define the process_sql_query function
def process_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated database connection and query execution (in practice, connect to your database here)
    # Example: conn = sqlite3.connect('database.db')
    # Use the below line to actually read from your database and get the result into a DataFrame
    
    # Execute the query and return a DataFrame (using pandas)
    # df = pd.read_sql_query(sql_query, conn)
    # conn.close()
    
    # Simulating the DataFrame for demonstration purposes
    data = {
        'ManagerID': [1, 1, 2, 2],
        'EmployeeName': ['Alice', 'Bob', 'Charlie', 'David']
    }
    
    return pd.DataFrame(data)

# Define the display_data_to_user function
def display_data_to_user(data: pd.DataFrame):
    # Display the data
    print(data)

# SQL query to identify employees who report to each manager
sql_query = """"""
SELECT e1.ManagerID, e2.Name AS EmployeeName
FROM employees e1
JOIN e2 ON e1.ID = e2.ManagerID
""""""

# Execute the SQL query and get the results in a DataFrame
df = process_sql_query(sql_query)

# Display the data to the user
display_data_to_user(df)
```
",The input code does not use the same logic as the reference. The input SQL is incorrect; it references 'employees e1' with a nonexistent alias 'e2' and column names are mismatched. It should join on 'ReportsTo' and 'EmployeeID'.,None
Which employee generated the most sales in the last year? Use a bar chart for clearer comparison.,"```python
import plotly.express as px

# SQL query to get total sales for each employee for the last year
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC LIMIT 1;
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to display the sales comparison
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Total Sales by Employee for the Last Year')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the date range for the last year
end_date = pd.to_datetime('today')
start_date = end_date - pd.DateOffset(years=1)

# SQL query to get total sales per employee in the last year
sql_query = f""""""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY e.EmployeeID, EmployeeName
ORDER BY TotalSales DESC
""""""

# Execute the query
sales_data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(sales_data, x='EmployeeName', y='TotalSales', title='Total Sales per Employee in the Last Year')
show_to_user(fig)
```","The input code meets the business analytics request by identifying the employee with the highest sales in the last year and displays the results using a bar chart, similar to the reference implementation. The difference in presentation (using EmployeeName instead of EmployeeID) does not affect the functionality as both codes group by employee and sort by TotalSales to determine the top performer.","
```python
import pandas as pd
import plotly.express as px

# Define the analytical functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for context
    # In practice, this would connect to a database and return a DataFrame
    pass

def show_to_user(data):
    # Dummy implementation for context
    # In practice, this would display the DataFrame or Plotly figure
    pass

# SQL query to extract employee sales data for the last year
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS sales_total 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY employees.EmployeeID 
ORDER BY sales_total DESC;
""""""

# Execute the SQL query
employee_sales_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(employee_sales_df, x='EmployeeID', y='sales_total', 
             title='Employee Sales Comparison for the Last Year',
             labels={'sales_total': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Display the bar chart
show_to_user(fig)
```
","The provided code and the reference implementation differ in logic for calculating the sales for the last year. The reference code uses `YEAR(o.OrderDate) = YEAR(CURDATE())`, which restricts the data to only the current year, while the provided code uses `orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)`, which includes data from the last 365 days. This difference could lead to varying results if the query is executed any time beyond the start of a new year.",Base
Which products need to be reordered soon?,"```python
import pandas as pd

# SQL Query to retrieve products that need to be reordered
sql_query = """"""
SELECT ProductName
FROM products
WHERE UnitsInStock <= ReorderLevel;
""""""

# Execute the SQL query
reorder_products_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(reorder_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND UnitsInStock <= ReorderLevel
""""""

products_to_reorder = execute_sql_query(sql_query)
show_to_user(products_to_reorder)
```","The input implementation adds an additional filter 'Discontinued = 0', which the reference code does not specify. This alters the logic, as it ignores discontinued products, which might still be relevant if they need reordering. Therefore, it's not strictly adhering to the reference logic.","```python
import pandas as pd

# Define the threshold below which products need to be reordered
REORDER_THRESHOLD = 50

# SQL query to select products that need to be reordered
sql_query = f""""""
SELECT ProductName
FROM products
WHERE UnitsInStock < {REORDER_THRESHOLD};
""""""

# Execute the SQL query to obtain the reorder list
def main():
    reorder_products_df = execute_sql_query(sql_query)

    # Use the utility function to display the results
    show_to_user(reorder_products_df)

# Execute the main function
main()
```","The input Python code uses a fixed REORDER_THRESHOLD of 50, whereas the reference implementation checks if UnitsInStock is less than or equal to the ReorderLevel specified in the database. The input code does not properly reference the ReorderLevel column from the products table, making it differ logically from the reference implementation.",None
How many orders did each employee handle in the first quarter of this year? Use a bar chart for easy comparison.,"```python
import plotly.express as px

# SQL query
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID;
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Orders Handled by Each Employee in Q1 2023', labels={'EmployeeID':'Employee ID', 'OrderCount':'Order Count'})

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
GROUP BY e.EmployeeID, EmployeeName
ORDER BY OrderCount DESC
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='EmployeeName', y='OrderCount', title='Orders Handled by Each Employee in Q1 2023', labels={'OrderCount': 'Number of Orders', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code correctly fulfills the business analytics request. It calculates the number of orders each employee handled in Q1 2023 using an SQL query similar to the reference implementation. The key differences are the use of a LEFT JOIN, the inclusion of employee names, and sorting by order count. These differences are acceptable since they do not alter the intended output of the number of orders per employee in this quarter. The use of 'ORDER BY' in SQL does not impact the correctness of the output. The visualization, created using Plotly, is consistent with the requested bar chart format.","```python
import pandas as pd
import plotly.express as px

# Define SQL query to fetch the number of orders handled by each employee
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for the number of orders per employee
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Orders Handled by Each Employee in Q1 2023')

# Display the bar chart
show_to_user(fig)
```","The input code correctly executes the SQL query to retrieve the number of orders handled by each employee in the first quarter of 2023, similar to the reference implementation. It uses a bar chart to display the results. Although the label specification in Plotly is omitted, this does not affect the correctness of the code since the x and y axes remain clear. Both the reference and input code use the same logic and provide the correct answer to the business analytics request.",both
"What is the total sales for each product category this year, and can it be visualized using a bar chart?","```python
import plotly.express as px

# SQL Query provided
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY categories.CategoryName
""""""

# Execute SQL query to get the data
sales_data_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(sales_data_df, x='CategoryName', y='TotalSales', title='Total Sales for Each Product Category This Year')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY 
    p.CategoryID
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.bar(total_sales_df, x='CategoryID', y='TotalSales', title='Total Sales for Each Product Category This Year')
show_to_user(fig)
```","The input code differs from the reference code in key ways: it aggregates sales by `CategoryID` instead of `CategoryName`, as done in the reference. This could lead to different labels on the chart. Additionally, it does not join with the `categories` table, which is necessary to convert `CategoryID` to `CategoryName`. As a result, the logic does not completely match the reference implementation, as it doesn't provide the same level of detail or identifiers in the output.","```python
import plotly.express as px

# Define the SQL query to fetch total sales for each product category this year
sql_query = """"""
SELECT 
    ProductCategory, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM 
    products p 
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID 
JOIN 
    orders o ON od.OrderID = o.OrderID 
WHERE 
    EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
GROUP BY 
    ProductCategory
""""""

# Execute the SQL query to get the data into a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using the data
fig = px.bar(sales_data, x='ProductCategory', y='TotalSales', title='Total Sales by Product Category - Current Year')

# Display the bar chart
show_to_user(fig)
```","The input code uses 'ProductCategory', but the reference uses 'CategoryName', suggesting a possible mismatch in column names or logic. Without knowing the exact schema, it's uncertain if 'ProductCategory' is the correct field. Both queries intend to extract sales by product category for the current year, but the difference in column names prevents us from confirming they are equivalent.",None
Find the total freight cost for all orders shipped via each shipping method in 2022 and illustrate it with a pie chart.,"```python
import plotly.express as px

# Execute the SQL query to get the data
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2022 
GROUP BY ShipVia;
""""""
data = execute_sql_query(sql_query)

# Create a pie chart of the total freight cost by shipping method
fig = px.pie(data_frame=data, names='ShipVia', values='TotalFreight', title='Total Freight Cost by Shipping Method (2022)')

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
WHERE YEAR(OrderDate) = 2022
GROUP BY ShipVia
""""""

freight_data = execute_sql_query(sql_query)

fig = px.pie(freight_data, values='TotalFreight', names='ShipVia', title='Total Freight Cost by Shipping Method in 2022')
show_to_user(fig)
```","The input Python code correctly follows the same logic as the reference implementation. Both codes execute the same SQL query to retrieve the total freight costs grouped by 'ShipVia' for the year 2022. They also utilize Plotly to create and display a pie chart with 'TotalFreight' as the values and 'ShipVia' as the names. Although the code structure may vary slightly, the core functionality and output remain consistent with the request and reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total freight cost by shipping method for 2022
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS total_freight_cost
FROM orders
WHERE EXTRACT(YEAR FROM OrderDate) = 2022
GROUP BY ShipVia
""""""

# Execute the SQL query and store result in a DataFrame
df = execute_sql_query(sql_query)

# Generate a pie chart to illustrate freight cost distribution by shipping method
fig = px.pie(df, names='ShipVia', values='total_freight_cost', title='Freight Cost Distribution by Shipping Method in 2022')

# Display the pie chart to the user
show_to_user(fig)
```","The input code correctly executes an SQL query to sum the freight costs per shipping method for the year 2022, using 'EXTRACT(YEAR FROM OrderDate)' instead of 'YEAR(OrderDate)', which is a minor syntactic difference depending on the SQL dialect but serves the same purpose. The result is stored in a DataFrame and used to create a pie chart with Plotly Express, matching the logic of the reference implementation. Consequently, the input code fulfills the business analytics request and adheres to the reference implementation's logic.",both
What are the five cities with the highest total sales and present them in a ranked bar chart?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCity, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipCity 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not df.empty:
    # Create a ranked bar chart using plotly
    fig = px.bar(df, x='ShipCity', y='TotalSales', 
                 title=""Top 5 Cities by Total Sales"", 
                 labels={'ShipCity': 'City', 'TotalSales': 'Total Sales'})
    
    # Show the figure using the provided utility function
    show_to_user(fig)
else:
    show_to_user(""No data available to display."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.City, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.City
ORDER BY TotalSales DESC
LIMIT 5
""""""

top_cities_sales = execute_sql_query(sql_query)

fig = px.bar(top_cities_sales, x='City', y='TotalSales', title='Top 5 Cities with Highest Total Sales', labels={'TotalSales': 'Total Sales', 'City': 'City'})
show_to_user(fig)
```","The input code uses the 'City' field from the 'employees' table, while the reference code uses 'ShipCity' from orders. Consequently, the context of cities differs, skewing results. All other logic adheres to the reference, but input's selection criteria vary, making it incorrect as per requirements.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the top 5 cities with the highest total sales
sql_query = """"""
SELECT c.City, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.City 
ORDER BY TotalSales DESC 
LIMIT 5
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a ranked bar chart using Plotly
fig = px.bar(data, x='City', y='TotalSales', title='Top 5 Cities by Total Sales', 
             labels={'TotalSales': 'Total Sales ($)', 'City': 'City'}, 
             text='TotalSales', orientation='v')

# Set the layout for better visibility of values
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
fig.update_yaxes(title_text='Total Sales ($)', ticksuffix="" $"")

# Display the visualization to the user
show_to_user(fig)
```","The provided code correctly answers the business analytics request by querying the top 5 cities with the highest total sales, similar to the reference code. It uses an equivalent SQL query that joins the necessary tables to calculate total sales and ranks the top cities. The code then creates a ranked bar chart using Plotly, aligning with the logic of the reference implementation, despite minor differences in SQL structure and visualization details.",Finetuned
Calculate the total number of units ordered for each product category and visualize it with a histogram.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT c.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
INNER JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryID;
""""""

# Execute SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart of total units ordered for each product category
fig = px.bar(df, x='CategoryID', y='TotalUnitsOrdered', title='Total Units Ordered per Product Category')

# Display the plotly figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
""""""

data = execute_sql_query(sql_query)

fig = px.histogram(data, x='CategoryID', y='TotalUnitsOrdered', title='Total Units Ordered by Product Category', 
                   labels={'CategoryID': 'Product Category ID', 'TotalUnitsOrdered': 'Total Units Ordered'})
show_to_user(fig)
```","The input code uses a histogram instead of a bar chart for visualization, which is not the same as the reference implementation that uses a bar chart, leading to potentially incorrect visualization for this specific task. Also, it misses the inner join with the categories table, which might lead to incorrect category IDs if product IDs aren't matched correctly to categories.","
```python
import pandas as pd
import plotly.express as px

# SQL Query to calculate the total number of units ordered for each product category
sql_query = """"""
SELECT ProductCategory, SUM(UnitesOrdered) AS TotalUnitsOrdered 
FROM orderdetails 
JOIN products ON orderdetails.ProductID = products.ProductID 
GROUP BY ProductCategory;
""""""

# Execute the SQL query and get the data as a pandas DataFrame
category_units_df = execute_sql_query(sql_query)

# Create a histogram using Plotly to visualize the total number of units ordered per product category
fig = px.histogram(category_units_df, x='TotalUnitsOrdered', 
                   title='Total Units Ordered per Product Category',
                   labels={'TotalUnitsOrdered':'Total Units Ordered'})

# Show the plot to the user
show_to_user(fig)
```
","The input code has discrepancies that deviate from the reference implementation. Firstly, the SQL query uses 'ProductCategory' instead of 'CategoryID', and 'UnitesOrdered' (likely a typo of 'UnitsOrdered') instead of 'od.Quantity'. Secondly, the table names and join conditions differ. The input code uses 'orderdetails' and lacks the 'categories' table, while the reference code uses '[Order Details]' and includes joining with 'categories'. Also, the input code uses a histogram whereas the reference code uses a bar chart with 'CategoryID' on the x-axis, leading to a difference in visualization semantics.",None
"What is the monthly trend of order placements for the current year, and how can a line chart be used to represent it?","```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT MONTH(OrderDate) AS Month, COUNT(*) AS NumberOfOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY MONTH(OrderDate);
""""""

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Sort the DataFrame by Month to ensure the line chart is ordered correctly
orders_df = orders_df.sort_values(by='Month')

# Create line chart using plotly
fig = px.line(orders_df, x='Month', y='NumberOfOrders', title='Monthly Trend of Order Placements')

# Display plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to get monthly order placements for the current year
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
WHERE 
    OrderDate >= DATE_FORMAT(CURRENT_DATE(), '%Y-01-01')
GROUP BY 
    Month
ORDER BY 
    Month;
""""""
order_data = execute_sql_query(sql_query)

# Create a line chart to represent the monthly trend of order placements
fig = px.line(order_data, x='Month', y='OrderCount', title='Monthly Trend of Order Placements for Current Year', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})
show_to_user(fig)
```","The provided code effectively generates the monthly trend of order placements for the current year and uses a line chart to represent it, adhering to the business analytics request. Both the reference and input implementations group order counts by month for the current year and visualize the data using Plotly. The minor differences, like the formatting and labels, do not affect the overall logic and correctness.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the monthly trend of order placements for the current year
sql_query = """"""
SELECT 
    DATE_PART('month', OrderDate) AS month, 
    COUNT(*) AS order_count 
FROM orders 
WHERE DATE_PART('year', OrderDate) = DATE_PART('year', CURRENT_DATE) 
GROUP BY DATE_PART('month', OrderDate);
""""""

# Execute the SQL query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Plotting the line chart for monthly order placements
fig = px.line(orders_df.sort_values('month'), x='month', y='order_count', 
              labels={'month': 'Month', 'order_count': 'Number of Orders'},
              title='Monthly Trend of Order Placements for Current Year')

# Display the line chart using the utility function
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request by calculating the monthly trend of order placements for the current year. It uses SQL to filter and group orders by month, similar to the reference implementation, but utilizes the 'DATE_PART' function for PostgreSQL compatibility, which is appropriate. The subsequent steps of sorting the DataFrame, creating a line chart, and displaying it align with the required task. Overall, the logic is consistent with the reference implementation, confirming its correctness.",both
How long has each employee been working at the company?,"```python
import pandas as pd

# SQL query to get the employee duration
sql_query = ""SELECT employees.EmployeeID, DATEDIFF(CURDATE(), employees.HireDate) AS DaysWorked FROM employees;""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
import pandas as pd
from datetime import datetime

sql_query = """"""
SELECT EmployeeID, FirstName, LastName, HireDate 
FROM employees
""""""

employees_df = execute_sql_query(sql_query)

current_date = datetime.now().date()
employees_df['Tenure'] = (current_date - employees_df['HireDate']).dt.days
employees_df = employees_df[['EmployeeID', 'FirstName', 'LastName', 'Tenure']]

show_to_user(employees_df)
```","The input code correctly calculates the tenure of each employee by computing the difference between the current date and the hire date. It adheres to the business request by determining how long each employee has been working at the company. Although it includes additional columns (FirstName, LastName), it fundamentally answers the same question as the reference code by providing the duration (in days) each employee has been employed.","```python
import pandas as pd

# SQL Query to retrieve employee start dates and calculate tenure
sql_query = """"""
SELECT employees.EmployeeID, 
       DATEDIFF(CURRENT_DATE(), employees.HireDate) AS Tenure 
FROM employees;
""""""

# Execute the SQL query using the provided utility function
employee_tenure_df = execute_sql_query(sql_query)

# Display the result
show_to_user(employee_tenure_df)
```","Both the input Python code and the reference code retrieve employee IDs and calculate the number of days each employee has been with the company using the DATEDIFF function. The only differences are in variable names and using CURRENT_DATE() versus CURDATE(), which are equivalent in MySQL. Both implementations adhere to the specified business analytics request.",both
Which products need reordering?,"```python
import pandas as pd

# SQL query to identify products that need reordering
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query and retrieve the data
products_to_reorder_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND (UnitsInStock + UnitsOnOrder) <= ReorderLevel;
""""""

products_needing_reorder = execute_sql_query(sql_query)
show_to_user(products_needing_reorder)
```","The input code adds additional conditions that affect the filter logic: (1) It includes a check for 'Discontinued = 0,' while the reference doesn't consider product discontinuation status. (2) It combines 'UnitsInStock' and 'UnitsOnOrder' to be less than or equal to 'ReorderLevel,' but the reference only checks 'UnitsInStock' against 'ReorderLevel.' These differences result in a different set of products, which may lead to a different outcome.","```python
# Import necessary libraries
import pandas as pd

# Define the SQL query to find products that need reordering
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock <= ReorderLevel;
""""""

# Execute the SQL query and obtain the results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function's implementation is assumed to be available 
    # and returns a DataFrame based on SQL execution.
    pass

# Call the function to execute the SQL and get the data
reorder_products_df = execute_sql_query(sql_query)

# Display the results to the user
def show_to_user(data: pd.DataFrame):
    # This function is assumed to format and display the DataFrame.
    pass

# Display the DataFrame showing products that need reordering
show_to_user(reorder_products_df)
```","The provided code correctly determines which products need reordering by selecting products where UnitsInStock is less than or equal to ReorderLevel. It adheres to the same logic as the reference code, even though it includes additional fields in the SQL query, which does not affect the correctness in terms of the business request.",Finetuned
How many products have a reorder level higher than 20?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT * FROM products WHERE ReorderLevel > 20;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Count the number of rows (products) with ReorderLevel > 20
high_reorder_products_count = result_df.shape[0]

# Create a DataFrame to hold the count
count_df = pd.DataFrame({'HighReorderProducts': [high_reorder_products_count]})

# Display the result using the provided utility function
show_to_user(count_df)
```","```python
sql_query = ""SELECT COUNT(*) AS ProductCount FROM products WHERE ReorderLevel > 20""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code constructs a SQL query to count the products with a ReorderLevel greater than 20. It directly retrieves the count using an aggregate function (COUNT) within the SQL operation, which aligns with the business requirement. The reference code uses the .shape method to count the rows after filtering. Both approaches achieve the same objective: determining the number of products with a ReorderLevel above 20. Thus, the input code is correct according to the specified request.","```python
# Import necessary library to execute SQL
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(ProductID) FROM products WHERE ReorderLevel > 20;""

# Execute the SQL query and fetch the result
df = execute_sql_query(sql_query)

# Display result to the user
show_to_user(df)
```","The input Python code correctly answers the business question about the number of products with a reorder level higher than 20. It uses a SQL query to directly count the products with ReorderLevel > 20, which aligns logically with the reference implementation. Although the approach differs—directly counting in the SQL query versus filtering and then counting in the DataFrame—the end result is the same: finding the number of such products. Thus, the input code is considered correct.",both
Find the customers who have not placed any orders in the current year.,"```python
import pandas as pd

# Define the SQL queries
query_customers = ""SELECT CustomerID FROM customers;""
query_orders_current_year = ""SELECT DISTINCT CustomerID FROM orders WHERE OrderDate >= DATE_FORMAT(NOW(), '%Y-01-01');""

# Execute the SQL queries
customers_df = execute_sql_query(query_customers)
orders_df = execute_sql_query(query_orders_current_year)

# Find customers who have not placed any orders in the current year
inactive_customers_df = customers_df[~customers_df['CustomerID'].isin(orders_df['CustomerID'])]

# Show result to the user
show_to_user(inactive_customers_df)
```","```python
import pandas as pd

current_year = pd.to_datetime(""now"").year

sql_query = f""""""
SELECT DISTINCT CustomerID
FROM orders
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID
    FROM orders
    WHERE YEAR(OrderDate) = {current_year}
);
""""""

customers_no_orders = execute_sql_query(sql_query)
show_to_user(customers_no_orders)
```","The input code correctly identifies customers who have not placed any orders in the current year. It does this by querying the 'orders' table to find customers whose IDs are not present in the orders placed this year. The logic aligns with the reference implementation, though it achieves it using a SQL query with a subquery instead of performing operations on two dataframes. Both approaches provide the desired result.","To accomplish the task of identifying customers who have not placed any orders in the current year, we will leverage a SQL query executed using the provided utility function, `execute_sql_query`.

### SQL Query Explanation:

The SQL query employs a `LEFT JOIN` operation between the `Customers` table and the `orders` table on the `CustomerID` field. The query selects customers for whom no orders exist in the current year, filtering results by checking if the `OrderID` is `NULL`.

```sql
SELECT c.CustomerID, c.CustomerName 
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
AND YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
WHERE o.OrderID IS NULL;
```

### Python Implementation:

1. **Define the SQL Query**: We'll use the SQL query provided.
2. **Execute the Query**: We'll execute the SQL statement using the `execute_sql_query` function, which returns a DataFrame.
3. **Display Results**: Finally, we'll present the resulting DataFrame to the user.

```python
# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, c.CustomerName 
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
AND YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
WHERE o.OrderID IS NULL;
""""""

# Execute the SQL query and retrieve results as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)
``` 

### Considerations:
- Ensure that the `execute_sql_query` and `show_to_user` functions are available in the environment.
- The database must support the SQL syntax used.
- Make sure that the date handling functions (like `YEAR()`) are compatible with the database being queried. 

The provided code will effectively fetch and display the relevant data to the user, highlighting customers with no orders in the current year.","The input Python code is correct. It uses a `LEFT JOIN` to identify customers who have not placed any orders in the current year, leveraging the fact that `OrderID` will be `NULL` for those customers. This approach is logically consistent with the reference code's use of set operations with DataFrames to find inactive customers.",both
Identify the top 5 customers who have incurred the highest total freight costs and display in a ranked list.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CustomerID, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY CustomerID 
ORDER BY TotalFreight DESC 
LIMIT 5;
""""""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Ensure the result is sorted and ranked properly
df = df.sort_values(by='TotalFreight', ascending=False).reset_index(drop=True)

# Display the ranked list of top 5 customers by total freight costs
show_to_user(df)
```","```python
sql_query = """"""
SELECT CustomerID, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY CustomerID
ORDER BY TotalFreight DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)
show_to_user(top_customers)
```","The input code correctly implements the business request. Both the reference and input code use an SQL query to select the top 5 customers based on total freight costs by summing 'Freight' and ordering by the sum in descending order. They both execute the query and display the result, achieving the same outcome. The explicit sorting step in the reference code is redundant because the query already orders the results.","
```python
import pandas as pd

# Function to execute the SQL query and display the results
def process_request(sql_query: str):
    # Execute the SQL query to get the data
    df = pd.read_sql(sql_query, con=your_database_connection)
    
    # Display the data
    print(df)

# SQL query to fetch the top 5 customers with the highest total freight costs
sql_query = """"""
SELECT c.CustomerID, 
       SUM(o.Freight) AS TotalFreightCost 
FROM customers c 
JOIN orders o 
ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID 
ORDER BY TotalFreightCost DESC 
LIMIT 5
""""""

# Process the request using the utility function
process_request(sql_query)
```
","The provided Python code correctly implements the business analytics request. It joins the 'customers' and 'orders' tables to aggregate and sum 'Freight' costs per 'CustomerID'. It then orders by total freight cost and limits to the top 5 customers, matching the reference logic. The only difference is the use of an additional join with the 'customers' table, which does not affect the correctness as it aligns with the logic of obtaining customer data.",both
"How many units of each product were sold in the first quarter of 2023, and can this be shown in a grouped bar chart?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
    SELECT products.ProductID, SUM([Order Details].Quantity) AS units_sold 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
    GROUP BY products.ProductID
""""""

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Create a grouped bar chart using plotly
fig = px.bar(df, x='ProductID', y='units_sold', title='Units Sold Per Product in Q1 2023', barmode='group')

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS units_sold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='units_sold', title='Units Sold in Q1 2023', labels={'units_sold': 'Units Sold', 'ProductName': 'Product'})
show_to_user(fig)
```","The provided code correctly answers the business analytics request by calculating the number of units sold per product in the first quarter of 2023. It uses a SQL query similar to the reference implementation, grouping by both ProductID and ProductName to maintain associated names. Additionally, it generates a grouped bar chart using Plotly, meeting the visualization requirement. The logic and outcome are consistent with the reference implementation, even with the inclusion of product names to enhance the chart's readability.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalSold
FROM [Order Details]
WHERE OrderID IN (
    SELECT OrderID
    FROM orders
    WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
)
GROUP BY ProductID;
""""""

# Execute the query and get the result as a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a grouped bar chart using Plotly
fig = px.bar(sales_data, x='ProductID', y='TotalSold', 
             title='Units of Each Product Sold in Q1 2023',
             labels={'TotalSold': 'Total Units Sold', 'ProductID': 'Product ID'})

# Display the result
show_to_user(fig)
```","The input code does not join the 'products' table, so it may miss products without orders in the specified period. This could lead to discrepancies if the product list is needed in the analysis. The reference code correctly joins necessary tables to ensure all products are considered.",Base
"How many orders were shipped via each shipping method in 2023, and illustrate it with a bar chart?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
    SELECT ShipVia, COUNT(OrderID) AS OrderCount
    FROM orders
    WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
    GROUP BY ShipVia
""""""

# Execute the SQL query and retrieve data as a pandas dataframe
order_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(order_data, x='ShipVia', y='OrderCount', title='Orders Shipped Via Each Method in 2023')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY ShipVia
""""""

order_counts = execute_sql_query(sql_query)

fig = px.bar(order_counts, x='ShipVia', y='OrderCount', 
             title='Number of Orders Shipped via Each Shipping Method in 2023',
             labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","Both implementations correctly calculate the number of orders shipped via each method in 2023. The primary difference in SQL is the use of 'YEAR(OrderDate) = 2023' instead of the date range, which logically results in the same output. The plotly bar chart and its configuration are consistent, and the visualization functions are equivalent. Therefore, the input Python code can be considered correct.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
WHERE EXTRACT(YEAR FROM OrderDate) = 2023
GROUP BY ShipVia;
""""""

# Execute the SQL query and fetch the data into a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart to display the number of orders per shipping method
fig = px.bar(data, x='ShipVia', y='OrderCount', title='Orders Shipped via Each Method in 2023')

# Show the visualization
show_to_user(fig)
```","The input Python code accurately addresses the business analytics request by obtaining the number of orders shipped via each method in 2023. The code uses a slightly different SQL command (`EXTRACT(YEAR FROM OrderDate) = 2023`) compared to the reference implementation which uses a `BETWEEN` clause, but both methods effectively filter orders within the year 2023. The data is then plotted using Plotly's bar chart, consistent with the reference implementation, and displayed with the `show_to_user()` function. Therefore, the logic and outcome align with the reference code.",both
How many orders were placed each month in the current year and visualize with a line chart?,"```python
import plotly.express as px

# SQL query to get the number of orders placed each month in the current year
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY OrderMonth 
ORDER BY OrderMonth;
""""""

# Execute the query and retrieve the data as a pandas dataframe
orders_data = execute_sql_query(sql_query)

# Create a line chart using plotly
fig = px.line(orders_data, x='OrderMonth', y='TotalOrders', title='Monthly Orders in Current Year', labels={'OrderMonth': 'Month', 'TotalOrders': 'Number of Orders'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_year = datetime.now().year

sql_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS OrdersCount
FROM 
    orders
WHERE 
    YEAR(OrderDate) = {current_year}
GROUP BY 
    Month
ORDER BY 
    Month
""""""

orders_per_month = execute_sql_query(sql_query)

fig = px.line(orders_per_month, x='Month', y='OrdersCount', title='Number of Orders Placed Each Month in {current_year}')
show_to_user(fig)
```","The provided input code correctly answers the business analytics request by selecting the number of orders placed each month in the current year from the database. It uses a similar SQL query to the reference code, with equivalent aggregation and formatting functions. The visualization step uses Plotly to generate a line chart, just as the reference code does, with appropriate labels and title. The logic and output of the input code match those of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch monthly order counts for the current year
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
WHERE 
    EXTRACT(year FROM OrderDate) = EXTRACT(year FROM CURRENT_DATE) 
GROUP BY 
    DATE_TRUNC('month', OrderDate)
""""""

# Execute the SQL query to get the data
monthly_orders_df = execute_sql_query(sql_query)

# Create a line chart to visualize the data
fig = px.line(monthly_orders_df, x='Month', y='OrderCount', title='Monthly Orders for Current Year')

# Display the line chart to the user
show_to_user(fig)
```","The provided code correctly addresses the business request to calculate and visualize the number of orders placed each month in the current year. Both implementations use SQL to group and count orders by month for the current year. While the reference code uses DATE_FORMAT to format dates, the input code uses DATE_TRUNC, which also extracts by month effectively. Both codes produce a line chart visualizing the data using plotly, making the input code logically aligned with the reference implementation.",both
Which product had the highest average discount and illustrate it with a bar chart?,"```python
import plotly.express as px

# SQL query to get the product with the highest average discount
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AvgDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY AvgDiscount DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not df.empty:
    # Create a bar chart to illustrate the product with the highest average discount
    fig = px.bar(df, x=""ProductID"", y=""AvgDiscount"", title=""Product with the Highest Average Discount"")

    # Show the result to the user
    show_to_user(fig)
else:
    print(""No data returned from the query."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, AVG(od.Discount) AS AvgDiscount
FROM [Order Details] od
GROUP BY od.ProductID
ORDER BY AvgDiscount DESC
LIMIT 1
""""""

highest_discount_df = execute_sql_query(sql_query)
highest_discount_product_id = highest_discount_df['ProductID'].iloc[0]

discounts_query = """"""
SELECT ProductID, AVG(Discount) AS AvgDiscount
FROM [Order Details]
GROUP BY ProductID
""""""

discounts_df = execute_sql_query(discounts_query)

fig = px.bar(discounts_df, x='ProductID', y='AvgDiscount', title='Average Discount per Product')
show_to_user(fig)
```",The input code retrieves the product with the highest average discount but then goes on to plot the average discount for all products instead of illustrating just the product with the highest average discount. The reference implementation specifically plots only the product with the highest average discount.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL query to retrieve the product with the highest average discount
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AvgDiscount
FROM [Order Details]
GROUP BY ProductID
ORDER BY AvgDiscount DESC
LIMIT 1;
""""""

# Execute the SQL query and store the result in a DataFrame
highest_discount_df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the product ID with the highest average discount
fig = px.bar(
    highest_discount_df, 
    x='ProductID', 
    y='AvgDiscount', 
    title='Product with the Highest Average Discount',
    labels={'ProductID': 'Product ID', 'AvgDiscount': 'Average Discount'}
)

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code executes the same SQL query as the reference implementation, which retrieves the product with the highest average discount. Then, it uses Plotly Express to create a bar chart to illustrate the finding. The code includes appropriate labels for the axes, similar to the reference code's logic. Both implementations insert the appropriate SQL query, check for non-empty results, and generate a bar chart, fulfilling the business analytics request.",Finetuned
"What percentage of total stock does each product contribute, and can this be visualized in a pie chart?","```python
import plotly.express as px

# SQL query to retrieve the required data
sql_query = """"""
SELECT p.ProductID, 
ROUND(p.UnitsInStock / (SELECT SUM(UnitsInStock) FROM products) * 100, 2) AS StockPercentage 
FROM products p;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Ensure that 'ProductID' and 'StockPercentage' are treated as strings and numeric
df['ProductID'] = df['ProductID'].astype(str)
df['StockPercentage'] = df['StockPercentage'].astype(float)

# Generate a pie chart using Plotly
fig = px.pie(df, names='ProductID', values='StockPercentage', title='Percentage Contribution of Total Stock by Product')

# Display the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0
""""""

products_df = execute_sql_query(sql_query)

total_stock = products_df['UnitsInStock'].sum()
products_df['Percentage'] = (products_df['UnitsInStock'] / total_stock) * 100

fig = px.pie(products_df, names='ProductName', values='Percentage', title='Percentage of Total Stock by Product')
show_to_user(fig)
```","The provided code calculates percentages correctly but differs in logic from the reference implementation. The reference focuses on all products using 'ProductID' and excludes a 'Discontinued' condition, whereas the evaluated code only considers non-discontinued products using 'ProductName'. This change affects comparability and the answer to the business question.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductID, (QuantityInStock / (SELECT SUM(QuantityInStock) FROM products)) * 100 AS StockPercentage
FROM products;
""""""

# Execute the SQL query and get a DataFrame
df = execute_sql_query(sql_query)

# Create a pie chart visualization
fig = px.pie(df, names='ProductID', values='StockPercentage', title='Percentage of Total Stock by Product')

# Display the visualization to the user
show_to_user(fig)
```","The input code correctly calculates the percentage contribution of each product to the total stock. It uses a similar SQL query to compute the 'StockPercentage', dividing 'QuantityInStock' for each product by the total sum of 'QuantityInStock'. The key difference in column names ('QuantityInStock' vs. 'UnitsInStock') doesn't affect the logic. Both approaches use Plotly to create a pie chart. Therefore, the input code adheres to the same logic and fulfills the business analytics request.",Finetuned
Which employee processed the highest number of orders last month?,"```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate last month's year and month
today = datetime.today()
first_day_of_current_month = today.replace(day=1)
last_month_end = first_day_of_current_month - timedelta(days=1)
last_month_year = last_month_end.year
last_month = last_month_end.month

# Define SQL query
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE YEAR(o.OrderDate) = {last_month_year} 
AND MONTH(o.OrderDate) = {last_month} 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
""""""

# Execute the SQL query and fetch the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate the first and last day of last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to get the employee who processed the highest number of orders last month
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= '{first_day_last_month.date()}' AND o.OrderDate <= '{last_day_last_month.date()}'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","Both implementations aim to identify the employee who processed the highest number of orders in the last month. The reference code calculates the year and month of the last month and uses it in the SQL query's WHERE clause to filter orders by year and month. The input code calculates the first and last day of the last month to filter orders using a date range. Both approaches correctly identify orders from the last month and group by EmployeeID, ordering by the count of orders processed. There is a slight difference in the fields selected (the input code includes FirstName and LastName), but this does not affect the logic correctness regarding the business question.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 2 MONTH) AND LAST_DAY(DATE_SUB(CURDATE(), INTERVAL 1 MONTH)) 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The input code uses the condition 'WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 2 MONTH) AND LAST_DAY(DATE_SUB(CURDATE(), INTERVAL 1 MONTH))', which extracts a date range covering two months ago up to the last day of the previous month. This range is incorrect as it includes an extra month compared to the reference code. The reference implementation specifically extracts the last month's year and month, ensuring only orders from the previous month are considered.",Base
"Determine the month with the highest total sales, and visualize the monthly sales trend with a line chart.","```python
import plotly.express as px

# SQL query to get monthly sales data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as order_month, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as total_sales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY order_month 
ORDER BY total_sales DESC;
""""""

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Determine the month with the highest total sales
highest_sales_row = monthly_sales_df.iloc[0]

# Visualize the monthly sales trend with a line chart
monthly_sales_df_sorted = monthly_sales_df.sort_values(by='order_month')
fig = px.line(monthly_sales_df_sorted, x='order_month', y='total_sales', title='Monthly Sales Trend')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    TotalSales DESC
""""""

monthly_sales = execute_sql_query(sql_query)

highest_sales_month = monthly_sales.iloc[0]
monthly_sales['Month'] = pd.to_datetime(monthly_sales['Month'])
fig = px.line(monthly_sales, x='Month', y='TotalSales', title='Monthly Sales Trend')
show_to_user(fig)
```","The input code correctly executes an SQL query to calculate monthly sales and orders them in descending order by total sales, similar to the reference implementation. It determines the highest sales month using the first row of the result, which is ordered by `TotalSales` in descending order. It then converts the 'Month' to datetime and plots a line chart of the sales trend, aligning with the reference implementation's logic. The core functionality and intended output are preserved in both implementations.","```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to get total sales by month
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       SUM(`Order Details`.UnitPrice * `Order Details`.Quantity * (1 - `Order Details`.Discount)) AS total_sales 
FROM orders 
JOIN `Order Details` ON orders.OrderID = `Order Details`.OrderID 
GROUP BY month 
ORDER BY total_sales DESC;
""""""

# Step 2: Execute the SQL query and get the results in a pandas DataFrame
monthly_sales_df = execute_sql_query(sql_query)

# Step 3: Identify the month with the highest total sales
if not monthly_sales_df.empty:
    # Step 4: Extract the month with the highest sales
    best_month = monthly_sales_df.iloc[0]

    # Display the month and its sales
    show_to_user(pd.DataFrame([best_month]))

    # Step 5: Visualize the monthly sales trend with a line chart
    fig = px.line(monthly_sales_df, x='month', y='total_sales', title='Monthly Sales Trend',
                  labels={'total_sales': 'Total Sales', 'month': 'Month'})
    
    # Show the plot
    show_to_user(fig)
```
","The provided input code correctly answers the task and follows the same logic as the reference code. It executes a SQL query to retrieve the total monthly sales, sorts the data, identifies the month with the highest sales, and visualizes the monthly sales trend using a line chart. The key operations and outputs are consistent with the goal of determining and displaying the month with highest sales and plotting the trend.",both
Identify the top 5 suppliers based on the total sales revenue and show this in a ranked bar chart.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT p.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID, s.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the query
top_suppliers_df = execute_sql_query(sql_query)

# Create a ranked bar chart
fig = px.bar(top_suppliers_df, x='CompanyName', y='TotalRevenue', 
             title='Top 5 Suppliers by Total Sales Revenue', 
             text='TotalRevenue', 
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier Name'})

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalSales DESC
LIMIT 5
""""""

top_suppliers = execute_sql_query(sql_query)

fig = px.bar(top_suppliers, 
              x='CompanyName', 
              y='TotalSales', 
              title='Top 5 Suppliers by Total Sales Revenue', 
              labels={'TotalSales': 'Total Sales Revenue', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It follows the same logic as the reference implementation: both codes execute a SQL query to fetch the top 5 suppliers by total sales revenue using similar calculations involving `UnitPrice`, `Quantity`, and `Discount`. The results are grouped by `SupplierID` and `CompanyName`, ordered by total revenue in descending order, and limited to the top 5 entries. Both codes use Plotly to create a bar chart displaying the queried data. The main difference is the explicit inclusion of the 'orders' table in the input, which does not affect the result given the query structure. Overall, the input code successfully meets the specified requirements.","```python
import pandas as pd
import plotly.express as px

# Utility function definitions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Replace with actual implementation
    pass

def show_to_user(data):
    # Placeholder function: Replace with actual implementation
    pass

# Function using the provided utility functions
def main():
    # SQL query to fetch the top 5 suppliers by total sales revenue
    query = """"""
    SELECT suppliers.SupplierID, suppliers.CompanyName, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
    FROM suppliers 
    JOIN products ON suppliers.SupplierID = products.SupplierID 
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
    GROUP BY suppliers.SupplierID, suppliers.CompanyName 
    ORDER BY TotalSales DESC 
    LIMIT 5;
    """"""

    # Execute the SQL query
    top_suppliers_df = execute_sql_query(query)

    # Create a ranked bar chart using Plotly
    fig = px.bar(
        top_suppliers_df, 
        x='CompanyName', 
        y='TotalSales', 
        title='Top 5 Suppliers by Total Sales Revenue',
        labels={'TotalSales': 'Total Sales Revenue', 'CompanyName': 'Supplier'},
        text='TotalSales'
    )

    # Add text labels on top of the bars for clarity
    fig.update_traces(textposition='outside')

    # Show the plot to the user
    show_to_user(fig)

# Run the main function
main()
```","The input code correctly implements the logic specified in the business analytics request. It queries the top 5 suppliers based on total sales revenue using similar SQL logic as the reference. The code uses Plotly to create and display a ranked bar chart, consistent with the request. Both the reference and input implementations align on query structure, data handling, and visualization, indicating correctness.",both
Which customer generated the highest lifetime value?,"```python
import pandas as pd

# SQL query to find the customer with the highest lifetime value
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS CustomerLifetimeValue
FROM customers
INNER JOIN orders ON customers.CustomerID = orders.CustomerID
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY customers.CustomerID
ORDER BY CustomerLifetimeValue DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    LifetimeValue DESC
LIMIT 1
""""""

highest_lifetime_value_customer = execute_sql_query(sql_query)
show_to_user(highest_lifetime_value_customer)
```","The input Python code correctly implements the desired logic. It calculates the lifetime value for each customer using the same calculation as the reference implementation: multiplying the unit price, quantity, and discount factor. It joins the 'customers', 'orders', and 'Order Details' tables appropriately, groups the results by customer ID, and orders the results to find the customer with the highest lifetime value. Additionally, the input code includes 'CompanyName' in the SELECT and GROUP BY clauses, which does not interfere with identifying the customer of highest lifetime value.","```python
import pandas as pd

# Define the parameters for the SQL query
sql_query = """"""
SELECT CustomerID, 
       SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS lifetime_value 
FROM orders o 
JOIN [Order Details] OD ON o.OrderID = OD.OrderID 
GROUP BY CustomerID 
ORDER BY lifetime_value DESC 
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The provided code lacks the join with the 'customers' table, which is necessary to directly select CustomerID. The reference code correctly joins 'customers' with 'orders'. The evaluated code also doesn't specify the table for CustomerID, which should be from 'orders'. Technically, both customer joins and source specification are required to ensure the correct logic.",Base
How many employees live in each country and illustrate it with a map or bar chart?,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT Country, COUNT(EmployeeID) AS EmployeeCount 
FROM employees 
GROUP BY Country;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Country', y='EmployeeCount', title='Number of Employees by Country')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Country, COUNT(EmployeeID) AS EmployeeCount FROM employees GROUP BY Country""
employee_counts = execute_sql_query(sql_query)

fig = px.bar(employee_counts, x='Country', y='EmployeeCount', title='Number of Employees by Country')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request by executing the same SQL query as the reference code to get the number of employees in each country. It uses Plotly to create a bar chart that visualizes the result, just like the reference implementation. The logic and steps outlined in both codes, from executing the query to displaying the bar chart, are aligned and correct.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query based on the request
sql_query = """"""
SELECT employees.Country, COUNT(employees.EmployeeID) AS employees_count 
FROM employees 
GROUP BY employees.Country
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Illustrate the data with a bar chart to show the number of employees in each country
fig = px.bar(df, x='Country', y='employees_count', title='Number of Employees by Country')

# Display the bar chart
show_to_user(fig)
```","The provided code correctly implements the business analytics request by executing a SQL query to count employees per country, grouping them by country, and then visualizing the result using a bar chart, which matches the logic of the reference implementation.",both
Visualize the total sales revenue for the month of January 2023 to identify trends or patterns using time-series or bar charts.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales, 
       DAY(OrderDate) as SaleDay
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE MONTH(OrderDate) = 1 AND YEAR(OrderDate) = 2023
GROUP BY DAY(OrderDate)
ORDER BY SaleDay;
""""""

# Execute the query
sales_data = execute_sql_query(sql_query)

# Visualize the data with a time-series line chart
fig = px.line(sales_data, x='SaleDay', y='TotalSales', title='Total Sales Revenue - January 2023', labels={'SaleDay': 'Day of January', 'TotalSales': 'Total Sales Revenue'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m-%d') AS OrderDate,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
GROUP BY 
    OrderDate
ORDER BY 
    OrderDate;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='OrderDate', y='TotalSales', title='Total Sales Revenue for January 2023', labels={'OrderDate': 'Date', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The provided Python code correctly visualizes total sales revenue for January 2023. It uses a SQL query to compute total sales per day, similar to the reference implementation by aggregating sales data using SUM and grouping by date. The date filtering ensures only January 2023 data is used. While the reference code uses a line chart for visualization, the input code uses a bar chart. Both chart types are suitable for the task of identifying sales trends or patterns, therefore the input code adheres to the task requirements and the logic of the reference implementation.","
```python
import pandas as pd
import plotly.express as px

# Define the execute_sql_query function (assuming it's defined elsewhere in your environment)
def execute_sql_query(sql_query: str):
    # This function would execute the SQL query and return a pandas DataFrame
    pass  # Placeholder for actual implementation

# Define the show_to_user function (assuming it's defined elsewhere in your environment)
def show_to_user(data):
    # This function would display a DataFrame or Plotly figure
    pass  # Placeholder for actual implementation

# SQL query to fetch total sales revenue for each day in January 2023
sql_query = """"""
SELECT 
    o.OrderDate, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS DailySales 
FROM 
    orders o 
JOIN 
    [Order Details] od 
ON 
    o.OrderID = od.OrderID 
WHERE 
    o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31' 
GROUP BY 
    o.OrderDate
""""""

# Execute the SQL query and get the results in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales revenue per day in January 2023
fig = px.bar(sales_data, 
             x='OrderDate', 
             y='DailySales', 
             title='Total Sales Revenue for January 2023',
             labels={'OrderDate': 'Date', 'DailySales': 'Daily Sales Revenue'},
             template='plotly')

# Show the visualization
show_to_user(fig)
```","The input code correctly executes an SQL query to calculate daily sales revenue for January 2023 and visualizes it using Plotly. Both the reference and input codes compute total sales using a similar aggregate of unit price, quantity, and discount. The main differences are the visualization types and small syntax changes. The reference code uses a line chart and groups by day, while the input uses a bar chart and groups by exact order dates. Despite these differences, both approaches fulfill the business analytics request to visualize the sales for January 2023.",both
Find and visualize the top 5 cities with the highest average shipping cost to compare differences using a bar chart or map.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageFreight 
FROM orders 
GROUP BY ShipCity 
ORDER BY AverageFreight DESC 
LIMIT 5;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='ShipCity', y='AverageFreight', title='Top 5 Cities with Highest Average Shipping Cost', labels={'AverageFreight':'Average Freight'})

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AverageShippingCost DESC
LIMIT 5;
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='ShipCity', y='AverageShippingCost', 
             title='Top 5 Cities with Highest Average Shipping Cost', 
             labels={'AverageShippingCost': 'Average Shipping Cost', 'ShipCity': 'City'})

show_to_user(fig)
```","The input code correctly follows the business analytics request and logic of the reference implementation. Both segments execute the same SQL query to retrieve the top 5 cities with the highest average freight costs, then visualize this data using a bar chart with Plotly. The differences in variable names (e.g., 'AverageFreight' vs 'AverageShippingCost') and labels do not affect the correctness of the solution, as they serve the same function in terms of logic and visualization.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch average freight charges for each city, sorted in descending order
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AvgShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AvgShippingCost DESC
LIMIT 5;
""""""

# Function to execute the SQL query and return the result as a DataFrame
def execute_sql_query(query: str) -> pd.DataFrame:
    # Assuming this function is implemented elsewhere to fetch data from the database
    pass  # Placeholder for the actual implementation

# Function to display the result to the user, either as a DataFrame or a Plotly visualization
def show_to_user(data):
    # Assuming this function accounts for type checking, implemented elsewhere
    pass  # Placeholder for actual implementation

# Get the top 5 cities with highest average shipping cost
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly for visualization
fig = px.bar(
    top_cities_df,
    x='ShipCity',
    y='AvgShippingCost',
    title='Top 5 Cities with Highest Average Shipping Cost',
    labels={'AvgShippingCost': 'Average Shipping Cost'},
    text='AvgShippingCost'
)

# Display the figure using the utility function
show_to_user(fig)
```","The input code correctly answers the business analytics request by querying the top 5 cities with the highest average shipping cost using a SQL query. It creates a bar chart using Plotly, adheres to the same logical structure as the reference code, and ensures the right data fields are used for visualization, with only minor differences in variable naming and additional chart configuration (e.g., adding text to bars).",both
Which products need to be reordered (units in stock less than reorder level)?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_to_reorder_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_to_reorder_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
products_to_reorder = execute_sql_query(sql_query)
show_to_user(products_to_reorder)
```","The input code includes an additional condition 'Discontinued = 0', which is not present in the reference implementation. This implies that the input code filters out products that are discontinued, which does not adhere exactly to the logic specified in the reference code. The reference code's logic does not consider discontinuation status.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
reorder_products_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(reorder_products_df)
```","The input code correctly executes a SQL query to identify products with 'UnitsInStock' less than 'ReorderLevel', matching the business analytics request. Despite a variable name change from 'products_to_reorder_df' in the reference code to 'reorder_products_df' in the input code, the logic and outcome remain equivalent.",Finetuned
Visualize the top 5 products by sales revenue using a bar chart for comparative analysis.,"```python
import plotly.express as px

# SQL query to retrieve top 5 products by sales revenue
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query using provided utility function
sales_data = execute_sql_query(sql_query)

# Ensure ProductID is treated as a categorical variable for plotting
sales_data['ProductID'] = sales_data['ProductID'].astype(str)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue')

# Display the bar chart using provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalSales DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue', labels={'ProductID': 'Product ID', 'TotalSales': 'Sales Revenue'})
show_to_user(fig)
```","The input Python code follows the same logic as the reference implementation to retrieve and visualize the top 5 products by sales revenue. Both SQL queries aggregate sales values by multiplying UnitPrice, Quantity, and applying Discount. The results are ordered by TotalSales in descending order and limited to 5 records. Although the input code includes a join with an 'orders' table, this does not affect logic regarding sales revenue aggregation and ranking. The use of Plotly for visualization and showing the chart is consistent, hence the code meets the requirement.","```python
import plotly.express as px
import pandas as pd

# Sample SQL query to fetch data
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * (od.UnitPrice - (od.UnitPrice * od.Discount))) AS ProductRevenue 
FROM products p 
INNER JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY ProductRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query using the provided utility function to get the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df,
    x='ProductName',
    y='ProductRevenue',
    title='Top 5 Products by Sales Revenue',
    labels={'ProductName': 'Product Name', 'ProductRevenue': 'Sales Revenue'},
    text='ProductRevenue'
)

# Display the generated bar chart using the provided utility function
show_to_user(fig)
```","Both implementations correctly retrieve and plot the top 5 products by sales revenue using SQL and a bar chart. The input code aggregates sales revenue similarly and utilizes Plotly for visualization, adhering to the request logic.",both
Analyze and visualize the correlation between employee hire date and performance using scatter plots or correlation matrices.,"```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT employees.EmployeeID, employees.HireDate, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, employees.HireDate 
ORDER BY employees.HireDate;
""""""

# Execute SQL query to retrieve data
df = execute_sql_query(sql_query)

# Ensure HireDate is in datetime format
df['HireDate'] = pd.to_datetime(df['HireDate'])

# Calculate performance metric (e.g., using TotalSales as a proxy for performance)
# Assuming we want to standardize it
df['Performance'] = (df['TotalSales'] - df['TotalSales'].mean()) / df['TotalSales'].std()

# Visualize the correlation between HireDate and Performance
fig = px.scatter(df, x='HireDate', y='Performance', 
                 title='Correlation between Hire Date and Performance',
                 labels={'HireDate': 'Hire Date', 'Performance': 'Performance'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to join employees with total sales
sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.HireDate, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.HireDate
""""""

# Execute the query and get the DataFrame
data = execute_sql_query(sql_query)

# Calculate correlation
correlation = data[['HireDate', 'TotalSales']].corr()

# Create a scatter plot to visualize correlation
fig = px.scatter(data, x='HireDate', y='TotalSales', title='Correlation between Hire Date and Total Sales')
show_to_user(fig)

# Display correlation matrix
correlation_matrix_fig = px.imshow(correlation, text_auto=True, title='Correlation Matrix')
show_to_user(correlation_matrix_fig)
```","The input code correctly calculates and visualizes the correlation between the hire date and total sales, aligning with the goal of analyzing correlations as stated in the request. Although it doesn't standardize the performance metric as the reference code does, it includes both the scatter plot and a correlation matrix, adhering to the analysis' intent. The additional correlation matrix provides more insight into the correlation values, ensuring clarity and depth in the analysis. The methodology in both codes involves similar joined database structures and appropriate visualizations.","
import pandas as pd
import plotly.express as px

# Function to analyze and visualize the correlation between employee hire date and performance
def analyze_hire_date_performance():
    # Step 1: Execute SQL query to obtain necessary data
    sql_query = """"""
    SELECT e.HireDate, e.PerformanceRating
    FROM employees e;
    """"""
    
    # Fetch data
    data = execute_sql_query(sql_query)
    
    # Step 2: Ensure the correct data types
    data['HireDate'] = pd.to_datetime(data['HireDate'])
    
    # Extract year for HireDate to analyze correlation
    data['HireYear'] = data['HireDate'].dt.year
    
    # Step 3: Calculate correlation
    correlation_data = data[['HireYear', 'PerformanceRating']].corr().iloc[0, 1]
    
    # Step 4: Visualize the correlation using a scatter plot
    fig = px.scatter(
        data,
        x='HireYear',
        y='PerformanceRating',
        title=f'Correlation between Hire Year and Performance Rating: {correlation_data:.2f}',
        labels={'HireYear': 'Hire Year', 'PerformanceRating': 'Performance Rating'},
        trendline='ols'  # Add a trendline for better insight
    )
   
    # Display the figure to the user
    show_to_user(fig)

# Call the function to execute it
analyze_hire_date_performance()
","The input code is not correct according to the specified business analytics request and the reference implementation. The reference code computes 'Performance' using 'TotalSales' as a proxy, calculated from detailed order information. In contrast, the input code directly uses 'PerformanceRating', and lacks the detailed sales calculation. Furthermore, the input code analyzes correlation with 'HireYear' instead of 'HireDate', which differs from the specific request to analyze and visualize the correlation between 'HireDate' and performance using a scatter plot.",Base
How many new customers were acquired in May 2023?,"```python
import pandas as pd

# SQL query to count distinct new customers acquired in May 2023
sql_query = """"""
SELECT COUNT(DISTINCT customers.CustomerID) AS new_customers 
FROM customers 
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
AND customers.CustomerID NOT IN (
    SELECT CustomerID 
    FROM orders 
    WHERE OrderDate < '2023-05-01')
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS new_customers
FROM orders
WHERE OrderDate BETWEEN '2023-05-01' AND '2023-05-31';
""""""
new_customers_data = execute_sql_query(sql_query)
show_to_user(new_customers_data)
```","The input code incorrectly counts all unique CustomerIDs with orders in May 2023, without excluding those who placed orders before May 2023. The reference implementation correctly excludes these customers, ensuring that only new customers acquired in May 2023 are counted.","```python
import pandas as pd

# Assume the function execute_sql_query is predefined elsewhere
# Example function signature for context:
# def execute_sql_query(sql_query: str) -> pd.DataFrame

# Given SQL query to acquire new customers
sql_query = """"""
SELECT COUNT(CustomerID) AS NewCustomers 
FROM customers 
WHERE EXTRACT(YEAR FROM CreationDate) = 2023 
AND EXTRACT(MONTH FROM CreationDate) = 5;
""""""

# Execute the SQL query and obtain the DataFrame
new_customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(new_customers_df)
```","The input code counts customers based on their 'CreationDate' in May 2023, which could include any new customer records entered in that month, regardless of whether they have made an order. The reference code checks for customers who placed their first order in May 2023 by ensuring it's not found in earlier months. These approaches differ because the input code does not consider order activity, only account creation.",None
Which suppliers provide products that are currently in stock?,"```python
import pandas as pd

# SQL Query to get suppliers with products currently in stock
sql_query = ""SELECT DISTINCT SupplierID FROM products WHERE UnitsInStock > 0""

# Execute the SQL query
supplier_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(supplier_df)
```","```python
sql_query = """"""
SELECT DISTINCT p.SupplierID, p.ProductName 
FROM products p 
WHERE p.UnitsInStock > 0 AND p.Discontinued = 0
""""""
data = execute_sql_query(sql_query)
show_to_user(data)
```","The input code includes a condition `p.Discontinued = 0`, which is not present in the reference code. This adds an extra filter by excluding discontinued products. Therefore, the logic of the input code does not match the reference code exactly. Additionally, the input code selects `p.ProductName` which is unnecessary for identifying suppliers.","```python
# Import necessary libraries
import pandas as pd

# Define SQL query to find suppliers with products in stock
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName
FROM suppliers
INNER JOIN products ON suppliers.SupplierID = products.SupplierID
WHERE products.UnitsInStock > 0;
""""""

# Execute the SQL query and store the results in a DataFrame
results_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(results_df)
```","The input code retrieves both SupplierID and CompanyName from the suppliers table by joining with products. The reference implementation only retrieves distinct SupplierID. The input code also seems to imply using a different schema since it involves an INNER JOIN with suppliers, which was not part of the reference.",None
Visualize the number of employees in each country to identify distribution using a map or bar chart.,"```python
import plotly.express as px

# Execute the SQL query and fetch data
sql_query = ""SELECT Country, COUNT(*) AS NumEmployees FROM employees GROUP BY Country;""
employees_df = execute_sql_query(sql_query)

# Create a map visualization using Plotly
fig_bar = px.bar(employees_df, x='Country', y='NumEmployees', title='Number of Employees per Country')

# Show the bar chart to the user
show_to_user(fig_bar)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Country, COUNT(EmployeeID) AS EmployeeCount
FROM employees
GROUP BY Country
ORDER BY EmployeeCount DESC
""""""

employee_distribution = execute_sql_query(sql_query)

fig = px.bar(employee_distribution, x='Country', y='EmployeeCount', title='Number of Employees by Country')
show_to_user(fig)
```","The input Python code correctly answers the business analytics request and adheres to the logic of the reference implementation. Both codes create a bar chart to visualize the number of employees per country. The input code includes an added `ORDER BY EmployeeCount DESC`, which is a valid addition and does not affect the correctness of the output. The column names used are equivalent, and the visualization function is correctly invoked.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the data
sql_query = """"""
SELECT Country, COUNT(EmployeeID) AS EmployeeCount
FROM employees
GROUP BY Country;
""""""
employee_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of employees per country
fig = px.bar(
    employee_data,
    x='Country',
    y='EmployeeCount',
    title='Number of Employees in Each Country',
    labels={'EmployeeCount': 'Number of Employees', 'Country': 'Country'}
)

# Show the plot to the user
show_to_user(fig)
```","The provided code correctly visualizes the number of employees per country using a bar chart, similar to the reference implementation. Both codes execute an SQL query to group employees by country, and use Plotly Express to create the bar chart. The differences in column names (NumEmployees vs. EmployeeCount) and specific wording in titles and labels do not impact the correctness of the logic or functionality.",both
Visualize the average fulfillment time for orders by month to identify seasonal trends using a line chart.,"```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
    SELECT EXTRACT(MONTH FROM OrderDate) AS Month, 
    AVG(DATEDIFF(DAY, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
    FROM orders 
    GROUP BY EXTRACT(MONTH FROM OrderDate)
""""""

# Execute the SQL query to get a dataframe
data = execute_sql_query(sql_query)

# Convert the Month column to integer in case it's not already
data['Month'] = data['Month'].astype(int)

# Sort the dataframe by Month to ensure correct order in the visualization
data = data.sort_values('Month')

# Create a line chart
fig = px.line(data, x='Month', y='AvgFulfillmentTime', 
              title='Average Fulfillment Time by Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'Month': 'Month'})

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS Avg_Fulfillment_Time
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='Month', y='Avg_Fulfillment_Time', 
              title='Average Fulfillment Time for Orders by Month',
              labels={'Avg_Fulfillment_Time': 'Average Fulfillment Time (Days)', 'Month': 'Month'})
show_to_user(fig)
```","The input code groups by 'Month' with '%Y-%m', potentially using year and month, while the reference uses only month from the date. This could affect the aggregation level, showing different monthly trends. The logic of extracting and grouping, thus, changes between the two implementations, making the input code incorrect per the given requirements.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the required data
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time 
FROM 
    orders 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(df, x='month', y='avg_fulfillment_time', 
              title='Average Fulfillment Time by Month',
              labels={'avg_fulfillment_time': 'Average Fulfillment Time (days)', 'month': 'Month'},
              markers=True)

# Display the visualization to the user
show_to_user(fig)
```","The input code calculates the average fulfillment time by year-month (using DATE_FORMAT on '%Y-%m'), rather than aggregating just by month as asked (similar to EXTRACT(MONTH) in the reference code). This means it identifies trends across year-months rather than by month, which can obscure monthly seasonal trends.",None
How many days on average does it take to fulfill an order?,"```python
import pandas as pd

# Execute SQL query and retrieve data
df = execute_sql_query(""SELECT OrderDate, ShippedDate FROM orders"")

# Calculate average fulfillment time
df['FulfillmentTime'] = (pd.to_datetime(df['ShippedDate']) - pd.to_datetime(df['OrderDate'])).dt.days
avg_fulfillment_time = df['FulfillmentTime'].mean()

# Create a DataFrame to display the result
result_df = pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]})

# Display result to user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL AND OrderDate IS NOT NULL
""""""

average_fulfillment_time = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time)
```","The input code correctly calculates the average fulfillment time by using SQL's AVG and DATEDIFF functions to determine the difference between ShippedDate and OrderDate directly in the database. It filters out any null ShippedDate or OrderDate values to ensure accurate calculation, which aligns with the logic of the reference implementation. Both approaches achieve the same result of calculating the average number of days to fulfill an order.","```python
import pandas as pd

# Function to execute SQL query and fetch result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation; replace with actual database connection logic
    # For demonstration, returning a hardcoded pandas DataFrame
    data = {'AverageDaysToFulfill': [5.2]}  # Example average
    return pd.DataFrame(data)

# Function to display data or results to a user
def show_to_user(data: pd.DataFrame) -> None:
    print(data)

# SQL query to calculate the average days to fulfill an order
sql_query = """"""
SELECT AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageDaysToFulfill 
FROM orders;
""""""

# Execute the query and get results
results_df = execute_sql_query(sql_query)

# Show results to the user
show_to_user(results_df)
```","The provided code does not perform the calculation of average fulfillment time similar to the reference implementation. Instead, it queries the database directly for the average days to fulfill an order using SQL and returns a hardcoded DataFrame as an example, which doesn't replicate the computation logic. The reference code retrieves all data and performs the calculation of day differences in Python, whereas the input code assumes the SQL query provides the result directly.",Base
What is the average discount applied per product?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute SQL query and retrieve data as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the average discount result to the user
average_discount = df['AverageDiscount'].iloc[0]
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))
```","```python
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY ProductID
""""""
average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code calculates the average discount per ProductID, not the overall average discount as specified in the business request. The reference code computes a single average discount value from the entire dataset, while the input code computes separate average discounts for each product, which is not aligned with the request.","```python
# SQL Query to get the average discount applied per product
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];
""""""

# Execute the SQL query and store the result in a DataFrame
import pandas as pd

# Assume execute_sql_query is already defined in the environment.
results_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(results_df)
```","The input Python code correctly executes the SQL query to calculate the average discount applied per product and retrieves the result using `execute_sql_query`. It then displays the result directly to the user with `show_to_user(results_df)`. This logic matches the reference implementation, which also calculates and displays the average discount, even though the handling of the display operation is slightly different.",Finetuned
Which suppliers have supplied the most products?,"```python
import pandas as pd

# SQL query to get suppliers and the count of products they supplied
sql_query = """"""
SELECT s.SupplierID, COUNT(p.ProductID) AS TotalProductsSupplied 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID 
ORDER BY TotalProductsSupplied DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.SupplierID, COUNT(p.ProductID) AS ProductCount
FROM products p
GROUP BY p.SupplierID
ORDER BY ProductCount DESC
""""""

suppliers_product_count = execute_sql_query(sql_query)
show_to_user(suppliers_product_count)
```","The provided code does not join the 'suppliers' and 'products' tables, hence it doesn't distinguish between suppliers specifically. It assumes 'SupplierID' exists only in the 'products' table, differing from the reference, which performs a join and groups by 'suppliers'.","```python
import pandas as pd

# Execute the SQL query to retrieve data on the number of products supplied by each supplier
sql_query = """"""
SELECT suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.CompanyName 
ORDER BY COUNT(products.ProductID) DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
df_results = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df_results)
```","The input Python code correctly answers the business analytics request by identifying which suppliers have supplied the most products. It selects the supplier names from the 'suppliers' table and counts the products per supplier, ordering by the count in descending order. This matches the logic of the reference implementation, which also counts products per supplier and orders by that count.",Finetuned
Visualize which regions have the highest on-time delivery rates using a bar chart or heat map.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipRegion, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID)) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipRegion', y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rates by Region',
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'ShipRegion': 'Region'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rates by region
sql_query = """"""
SELECT ShipRegion, 
       COUNT(OrderID) AS TotalOrders,
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM orders
GROUP BY ShipRegion
""""""

# Execute the SQL query
delivery_data = execute_sql_query(sql_query)

# Calculate on-time delivery rate
delivery_data['OnTimeDeliveryRate'] = delivery_data['OnTimeDeliveries'] / delivery_data['TotalOrders'] * 100

# Create a bar chart for on-time delivery rates by region
fig = px.bar(delivery_data, x='ShipRegion', y='OnTimeDeliveryRate',
             title='On-time Delivery Rates by Region',
             labels={'OnTimeDeliveryRate': 'On-time Delivery Rate (%)', 'ShipRegion': 'Region'})

# Show the visualization
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rates by region. It executes an SQL query to get the necessary data, calculates the rate as a percentage, and then creates a bar chart similar to the reference implementation. The logic and end goal are aligned, even though the SQL query construction method differs slightly, achieving the same result.","
import pandas as pd
import plotly.express as px

# SQL query to extract on-time delivery rates by region
sql_query = """"""
SELECT RegionID, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN OrderID END) * 100.0 / COUNT(OrderID) AS OnTimeRate 
FROM orders 
GROUP BY RegionID;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the on-time delivery rates by region
fig = px.bar(df, x='RegionID', y='OnTimeRate', 
             title='On-Time Delivery Rates by Region',
             labels={'OnTimeRate': 'On-Time Delivery Rate (%)', 'RegionID': 'Region ID'})

# Display the visualization to the user
show_to_user(fig)
","The input code uses 'RegionID' instead of 'ShipRegion', which might not represent the region's name comprehensively. The reference implementation uses 'ShipRegion', indicating a potential mismatch in reporting granularity. Additionally, 'ORDER BY OnTimeDeliveryRate DESC' is missing in the input code, affecting the ordering of results.",Base
How many orders were handled by employees who were hired in the year 2020?,"```python
sql_query = """"""
    SELECT COUNT(orders.OrderID) AS TotalOrders
    FROM employees
    JOIN orders ON employees.EmployeeID = orders.EmployeeID
    WHERE YEAR(HireDate) = 2020;
""""""

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(o.OrderID) AS TotalOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE YEAR(e.HireDate) = 2020
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code correctly matches the logic of the reference implementation. Both queries count the number of orders handled by employees hired in 2020 by joining the 'employees' and 'orders' tables on 'EmployeeID'. The naming conventions for table aliases differ, but the operations and conditions are equivalent.","```python
import pandas as pd

# SQL query to get the number of orders handled by employees hired in 2020
sql_query = '''
SELECT COUNT(OrderID) AS OrdersHandledBy2020Employees
FROM orders
INNER JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE YEAR(employees.HireDate) = 2020
'''

# Executing the SQL query and storing the result in a pandas DataFrame
orders_handled_df = execute_sql_query(sql_query)

# Displaying the result
show_to_user(orders_handled_df)
```","The provided input code executes a SQL query that correctly counts the number of orders by employees hired in 2020, adhering to the logic of the reference code. Both codes use an INNER JOIN on 'employees' and 'orders' tables using 'EmployeeID', and filter by 'HireDate' using YEAR function. The results are displayed to the user through a similar mechanism, making the input code logically correct.",both
Visualize the average discount applied to products per month using a line chart to identify trends.,"```python
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       AVG(Discount) AS AverageDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Convert 'month' column to string if needed (ensure consistent data type)
data['month'] = data['month'].astype(str)

# Create a line chart using plotly
fig = px.line(data, x='month', y='AverageDiscount', title='Average Discount per Month')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    AVG([Order Details].Discount) AS Average_Discount
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

average_discount_data = execute_sql_query(sql_query)

fig = px.line(average_discount_data, x='Month', y='Average_Discount', title='Average Discount Applied to Products per Month')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It fetches data on the average discount per month from a database, similar to the reference code. The SQL query used filters data by month, calculates average discounts, and orders the results by month. The visualization part of the code utilizes Plotly Express to create a line chart, matching the functionality of the reference implementation. Both implementations handle the same logic, ensuring the correctness of the trend identification through visual representation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average discount applied to products per month
sql_query = """"""
SELECT 
    TO_CHAR(OrderDate, 'YYYY-MM') AS month, 
    AVG(Discount) AS avg_discount 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY 
    TO_CHAR(OrderDate, 'YYYY-MM')
""""""

# Execute the SQL query and get the result as a DataFrame
data = execute_sql_query(sql_query)

# Create a line chart to visualize the average discount per month
fig = px.line(data, x='month', y='avg_discount', title='Average Discount Per Month')

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly implements the business analytics request by querying the average discount per month and uses Plotly Express to create a line chart to visualize this data. The logic is consistent with the reference code: both execute a SQL query to group discounts by month, calculate the average, and plot this average. The input code uses 'TO_CHAR' for date formatting, which is appropriate for certain SQL database systems, while the reference uses 'DATE_FORMAT'. Both serve the purpose of extracting the year and month from the date. Thus, the input code aligns with the reference implementation's logic.",both
What is the average time between order date and required date?,"```python
import pandas as pd

# SQL query to calculate average time between order date and required date
sql_query = """"""
SELECT OrderDate, RequiredDate FROM orders;
""""""

# Execute the SQL query and get the result in a dataframe
df = execute_sql_query(sql_query)

# Calculate the average time between order date and required date
df['OrderDate'] = pd.to_datetime(df['OrderDate'])
df['RequiredDate'] = pd.to_datetime(df['RequiredDate'])
df['LeadTime'] = (df['RequiredDate'] - df['OrderDate']).dt.days
average_lead_time = df['LeadTime'].mean()

# Display the result to the user
show_to_user(pd.DataFrame({'AverageLeadTime': [average_lead_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(RequiredDate, OrderDate)) AS AverageTime
FROM orders
""""""

average_time_df = execute_sql_query(sql_query)
show_to_user(average_time_df)
```","Both implementations achieve the same goal: calculating the average time between the order date and the required date. The reference code computes the difference in days in Python after fetching the dates from the database, while the input code calculates the difference directly in the SQL query using DATEDIFF and returns the average. Both approaches correctly compute the desired metric.","
```python
import pandas as pd

# Utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation to execute the SQL query and return a DataFrame
    pass

def show_to_user(data: pd.DataFrame):
    # Implementation to display the DataFrame
    pass

# SQL query provided
sql_query = """"""
SELECT AVG(JULIANDAY(RequiredDate) - JULIANDAY(OrderDate)) AS AverageTime
FROM orders;
""""""

# Execute the query and get the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result using the utility function
show_to_user(result_df)
```","The provided Python code uses an SQL query to directly calculate the average time between the 'RequiredDate' and 'OrderDate' using the `JULIANDAY` function. This approach is equivalent to the reference implementation which manually calculates the difference in days after retrieving the data into a DataFrame. Both implementations achieve the same result by calculating the average difference between the two dates, adhering to the same logic.",both
How many products have a stock level below their reorder level?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(ProductName) as NumProductsBelowReorder FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the query and get the result as a Pandas DataFrame
products_below_reorder = execute_sql_query(sql_query)

# Prepare the result to show to user
result_df = pd.DataFrame({'Number of Products Below Reorder Level': products_below_reorder['NumProductsBelowReorder']})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS ProductCount
FROM products
WHERE UnitsInStock < ReorderLevel
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The evaluated code correctly counts the number of products with stock levels below the reorder level by querying the database with SQL. The logic and the condition in the WHERE clause match the reference implementation. Although the column name for the count is different, the query logic and output serve the same purpose, which is to identify the number of such products. The result is then displayed using the show_to_user function, similar to the reference implementation.","```python
# Define the SQL query
sql_query = ""SELECT COUNT(*) FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
low_stock_count = execute_sql_query(sql_query)

# Display the result
show_to_user(low_stock_count)
```","Both the input and reference implementations correctly count the number of products with a stock level below the reorder level using an SQL query. The input code uses COUNT(*) which counts all rows and simplifies the process compared to COUNT(ProductName) but achieves the same result. The display methods differ slightly, but they do not affect the correctness of the calculation.",both
Which orders were delayed more than five days past the required date?,"```python
import pandas as pd

# Retrieve all orders
all_orders_df = execute_sql_query(""SELECT OrderID, ShippedDate, RequiredDate FROM orders"")

# Calculate the delay in days
all_orders_df['DelayDays'] = (all_orders_df['ShippedDate'] - all_orders_df['RequiredDate']).dt.days

# Filter orders delayed more than 5 days
delayed_orders_df = all_orders_df[all_orders_df['DelayDays'] > 5][['OrderID']]

# Display the result to the user
show_to_user(delayed_orders_df)
```","```python
sql_query = """"""
SELECT OrderID, RequiredDate, ShippedDate 
FROM orders 
WHERE DATEDIFF(ShippedDate, RequiredDate) > 5
""""""

delayed_orders = execute_sql_query(sql_query)
show_to_user(delayed_orders)
```","The provided input code directly retrieves orders where the shipped date is more than 5 days after the required date using a SQL query with the DATEDIFF function. This achieves the same logical outcome as the reference implementation, which calculates the delay in days and filters orders with a delay greater than 5 days. Both approaches identify orders delayed by more than 5 days.","```python
import pandas as pd

# SQL query to find delayed orders
sql_query = """"""
SELECT OrderID FROM orders WHERE DATEDIFF(ShippedDate, RequiredDate) > 5;
""""""

# Execute the SQL query and get the data
delayed_orders_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(delayed_orders_df)
```","The input code correctly identifies orders delayed more than five days past the required date using an SQL query that calculates delay directly in the database. This matches the logic of the reference code, which calculates the delay in steps and then filters the orders in Python.",both
What is the average time taken to fulfill an order?,"```python
import pandas as pd

# SQL query to get the average fulfillment time
sql_query = """"""
SELECT AVG(DATE_PART('day', ShippedDate::timestamp - OrderDate::timestamp)) AS AverageFulfillmentTime FROM orders;
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Extract the average fulfillment time from the dataframe
average_fulfillment_time = df.loc[0, 'AverageFulfillmentTime']

# Display the result to the user
show_to_user(pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
""""""
average_fulfillment_time = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time)
```","The input code calculates the average fulfillment time using the DATEDIFF function, which determines the difference in days between the 'ShippedDate' and 'OrderDate', similar to the DATE_PART('day', ...) used in the reference implementation. Both approaches aim to calculate the average difference in days between order fulfillment dates. The final output is appropriately used to display the result as intended. Thus, the logic aligns with the reference implementation.","```python
import pandas as pd

# SQL Query to fetch the average fulfillment time
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time 
FROM orders;
""""""

# Execute the SQL query and store the result in a DataFrame
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result)
```",The input code correctly calculates the average fulfillment time using a SQL query that computes the difference between 'ShippedDate' and 'OrderDate'. The logic is consistent with the reference implementation as both use SQL functions to find the difference in days and then average it. The difference in function names (DATE_PART vs DATEDIFF) is due to specific SQL dialects but serves the same purpose. The result is displayed correctly using the show_to_user function.,both
Calculate and visualize the total value of current inventory (UnitPrice * UnitsInStock) for all products using a pie chart or bar chart for better understanding.,"```python
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT UnitPrice, UnitsInStock FROM products;""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Calculate the total inventory value
total_inventory_value = (df['UnitPrice'] * df['UnitsInStock']).sum()

# Create a bar chart to visualize the total inventory value
fig = px.bar(x=['Total Inventory Value'], y=[total_inventory_value], 
             title='Total Value of Current Inventory', labels={'x': 'Category', 'y': 'Value'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ProductName, 
    UnitPrice * UnitsInStock AS TotalInventoryValue
FROM 
    products
WHERE 
    Discontinued = 0
""""""

inventory_data = execute_sql_query(sql_query)

fig = px.pie(inventory_data, values='TotalInventoryValue', names='ProductName', title='Total Inventory Value by Product')
show_to_user(fig)
```","The input code calculates the total inventory value for each product and visualizes it using a pie chart, segmenting by 'ProductName'. The reference code calculates a single total inventory value for all products combined and visualizes this with a bar chart. Therefore, the logic and final output of the input and reference codes differ. Additionally, the input code filters for non-discontinued products, which is not present in the reference code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, (UnitPrice * UnitsInStock) AS InventoryValue FROM products;""

# Execute the SQL query and get the result as a DataFrame
products_df = execute_sql_query(sql_query)

# Calculate total inventory value
products_df['TotalInventoryValue'] = products_df['InventoryValue'].sum()

# Visualize the total value of current inventory as a pie chart
fig = px.pie(
    products_df,
    names='ProductID',
    values='InventoryValue',
    title='Total Inventory Value by Product',
    hover_data=['InventoryValue']
    )

# Show the visualization to the user
show_to_user(fig)
```
","The input code computes and visualizes individual product inventory values using a pie chart, whereas the reference code calculates the total inventory value across all products and visualizes it using a bar chart. The business request focuses on total inventory value, not individual product inventories, thus the input code does not adhere to the specified requirements.",None
What is the average lead time for each supplier? Visualize the average lead time using a bar chart to compare suppliers effectively.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY products.SupplierID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Ensure 'AverageLeadTime' is treated as a float for plotting
df['AverageLeadTime'] = df['AverageLeadTime'].astype(float)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', 
             title='Average Lead Time for Each Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (days)'}, 
             height=400)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
GROUP BY s.SupplierID, s.CompanyName
""""""

average_lead_time_df = execute_sql_query(sql_query)

fig = px.bar(average_lead_time_df, x='CompanyName', y='AverageLeadTime', 
             title='Average Lead Time for Each Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly calculates the average lead time for each supplier by joining the 'suppliers', 'products', and 'orders' tables. It uses a subquery to connect products with order details similar to the reference. The main difference is that it includes 'CompanyName' for more informative visualization, which does not impact correctness. The bar chart still visualizes the average lead time effectively.","```python
import pandas as pd
import plotly.express as px

# Execute the provided SQL query and get the results as a DataFrame
sql_query = """"""
SELECT suppliers.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID;
""""""

# Assuming the execute_sql_query function is implemented as specified
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average lead time for each supplier
fig = px.bar(
    data,
    x='SupplierID',
    y='AvgLeadTime',
    title='Average Lead Time per Supplier',
    labels={'AvgLeadTime': 'Average Lead Time (days)', 'SupplierID': 'Supplier ID'},
    text='AvgLeadTime'
)

# Show the bar chart to the user
show_to_user(fig)

```
","The input code correctly calculates the average lead time for each supplier using a similar SQL logic as the reference implementation. It retrieves SupplierID and the average lead time by joining suppliers, products, Order Details, and orders tables. The calculations and grouping are done correctly with respect to the suppliers. The visualization is created using Plotly, with the appropriate labels and titles similar to the reference code. Although column names differ slightly (AvgLeadTime vs. AverageLeadTime), they serve the same purpose and ensure the correct functionality.",both
List all orders including the details of the employee who handled them.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT orders.OrderID, orders.CustomerID, orders.OrderDate, 
       employees.LastName, employees.FirstName 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)
```","```python
sql_query = """"""
SELECT o.OrderID, o.CustomerID, o.OrderDate, o.RequiredDate, o.ShippedDate, 
       o.ShipName, o.ShipAddress, o.ShipCity, o.ShipRegion, o.ShipPostalCode, o.ShipCountry,
       e.EmployeeID, e.FirstName, e.LastName, e.Title
FROM orders o
JOIN employees e ON o.EmployeeID = e.EmployeeID
""""""
orders_with_employee_details = execute_sql_query(sql_query)
show_to_user(orders_with_employee_details)
```","The input code correctly lists all orders with details of the employee who handled them, similar to the reference implementation. It includes additional fields in the SELECT clause but also covers the main ones needed (OrderID, CustomerID, OrderDate, and Employee details). The join condition is identical, ensuring each order is linked to the corresponding employee.","
```python
# Define the SQL query to join 'employees' and 'orders' tables
sql_query = """"""
SELECT o.*, e.*
FROM orders o
JOIN employees e ON o.EmployeeID = e.EmployeeID;
""""""

# Execute the SQL query using the provided utility function
orders_with_employee_details = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_with_employee_details)
```","The input code correctly joins the 'orders' and 'employees' tables on 'EmployeeID' to include order details with the corresponding employee information. While the columns selected in the output include more fields than the reference code, it adheres to the business request and provides all relevant details, thus fulfilling the requirement.",both
What is the total quantity of products ordered from each employee? Use a pie chart to illustrate the proportion of total orders handled by each employee.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalQuantity 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and retrieve the data into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a pie chart using plotly express
fig = px.pie(df, names='EmployeeID', values='TotalQuantity', 
             title='Proportion of Total Orders Handled by Each Employee')

# Display the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, EmployeeName
""""""

data = execute_sql_query(sql_query)

fig = px.pie(data, values='TotalQuantity', names='EmployeeName', title='Total Quantity of Products Ordered from Each Employee')
show_to_user(fig)
```","The input Python code fulfills the business analytics request correctly. It calculates the total quantity of products ordered for each employee and creates a pie chart to illustrate the proportion of total orders handled by each employee. Although the input code adds an additional concatenation of first and last names as 'EmployeeName', it does not impact the correctness of the task, which is concerned with displaying order distribution among employees. The aggregation logic and pie chart creation are consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Business Analytic Request
def calculate_employee_order_distribution():
    # Define the SQL query
    sql_query = """"""
    SELECT employees.EmployeeID, 
    SUM([Order Details].Quantity) AS total_quantity
    FROM employees
    JOIN orders ON employees.EmployeeID = orders.EmployeeID
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
    GROUP BY employees.EmployeeID
    """"""

    # Execute the SQL query to get the data
    employee_order_data = execute_sql_query(sql_query)

    # Create a pie chart to visualize the proportion of total orders by each employee
    fig = px.pie(employee_order_data, names='EmployeeID', values='total_quantity', 
                 title='Proportion of Total Orders Handled by Each Employee')

    # Display the pie chart
    show_to_user(fig)

# Execute the function
calculate_employee_order_distribution()
```","The input code correctly implements the required business analytics request. It defines an SQL query that selects the EmployeeID and the total quantity of products ordered by each employee. It then uses Plotly Express to create a pie chart that visualizes the distribution of orders, similar to the logic in the reference implementation. The slight differences in variable naming or function encapsulation do not affect the correctness, as the essential logic and outcome match the reference code.",both
How many orders were shipped late in the last month?,"```python
import pandas as pd
from datetime import datetime

# Calculate the last month details
today = datetime.today()
first_day_of_this_month = today.replace(day=1)
last_month = first_day_of_this_month - pd.DateOffset(days=1)
last_month_year = last_month.year
last_month_number = last_month.month

# SQL query to count late orders in the last month
sql_query = f""""""
SELECT COUNT(orders.OrderID) AS Late_Orders
FROM orders
WHERE orders.RequiredDate < orders.ShippedDate
AND MONTH(orders.OrderDate) = {last_month_number}
AND YEAR(orders.OrderDate) = {last_month_year};
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta

# Calculate the first and last dates of the last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to count late orders
sql_query = f""""""
    SELECT COUNT(*) AS LateOrders
    FROM orders
    WHERE ShippedDate > RequiredDate
    AND OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
    AND OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(late_orders_df)
```","The input code correctly calculates the first and last dates of the last month, forming the correct SQL query to count late orders where the ShippedDate is greater than the RequiredDate, and the OrderDate falls within the last month. This logic matches the reference implementation in essence, making the input code correct.","
from datetime import datetime, timedelta

# Define helper functions
def execute_sql_query(sql_query: str):
    # Simulating SQL execution and returning a DataFrame
    # Implement actual database connection and execution logic
    import pandas as pd
    # Sample data simulating SQL result
    data = [(5,)]
    return pd.DataFrame(data, columns=[""LateOrders""])

def show_to_user(data):
    # Display data to the user
    print(data)

# Calculate the date range for the last month
today = datetime.now()
first_day_this_month = datetime(today.year, today.month, 1)
last_month_last_day = first_day_this_month - timedelta(days=1)
last_month_first_day = datetime(last_month_last_day.year, last_month_last_day.month, 1)

# SQL query
sql_query = f""""""
SELECT COUNT(o.OrderID) AS LateOrders
FROM orders o
WHERE o.ShippedDate > o.RequiredDate
AND MONTH(o.OrderDate) = MONTH(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH))
AND YEAR(o.OrderDate) = YEAR(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH));
""""""

# Execute and show result
late_orders_df = execute_sql_query(sql_query)
show_to_user(late_orders_df)
","The input code correctly calculates the number of late orders shipped in the last month. It follows the same logic as the reference implementation by determining the last month using the current date, constructing a SQL query to count orders where the shipped date is later than the required date, and using the correct conditions for the month and year. Both codes use similar calculations to handle date offsets and achieve the same result.",both
"How many orders were shipped late (i.e., shipped after the required date)?","```python
import pandas as pd

# SQL query to count late orders
sql_query = ""SELECT COUNT(*) AS LateOrders FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(late_orders_df['LateOrders'][0])
```","```python
sql_query = """"""
SELECT COUNT(*) AS LateOrders
FROM orders
WHERE ShippedDate > RequiredDate
""""""
late_orders_df = execute_sql_query(sql_query)
show_to_user(late_orders_df)
```","The input Python code does not correctly extract and display the count of late orders. While the SQL query and execution are correct, the display function 'show_to_user' is incorrectly used. It should specifically fetch and display the value within 'LateOrders', similar to the indexing done in the reference code: late_orders_df['LateOrders'][0].","```python
import pandas as pd

# Function to execute SQL queries and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for context
    # Assume this function interacts with the database and fetches the results.
    pass

# Function to show data to the user
def show_to_user(data):
    # Dummy implementation for context
    # Assume this function presents data in an understandable manner.
    pass

# SQL query to get the count of late shipments
query = """"""
SELECT COUNT(OrderID) AS LateOrders 
FROM orders 
WHERE ShippedDate > RequiredDate;
""""""

# Execute the query using the provided utility function
late_orders_df = execute_sql_query(query)

# Display the result to the user
show_to_user(late_orders_df)
```","The input code correctly answers the business analytics request by executing an SQL query that counts the number of late orders, where ShippedDate is greater than RequiredDate. While the reference code uses 'COUNT(*)' and the input code uses 'COUNT(OrderID)', both effectively achieve the same outcome by counting late orders. Additionally, the input code correctly uses the provided utility functions to execute the SQL query and present the results, matching the intended logic of the reference implementation.",Finetuned
Which employee has the most orders shipped on time? Display the comparison using a bar chart.,"```python
import plotly.express as px

# SQL query to get employee IDs and count of on-time orders
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OnTimeOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate <= o.RequiredDate
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using plotly express
fig = px.bar(df, x='EmployeeID', y='OnTimeOrders', title='On-Time Orders by Employee')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
       COUNT(o.OrderID) AS OnTimeOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate <= o.RequiredDate
GROUP BY e.EmployeeID
ORDER BY OnTimeOrders DESC
LIMIT 10
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='EmployeeName', y='OnTimeOrders', title='Employees with Most On-time Orders', labels={'OnTimeOrders': 'Number of On-time Orders'})
show_to_user(fig)
```","The input code includes additional changes not present in the reference implementation, such as adding a concatenated 'EmployeeName' field and modifying the query to order and limit the results to the top 10 employees. The task asks for the employee with the most on-time orders, but the input code is focused on displaying the top 10 employees instead, which deviates from the requested task.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be predefined elsewhere to fetch results from the database
    pass

def show_to_user(data):
    # This function is assumed to be predefined elsewhere to display the results
    pass

# SQL query to get the number of on-time shipments per employee
sql_query = """"""
SELECT employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OnTimeOrders
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE orders.ShippedDate <= orders.RequiredDate
GROUP BY employees.FirstName, employees.LastName
ORDER BY OnTimeOrders DESC
LIMIT 5
""""""

# Execute the query and get the data in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='OnTimeOrders', y=df.index, orientation='h',
             labels={'x': 'Number of On-Time Orders', 'y': 'Employee'},
             title='Top Employees by On-Time Order Shipments')

# Display the bar chart
show_to_user(fig)
```","The input code fetches and displays the top 5 employees with the most on-time orders, using their FirstName and LastName, instead of EmployeeID. This deviates from the reference code, which lists all employees by EmployeeID without a limit. The input code also changes the orientation of the bar chart from vertical to horizontal. These differences do not fully adhere to the logic of the reference implementation.",None
What is the most frequently ordered product? Use a bar chart to show frequency counts for the top ordered products.,"```python
import plotly.express as px

# Define the SQL query to get the frequency of ordered products
sql_query = """"""
SELECT p.ProductName, COUNT(od.ProductID) AS OrderCount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY OrderCount DESC
""""""

# Execute the SQL query and retrieve the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Correcting the code: Select only the top products
df_top = df.head(10)  # Assuming we want to display top 10 products

# Create a bar chart using plotly to visualize the frequency counts for the top ordered products
fig = px.bar(df_top, x='ProductName', y='OrderCount', title='Top Ordered Products by Frequency')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
LIMIT 10
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductID', y='TotalQuantity', title='Top Ordered Products', labels={'TotalQuantity': 'Order Frequency', 'ProductID': 'Product ID'})
show_to_user(fig)
```","The input code calculates the top ordered products based on the total quantity ordered ('SUM(od.Quantity)'), while the reference code determines it by the number of times a product appears in orders ('COUNT(od.ProductID)'). Additionally, the input code joins with the 'orders' table instead of 'products', which results in selecting and displaying 'ProductID' rather than 'ProductName'. Thus, the logic differs from the reference implementation, which identifies products by their name and uses order frequency instead of total quantity.","```python
import pandas as pd
import plotly.express as px

# Defining the SQL query
sql_query = """"""
SELECT products.ProductName, COUNT([Order Details].OrderID) AS order_count 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY order_count DESC
""""""

# Execute SQL query and fetch data
data = execute_sql_query(sql_query)

# Create a bar chart for top ordered products
fig = px.bar(data, x='ProductName', y='order_count', title='Top Ordered Products')

# Display the bar chart to the user
show_to_user(fig)
```",The input code does not limit the number of top ordered products displayed. The reference code specifically selects the top 10 products with 'df_top = df.head(10)'. Adding this step would make it consistent with the reference implementation.,None
Which products have a unit price greater than 50?,"```python
sql_query = ""SELECT ProductName FROM products WHERE UnitPrice > 50;""
products_df = execute_sql_query(sql_query)
show_to_user(products_df)
```","```python
sql_query = ""SELECT ProductID, ProductName, UnitPrice FROM products WHERE UnitPrice > 50""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code retrieves additional fields (ProductID and UnitPrice) that are not part of the original request, which specifically asks for only the ProductName. The logic of the request is to filter products with a unit price greater than 50 and show only their names, matching the reference implementation.","```python
## Code to execute the SQL query in the predefined utility function
execute_sql_query(""SELECT ProductID, ProductName FROM products WHERE UnitPrice > 50;"")
```","The provided code executes an SQL query that selects both ProductID and ProductName, while the reference implementation only selects ProductName. Furthermore, the provided code does not store or display the results using 'show_to_user', which is part of the request.",None
How many units of each product were ordered last month? Visualize the data using a bar chart for a clear comparison.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].Quantity) AS UnitsOrderedLastMonth 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderDate >= DATEADD(month, -1, GETDATE()) 
GROUP BY products.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='UnitsOrderedLastMonth', 
             title='Units Ordered Last Month by Product', 
             labels={'UnitsOrderedLastMonth':'Units Ordered', 'ProductID':'Product ID'})

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the first and last day of the last month
today = datetime.now()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to get the quantity of each product ordered last month
sql_query = f""""""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) as TotalOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN '{first_day_last_month.date()}' AND '{last_day_last_month.date()}'
GROUP BY p.ProductID, p.ProductName
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(data, x='ProductName', y='TotalOrdered', title='Units Ordered Last Month',
             labels={'TotalOrdered': 'Total Units Ordered', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly computes the units ordered by selecting products and joins with '[Order Details]' using matching product IDs. The time frame is determined correctly as the last month's first and last days, and a sum of quantities is computed, similar to the reference. Although it includes 'ProductName' for more detailed visualization, and uses an additional join on the 'orders' table, it adheres to the primary logic. It visualizes the data using a bar chart with plotly, which satisfies the business request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
WHERE OrderID IN (
    SELECT OrderID 
    FROM orders 
    WHERE EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
    AND EXTRACT(MONTH FROM OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE) - 1
) 
GROUP BY ProductID;
""""""

# Execute the query and get the data
df = execute_sql_query(sql_query)

# Create the bar chart
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Units of Each Product Ordered Last Month')

# Display the visualization
show_to_user(fig)
```","The input code uses a subquery to filter orders from the previous month, but it does not consider orders from the current year and incorrect handling of year boundary situations. Additionally, it does not join with the 'products' table as the reference code does. This leads to potential discrepancies if product IDs in 'Order Details' don't fully match those in 'products'. The reference code ensures analysis under every condition through a proper JOIN and uses date functions compatible across months and years.",Base
Which shipping company has the highest on-time delivery rate? A bar chart can show the on-time delivery rates for easy comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the data
sql_query = """"""
SELECT shippers.CompanyName, 
    COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / 
    CAST(COUNT(orders.OrderID) AS float) AS on_time_delivery_rate 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY on_time_delivery_rate DESC
""""""

# Execute the SQL query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the company with the highest on-time delivery rate
top_company = df.iloc[0]
show_to_user(top_company)

# Create a bar chart for on-time delivery rates
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate', 
             title='On-Time Delivery Rates by Shipping Company')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, 
       COUNT(orders.OrderID) AS total_orders, 
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) AS on_time_deliveries
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

results = execute_sql_query(sql_query)
results['on_time_delivery_rate'] = results['on_time_deliveries'] / results['total_orders'] * 100
fig = px.bar(results, x='CompanyName', y='on_time_delivery_rate', 
             title='On-time Delivery Rates by Shipping Company', 
             labels={'on_time_delivery_rate': 'On-time Delivery Rate (%)', 'CompanyName': 'Shipping Company'})
show_to_user(fig)
```","The input Python code correctly calculates the on-time delivery rate for each shipping company, matches the logic of the reference implementation, and presents the data in a bar chart. The main difference is that the input code explicitly calculates the total orders and on-time deliveries before computing the on-time delivery rate, while the reference uses SQL with a FILTER clause directly. Both approaches yield the same outcome, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT shipper.SupplierID, AVG(shipper.OnTime) AS OnTimeRate
FROM (
    SELECT o.ShippedDate, o.OrderID, o.ShipVia, 
           CASE WHEN o.ShippedDate <= o.RequiredDate THEN 1 ELSE 0 END AS OnTime,
           o.EmployeeID
    FROM orders o
) shipper
GROUP BY shipper.SupplierID
ORDER BY OnTimeRate DESC
LIMIT 1;
""""""

# Executing the SQL query
data = execute_sql_query(sql_query)

# Creating a bar chart for comparison
fig = px.bar(data, x='SupplierID', y='OnTimeRate', title='On-Time Delivery Rates by Shipping Company')

# Showing the visualization
show_to_user(fig)
```","The input Python code is incorrect because it selects 'SupplierID' instead of 'CompanyName' for grouping, which is inconsistent with the reference implementation. Additionally, the input limits the output to a single entry with 'LIMIT 1', not providing the full comparison across companies as required for a bar chart. Moreover, 'SupplierID' appears incorrect for 'ShipperID' used in the reference. Thus, it fails to provide a complete view of on-time delivery rates per shipping company.",Base
What is the total discount amount given for each product? Use a bar chart to display the total discount amounts.,"```python
import plotly.express as px

# SQL query to retrieve total discount amount for each product
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to display the total discount amounts
fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Total Discount Amount for Each Product')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Discount) AS TotalDiscount 
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductName', y='TotalDiscount', title='Total Discount Amount by Product')
show_to_user(fig)
```","The input Python code computes the total discount as the sum of raw discount values, but the reference implementation multiplies by UnitPrice and Quantity to calculate the total discount amount. Therefore, the logic differs, leading to incorrect computation results.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the total discount for each product
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS TotalDiscount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName
""""""

# Assume this function is defined elsewhere, returning a DataFrame
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to display the total discount amounts for each product
fig = px.bar(result_df, x='ProductName', y='TotalDiscount', 
             title='Total Discount Amount by Product',
             labels={'TotalDiscount': 'Total Discount', 'ProductName': 'Product Name'})

# Display the bar chart using the assumed existing function
show_to_user(fig)
```","The provided code captures the same logic as the reference implementation. Both codes execute an SQL query to compute the total discount amount for each product and use Plotly to create a bar chart displaying the results. The SQL query structures in both codes join the 'products' and 'Order Details' tables using the ProductID and calculate the total discount using the same formula. Although variable names and chart titles are slightly different, these differences do not affect the logical correctness of the implementation.",Finetuned
Calculate the total number of products sold by each employee. Represent the data using a bar chart.,"```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].Quantity) AS TotalProductsSold
FROM employees
INNER JOIN orders ON employees.EmployeeID = orders.EmployeeID
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='EmployeeID', y='TotalProductsSold', title='Total Products Sold by Each Employee')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.Quantity) AS TotalProductsSold
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='FirstName', y='TotalProductsSold', title='Total Products Sold by Each Employee', 
             labels={'FirstName': 'Employee Name', 'TotalProductsSold': 'Total Products Sold'})

show_to_user(fig)
```","The input code queries the correct data by joining the employees, orders, and order details tables and calculating the sum of products sold per employee. While it includes first and last names in the query, this additional detail does not affect the accuracy of the total product count per employee. The bar chart is correctly plotted by using the 'FirstName' field instead of 'EmployeeID' for the x-axis, ensuring adherence to the business analytics request. The core logic of calculating the 'TotalProductsSold' is consistent with the reference implementation.","```python
import plotly.express as px
import pandas as pd

# SQL query to get total products sold by each employee
sql_query = """"""
SELECT EmployeeID, SUM(Quantity) AS TotalProductsSold
FROM orders
GROUP BY EmployeeID
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total products sold by each employee
fig = px.bar(df, x='EmployeeID', y='TotalProductsSold', title='Total Products Sold by Employee',
             labels={'TotalProductsSold': 'Total Products Sold', 'EmployeeID': 'Employee ID'},
             text='TotalProductsSold')

# Display the plot
show_to_user(fig)
```","The input code aggregates data from the 'orders' table instead of joining with 'Order Details' to sum the 'Quantity'. It misses the necessary join, leading to incorrect product counts. The reference code correctly joins 'orders' with 'Order Details'.",Base
List customers who have not placed any orders in the last year.,"```python
import pandas as pd

# SQL query to list customers who have not placed any orders in the last year
sql_query = """"""
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderID IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
""""""

# Execute SQL query and retrieve data as a pandas dataframe
customer_data = execute_sql_query(sql_query)

# Remove duplicates to ensure unique customer results
unique_customer_data = customer_data.drop_duplicates()

# Display the result to the user
show_to_user(unique_customer_data)
```","```python
from datetime import datetime, timedelta

one_year_ago = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')

sql_query = f""""""
SELECT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, c.City, c.Region, c.PostalCode, c.Country, c.Phone, c.Fax
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID AND o.OrderDate >= '{one_year_ago}'
WHERE o.CustomerID IS NULL
""""""

customers_no_orders = execute_sql_query(sql_query)
show_to_user(customers_no_orders)
```","The input code uses a different logic by filtering orders in the join condition instead of in the WHERE clause. This leads to excluding customers with orders older than a year from the results, whereas the reference code correctly includes them. The reference code checks for customers with NULL order IDs or orders older than a year, ensuring all customers without recent orders are listed.","```python
import pandas as pd
from datetime import datetime
from utilities import execute_sql_query, display_to_user

# SQL query to find customers who haven't ordered in the last year
sql_query = """"""
SELECT CustomerID 
FROM customers 
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID 
    FROM orders 
    WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
);
""""""

# Execute the SQL query and get the result as a DataFrame
customers_without_recent_orders_df = execute_sql_query(sql_query)

# Display the results to the user
display_to_user(customers_without_recent_orders_df)
```","Both implementations achieve the same goal of identifying customers who haven't placed orders in the last year. The reference code uses a LEFT JOIN approach and checks for NULLs to identify customers with no recent orders, whereas the input code uses a 'NOT IN' subquery to exclude customers with orders in the past year. Both methods are valid and correct in returning the desired result.",Finetuned
Identify products with a unit price greater than the average unit price across all products.,"```python
import pandas as pd

# Execute the SQL query to fetch the product data
products_df = execute_sql_query(""SELECT ProductID, ProductName, UnitPrice FROM products"")

# Calculate the average unit price
average_price = products_df['UnitPrice'].mean()

# Filter products with a unit price greater than the average
filtered_products_df = products_df[products_df['UnitPrice'] > average_price][['ProductID', 'ProductName']]

# Display the result to user
show_to_user(filtered_products_df)
```","```python
# SQL query to calculate the average unit price and identify products with a unit price greater than that average
sql_query = """"""
WITH AvgUnitPrice AS (
    SELECT AVG(UnitPrice) AS AvgPrice
    FROM products
)
SELECT ProductID, ProductName, UnitPrice
FROM products
WHERE UnitPrice > (SELECT AvgPrice FROM AvgUnitPrice)
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)
```","The input Python code correctly addresses the business analytics request by utilizing a SQL query to calculate the average unit price and then filtering products with a unit price greater than that average. This aligns with the logic of the reference implementation, which calculates the average unit price using pandas and then filters the DataFrame accordingly. Both implementations achieve the same outcome, matching the business request.","```python
import pandas as pd

# Execute the SQL query to find products with a unit price greater than the average
sql_query = """"""
SELECT ProductID, ProductName
FROM products
WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products);
""""""

# Use the provided utility function to execute the SQL query and get the results as a DataFrame
df_products_above_avg_price = execute_sql_query(sql_query)

# Display the DataFrame with product information to the user
show_to_user(df_products_above_avg_price)
```","The provided code correctly identifies products with a unit price greater than the average by using a SQL query that computes the average unit price within the query itself. This approach is logically consistent with the reference implementation, which computes the average using DataFrame operations and then filters products based on this computed value. Both achieve the same business analytics objective.",both
What is the most frequently ordered product in 2023? Use a bar chart to compare the frequencies.,"```python
import plotly.express as px

# Define SQL query to get order counts for 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, COUNT([Order Details].OrderID) AS order_count 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE YEAR([Order Details].OrderDate) = 2023
GROUP BY products.ProductID, products.ProductName 
ORDER BY order_count DESC
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ProductName', y='order_count', title='Most Frequently Ordered Products in 2023')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS order_frequency 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY products.ProductID, products.ProductName 
ORDER BY order_frequency DESC
""""""

product_frequencies = execute_sql_query(sql_query)
fig = px.bar(product_frequencies, x='ProductName', y='order_frequency', title='Most Frequently Ordered Products in 2023')
show_to_user(fig)
```","The input Python code computes the `order_frequency` using the `SUM([Order Details].Quantity)` which measures the total quantity of products ordered. The reference code uses `COUNT([Order Details].OrderID)` to count the number of orders. These two logic approaches could lead to different results as one counts total quantities and the other counts occurrences of orders. Therefore, the input code does not match the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(od.OrderID) AS OrderCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY p.ProductID, p.ProductName
ORDER BY OrderCount DESC
LIMIT 10;
""""""

# Execute the SQL query and fetch results into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the order frequencies
fig = px.bar(df, x='ProductName', y='OrderCount', title='Top 10 Ordered Products in 2023')

# Display the visualization to the user
show_to_user(fig)
```","The input code limits the results to the top 10 products using 'LIMIT 10', which the reference code does not include. This results in a different output than what is requested by evaluating all products for the most frequently ordered one in 2023. Therefore, the input code does not fully adhere to the intended logic of analyzing all products.",None
What are the names and IDs of all products that are currently out of stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;""

# Execute the SQL query to retrieve the data
out_of_stock_products = execute_sql_query(sql_query)

# Display the result
show_to_user(out_of_stock_products)
```","```python
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE UnitsInStock = 0
""""""
out_of_stock_products = execute_sql_query(sql_query)
show_to_user(out_of_stock_products)
```","The input Python code and the reference implementation are functionally identical. Both execute an SQL query to select the ProductID and ProductName from the products table where UnitsInStock equals zero, achieving the goal of finding products that are out of stock. The method of defining and executing the query, as well as displaying the results, is consistent across both implementations.","```python
# SQL query to find all products currently out of stock
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;""

# Executing the SQL query using the provided utility function
out_of_stock_products_df = execute_sql_query(sql_query)

# Displaying the result to the user
show_to_user(out_of_stock_products_df)
```","The input Python code is correct. It uses the same SQL query to select products with zero units in stock, executes it using the 'execute_sql_query' function, and displays the result using the 'show_to_user' function, matching the logic of the reference implementation.",both
How many products were low on stock (below reorder level) in August 2023?,"```python
import pandas as pd

# Define the SQL Query
sql_query = """"""
SELECT products.ProductID 
FROM products 
WHERE products.UnitsInStock < products.ReorderLevel 
AND MONTH(products.RecordDate) = 8 
AND YEAR(products.RecordDate) = 2023
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Count the number of products low on stock
low_stock_count = df['ProductID'].nunique()  # Use nunique to count distinct ProductIDs

# Create a result dataframe to show the count
result_df = pd.DataFrame({""LowStockCount"": [low_stock_count]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS low_stock_products 
FROM products 
WHERE UnitsInStock < ReorderLevel 
AND Discontinued = 0 
AND EXISTS (
    SELECT 1 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-08-01' AND '2023-08-31'
);
""""""

low_stock_df = execute_sql_query(sql_query)
show_to_user(low_stock_df)
```","The input code filters products based on involvement in any order during August 2023, which differs from the reference, focusing solely on inventory levels and reorder points. It also includes a condition on 'Discontinued' column, which is not part of the reference query.","```python
execute_sql_query(""SELECT COUNT(*) FROM products WHERE UnitsInStock < ReorderLevel AND MONTH(LastRestockDate) = 8 AND YEAR(LastRestockDate) = 2023;"")
```","The input code uses LastRestockDate instead of RecordDate to filter the month and year, which changes the logic. The reference implementation filters based on RecordDate, ensuring the products are low on stock in August 2023. Additionally, the input code directly counts rows instead of counting distinct Product IDs, potentially counting repeated entries.",None
What is the total number of products available in the inventory?,"```python
import pandas as pd

# SQL query to get the total number of products
sql_query = ""SELECT COUNT(*) as total_products FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df['total_products'].iloc[0])
```","```python
sql_query = ""SELECT SUM(UnitsInStock) AS TotalProducts FROM products""
total_products_df = execute_sql_query(sql_query)
show_to_user(total_products_df)
```","The input code calculates the total of 'UnitsInStock', which represents the sum of unit counts for products in stock, not the total number of products. The reference code calculates the count of distinct product entries in the products table.","```python
# Assuming the utility function execute_sql_query is defined elsewhere and available for use

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS total_products FROM products;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code executes the SQL query correctly to count products, but it shows the entire DataFrame to the user instead of just the count. The reference code specifically extracts the count using df['total_products'].iloc[0] to show just the number, aligning with the business request for the total number of products.",None
Which shipping company has the highest on-time delivery rate? Display the rates using a bar chart for a better comparison.,"```python
import plotly.express as px

# SQL query to retrieve the shipping company's on-time delivery data
sql_query = """"""
SELECT ShipVia, 
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipVia 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query using the provided function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly for better comparison
fig = px.bar(df, x='ShipVia', y='OnTimeDeliveryRate', title='On-Time Delivery Rate by Shipping Company', labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-Time Delivery Rate'})

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, 
       COUNT(OrderID) AS TotalOrders, 
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries,
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(OrderID)) * 100 AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipVia
ORDER BY OnTimeDeliveryRate DESC
""""""

delivery_rates = execute_sql_query(sql_query)

fig = px.bar(delivery_rates, x='ShipVia', y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rates by Shipping Company',
             labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'})
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate for shipping companies by dividing the number of on-time deliveries by the total number of orders, just like the reference code. Both codes use a SQL query to extract the necessary data and create a bar chart to visualize the on-time delivery rates using Plotly Express. The input code also multiplies the rate by 100 to convert it into a percentage, which doesn't affect the correctness of the logic but provides a percentage format. The overall implementation matches the business request and follows the reference logic.","```python
import pandas as pd
import plotly.express as px

# Assume that the function exists
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the actual implementation
    pass

# Assume that the function exists
def show_to_user(data):
    # Placeholder for the actual implementation
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to calculate on-time delivery rate for each shipping company
sql_query = """"""
SELECT shippers.CompanyName, 
       (SUM(shipments.ShippedOnTime) * 100.0 / COUNT(shipments.ShipmentID)) AS OnTimeDeliveryRate 
FROM shipments 
JOIN shippers ON shipments.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the query and get the results in a DataFrame
delivery_rates_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(delivery_rates_df, 
             x='CompanyName', 
             y='OnTimeDeliveryRate',
             title='On-Time Delivery Rate by Shipping Company',
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'CompanyName': 'Shipping Company'},
             text='OnTimeDeliveryRate')

# Display the bar chart
show_to_user(fig)
```","The input code uses a different table structure. The reference uses 'orders' with 'ShippedDate' and 'RequiredDate', while the input uses 'shipments' and 'shippers' with 'ShippedOnTime'. The input assumes a different data layout and logic, which may not directly correspond to on-time delivery as calculated by comparing dates in the reference.",Base
What are the top 5 products in terms of total units sold? Visualize the top products using a bar chart for better insights.,"```python
import plotly.express as px

# SQL query to retrieve top 5 products by total units sold
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalUnitsSold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
'''

# Execute the SQL query
df_top_products = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df_top_products, x='ProductName', y='TotalUnitsSold',
             title='Top 5 Products by Total Units Sold',
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalUnitsSold', 
             title='Top 5 Products by Total Units Sold', 
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code is correct because it accomplishes the same task as the reference implementation. It queries the correct data to determine the top 5 products by total units sold, groups and orders them properly, and uses Plotly to create and show a bar chart. The SQL query structure, data handling, and visualization steps align with the reference code, ensuring equivalent functionality.","
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductName, SUM(Quantity) AS TotalUnitsSold 
FROM [Order Details] 
GROUP BY ProductName 
ORDER BY TotalUnitsSold DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the results in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, 
             x='ProductName', 
             y='TotalUnitsSold', 
             title='Top 5 Products by Total Units Sold', 
             labels={'TotalUnitsSold': 'Total Units Sold', 'ProductName': 'Product Name'},
             text='TotalUnitsSold')

# Display the chart to the user
show_to_user(fig)
```
","The input Python code does not join the 'products' table with '[Order Details]' like the reference implementation. This results in the ProductName being ambiguous if the ProductID isn't used. The reference code joins tables to correctly map ProductID to ProductName and sum the quantities accordingly. The input may assume ProductName is directly accessible in '[Order Details]', but this does not match the reference's approach of using both ProductID and ProductName.",Base
What is the monthly average shipping cost?,"```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve monthly average shipping cost
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Plot the result
fig = px.line(df, x='Month', y='AvgShippingCost', title='Monthly Average Shipping Cost')

# Display the result to the user
show_to_user(fig)
```","```python
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    AVG(Freight) AS Average_Shipping_Cost
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

monthly_average_shipping_cost = execute_sql_query(sql_query)
show_to_user(monthly_average_shipping_cost)
```","The evaluated code correctly calculates the monthly average shipping cost. It uses a SQL query to group by month, calculating the average freight in each month, similar to the reference implementation. The difference in SQL syntax (DATE_TRUNC vs. DATE_FORMAT) is due to expected differences in SQL dialects, but logically they achieve the same result. Both implementations convey the result to the user without altering the logic or correctness of the analysis.","```python
import pandas as pd

# SQL query to fetch the monthly average shipping cost
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS year, 
       EXTRACT(MONTH FROM OrderDate) AS month, 
       AVG(Freight) AS monthly_avg_shipping_cost 
FROM orders 
GROUP BY EXTRACT(YEAR FROM OrderDate), EXTRACT(MONTH FROM OrderDate)
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)
```","The input code correctly calculates the monthly average shipping cost by extracting the year and month from the OrderDate and using them to group the data. This matches the business request to compute monthly averages of the 'Freight'. Both the input code and reference code compute the same metrics, albeit with slightly different SQL syntax. The main difference is the format of the month (two integers vs. formatted string), which doesn't affect the correctness for computing averages.",both
Which employee has the highest sales in Q1 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID 
ORDER BY employee_sales DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT employees.EmployeeID, 
       employees.FirstName, 
       employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC 
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code provides the correct result by selecting the employee with the highest sales for Q1 2023. It calculates total sales similarly by joining the necessary tables, summing up sales with discounts applied, and grouping by EmployeeID as well as the employee’s name details. It orders the results by total sales in descending order and limits the result to the top employee. Providing additional employee details (FirstName, LastName) does not affect the correctness of the solution.","
```python
import pandas as pd

# Sample utility function: Execute the SQL query and return a DataFrame.
# This function should be implemented as per the project's requirements.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for placeholder purposes
    # Replace with actual database interaction code
    return pd.DataFrame({
        ""EmployeeID"": [101],
        ""TotalSales"": [50000]
    })

# Sample utility function: Display results to the user.
# This function should be implemented as per the project's requirements.
def show_to_user(data: pd.DataFrame):
    # Dummy implementation for placeholder purposes
    # Replace with actual display code
    print(data)

# SQL query to find the employee with the highest sales in Q1 2023
sql_query = """"""
SELECT e.EmployeeID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 1;
""""""

# Execute the query and get the results
results_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(results_df)
```
","The input code correctly answers the business analytics request by returning the employee with the highest sales in Q1 2023. It uses the same logic as the reference code: joining the necessary tables, calculating total sales, filtering by the specified date range, grouping by employee, ordering by total sales in descending order, and limiting the result to the top employee. The function placeholders for database interaction and result display do not affect the correctness of the SQL logic.",both
What is the total revenue generated from each product sold in 2022? Visualize the revenue distribution across products.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    products.ProductID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID
""""""

# Execute the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Ensure ProductID is treated as a string for visualization purposes
data['ProductID'] = data['ProductID'].astype(str)

# Visualize the revenue distribution across products
fig = px.bar(data, x='ProductID', y='total_revenue', title='Total Revenue by Product in 2022')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID, products.ProductName
""""""

revenue_df = execute_sql_query(sql_query)

fig = px.bar(revenue_df, x='ProductName', y='total_revenue', title='Total Revenue per Product in 2022')
show_to_user(fig)
```","The input Python code correctly computes the total revenue generated from each product sold in 2022, similar to the reference implementation. It uses the same SQL logic involving the calculation of revenue and filtering on the order date. In addition, it groups by both ProductID and ProductName, which doesn't affect correctness and enhances the visualization by displaying product names instead of IDs. The visualization using plotly also aligns with the request to visualize the revenue distribution across products.","```python
import pandas as pd
import plotly.express as px

# SQL Query to extract revenue data by product
sql_query = """"""
SELECT ProductID, 
       SUM('Order Details'.Quantity * 'Order Details'.UnitPrice) AS TotalRevenue 
FROM 'Order Details' 
JOIN orders ON 'Order Details'.OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY ProductID;
""""""

# Execute the SQL query and get the result as a DataFrame
revenue_df = execute_sql_query(sql_query)

# Generate a visualization for revenue distribution across products
fig = px.bar(revenue_df, x='ProductID', y='TotalRevenue', 
             title='Revenue Distribution Across Products in 2022', 
             labels={'TotalRevenue': 'Total Revenue', 'ProductID': 'Product ID'})

# Display the figure
show_to_user(fig)
```","The input Python code does not account for discounts on the order details as does the reference implementation. The reference implementation computes the total revenue by considering the discount with the expression UnitPrice * Quantity * (1 - Discount), whereas the input code simply multiplies UnitPrice by Quantity without factoring in any discounts.",Base
What is the most ordered product in terms of quantity?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
    SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantityOrdered 
    FROM [Order Details] 
    JOIN products 
    ON [Order Details].ProductID = products.ProductID 
    GROUP BY products.ProductName 
    ORDER BY TotalQuantityOrdered DESC 
    LIMIT 1;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 1;
""""""

most_ordered_product = execute_sql_query(sql_query)
show_to_user(most_ordered_product)
```","The input code correctly identifies the most ordered product in terms of quantity. It uses a SQL query to join the 'Order Details' and 'products' tables, groups the results by product, and orders them by the total quantity ordered in descending order, returning the top result. While the reference implementation groups only by 'ProductName', the input also groups by 'ProductID', which does not affect the outcome since 'ProductID' is the primary key. The logic is consistent with the reference implementation.","```python
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database connection and execution code.
    # Assuming it returns a DataFrame with the query result.
    pass

def show_to_user(data): 
    # Placeholder for actual display logic.
    pass

# SQL query to find the most ordered product in terms of quantity
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalQuantity DESC 
LIMIT 1
""""""

# Execute the SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result using the defined function
show_to_user(result_df)
```","The input code queries for the most ordered product by ProductID, instead of combining the ProductName using a JOIN with the Products table. The reference implementation associates the product with its name, and this results in displaying the ProductName, not just the ProductID.",Base
How many products have less than 10 units in stock?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID FROM products WHERE UnitsInStock < 10;""

# Execute the query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Count the number of products with less than 10 units in stock
product_count = len(df)

# Display the result to the user
show_to_user(product_count)
```","```python
sql_query = ""SELECT COUNT(*) AS ProductsWithLowStock FROM products WHERE UnitsInStock < 10""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly formulates the SQL query to count products with less than 10 units in stock. The query selects COUNT(*) which efficiently returns the number of such products, and the result is then displayed to the user. This logic aligns with the business analytics request and achieves the same end goal as the reference implementation, albeit in a more efficient manner.","```python
# Define the SQL query to fetch the count of products with less than 10 units in stock
sql_query = ""SELECT COUNT(*) FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query and store the result in a variable
low_stock_count = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(low_stock_count)
```","Both the input and reference code aim to count the number of products with less than 10 units in stock. The input code uses an SQL COUNT function to directly get the count from the database, which is efficient and correct. The reference code retrieves the products and then counts them using the length of a DataFrame. Both approaches use correct logic to achieve the same outcome, making the input code correct.",both
List the top 5 products with the highest total sales revenue. Visualize the sales revenue comparison among these products.,"```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID, products.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Visualize the sales revenue comparison among the top 5 products
fig = px.bar(top_products_df, 
             x='ProductName', 
             y='TotalSales', 
             title='Top 5 Products by Total Sales Revenue', 
             labels={'TotalSales': 'Total Sales Revenue', 'ProductName': 'Product Name'})

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalSales DESC
LIMIT 5
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, 
             x='ProductName', 
             y='TotalSales', 
             title='Top 5 Products with Highest Total Sales Revenue',
             labels={'ProductName': 'Product Name', 'TotalSales': 'Total Sales Revenue'},
             color='TotalSales')

show_to_user(fig)
```","The input Python code correctly implements the business analytics request by querying the top 5 products with the highest total sales revenue. It aligns with the logic of the reference code by executing a similar SQL query to retrieve the data and visualizing it using a bar chart. The differences, such as color-coding the bars by 'TotalSales', do not affect the correctness of the output.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch top 5 products by sales revenue
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY total_sales DESC 
LIMIT 5;
""""""

# Execute the query and store the result in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a Plotly bar chart to visualize sales revenue comparison
fig = px.bar(top_products_df, x='ProductName', y='total_sales', 
             title='Top 5 Products by Sales Revenue',
             labels={'total_sales': 'Total Sales Revenue ($)', 'ProductName': 'Product Name'})

# Display the plot to the user
show_to_user(fig)
```","The input code does not account for discounts when calculating total sales revenue, unlike the reference code. The reference implementation uses the formula 'UnitPrice * Quantity * (1 - Discount)' to incorporate discounts, whereas the input code uses 'UnitPrice * Quantity' without adjusting for any discounts, leading to potentially incorrect sales revenue values.",Base
Which products have the highest and lowest inventory turnover ratio? Visualize the turnover ratios for comparison.,"```python
import plotly.express as px

# Define the SQL query to get inventory turnover ratios
sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    p.ProductName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort to find the highest and lowest inventory turnover ratios
sorted_df = df.sort_values(by='InventoryTurnoverRatio', ascending=False)

# Filter for products with the highest and lowest inventory turnover ratios
highest_df = sorted_df.head(1)
lowest_df = sorted_df.tail(1)
comparison_df = highest_df.append(lowest_df)

# Visualize the turnover ratios for comparison
fig = px.bar(comparison_df, x='ProductName', y='InventoryTurnoverRatio', title='Highest and Lowest Inventory Turnover Ratios for Products')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS TotalSales, 
    AVG(p.UnitsInStock) AS AverageInventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

data = execute_sql_query(sql_query)

highest_turnover = data.loc[data['InventoryTurnoverRatio'].idxmax()]
lowest_turnover = data.loc[data['InventoryTurnoverRatio'].idxmin()]

turnover_comparison = data[['ProductName', 'InventoryTurnoverRatio']]

fig = px.bar(turnover_comparison, x='ProductName', y='InventoryTurnoverRatio', 
             title='Inventory Turnover Ratios of Products', 
             labels={'InventoryTurnoverRatio': 'Turnover Ratio', 'ProductName': 'Product'},
             range_y=[0, turnover_comparison['InventoryTurnoverRatio'].max() * 1.2])

show_to_user(fig)
```","The input code does not specifically highlight or visualize the highest and lowest inventory turnover ratios as requested. Instead, it visualizes all products' turnover ratios. The reference code identifies and visualizes only the top and bottom product based on inventory turnover, whereas the input code generates a plot for all products, conflicting with the specific business request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query for the turnover ratios
sql_query = """"""
SELECT ProductID, SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnover
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY ProductID
ORDER BY InventoryTurnover DESC;
""""""

# Execute the SQL query
turnover_df = execute_sql_query(sql_query)

# Display the DataFrame
show_to_user(turnover_df)

# Find the highest and lowest turnover ratios
highest_turnover = turnover_df.iloc[0]
lowest_turnover = turnover_df.iloc[-1]

# Create a visualization for turnover ratios
fig = px.bar(turnover_df, x='ProductID', y='InventoryTurnover', 
             title='Inventory Turnover Ratios by Product',
             labels={'InventoryTurnover': 'Turnover Ratio'},
             height=400)

# Show the visualization to the user
show_to_user(fig)

# Display the products with highest and lowest turnover ratios
summary_df = pd.DataFrame({
    'Description': ['Highest Turnover', 'Lowest Turnover'],
    'ProductID': [highest_turnover['ProductID'], lowest_turnover['ProductID']],
    'TurnoverRatio': [highest_turnover['InventoryTurnover'], lowest_turnover['InventoryTurnover']]
})

show_to_user(summary_df)
```","The input code does not fully answer the business analytics request as specified. While it calculates and displays the turnover ratios for all products and visualizes them, it does not focus on highlighting only the products with the highest and lowest turnover ratios in the visualization. The reference code provides a comparison between these two extremes, but the input code does not. The input code does summarize the highest and lowest ratios in a separate output, but the visual does not specifically compare these two products, which is a key aspect of the request.",None
Identify employees with the highest and lowest order counts. Visualize the order counts for each employee.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1 
UNION 
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount ASC 
LIMIT 1;
""""""

# Execute the query
employees_df = execute_sql_query(sql_query)

# Adjust FirstName for proper visualization if multiple employees have the same name
employees_df['FullName'] = employees_df['FirstName'] + ' ' + employees_df['LastName']

# Generate a bar plot for order counts
fig = px.bar(employees_df, x='FullName', y='OrderCount', color='OrderCount', 
             title='Order Counts for Employees with Highest and Lowest Orders')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get order counts for each employee
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
employee_order_counts = execute_sql_query(sql_query)

# Identify employees with the highest and lowest order counts
highest_order_count = employee_order_counts.nlargest(1, ""OrderCount"")
lowest_order_count = employee_order_counts.nsmallest(1, ""OrderCount"")

# Combine results for display
summary = pd.concat([highest_order_count, lowest_order_count])

# Visualize the order counts for each employee
fig = px.bar(employee_order_counts, 
             x='EmployeeName', 
             y='OrderCount', 
             title='Order Counts for Each Employee',
             labels={'EmployeeName': 'Employee', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The input code is not correct because it does not select and visualize only the employees with the highest and lowest order counts, as requested. Instead, it visualizes the order counts for all employees, which differs from the request and the reference implementation. The reference code specifically selects employees with the highest and lowest order counts using SQL with 'ORDER BY' and 'LIMIT', and visualizes only those selected records.","
```python
import plotly.express as px
import pandas as pd

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function - implement the actual database connection and query execution
    pass

# Function to display data or visualizations
def show_to_user(data):
    # Implement display logic for DataFrame or Plotly figure
    pass

# SQL query to fetch order counts per employee
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC;
""""""

# Execute the query and get the data as a DataFrame
df = execute_sql_query(sql_query)

# Identify employees with the highest and lowest order counts
highest_order_count = df.iloc[0]
lowest_order_count = df.iloc[-1]

# Create a bar chart for order counts per employee
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Order Counts per Employee')

# Show the bar chart
show_to_user(fig)

# Display the employees with highest and lowest order counts
print(""Employee with highest order count:"")
print(highest_order_count)
print(""\nEmployee with lowest order count:"")
print(lowest_order_count)
```
","The input code does not adhere to the logic of the reference implementation. The reference implementation uses two queries with `LIMIT 1` to fetch employees with the highest and lowest order counts, handling ties by returning one employee at each extreme. The input code assumes sorted order after executing a single query and selects the first and last entries as highest and lowest orders, which could be incorrect if there are ties. Moreover, the input code lacks the visualization of only the highest and lowest order counts separately, as outlined in the reference implementation.",None
Which employee handled the most orders?,"```python
import pandas as pd

# SQL query to get the EmployeeID with the most orders
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Since we need only EmployeeID, extract it from the dataframe
most_orders_employee = result_df['EmployeeID'].iloc[0]

# Display the EmployeeID to the user
show_to_user(most_orders_employee)
```","```python
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code does not extract the 'EmployeeID' directly from the result DataFrame before displaying it with 'show_to_user'. It attempts to display the entire result, whereas the reference code specifically extracts the 'EmployeeID' using 'iloc[0]'.","```python
import pandas as pd

# Predefined function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function for demonstration purposes
    # Replace with actual implementation
    pass

# Predefined function to display data or analysis results
def show_to_user(data):
    # Mock function for demonstration purposes
    # Replace with actual implementation
    pass

# SQL query to find the employee who handled the most orders
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY NumberOfOrders DESC
LIMIT 1
""""""

# Execute the SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code correctly implements the business analytics request by querying for the EmployeeID with the most orders. It uses a SQL join to ensure the link between employees and orders, groups by EmployeeID, orders the result in descending order of order count, and limits the result to the top entry. This logic aligns with the reference implementation, with the slight difference being presentation. The reference extracts and presents only the EmployeeID, while the input presents the entire row. The logic to identify the employee with the most orders is intact in both implementations.",Finetuned
Calculate the average lead time for each supplier in delivered products. Visualize the lead times to compare suppliers.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT suppliers.SupplierID, CompanyName, 
AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, CompanyName;
""""""

# Execute SQL query and get the data
data = execute_sql_query(sql_query)

# Create a bar plot of average lead time per supplier
fig = px.bar(data, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
""""""

lead_time_df = execute_sql_query(sql_query)

fig = px.bar(lead_time_df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier', labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. Both implementations perform the same SQL query to calculate the average lead time for each supplier by joining the necessary tables and grouping by SupplierID and CompanyName. The visualization is also created using Plotly Express to display a bar plot with similar elements. The minor differences, such as the use of aliases for table names and the addition of labels in the visualization, do not affect the correctness of the logic or output.","
    ","No input code was provided to evaluate against the reference implementation. The task requires comparing a given implementation with the reference to determine correctness, but without any input code to analyze, it's not possible to make such a determination.",Base
What is the average discount given in orders for the year 2023?,"```python
sql_query = """"""
SELECT AVG([Order Details].Discount) AS avg_discount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute SQL query to get the average discount
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT AVG([Order Details].Discount) AS average_discount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The provided code accurately reflects the logic of the reference implementation. It constructs a SQL query that selects the average discount from orders in 2023 by joining the 'Order Details' and 'orders' tables. It uses 'BETWEEN' to specify the date range, similar to the reference code. The query is executed, and the result is displayed to the user, just as in the reference.","```python
import pandas as pd

# Define a function to execute the SQL query and get the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating the function to return a DataFrame for demonstration
    # Replace with actual database connection and query execution logic
    data = {'Average Discount': [0.15]}  # Sample data
    return pd.DataFrame(data)

# Define a function to display the DataFrame to the user
def show_to_user(df: pd.DataFrame) -> None:
    print(df)

# SQL query to get the average discount for the year 2023
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
WHERE OrderID IN (SELECT OrderID FROM orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31')
""""""

# Execute the SQL query to get the result
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","Both the reference code and the input code calculate the average discount for orders made in the year 2023. The input code uses a subquery in the WHERE clause to filter orders from 'orders' with the correct date range, matching the logic of the reference implementation. Thus, it adheres to the required business logic and is considered correct.",both
What is the average order fulfillment time by month? Visualize the monthly fulfillment times.,"```python
import plotly.express as px

# SQL query to fetch required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgOrderFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert 'Month' to string to ensure proper sorting by month
df['Month'] = df['Month'].astype(str)

# Create line plot using Plotly
fig = px.line(df, x='Month', y='AvgOrderFulfillmentTime', title='Average Order Fulfillment Time by Month')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    month
ORDER BY 
    month;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time by Month', 
              labels={'avg_fulfillment_time': 'Average Fulfillment Time (Days)', 'month': 'Month'})
show_to_user(fig)
```","The input code correctly calculates the average order fulfillment time by month using SQL, similar to the reference code. Both implementations group by month and average the difference between 'ShippedDate' and 'OrderDate'. The input code uses 'DATE_TRUNC' for monthly grouping and includes a 'WHERE' clause to exclude NULL 'ShippedDate', which is valid and necessary for accurate calculation. The visualization part in both codes uses Plotly to create a line plot of the average time by month, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT TO_CHAR(orders.OrderDate, 'YYYY-MM') AS month,
       AVG(orders.OrderFulfillmentTime) AS avg_fulfillment_time
FROM orders
GROUP BY TO_CHAR(orders.OrderDate, 'YYYY-MM');
""""""

# Execute the SQL query using a placeholder for the function
monthly_fulfillment_df = execute_sql_query(sql_query)

# Plot the results using Plotly
fig = px.line(
    monthly_fulfillment_df, 
    x='month', 
    y='avg_fulfillment_time',
    title='Average Order Fulfillment Time by Month',
    labels={'avg_fulfillment_time': 'Average Fulfillment Time (days)'}
)

# Display the plot
show_to_user(fig)
```","The input code calculates 'AVG(orders.OrderFulfillmentTime)' while the reference code calculates 'AVG(DATEDIFF(ShippedDate, OrderDate))'. The input assumes that 'OrderFulfillmentTime' is a pre-calculated field, which may not align with the reference logic. The date formatting function also differs ('TO_CHAR' vs. 'DATE_FORMAT'), but that is less critical. The SQL logic differs in how the average time is computed.",Base
What is the total revenue generated by each employee? Visualize employee contribution to revenue.,"```python
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY EmployeeID;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using plotly to visualize employee contribution to revenue
fig = px.bar(df, x='EmployeeID', y='TotalRevenue', title='Employee Contribution to Revenue')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.EmployeeID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.EmployeeID
""""""

employee_revenue = execute_sql_query(sql_query)

fig = px.bar(employee_revenue, x='EmployeeID', y='TotalRevenue',
              title='Total Revenue Generated by Each Employee',
              labels={'EmployeeID': 'Employee ID', 'TotalRevenue': 'Total Revenue'},
              text='TotalRevenue')

show_to_user(fig)
```","The provided Python code accomplishes the same task as the reference implementation. It calculates the total revenue for each employee using a SQL query, groups by EmployeeID, and then creates a bar chart using plotly to visualize the data. The key steps, such as executing the query and visualizing with a bar chart, are consistent with the reference implementation. Minor differences, such as the addition of custom labels and text within the bar chart, do not affect the core logic or output.","
import pandas as pd
import plotly.express as px

# Function to display the data analysis result
def show_to_user(data):
    print(data)
    if isinstance(data, pd.DataFrame):
        fig = px.bar(data, x='EmployeeID', y='TotalRevenue', title='Employee Contribution to Revenue')
        fig.show()

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the logic to connect to the database,
    # execute the query, and return a DataFrame
    # For demonstration, we'll use a placeholder DataFrame
    data = {'EmployeeID': [1, 2, 3], 'TotalRevenue': [1000, 2000, 1500]}
    return pd.DataFrame(data)

# Define SQL query
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Execute the query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Display the DataFrame and visualization
show_to_user(df)
","The input code accurately executes a SQL query that calculates the total revenue by each employee, similar to the reference code. It also visualizes the result using a bar chart. The logic in the SQL query and the approach to visualization are consistent with the reference implementation, fulfilling the business analytics request.",both
Find the total freight cost incurred in the year 2023.,"```python
import pandas as pd

# Execute the SQL query to get the data
result_df = execute_sql_query(""SELECT SUM(Freight) AS TotalFreightCost2023 FROM orders WHERE YEAR(OrderDate) = 2023;"")

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE YEAR(OrderDate) = 2023
""""""

total_freight_cost = execute_sql_query(sql_query)
show_to_user(total_freight_cost)
```","The input code correctly calculates the total freight cost for orders made in the year 2023 by executing a similar SQL query as in the reference implementation. The column alias is slightly different ('TotalFreightCost' instead of 'TotalFreightCost2023'), but this does not affect the correctness of the logic in terms of query execution. The final result is shown to the user using the 'show_to_user' function, just like in the reference.","```python
# Import the necessary libraries
import pandas as pd

# SQL query to select the total freight cost incurred in the year 2023
sql_query = """"""
SELECT SUM(OrderFreight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2023;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code correctly implements the business requirement of finding the total freight cost for the year 2023. It performs an SQL query to sum up the 'OrderFreight' where 'OrderDate' is in 2023, similar to the reference implementation. The difference in column names (OrderFreight vs Freight) doesn't affect the logic, assuming they refer to the same data. The process of executing the query and displaying the result is consistent with the reference code.",both
Identify which month has the highest number of orders historically. Visualize the order count by month.,"```python
import plotly.express as px

# SQL query to get order counts by month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Visualize order count by month
fig = px.bar(order_data, x='Month', y='OrderCount', title='Order Count by Month')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

orders_by_month = execute_sql_query(sql_query)

max_orders_month = orders_by_month.loc[orders_by_month['OrderCount'].idxmax()]

fig = px.bar(orders_by_month, x='Month', y='OrderCount', title='Order Count by Month')
show_to_user(fig)
```","The input Python code correctly identifies the month with the highest number of orders and visualizes the order count by month using logic similar to the reference code. Both versions group orders by month and count them. While the input code includes ordering the months and explicitly extracting the month with the highest order count, it still adheres to the core requirements of the task. Additionally, both the reference and input codes utilize Plotly Express to generate a bar chart for visualization. Therefore, the input code is correct.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the order counts by month
sql_query = """"""
SELECT 
    TO_CHAR(orders.OrderDate, 'YYYY-MM') AS month, COUNT(orders.OrderID) AS order_count 
FROM 
    orders 
GROUP BY 
    month 
ORDER BY 
    month;
""""""

# Execute the SQL query and fetch the data into a DataFrame
df = execute_sql_query(sql_query)

# Find the month with the highest number of orders
max_month = df.loc[df['order_count'].idxmax()]

# Display the month with the highest orders
show_to_user(pd.DataFrame([max_month]))

# Visualize the order count by month
fig = px.line(df, x='month', y='order_count', title='Monthly Order Counts')
show_to_user(fig)
```","Both implementations perform the task of querying order counts by month from a database, identifying the month with the highest number of orders, and visualizing the results. The reference code uses DATE_FORMAT while the input code uses TO_CHAR, which is analogous for different SQL dialects. Both codes execute the query and visualize the data, with the reference using a bar chart and the input code using a line chart. The core logic aligns with the business request.",both
Calculate the average number of products per order.,"```python
import pandas as pd

# Define the SQL query to calculate the average number of products per order
sql_query = ""SELECT AVG(od.Quantity) AS AverageProductsPerOrder FROM [Order Details] od;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Correctly extract the average products per order from the result dataframe
average_products_per_order = result_df['AverageProductsPerOrder'][0]

# Display the result
show_to_user(pd.DataFrame({'Average Products Per Order': [average_products_per_order]}))
```","```python
sql_query = """"""
SELECT AVG(product_count) AS average_products_per_order
FROM (
    SELECT o.OrderID, COUNT(od.ProductID) AS product_count
    FROM orders o
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    GROUP BY o.OrderID
) AS individual_order_counts
""""""

average_products_per_order = execute_sql_query(sql_query)
show_to_user(average_products_per_order)
```","The input code calculates the average number of products per order by first counting products per order and then averaging these counts, matching the intent and result of the reference code logic.","```python
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function implementation
    # This should connect to the database and execute the SQL query
    pass

def show_to_user(data) -> None:
    # Placeholder function implementation
    # This should display the data to the user
    pd.set_option('display.float_format', '{:.2f}'.format)
    print(data)

# SQL Query to calculate the average number of products per order
sql_query = """"""
SELECT AVG(NumOfProducts) AS AvgProductsPerOrder 
FROM (
    SELECT COUNT(*) AS NumOfProducts 
    FROM [Order Details] 
    GROUP BY OrderID
) AS OrderProductCounts;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","The input code calculates the average number of products per order correctly. It groups the order details by OrderID to count the number of products in each order, then averages these counts. This approach aligns logically with the given business requirement and the reference implementation which averages the 'Quantity' directly, assuming 'Quantity' represents products per order.",both
Which product has the highest total sales in 2022?,"```python
import pandas as pd

# SQL Query to retrieve the product with the highest total sales in 2022
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID 
ORDER BY total_sales DESC 
LIMIT 1
""""""

# Execute the SQL query and retrieve the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","Both implementations correctly calculate the product with the highest total sales in 2022. The key difference is that the input code includes the ProductName in the SELECT and GROUP BY clauses, which does not affect the logic needed to meet the business analytics request. Both codes use the same logic to filter for 2022 orders and calculate total sales, then sort and limit the result to the top entry.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT product_id, SUM(quantity * unit_price) AS total_sales 
FROM [Order Details] 
WHERE order_id IN (
  SELECT order_id 
  FROM orders 
  WHERE YEAR(order_date) = 2022
)
GROUP BY product_id 
ORDER BY total_sales DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Display the product with the highest total sales
show_to_user(result_df)
```","The input code does not consider the discount when calculating total sales, unlike the reference code. The reference code uses the formula (UnitPrice * Quantity * (1 - Discount)) to calculate total sales, while the input code uses only (quantity * unit_price), missing the discount factor.",Base
How many orders were placed in each quarter of 2022? Visualize the quarterly order distribution.,"```python
import plotly.express as px

# SQL query to get the number of orders per quarter for 2022
sql_query = """"""
SELECT QUARTER(orders.OrderDate) AS order_quarter, COUNT(orders.OrderID) AS total_orders
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY order_quarter
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the dataframe by order_quarter to ensure the correct order in visualization
df = df.sort_values(by='order_quarter')

# Create a bar chart to visualize the quarterly order distribution
fig = px.bar(df, x='order_quarter', y='total_orders', title='Quarterly Orders Distribution in 2022',
             labels={'order_quarter': 'Quarter', 'total_orders': 'Total Orders'})

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATEPART(QUARTER, OrderDate) AS Quarter,
    COUNT(OrderID) AS NumberOfOrders 
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY 
    DATEPART(QUARTER, OrderDate)
ORDER BY 
    Quarter;
""""""

quarterly_orders = execute_sql_query(sql_query)

fig = px.bar(quarterly_orders, x='Quarter', y='NumberOfOrders', 
             labels={'NumberOfOrders': 'Number of Orders', 'Quarter': 'Quarter'},
             title='Quarterly Orders in 2022')
show_to_user(fig)
```","The input code correctly calculates the number of orders per quarter for 2022 using a SQL query that selects and counts orders by quarter and filters for the correct date range. It orders the results by quarter, similar to the reference code's sorting step. Both codes use Plotly Express to create a bar chart for visualization, and the resultant structure and labels are equivalent. Therefore, the logic adheres to the reference code, fulfilling the business request.","```python
import pandas as pd
import plotly.express as px

# Write SQL query to get the quarterly order counts for 2022
sql_query = """"""
SELECT DATEPART(QUARTER, OrderDate) AS Quarter, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = 2022 
GROUP BY DATEPART(QUARTER, OrderDate);
""""""

# Execute the SQL query and store the result in a DataFrame
quarterly_orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quarterly order distribution
fig = px.bar(
    quarterly_orders_df, 
    x='Quarter', 
    y='OrderCount', 
    title='Quarterly Order Distribution for 2022',
    labels={'OrderCount': 'Number of Orders', 'Quarter': 'Quarter'},
    text='OrderCount'
)

# Display the plot using the provided utility function
show_to_user(fig)
```","The input code is functionally equivalent to the reference implementation. Both use an SQL query to retrieve the number of orders per quarter in 2022 and visualize this data using a bar chart. Differences such as the SQL syntax for selecting the quarter and the addition of displaying text on bars (`text='OrderCount'`) in the input code do not affect the fundamental logic or correctness. Therefore, the input code adheres to the business analytics request and reference logic.",both
How many unique customers placed orders in the last quarter?,"```python
import pandas as pd

# Define the SQL query to get unique customer IDs
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders
WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE());
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Count the unique customers
unique_customers_count = len(result_df['CustomerID'].unique())

# Display the result to the user
show_to_user(pd.DataFrame({'unique_customers': [unique_customers_count]}))
```","```python
import pandas as pd

# Define the start and end dates for the last quarter
end_date = pd.to_datetime('today').normalize() - pd.offsets.QuarterEnd()
start_date = end_date - pd.DateOffset(months=3)

# SQL query to get the number of unique customers who placed orders in the last quarter
sql_query = f""""""
SELECT COUNT(DISTINCT CustomerID) AS unique_customers
FROM orders
WHERE OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","Both the reference and input codes retrieve unique customer IDs from a database for orders placed in the last quarter. The reference code calculates the unique customer count in Python after retrieving all distinct CustomerIDs. In contrast, the input code performs this count using SQL with 'COUNT(DISTINCT CustomerID)'. The input code defines the last quarter's date range correctly using pandas, and the SQL logic matches the task of counting distinct customers. Both codes achieve the same outcome, consistent with the business analytics request.","```python
# Import necessary libraries
import pandas as pd

# Define the utility function execute_sql_query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This placeholder function will execute the SQL query
    # and return the result as a pandas DataFrame.
    # Assume implementation is provided.
    pass

# Define the utility function show_to_user
def show_to_user(data):
    # This placeholder function will display the data passed to it
    # It can handle both pandas DataFrame and integer/float objects.
    # Assume implementation is provided.
    pass

# SQL query to fetch unique customer count in the last quarter
sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS unique_customers 
FROM orders 
WHERE OrderDate >= DATEADD(quarter, -1, CURRENT_DATE);
""""""

# Execute the SQL query and retrieve the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Extract the unique customer count from the DataFrame
unique_customers_count = result_df['unique_customers'].iloc[0]

# Display the unique customer count to the user
show_to_user(unique_customers_count)
```","The input code uses 'DATEADD(quarter, -1, CURRENT_DATE)' instead of 'DATEADD(MONTH, -3, GETDATE())'. This could lead to different date ranges, notably because 'quarter' and 'MONTH' have different interpretations of three months prior. Additionally, the input code calculates the count directly in SQL, while the reference filters and counts in Python. These differences may lead to discrepancies if the DBMS treats quarters differently from three months.",Base
What are the top three products that generate the most sales revenue? Visualize their sales revenue for comparison.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the query to get data
data = execute_sql_query(sql_query)

# Ensure the dataframe has columns in the correct case
data.columns = ['ProductID', 'TotalRevenue']

# Create a bar chart for visualization
fig = px.bar(data, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalRevenue DESC
LIMIT 3;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue', labels={'TotalRevenue': 'Sales Revenue', 'ProductID': 'Product ID'})
show_to_user(fig)
```","Both implementations aim to identify the top three products by sales revenue and visualize the results in a bar chart. The input code includes a join with an 'orders' table, which doesn't change the logic as the summation, grouping, and ordering logic adheres to the reference. The visualization is also similar, displaying a bar chart with appropriate labels. Thus, the input code is correct in terms of the specified request and logic.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch top three products by sales revenue
sql_query = """"""
SELECT ProductID, 
       SUM(od.Quantity * od.UnitPrice) AS ProductRevenue 
FROM [Order Details] od 
GROUP BY ProductID 
ORDER BY ProductRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query and fetch the data into a pandas DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a Plotly bar chart for visual comparison of sales revenue
fig = px.bar(top_products_df, 
             x='ProductID', 
             y='ProductRevenue', 
             title='Top 3 Products by Sales Revenue', 
             labels={'ProductRevenue': 'Sales Revenue', 'ProductID': 'Product ID'})

# Display the visualization to the user
show_to_user(fig)
```","The provided code does not account for discounts in the calculation of 'ProductRevenue', whereas the reference code includes a discount in the revenue calculation using (1 - od.Discount). Therefore, the logic does not match the reference implementation.",Base
What are the names of products that have been discontinued?,"```python
import pandas as pd

# SQL Query to get discontinued products
sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query to retrieve the dataframe
discontinued_products_df = execute_sql_query(sql_query)

# Display the names of products that have been discontinued
show_to_user(discontinued_products_df['ProductName'])
```","```python
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE Discontinued = 1;
""""""
discontinued_products = execute_sql_query(sql_query)
show_to_user(discontinued_products)
```","In the input code, the output of the SQL query is not correctly processed before being passed to 'show_to_user'. The 'show_to_user' function in the reference code specifically uses 'discontinued_products_df['ProductName']' to select the 'ProductName' column. The input code should also select only this column when showing to the user.","```python
# Execute the SQL query to fetch discontinued products
discontinued_products_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""
discontinued_products_df = execute_sql_query(discontinued_products_query)

# Display the results to the user
show_to_user(discontinued_products_df)
```",The input code displays the entire DataFrame whereas the reference implementation specifically shows only the 'ProductName' column. The input code should be modified to display 'discontinued_products_df['ProductName']' to match the logic of the reference implementation.,None
Which supplier has supplied the most quantity of products?,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT SupplierID, SUM(UnitsOnOrder) AS TotalQuantitySupplied 
FROM products 
GROUP BY SupplierID 
ORDER BY TotalQuantitySupplied DESC 
LIMIT 1;
""""""

# Execute SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Correctly display just the SupplierID
max_supplier_id = result_df['SupplierID'].iloc[0]

# Display the SupplierID to the user
show_to_user(max_supplier_id)
```","```python
sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code uses a different table and field compared to the reference implementation. The input joins with the 'Order Details' table and sums the 'Quantity' field, while the reference implementation sums 'UnitsOnOrder' from the 'products' table. These may lead to different results depending on the database schema and data stored.","```python
import pandas as pd

# Assuming execute_sql_query and display_dataframe functions are defined elsewhere
# execute_sql_query(sql:str) -> pd.DataFrame
# display_dataframe(df: pd.DataFrame)

# SQL query to find the supplier with the maximum sum of quantities supplied
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, SUM([Order Details].Quantity) AS TotalQuantity
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY TotalQuantity DESC
LIMIT 1;
""""""

# Execute the SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the resulting DataFrame
display_dataframe(result_df)
```","The input code includes the 'CompanyName' in the SQL query and displays the entire DataFrame rather than just the 'SupplierID'. This deviates from the reference implementation, which only identifies the SupplierID of the supplier who supplied the most quantity.",None
Determine the average discount given by each employee.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, 
       e.FirstName, 
       e.LastName, 
       AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input Python code correctly calculates the average discount given by each employee, similar to the reference implementation. It includes additional fields (FirstName, LastName) in the SELECT and GROUP BY clauses, but these do not affect the correctness of the average calculation of discounts per employee.","```python
# Define the SQL query to compute the average discount per employee
sql_query = """"""
SELECT e.EmployeeID, AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the query using the utility function to fetch data
discount_data = execute_sql_query(sql_query)

# Define a function to show the results to the user
def show_to_user(data):
    # Display the data to the user (Implementation depends on the environment)
    print(data)

# Present the results using the utility function
show_to_user(discount_data)
```","The evaluated code is logically equivalent to the reference code. Both SQL queries are identical in structure and intent, computing the average discount per employee by joining the same tables and grouping by EmployeeID. The difference in naming 'AvgDiscount' vs 'AverageDiscount' does not affect correctness. The execution and result display functions, 'execute_sql_query' and 'show_to_user', are used consistently in both implementations.",both
Which month had the highest number of orders placed? Provide a visualization to compare monthly order volumes.,"```python
import plotly.express as px

# Query to get monthly order counts
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
ORDER BY Month
""""""

# Execute the SQL query
monthly_order_data = execute_sql_query(sql_query)

# Find the month with the highest number of orders
highest_order_month = monthly_order_data.loc[monthly_order_data['OrderCount'].idxmax()]

# Visualize monthly order volumes
fig = px.bar(monthly_order_data, x='Month', y='OrderCount', 
             title=f""Monthly Order Volumes (Highest: {highest_order_month['Month']})"", 
             labels={'OrderCount': 'Number of Orders'})

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

monthly_orders = execute_sql_query(sql_query)

highest_month = monthly_orders.loc[monthly_orders['OrderCount'].idxmax()]

fig = px.bar(monthly_orders, x='Month', y='OrderCount', title='Monthly Order Volumes', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})
show_to_user(fig)
```","The provided code correctly queries and groups the data by month, then counts the orders. It identifies the month with the highest number of orders using the `idxmax()` function. The visualization is generated with Plotly Express, similar to the reference implementation. Both implementations effectively solve the business analytics request and present the results in the same logical manner, even though the titles in the visualizations differ slightly.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get monthly order counts
query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
    COUNT(o.OrderID) AS OrderCount 
FROM 
    orders o 
WHERE 
   YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY 
    DATE_FORMAT(o.OrderDate, '%Y-%m') 
ORDER BY 
    OrderCount DESC
""""""
monthly_order_data = execute_sql_query(query)

# Create a visualization to compare monthly order volumes
fig = px.bar(
    monthly_order_data,
    x='Month',
    y='OrderCount',
    title='Monthly Order Volumes',
    labels={'OrderCount': 'Number of Orders'}
)

# Display the plot
show_to_user(fig)
```","The input code evaluates only the current year by filtering orders with `YEAR(o.OrderDate) = YEAR(CURRENT_DATE)`, which is not present in the reference implementation. Additionally, it orders the data by `OrderCount DESC`, whereas the reference orders by `Month`. The task requires determining the month with the highest order count across all data, not restricted to the current year. Thus, the logic is not the same.",Base
Retrieve the contact information for all suppliers located in a specific region.,"```python
import pandas as pd

# Define the specific region
specified_region = 'specified_region'

# Create the SQL query
sql_query = f""""""
SELECT SupplierID, CompanyName, ContactName, Phone, City, Region
FROM suppliers
WHERE Region = '{specified_region}';
""""""

# Execute the SQL query and retrieve the data
suppliers_df = execute_sql_query(sql_query)

# Display the retrieved data
show_to_user(suppliers_df)
```","```python
region = 'specific_region'  # Replace with the desired region
sql_query = f""""""
SELECT SupplierID, CompanyName, ContactName, ContactTitle, Address, City, Region, PostalCode, Country, Phone, Fax, HomePage
FROM suppliers
WHERE Region = '{region}'
""""""
supplier_contact_info = execute_sql_query(sql_query)
show_to_user(supplier_contact_info)
```","The input code retrieves additional fields (ContactTitle, Address, PostalCode, Country, Fax, HomePage) beyond what the reference implementation specifies. The reference code focuses on specific fields: SupplierID, CompanyName, ContactName, Phone, City, and Region, which are relevant to the business request. Therefore, the logic does not align with the reference implementation's specified output.","```python
# Define the supplier region
supplier_region = ""specified_region""  # Replace with the actual region as required

# Execute the SQL query to get supplier contact information for the specified region
sql_query = f""""""
SELECT suppliers.ContactName, suppliers.ContactTitle, suppliers.Address, suppliers.City, suppliers.Region
FROM suppliers
WHERE suppliers.Region = '{supplier_region}'
""""""

# Use the provided function to fetch the data
supplier_data = execute_sql_query(sql_query)

# Display the supplier data using show_to_user function
show_to_user(supplier_data)
```","The input code includes different columns in the SELECT statement compared to the reference implementation. It retrieves ContactName, ContactTitle, Address, City, and Region, but the reference code fetches SupplierID, CompanyName, ContactName, Phone, City, and Region. Thus, the input code does not fully adhere to the same logic as the reference implementation.",None
Calculate the discount amount for each order in January 2023.,"```python
import pandas as pd

# SQL query to fetch the required data
sql_query = """"""
SELECT o.OrderID, SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY o.OrderID;
""""""

# Execute the SQL query to get the results in a dataframe
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    o.OrderID, 
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
GROUP BY 
    o.OrderID
""""""

discount_data = execute_sql_query(sql_query)
show_to_user(discount_data)
```","The input code correctly calculates the discount amount for each order in January 2023. It uses a date range from '2023-01-01' to '2023-02-01', which is equivalent to '2023-01-31' in the reference code for filtering January dates. The logic of multiplying UnitPrice, Quantity, and Discount in the SUM function follows the reference implementation. Therefore, the input code achieves the same objective as the reference code.","```python
import pandas as pd

# SQL query to calculate the discount amount for each order in January 2023
sql_query = """"""
SELECT OrderID, SUM(Quantity * UnitPrice * Discount) AS DiscountAmount
FROM [Order Details]
WHERE OrderID IN (
    SELECT OrderID
    FROM orders
    WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
)
GROUP BY OrderID;
""""""

# Execute the SQL query and retrieve the result as a pandas DataFrame
orders_discount_df = execute_sql_query(sql_query)

# Display the output to the user
show_to_user(orders_discount_df)
```","Both implementations aim to calculate the discount amount for each order in January 2023. The key difference is the method of filtering orders. The reference code uses a JOIN between the orders and their details, filtering with a WHERE clause on OrderDate. The input code first filters OrderIDs with a subquery for January orders and then computes discounts from 'Order Details'. Both return the same logic of SUMing Quantity * UnitPrice * Discount and grouping by OrderID. Thus, the input code is correct.",both
What are the total sales by month? Use a line or bar chart to illustrate monthly sales trends.,"```python
import plotly.express as px

# SQL query to get the total sales by month
sql_query = """"""
SELECT 
    YEAR(o.OrderDate) AS Year, 
    MONTH(o.OrderDate) AS Month, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM 
    orders o 
INNER JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
GROUP BY 
    YEAR(o.OrderDate), 
    MONTH(o.OrderDate) 
ORDER BY 
    Year, 
    Month;
""""""

# Execute the query and get the dataframe
sales_data = execute_sql_query(sql_query)

# Ensure we use the 'Year' and 'Month' columns combined for correct x-axis
sales_data['YearMonth'] = sales_data['Year'].astype(str) + '-' + sales_data['Month'].astype(str).str.zfill(2)

# Create a line chart to illustrate monthly sales trends
fig = px.line(sales_data, x='YearMonth', y='TotalSales', title='Monthly Sales Trends', labels={'YearMonth': 'Month', 'TotalSales': 'Total Sales'}, markers=True)

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

monthly_sales = execute_sql_query(sql_query)

fig = px.line(monthly_sales, x='Month', y='TotalSales', title='Total Sales by Month', labels={'TotalSales':'Sales', 'Month':'Month'})
show_to_user(fig)
```","The input code and reference implementation both calculate total sales by month and visualize the trend using a line chart. While the SQL syntax and table/column references differ slightly, both achieve the same grouping and ordering by month. The visualization aspect is also consistent, using Plotly Express for creating a line chart with similar parameters.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', orders.OrderDate) AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Month;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Replace with actual implementation
    pass

def show_to_user(data):
    # Replace with actual implementation
    pass

# Execute the query to get data in a DataFrame
monthly_sales_df = execute_sql_query(sql_query)

# Create the line chart
fig = px.line(monthly_sales_df, x='Month', y='TotalSales', title='Monthly Sales Trends')

# Show the chart using the provided utility function
show_to_user(fig)
```","The input code does not align with the reference code logic in several aspects: 1) The reference implementation extracts 'Year' and 'Month' separately for ordering, while the input code uses 'DATE_TRUNC' to group by months without explicit ordering and without computing year separately. 2) The input code might not handle the sorting of months correctly since 'DATE_TRUNC' returns a timestamp and the chart might not be formatted properly. 3) The input code lacks markers in the plotting, which are present in the reference code. These differences can affect the analysis and visualization, making the input code incorrect regarding the given business analytics request.",Base
Which category has the highest number of products?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS NumberOfProducts 
FROM products 
GROUP BY CategoryID 
ORDER BY NumberOfProducts DESC 
LIMIT 1;
""""""

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS ProductCount
FROM products
GROUP BY CategoryID
ORDER BY ProductCount DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly replicates the behavior of the reference code. Both query the database for the category with the highest number of products, using COUNT and GROUP BY CategoryID, sorting in descending order by the count, and limiting the result to one record. The differences are only in alias naming conventions, which do not impact the logic or outcome.","```python
# Execute the SQL query to find the category with the highest number of products.
query = '''
SELECT CategoryID, COUNT(ProductID) AS number_of_products
FROM products
GROUP BY CategoryID
ORDER BY number_of_products DESC
LIMIT 1
'''

# Fetch the data using the utility function.
result_df = execute_sql_query(query)

# Display the result to the user.
show_to_user(result_df)
```","The input code correctly executes an SQL query that selects the CategoryID with the highest number of products, using the same logic as the reference code. It groups by CategoryID, counts ProductID, orders by this count in descending order, and limits the result to 1, which matches the request.",both
Which products received the highest total discount? Present this data with a bar chart for better comparison.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Discount) AS TotalDiscount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalDiscount DESC;
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Correct column names for Plotly
df.columns = ['ProductName', 'TotalDiscount']

# Create a bar chart
fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Products with the Highest Total Discount')

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalDiscount DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='TotalDiscount', title='Products with Highest Total Discount')
show_to_user(fig)
```","The input code calculates the total discount using `SUM(od.Discount * od.Quantity)`, which multiplies the discount by the quantity. The reference code calculates it using `SUM([Order Details].Discount)` without this multiplication. This discrepancy may lead to different discount totals and thus differing outputs.","```python
import plotly.express as px

# Given query to fetch data from the database
def execute_sql_query(sql_query: str):
    # Placeholder for the function to execute SQL and return a DataFrame
    pass

def show_to_user(data):
    # Placeholder for the function to display a DataFrame or Plotly figure
    pass

# SQL query to fetch products with their total discounts
sql_query = """"""
SELECT ProductID, SUM(Discount) AS TotalDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalDiscount DESC;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalDiscount', 
             title='Total Discounts by Product',
             labels={'TotalDiscount': 'Total Discount', 'ProductID': 'Product ID'})

# Display the bar chart
show_to_user(fig)
```","The input Python code does not match the reference implementation logic. The reference code joins the 'Order Details' with the 'products' table to obtain 'ProductName' and calculates the total discount for each product. The input code only fetches 'ProductID' and calculates its discount, missing the join with the 'products' table, which is required to display 'ProductName' instead of 'ProductID'. Thus, the input doesn't fully answer the business analytics request.",None
Which regions have the highest average order value? Use a bar chart to compare average order values across regions.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipRegion, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * 
       (1 - [Order Details].Discount)) AS AverageOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipRegion 
ORDER BY AverageOrderValue DESC
""""""

# Execute SQL query to get the data
data = execute_sql_query(sql_query)

# Create a bar chart to compare average order values across regions
fig = px.bar(data, x='ShipRegion', y='AverageOrderValue', 
             title='Average Order Value by Region',
             labels={'ShipRegion': 'Region', 'AverageOrderValue': 'Average Order Value'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.ShipRegion, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.ShipRegion
ORDER BY 
    AverageOrderValue DESC
""""""

average_order_value_df = execute_sql_query(sql_query)

fig = px.bar(average_order_value_df, x='ShipRegion', y='AverageOrderValue', 
             title='Average Order Value by Region', 
             labels={'AverageOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})
show_to_user(fig)
```","The input Python code correctly calculates the average order value by region using a SUM for total order values divided by the count of distinct orders. This aligns with the reference logic using AVG on the total order value calculation. Both approaches give the same result, and the input also correctly generates a bar chart to compare the values across regions.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch average order value by region
sql_query = """"""
SELECT RegionID, AVG(OrderValue) AS AvgOrderValue
FROM orders
GROUP BY RegionID;
""""""

# Utility function to execute SQL query and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would contain logic to connect to the database
    # execute the query, and return the results as a pandas DataFrame.
    # Placeholder implementation:
    # connection = sqlite3.connect('mddx.db')
    # return pd.read_sql_query(sql_query, connection)
    pass

# Execute SQL query and get data
df = execute_sql_query(sql_query)

# Ensure data is retrieved correctly
if df is not None and not df.empty:
    # Create a bar chart for average order values by region
    fig = px.bar(df, x='RegionID', y='AvgOrderValue',
                 title='Average Order Value by Region',
                 labels={'AvgOrderValue': 'Average Order Value', 'RegionID': 'Region ID'})

    # Display the bar chart using the utility function
    show_to_user(fig)
else:
    print(""No data found to display."")
```","The input code evaluates 'RegionID' and 'OrderValue' from a non-specified field, whereas the reference code calculates average order value from '[Order Details]' table using 'ShipRegion'. The input code does not replicate the logic of calculating using 'UnitPrice', 'Quantity', and 'Discount'. Thus, it does not adhere to the same logic or extract data correctly from the same tables and fields.",Base
Identify the top 3 customers by revenue in the last quarter. Include a bar chart to visualize customer revenue comparison.,"```python
import plotly.express as px

# Execute the SQL query using the provided utility function
sql_query = """"""
SELECT customers.CustomerID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as Revenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate > DATE_SUB(NOW(), INTERVAL 3 MONTH) 
GROUP BY customers.CustomerID 
ORDER BY Revenue DESC 
LIMIT 3;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart to visualize customer revenue comparison
fig = px.bar(df, x='CustomerID', y='Revenue', title='Top 3 Customers by Revenue in the Last Quarter')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the last quarter date range
last_quarter_start = '2023-07-01'
last_quarter_end = '2023-09-30'

# SQL query to get total revenue by customer in the last quarter
sql_query = f""""""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate BETWEEN '{last_quarter_start}' AND '{last_quarter_end}'
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    Revenue DESC
LIMIT 3;
""""""

# Execute the SQL query
top_customers = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(top_customers, x='CompanyName', y='Revenue', title='Top 3 Customers by Revenue in Last Quarter', labels={'Revenue': 'Revenue ($)'})

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It calculates the revenue by joining the tables customers, orders, and Order Details, computes the revenue, and filters the data by the last quarter. It then groups the data, orders by revenue, and limits the results to the top 3 customers. The visualization is created with a bar chart using Plotly. The inclusion of customer names under 'CompanyName' provides a more detailed visualization, which is an acceptable enhancement.","```python
import pandas as pd
import plotly.express as px

# Assume the utility functions are defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    pass

def show_to_user(data):
    # Placeholder for displaying data or plot
    pass

# SQL query to fetch data
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS revenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATEADD(quarter, -1, CURRENT_DATE) 
GROUP BY customers.CustomerID 
ORDER BY revenue DESC 
LIMIT 3;
""""""

# Execute the query and get the DataFrame
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart for revenue comparison
fig = px.bar(top_customers_df, x='CustomerID', y='revenue', 
             title='Top 3 Customers by Revenue in Last Quarter',
             labels={'CustomerID': 'Customer ID', 'revenue': 'Revenue'},
             text='revenue')

# Add text annotations to bars
fig.update_traces(textposition='outside')

# Show the plot to the user
show_to_user(fig)
```","The input Python code correctly implements the logic specified in the business analytics request. It mirrors the behavior of the reference implementation by executing a SQL query to identify the top 3 customers by revenue in the last quarter. The primary difference is the usage of DATEADD in place of DATE_SUB, which is a valid alternative to fetch data from the last quarter. Additionally, the input code uses a slightly enhanced visualization by adding text annotations to the bar chart, which does not deviate from the requested functionality but rather enriches it.",both
What percentage of orders were delivered before the required date in 2022?,"```python
import pandas as pd

# Execute the SQL query using the utility function
orders_df = execute_sql_query(""SELECT OrderDate, ShippedDate, RequiredDate FROM orders"")

# Filter orders for the year 2022
orders_2022 = orders_df[pd.to_datetime(orders_df['OrderDate']).dt.year == 2022]

# Calculate the number of orders delivered on or before the required date
delivered_on_time = orders_2022[orders_2022['ShippedDate'] <= orders_2022['RequiredDate']].shape[0]

# Calculate the percentage
before_required_date_rate = (delivered_on_time / orders_2022.shape[0]) * 100

# Create a DataFrame to display the result
result_df = pd.DataFrame({'BeforeRequiredDateRate': [before_required_date_rate]})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(OrderID) AS total_orders,
    COUNT(CASE WHEN ShippedDate < RequiredDate THEN 1 END) AS delivered_early
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2022
""""""

result = execute_sql_query(sql_query)
percentage_delivered_early = (result['delivered_early'][0] / result['total_orders'][0]) * 100

show_to_user(pd.DataFrame({'Percentage Delivered Early': [percentage_delivered_early]}))
```","The input code calculates orders delivered before the required date, while the reference considers orders delivered on or before. The input uses '<', but it should use '<=' to match the logic of the reference implementation.","```python
import pandas as pd

# Function that simulates the SQL query execution and returns the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Sample DataFrame returned as a placeholder for actual SQL execution
    # Replace with actual database query execution logic
    data = {
        'EarlyDeliveryCount': [30],  # Sample data for early deliveries
        'TotalOrderCount': [100]     # Sample data for total orders
    }
    return pd.DataFrame(data)

# Function to display results to the user
def show_to_user(data: pd.DataFrame):
    print(data)

# Main analysis function
def main():
    # SQL query to execute
    sql_query = '''
        SELECT COUNT(orders.OrderID) AS EarlyDeliveryCount
        FROM orders
        WHERE orders.RequiredDate > orders.ShippedDate AND orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
        
        SELECT COUNT(orders.OrderID) AS TotalOrderCount
        FROM orders
        WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
    '''
    
    # Execute SQL query and get results
    result_df = execute_sql_query(sql_query)
    
    early_delivery_count = result_df.iloc[0]['EarlyDeliveryCount']
    total_order_count = result_df.iloc[0]['TotalOrderCount']
    
    # Calculate early delivery percentage
    early_delivery_percentage = (early_delivery_count / total_order_count) * 100
    
    # Create a DataFrame for the result
    result_df = pd.DataFrame({'EarlyDeliveryPercentage': [early_delivery_percentage]})
    
    # Display the results
    show_to_user(result_df)

# Execute main analysis function
main()
```","The input code is incorrect because it does not follow the same logic as the reference implementation. It uses a simulated SQL query that does not return the correct dataset structure (OrderDate, ShippedDate, RequiredDate) required for filtering and calculating the percentage of on-time deliveries. Additionally, it combines two separate SQL queries into one string, which is not executed in a manner that reflects this separation. The reference code filters the orders from 2022 and checks each individually for on-time delivery, while the provided code seems to attempt aggregating results straight from a query, but does not align with how the data is processed in the reference implementation.",None
Which supplier has the shortest average lead time in April 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY products.SupplierID
ORDER BY supplier_lead_time ASC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time
FROM orders
JOIN products ON orders.OrderID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY avg_lead_time ASC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The evaluated code is incorrect because it joins tables differently than the reference implementation. Specifically, it mistakenly joins 'orders' with 'products' using the 'OrderID' and 'ProductID', which does not make sense. The join should be between 'orders' and 'Order Details' on 'OrderID'. Additionally, the inclusion of 'suppliers.CompanyName' is unnecessary and slightly alters the grouping logic compared to the reference, which only groups by 'SupplierID'.","```python
import pandas as pd

# Assume the following function is provided to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function to execute SQL queries and return DataFrame
    pass

# Function to display data or result to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        print(""No data available"")

def find_shortest_lead_time_supplier():
    # SQL query to fetch the supplier with the shortest average lead time in April 2023
    sql_query = """"""
    SELECT suppliers.CompanyName 
    FROM suppliers 
    INNER JOIN [Order Details] ON suppliers.SupplierID = [Order Details].SupplierID 
    INNER JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
    GROUP BY suppliers.CompanyName 
    ORDER BY AVG(orders.RequiredDate - orders.OrderDate) ASC 
    LIMIT 1
    """"""
    
    # Execute the query and get the result
    results_df = execute_sql_query(sql_query)
    
    # Show the result to the user
    show_to_user(results_df)

# Call the function to execute
find_shortest_lead_time_supplier()
```","The provided code does not correctly implement the logic specified by the reference code. The reference implementation calculates the shortest average lead time using 'AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate))', which is based on shipped dates, while the input code uses 'AVG(orders.RequiredDate - orders.OrderDate)', based on required dates. Additionally, the reference code selects SupplierID, whereas the input code selects CompanyName, and uses different joining paths. These discrepancies show that it does not align with the logic of the reference implementation.",None
Who are the employees reporting to each manager?,"```python
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT m.EmployeeID AS ManagerID, 
       m.LastName AS ManagerLastName, 
       m.FirstName AS ManagerFirstName, 
       e.EmployeeID AS EmployeeID, 
       e.LastName AS EmployeeLastName, 
       e.FirstName AS EmployeeFirstName 
FROM employees e 
JOIN employees m ON e.ReportsTo = m.EmployeeID;
""""""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Display the results
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    e1.FirstName AS ManagerFirstName,
    e1.LastName AS ManagerLastName,
    e2.FirstName AS EmployeeFirstName,
    e2.LastName AS EmployeeLastName
FROM 
    employees e1
LEFT JOIN 
    employees e2 ON e1.EmployeeID = e2.ReportsTo
WHERE 
    e1.Title LIKE '%Manager%'
ORDER BY 
    e1.LastName, e1.FirstName, e2.LastName;
""""""

employees_reporting_to_managers = execute_sql_query(sql_query)
show_to_user(employees_reporting_to_managers)
```","The input code filters managers based on a title containing 'Manager' rather than using the existing relationship defined by the ReportsTo field in the employees table. The reference code correctly associates employees to managers using the ReportsTo relationship without assuming that a manager's title contains 'Manager'. Therefore, the logic of the input code does not align with the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    e1.FirstName AS EmployeeFirstName, 
    e1.LastName AS EmployeeLastName, 
    e2.FirstName AS ManagerFirstName, 
    e2.LastName AS ManagerLastName 
FROM 
    employees e1 
JOIN 
    employees e2 
ON 
    e1.ReportsTo = e2.EmployeeID;
""""""

# Execute the query and get the result as a DataFrame
employee_manager_df = execute_sql_query(sql_query)

# Display the result
show_to_user(employee_manager_df)
```","Both implementations achieve the same objective: listing employees along with their managers by joining the employees table on the 'ReportsTo' and 'EmployeeID' columns. The evaluated code simply changes the order of columns and does not include 'EmployeeID' and 'ManagerID', which is non-essential for addressing the business request.",Finetuned
Find the average discount applied to orders in January 2023.,"```python
import pandas as pd

# SQL Query to find average discount
sql_query = """"""
SELECT AVG(od.Discount) AS AvgDiscount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","Both the input code and the reference implementation are functionally equivalent. The input code correctly calculates the average discount for orders in January 2023 by joining the 'Order Details' and 'orders' tables on 'OrderID'. It conditions the 'OrderDate' to be from January 1, 2023, to before February 1, 2023, which is an equivalent range to January 1 to January 31. The SQL logic matches the reference code's logic, hence it is correct.","```python
import pandas as pd

# Define the SQL query to retrieve the average discount for January 2023
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE MONTH(orders.OrderDate) = 1 AND YEAR(orders.OrderDate) = 2023
""""""

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the average discount to the user
show_to_user(result_df)
```","The input code correctly calculates the average discount for orders placed in January 2023. It joins the 'orders' table with the '[Order Details]' table based on OrderID, which aligns with the reference code. The use of `MONTH(orders.OrderDate) = 1 AND YEAR(orders.OrderDate) = 2023` is logically equivalent to the date range used in the reference code (`BETWEEN '2023-01-01' AND '2023-01-31'`). Thus, the input code adheres to the same logic and accomplishes the business analytics request accurately.",both
Calculate the total sales for employees located in a specific region.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = 'specific region'
GROUP BY e.EmployeeID;
""""""

# Execute the query and get the result as a dataframe
sales_data_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_data_df)
```","```python
def calculate_total_sales(region):
    sql_query = f""""""
    SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
    FROM employees e
    JOIN orders o ON e.EmployeeID = o.EmployeeID
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    WHERE e.Region = '{region}'
    GROUP BY e.EmployeeID
    """"""
    total_sales_df = execute_sql_query(sql_query)
    show_to_user(total_sales_df)

calculate_total_sales('Specific Region')
```",The input code correctly replicates the logic of the reference implementation. It calculates the total sales for employees in a specified region using a SQL query. The only difference is the implementation of a parameterized function that allows for dynamic region input. This change maintains the functionality and logic of the reference code.,"```python
import pandas as pd

# Define the SQL query with a parameter placeholder for the region
sql_query = """"""
SELECT SUM(od.Quantity * od.UnitPrice) AS EmployeeTotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = ?
""""""

# Function to execute the SQL query and calculate sales
def calculate_employee_sales(region: str) -> pd.DataFrame:
    # Execute the SQL query with the provided region
    sales_data = execute_sql_query(sql_query, (region,))
    
    # Return the sales data as a pandas DataFrame
    return sales_data

# Example to calculate total sales for a specific region
# sales_df = calculate_employee_sales('East')
# display_to_user(sales_df)
```","The input code calculates total sales without accounting for discounts, unlike the reference code, which includes a discount in the calculation `(od.UnitPrice * od.Quantity * (1 - od.Discount))`. Moreover, the input code does not group by EmployeeID, which is necessary to match the reference implementation's per-employee breakdown.",Base
What are the names of all suppliers who are located in Germany?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""

# Execute the query
suppliers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(suppliers_df)
```","```python
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""
suppliers_in_germany = execute_sql_query(sql_query)
show_to_user(suppliers_in_germany)
```",The input code precisely replicates the logic and intent of the reference code. Both versions execute the same SQL query to retrieve the 'CompanyName' of suppliers located in Germany and use a function to display the results to the user. The differences in variable naming ('suppliers_df' vs 'suppliers_in_germany') do not affect the code's correctness or adherence to the specified business request.,"```python
# Define the SQL query
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""

# Execute the query using the utility function to get the result as a DataFrame
df_suppliers_in_germany = execute_sql_query(sql_query)

# Utilize the provided utility function to display the result
show_to_user(df_suppliers_in_germany)
```","The input Python code correctly follows the logic of the reference implementation. It selects the `CompanyName` from the `suppliers` table where the `Country` is 'Germany', executes the query using `execute_sql_query`, and displays the result using `show_to_user`. The transformation of code variables from `suppliers_df` to `df_suppliers_in_germany` is consistent with the reference logic.",both
What was the average order value in June 2023?,"```python
import pandas as pd

# SQL query to calculate average order value in June 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-06';
""""""

# Execute the query and retrieve the result in a dataframe
df = execute_sql_query(sql_query)

# Display the average order value to the user
show_to_user(df['AvgOrderValue'].iloc[0])
```","```python
sql_query = """"""
SELECT 
    AVG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-06-01' AND o.OrderDate < '2023-07-01'
GROUP BY 
    o.OrderID
""""""

average_order_value_df = execute_sql_query(sql_query)
show_to_user(average_order_value_df)
```","The evaluated code calculates the average order value by computing the average of sums per order after filtering for June 2023. It groups by OrderID and uses AVG on the sums, which aligns with calculating SUM/COUNT(DISTINCT OrderID) as in the reference. The date filter logic is also equivalent.","
import pandas as pd

# Define the utility function to execute the SQL query and return the result
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would connect to the database, execute the query, and return a DataFrame
    # Placeholder implementation
    pass

def show_to_user(data):
    # Function to display data or result to the user
    print(data)

# SQL query to fetch the average order value for June 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    EXTRACT(YEAR FROM o.OrderDate) = 2023 
    AND EXTRACT(MONTH FROM o.OrderDate) = 6;
""""""

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","The input Python code adheres to the same logic as the reference implementation. It calculates the average order value for June 2023 by using a SQL query that sums the product of UnitPrice, Quantity, and the discount, then divides by the count of distinct OrderIDs. Both the input and reference codes filter on the order date to ensure only orders from June 2023 are considered. The syntax used to extract the month and year from the date differs (EXTRACT function vs DATE_FORMAT), but both achieve the same result. The implementation correctly displays the average order value to the user.",both
Calculate the average freight cost for each customer. Use a bar chart to compare freight costs across customers.,"```python
import plotly.express as px

# Execute the SQL query to retrieve the data
sql_query = ""SELECT CustomerID, AVG(Freight) AS AvgFreight FROM orders GROUP BY CustomerID;""
df = execute_sql_query(sql_query)

# Create a bar chart to compare freight costs across customers
fig = px.bar(df, x='CustomerID', y='AvgFreight', title='Average Freight Cost per Customer', labels={'AvgFreight': 'Average Freight Cost', 'CustomerID': 'Customer ID'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, AVG(Freight) AS AverageFreight
FROM orders
GROUP BY CustomerID
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='CustomerID', y='AverageFreight', title='Average Freight Cost per Customer')
show_to_user(fig)
```","The input code computes the average freight cost for each customer by executing a SQL query. It groups data by CustomerID and calculates the average freight using AVG(Freight). This aligns with the reference implementation's logic. Both implementations use Plotly Express to create a bar chart comparing customers' average freight costs, using the same data and visual parameters. Therefore, the input code fulfills the business analytics request correctly.","```python
import pandas as pd
import plotly.express as px

# Sample implementation of the placeholder functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulate fetching data from SQL database
    data = {
        'CustomerID': ['C001', 'C002', 'C003'],
        'AverageFreightCost': [50.5, 75.0, 32.5]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Business Logic
sql_query = ""SELECT CustomerID, AVG(Freight) as AverageFreightCost FROM orders GROUP BY CustomerID;""
averaged_data = execute_sql_query(sql_query)

# Visualization
fig = px.bar(
    averaged_data,
    x='CustomerID',
    y='AverageFreightCost',
    title='Average Freight Cost per Customer',
    labels={'AverageFreightCost': 'Avg Freight Cost', 'CustomerID': 'Customer ID'},
    text='AverageFreightCost'
)

# Show the plot
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It executes an SQL query to obtain average freight costs per customer and uses Plotly to create a bar chart comparing these costs. The SQL query, data processing, and visualization match the intent of the business request and the reference code. Although the placeholder function `execute_sql_query` returns simulated data, it adheres to the required schema. The use of 'AverageFreightCost' instead of 'AvgFreight' as the column label is consistent across the code and does not affect the correctness.",both
How many orders were placed on weekends in the last three months? Present the data with a bar chart for each weekend.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders placed on weekends in the last three months
sql_query = """"""
SELECT DAY(OrderDate) AS Day, MONTH(OrderDate) AS Month, YEAR(OrderDate) AS Year, COUNT(OrderID) AS WeekendOrders 
FROM orders 
WHERE DAYOFWEEK(OrderDate) IN (1, 7) 
AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
GROUP BY Year, Month, Day
""""""

# Execute the SQL query and get the dataframe
df = execute_sql_query(sql_query)

# Combine the day, month, and year into a single date column
df['OrderDate'] = pd.to_datetime(df[['Year', 'Month', 'Day']])

# Create a bar chart with Plotly
fig = px.bar(df, x='OrderDate', y='WeekendOrders', title='Weekend Orders in the Last 3 Months')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last three months
end_date = datetime.now()
start_date = end_date - timedelta(days=90)

# Query to retrieve weekend order counts from the database
sql_query = f""""""
SELECT 
    DATE(OrderDate) AS OrderDate, 
    COUNT(OrderID) AS OrderCount
FROM 
    orders
WHERE 
    OrderDate >= '{start_date.strftime('%Y-%m-%d')}' 
    AND OrderDate <= '{end_date.strftime('%Y-%m-%d')}'
    AND DAYOFWEEK(OrderDate) IN (1, 7)  -- 1 = Sunday, 7 = Saturday
GROUP BY 
    DATE(OrderDate)
ORDER BY 
    OrderDate;
""""""

# Execute the SQL query
weekend_orders = execute_sql_query(sql_query)

# Plotting the data
fig = px.bar(weekend_orders, x='OrderDate', y='OrderCount', title='Weekend Orders in the Last 3 Months')
show_to_user(fig)
```","The input code correctly calculates the number of orders placed on weekends in the last three months and plots it on a bar chart. It uses the `DAYOFWEEK` function to filter weekends and selects dates within the last 90 days (approximation for 3 months). It groups and counts orders by date, similar to the reference implementation which groups by day, month, and year. Both approaches result in the same logical outcome.","```python
import pandas as pd
import plotly.express as px

# Given SQL query to fetch all weekend orders in the last three months
sql_query = """"""
SELECT 
    o.OrderID, 
    o.OrderDate 
FROM 
    orders o 
WHERE 
    MONTH(o.OrderDate) = MONTH(CURRENT_DATE) OR 
    MONTH(o.OrderDate) = MONTH(CURRENT_DATE - interval 1 month) OR 
    MONTH(o.OrderDate) = MONTH(CURRENT_DATE - interval 2 month) 
AND 
    DAYOFWEEK(o.OrderDate) IN (1, 7)
""""""

# Execute SQL query and get the result as a DataFrame
orders_df = execute_sql_query(sql_query)

# Add a column to identify the weekend (Saturday or Sunday)
# Note: DAYOFWEEK returns 1 for Sunday, 7 for Saturday
orders_df['Weekend'] = orders_df['OrderDate'].apply(lambda x: 'Saturday' if x.weekday() == 5 else 'Sunday')

# Group by Weekend and count the number of orders for each weekend
weekend_orders_df = orders_df.groupby(['OrderDate', 'Weekend']).size().reset_index(name='OrderCount')

# Create a bar chart for the number of orders placed on weekends
fig = px.bar(weekend_orders_df, 
             x='OrderDate', 
             y='OrderCount', 
             color='Weekend', 
             title='Weekend Orders in the Last Three Months',
             labels={'OrderDate': 'Date', 'OrderCount': 'Number of Orders'},
             barmode='group')

# Show the plot to the user
show_to_user(fig)
```","The input code filters months using a logic that might include dates not within the last three months from the current date, whereas the reference considers an exact three-month interval from the current date. Additionally, the input code doesn't group totals by each specific weekend date but rather by the day, potentially leading to different aggregation logic. The reference code aggregates strictly by full weekend day counts. Hence, the input implementation could lead to incorrect results.",Base
What is the total sales revenue generated in the year 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result
total_sales = df['total_sales'].iloc[0]
show_to_user(total_sales)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input code shows the entire DataFrame 'total_sales_df' directly, rather than extracting the first element as done in the reference code, which uses 'total_sales = df['total_sales'].iloc[0]'. This means it may not display the total sales revenue correctly if 'show_to_user' is not designed to handle DataFrame inputs.","```python
from typing import Any

def execute_sql_query(sql_query: str) -> Any:
    # Simulated function to execute an SQL query
    # This function should return the result of the query
    pass

def show_to_user(data: Any) -> None:
    # Simulated function to display data analysis or queries to the user
    pass

# SQL query to calculate total sales revenue for the year 2023
sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = 2023
""""""

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(revenue_data)
```","The provided code achieves the same functionality as the reference code. It calculates the total sales revenue for the year 2023 through a SQL query. The main difference is in the way the year filter is applied: the provided code uses 'YEAR(o.OrderDate) = 2023', while the reference uses a date range 'BETWEEN 2023-01-01 AND 2023-12-31'. Both methods are logically equivalent in filtering orders to the year 2023 and calculating the total revenue correctly.",Finetuned
How many products have been ordered but not yet shipped?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT COUNT(orders.OrderID) AS Products_Not_Shipped FROM orders WHERE orders.ShippedDate IS NULL;""

# Execute the query
df_orders_not_shipped = execute_sql_query(sql_query)

# Prepare result to show
result_df = pd.DataFrame({'Products_Not_Shipped': [df_orders_not_shipped['Products_Not_Shipped'].iloc[0]]})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(*) AS ProductsNotShipped
FROM orders
WHERE ShippedDate IS NULL
""""""
products_not_shipped = execute_sql_query(sql_query)
show_to_user(products_not_shipped)
```","The input code correctly answers the business request by counting the number of products where 'ShippedDate' is NULL, indicating they are ordered but not shipped. It uses an equivalent SQL query to the reference implementation. The main difference is in how the result is handled: the input code directly displays the result returned from the query without creating a DataFrame, but this does not affect the correctness of the logic.","```python
import pandas as pd

# Assuming execute_sql_query and display_data_to_user are predefined functions

# SQL query to fetch the number of products ordered but not yet shipped
sql_query = """"""
SELECT COUNT(*) AS UnshippedOrders
FROM OrderDetails
WHERE OrderID IN (
    SELECT OrderID FROM Orders WHERE ShippedDate IS NULL
);
""""""

# Execute the SQL query and store the result in a DataFrame
unshipped_orders_df = execute_sql_query(sql_query)

# Display the result to the user
display_data_to_user(unshipped_orders_df)
```","The provided code correctly calculates the number of products that have been ordered but not yet shipped by counting the unshipped orders from the 'Orders' table. It uses a subquery to find orders with a NULL 'ShippedDate', aligning logically with the reference implementation. Despite differences in table names ('OrderDetails' vs 'orders') and slight variation in SQL structure, the key logic to identify unshipped orders is maintained.",both
Which products are low in stock and need reordering?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE UnitsInStock <= ReorderLevel 
AND Discontinued = 0;
""""""

# Execute the SQL query to get the data
low_stock_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(low_stock_products_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
low_stock_products = execute_sql_query(sql_query)
show_to_user(low_stock_products)
```","The input code correctly identifies low stock products needing reordering by querying for products where UnitsInStock is less than ReorderLevel and Discontinued is 0, similar to the reference. The slight difference in the operator (<= vs <) is acceptable as both capture the condition of needing reorder. The additional columns (ProductID, UnitsInStock, ReorderLevel) do not affect correctness regarding the business question.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE UnitsInStock < ReorderLevel;
""""""

# Execute the SQL query to get the low stock products
low_stock_products_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(low_stock_products_df)
```","The input code incorrectly identifies low stock products because it does not check if the products are 'Discontinued'. The reference implementation includes 'AND Discontinued = 0' to ensure it only considers products that are still active. Additionally, the comparison operator should be '<=' instead of '<' to align with the reference logic.",Base
How many orders were shipped but not yet delivered by the required date?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS Count FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result['Count'][0])
```","```python
sql_query = """"""
SELECT COUNT(OrderID) AS UnfulfilledOrders
FROM orders
WHERE ShippedDate IS NOT NULL 
AND ShippedDate > RequiredDate
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly counts the number of orders where the 'ShippedDate' is not null and exceeds the 'RequiredDate', which aligns with the business analytics request. The key condition 'ShippedDate > RequiredDate' is the same as in the reference implementation. The difference in counting 'OrderID' instead of '*' and naming the column differently ('UnfulfilledOrders' vs. 'Count') does not change the outcome of the query execution or its logic.","```python
# This utility function fetches data using an SQL query and loads it as a DataFrame.
def execute_sql_query(sql_query: str):
    # Placeholder for actual implementation.
    pass

# This utility function displays the data to the user.
def show_to_user(data):
    # Placeholder for actual implementation.
    pass

# SQL query to count orders that have a ship date but are still pending delivery.
sql_query = """"""
SELECT COUNT(OrderID) FROM orders 
WHERE ShipDate < RequiredDate AND ShippedDate IS NOT NULL;
""""""

# Execute the SQL query to get the count of overdue shipped orders.
overdue_orders_count_df = execute_sql_query(sql_query)

# Display the result to the user.
show_to_user(overdue_orders_count_df)
```","The input code checks for ShipDate < RequiredDate and ShippedDate IS NOT NULL, which does not align with the request or reference implementation checking ShippedDate > RequiredDate.",Base
Determine the average number of products per order.,"```python
import pandas as pd

# SQL query to determine the average number of products per order
sql_query = """"""
SELECT AVG(ProductCount) AS AverageProductsPerOrder 
FROM (
    SELECT OrderID, COUNT(ProductID) AS ProductCount 
    FROM [Order Details] 
    GROUP BY OrderID
) AS ProductCounts;
""""""

# Execute the SQL query
average_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_df['AverageProductsPerOrder'])
```","```python
sql_query = """"""
SELECT AVG(OrderDetails.Quantity) AS AverageProductsPerOrder
FROM [Order Details] AS OrderDetails
GROUP BY OrderDetails.OrderID
""""""

average_products_per_order = execute_sql_query(sql_query)
show_to_user(average_products_per_order)
```","The input code is incorrect because it calculates the average of the 'Quantity' for each 'OrderID', treating quantities within an order as individual contributions to the average. The reference implementation correctly calculates the average number of distinct products per order by grouping first by 'OrderID' and counting 'ProductID'. Thus, the logic differs in how the average is computed.","To calculate the average number of products per order using SQL is straightforward. However, since you've requested a Python implementation, I will provide a script that integrates SQL execution and the processing of results.

Here's how you would write it in Python:

```python
import pandas as pd

# Assuming these helper functions are already provided and available to use
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function needs to execute the provided SQL query
    # and return the result as a pandas DataFrame
    pass  # Replace with actual implementation

def show_to_user(data):
    # This function displays results to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to calculate the average number of products per order
sql_query = """"""
SELECT AVG(NumberOfProducts) AS AvgProductsPerOrder
FROM (
    SELECT o.OrderID, COUNT(op.ProductID) AS NumberOfProducts
    FROM orders o
    JOIN [Order Details] op ON o.OrderID = op.OrderID
    GROUP BY o.OrderID
) AS OrderProductCounts;
""""""

# Execute the SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```

### Explanation:
1. **SQL Query**: This remains unchanged. It calculates the average number of products per order, using a subquery to first count the number of products per order.
  
2. **`execute_sql_query` Function**: This should execute the SQL query and return the processed result as a pandas DataFrame.

3. **`show_to_user` Function**: This displays the DataFrame to the user. If additional functionality is needed (e.g., printing tables in a specific format), that can be added here.

### Note:
You need to ensure the environment you run this code in has the necessary database connection established in `execute_sql_query` and the output methods tailored to your requirements.","The provided Python code correctly follows the logic of the reference implementation. It retrieves the average number of products per order by using an SQL query with a subquery to count products per order and then calculating the average. The use of helper functions to execute the SQL and display results is methodologically sound, as the reference focuses on the query's logic rather than the specifics of these implementations.",Finetuned
Which suppliers provide products that are currently discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 1;
""""""

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT DISTINCT p.SupplierID
FROM products p
WHERE p.Discontinued = 1
""""""
discontinued_suppliers = execute_sql_query(sql_query)
show_to_user(discontinued_suppliers)
```","The evaluated code only selects the SupplierID from the products table where products are discontinued, missing the required JOIN to fetch the CompanyName from the suppliers table. Without joining and including CompanyName, it does not fully adhere to the logic of the reference implementation.","```python
import pandas as pd

# Execute the SQL query to find discontinued products and their suppliers
sql_query = """"""
SELECT suppliers.SupplierName
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
WHERE products.Discontinued = 1;
""""""

# Using the provided utility function to get the data
results_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(results_df)
```",The input code returns 'SupplierName' while the reference code returns 'SupplierID' and 'CompanyName'. The input does not select the correct fields to fulfill the business request.,None
What are the most commonly ordered product quantities?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS MostCommonQuantities 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID 
ORDER BY MostCommonQuantities DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Quantity, COUNT(*) as OrderCount
FROM [Order Details]
GROUP BY Quantity
ORDER BY OrderCount DESC
LIMIT 10;
""""""

result_df = execute_sql_query(sql_query)
fig = px.bar(result_df, x='Quantity', y='OrderCount', title=""Most Commonly Ordered Product Quantities"")
show_to_user(fig)
```","The input code counts how many times each quantity is ordered across all products and displays the top 10 most common quantities, whereas the reference code sums quantities per product and ranks products based on total quantities ordered. The logic of determining most common quantities is different between the two implementations.","```python
import pandas as pd

# Assuming utility functions execute_sql_query and show_to_user are already defined

# Execute the provided SQL query to get the data
sql_query = """"""
SELECT Quantity, COUNT(*) AS OrderCount
FROM [Order Details]
GROUP BY Quantity
ORDER BY COUNT(*) DESC;
""""""

# Fetch the data into a pandas DataFrame
df = execute_sql_query(sql_query)

# Display the results
show_to_user(df)
```","The reference implementation aggregates order quantities by ProductID, summing the quantities per product to determine the most ordered products. The input code, however, groups by the quantity itself, counting occurrences of each quantity ordered, which does not align with the reference implementation's goal of identifying most commonly ordered products.",None
Find the most expensive product by unit price.,"```python
import pandas as pd

sql_query = ""SELECT ProductName FROM products ORDER BY UnitPrice DESC LIMIT 1;""
df = execute_sql_query(sql_query)

most_expensive_product = df['ProductName'].iloc[0]

result_df = pd.DataFrame({'Most Expensive Product': [most_expensive_product]})
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice 
FROM products 
ORDER BY UnitPrice DESC 
LIMIT 1
""""""

most_expensive_product = execute_sql_query(sql_query)
show_to_user(most_expensive_product)
```","The input code effectively accomplishes the same task as the reference code by querying the product with the highest unit price and displaying the result. Both implementations use SQL to sort by 'UnitPrice' and retrieve the top record with 'LIMIT 1'. The difference lies in how the results are shown: the input code directly displays the result dataframe using 'show_to_user', while the reference extracts the 'ProductName' and creates a new dataframe for display. Both provide the same outcome in response to the business query.","
```python
import pandas as pd

# Define the SQL query to find the most expensive product
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 1;""

# Execute the SQL query and get the result as a DataFrame
most_expensive_product_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(most_expensive_product_df)
```","Both the reference and the input code aim to find the most expensive product by ordering the products by UnitPrice in descending order and limiting to the top result. The input code includes both 'ProductName' and 'UnitPrice' in the query, and displays this directly, which still fulfills the requirement. The logic aligns with the reference implementation.",both
Find the top 5 highest priced products with a visualization to compare prices.,"```python
import plotly.express as px

# Define SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Generate a bar chart to compare prices
fig = px.bar(df, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
ORDER BY UnitPrice DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products', labels={'UnitPrice': 'Price', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly implements the task requested. It retrieves the top 5 highest priced products by executing an SQL query similar to the reference implementation. The result is stored in a dataframe called 'top_products'. The visualization is generated using Plotly Express, creating a bar chart to compare product prices, which aligns with the reference code. Additional label customizations in the input code do not affect correctness per the task's requirements.","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query to get the top 5 highest priced products
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to compare product prices
fig = px.bar(top_products_df, x='ProductName', y='UnitPrice',
             title='Top 5 Highest Priced Products',
             labels={'UnitPrice': 'Price ($)', 'ProductName': 'Product Name'})

# Display the visualization to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to retrieve the top 5 highest priced products, stores the result in a DataFrame, and creates a bar chart using Plotly to compare product prices. Although it includes additional labeling that is not present in the reference code, the logic follows the same steps as the reference implementation: executing the query, creating a visualization, and displaying it. Therefore, it adheres to the business analytics request and the logic of the reference code.",both
"List customers with their respective regions and count of orders placed, visualizing order counts geographically.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    customers.CustomerID, 
    customers.Region, 
    COUNT(orders.OrderID) AS total_orders 
FROM 
    customers 
LEFT JOIN 
    orders 
ON 
    customers.CustomerID = orders.CustomerID 
GROUP BY 
    customers.CustomerID, customers.Region;
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Aggregate total_orders by region
aggregated_data = data.groupby('Region', as_index=False)['total_orders'].sum()

# Visualize order counts geographically
fig = px.bar(aggregated_data, x='Region', y='total_orders', color='Region', 
             title='Order Counts by Region')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get customers with their regions and count of orders
sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    c.Region,
    COUNT(o.OrderID) AS OrderCount
FROM 
    customers c
LEFT JOIN 
    orders o ON c.CustomerID = o.CustomerID
GROUP BY 
    c.CustomerID, c.CompanyName, c.Region
""""""

# Execute the SQL query
customers_orders = execute_sql_query(sql_query)

# Create a geographical visualization of order counts
fig = px.scatter_geo(customers_orders,
                     locations=""Region"",
                     size=""OrderCount"",
                     hover_name=""CompanyName"",
                     title=""Customers by Region and Order Count"",
                     locationmode='country names',
                     scope='world')

# Show the visualization to the user
show_to_user(fig)
```","The input code differs from the reference implementation in key areas. The reference code aggregates the order counts by region, whereas the input code aggregates by customer and region, leading to potentially different visualizations. Furthermore, the visualization type differs: the reference uses a bar chart to display aggregated data by region, which provides a clear overview, while the input uses a scatter geo plot showing data by individual customers, which may not effectively visualize order counts geographically at a regional level as requested.","To fulfill the given request, we will follow these steps:

1. **SQL Query Execution** to get customer data with their respective regions and order counts.
2. **Data Visualization** to plot the geographical distribution of order counts by region.

Here's how to implement this using Python:

```python
import pandas as pd
import plotly.express as px

# Assume the utility function is defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented
    pass

def show_to_user(data):
    # This function is assumed to display a plot or DataFrame
    pass

# SQL Query to fetch customer regions with order counts
sql_query = """"""
SELECT c.CustomerID, c.Region, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.Region
""""""

# Execute the SQL query and get the results in a DataFrame
customer_order_data = execute_sql_query(sql_query)

# Create a geographical plot using Plotly
fig = px.scatter_geo(
    customer_order_data,
    locations=""Region"",  # Use Region column for geographical mapping
    locationmode=""region names"",  # Specify that Region names will be used
    size=""OrderCount"",  # Bubble size based on OrderCount
    title=""Order Counts by Customer Region""
)

# Show plot to user
show_to_user(fig)
```

### Explanation of the Code Snippet:

1. **SQL Query**: The query joins the `customers` and `orders` tables using the `CustomerID`, counting the number of orders per customer per region.

2. **Data Retrieval**: The `execute_sql_query` function executes the SQL query and returns the results in a `pandas` DataFrame.

3. **Geographic Plot**: 
   - `plotly.express.scatter_geo` is used to create a geographical scatter plot.
   - `locations` is set to the `Region` column (assumed to contain valid region names).
   - `size` is set to `OrderCount` to reflect the number of orders per region.

4. **Display Function**: The `show_to_user` utility function is called to render the resulting plot.","The provided Python code does not align with the reference implementation in terms of visualizing order counts. The reference implementation aggregates total order counts by region, but the input code groups them by customers per region and uses a scatter_geo plot, which doesn't match the reference bar chart approach. Moreover, the input code uses JOIN instead of LEFT JOIN; thus, it might exclude customers with no orders.",None
"Find the top 5 cities with the highest number of orders, using a bar chart for comparison.","```python
import plotly.express as px

# Execute the SQL query to get the top 5 cities with highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 5
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request of finding the top 5 cities with the highest number of orders and visualizes it using a bar chart with Plotly. The SQL query used is identical to the reference implementation, selecting 'ShipCity' and counting 'OrderID', grouping by 'ShipCity', ordering by 'OrderCount' descending, and limiting the result to 5 records. The bar chart creation also matches the logic of the reference code, ensuring the same visualization outcome. Therefore, the input code adheres to the specified logic and correctness requirements.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch top 5 cities with highest orders
sql_query = """"""
SELECT o.ShipCity, COUNT(o.OrderID) AS OrderCount
FROM orders o
GROUP BY o.ShipCity
ORDER BY OrderCount DESC
LIMIT 5;
""""""

# Execute the SQL query to get the data
data_frame = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top cities
fig = px.bar(data_frame, x='ShipCity', y='OrderCount', title='Top 5 Cities by Number of Orders')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code is correct as it implements the same logic as the reference code. Both codes execute a SQL query to find the top 5 cities with the highest number of orders, using COUNT and GROUP BY clauses, and then order them in descending order before limiting the results to 5. They both use Plotly Express to create a bar chart with the queried data, displaying 'ShipCity' on the x-axis and 'OrderCount' on the y-axis, and use the function `show_to_user` to display the chart. The slight differences in variable names and the SQL syntax do not affect the logic or correctness of the implementation.",both
"What is the total quantity of each product sold, visualized with a bar chart?","```python
import plotly.express as px

# SQL query to get the total quantity of each product sold
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity Sold by Product')

# Show the result to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductID', y='TotalQuantity', title='Total Quantity of Each Product Sold')
show_to_user(fig)
```","The input code effectively calculates the total quantity of each product sold and visualizes it with a bar chart. It uses a similar SQL query logic as the reference, grouping by ProductID and summing the Quantities. The additional JOIN operation in the input code fetches Order details but does not affect the outcome for the given task of aggregating quantities by ProductID. The use of plotly.express to create a bar chart is consistent with the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Assumed utility functions based on prompt context
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would connect to the database and execute the query.
    # It is predefined and returns a pandas DataFrame.
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query for fetching total quantity sold for each product
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity
FROM [Order Details]
GROUP BY ProductID;
""""""

# Execute the SQL query to retrieve data into a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total quantity sold for each product
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity Sold for Each Product')

# Display the visualization using the predefined function
show_to_user(fig)
```","The provided code performs the same operations as the reference code. It executes the SQL query to sum quantities by ProductID, stores the result in a DataFrame, and then uses Plotly to create and display a bar chart. The logic and intended output align with the reference implementation.",both
Find the total sales and the number of orders for each customer in March 2023 with a bar chart for comparison.,"```python
import plotly.express as px

# The SQL query to execute
sql_query = """"""
SELECT O.CustomerID, SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales, 
COUNT(O.OrderID) AS OrderCount 
FROM orders O 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
WHERE DATE_FORMAT(O.OrderDate, '%Y-%m') = '2023-03' 
GROUP BY O.CustomerID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for comparison
fig = px.bar(data, x='CustomerID', y=['TotalSales', 'OrderCount'], 
             barmode='group', 
             title='Total Sales and Number of Orders for Each Customer in March 2023')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.CustomerID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
    COUNT(o.OrderID) AS NumberOfOrders
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-03-01' AND o.OrderDate < '2023-04-01'
GROUP BY 
    o.CustomerID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CustomerID', y='TotalSales', text='NumberOfOrders', title='Total Sales and Number of Orders per Customer in March 2023')
show_to_user(fig)
```","The input Python code correctly calculates the total sales and the number of orders for each customer in March 2023. It uses a different date filtering approach, which is equally valid (using date range instead of date formatting). The bar chart displays 'TotalSales' with the number of orders as text, which, although styled differently from the reference implementation (grouped bars), still fulfills the business request for a comparison chart. The logic and the analysis intent are the same as in the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch required data
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales, 
       COUNT(orders.OrderID) AS number_of_orders 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY customers.CustomerID
""""""

# Execute the SQL query and fetch the result into a DataFrame
data = execute_sql_query(sql_query)

# Generate a bar chart for comparison
fig = px.bar(data, x='CustomerID', 
             y=['total_sales', 'number_of_orders'], 
             labels={'value':'Amount', 'variable':'Metric'},
             title='Total Sales and Number of Orders per Customer - March 2023',
             barmode='group')

# Display the chart to the user
show_to_user(fig)
```","The provided code correctly implements the business analytics request, adhering to the logic of the reference implementation. Both codes execute an SQL query to calculate total sales and the number of orders for each customer in March 2023. The reference uses DATE_FORMAT() to filter March, while the input code uses a date range filter, but both filters effectively cover March 2023. The results are visualized using a bar chart comparing total sales and order counts for each customer, and the visualization libraries and methods used achieve the same purpose.",both
"How many units have been sold for each product, grouped by supplier, visualized with a stacked bar chart?","```python
import plotly.express as px

# SQL query to retrieve the required data
sql_query = '''
SELECT s.SupplierName, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierName, p.ProductName;
'''

# Execute the SQL query to get the data in a dataframe
df = execute_sql_query(sql_query)

# Create the stacked bar chart using plotly
fig = px.bar(df, x='SupplierName', y='TotalQuantitySold', color='ProductName', 
             title='Units Sold for Each Product by Supplier', 
             labels={'TotalQuantitySold': 'Total Quantity Sold', 'SupplierName': 'Supplier'})

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       p.SupplierID, 
       SUM(od.Quantity) AS TotalUnitsSold
FROM products AS p
JOIN [Order Details] AS od ON p.ProductID = od.ProductID
GROUP BY p.ProductName, p.SupplierID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, 
             x='ProductName', 
             y='TotalUnitsSold', 
             color='SupplierID', 
             title='Units Sold for Each Product Grouped by Supplier',
             labels={'TotalUnitsSold': 'Units Sold', 'ProductName': 'Product'},
             text='TotalUnitsSold')

fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(barmode='stack')

show_to_user(fig)
```","The input code does not group the data by SupplierName like the reference code does. Instead, it groups by SupplierID and ProductName without joining the suppliers table to retrieve the supplier's name. Consequently, the intended grouping by supplier name is not achieved in the stacked bar chart visualization.","
import pandas as pd
import plotly.express as px

# Utility Function Definitions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute SQL queries
    pass

def show_to_user(data):
    # Placeholder function to display data or visualizations
    pass

# SQL Query
sql_query = """"""
SELECT products.ProductID, suppliers.CompanyName, 
       SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details] 
INNER JOIN products ON [Order Details].ProductID = products.ProductID 
INNER JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY products.ProductID, suppliers.CompanyName;
""""""

# Execute SQL Query and get the result as a pandas DataFrame
data_frame = execute_sql_query(sql_query)

# Create a stacked bar chart using Plotly
fig = px.bar(
    data_frame, 
    x='ProductID', 
    y='TotalUnitsSold', 
    color='CompanyName',
    title='Units Sold for Each Product by Supplier',
    labels={'TotalUnitsSold': 'Total Units Sold', 'ProductID': 'Product ID'}
)

# Display the stacked bar chart
show_to_user(fig)
","The input code groups by 'ProductID' and uses 'CompanyName' as the color, which swaps the axes compared to the reference code. The grouping should be by 'SupplierName' and color by 'ProductName' to match the reference implementation. Additionally, the x-axis should be 'SupplierName' to fulfill the business request, not 'ProductID'.",None
Calculate the percentage of orders shipped within 5 days of the order date.,"```python
import pandas as pd

# Execute query to retrieve all orders data
orders_df = execute_sql_query(""SELECT OrderID, OrderDate, ShippedDate FROM orders"")

# Calculate percentage of orders shipped within 5 days
orders_df['DaysDifference'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days
within_5_days = orders_df['DaysDifference'] <= 5
percentage_within_5_days = within_5_days.sum() * 100.0 / len(orders_df)

# Prepare the result as a dataframe
result_df = pd.DataFrame({
    'PercentageWithin5Days': [percentage_within_5_days]
})

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    COUNT(OrderID) AS total_orders,
    COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 5 THEN OrderID END) AS orders_within_5_days
FROM 
    orders
""""""

result_df = execute_sql_query(sql_query)

percentage_within_5_days = (result_df['orders_within_5_days'].iloc[0] / result_df['total_orders'].iloc[0]) * 100

show_to_user(pd.DataFrame({'Percentage of Orders Shipped Within 5 Days': [percentage_within_5_days]}))
```","The input Python code uses an SQL query to directly calculate the total number of orders and the number of orders shipped within 5 days. It then calculates the percentage by dividing the number of orders shipped within 5 days by the total number of orders, which matches the logic of the reference implementation. Both approaches correctly compute the percentage of orders shipped within 5 days, albeit using different methodologies (DataFrame calculations vs. SQL aggregation).","```python
import pandas as pd

# Define the function to execute the SQL query and calculate the percentage
def analyze_order_shipping():
    # SQL query to calculate the number of orders shipped within 5 days
    query_within_5_days = """"""
    SELECT COUNT(OrderID) AS OrdersShippedWithin5Days
    FROM orders
    WHERE DATEDIFF(ShippedDate, OrderDate) <= 5;
    """"""

    # Execute the SQL query and store the result in a DataFrame
    shipped_within_5_days_df = execute_sql_query(query_within_5_days)

    # SQL query to calculate the total number of orders
    query_total_orders = ""SELECT COUNT(OrderID) AS TotalOrders FROM orders;""

    # Execute the SQL query and store the result in a DataFrame
    total_orders_df = execute_sql_query(query_total_orders)

    # Extract the counts from the DataFrames
    shipped_within_5_days = shipped_within_5_days_df.loc[0, 'OrdersShippedWithin5Days']
    total_orders = total_orders_df.loc[0, 'TotalOrders']

    # Calculate the percentage of orders shipped within 5 days
    percentage_shipped_within_5_days = (shipped_within_5_days / total_orders) * 100

    # Create a result DataFrame
    result_df = pd.DataFrame({
        'PercentageShippedWithin5Days': [percentage_shipped_within_5_days]
    })

    # Display the result
    show_to_user(result_df)

# Call the function to perform the analysis
analyze_order_shipping()
```","The input code correctly calculates the percentage of orders shipped within 5 days. It uses SQL queries to count the orders meeting the criteria and the total orders, then computes the percentage in a similar logical flow as the reference implementation. The difference in method (direct computation in SQL vs. DataFrame operations) doesn’t affect correctness.",both
"What is the total quantity ordered across all products by month, with a line chart to show trends?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT MONTH(OrderDate) AS OrderMonth, 
       YEAR(OrderDate) AS OrderYear, 
       SUM(Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
GROUP BY YEAR(OrderDate), MONTH(OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort data by year and month for proper trend visualization
df.sort_values(by=['OrderYear', 'OrderMonth'], inplace=True)

# Concatenate year and month for the x-axis
df['YearMonth'] = df['OrderYear'].astype(str) + '-' + df['OrderMonth'].astype(str)

# Create a line chart using Plotly
fig = px.line(df, x='YearMonth', y='TotalQuantityOrdered', 
              labels={'YearMonth': 'Year-Month', 'TotalQuantityOrdered': 'Total Quantity Ordered'},
              title='Monthly Total Quantity Ordered Across All Products')

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(O.OrderDate, '%Y-%m') AS OrderMonth,
    SUM(OD.Quantity) AS TotalQuantityOrdered
FROM 
    [Order Details] OD
JOIN 
    Orders O ON OD.OrderID = O.OrderID
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='OrderMonth', y='TotalQuantityOrdered', title='Total Quantity Ordered by Month')
show_to_user(fig)
```","The input code correctly calculates the total quantity ordered across all products by month. It uses a SQL query that extracts the year and month from the OrderDate, groups by this month representation, and sums up the quantities. The results are ordered and visualized with a line chart using Plotly, aligning with the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Mock function to simulate executing the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated data
    data = {
        'OrderMonth': [1, 2, 3, 4],
        'TotalQuantityOrdered': [200, 250, 300, 280]
    }
    return pd.DataFrame(data)

# Mock function to simulate showing data to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to execute
sql_query = """"""
SELECT 
    MONTH(OrderDate) AS OrderMonth, 
    SUM(Quantity) AS TotalQuantityOrdered 
FROM orders 
GROUP BY YEAR(OrderDate), MONTH(OrderDate)
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a line chart to show the trend of total quantity ordered by month
fig = px.line(df, x='OrderMonth', y='TotalQuantityOrdered', title='Total Quantity Ordered by Month')

# Show the line chart
show_to_user(fig)
```","The input code does not correctly reflect the reference implementation for two main reasons: 1) It lacks the handling of 'OrderYear' in the SQL query and the final DataFrame, which is crucial for ensuring that the data does not mix months from different years. 2) It does not concatenate the 'OrderYear' and 'OrderMonth' into 'YearMonth' for the x-axis, which is used in the reference to indicate both year and month in the trend line chart.",Base
"Which product has generated the highest revenue, and visualize this with a bar chart?","```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS Revenue
FROM [Order Details]
GROUP BY ProductID
ORDER BY Revenue DESC;
""""""

# Execute the SQL query and get the data in a pandas DataFrame
data_df = execute_sql_query(sql_query)

# Visualize the revenue of each product
fig = px.bar(data_df, x='ProductID', y='Revenue', title='Product Revenue')

# Show the visualization
show_to_user(fig)

# Determine the product with the highest revenue
highest_revenue_product = data_df.iloc[0]
show_to_user(highest_revenue_product)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalRevenue DESC
LIMIT 1
""""""

highest_revenue_product = execute_sql_query(sql_query)

product_id = highest_revenue_product['ProductID'].iloc[0]
total_revenue = highest_revenue_product['TotalRevenue'].iloc[0]

revenue_data = pd.DataFrame({
    'ProductID': [product_id],
    'TotalRevenue': [total_revenue]
})

fig = px.bar(revenue_data, x='ProductID', y='TotalRevenue', title='Highest Revenue Generating Product')
show_to_user(fig)
```","The input Python code fetches only the product with the highest revenue using a SQL query with LIMIT 1, which is different from the reference implementation. The reference implementation retrieves all products' revenues and visually represents them in a bar chart, then identifies the product with the highest revenue. This approach allows for a complete visualization of all products. The input code only visualizes the top product, not adhering to the full logic of retrieving and displaying all products' revenues.","```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = '''
SELECT products.ProductName, 
SUM([Order Details].Quantity * [Order Details].UnitPrice) AS revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY revenue DESC 
LIMIT 1
'''

# Execute the SQL query
top_product_df = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(top_product_df, x='ProductName', y='revenue', 
             title='Product with Highest Revenue')

# Display the figure to the user
show_to_user(fig)
```","The input code computes revenue but only selects the product with the highest revenue due to the use of 'LIMIT 1', rather than generating a bar chart for all products. The reference code calculates revenue for all products, sorts them, and visualizes all in a bar chart. The input code only visualizes the top product, not meeting the full requirement of visualizing revenue for each product.",None
Calculate the average order value for each customer with a bar chart for comparison.,"```python
import plotly.express as px

# SQL query to calculate average order value for each customer
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM customers c 
INNER JOIN orders o ON c.CustomerID = o.CustomerID 
INNER JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using plotly to visualize average order value for each customer
fig = px.bar(df, x='CustomerID', y='AverageOrderValue', title='Average Order Value per Customer')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent,
    COUNT(DISTINCT o.OrderID) AS OrderCount,
    CASE WHEN COUNT(DISTINCT o.OrderID) = 0 THEN 0 ELSE SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) END AS AverageOrderValue
FROM 
    customers c
LEFT JOIN 
    orders o ON c.CustomerID = o.CustomerID
LEFT JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
""""""

customer_avg_order_value = execute_sql_query(sql_query)

fig = px.bar(customer_avg_order_value, 
             x='CompanyName', 
             y='AverageOrderValue', 
             title='Average Order Value for Each Customer', 
             labels={'AverageOrderValue': 'Average Order Value', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The input code uses a LEFT JOIN instead of an INNER JOIN. This causes customers with no orders to be included, potentially resulting in zero average order values for such customers. The reference uses an INNER JOIN which only includes customers with at least one order. This discrepancy affects the logic and results, making the input code incorrect according to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assuming the existence of the utility function:
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing the SQL query and returning results as DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying the data or plot
    pass

# SQL query to fetch the total amount spent by each customer
sql_query = """"""
SELECT Customer.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSpent 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN Customer ON orders.CustomerID = Customer.CustomerID 
GROUP BY Customer.CustomerID
""""""

# Execute the query and get the DataFrame
df = execute_sql_query(sql_query)

# Calculate the average order value for each customer
# Assuming 'TotalSpent' represents the total amount spent by each customer
num_orders_query = """"""
SELECT [Order Details].OrderID, 
       [Order Details].CustomerID, 
       COUNT([Order Details].OrderID) AS OrderCount 
FROM [Order Details] 
GROUP BY [Order Details].OrderID, [Order Details].CustomerID
""""""

# Execute to get number of orders per Customer
order_count_df = execute_sql_query(num_orders_query)

# Group and sum to get total orders per Customer
customer_order_count = order_count_df.groupby('CustomerID')['OrderCount'].sum().reset_index()

# Merge the total spent and order count dataframes to compute average order value
avg_order_value_df = pd.merge(df, customer_order_count, on='CustomerID')
avg_order_value_df['AvgOrderValue'] = avg_order_value_df['TotalSpent'] / avg_order_value_df['OrderCount']

# Create bar chart for average order value
fig = px.bar(avg_order_value_df, x='CustomerID', y='AvgOrderValue', title='Average Order Value per Customer')

# Display the chart
show_to_user(fig)
```","The input code does not correctly calculate the average order value per customer. It calculates the total spent by each customer but attempts to calculate 'OrderCount' incorrectly. The joining of 'Order Details' with 'orders' was not correctly reflected in `num_orders_query`, and it should not have used 'Order Details' for counting orders directly. The correct query should group by Orders and CustomerID and then merge. Additionally, the order count calculation was overly convoluted without the necessary distinct order count per customer. Therefore, the logic of the input code doesn't match the reference implementation.",None
"What is the average lead time for orders delivered by each supplier, visualized with a bar chart?","```python
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID
""""""
data = execute_sql_query(sql_query)

# Create the bar chart
fig = px.bar(data, x='SupplierID', y='avg_lead_time', title='Average Lead Time by Supplier')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time
FROM orders
JOIN products ON orders.OrderID = products.ProductID
GROUP BY products.SupplierID
""""""

lead_time_df = execute_sql_query(sql_query)

fig = px.bar(lead_time_df, x='SupplierID', y='average_lead_time', 
             title='Average Lead Time for Orders by Supplier',
             labels={'average_lead_time': 'Average Lead Time (Days)', 'SupplierID': 'Supplier ID'})
show_to_user(fig)
```","The input code has a mistake in the SQL JOIN between orders and products. In the reference implementation, [Order Details] is explicitly joined to connect orders and products, providing the proper relationship between orders and products. The input code tries to join orders directly with products using their OrderID and ProductID, which is incorrect because they should be joined through the [Order Details] table. This would lead to incorrect results or even a query failure.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, 
             x='CompanyName', 
             y='average_lead_time', 
             title='Average Lead Time for Orders Delivered by Each Supplier', 
             labels={'average_lead_time': 'Average Lead Time (days)', 'CompanyName': 'Supplier Company Name'},
             color='average_lead_time'
            )

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to calculate the average lead time by supplier, similar to the reference implementation. Both codes use a SQL JOIN operation across the same tables (orders, [Order Details], and products) to compute the average lead time. The input code additionally includes the 'suppliers' table to get the CompanyName instead of SupplierID, which still aligns with the question requirement as it provides the average lead time per supplier. Both implementations use Plotly to create a bar chart with the average lead time, satisfying the visualization requirement.",Finetuned
Which suppliers provide products that are currently out of stock?,"```python
import pandas as pd

# SQL query to find suppliers providing out-of-stock products
sql_query = """"""
SELECT s.SupplierName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.UnitsInStock = 0;
""""""

# Execute the SQL query
out_of_stock_suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(out_of_stock_suppliers_df)
```","```python
sql_query = """"""
SELECT DISTINCT p.SupplierID, p.ProductName
FROM products p
WHERE p.UnitsInStock = 0
""""""
out_of_stock_suppliers = execute_sql_query(sql_query)
show_to_user(out_of_stock_suppliers)
```","The input code selects DISTINCT SupplierID and ProductName from the products with zero stock, but it does not join with the suppliers table to get SupplierName. The reference code retrieves SupplierName by joining the suppliers and products tables on SupplierID and filtering products with zero stock.","```python
import pandas as pd

# Define the SQL query to find suppliers with out-of-stock products
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
WHERE products.UnitsInStock = 0;
""""""

# Execute the SQL query using the utility function and get the result as a DataFrame
suppliers_out_of_stock = execute_sql_query(sql_query)

# Display the DataFrame to the user using the provided utility function
show_to_user(suppliers_out_of_stock)
```","The input code selects both SupplierID and CompanyName, whereas the reference code selects only SupplierName. Therefore, the input code outputs different fields and does not match the reference logic.",None
How many units on order are there for each product?,"```python
import pandas as pd

# SQL query
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductID, SUM(UnitsOnOrder) AS TotalUnitsOnOrder
FROM products
GROUP BY ProductID
""""""

units_on_order_df = execute_sql_query(sql_query)
show_to_user(units_on_order_df)
```","The input Python code evaluates the total units on order for each ProductID using aggregation (SUM), while the business request is to display units on order per product without aggregation. The reference code retrieves the 'ProductName' and 'UnitsOnOrder' directly from the table without grouping or summing, which aligns with the business request for individual product details.","```python
# SQL query as provided
sql_query = ""SELECT ProductID, UnitsOnOrder FROM products;""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Using the provided utility function to display the result to the user
show_to_user(df)
```",The input Python code retrieves 'ProductID' and 'UnitsOnOrder' whereas the business request and reference code require 'ProductName' and 'UnitsOnOrder'. The attribute 'ProductID' does not satisfy the requirements.,None
How many units of each product are currently in stock?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT ProductID, ProductName, UnitsInStock FROM products;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0
""""""
units_in_stock_df = execute_sql_query(sql_query)
show_to_user(units_in_stock_df)
```","The input code adds a condition to filter products to only those not discontinued (Discontinued = 0), while the reference code retrieves the stock for all products regardless of their discontinued status. This changes the logic and output of the code, making it incorrect according to the reference implementation.","```python
import pandas as pd

# SQL query to fetch the current stock for each product
sql_query = ""SELECT ProductID, UnitsInStock FROM products;""

# Execute the SQL query and get the result in a DataFrame
stock_data_df = execute_sql_query(sql_query)

# Display the stock data to the user
show_to_user(stock_data_df)
```","The input code correctly queries and retrieves the ProductID and UnitsInStock from the 'products' table, which aligns with the business analytics request of determining how many units of each product are currently in stock. Although it does not include ProductName, the primary requirement is met, and ProductName is not essential to answering the specific business question as stated.",Finetuned
Which product has the highest unit price but lowest sales quantity?,"```python
import pandas as pd

# SQL query to find the product with the highest unit price but lowest sales quantity
sql_query = """"""
SELECT products.ProductID, products.ProductName 
FROM products 
WHERE products.UnitPrice = (SELECT MAX(products.UnitPrice) FROM products) 
AND products.ProductID NOT IN (
    SELECT ProductID 
    FROM [Order Details] 
    WHERE Quantity > 0
)
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, [Order Details].UnitPrice, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductID, products.ProductName, [Order Details].UnitPrice
ORDER BY [Order Details].UnitPrice DESC, total_quantity ASC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code does not correctly implement the logic from the reference implementation. The reference aims to find a product with the highest unit price that has no sales (Quantity = 0). However, the input code sorts by descending unit price and ascending total quantity, selecting the first entry without ensuring the sales quantity is zero. This could return a product with sales, as it checks for lowest sales among those with highest prices rather than checking for zero sales.","```python
# SQL Query to get the product with the highest unit price but lowest sales quantity
sql_query = """"""
SELECT p.ProductID, p.UnitPrice, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.UnitPrice
ORDER BY p.UnitPrice DESC, TotalSales ASC
LIMIT 1;
""""""

# Executing the SQL query and getting the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Displaying the result to the user
show_to_user(result_df)
```","The reference code selects products with the highest unit price and checks for zero sales quantity using a subquery to exclude products with any orders. The input code, however, aggregates sales quantities and orders products by descending unit price and ascending total sales, returning only one product. This may not ensure zero sales quantity and might select a product with minimal but non-zero sales, thus not adhering to the logic of the reference code.",None
Which product had the highest sales in terms of quantity in March 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
    SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
    GROUP BY products.ProductName 
    ORDER BY total_quantity DESC 
    LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductID
ORDER BY total_quantity DESC
LIMIT 1
""""""

highest_sales_product = execute_sql_query(sql_query)
show_to_user(highest_sales_product)
```","The input code queries 'ProductID' instead of 'ProductName', which does not directly fulfill the business request of identifying the product with the highest sales. The reference implementation correctly lists 'ProductName', which is more informative for business analysis.","```python
import pandas as pd

# SQL query to find the product with the highest sales in March 2023
sql_query = """"""
SELECT p.ProductID, 
       SUM(od.Quantity) AS TotalQuantity 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
JOIN orders o 
ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY p.ProductID 
ORDER BY TotalQuantity DESC 
LIMIT 1;
""""""

# Execute the query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code selects 'ProductID' instead of 'ProductName'. The reference code selects and groups by 'ProductName', ensuring the result includes the name of the product with the highest sales. Thus, the input code does not fully meet the business analytics request.",None
What is the total sales generated by each employee for the past year?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)
```","```python
import pandas as pd

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATEADD(year, -1, GETDATE())
GROUP BY e.EmployeeID, EmployeeName
ORDER BY TotalSales DESC
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The input code is correct. It calculates total sales per employee over the past year, matching the logic of the reference code. Field CONCAT is used for full names, and the date filtering is equivalent (DATEADD and GETDATE in SQL Server vs. DATE_SUB and CURDATE in MySQL). Additional ordering by TotalSales doesn't affect correctness.","```python
import pandas as pd

# Sample function definitions (assume these are pre-defined in your environment)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function execution
    pass

def to_user(data: pd.DataFrame):
    # Simulated function to display data
    pass

# SQL query
sql_query = """"""
SELECT S.EmployeeID, 
       SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales 
FROM orders AS O 
JOIN [Order Details] AS OD ON O.OrderID = OD.OrderID 
JOIN employees AS S ON O.EmployeeID = S.EmployeeID 
WHERE O.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE() 
GROUP BY S.FirstName, S.LastName, S.EmployeeID;
""""""

# Execute the query and store the results
df = execute_sql_query(sql_query)

# Display the results to the user
to_user(df)
```","The input code correctly calculates the total sales by each employee for the past year. It uses SQL to join the orders and order details tables based on OrderID and the employees table based on EmployeeID. It calculates the total sales using the formula (UnitPrice * Quantity * (1 - Discount)) and groups the results by EmployeeID. The logic matches the reference implementation, with slight syntax differences like the use of ALIAS names (S, O, OD) and grouping by EmployeeID only. The WHERE clause also effectively restricts the date range to the past year.",both
Visualize the average number of days between order placement and order shipping by customer.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageDaysToShip
FROM orders
GROUP BY CustomerID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average days to ship by customer
fig = px.bar(data, x='CustomerID', y='AverageDaysToShip', 
             title='Average Days to Ship by Customer',
             labels={'CustomerID': 'Customer ID', 'AverageDaysToShip': 'Average Days to Ship'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    CustomerID,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgDaysToShip
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    CustomerID
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='CustomerID', y='AvgDaysToShip', title='Average Days Between Order Placement and Shipping by Customer', labels={'AvgDaysToShip': 'Average Days to Ship', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```","The input Python code accurately implements the requested business analytics task. It computes the average number of days between order placement and shipping per customer. Both the input and reference codes utilize SQL queries with similar logic, including selecting CustomerID, computing average days using AVG(DATEDIFF(ShippedDate, OrderDate)), and grouping by CustomerID. The only notable difference is the addition of a WHERE clause in the input code to exclude null ShippedDate entries, which is reasonable for ensuring data quality. The visualization aspect using Plotly Express to create a bar chart is consistent between both implementations, with slight differences in the title wording that do not affect the underlying logic or correctness of the task.","```python
import pandas as pd
import plotly.express as px

# Simulating the utility function to execute SQL
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the actual function that would execute the SQL and return a DataFrame
    pass

# Simulating the utility function to display a Plotly figure
def show_to_user(fig):
    # Displays the Plotly figure
    fig.show()

# SQL query to get the average days between order and shipment by customer
sql_query = """"""
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgDays
FROM orders
GROUP BY CustomerID;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar plot to visualize the average days between order and shipment by customer
fig = px.bar(df, x='CustomerID', y='AvgDays',
             title='Average Days Between Order Placement and Shipping by Customer',
             labels={'AvgDays': 'Average Days', 'CustomerID': 'Customer ID'},
             hover_data=['AvgDays'])

# Display the plot using the utility function
show_to_user(fig)
```","The input code correctly executes a SQL query to calculate the average days between order placement and shipping by customer, similar to the reference implementation. It also uses Plotly to create a bar chart and displays it, just like the reference code. The differences in variable names like 'AvgDays' instead of 'AverageDaysToShip' and a slightly different plot title are acceptable variations that do not alter the logic or the correctness of the implementation.",both
Visualize the total sales revenue generated by each product category in the last year.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by product
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY ProductID;
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Assuming we have a separate table to get ProductID to Category mapping
product_category_query = """"""
SELECT ProductID, CategoryName 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID;
""""""
product_category_data = execute_sql_query(product_category_query)

# Merge the data to include CategoryName
merged_data = pd.merge(data, product_category_data, on='ProductID')

# Calculate total sales by Category
category_sales = merged_data.groupby('CategoryName', as_index=False)['TotalSales'].sum()

# Visualize using plotly
fig = px.bar(category_sales, x='CategoryName', y='TotalSales', title='Total Sales Revenue by Product Category in Last Year')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    o.OrderDate >= DATEADD(year, -1, GETDATE())
GROUP BY 
    p.CategoryID
""""""

total_sales = execute_sql_query(sql_query)

fig = px.bar(total_sales, x='CategoryID', y='TotalRevenue', title='Total Sales Revenue by Product Category (Last Year)', labels={'CategoryID': 'Product Category', 'TotalRevenue': 'Total Revenue'})
show_to_user(fig)
```","The input code does not join with a table to map CategoryID to CategoryName, resulting in a visualization that uses CategoryID instead of CategoryName. The reference implementation includes a step to join category information to produce more user-friendly visualizations with category names, which is missing in the input code.","```python
import pandas as pd
import plotly.express as px

# SQL query to extract total sales revenue by product category for the last year
sql_query = """"""
SELECT ProductCategory, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSalesRevenue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY ProductCategory;
""""""

# Execute the SQL query and get the result as a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total sales revenue by product category
fig = px.bar(sales_data, 
             x='ProductCategory', 
             y='TotalSalesRevenue',
             title='Total Sales Revenue by Product Category in the Last Year',
             labels={'TotalSalesRevenue': 'Total Sales Revenue', 'ProductCategory': 'Product Category'})

# Display the visualization to the user
show_to_user(fig)
```","The input code directly uses 'ProductCategory' in the SQL query, suggesting that the base data already contains category information during aggregation. The reference implementation separates the product sales calculation and category mapping, indicating the data structure might not inherently include 'ProductCategory' with sales data. The reference merges product IDs with category names after getting the sales data, while the input code assumes this mapping is already in place before or during aggregation.",None
Identify suppliers that have not supplied any products in the last year.,"```python
import pandas as pd

# SQL query to identify suppliers not active in last year
sql_query = """"""
SELECT suppliers.CompanyName 
FROM suppliers 
LEFT JOIN (
    SELECT products.SupplierID, COUNT(*) AS ProductCount 
    FROM products 
    JOIN ""Order Details"" ON products.ProductID = ""Order Details"".ProductID 
    JOIN orders ON ""Order Details"".OrderID = orders.OrderID 
    WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY products.SupplierID
) AS recent_products 
ON suppliers.SupplierID = recent_products.SupplierID 
WHERE recent_products.ProductCount IS NULL;
""""""

# Execute the query
inactive_suppliers_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(inactive_suppliers_df)
```","```python
from datetime import datetime, timedelta

# Define the cutoff date for the last year
cutoff_date = datetime.now() - timedelta(days=365)

# Create the SQL query to identify suppliers who have not supplied any products in the last year
sql_query = f""""""
SELECT s.SupplierID, s.CompanyName
FROM suppliers s
LEFT JOIN products p ON s.SupplierID = p.SupplierID
LEFT JOIN orders o ON p.ProductID = o.OrderID
WHERE o.OrderDate IS NULL OR o.OrderDate < '{cutoff_date.strftime('%Y-%m-%d')}'
GROUP BY s.SupplierID, s.CompanyName
ORDER BY s.CompanyName;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input code is incorrect. It joins 'orders' on 'products.ProductID' with 'orders.OrderID', which is incorrect as 'orders' should be joined through 'Order Details'. It should filter out suppliers with no products ordered in the last year using a subquery left joined on suppliers, similar to the reference implementation.","```python
import pandas as pd
from datetime import datetime, timedelta

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function body
    # Implement SQL execution logic here
    # Returning an empty DataFrame for demonstration
    return pd.DataFrame()

# Function to display the result to the user
def show_to_user(data: pd.DataFrame) -> None:
    if not data.empty:
        print(data.to_string(index=False))
    else:
        print(""No data to display."")

# SQL query definition
one_year_ago_date = (datetime.now() - timedelta(days=365)).date()

# Execute the query to get suppliers who haven't supplied products in the last year
sql_query = f""""""
SELECT s.SupplierID, s.CompanyName
FROM suppliers s
LEFT JOIN products p ON s.SupplierID = p.SupplierID
LEFT JOIN products_orders po ON p.ProductID = po.ProductID
WHERE MAX(po.OrderDate) < '{one_year_ago_date}'
GROUP BY s.SupplierID, s.CompanyName;
""""""

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(supplier_data)
```","The input code uses an incorrect logic for identifying suppliers that have not supplied any products in the last year. It attempts to use a MAX() function in a WHERE clause, which is not valid SQL syntax. Additionally, the input code tries to join directly on individual product orders without verifying if they are part of an 'Order Details' relationship as in the reference code. In contrast, the reference code correctly uses a LEFT JOIN with a subquery that counts products supplied in the last year and filters for suppliers with a NULL count, indicating no activity. Therefore, the input code does not align with the logic and SQL structure of the reference implementation.",None
Which products have stock levels below their reorder level?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
products_below_reorder_level = execute_sql_query(sql_query)
show_to_user(products_below_reorder_level)
```","The input code includes an additional condition 'Discontinued = 0', which is not present in the reference implementation. This condition filters out products that are discontinued, altering the logic and scope of the query compared to the reference code.","```python
# Execute SQL query to retrieve products with stock below reorder level
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""
low_stock_products = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(low_stock_products)
```","The input code correctly executes an SQL query to select products where the stock is below the reorder level. The only difference from the reference code is that it does not select 'ProductID', but the business request only asks for product names, which the input code fulfills. Therefore, it adheres to the same logical outcome as the reference code.",Finetuned
How many units of each product are currently on order?,"```python
import pandas as pd

# SQL query to get units on order for each product
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products;""

# Execute SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductName, UnitsOnOrder
FROM products
WHERE UnitsOnOrder > 0
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code filters products based on 'UnitsOnOrder > 0', meaning it excludes products with zero units on order. The request was to report current units on order for each product, which implies including those with zero units. The reference code selects all products, regardless of 'UnitsOnOrder' being greater than zero, which matches the request more accurately.","```python
# SQL query to fetch the units of each product currently on order
sql_query = """"""
SELECT ProductID, UnitsOnOrder FROM products;
""""""

# Execute the SQL query and store the result in a DataFrame
products_on_order_df = execute_sql_query(sql_query)

# Display the DataFrame to the user
show_to_user(products_on_order_df)
```","The input code queries 'ProductID' instead of 'ProductName'. The business analytics request asks for product names (ProductName), aligning with the reference implementation. The logic should mirror the reference code's emphasis on 'ProductName' to be considered correct.",None
What is the monthly sales trend for each product over the last year?,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM') AS Month, 
SUM([Order Details].Quantity) AS MonthlySales
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
WHERE [Order Details].OrderDate >= DATEADD(year, -1, GETDATE()) 
GROUP BY products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM');
""""""

# Execute the query and retrieve data as a dataframe
df = execute_sql_query(sql_query)

# Sort the dataframe by Month to ensure the trend line is accurate
df = df.sort_values(by='Month')

# Create a line plot for the monthly sales trend of each product
fig = px.line(df, x='Month', y='MonthlySales', color='ProductID', title='Monthly Sales Trend for Each Product')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    p.ProductID, Month
ORDER BY 
    p.ProductID, Month;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='Month', y='TotalSales', color='ProductName', title='Monthly Sales Trend for Each Product Over the Last Year')
show_to_user(fig)
```","The input code calculates 'TotalSales' using quantity, unit price, and discount, whereas the reference code calculates 'MonthlySales' using only the quantity. Thus, the logic and metrics differ. Moreover, the input code includes 'ProductName' for the line plot, which is not handled similarly in the reference implementation.","```python
import pandas as pd

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function to execute SQL and return a DataFrame
    pass  # Replace with actual implementation

# Function to display the data
def show_to_user(data):
    # Mock function to display data
    pass  # Replace with actual implementation

# Define the SQL query
sql_query = """"""
SELECT YEAR(o.OrderDate) AS Year, MONTH(o.OrderDate) AS Month, 
       p.ProductID, p.ProductName, 
       SUM(od.Quantity) AS MonthlySales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY YEAR(o.OrderDate), MONTH(o.OrderDate), p.ProductID, p.ProductName 
ORDER BY p.ProductID, CONCAT(YEAR(o.OrderDate), '-', LPAD(MONTH(o.OrderDate), 2, '0'));
""""""

# Execute the SQL query and get the result as a DataFrame
data = execute_sql_query(sql_query)

# Display the resulting DataFrame to the user
show_to_user(data)
```","The input code does not create a line plot, which is a key part of the business request for visualizing the monthly sales trend. Unlike the reference code, the input code displays the raw data directly without generating any visualization to depict trends. Additionally, the input SQL query groups by both ProductID and ProductName without aggregating them, which differs from the reference implementation.",None
Find the average discount provided per order.,"```python
import pandas as pd

# SQL query to get order discounts
sql_query = ""SELECT Discount FROM [Order Details];""

# Execute the SQL query
order_details_df = execute_sql_query(sql_query)

# Calculate the average discount per order
avg_discount = order_details_df['Discount'].mean()

# Prepare the result in a DataFrame for display
result_df = pd.DataFrame({'AvgDiscount': [avg_discount]})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
""""""

average_discount_df = execute_sql_query(sql_query)
show_to_user(average_discount_df)
```","The input code and the reference code both correctly calculate the average discount per order. The input code directly utilizes SQL to compute the average using AVG(Discount), which simplifies the process compared to retrieving all discounts and then calculating the mean in Python like the reference implementation. Both methods adhere to the logic of finding the average discount and generating the correct result.","```python
import pandas as pd

# Assuming the execute_sql_query and display_dataframe functions are predefined

# SQL query to fetch the required data
sql_query = """"""
SELECT AVG(Discount) AS AvgDiscount
FROM [Order Details]
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
display_dataframe(result_df)
```","The input code and the reference implementation both calculate the average discount per order. The input code achieves this by using an SQL query to calculate the average directly in the database, which is an efficient method. The reference implementation calculates the average after fetching the data into a DataFrame. Both approaches provide the same result, so the input code is correct.",both
Visualize the average quantity per unit for products supplied by each supplier.,"```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT s.SupplierID, s.SupplierName, AVG(CAST(p.QuantityPerUnit AS DECIMAL)) AS AverageQuantityPerUnit
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.SupplierName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(df, x='SupplierName', y='AverageQuantityPerUnit',
             title='Average Quantity Per Unit by Supplier',
             labels={'AverageQuantityPerUnit': 'Average Quantity Per Unit', 'SupplierName': 'Supplier Name'})

# Show to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(CAST(p.QuantityPerUnit AS FLOAT)) AS AverageQuantityPerUnit
FROM products p
GROUP BY p.SupplierID
""""""

average_quantity_df = execute_sql_query(sql_query)

fig = px.bar(average_quantity_df, x='SupplierID', y='AverageQuantityPerUnit',
             title='Average Quantity Per Unit by Supplier',
             labels={'SupplierID': 'Supplier ID', 'AverageQuantityPerUnit': 'Average Quantity Per Unit'})

show_to_user(fig)
```","The input code does not include the supplier name in the query and visualization, which is a part of the business request. Unlike the reference, it groups only by SupplierID and does not join the suppliers table to get the SupplierName. Therefore, it does not fully adhere to the business analytics request of visualizing average quantities per supplier via SupplierName.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function simulates the execution of an SQL query 
    # and returns a DataFrame
    # In an actual environment, this would connect to a database and execute the query
    # Here, we will just create a DataFrame with dummy data for demonstration
    data = {
        'SupplierID': [1, 2, 3],
        'AverageQuantityPerUnit': [5.6, 7.3, 4.5]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This function assumes that the provided data is either a Plotly figure or a DataFrame
    # Here, we'll just print the DataFrame for demonstration
    print(data)

# SQL query
sql_query = ""SELECT SupplierID, AVG(CAST(SUBSTRING_INDEX(QuantityPerUnit, ' ', 1) AS DECIMAL)) AS AverageQuantityPerUnit FROM products GROUP BY SupplierID;""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar plot using Plotly
fig = px.bar(
    df,
    x='SupplierID',
    y='AverageQuantityPerUnit',
    title='Average Quantity Per Unit by Supplier',
    labels={'AverageQuantityPerUnit': 'Average Quantity Per Unit', 'SupplierID': 'Supplier ID'}
)

# Display the plot
show_to_user(fig)
```","The input code does not match the referenced business logic. The SQL query in the input code does not properly join the suppliers and products tables, which means it lacks the SupplierName in the output, deviating from the reference. Consequently, the plot is based on SupplierID rather than SupplierName, which does not adhere to the specified analytics request.",None
Visualize the average shipping cost per order for the current year.,"```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# SQL query to get the average shipping cost per order for the current year
sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order 
FROM orders 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE())
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a DataFrame to use for plotting
current_year = datetime.now().year
plot_df = pd.DataFrame({
    'Year': [current_year],
    'Average Shipping Cost': df['shipping_cost_per_order']
})

# Visualize the result
fig = px.bar(plot_df, x='Year', y='Average Shipping Cost',
             labels={'Year': 'Year', 'Average Shipping Cost': 'Average Shipping Cost'},
             title='Average Shipping Cost Per Order for the Current Year')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT AVG(orders.Freight) AS average_shipping_cost
FROM orders
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE)
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data_frame=data, x=['average_shipping_cost'], y=data['average_shipping_cost'], title=""Average Shipping Cost per Order for Current Year"", labels={'y':'Average Shipping Cost', 'x':''})
show_to_user(fig)
```","Both implementations calculate the average shipping cost per order for the current year using a SQL query to the 'orders' table, focusing on the 'Freight' column and filtering by the 'OrderDate'. The input Python code uses 'CURRENT_DATE', which is equivalent to 'CURDATE()' in SQL for the reference implementation. Both implementations then visualize the average shipping cost using Plotly Express, although the configurations differ slightly (e.g., the way data is structured for plotting). Nonetheless, the core logic aligns with the reference implementation's intent.","```python
import pandas as pd
import plotly.express as px

# Given SQL query to fetch data from the database.
sql_query = """"""
SELECT orders.OrderID, orders.ShippedDate, orders.ShipVia, AVG(orders.Freight) AS AvgShippingCost
FROM orders
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE())
GROUP BY orders.OrderID, orders.ShippedDate, orders.ShipVia;
""""""

# Read the data into a DataFrame
df_orders = read_sql_query(sql_query)

# Create a line plot to visualize the average shipping cost per order
fig = px.line(
    df_orders, 
    x='OrderID', 
    y='AvgShippingCost', 
    title='Average Shipping Cost per Order for the Current Year',
    labels={'AvgShippingCost': 'Average Shipping Cost', 'OrderID': 'Order ID'},
    markers=True
)

# Display the plot
show_to_user(fig)
```","The input code calculates the average shipping cost for each order and plots this using a line chart with OrderID on the x-axis. However, the business request is to visualize the overall average shipping cost per order for the entire current year, not individual averages per order. The reference implementation calculates the global average and represents it in a bar chart, which aligns with the original request.",Base
Visualize the top 3 regions by total sales revenue.,"```python
import plotly.express as px

# SQL query to retrieve the top 3 regions by total sales revenue
sql_query = """"""
SELECT customers.Region, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSalesRevenue 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.Region 
ORDER BY TotalSalesRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Visualize the data using plotly
fig = px.bar(df, x='Region', y='TotalSalesRevenue', title='Top 3 Regions by Total Sales Revenue')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
ORDER BY TotalSales DESC
LIMIT 3;
""""""

top_regions = execute_sql_query(sql_query)
fig = px.bar(top_regions, x='Region', y='TotalSales', title='Top 3 Regions by Total Sales Revenue')
show_to_user(fig)
```","The input Python code correctly executes a SQL query to retrieve the top 3 regions by total sales revenue and visualizes the data using Plotly, just like the reference implementation. Both implementations join the same tables, perform identical calculations for total sales, and order the results to get the top 3 regions. The differences in variable naming do not affect the correctness.","```python
import pandas as pd
import plotly.express as px

# SQL query to get top 3 regions by total sales revenue
sql_query = """"""
SELECT [RegionID], SUM([Sales]) AS [TotalSales]
FROM [orders]
JOIN [employees] ON [orders].[EmployeeID] = [employees].[EmployeeID]
JOIN [regions] ON [employees].[RegionID] = [regions].[RegionID]
GROUP BY [RegionID]
ORDER BY TotalSales DESC
LIMIT 3
""""""

# Execute SQL query and get result as a DataFrame
top_regions_df = execute_sql_query(sql_query)

# Visualize the results using Plotly
fig = px.bar(
    top_regions_df, 
    x='RegionID', 
    y='TotalSales',
    title='Top 3 Regions by Total Sales Revenue',
    labels={'TotalSales': 'Total Sales Revenue'}
)

# Show the visualization
show_to_user(fig)
```","The provided code does not adhere to the reference implementation's logic with respect to the business analytics request. The reference implementation aggregates sales revenue based on 'Region' using a SQL query that stems from 'customers', 'orders', and 'Order Details'. The input code uses 'RegionID' from joins on 'orders', 'employees', and 'regions', but there is no direct mention of calculating sales revenue from unit price, quantity, and discount as in the reference. Additionally, it groups by 'RegionID' instead of 'Region', and appears to rely on a non-comparable schema.",Base
Visualize how many orders were placed each month.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY OrderMonth;
""""""

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders placed each month
fig = px.bar(df, x='OrderMonth', y='TotalOrders', title='Monthly Orders Count', labels={'OrderMonth': 'Order Month', 'TotalOrders': 'Total Orders'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

order_data = execute_sql_query(sql_query)
fig = px.line(order_data, x='OrderMonth', y='OrderCount', title='Monthly Orders Count', labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input code correctly visualizes how many orders were placed each month. It uses a SQL query to retrieve the monthly order data, grouped by month, which matches the logic of the reference implementation. Although the input uses a line chart instead of a bar chart, it still fulfills the business requirement by showing the monthly order trend. The main difference is the type of chart used, which does not affect the correctness regarding the business request.","```python
import pandas as pd
import plotly.express as px

# Reusable function definitions (placeholders)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulate the execution of an SQL query and return a DataFrame
    data = {
        'Month': pd.date_range(start='2020-01-01', periods=12, freq='M'),
        '# of Orders': [100, 120, 110, 140, 160, 150, 170, 180, 175, 200, 210, 220]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to fetch the number of orders placed each month
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS '# of Orders' 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query and obtain the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a line chart to visualize the number of orders placed each month
fig = px.line(
    df,
    x='Month',
    y='# of Orders',
    title='Monthly Orders',
    labels={'# of Orders': 'Number of Orders'},
    markers=True
)

# Display the line chart to the user
show_to_user(fig)
```","The input code uses a line chart for visualization instead of a bar chart as specified in the reference code and business request. The business request specifies a bar chart to show how many orders were placed each month, while the input code produces a line chart, which is not aligned with the reference implementation.",Base
Which product has the highest cumulative discount in terms of dollar value?,"```python
# Define the SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Discount * od.UnitPrice * od.Quantity) AS TotalDiscount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalDiscount DESC LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.Discount) AS CumulativeDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY CumulativeDiscount DESC
LIMIT 1;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code incorrectly calculates the cumulative discount by not factoring in the UnitPrice. The correct calculation for cumulative discount should include (Discount * UnitPrice * Quantity) as shown in the reference code. The input code only multiplies Discount and Quantity, which doesn't align with the reference logic.","```python
# Import necessary modules
import pandas as pd

# Given SQL query
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * od.Discount) AS CumulativeDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY CumulativeDiscount DESC 
LIMIT 1
""""""

# Execute the SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the product with the highest cumulative discount
show_to_user(result_df)
```","The input code achieves the same objective as the reference by calculating cumulative discounts in dollar value per product and retrieving the product with the highest cumulative discount. Both codes utilize similar SQL logic to calculate and sort by total discount, properly limiting the results to one product. The difference in column naming does not impact the correctness of the logic applied.",Finetuned
How many different suppliers are there?,"```python
import pandas as pd

# SQL Query
sql_query = ""SELECT COUNT(DISTINCT SupplierID) as distinct_suppliers FROM products;""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Extract the count from the dataframe and display
distinct_suppliers_count = result_df['distinct_suppliers'][0]
show_to_user(pd.DataFrame({'Distinct Suppliers Count': [distinct_suppliers_count]}))
```","```python
sql_query = ""SELECT COUNT(DISTINCT SupplierID) AS UniqueSuppliers FROM products""
unique_suppliers_df = execute_sql_query(sql_query)
show_to_user(unique_suppliers_df)
```","The input code correctly performs the task of counting the distinct suppliers using an SQL query with COUNT(DISTINCT SupplierID). The difference is in naming the field as 'UniqueSuppliers' instead of 'distinct_suppliers', which does not affect the result's correctness. Both implementations execute the query and display the output using 'show_to_user'.","```python
import pandas as pd

# SQL query to count distinct suppliers
sql_query = ""SELECT COUNT(DISTINCT suppliers.SupplierID) FROM suppliers;""

# Execute the SQL query using the provided utility function
distinct_suppliers_count = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(distinct_suppliers_count)
```","Both the input and reference codes execute SQL queries to count the distinct number of suppliers. The main difference is that the reference code targets a 'products' table assuming a SupplierID is present there, while the input code directly queries the 'suppliers' table. As long as 'suppliers.SupplierID' accurately represents distinct suppliers, the logic remains consistent with the business request.",both
Visualize the correlation between freight cost and fulfillment time.,"```python
import plotly.express as px

# SQL query
sql_query = ""SELECT Freight, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders;""

# Execute the query and retrieve data
df = execute_sql_query(sql_query)

# Create a scatter plot to visualize the correlation
fig = px.scatter(df, x='Freight', y='FulfillmentTime', 
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (days)'})

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS FulfillmentTime,
    AVG(Freight) AS FreightCost
FROM 
    orders
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m')
""""""

data = execute_sql_query(sql_query)

fig = px.scatter(data_frame=data, 
                 x='FreightCost', 
                 y='FulfillmentTime', 
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'FreightCost': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (Days)'})

show_to_user(fig)
```","The input code calculates average fulfillment time and freight cost by month and plots these aggregated averages, whereas the reference code plots each individual order's values. This means the input code does not directly visualize the correlation as intended for individual orders as per the business analytics request.","```python
# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT orders.Freight, orders.ShippedDate - orders.OrderDate AS FulfillmentTime 
FROM orders;
""""""

# Execute the query and store the results in a DataFrame, assuming execute_sql_query is predefined
df = execute_sql_query(sql_query)

# Create a scatter plot to visualize the correlation between Freight and FulfillmentTime
fig = px.scatter(df, x='Freight', y='FulfillmentTime', 
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (Days)'})

# Display the visualization, assuming show_to_user is predefined
show_to_user(fig)
```","The input code correctly executes an SQL query to retrieve Freight and FulfillmentTime from the orders table, calculates the difference between ShippedDate and OrderDate, and visualizes the data using a scatter plot. Although there is a slight difference in calculating the date difference directly in the query rather than using DATEDIFF, the logic and outcome are consistent with the reference implementation.",Finetuned
Which employee made the highest sales on a specific date?,"```python
from datetime import datetime
import pandas as pd

# Define the date for which we want to find the highest sales
target_date = 'YYYY-MM-DD'

# SQL query to find the employee with the highest sales on the specific date
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate = '{target_date}' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC LIMIT 1;
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
import pandas as pd

# Define the specific date for the sales analysis
specific_date = '2023-10-05'

# SQL query to find the employee with the highest sales on the specific date
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate = '{specific_date}'
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input code correctly follows the logic of the reference implementation. It sets a specific date for the sales analysis, constructs an SQL query to find the employee with the highest sales on that date, executes the query, and displays the result. The only differences are the specific date value and some minor formatting, both of which do not affect the correctness of the implementation.","```python
import pandas as pd

# Define the SQL query with a placeholder for the date
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate = '{specific_date}' 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC
""""""

# Function to execute the SQL query and display the top employee
def find_top_sales_employee(specific_date: str):
    # Format the SQL query with the given date
    formatted_query = sql_query.format(specific_date=specific_date)
    
    # Execute the query and get the results as a DataFrame
    sales_data = execute_sql_query(formatted_query)
    
    # Display the top employee
    if not sales_data.empty:
        top_employee = sales_data.iloc[0]
        show_to_user(pd.DataFrame([top_employee]))
    else:
        show_to_user(pd.DataFrame(columns=['EmployeeID', 'TotalSales']))

# Example usage
find_top_sales_employee('2021-09-15')
```","The input code achieves the same goal as the reference implementation. Both codes execute a query to calculate total sales for each employee on a specified date and return the employee with the highest sales. Although the input code uses a slightly different method to handle data (formatting the query and extracting the top row), it adheres to the same logic and provides the correct answer by ordering the results in descending order and selecting the first entry. Thus, it is considered correct.",both
What is the average unit price of products in each category? (Consider visualizing the average unit prices by category using a bar chart for easier comparison.),"```python
import plotly.express as px

# SQL query to execute
sql_query = ""SELECT CategoryID, AVG(UnitPrice) AS AveragePrice FROM products GROUP BY CategoryID;""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit prices by category
fig = px.bar(df, x='CategoryID', y='AveragePrice', title='Average Unit Price by Category')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AvgUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_unit_prices = execute_sql_query(sql_query)

fig = px.bar(average_unit_prices, x='CategoryID', y='AvgUnitPrice', 
             title='Average Unit Price by Category', 
             labels={'CategoryID': 'Category ID', 'AvgUnitPrice': 'Average Unit Price'})
show_to_user(fig)
```","The provided Python code correctly executes the task of calculating average unit prices by category and visualizes the data using a bar chart. It follows the same logical approach as the reference code: executing an SQL query to obtain average prices grouped by CategoryID, and then using Plotly Express to create and display a bar chart. The differences in variable names and minor query formatting do not affect the correctness of the solution.","
import pandas as pd
import plotly.express as px

# Assuming the definitions of `execute_sql_query` and `show_to_user` are available

# Given SQL query
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AvgUnitPrice FROM products GROUP BY CategoryID;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for better comparison of average unit prices by category
fig = px.bar(df, x='CategoryID', y='AvgUnitPrice',
             title='Average Unit Price by Category',
             labels={'CategoryID': 'Category ID', 'AvgUnitPrice': 'Average Unit Price'})

# Display the visualization to the user
show_to_user(fig)
","The input Python code meets the business analytics request. It performs the same SQL query as the reference to calculate the average unit price by category, groups the result by CategoryID, and visualizes the data using a bar chart. The difference in the naming of 'AvgUnitPrice' instead of 'AveragePrice' in the SQL and DataFrame doesn't affect the logical correctness. Additionally, customization of labels in the visualization does not impact the correctness of the solution.",both
Which product had the highest sales revenue in 2022?,"```python
import pandas as pd

# SQL query to find the product with highest sales revenue in 2022
sql_query = """"""
SELECT products.ProductID, 
       products.ProductName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, products.ProductName
ORDER BY product_sales DESC 
LIMIT 1
""""""

# Execute the SQL query and retrieve the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE YEAR(orders.OrderDate) = 2022
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 1
""""""

highest_sales_product = execute_sql_query(sql_query)
show_to_user(highest_sales_product)
```","Both implementations aim to determine the product with the highest sales revenue in 2022. The logic and SQL queries are equivalent: they join the 'Order Details', 'orders', and 'products' tables; calculate total sales revenue considering price, quantity, and discount; filter data for the year 2022; group by product; and order by total sales descending, limiting to the top result. The input code uses a different method to specify the date range (YEAR function) but effectively achieves the same result.","```python
# Utility Functions
def execute_sql_query(sql_query: str):
    # Placeholder for executing an SQL query and fetching a DataFrame
    # Implementation details would go here
    pass

def show_to_user(data):
    # Placeholder for showing DataFrame or result to the user
    # Implementation details would go here
    pass

# SQL query to fetch the product with the highest sales revenue in 2022
sql_query = """"""
SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue
FROM [Order Details]
WHERE OrderID IN (
    SELECT OrderID
    FROM orders
    WHERE YEAR(OrderDate) = 2022
)
GROUP BY ProductID
ORDER BY TotalRevenue DESC
LIMIT 1;
""""""

# Execute the query and get the result DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input code does not consider discounts on the order details when calculating the total revenue. The reference code multiplies 'UnitPrice', 'Quantity', and accounts for 'Discount' to compute 'product_sales'. The input code should also incorporate discounts to match the logic of the reference implementation.",Base
How many orders have been placed by each customer? (A bar chart can be used to visualize the number of orders per customer.),"```python
import plotly.express as px

# SQL query to get the order count per customer
sql_query = ""SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Creating a bar chart using plotly
fig = px.bar(orders_df, x='CustomerID', y='OrderCount', title='Number of Orders per Customer')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) as OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
""""""

order_counts = execute_sql_query(sql_query)

fig = px.bar(order_counts, x='CustomerID', y='OrderCount', title='Number of Orders per Customer', labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```","The input code correctly fulfills the business analytics request. It uses a SQL query to count the number of orders per customer, groups the results by CustomerID, and orders them by OrderCount, which does not affect the correctness. It then visualizes the results in a bar chart using Plotly, adhering to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the number of orders per customer
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS total_orders
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query and get the result as a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    orders_df,
    x='CustomerID',
    y='total_orders',
    labels={'CustomerID': 'Customer ID', 'total_orders': 'Total Orders'},
    title='Number of Orders per Customer'
)

# Visualize the results
show_to_user(fig)
```","The input code is correct as it successfully achieves the same outcome as the reference implementation: it calculates and visualizes the number of orders placed by each customer. The differences, such as joining the 'customers' table, don't impact correctness as all necessary data is retrieved, and the logic aligns with the reference.",both
Which employee generated the most sales in Q4 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 1
""""""

# Execute the SQL query using the utility function
sales_data_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(sales_data_df)
```","```python
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC 
LIMIT 1
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code correctly identifies the employee who generated the most sales in Q4 2023. The SQL query correctly calculates total sales for each employee, filters for orders in Q4 2023, groups by employee, and orders by total sales in descending order. It limits the result to the top employee, as required. The addition of FirstName and LastName does not alter the logic of finding the top employee by total sales.","```python
import pandas as pd

# Mock function definitions (assuming they are implemented elsewhere)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Executes the SQL query and returns the result as a DataFrame
    # Implementation is not provided here
    pass

def show_to_user(data: pd.DataFrame):
    # Displays the DataFrame to the user
    # Implementation is not provided here
    pass


# SQL query to find the employee with the most sales in Q4 2023
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 1
""""""

# Execute the SQL query and get results in a DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)
```","The input Python code correctly answers the business analytics request by executing a SQL query that identifies the employee with the highest sales in Q4 2023. The logic used matches the reference code's approach: it sums up the sales, applies discounts, filters by order date in Q4 2023, groups by EmployeeID, and orders the results by total sales in descending order, limiting the output to the top result. The minor differences in formatting and table join order do not affect the correctness of the logic.",both
"What is the maximum, minimum, and average salary of the employees? (A box plot can visualize salary distribution effectively.)","```python
import plotly.express as px

# Define SQL query
sql_query = ""SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees;""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Display max, min, and average salary
show_to_user(result_df)

# Query to get salary data for box plot
salary_query = ""SELECT Salary FROM employees;""

# Execute query to get all salaries
salary_df = execute_sql_query(salary_query)

# Create box plot for salary distribution
fig = px.box(salary_df, y='Salary', title='Salary Distribution')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT MAX(Salary) AS max_salary, MIN(Salary) AS min_salary, AVG(Salary) AS avg_salary FROM employees;""
salary_stats = execute_sql_query(sql_query)

box_plot = px.box(salary_stats, y=['max_salary', 'min_salary', 'avg_salary'], title=""Salary Distribution"")
show_to_user(box_plot)
```","The input code attempts to create a box plot using the result of the statistical query which includes only max, min, and average salary. However, a box plot should be created from a dataset with individual salary values to properly represent the distribution. The reference code correctly queries all salaries and uses those for visualization.","```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = ""SELECT MAX(Salary) as MaxSalary, MIN(Salary) as MinSalary, AVG(Salary) as AvgSalary FROM employees;""

# Step 2: Execute the SQL query and get the result as a DataFrame
salary_data = execute_sql_query(sql_query)

# Step 3: Convert the result to a long format DataFrame for visualization
salary_summary_long = salary_data.melt(var_name='Metric', value_name='Value')

# Step 4: Create a box plot to visualize salary distribution
fig = px.box(salary_summary_long, x='Metric', y='Value', title='Salary Distribution')

# Step 5: Display the plot to the user
show_to_user(fig)
```","The input implementation incorrectly uses the summary DataFrame for the box plot, which should visualize individual salary data, not aggregate metrics like max, min, and average. The reference implementation correctly queries and uses raw salary data for the box plot.",None
What is the average discount given per order in the last week?,"```python
import pandas as pd

# SQL query to retrieve average discount per order in the last week
sql_query = """"""
SELECT AVG([Order Details].Discount) AS Average_Discount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 WEEK);
""""""

# Execute SQL query and get the result as a dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df['Average_Discount'][0])
```","```python
import pandas as pd

# Define the SQL query to calculate the average discount per order in the last week
sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= CURDATE() - INTERVAL 7 DAY
""""""

# Execute the SQL query
average_discount_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_discount_df)
```","The input code correctly computes the average discount per order in the last week. It uses a similar SQL query by joining 'orders' and 'Order Details' tables to retrieve the average discount where orders are from the last week. The calculation logic matches the reference implementation by using 'AVG(Discount)' and similar date comparison criteria. The result of the query is then shown to the user, which meets the requirements of the business analytics request.","```python
import pandas as pd

# SQL query to fetch the total number of orders and total discount applied in the last week
sql_query = """"""
SELECT 
    COUNT(DISTINCT OrderID) AS total_orders, 
    SUM(Discount) AS total_discount 
FROM 
    [Order Details] 
WHERE 
    OrderID IN (
        SELECT OrderID FROM orders 
        WHERE OrderDate >= DATEADD(week, -1, CURRENT_DATE)
    )
""""""

# Execute the SQL query using the provided utility function
result = execute_sql_query(sql_query)

# Calculate the average discount per order and prepare the final DataFrame
# To avoid division by zero, we add a condition to check for total_orders count
if result['total_orders'].iloc[0] > 0:
    average_discount_per_order = result['total_discount'].iloc[0] / result['total_orders'].iloc[0]
else:
    average_discount_per_order = 0

# Create a DataFrame to present the result
average_discount_df = pd.DataFrame({
    'average_discount_per_order': [average_discount_per_order]
})

# Display the result
show_to_user(average_discount_df)
```","The input code correctly calculates the average discount per order for the last week. It sums up the discounts and counts the distinct orders in the last week, ensuring no division by zero. While the SQL syntax differs from the reference due to the use of COUNT and SUM, the logic and the final outcome match the request and reference code.",both
What is the average order value for the year 2022?,"```python
import pandas as pd

# SQL query to calculate average order value for the year 2022
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) 
       / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the average order value from the DataFrame
average_order_value = df['avg_order_value'].iloc[0]

# Display the result to user
show_to_user(average_order_value)
```","```python
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
       COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""
avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)
```","The input code displays the entire DataFrame instead of extracting and displaying the specific 'avg_order_value' value. In contrast, the reference implementation extracts the average order value from the DataFrame before displaying it, ensuring that only the calculated average is shown to the user.","```python
import pandas as pd

# SQL Query to fetch data
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS Average_order_value
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = 2022;
""""""

# Execute the SQL query using the execute_sql_query function
average_order_value_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_order_value_df)
```","The input code correctly calculates the average order value for the year 2022. It uses the same logic as the reference implementation by summing the product of UnitPrice, Quantity, and discount adjustment, and dividing by the count of distinct OrderID. Both codes target the same date range for the year 2022. While the input code uses YEAR(o.OrderDate) to filter the date, it is logically equivalent to the BETWEEN clause used in the reference. The result is displayed through the show_to_user function.",Finetuned
How many orders were placed by each customer in the last quarter of 2022? (Consider visualizing this using a bar chart for better insights.),"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
  SELECT CustomerID, COUNT(OrderID) AS OrderCount 
  FROM orders 
  WHERE OrderDate BETWEEN '2022-10-01' AND '2022-12-31' 
  GROUP BY CustomerID
""""""

# Execute the SQL query and get the result as a dataframe
orders_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(orders_data, x='CustomerID', y='OrderCount', title='Orders by Customer in Q4 2022')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= '2022-10-01' AND OrderDate < '2023-01-01'
GROUP BY CustomerID
ORDER BY OrderCount DESC
""""""

order_counts = execute_sql_query(sql_query)

fig = px.bar(order_counts, x='CustomerID', y='OrderCount', title='Orders Placed by Each Customer in Q4 2022', 
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input code correctly retrieves the number of orders placed by each customer in the last quarter of 2022. It uses a SQL query with the correct date range, aggregating order counts by CustomerID, and visualizes the data in a bar chart similar to the reference implementation. Despite minor differences, such as including an ORDER BY clause and adding labels, the core logic and the outcome remain consistent with the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the number of orders placed by each customer in Q4 2022
sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) AS NumberOfOrders
FROM orders o
WHERE o.OrderDate BETWEEN '2022-10-01' AND '2022-12-31'
GROUP BY o.CustomerID;
""""""

# Execute the SQL query to get the data into a DataFrame
df_orders = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per customer
fig = px.bar(df_orders, x='CustomerID', y='NumberOfOrders', 
             title='Number of Orders per Customer in Q4 2022', 
             labels={'NumberOfOrders': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to fetch the number of orders placed by each customer in Q4 2022, just like the reference implementation. Both codes use the same logic to filter orders by date and group by customer, and the visualization is appropriately created using Plotly. Although the input code includes labels for the bar chart, it doesn't affect the correctness or logic. Hence, the input code is correct.",both
What is the total quantity of products ordered in each month of the current year? (A line chart or bar chart can illustrate monthly totals.),"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(od.Quantity) AS TotalQuantityOrdered 
FROM `Order Details` od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY Month;
""""""

# Execute SQL query and get data
df = execute_sql_query(sql_query)

# Create a line chart to represent the total quantity ordered each month
fig = px.line(df, x='Month', y='TotalQuantityOrdered', title='Total Quantity of Products Ordered Each Month in Current Year', labels={'TotalQuantityOrdered': 'Total Quantity Ordered'})

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_year = datetime.now().year

sql_query = f""""""
SELECT 
    MONTH(od.OrderID) AS OrderMonth, 
    SUM(od.Quantity) AS TotalQuantity
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    YEAR(o.OrderDate) = {current_year}
GROUP BY 
    MONTH(od.OrderID)
ORDER BY 
    OrderMonth
""""""

monthly_totals = execute_sql_query(sql_query)

fig = px.bar(monthly_totals, x='OrderMonth', y='TotalQuantity', 
              labels={'OrderMonth': 'Month', 'TotalQuantity': 'Total Quantity Ordered'},
              title=f'Total Quantity of Products Ordered in Each Month of {current_year}')

show_to_user(fig)
```","The input code uses 'MONTH(od.OrderID)' instead of 'MONTH(o.OrderDate)' for grouping and ordering. This is incorrect, as 'OrderID' should not be used to determine the month. The reference code correctly uses 'OrderDate' for extracting the month. Additionally, the input code uses brackets '[Order Details]' instead of backticks, but this is a syntax matter related to the SQL dialect being used.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are predefined utility functions

# SQL query to get total quantity of products ordered per month for the current year
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    SUM(Quantity) AS total_quantity
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly totals
fig = px.line(df, x='month', y='total_quantity', title='Total Quantity of Products Ordered Per Month',
              labels={'total_quantity': 'Total Quantity', 'month': 'Month'})

# Display the chart to the user
show_to_user(fig)
```","The input code does not filter the data to restrict it to the current year. Additionally, the input code does not perform the JOIN with the 'Order Details' table to sum the quantities from the correct source, and it uses a single table 'orders' which doesn't match the reference. Therefore, it doesn't adhere to the business analytics request correctly.",None
How many orders included products with more than a 10% discount?,"```python
import pandas as pd

# Define SQL query to count distinct orders with more than 10% discount
sql_query = """"""
SELECT COUNT(DISTINCT od.OrderID) as NumberOfOrders 
FROM [Order Details] od 
WHERE od.Discount > 0.10
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df['NumberOfOrders'][0])
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT od.OrderID) AS OrderCount
FROM [Order Details] od
WHERE od.Discount > 0.10
""""""
order_count = execute_sql_query(sql_query)
show_to_user(order_count)
```","The input Python code uses the same SQL logic as the reference implementation to count distinct orders with more than a 10% discount. Both codes select a distinct count of OrderID from the '[Order Details]' table where the Discount is greater than 0.10. The input code retrieves the result with 'execute_sql_query' and 'show_to_user' similarly, making it correct in logic and purpose.","```python
import pandas as pd

# Given the SQL query
sql_query = """"""
SELECT COUNT(DISTINCT OrderID) AS OrdersWithHighDiscount 
FROM [Order Details] 
WHERE Discount > 0.10;
""""""

# Execute the SQL query using the utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","The input code is incorrect because it does not extract the specific value from the result DataFrame before displaying it. It tries to display the entire DataFrame, whereas the reference implementation accesses the specific field 'NumberOfOrders'. The input code should extract the count value similar to the reference implementation, such as accessing the first element of the 'OrdersWithHighDiscount' column.",Base
What is the inventory turnover ratio for the past month?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 MONTH')
AND EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '1 MONTH');
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
from datetime import datetime, timedelta
import pandas as pd

# Calculate the date range for the past month
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# SQL query to calculate the Inventory Turnover Ratio
sql_query = f""""""
SELECT 
    SUM(OD.Quantity * OD.UnitPrice) AS total_sales,
    AVG(P.UnitsInStock) AS average_inventory,
    SUM(OD.Quantity * OD.UnitPrice) / NULLIF(AVG(P.UnitsInStock), 0) AS inventory_turnover_ratio
FROM 
    products P
JOIN 
    [Order Details] OD ON P.ProductID = OD.ProductID
WHERE 
    OD.OrderID IN (SELECT OrderID FROM [Orders] WHERE OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}')
""""""

# Execute the SQL query
inventory_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(inventory_data)
```","The provided code calculates the date for the past 30 days instead of using the previous calendar month as the reference implementation does. The reference implementation ensures that it uses the entire past month regardless of the current date by checking the month and year specifically. The provided code uses a date range that may not align with the intended past calendar month. Additionally, the query in the provided code selects orders based on this incorrect date range.","
```python
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute an SQL query
    # In practice, this would connect to a database and run the query
    raise NotImplementedError(""This function needs to be implemented to execute SQL queries."")

def show_to_user(data):
    # Placeholder function to display data
    # In practice, this might format data or present it in a specific way
    print(data)

# SQL query to fetch the total sales for the past month
sql_query_total_sales = """"""
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSales
FROM [Order Details]
INNER JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE)
AND orders.OrderDate < CURRENT_DATE
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query_total_sales)
total_sales = sales_data['TotalSales'][0] if not sales_data.empty else 0

# SQL query to fetch the average inventory for the current month
sql_query_avg_inventory = """"""
SELECT AVG(products.UnitsInStock) AS AvgInventory
FROM products
INNER JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
INNER JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE)
AND orders.OrderDate < CURRENT_DATE
""""""

# Execute the SQL query
inventory_data = execute_sql_query(sql_query_avg_inventory)
avg_inventory = inventory_data['AvgInventory'][0] if not inventory_data.empty else 0

# Calculate the inventory turnover ratio
inventory_turnover_ratio = (total_sales / avg_inventory) if avg_inventory != 0 else 0

# Display the inventory turnover ratio
results = pd.DataFrame({'Inventory Turnover Ratio': [inventory_turnover_ratio]})
show_to_user(results)
```
","The input code incorrectly calculates dates. It uses DATEADD() and CURRENT_DATE to get past month data, but this may not match the last month's complete date range as used in the reference code with EXTRACT(). This results in different records included in the calculation and possibly a different inventory turnover ratio.",None
Find the top 3 cities with the most orders placed. (A bar chart can be useful to visualize and compare the top cities.),"```python
import plotly.express as px

# SQL query to get the top 3 cities with the most orders placed
sql_query = """"""
SELECT ShipCity, COUNT(*) AS total_orders 
FROM orders 
GROUP BY ShipCity 
ORDER BY total_orders DESC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top cities
fig = px.bar(df, x='ShipCity', y='total_orders', title='Top 3 Cities with Most Orders', labels={'ShipCity': 'City', 'total_orders': 'Total Orders'})

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to get the top 3 cities with the most orders
sql_query = """"""
SELECT c.City, COUNT(o.OrderID) as OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.City
ORDER BY OrderCount DESC
LIMIT 3
""""""

# Execute query and retrieve data
top_cities = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(top_cities, x='City', y='OrderCount', title='Top 3 Cities with Most Orders', labels={'OrderCount': 'Number of Orders', 'City': 'City'})

# Show result to user
show_to_user(fig)
```","The input code correctly implements the logic to find the top 3 cities with the most orders. It uses a similar SQL query to join customers and orders, counts the orders per city, and limits the results to the top 3 based on order count. The use of column aliases and column names differ slightly, but the logic aligns with the reference implementation. Both implementations create a bar chart for visualization and display the result using `show_to_user(fig)`, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Query to get the top 3 cities with the most orders placed
sql_query = """"""
SELECT o.ShipCity, COUNT(o.OrderID) AS NumberOfOrders 
FROM orders o 
GROUP BY o.ShipCity 
ORDER BY NumberOfOrders DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the result as a DataFrame
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 3 cities
fig = px.bar(top_cities_df, x='ShipCity', y='NumberOfOrders', 
             title='Top 3 Cities with Most Orders Placed',
             labels={'ShipCity': 'City', 'NumberOfOrders': 'Number of Orders'})

# Display the bar chart to the user
show_to_user(fig)
```","The provided code correctly implements the business requirement to find the top 3 cities with the most orders placed using SQL and visualizes the result with a bar chart. It follows the same logic as the reference implementation by querying for the city names and their respective order counts, ordering them in descending order, and limiting the results to the top 3. The use of COUNT and GROUP BY is consistent between both implementations. The label names differ slightly but convey the same meaning. Overall, the input code achieves the necessary objective as the reference code.",both
What is the average shipping cost per order for orders shipped to 'Canada'?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Freight) AS AverageShippingCost FROM orders WHERE ShipCountry = 'Canada';""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Since the result is a single value in a DataFrame, extract and print it.
average_shipping_cost = df['AverageShippingCost'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'AverageShippingCost': [average_shipping_cost]}))
```","```python
sql_query = """"""
SELECT AVG(Freight) AS Average_Shipping_Cost
FROM orders
WHERE ShipCountry = 'Canada'
""""""

average_shipping_cost_df = execute_sql_query(sql_query)
show_to_user(average_shipping_cost_df)
```","The provided code correctly calculates the average shipping cost for orders shipped to 'Canada'. It uses the same SQL logic as the reference implementation by selecting the average freight (shipping cost) from orders where the 'ShipCountry' is 'Canada'. The difference in column naming ('Average_Shipping_Cost' vs. 'AverageShippingCost') does not affect the correctness, as it still calculates the same metric. Finally, it displays the result using the show_to_user function, which aligns with the intended task.","```python
# Execute the provided SQL query to calculate the average shipping cost per order for orders shipped to 'Canada'
average_shipping_cost_query = """"""
SELECT AVG(Orders.Freight) AS AverageShippingCost 
FROM orders 
WHERE orders.ShipCountry = 'Canada';
""""""

# Assuming execute_sql_query function will return the result as a DataFrame
average_shipping_cost_df = execute_sql_query(average_shipping_cost_query)

# Displaying the result to the user
show_to_user(average_shipping_cost_df)
```","The input Python code accurately implements the same logic as the reference implementation. Both codes execute an SQL query to calculate the average shipping cost of orders shipped to 'Canada'. The main difference is in how the result is displayed, yet both codes ensure the final result is shown to the user. Since the logic and the query executed are the same, the input code is considered correct.",both
What is the retention rate of customers comparing the first half of 2023 to the previous year? (A line graph could help show changes in retention rates over time.),"```python
import pandas as pd
import plotly.express as px

# Define SQL queries
first_half_2023_query = """"""
SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_2023_1H
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
""""""

previous_year_query = """"""
SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_prev_year
FROM orders o 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute queries
first_half_2023_df = execute_sql_query(first_half_2023_query)
previous_year_df = execute_sql_query(previous_year_query)

# Calculate retention rate
customer_retention_rate = (first_half_2023_df['customer_count_2023_1H'][0] / 
                           previous_year_df['customer_count_prev_year'][0])

# Create DataFrame for visualization
retention_data = pd.DataFrame({
    'Period': ['First Half 2023'],
    'Retention Rate': [customer_retention_rate]
})

# Visualize retention rate
fig = px.line(retention_data, x='Period', y='Retention Rate', 
              title='Customer Retention Rate: First Half 2023 vs Previous Year')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL queries to get customer retention data for the first half of 2023 and the entire 2022
query_2023 = """"""
SELECT MONTH(orders.OrderDate) AS month,
       COUNT(DISTINCT orders.CustomerID) AS retained_customers
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
GROUP BY MONTH(orders.OrderDate)
""""""

query_2022 = """"""
SELECT MONTH(orders.OrderDate) AS month,
       COUNT(DISTINCT orders.CustomerID) AS total_customers
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY MONTH(orders.OrderDate)
""""""

# Execute the queries
retained_customers_2023 = execute_sql_query(query_2023)
total_customers_2022 = execute_sql_query(query_2022)

# Calculate retention rate for each month in the first half of 2023
retention_data = retained_customers_2023.merge(total_customers_2022, on=""month"", suffixes=('_2023', '_2022'))
retention_data['retention_rate'] = retention_data['retained_customers'] / total_customers_2022['total_customers']

# Create line graph for retention rates
fig = px.line(retention_data, x='month', y='retention_rate', title='Customer Retention Rate: 2023 (H1) vs 2022', labels={'retention_rate':'Retention Rate', 'month':'Month'})
show_to_user(fig)
```","The input code calculates monthly retention rates for the first half of 2023 against the entire 2022, while the reference code computes a single retention rate for the entire first half of 2023 compared to the previous year. The input does not correctly aggregate all months for a yearly comparison, deviating from the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px


def calculate_retention_rate():
    # SQL query to get retention rates for both halves of the years
    sql_query = """"""
    WITH base AS (
        SELECT
            CAST(orders.OrderDate AS DATE) AS order_date,
            orders.CustomerID,
            orders.EmployeeID,
            EXTRACT(YEAR FROM orders.OrderDate) AS order_year,
            COUNT(orders.OrderID) AS order_count
        FROM
            orders
        GROUP BY
            order_date, orders.CustomerID, orders.EmployeeID, order_year
    ),
    first_half_2022 AS (
        SELECT DISTINCT CustomerID FROM base WHERE order_year = 2022 AND order_date < '2022-07-01'
    ),
    first_half_2023 AS (
        SELECT DISTINCT CustomerID FROM base WHERE order_year = 2023 AND order_date < '2023-07-01'
    )
    SELECT
        (SELECT COUNT(CustomerID) FROM first_half_2023) * 1.0 /
        (SELECT COUNT(CustomerID) FROM first_half_2022) AS retention_rate
    """"""

    # Executing SQL query
    df = execute_sql_query(sql_query)
    
    # Extracting the retention rate
    retention_rate = df.iloc[0]['retention_rate']
    
    # Preparing the line graph data
    retention_data = {
        'Year': [2022, 2023],
        'RetentionRate': [None, retention_rate]  # Assuming you want to compare
    }
    retention_df = pd.DataFrame(retention_data)

    # Creating a line graph using Plotly
    fig = px.line(retention_df, x='Year', y='RetentionRate', title='Customer Retention Rate Comparison', markers=True)

    # Displaying the plot to the user
    show_to_user(fig)

# Call the function
calculate_retention_rate()
```","The input Python code correctly calculates the retention rate by comparing the number of unique customers in the first half of 2023 with those in the first half of 2022. The logic aligns with the reference implementation, which compares customers in 2023 with those in 2022. Both approaches involve executing SQL queries to retrieve distinct customer counts for specified periods and then using these counts to compute the retention rate. The visualization with Plotly also correctly displays the retention rate. The assumptions made, like using data from the first halves of the years, are consistent with the request.",Finetuned
How many distinct products have been ordered?,"```python
import pandas as pd

# SQL query to get the distinct product IDs
sql_query = ""SELECT DISTINCT ProductID FROM [Order Details];""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate the count of distinct products
distinct_product_count = len(result_df)

# Display the result to the user
show_to_user(pd.DataFrame({'DistinctProducts': [distinct_product_count]}))
```","```python
sql_query = """"""
SELECT COUNT(DISTINCT ProductID) AS distinct_products_ordered
FROM [Order Details]
""""""
distinct_products_df = execute_sql_query(sql_query)
show_to_user(distinct_products_df)
```",The input code correctly calculates the number of distinct products by using a SQL query to COUNT DISTINCT 'ProductID'. The reference implementation also gets distinct 'ProductID' and counts them using Python. Both approaches achieve the same result through different methods and adhere to the business analytics request.,"
```python
import pandas as pd

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation - In a real scenario, this would connect to a database and execute the query
    # For this example, returning an empty DataFrame
    return pd.DataFrame()

# Utility function to display data to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        print(f""Result: {data}"")

# Define the SQL query to find the number of distinct products ordered
sql_query = '''
SELECT COUNT(DISTINCT ProductID) AS DistinctProducts FROM [Order Details]
'''

# Execute the query to get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Extract the distinct product count from the DataFrame
distinct_products_count = result_df['DistinctProducts'].iloc[0] if not result_df.empty else 0

# Display the result to the user
show_to_user(distinct_products_count)
```
","The evaluated code correctly uses a SQL query to count the distinct ProductIDs directly with the COUNT(DISTINCT ProductID) SQL function. Although it retrieves the count in a different way compared to the reference implementation (which lists distinct ProductIDs and then measures the length), it adheres to the logic of determining the count of distinct products. The result is then displayed correctly. Both implementations correctly answer the business analytics request.",both
How many orders were placed each month by each customer? (A stacked bar chart might provide a clear visual representation.),"```python
import plotly.express as px

# Step 1: Execute SQL Query
sql_query = """"""
SELECT c.CustomerID, DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth, 
COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID, OrderMonth;
""""""
df = execute_sql_query(sql_query)

# Step 2: Create a stacked bar chart
fig = px.bar(df, x='OrderMonth', y='OrderCount', color='CustomerID', 
             title='Monthly Orders by Customer', 
             labels={'OrderMonth':'Order Month', 
                     'OrderCount':'Order Count', 
                     'CustomerID':'Customer ID'}, 
             barmode='stack')

# Step 3: Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
    COUNT(o.OrderID) AS OrderCount
FROM 
    customers AS c
JOIN 
    orders AS o ON c.CustomerID = o.CustomerID
GROUP BY 
    c.CustomerID, OrderMonth
ORDER BY 
    OrderMonth, c.CustomerID;
""""""

order_counts_df = execute_sql_query(sql_query)

fig = px.bar(order_counts_df, 
             x='OrderMonth', 
             y='OrderCount', 
             color='CompanyName', 
             title='Monthly Orders by Customer',
             labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'},
             text='OrderCount')

show_to_user(fig)
```","The provided code is aligned with the reference implementation in terms of functionality. Both queries correctly group the order counts by customer and by month. The provided code uses `CompanyName` for coloring the stacked bars, which is an acceptable alternative to using `CustomerID` as it provides a clearer label in the graph. The main purpose of visualizing monthly order counts per customer is achieved with the provided code, making it correct.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM orders.OrderDate) AS month,
    orders.CustomerID,
    COUNT(orders.OrderID) AS number_of_orders
FROM 
    orders
GROUP BY 
    EXTRACT(MONTH FROM orders.OrderDate), orders.CustomerID
""""""

# Execute the SQL query to get the data in a DataFrame
df = execute_sql_query(sql_query)

# Create a pivot table for the stacked bar chart
pivot_df = df.pivot(index='month', columns='CustomerID', values='number_of_orders').fillna(0)

# Create a stacked bar chart using Plotly
fig = px.bar(pivot_df, x=pivot_df.index, y=pivot_df.columns, title='Monthly Orders by Customer', 
             labels={'value': 'Number of Orders', 'variable': 'Customer ID'})

# Show the resulting visualization to the user
show_to_user(fig)
```","The input code groups data by month only, while the reference code groups by both year and month. Consequently, the input code aggregates data for the same month across different years, leading to incorrect analysis. Additionally, the input code mistakenly uses pivot and stacks data differently than the reference implementation, which uses direct stacking by customer in Plotly.",Base
What is the hire date of the oldest employee?,"```python
import pandas as pd

# Execute the SQL query to get the oldest employee's hire date
sql_query = ""SELECT e.FirstName, e.LastName, e.HireDate FROM employees e ORDER BY e.HireDate ASC LIMIT 1""
oldest_employee_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(oldest_employee_df)
```","```python
sql_query = """"""
SELECT HireDate
FROM employees
ORDER BY HireDate ASC
LIMIT 1
""""""

oldest_employee_hire_date = execute_sql_query(sql_query)
show_to_user(oldest_employee_hire_date)
```","The provided input Python code correctly executes an SQL query to select the hire date of the oldest employee by ordering the 'HireDate' in ascending order and limiting the result to 1. It then displays the result to the user. This logic matches the reference implementation, despite minor differences such as not selecting the employee's first and last name, which are not required by the business analytics request.","
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT HireDate
FROM employees
ORDER BY BirthDate ASC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","The input code retrieves the hire date of the youngest employee based on the 'BirthDate' field, not the oldest based on 'HireDate' field. The logic in the reference code sorts by 'HireDate' ascendingly to find the oldest employee by hire date, which is not present in the input code.",Base
How many order details entries have a discount greater than 10%?,"```python
import pandas as pd

# The SQL query to get the count of order details entries with a discount greater than 10%
sql_query = ""SELECT COUNT(*) as count FROM [Order Details] WHERE Discount > 0.1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the count result to the user
show_to_user(result_df['count'][0])
```","```python
sql_query = """"""
SELECT COUNT(*) AS DiscountedOrderDetailsCount
FROM [Order Details]
WHERE Discount > 0.1
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code is correct in terms of SQL logic, but it does not index into the DataFrame to extract and display the count value, unlike the reference code which uses `result_df['count'][0]`.","```python
# Pre-defined utility functions
def execute_sql_query(sql_query: str):
    # Placeholder function to simulate SQL query execution.
    # In practice, this would interface with a database connection.
    # For now, it just returns a static value for demonstration purposes.
    return 15  # Simulated result: 15 entries with discount > 10%

def show_to_user(data):
    # Placeholder function to display data.
    # In practice, this would render the result in an appropriate format.
    print(f""Number of order details with discount greater than 10%: {data}"")

# Business logic
def main():
    # SQL query to count entries with a discount greater than 10%
    sql_query = ""SELECT COUNT(*) FROM Order_Details WHERE Discount > 0.1;""
    
    # Execute the SQL query and retrieve the result
    result = execute_sql_query(sql_query)
    
    # Show the result to the user
    show_to_user(result)

# Execute the main function
main()
```","The input code correctly executes the SQL query logic by querying the number of entries with a discount greater than 10%. Although the function implementations are placeholders and the SQL syntax slightly differs (table name format), both codes aim to achieve the same output. The input code also retrieves and displays the result, satisfying the business request.",Finetuned
Which supplier has the highest average lead time? (A bar chart can highlight differences among suppliers.),"```python
import plotly.express as px

# SQL query to retrieve data on suppliers and their average lead time
sql_query = """"""
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY s.CompanyName 
ORDER BY AverageLeadTime DESC
""""""

# Execute the SQL query and get the data in a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to highlight differences among suppliers
fig = px.bar(df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
GROUP BY s.SupplierID, s.CompanyName
ORDER BY AverageLeadTime DESC
LIMIT 1
""""""

lead_time_data = execute_sql_query(sql_query)

fig = px.bar(lead_time_data, x='CompanyName', y='AverageLeadTime', title='Supplier with Highest Average Lead Time')
show_to_user(fig)
```","The input code retrieves only the supplier with the highest average lead time using 'LIMIT 1', whereas the reference code retrieves all suppliers' average lead times and sorts them. The input code also modifies the join condition for 'Order Details' compared to the reference code. To adhere to the request and reference logic, the code should not limit to a single result and should use consistent joins.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY products.SupplierID 
ORDER BY avg_lead_time DESC
""""""

# Fetch data using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the results
fig = px.bar(df, x='SupplierID', y='avg_lead_time', 
             title='Average Lead Time by Supplier', 
             labels={'avg_lead_time': 'Average Lead Time (days)', 'SupplierID': 'Supplier ID'})

# Display the bar chart using the provided utility function
show_to_user(fig)
```","The input code calculates the average lead time for each SupplierID, not CompanyName, like the reference implementation. This means the input code does not check the supplier's company name explicitly and could lead to misinterpretation since users might not know SupplierID. The input should also ensure proper joins with suppliers to access the CompanyName and match the requirement for easier identification of the supplier with the highest lead time.",None
Identify employees whose orders had the highest average discount applied. (Consider using a bar chart to visualize discounts by employee.),"```python
import plotly.express as px

# SQL query to retrieve required data
sql_query = """"""
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY AvgDiscount DESC;
""""""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Visualize the average discount by employee using a bar chart
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', title='Average Discount by Employee')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY AverageDiscount DESC;
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='EmployeeName', y='AverageDiscount',
             title='Average Discount by Employee', labels={'AverageDiscount': 'Average Discount', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input Python code effectively retrieves the average discount applied to each employee’s orders and then visualizes it using a bar chart. It aligns with the business analytics request and adheres to the same logic as the reference implementation, except for including concatenated employee names. This addition enhances the visualization without altering the core logic of calculating and ranking employees by average discount. Both codes utilize a SQL query to calculate the average discount, grouping by EmployeeID. The use of `px.bar` from Plotly to visualize the data is consistent in both the reference and input implementations.","```python
import pandas as pd
import plotly.express as px

# Given the SQL query to find the highest average discount per employee
sql_query = """"""
SELECT e.EmployeeID, 
       AVG(od.Discount) AS AvgDiscount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY AvgDiscount DESC;
""""""

# Execute the SQL query and get the result as a DataFrame
employees_avg_discount_df = execute_sql_query(sql_query)

# Visualize the data using Plotly
fig = px.bar(
    employees_avg_discount_df,
    x='EmployeeID',
    y='AvgDiscount',
    title='Average Discount per Employee',
    labels={'AvgDiscount': 'Average Discount', 'EmployeeID': 'Employee ID'}
)

# Display the visualization to the user
show_to_user(fig)
```","The input code closely follows the reference implementation logic. It uses the same SQL query to compute the average discount by employee and visualizes the results using Plotly, with appropriate labels for clarity. The order of the operations and the visualization technique match the intent of the reference implementation.",both
What is the average unit price of products within each category? Show this using a bar chart of categories along with their average unit prices.,"```python
import plotly.express as px

# SQL Query to get average unit price per category
sql_query = ""SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice FROM products GROUP BY CategoryID;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the data type for CategoryID is string for proper categorical display
df['CategoryID'] = df['CategoryID'].astype(str) 

# Create a bar chart using plotly
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price per Category')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AvgUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_prices_df = execute_sql_query(sql_query)

fig = px.bar(average_prices_df, x='CategoryID', y='AvgUnitPrice', 
             title='Average Unit Price by Category', 
             labels={'CategoryID': 'Category ID', 'AvgUnitPrice': 'Average Unit Price'})

show_to_user(fig)
```","The provided code correctly implements the business analytics request: it performs a SQL query to calculate the average unit price by category, creates a bar chart with Plotly, and displays this chart to the user. The logic matches the reference implementation, using similar steps of executing the SQL query, processing the data, and visualizing it, despite minor differences in naming conventions and labels.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice 
FROM products 
GROUP BY CategoryID
""""""

# Execute the SQL query to get a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Category')

# Display the bar chart
show_to_user(fig)
```",The provided code accurately executes the SQL query to retrieve average unit prices per category and then uses Plotly to create a bar chart that visually represents the results. The differences in variable naming and string conversion for 'CategoryID' do not affect the correctness of the output as a categorical display is still achieved without explicit conversion. The logic and output are consistent with the reference implementation.,both
List the employees who have never made a sale.,"```python
import pandas as pd

# SQL query to retrieve employees who have never made a sale
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o 
ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL
""""""

# Execute the SQL query
employees_without_sales_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(employees_without_sales_df)
```","```python
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL
""""""
result = execute_sql_query(sql_query)
show_to_user(result)
```","The provided code matches the reference implementation in both logic and SQL query. It correctly identifies employees who have never made a sale by performing a LEFT JOIN between the 'employees' and 'orders' tables and checking for NULL 'OrderID'. The execution and display parts are handled similarly, confirming correctness.","```python
# Define the SQL query to find employees who have never made a sale
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL;
""""""

# Execute the SQL query to get the result as a DataFrame
employees_never_sold_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_never_sold_df)
```","The input code is correct because it matches the reference implementation's logic. Both codes construct a SQL query to perform a LEFT JOIN between employees and orders tables, then filter for employees with no matching orders using 'WHERE o.OrderID IS NULL'. The function 'execute_sql_query' is used to retrieve the result, and 'show_to_user' is used to display the DataFrame. The logic and intent in both implementations are consistent with the business request.",both
How many orders were shipped but not yet delivered?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT OrderID FROM orders WHERE ShippedDate IS NOT NULL AND RequiredDate IS NULL;""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Count the number of orders shipped but not yet delivered
shipped_not_delivered_count = orders_df.shape[0]

# Create a result DataFrame to display
result_df = pd.DataFrame({
    ""Shipped but Not Delivered Count"": [shipped_not_delivered_count]
})

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT COUNT(OrderID) AS UndeliveredOrders
FROM orders
WHERE ShippedDate IS NOT NULL AND (DeliveredDate IS NULL OR DeliveredDate > CURRENT_DATE)
""""""

order_counts = execute_sql_query(sql_query)
show_to_user(order_counts)
```","The reference implementation checks for orders where 'ShippedDate' is not null and 'RequiredDate' is null, meaning shipped but not necessarily delivered. The input code checks for 'ShippedDate' not null and 'DeliveredDate' null or in the future. This logic differs from the reference, which implies undelivered orders based on 'RequiredDate' status.","```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) as UndeliveredOrders FROM orders WHERE ShippedDate IS NOT NULL AND DeliveredDate IS NULL;""

# Execute the SQL query
undelivered_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(undelivered_orders_df)
```",The input code checks for 'DeliveredDate IS NULL' instead of 'RequiredDate IS NULL' as in the reference implementation. The condition should be on RequiredDate to match the logic of the reference code for orders shipped but not yet delivered.,None
Which orders have the highest discounts applied? Visualize the top orders with the highest discounts using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get order discounts
sql_query = """"""
SELECT orders.OrderID, MAX([Order Details].Discount) AS MaxDiscount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY orders.OrderID 
ORDER BY MaxDiscount DESC 
LIMIT 10
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the top orders with the highest discounts
fig = px.bar(df, x='OrderID', y='MaxDiscount', title='Top Orders with Highest Discounts')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.OrderID, 
    SUM(od.Discount) AS TotalDiscount
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    o.OrderID
ORDER BY 
    TotalDiscount DESC
LIMIT 10
""""""

top_discount_orders = execute_sql_query(sql_query)

fig = px.bar(top_discount_orders, x='OrderID', y='TotalDiscount', title='Top Orders with Highest Discounts', labels={'TotalDiscount':'Total Discount', 'OrderID':'Order ID'})
show_to_user(fig)
```","The reference implementation calculates the maximum discount per order using 'MAX', focusing on the highest individual discount for any item in an order. The input code calculates the total discount per order with 'SUM', considering cumulative discounts across all items. Therefore, the logic differs in how discounts are aggregated, not aligning with the specified requirement of finding the highest individual discount per order.","
```python
import plotly.express as px

# SQL query to fetch orders with the highest discounts.
sql_query = """"""
SELECT OrderID, SUM(Quantity * UnitPrice * Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY OrderID
ORDER BY TotalDiscount DESC
LIMIT 10;
""""""

# Execute the SQL query and get the result as a DataFrame.
top_discount_orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top orders with the highest discounts.
fig = px.bar(
    top_discount_orders_df,
    x='OrderID',
    y='TotalDiscount',
    title='Top Orders with Highest Discounts',
    labels={'TotalDiscount': 'Total Discount Amount', 'OrderID': 'Order ID'},
    text='TotalDiscount'
)

# Display the bar chart to the user.
show_to_user(fig)
```","The input code calculates total discount amounts by multiplying quantity, unit price, and discount, whereas the reference implementation uses the maximum discount per order. The logic and aggregation method differ, leading to different results.",None
What is the average time taken to ship an order? Use a histogram to visualize the distribution of shipping times.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get the shipping times
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) as ShippingTime FROM orders;
""""""

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Calculate the average shipping time
average_shipping_time = df['ShippingTime'].mean()

# Display the average shipping time to the user
average_df = pd.DataFrame({'AverageShippingTime': [average_shipping_time]})
show_to_user(average_df)

# Create a histogram to visualize the distribution of shipping times
fig = px.histogram(df, x='ShippingTime', title='Distribution of Shipping Times')

# Display the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate shipping times
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS ShippingDays
FROM orders
WHERE ShippedDate IS NOT NULL
""""""
shipping_data = execute_sql_query(sql_query)

# Calculate average shipping time
average_shipping_time = shipping_data['ShippingDays'].mean()

# Create histogram of shipping times
fig = px.histogram(shipping_data, x='ShippingDays', title='Distribution of Shipping Times', labels={'ShippingDays': 'Days to Ship'})
show_to_user(fig)
```","The evaluated code does not calculate, display, or provide the average shipping time like the reference implementation. It also includes a WHERE clause to exclude NULL ShippedDate entries, which wasn't specified in the reference.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT OrderID, DATEDIFF(ShippingDate, OrderDate) AS ShippingTime
FROM orders;
""""""

# Execute the query and retrieve the data
data = execute_sql_query(sql_query)

# Calculate the average shipping time
average_shipping_time = data['ShippingTime'].mean()

# Create a histogram to visualize the distribution of shipping times
fig = px.histogram(data, x='ShippingTime', title='Distribution of Shipping Times',
                   labels={'ShippingTime': 'Shipping Time (days)'},
                   nbins=30)

# Display the average shipping time on the histogram
fig.add_annotation(
    x=average_shipping_time,
    y=0,  # Position at the bottom
    text=f'Average Shipping Time: {average_shipping_time:.2f} days',
    showarrow=True,
    arrowhead=2,
    ax=0,
    ay=-40
)

# Show the histogram to the user
show_to_user(fig)
```","The input code is using 'ShippingDate' instead of 'ShippedDate' which may lead to a discrepancy if 'ShippingDate' is not equivalent to 'ShippedDate'. Moreover, the average shipping time is not being displayed separately to the user; it's only annotated on the histogram. For adherence to the reference implementation, the average should also be displayed apart from the histogram.",None
List the top 5 products by sales for Q2 2023. Represent these top products using a bar chart for better insight.,"```python
import plotly.express as px

# SQL query to list top 5 products by sales for Q2 2023
sql_query = """"""
SELECT products.ProductID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY products.ProductID 
ORDER BY total_sales DESC 
LIMIT 5
""""""

# Execute the SQL query
df_top_products = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df_top_products, x='ProductID', y='total_sales', title='Top 5 Products by Sales for Q2 2023')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY products.ProductName
ORDER BY total_sales DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='total_sales', title='Top 5 Products by Sales for Q2 2023')
show_to_user(fig)
```","The input code uses 'ProductName' instead of 'ProductID' in the SQL query. This changes the grouping logic compared to the reference code, which groups by 'ProductID'. Although the bar chart logic and display are correct, grouping by 'ProductName' instead of 'ProductID' does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch top 5 products by sales for Q2 2023
sql_query = """"""
SELECT ProductName, SUM([Order Details].Quantity) AS total_sales 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY ProductName 
ORDER BY total_sales DESC 
LIMIT 5;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='total_sales', 
             title='Top 5 Products by Sales for Q2 2023',
             labels={'total_sales': 'Total Sales', 'ProductName': 'Product Name'})

# Display the bar chart
show_to_user(fig)
```","The input code lists products by the number of units sold (Quantity), not by the total sales value, which contradicts the business analytics request and the reference implementation. The reference code calculates total sales using 'UnitPrice', 'Quantity', and 'Discount', while the input code only sums 'Quantity'. Additionally, the input uses 'ProductName' instead of 'ProductID'.",None
Which products from each supplier have not been discontinued?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, products.ProductName 
FROM suppliers 
INNER JOIN products 
ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 0;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT s.CompanyName, p.ProductName
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.Discontinued = 0
ORDER BY s.CompanyName, p.ProductName;
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code uses an equivalent SQL query to select products from each supplier that have not been discontinued. It correctly joins the 'suppliers' and 'products' tables on 'SupplierID', applies the filter 'WHERE p.Discontinued = 0', and orders the results. The order by clause doesn't affect correctness in this context. Therefore, the input code adheres to the specified task and matches the logic of the reference implementation.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, products.ProductID, products.ProductName
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
WHERE products.Discontinued = 0;
""""""

# Execute the SQL query and store the result in a DataFrame
results = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(results)
```","The provided input code correctly retrieves the products from each supplier that have not been discontinued. It joins the suppliers and products tables on SupplierID and filters the products where Discontinued equals 0, which aligns with the logic of the reference implementation. The additional selection of SupplierID and ProductID columns does not alter the result for the business question.",both
What is the total number of orders where the quantity ordered exceeded 50 units in 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT COUNT(orders.OrderID) AS large_orders 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Quantity > 50 
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and get the result in a dataframe
df_large_orders = execute_sql_query(sql_query)

# Extract the count value from the dataframe
large_orders_count = df_large_orders.iloc[0]['large_orders']

# Display the result to the user
show_to_user(pd.DataFrame({'Large Orders Count': [large_orders_count]}))
```","```python
sql_query = """"""
SELECT COUNT(*) AS total_orders
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE [Order Details].Quantity > 50 AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The provided code correctly executes a SQL query to count the number of orders with a quantity greater than 50 and within the year 2023. It uses a similar SQL JOIN and WHERE clause as the reference implementation and displays the result. Although it names the count differently ('total_orders' instead of 'large_orders') and shows the raw output, it still adheres to the logic and requirement of the business request.","
import pandas as pd

# Define the utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is a placeholder for executing the provided SQL query
    # It returns a pandas DataFrame
    pass

# Define the utility function
def show_to_user(data: pd.DataFrame):
    # This function is a placeholder for displaying data to the user
    pass

# SQL query to get the required data
sql_query = """"""
SELECT COUNT(OrderID) AS TotalLargeOrders 
FROM [Order Details] 
WHERE Quantity > 50 AND OrderID IN 
    (SELECT OrderID FROM orders WHERE YEAR(OrderDate) = 2023);
""""""

# Execute the SQL query and get the result
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
","The provided code does not correctly join the 'Order Details' with the 'orders' table before filtering. It uses a subquery to filter 'OrderID' from the 'orders' table based on the year but misses the direct join, which may affect the performance and correctness if any matches are missed due to discrepancies in the tables. The reference code uses a JOIN operation, ensuring only existing order records are considered. Additionally, the output column name in the provided code is 'TotalLargeOrders', while the reference expects 'large_orders'.",Base
What is the average quantity of products ordered per order?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG([Order Details].Quantity) AS AverageQuantity FROM [Order Details]""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Extract the average quantity and display it
average_quantity = df_result['AverageQuantity'].iloc[0]
show_to_user(pd.DataFrame({'AverageQuantity': [average_quantity]}))
```","```python
sql_query = """"""
SELECT AVG(Quantity) AS Average_Quantity
FROM [Order Details]
GROUP BY OrderID
""""""
average_quantity_df = execute_sql_query(sql_query)
show_to_user(average_quantity_df)
```","The input Python code calculates the average quantity per order by grouping by OrderID, whereas the reference code calculates the overall average quantity across all orders without grouping. The logic and outputs between the two implementations differ.","
```python
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function: Replace with actual implementation to connect to database and execute query
    pass  # Just an example; you would implement actual logic here.

def show_to_user(data: pd.DataFrame):
    # Mock function: Replace with actual implementation to display data
    pass  # Just an example; you would implement actual logic here.

# SQL query to get the average quantity of products ordered per order
sql_query = ""SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];""

# Execute the SQL query and store the results in a DataFrame
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result)
```
","The provided Python code is correct as it executes the SQL query to calculate the average quantity of products ordered per order. It uses a similar logic to the reference code by executing a query that selects the average quantity from the 'Order Details' table and assigns the result to a DataFrame. Both codes assume a predefined function to execute the SQL query and display the result. The minor differences, such as the addition of a semicolon at the end of the query and the way the result is extracted or displayed, do not affect the correctness of achieving the business analytics request.",Finetuned
What is the performance of each product based on sales quantities in Q1 2023? Use a line or bar chart to illustrate product performance.,"```python
import plotly.express as px

# SQL query to retrieve the sales quantities for each product in Q1 2023
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS product_performance
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate product performance
fig = px.bar(df, x='ProductID', y='product_performance', title='Product Performance in Q1 2023')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL Query to get product performance based on sales quantities in Q1 2023
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductName
ORDER BY total_quantity DESC
""""""

# Execute the SQL query and retrieve the data
product_performance_df = execute_sql_query(sql_query)

# Create a bar chart to visualize product performance
fig = px.bar(product_performance_df, x='ProductName', y='total_quantity',
             title='Product Performance Based on Sales Quantities in Q1 2023',
             labels={'total_quantity': 'Total Quantity Sold', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code evaluates the product performance in Q1 2023 based on sales quantities by correctly executing a SQL query to retrieve the required data. It uses 'ProductName' instead of 'ProductID', which still addresses the same purpose within the context of the logic. The generated bar chart effectively illustrates the product performance, and the differences in labeling and ordering do not impact the correctness to the business question.","```python
import plotly.express as px
import pandas as pd

# Utility Function: Placeholder for execute_sql_query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation
    # Replace with actual SQL execution logic to fetch pandas DataFrame
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'Sum(quantity)': [150, 200, 120]
    }
    return pd.DataFrame(data)

# Utility Function: Placeholder for show_to_user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to be executed
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS [Sum(quantity)]
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductName
ORDER BY [Sum(quantity)] DESC;
""""""

# Execute the SQL query and obtain the data
df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(df, x='ProductName', y='Sum(quantity)', title='Product Performance in Q1 2023',
              labels={'Sum(quantity)': 'Sales Quantity', 'ProductName': 'Product Name'})

# Display the plot
show_to_user(fig)
```","The input Python code differs from the reference implementation in two significant ways. First, it groups and plots data by 'ProductName' instead of 'ProductID', leading to a potential discrepancy in product identification. Second, it uses a line chart instead of a bar chart. The business request specified using a line or bar chart, so plot type flexibility is acceptable. However, the grouping and ordering are inconsistent, which could lead to differing results from the requested performance analysis based on product identifiers.",Base
Find the top 5 customers by the number of orders placed. Show results using a bar chart.,"```python
import plotly.express as px

# Define SQL query to retrieve top 5 customers by number of orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Top 5 Customers by Number of Orders')

# Display the result using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.CustomerID, 
    COUNT(o.OrderID) AS OrderCount
FROM 
    orders o
GROUP BY 
    o.CustomerID
ORDER BY 
    OrderCount DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CustomerID', y='OrderCount', title='Top 5 Customers by Number of Orders Placed')
show_to_user(fig)
```","The input code correctly executes a SQL query to retrieve the top 5 customers by the number of orders, groups and orders the data appropriately, and uses Plotly to create a bar chart. It adheres to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to find the top 5 customers by number of orders
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Top 5 Customers by Number of Orders')

# Show the plot to the user
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by finding the top 5 customers based on the number of orders placed. Both the input and reference codes execute an SQL query to count and sort orders by CustomerID. Although the input code includes a JOIN with the customers table, it does not affect the outcome regarding the number of orders per customer and matches the reference code's logic. Finally, the input code uses plotly to create and display a bar chart, just like the reference code.",both
What is the average shipping time for orders shipped to a specific country in the current month?,"```python
import pandas as pd
from datetime import datetime

# Set the specified country
specified_country = 'specified_country'

# Execute the SQL query to get the average shipping time
# Use a parameterized query to avoid SQL injection
query = """"""
    SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime 
    FROM orders 
    WHERE DATE_FORMAT(OrderDate, '%%Y-%%m') = DATE_FORMAT(CURDATE(), '%%Y-%%m') 
    AND ShipCountry = %s;
""""""
result_df = execute_sql_query(query, (specified_country,))

# Show the result to the user
show_to_user(result_df)
```","```python
import pandas as pd
import datetime

current_month = datetime.datetime.now().month
current_year = datetime.datetime.now().year

country = ""SPECIFIC_COUNTRY""

sql_query = f""""""
SELECT 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime
FROM 
    orders
WHERE 
    ShipCountry = '{country}'
    AND MONTH(OrderDate) = {current_month}
    AND YEAR(OrderDate) = {current_year}
""""""

average_shipping_time_df = execute_sql_query(sql_query)
show_to_user(average_shipping_time_df)
```","The input code lacks parameterization and is thus vulnerable to SQL injection. The country variable is directly integrated into the SQL query string, unlike the reference which uses a parameterized approach. Both codes aim to calculate the average shipping time for the current month and year, but the evaluated code is not secure due to the lack of parameterization.","```python
import pandas as pd
from datetime import datetime

# Define the country for which to calculate the average shipping time
specific_country = ""USA""  # Example country, modify as needed

# SQL Query
sql_query = f""""""
SELECT DATEDIFF(orders.ShippedDate, orders.OrderDate) AS ShippingTime
FROM orders
WHERE orders.ShipCountry = '{specific_country}'
AND MONTH(orders.OrderDate) = MONTH(CURRENT_DATE)
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE);
""""""

# Execute query and fetch results
shipping_times_df = execute_sql_query(sql_query)

# Calculate the average shipping time
if not shipping_times_df.empty:
    average_shipping_time = shipping_times_df['ShippingTime'].mean()
    average_shipping_time_df = pd.DataFrame({'AverageShippingTime': [average_shipping_time]})
else:
    average_shipping_time_df = pd.DataFrame({'AverageShippingTime': [None]})

# Display the result to the user
show_to_user(average_shipping_time_df)
```","The input Python code adheres to the same logic as the reference implementation for determining the average shipping time for orders shipped to a specified country during the current month. Although there are some stylistic differences, such as the use of a formatted string instead of a parameterized query and calculating the average using Python instead of SQL, both implementations essentially perform the same operations. The code correctly filters orders by the current month and year and then calculates the average shipping time.",Finetuned
Which customers have purchased more than 5 different products?,"```python
sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY customers.CustomerID, customers.CompanyName
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
""""""

# Execute the SQL query
df_customers = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_customers)
```","```python
sql_query = """"""
SELECT orders.CustomerID, COUNT(DISTINCT [Order Details].ProductID) AS product_count
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.CustomerID
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```",The input code retrieves customers with more than 5 different products but doesn't include the customer's company name. The reference implementation explicitly selects both CustomerID and CompanyName.,"```python
import pandas as pd

# Utility function stubs (assumed to be implemented elsewhere in the environment)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the provided SQL query and return a DataFrame
    pass

def show_to_user(data: pd.DataFrame) -> None:
    # This function should display the provided DataFrame to the user
    pass

# SQL query to find customers who purchased more than 5 different products
sql_query = """"""
SELECT customerID 
FROM [Order Details] 
GROUP BY customerID 
HAVING COUNT(DISTINCT ProductID) > 5;
""""""

# Execute the SQL query and get the result as a DataFrame
df_customers = execute_sql_query(sql_query)

# Display the resulting DataFrame to the user
show_to_user(df_customers)
```","The input code fails to join the necessary tables to properly associate customers with their orders and the products they ordered. The reference query joins the 'customers', 'orders', and 'Order Details' tables to ensure that products and their counts are linked to the correct Customer ID. The input code only queries the 'Order Details' table, which does not provide the Customer ID context needed to determine which customers purchased more than 5 different products.",None
Which region has the highest on-time delivery rate? Present this information with a pie chart or bar chart.,"```python
import plotly.express as px

# Define the SQL query to execute.
sql_query = """"""
SELECT ShipRegion, (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS on_time_rate
FROM orders
GROUP BY ShipRegion
ORDER BY on_time_rate DESC
LIMIT 1;
""""""

# Execute the SQL query using the provided utility function.
df = execute_sql_query(sql_query)

# Visualize the data with a bar chart to show the on-time delivery rates by region.
fig = px.bar(df, x='ShipRegion', y='on_time_rate', title='On-Time Delivery Rate by Region')

# Display the result to the user.
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID) AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipRegion
""""""

df = execute_sql_query(sql_query)

fig = px.pie(df, values='OnTimeDeliveryRate', names='ShipRegion', title='On-Time Delivery Rate by Region')
show_to_user(fig)
```","The input code calculates the on-time delivery rate per region and displays it in a pie chart, but does not identify which region has the highest on-time rate as requested. The reference code finds the region with the highest on-time rate and orders the results based on this metric using SQL, whereas the input code does not include an ORDER BY or LIMIT clause to identify or specifically present the highest rate. Moreover, the requested output visualization format should align with identifying the top region, which isn't directly achieved in a pie chart representation without additional context or manipulation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT Shippers.Region, AVG(Orders.OnTimeDelivery) AS OnTimeDeliveryRate
FROM Orders
JOIN Shippers ON Orders.ShipVia = Shippers.ShipperID
GROUP BY Shippers.Region
""""""

# Execute the query and get a DataFrame
df = execute_sql_query(sql_query)

# Identify the region with the highest on-time delivery rate
highest_on_time_region = df.loc[df['OnTimeDeliveryRate'].idxmax()]

# Prepare data for visualization
visualization_data = pd.DataFrame({
    'Region': [highest_on_time_region['Region']],
    'OnTimeDeliveryRate': [highest_on_time_region['OnTimeDeliveryRate']],
})

# Create a bar chart for the region with the highest on-time delivery rate
fig = px.bar(
    visualization_data,
    x='Region',
    y='OnTimeDeliveryRate',
    title='Region with the Highest On-Time Delivery Rate',
    labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate'}
)

# Display the visualization
show_to_user(fig)
```","The input code does not align with the logic of the reference implementation. The input code is joining Orders and Shippers tables and uses an AVG on 'OnTimeDelivery' which is not consistent with the reference logic. The reference code calculates the percentage of orders on time using a date comparison between 'ShippedDate' and 'RequiredDate'. Additionally, the input visualization only highlights the best performing region after analysis, whereas the reference code presents all regions' performance with on-time delivery rates.",None
How many orders were placed in the current year?,"```python
from datetime import datetime
import pandas as pd

# SQL query
sql_query = f""""""
SELECT COUNT(*) AS TotalOrders FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the total orders to the user
show_to_user(result_df)
```","```python
import pandas as pd

current_year = pd.to_datetime('today').year
sql_query = f""""""
    SELECT COUNT(OrderID) AS TotalOrders
    FROM orders
    WHERE YEAR(OrderDate) = {current_year}
""""""
order_count_df = execute_sql_query(sql_query)
show_to_user(order_count_df)
```","The input code correctly performs the task of counting the number of orders placed in the current year. It uses Pandas to get the current year, constructs an SQL query seeking the count of orders where the order date matches the current year, and uses similar logic to the reference implementation. The differences, such as using 'COUNT(OrderID)' instead of 'COUNT(*)', do not affect logic correctness since both count the number of rows.","
```python
import pandas as pd

# Define the SQL query to count the orders for the current year
sql_query = """"""
SELECT COUNT(*) AS total_orders FROM orders WHERE YEAR(order_date) = YEAR(CURDATE());
""""""

# Execute the SQL query and get the results as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)
```
","The input Python code aligns with the business analytics request and follows the logic of the reference implementation. Both codes select the count of orders from the 'orders' table where the year of the order date is the current year. The SQL functions and operations used (YEAR, CURDATE, CURRENT_DATE) are equivalent and will produce the same result. The difference in capitalization of SQL keywords and alias names is insignificant for correctness.",both
Calculate the total discount given on all orders in the last month.,"```python
import pandas as pd
from datetime import datetime, timedelta

# Calculate the start date for the last month
start_date_last_month = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1).strftime('%Y-%m-%d')

# SQL query to calculate the total discount
sql_query = f""""""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS TotalDiscount 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate >= '{start_date_last_month}';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
import pandas as pd
from datetime import datetime, timedelta

last_month_start = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
last_month_end = datetime.now().strftime('%Y-%m-%d')

sql_query = f""""""
SELECT SUM([Order Details].Discount) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '{last_month_start}' AND '{last_month_end}'
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code calculates the sum of the Discount column directly, which is incorrect. The discount should be calculated as a product of Quantity, UnitPrice, and Discount, as shown in the reference code. Additionally, the date range calculation in the input code uses a fixed 30-day range, which might not accurately reflect 'last month' as intended by the reference code that calculates the start of the previous month dynamically.","
```python
import pandas as pd

# Function to calculate total discount
def calculate_total_discount():
    # Define SQL query
    sql_query = """"""
    SELECT 
        SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
    FROM 
        orders o 
    JOIN 
        [Order Details] od ON o.OrderID = od.OrderID 
    WHERE 
        o.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE);
    """"""
    
    # Execute the SQL query and get the result
    total_discount_df = execute_sql_query(sql_query)
    
    # Check if the result is not empty
    if not total_discount_df.empty:
        # Print the total discount value
        print(""Total Discount in the Last Month:"", total_discount_df.iloc[0]['TotalDiscount'])
    else:
        print(""No data available for the last month."")

# Call the function
calculate_total_discount()
```","The input code uses `DATEADD(MONTH, -1, CURRENT_DATE)` which calculates the date one month before the current date. This differs from the reference code, which calculates the first day of the last month based on the current date. The reference code is designed to capture all orders from the start of the last month, whereas the input code might miss some orders depending on the current day of the month.",None
Which products have a stock level below their reorder level?,"```python
import pandas as pd

# Define the SQL query to find products with stock below reorder level
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user using the provided utility function
show_to_user(df)
```","```python
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
data = execute_sql_query(sql_query)
show_to_user(data)
```","The input code filters out products that have been discontinued by adding an additional condition 'Discontinued = 0', which is not present in the reference implementation. As a result, it may exclude some products that still have stock below their reorder level.","```python
def execute_sql_query(sql_query: str):
    # Mock implementation of the function to execute SQL query on the database
    # Let's assume it returns a pandas DataFrame
    # Sample data returned assuming the product_id is 1, 3 where stock < reorder level
    data = {
        ""product_id"": [1, 3],
        ""product_name"": [""Product A"", ""Product C""]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Function to display data to the user
    print(data)

# SQL query from the business requirement
sql_query = """"""
SELECT ProductID, ProductName 
FROM products 
WHERE unitsinstock < reorderlevel;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(df)
```",The input code follows the same logic as the reference implementation. It correctly queries products with stock levels below the reorder level and displays the results. The difference in column names does not affect the correctness related to the business request.,Finetuned
Which month had the highest number of orders placed? Show this with a bar chart of months and their corresponding order numbers.,"```python
import plotly.express as px

# SQL query to get the number of orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY Month
ORDER BY NumberOfOrders DESC
""""""

# Execute the SQL query and get the result as a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Create a bar chart showing the number of orders per month
fig = px.bar(orders_df, x=""Month"", y=""NumberOfOrders"", title=""Number of Orders per Month"")

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    OrderCount DESC
LIMIT 1
""""""

highest_month_df = execute_sql_query(sql_query)

month = highest_month_df['Month'].iloc[0]
order_count = highest_month_df['OrderCount'].iloc[0]

bar_chart_data = pd.DataFrame({
    'Month': [month],
    'OrderCount': [order_count]
})

fig = px.bar(bar_chart_data, x='Month', y='OrderCount', title='Month with Highest Number of Orders', labels={'OrderCount': 'Order Count', 'Month': 'Month'})
show_to_user(fig)
```","The input code only retrieves the month with the highest order count and creates a bar chart with that single month, while the reference code generates a bar chart for all months showing their order counts. The business request asks for a bar chart of all months, not just the highest one. Thus, the input code does not adhere to the correct logic as per the request and reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize orders per month
fig = px.bar(
    orders_df, 
    x='Month', 
    y='NumberOfOrders', 
    title='Number of Orders per Month',
    labels={'NumberOfOrders': 'Number of Orders', 'Month': 'Month'},
    text='NumberOfOrders'
)

# Display the bar chart using the utility function
show_to_user(fig)
```
","The input code correctly answers the business question by generating the number of orders per month and visualizing it using a bar chart. Although the SQL date formatting function (DATE_TRUNC) is different, it serves the same purpose as the reference code's DATE_FORMAT, grouping data by month accurately. The visual representation matches the requirement as in the reference code, displaying orders per month. The logic and outcome are consistent with the reference implementation.",Finetuned
Determine the employee with the largest average order size. Visualize this using a bar chart.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderSize 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY AvgOrderSize DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the dataframe is empty
if df.empty:
    raise ValueError(""No data returned from the query."")

# Create a bar chart to visualize the result
fig = px.bar(df, x='EmployeeID', y='AvgOrderSize', title='Employee with Largest Average Order Size')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderSize
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY AverageOrderSize DESC
LIMIT 1;
""""""

result = execute_sql_query(sql_query)

fig = px.bar(result, x='EmployeeName', y='AverageOrderSize', 
             title='Employee with Largest Average Order Size', 
             labels={'AverageOrderSize': 'Average Order Size', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code correctly calculates the employee with the largest average order size and visualizes the result using a bar chart. It follows the same logic as the reference code, computing the average order size and displaying the top result. The main difference is the inclusion of the employee's name in the visualization, which still aligns with the requested analysis.","```python
import pandas as pd
import plotly.express as px

# Utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute SQL queries and return a DataFrame
    pass

def show_to_user(data):
    # Placeholder function to display data or a Plotly figure
    pass

# SQL query to fetch employees with their average order size
sql_query = """"""
SELECT 
    e.FirstName, 
    e.LastName, 
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderSize 
FROM 
    employees e 
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY 
    e.FirstName, e.LastName 
ORDER BY 
    AverageOrderSize DESC 
LIMIT 1
""""""

# Execute the SQL query and fetch the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the employee with the largest average order size
fig = px.bar(df, x='FirstName', y='AverageOrderSize', hover_data=['LastName'], 
             title='Employee with the Largest Average Order Size')

# Display the bar chart
show_to_user(fig)
```","The input code achieves the same objective as the reference implementation: determining the employee with the largest average order size. Both codes aggregate the order size by employee, selecting the maximum. The main difference is that the input uses 'FirstName' and 'LastName' for grouping instead of 'EmployeeID'. The bar chart visualization is consistent with the requirement. This difference does not affect correctness as the code fetches and displays the required information correctly.",both
How many distinct customers placed orders each month? Use a line chart to show trends over the months.,"```python
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT DATE_TRUNC('month', o.OrderDate) AS Month, 
       COUNT(DISTINCT o.CustomerID) AS UniqueCustomers 
FROM orders o 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure 'Month' column is recognized as a date
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart using the data
fig = px.line(df, x='Month', y='UniqueCustomers', title='Distinct Customers Placing Orders Each Month', labels={'Month': 'Month', 'UniqueCustomers': 'Number of Unique Customers'})

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month,
    COUNT(DISTINCT CustomerID) AS DistinctCustomers
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

data = execute_sql_query(sql_query)
fig = px.line(data, x='Month', y='DistinctCustomers', title='Distinct Customers Placed Orders Each Month')
show_to_user(fig)
```","The input Python code correctly executes a SQL query to count distinct customers per month (`COUNT(DISTINCT CustomerID)`) and organizes the results by month (`DATE_TRUNC('month', OrderDate)`). It also properly creates a Plotly line chart to visualize the trend, using the query result. The logical structure and intent align with the reference implementation, and minor differences such as labels and table aliases do not affect correctness.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function to simulate SQL query execution
    # In practice, this function would connect to a database and execute the query
    pass

def show_to_user(data):
    # This would be the method to display the analysis or visualization
    pass

# SQL query to fetch distinct customer counts for each month
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(DISTINCT CustomerID) AS DistinctCustomers 
FROM orders 
GROUP BY Month;
""""""

# Execute the query to obtain the data
distinct_customers_df = execute_sql_query(sql_query)

# Create a line chart to display the trend of distinct customers over the months
fig = px.line(
    distinct_customers_df, 
    x='Month', 
    y='DistinctCustomers',
    title='Distinct Customers per Month',
    labels={'DistinctCustomers': 'Number of Distinct Customers'}
)

# Show the visualization
show_to_user(fig)
```","The input code is not fully correct due to the difference in date handling. The reference code uses 'DATE_TRUNC' (likely for PostgreSQL), which keeps the full date format as a timestamp. The input code uses 'DATE_FORMAT', which formats the date as a string in '%Y-%m'. This may affect plotting due to differences in date recognition by Plotly. Additionally, the labeling in the reference code is more precise and formatted ('UniqueCustomers' vs 'DistinctCustomers').",Base
What are the average discounts applied per order?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT OrderID, AVG(Discount) AS AverageDiscount FROM [Order Details] GROUP BY OrderID;""

# Execute the SQL query using the provided utility function
order_discounts_df = execute_sql_query(sql_query)

# Display the data analysis result
show_to_user(order_discounts_df)
```","```python
sql_query = """"""
SELECT OrderID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID
""""""

average_discounts = execute_sql_query(sql_query)
show_to_user(average_discounts)
```","The input Python code correctly implements the business analytics request. It uses SQL to calculate the average discount per order by grouping on 'OrderID', which is consistent with the reference implementation. The final result is displayed using the 'show_to_user' function, and the logic aligns perfectly with the reference implementation.","```python
import pandas as pd

# Given utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation; in real scenario it connects to a DB and executes the query
    pass

def display_to_user(data: pd.DataFrame):
    # Dummy implementation; displays the data in a user-friendly manner
    pass

# SQL query to fetch the average discount per order
sql_query = """"""
SELECT AVG(Discount) AS AvgDiscountPerOrder
FROM [Order Details];
""""""

# Execute the SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
display_to_user(result_df)
```","The input code calculates the average discount across all orders, while the reference code calculates the average discount per order. The logic differs as the input code doesn't group by OrderID.",Base
What is the average order fulfillment time for orders made in February 2023?,"```python
import pandas as pd

# SQL Query
sql_query = """"""
SELECT DATEDIFF(o.ShippedDate, o.OrderDate) AS FulfillmentTime 
FROM orders o 
WHERE MONTH(o.OrderDate) = 2 AND YEAR(o.OrderDate) = 2023;
""""""

# Execute the query and retrieve data
orders_df = execute_sql_query(sql_query)

# Calculate the average fulfillment time
avg_fulfillment_time = orders_df['FulfillmentTime'].mean()

# Display the result
show_to_user(pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]}))
```","```python
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= '2023-02-01' AND OrderDate < '2023-03-01';
""""""

fulfillment_data = execute_sql_query(sql_query)
show_to_user(fulfillment_data)
```","The input code calculates the average order fulfillment time for orders in February 2023, similar to the reference implementation. It uses SQL to compute the average directly in the query, simplifying the process. Both methods filter orders within February 2023 using the correct date range and compute the average fulfillment time, thus adhering to the same logic.","```python
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for executing SQL queries
    # This function should be implemented to connect to the database and execute the given query
    pass

def calculate_average_fulfillment_time():
    # SQL query to fetch the average fulfillment time for February 2023
    sql_query = """"""
    SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS 'Average Order Fulfillment Time'
    FROM orders
    WHERE OrderDate BETWEEN '2023-02-01' AND '2023-02-28';
    """"""
    
    # Execute the SQL query
    result_df = execute_sql_query(sql_query)
    
    # Display the average order fulfillment time
    if result_df is not None and not result_df.empty:
        print(result_df)
    else:
        print(""No data available."")

# Call the function to calculate and display average fulfillment time
calculate_average_fulfillment_time()
```","The input code directly computes the average in the SQL query using AVG, whereas the reference code calculates the average in Python. This changes the logic because any potential filtering or transformation after data retrieval is impossible in the input code. Additionally, the input code handles errors by checking for None or empty results, which the reference does not. These differences suggest a deviation from the specified logic.",Base
Get a list of employees and the number of orders they have handled.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    COUNT(o.OrderID) AS NumberOfOrders
FROM 
    employees e
LEFT JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
GROUP BY 
    e.EmployeeID
""""""

employee_orders_df = execute_sql_query(sql_query)
show_to_user(employee_orders_df)
```","The provided Python code correctly fulfills the business analytics request by querying a list of employees and the number of orders they have handled. It uses a LEFT JOIN to include employees with zero orders, which is slightly different from the reference code but still answers the question correctly. The reference implementation uses an INNER JOIN, implicitly excluding employees without orders. Both methods are logically valid, so the implementation is correct.","```python
# Import necessary libraries
import pandas as pd

# SQL query to get the list of employees and the number of orders they have handled
sql_query = """"""
SELECT e.FullName, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.FullName;
""""""

# Execute the SQL query
order_counts_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(order_counts_df)
```","The input code differs from the reference code in several key areas. Firstly, the input code uses 'LEFT JOIN' instead of 'JOIN'. While 'LEFT JOIN' may include employees with zero orders, this logic differs from the reference. Secondly, the code groups by 'e.FullName' instead of 'e.EmployeeID, e.FirstName, e.LastName'. This can lead to discrepancies if full names aren't unique. These differences mean the input code doesn't adhere to the same logic as the reference implementation.",Base
What is the inventory turnover ratio for the product 'Chai' in May 2023?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.ProductName = 'Chai'
AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the inventory turnover ratio value
inventory_turnover_ratio = df.iloc[0]['inventory_turnover_ratio']

# Display the result
show_to_user(inventory_turnover_ratio)
```","```python
import pandas as pd

sql_query = """"""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    products.ProductName = 'Chai' 
    AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code does execute a SQL query similar to the reference. However, the result from 'execute_sql_query' is passed directly to 'show_to_user' without extracting the 'inventory_turnover_ratio' value from the result dataframe. The reference code properly selects this value from the result using 'df.iloc[0]['inventory_turnover_ratio']'.","```python
import pandas as pd

# Assuming execute_sql_query and display are predefined functions

# Define the SQL query
sql_query = """"""
SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitPrice) AS InventoryTurnover
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE p.ProductName = 'Chai' AND o.OrderDate BETWEEN '2023-05-01' AND '2023-05-31';
""""""

# Execute the SQL query and get the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result
display(result_df)
```","The input code incorrectly calculates the inventory turnover ratio by dividing the sum of sales by the average unit price of 'Chai', not the average units in stock as in the reference code. The reference implementation correctly computes the ratio using UnitsInStock, which reflects the inventory accurately.",None
Which shipping method has the shortest average order fulfillment time?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AverageFulfillmentTime ASC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipVia
ORDER BY AvgFulfillmentTime
LIMIT 1
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input Python code correctly mimics the logic of the reference implementation by querying the database to find the shipping method with the shortest average order fulfillment time. Both the input and reference implementations perform the same steps: they compute the average fulfillment time by calculating the difference between 'ShippedDate' and 'OrderDate', group by 'ShipVia', order by the average time in ascending order, and limit the result to the top entry. The slight differences in variable names and formatting do not affect the correctness of the logic.","```python
import pandas as pd

# Placeholder function for executing SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating the execution of an SQL query
    # This should return a DataFrame containing the query results
    data = {
        'ShipVia': [1, 2, 3],
        'averageFulfillmentTime': [2.5, 3.0, 4.5]
    }
    return pd.DataFrame(data)

# Placeholder function for processing the result and displaying it
def show_to_user(data: pd.DataFrame) -> None:
    print(data)

# SQL query to calculate the average order fulfillment time by shipping method
sql_query = """"""
SELECT o.ShipVia, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS averageFulfillmentTime 
FROM orders o 
GROUP BY o.ShipVia 
ORDER BY averageFulfillmentTime ASC;
""""""

# Execute the SQL query and get the results as a DataFrame
result_df = execute_sql_query(sql_query)

# Display the shipping method with the shortest average fulfillment time
# Assuming we want only the top result
show_to_user(result_df.head(1))
```","The input Python code correctly calculates the shipping method with the shortest average order fulfillment time. It constructs an SQL query to calculate the average fulfillment time by 'ShipVia', orders the results, and limits the output to the top result similar to the reference implementation. Both implementations achieve the same goal using similar logic, despite minor differences in SQL syntax. The result output is also managed effectively by truncating the DataFrame to the first row with '.head(1)'.",both
What is the number of products sold with discounts?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ProductID 
FROM [Order Details] 
WHERE Discount > 0;
""""""

# Execute the query to retrieve data
result_df = execute_sql_query(sql_query)

# Count distinct ProductID
products_with_discount = result_df['ProductID'].nunique()

# Send the result to the user
show_to_user(pd.DataFrame({'ProductsWithDiscount': [products_with_discount]}))
```","```python
sql_query = """"""
SELECT SUM(Quantity) AS TotalProductsSoldWithDiscount
FROM [Order Details]
WHERE Discount > 0
""""""
result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code calculates the total quantity of products sold with a discount, rather than counting distinct ProductIDs with discounts, which is different from the reference implementation's logic.","```python
sql_query = """"""
SELECT COUNT(DISTINCT od.ProductID) AS DiscountedProductsCount
FROM [Order Details] od 
WHERE od.Discount > 0;
""""""

def execute_sql_query(sql_query: str):
    # Simulates interaction with a database
    # Replace with actual logic to connect and retrieve data
    class MockDatabaseCursor:
        def execute(self, query):
            print(f""Executing SQL: {query}"")

        def fetchone(self):
            return (5,)  # Example mock return

    class MockDatabaseConnection:
        def cursor(self):
            return MockDatabaseCursor()

        def close(self):
            pass

    db_connection = MockDatabaseConnection()
    cursor = db_connection.cursor()
    cursor.execute(sql_query)
    result = cursor.fetchone()
    db_connection.close()
    return result

def display_to_user(data):
    print(""Number of products sold with discounts:"", data[0])

# Execute the query and display the result
result_set = execute_sql_query(sql_query)
display_to_user(result_set)
```",The input code correctly calculates the number of distinct products sold with a discount by using a SQL query with a COUNT(DISTINCT ProductID) filter on Discount > 0. It simulates database interactions and ultimately extracts the same information as the reference implementation but does so in a more direct way by fetching the count directly from the query result rather than calculating it after fetching product IDs. The logic aligns with the business analytics request.,Finetuned
What is the average order fulfillment time per employee?,"```python
import pandas as pd

# Execute the SQL query
df = execute_sql_query(""""""
SELECT EmployeeID, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY EmployeeID;
"""""")

# Display the result to the user
show_to_user(df)
```","```python
sql_query = """"""
SELECT 
    EmployeeID, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM 
    orders
GROUP BY 
    EmployeeID
""""""

average_fulfillment_time = execute_sql_query(sql_query)
show_to_user(average_fulfillment_time)
```","The input code performs the same logic as the reference code. Both queries calculate the average order fulfillment time per employee using the DATEDIFF function between OrderDate and ShippedDate. Despite a small difference in the order of parameters in the DATEDIFF function, logically, both fulfill the business request correctly by deducing the time difference in days and averaging it per EmployeeID.","```python
def execute_sql_query(sql_query: str):
    # Simulated function for executing SQL query
    # Returns dummy data for demonstration purposes
    import pandas as pd
    
    # Dummy data representation
    data = {
        'EmployeeID': [1, 2, 3],
        'AverageFulfillmentTime': [1.5, 2.0, 1.8]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Simulated function to display data
    print(data)

# SQL query to get average order fulfillment time per employee
sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageFulfillmentTime
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query and store the result in a DataFrame
fulfillment_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(fulfillment_data)
```","The input code's SQL query references a JOIN with an 'employees' table, which is not used in the reference implementation. The reference only involves querying from the 'orders' table with a GROUP BY on EmployeeID. Additionally, the order of arguments in DATEDIFF is swapped. Both differences imply a discrepancy in logic from the reference code.",Base
What is the average number of units ordered per order?,"```python
import pandas as pd

# SQL Query to execute
sql_query = ""SELECT AVG(Quantity) AS AvgQuantityPerOrder FROM [Order Details];""

# Execute the query and get the result in a dataframe
result_df = execute_sql_query(sql_query)

# Since the result is a single value, extract and display it
avg_quantity_per_order = result_df['AvgQuantityPerOrder'].iloc[0]

# Create a dataframe to display the result
display_df = pd.DataFrame({'AvgQuantityPerOrder': [avg_quantity_per_order]})

# Show the result to the user
show_to_user(display_df)
```","```python
sql_query = """"""
SELECT AVG(quantity) AS AverageUnitsOrdered
FROM (
    SELECT OrderID, SUM(Quantity) AS quantity
    FROM [Order Details]
    GROUP BY OrderID
) AS OrderSums
""""""
average_units_ordered = execute_sql_query(sql_query)
show_to_user(average_units_ordered)
```","Both implementations calculate the average number of units ordered per order, but they do so with slightly different approaches. The reference code calculates the average directly using SQL's AVG on Quantity, while the input code first calculates the sum of quantities per order (grouping by OrderID) and then finds the average of these sums. Both methods answer the business question correctly, yielding the average number of units per order.","```python
def execute_and_fetch(sql_query: str):
    # Mock function to simulate execution of SQL query and fetching result.
    # Replace with actual implementation to connect and fetch from database.
    # Example return value assuming functionality to connect and fetch
    return 2.5  # Simulated average for demonstration

def show_to_user(data):
    # Mock function to simulate displaying data (use print, pd.DataFrame, etc.).
    print(data)

# Define the SQL query that calculates the average units per order
sql_query = """"""
    SELECT AVG([Order Details].Quantity) AS AverageUnitsPerOrder
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID;
""""""

# Execute the SQL query and fetch the result
average_units_per_order = execute_and_fetch(sql_query)

# Display the result to the user
show_to_user(average_units_per_order)
```","The input code uses a mock function `execute_and_fetch` which returns a fixed value (2.5), not the result of executing the SQL query. This does not adhere to the logic of actually querying the database to calculate the average number of units ordered per order. Additionally, the structure of the query in the input includes a JOIN, which is unnecessary for calculating the average based solely on the '[Order Details]' table as depicted in the reference implementation.",Base
Determine the total revenue generated from orders shipped to Germany.,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.ShipCountry = 'Germany';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
total_revenue = result_df['TotalRevenue'][0] if not result_df.empty else 0
show_to_user(pd.DataFrame({'TotalRevenue': [total_revenue]}))
```","```python
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE c.Country = 'Germany'
""""""

total_revenue_df = execute_sql_query(sql_query)
show_to_user(total_revenue_df)
```","The input Python code correctly calculates the total revenue from orders shipped to Germany, similar to the reference implementation. Both codes perform an SQL query that sums the product of unit price, quantity, and discount for order details where the shipment destination is Germany. Although the input code includes an extra join with the 'customers' table, it effectively filters on country like the reference code, achieving the same logical outcome.","```python
import pandas as pd

# Function to execute SQL query and get results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function; implementation needed to connect to a database
    pass  # Replace with actual implementation

# Function to display the DataFrame or processed results to the user
def show_to_user(data):
    # Implementation to display data
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        print(""Data:"", data)

# SQL query to calculate total revenue from orders shipped to Germany
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.ShipCountry = 'Germany';
""""""

# Execute the query and fetch results
revenue_df = execute_sql_query(sql_query)

# Show the revenue data to the user
show_to_user(revenue_df)
```","The input Python code correctly calculates the total revenue from orders shipped to Germany. It forms the SQL query in the same logical structure as the reference implementation by joining 'orders' and 'Order Details', calculating the revenue using UnitPrice, Quantity, and Discount, and filtering for ShipCountry = 'Germany'. The query execution and result displaying are handled similarly by using functions to execute the query and display the result. Therefore, the input code adheres to the specified business analytics request and is logically equivalent to the reference implementation.",both
Determine the freights cost totals for each month in 2023 and visualize them to identify trends.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Freight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY Month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Convert Month to datetime for proper sorting
data['Month'] = pd.to_datetime(data['Month'])

# Visualize the results
fig = px.line(data, x='Month', y='TotalFreight', title='Monthly Freight Costs in 2023', markers=True)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    SUM(Freight) AS TotalFreight
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2023
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

freight_totals_df = execute_sql_query(sql_query)

fig = px.line(freight_totals_df, x='OrderMonth', y='TotalFreight', title='Freight Cost Totals for Each Month in 2023', labels={'OrderMonth': 'Month', 'TotalFreight': 'Total Freight Cost'})
show_to_user(fig)
```","The provided code correctly implements the business analytics request. It executes an SQL query to retrieve the total freight costs for each month in 2023, grouping by month. The query uses DATE_FORMAT to extract the month and SUM to calculate total freight. The data is then visualized with a line chart using Plotly, which aligns with the reference implementation. Both codes are logically equivalent, though variable names and labels differ slightly.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch freight cost totals for each month in 2023
sql_query = """"""
SELECT MONTH(orders.OrderDate) AS month, 
       SUM(orders.Freight) AS total_freight 
FROM orders 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY MONTH(orders.OrderDate);
""""""

# Execute the SQL query and store the results in a DataFrame
freight_data = execute_sql_query(sql_query)

# Create a line plot to visualize the trend of freight costs over the months
fig = px.line(
    freight_data,
    x='month',
    y='total_freight',
    title='Monthly Freight Cost Totals for 2023',
    labels={'total_freight': 'Total Freight Cost', 'month': 'Month'},
    markers=True
)

# Show the plot to the user
show_to_user(fig)
```","The input code groups data by the numerical month rather than the year-month format. This can lead to incorrect plotting and sorting of months, especially since 'Month' as a number doesn't inherently contain year information. The reference implementation uses the '%Y-%m' format, which ensures both year and month are considered and allows for correct datetime sorting and visualization.",Base
Which categories have an average unit price above $20?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CategoryName 
FROM categories c 
JOIN products p ON c.CategoryID = p.CategoryID 
GROUP BY c.CategoryName 
HAVING AVG(p.UnitPrice) > 20;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
HAVING AVG(p.UnitPrice) > 20
""""""

result = execute_sql_query(sql_query)
show_to_user(result)
```","The input code returns CategoryID instead of CategoryName, which differs from the reference implementation that retrieves CategoryName by joining products with categories.","```python
import pandas as pd

# Assuming the execute_sql_query and show_to_user functions are defined elsewhere
# execute_sql_query(sql_query: str) -> pd.DataFrame
# show_to_user(data: pd.DataFrame)

# SQL query to get category names with average unit price above $20
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AvgUnitPrice 
FROM products 
GROUP BY CategoryID 
HAVING AVG(UnitPrice) > 20;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)
```","The input code only selects CategoryID with an average UnitPrice above $20, but it does not join with the categories table to retrieve the CategoryName. The reference code correctly retrieves the CategoryName by joining 'categories' and 'products' tables.",None
Who are the suppliers for orders placed in the first quarter of this year?,"```python
import pandas as pd

# SQL query to find suppliers for orders placed in the first quarter of 2023
sql_query = """"""
SELECT DISTINCT s.CompanyName
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query
suppliers_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(suppliers_df)
```","```python
import pandas as pd

# Define the SQL query to get suppliers for orders placed in the first quarter of this year
sql_query = """"""
SELECT DISTINCT s.SupplierID, s.CompanyName, s.ContactName, s.ContactTitle, s.Address, s.City, s.Region, s.PostalCode, s.Country, s.Phone
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT od.ProductID FROM [Order Details] od WHERE od.OrderID = o.OrderID)
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
""""""

# Execute the SQL query
suppliers_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(suppliers_data)
```","The provided code achieves the same objective as the reference code by retrieving suppliers for orders placed in the first quarter of the year. It joins the relevant tables using SQL, applies the date filter correctly, and executes the query. Although the input implementation retrieves additional columns, the core logic of finding distinct suppliers remains consistent with the reference implementation.","```python
import pandas as pd

# SQL query to fetch suppliers for orders in Q1
sql_query = """"""
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31';
""""""

# Execute the query and store the result in a DataFrame
df_suppliers = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_suppliers)
```","The input code correctly identifies the suppliers for orders placed in the first quarter of 2023. It matches the reference implementation in terms of logic, as it joins the tables 'orders', '[Order Details]', 'products', and 'suppliers' and applies the date filter to obtain distinct suppliers. The only difference is that the input code also selects 'suppliers.SupplierID', which doesn't affect the correctness of the query logic in determining the suppliers.",both
What is the total sales quantity for each product and visualize to compare performance across products?,"```python
import plotly.express as px

# Execute the SQL query to retrieve the data
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalSales FROM [Order Details] GROUP BY ProductID;""
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales quantity for each product
fig = px.bar(df, x='ProductID', y='TotalSales', title='Total Sales Quantity for Each Product')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

product_sales_df = execute_sql_query(sql_query)

fig = px.bar(product_sales_df, x='ProductName', y='TotalSalesQuantity', title='Total Sales Quantity per Product')
show_to_user(fig)
```","The input code correctly calculates the total sales quantity for each product and visualizes the data. It adheres to the same logic as the reference implementation by executing a SQL query that groups sales quantities by product and then creating a bar chart. The main difference is that it includes 'ProductName' as a group and uses it for labeling, which still answers the request and aligns with the reference logic.","
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute SQL and return DataFrame
    # Actual implementation would connect to the database, execute the query, and return results
    # This should only return dummy data for demonstration
    data = {
        'ProductID': [1, 2, 3],
        'TotalSalesQuantity': [150, 200, 120]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.scatter):
        data.show()

# SQL query to get total sales quantity per product
sql_query = '''
SELECT p.ProductID, SUM(od.Quantity) AS TotalSalesQuantity
FROM products p
INNER JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID;
'''

# Execute the SQL query and get results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales quantity for each product
fig = px.bar(df, x='ProductID', y='TotalSalesQuantity', title='Total Sales Quantity per Product')

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly executes a SQL query to sum the sales quantity for each product and organizes the data into a DataFrame. It then uses Plotly Express to create a bar chart visualizing total sales quantity per product. The main logic of summing quantities and creating the bar chart is consistent with the reference code, adhering to the business analytics request.",both
Which city has the highest number of orders?,"```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) as NumberOfOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC 
LIMIT 1;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)
```","```python
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input Python code adheres to the specified business analytics request and follows the same logic as the reference implementation. Both implementations execute an SQL query that selects the city with the highest number of orders, grouping by ShipCity and ordering by the order count in descending order, limiting the result to a single city. The key steps, like grouping, ordering by the count, and limiting to one result, are consistent in both implementations.","```python
import pandas as pd

# SQL query to find the city with the highest number of orders.
sql_query = """"""
SELECT o.ShipCity 
FROM orders o 
GROUP BY o.ShipCity 
ORDER BY COUNT(o.OrderID) DESC 
LIMIT 1;
""""""

# Execute the SQL query using the provided utility function.
city_with_most_orders = execute_sql_query(sql_query)

# Display the result to the user.
show_to_user(city_with_most_orders)
```","The input Python code produces the same outcome as the reference implementation. Both codes execute a SQL query to identify the city with the highest number of orders. They differ slightly in syntax, but both group by ShipCity, order by the count of OrderID in descending order, and limit the result to 1, which ensures that the city with the most orders is selected. Therefore, the input code is correct based on the specified request.",both
What is the average order fulfillment time for each shipping method and visualize to compare performance?,"```python
import plotly.express as px

# SQL query to fetch the relevant data
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY ShipVia;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Rename columns if necessary
df.columns = ['ShipVia', 'AverageFulfillmentTime']

# Create a visualization to compare average fulfillment times
fig = px.bar(df, x='ShipVia', y='AverageFulfillmentTime', title='Average Order Fulfillment Time by Shipping Method')

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY ShipVia
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)

fig = px.bar(average_fulfillment_time_df, x='ShipVia', y='AverageFulfillmentTime',
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'})

show_to_user(fig)
```","The input code uses 'DATEDIFF(ShippedDate, OrderDate)' which is inconsistent with the reference code's 'DATEDIFF(day, OrderDate, ShippedDate)'. This implies a reversed order in date subtraction, potentially leading to negative fulfillment times if not corrected, resulting in incorrect average calculations.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT o.ShipVia, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgFulfillmentTime 
FROM orders o 
GROUP BY o.ShipVia;
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize average order fulfillment time by shipping method
fig = px.bar(df, x='ShipVia', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)', 'ShipVia': 'Shipping Method'})

# Display the results using the utility function
show_to_user(fig)
```","The provided code correctly matches the business request to calculate the average order fulfillment time by shipping method. It uses a SQL query similar to the reference implementation to compute this average. Although the format of the DATEDIFF function differs slightly in terms of argument order, both implementations achieve the same calculation, where the SQL dialect assumes the order of arguments results in the same difference. Additionally, the visualization part correctly uses Plotly to create a bar chart comparing average fulfillment times, which aligns with the request and reference code's logic.",Finetuned
Which customers have placed orders in the last month?,"```python
import pandas as pd

# Define the SQL query to get customers who placed orders in the last month.
sql_query = ""SELECT CustomerID FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);""

# Execute the SQL query and retrieve the data.
df_customers = execute_sql_query(sql_query)

# Remove duplicate CustomerIDs if any.
df_unique_customers = df_customers.drop_duplicates()

# Display the customer data to the user.
show_to_user(df_unique_customers)
```","```python
from datetime import datetime, timedelta

one_month_ago = (datetime.now() - timedelta(days=30)).date()

sql_query = f""""""
SELECT DISTINCT CustomerID
FROM orders
WHERE OrderDate >= '{one_month_ago}'
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)
```","The input code correctly retrieves customers who have placed orders in the last month by using a SQL query to filter orders based on the `OrderDate`. It then uses `DISTINCT` to ensure customer IDs are unique, similar to dropping duplicates in the reference code. The logic of calculating one month ago using `datetime` functions and filtering the SQL query is equivalent to the reference implementation's logic using `DATE_SUB` in SQL. Thus, the input code satisfies the requirement of the business analytics request.","```python
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DISTINCT c.CustomerID 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH);
""""""

# Execute the query to get the data
customer_orders_df = execute_sql_query(sql_query)

# Display the results
show_to_user(customer_orders_df)
```","The input code correctly retrieves customers who placed orders in the last month. It joins the 'customers' and 'orders' tables, retains CustomerIDs from the orders made in the last month, and ensures uniqueness by using 'SELECT DISTINCT'. This aligns with the reference implementation's logic by effectively removing duplicates and retrieving relevant CustomerIDs. Both approaches display the unique customer list, thus fulfilling the business request.",both
List customers who have placed orders within the last 30 days.,"```python
import pandas as pd

# SQL query to get customers who have placed orders in the last 30 days
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders 
WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY);
""""""

# Execute the SQL query
customers_last_30_days = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_last_30_days)
```","```python
from datetime import datetime, timedelta

# Calculate the date 30 days ago from today
date_30_days_ago = (datetime.now() - timedelta(days=30)).date()

# SQL query to retrieve customers who have placed orders in the last 30 days
sql_query = f""""""
SELECT DISTINCT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, 
                c.City, c.Region, c.PostalCode, c.Country, c.Phone
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate >= '{date_30_days_ago}'
""""""

# Execute the SQL query
customers_last_30_days = execute_sql_query(sql_query)

# Show results to user
show_to_user(customers_last_30_days)
```","The input code retrieves additional customer fields such as CompanyName, ContactName, ContactTitle, Address, City, Region, PostalCode, Country, and Phone, while the reference implementation only retrieves CustomerID. This difference in the query results in more information than requested, deviating from the reference implementation's focus.","```python
import pandas as pd
from datetime import datetime, timedelta

# Define the SQL query to find customers who have placed orders within the last 30 days
sql_query = """"""
SELECT DISTINCT customers.CustomerID 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate >= CURDATE() - INTERVAL 30 DAY
""""""

# Execute the SQL query to retrieve the data into a DataFrame
customers_recent_orders_df = execute_sql_query(sql_query)

# Display the results to the user in the required format
show_to_user(customers_recent_orders_df)
```","Both the reference code and the input code correctly query customers who have placed orders in the last 30 days. The input code uses a JOIN on the customers table, but it still follows the same logic of checking the 'OrderDate' within the last 30 days. The use of 'JOIN' does not affect the correctness as it achieves the same outcome as the reference implementation.",Finetuned
What are the names and unit prices of all products?,"```python
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products;""

# Execute the query and get the results in a DataFrame
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)
```","```python
sql_query = ""SELECT ProductName, UnitPrice FROM products""
products_data = execute_sql_query(sql_query)
show_to_user(products_data)
```","The input code correctly formulates the SQL query to select 'ProductName' and 'UnitPrice' from the 'products' table. It calls 'execute_sql_query' with this query, and then uses 'show_to_user' to display the results, which aligns with the logic and intent of the reference implementation.","```python
# Provided utility function to execute SQL queries and fetch results
def execute_sql_query(sql_query: str):
    # This is a dummy implementation; the actual implementation would interface with a database
    pass

# Provided utility function to display results
def show_to_user(data):
    # This is a dummy implementation; the actual implementation would display data to the user in a suitable format
    pass

# Utility function to get product details
def fetch_product_details():
    # SQL query to fetch product names and unit prices
    sql_query = ""SELECT ProductName, UnitPrice FROM products;""
    
    # Execute the SQL query
    product_data = execute_sql_query(sql_query)
    
    # Show the data to the user
    show_to_user(product_data)

# Fetch and display product details
fetch_product_details()
```",The input code correctly implements the business analytics request by using an SQL query to retrieve 'ProductName' and 'UnitPrice' from the 'products' table and displays it using the provided functions. It adheres to the logic of the reference implementation.,both
Find the monthly sales performance for each product and visualize to identify sales trends.,"```python
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    EXTRACT(MONTH FROM o.OrderDate) AS Month, 
    SUM(od.Quantity) AS MonthlySales 
FROM [Order Details] od 
JOIN products p 
ON od.ProductID = p.ProductID 
JOIN orders o 
ON od.OrderID = o.OrderID 
GROUP BY p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as an integer for correct x-axis ordering
df['Month'] = df['Month'].astype(int)

# Create the visualization
fig = px.line(
    df, 
    x='Month', 
    y='MonthlySales', 
    color='ProductName',
    labels={'MonthlySales': 'Monthly Sales', 'Month': 'Month'},
    title='Monthly Sales Performance for Each Product'
)

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity) AS TotalQuantity, 
    SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, 
    Month
ORDER BY 
    Month, 
    p.ProductID;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='Month', y='TotalSales', color='ProductName', title='Monthly Sales Performance by Product')
show_to_user(fig)
```","The input code calculates 'TotalSales' (quantity * unit price) instead of 'MonthlySales' (sum of quantity), lacks conversion of 'Month' to integer, and uses DATE_FORMAT for 'Month' causing it to differ from extracting just the month as integer for x-axis ordering. These deviations lead to differences in both data representation and visualization logic compared to the reference implementation.","To analyze and visualize the monthly sales performance for each product, you can follow these steps with the provided Python utility functions:

1. **Define the SQL Query**: You'll need to aggregate the data monthly by each product.
2. **Execute the SQL Query**: Use the `execute_sql_query` function to retrieve the data.
3. **Visualize the Results**: Use the `show_to_user` function to display useful visualizations.

Here's how you can implement that:

```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get monthly sales per product
sql_query = """"""
SELECT 
    p.ProductName, 
    EXTRACT(YEAR FROM o.OrderDate) AS year, 
    EXTRACT(MONTH FROM o.OrderDate) AS month, 
    SUM(od.Quantity) AS total_sales 
FROM 
    products p 
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID 
JOIN 
    orders o ON od.OrderID = o.OrderID 
GROUP BY 
    p.ProductName, year, month 
ORDER BY 
    year, month;
""""""

# Execute the query to get the data in a DataFrame
df = execute_sql_query(sql_query)

# Creating a new column for visualization
df['YearMonth'] = df['year'].astype(str) + '-' + df['month'].astype(str)

# Plotting the sales trend for each product over time
fig = px.line(
    df,
    x='YearMonth',
    y='total_sales',
    color='ProductName',
    title='Monthly Sales Performance for Each Product',
    labels={'total_sales': 'Total Sales', 'YearMonth': 'Year-Month'}
)

# Show the plot to the user
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: This selects the product name, year, month, and calculates total sales by summing up the quantities from order details.
  
2. **Data Retrieval**: The `execute_sql_query` function executes the SQL statement and returns the results as a `pandas` DataFrame, which is stored in `df`.

3. **Data Processing**: A new column `YearMonth` is created by concatenating year and month for easier plotting.

4. **Plotting**: The code uses Plotly to create a line chart to present monthly sales trends for each product.

5. **Displaying Output**: Finally, `show_to_user` displays the resulting plot. 

Make sure that the utility functions (`execute_sql_query` and `show_to_user`) are correctly defined in your environment for the above code to function properly.","The provided code calculates sales grouped by both year and month, creating a 'YearMonth' column for visualization. This deviates from the reference code that groups only by month, directly using the extracted month for visualization. While both aim to show sales trends over time, the input code's logic leads to a more granular time grouping, potentially altering the intended analysis focus on monthly trends per year independently.",None
What is the total sales revenue generated last month?,"```python
# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales_Revenue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH)
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales revenue from the result
total_sales_revenue = result_df.loc[0, 'Total_Sales_Revenue']

# Show the result to the user
show_to_user(total_sales_revenue)
```","```python
from datetime import datetime, timedelta
import pandas as pd

today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

sql_query = f""""""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
AND o.OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
""""""

total_sales_df = execute_sql_query(sql_query)
show_to_user(total_sales_df)
```","The provided code correctly calculates the total sales revenue for the last month. It defines the start and end dates for the previous month correctly and uses those dates in the SQL query to filter the orders. The calculation of the total sales by summing up the product of UnitPrice, Quantity, and discount is the same as the reference implementation. The only difference is in how the dates are calculated, but it achieves the same result.","```python
# Example Python utility function to execute SQL queries
def execute_sql_query(sql_query: str):
    # Placeholder function implementation; for demonstration purposes only
    # In a real scenario, this function would connect to a database and execute the query
    pass

# Assume this utility function prints the calculated value to the user
def print_to_user(value):
    print(f""Total sales revenue generated last month: {value}"")

# SQL query to calculate total sales revenue for last month
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    DATEPART(MONTH, orders.OrderDate) = DATEPART(MONTH, GETDATE()) - 1 
    AND DATEPART(YEAR, orders.OrderDate) = DATEPART(YEAR, GETDATE());
""""""

# Execute the SQL query
total_sales_revenue = execute_sql_query(sql_query)

# Print the total sales revenue to the user
print_to_user(total_sales_revenue)
```","The input code incorrectly calculates the previous month. It uses 'DATEPART(MONTH, GETDATE()) - 1' which fails to account for January rollover, potentially returning zero for December's month. The reference code correctly handles this by using MONTH(CURRENT_DATE - INTERVAL 1 MONTH) and YEAR(CURRENT_DATE - INTERVAL 1 MONTH) to account for year-end transition. Additionally, 'print_to_user' may not properly print the SQL result since 'execute_sql_query' appears to return nothing.",Base
"Which employees have handled the most orders, and can this be illustrated using a bar chart to compare the number of orders handled by each employee?","```python
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrdersHandled
FROM orders
GROUP BY EmployeeID
ORDER BY OrdersHandled DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='EmployeeID', y='OrdersHandled', title='Number of Orders Handled by Each Employee')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) as OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""
employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='EmployeeID', y='OrderCount', 
             title='Number of Orders Handled by Each Employee', 
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'},
             text='OrderCount')

show_to_user(fig)
```","The input code is functionally equivalent to the reference code. It executes a SQL query that counts the number of orders handled by each employee, sorted in descending order. Both codes assign the correct aliases to the resulting columns. While the input code uses different labels in the bar chart and adds text annotations, these differences do not affect the logical correctness or the business objective of illustrating employee performance in handling orders.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute SQL query
    pass

def show_to_user(data):
    # Placeholder function to display data or plot
    pass

# SQL query to fetch employees and their order counts
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY NumberOfOrders DESC
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='NumberOfOrders', title='Orders Handled by Employees')

# Display the bar chart
show_to_user(fig)
```",The evaluated code is correct because it performs the same logical operations as the reference code. Both versions execute a SQL query to count the number of orders handled by each employee and return the results ordered in descending order. They then use Plotly Express to generate a bar chart that visualizes the number of orders handled by each employee. The differences in alias names (OrdersHandled vs. NumberOfOrders) and JOIN statement do not affect the logic or output of the code.,both
