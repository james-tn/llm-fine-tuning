Business Analytic Request,Ground Truth Code,Generated Code by Base Model,Explanation by Base Model,Generated Code by Finetuned Model,Explanation by Finetuned Model,Model that got it right
What was the average order value in Q1 of 2023?,"import pandas as pd

# SQL query to get the total value of orders and the count of unique orders in Q1 of 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AvgOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Create a final dataframe to show the result
final_df = pd.DataFrame({'AvgOrderValue': [result_df['AvgOrderValue'].iloc[0]]})

# Display the result to the user
show_to_user(final_df)","import pandas as pd

# Define the SQL query to calculate the Average Order Value in Q1 2023
sql_query = '''
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS AverageOrderValue
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    orders.OrderDate >= '2023-01-01' AND 
    orders.OrderDate < '2023-04-01'
''' 

# Execute the SQL query and store the result in a pandas dataframe
average_order_value_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_order_value_df)","The evaluated code correctly calculates the average order value in Q1 of 2023 by summing the products of unit prices, quantities, and discounts, then dividing by the count of distinct orders within the specified date range. The date condition is equivalent to the reference implementation, and the method to display the result is also satisfied.","To calculate the average order value in Q1 of 2023, we need to follow these steps:

1. Retrieve the sales data from the `orders` and `order_details` tables for Q1 2023.
2. Calculate the total revenue for Q1 2023 by summing the product of quantity and unit price.
3. Get the total number of orders in Q1 2023.
4. Divide the total revenue by the total number of orders to get the average order value.

Here is the Python code that implements this logic:

```python
import pandas as pd

# SQL query to get the total revenue and number of orders in Q1 2023
sql_query = '''
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity) AS total_revenue,
    COUNT(DISTINCT orders.OrderID) AS order_count
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the SQL query and get the result as a dataframe
df = execute_sql_query(sql_query)

# Ensure that the dataframe has only one row with the total revenue and order count
if not df.empty:
    total_revenue = df.iloc[0]['total_revenue']
    order_count = df.iloc[0]['order_count']
    # Calculate the average order value
    average_order_value = total_revenue / order_count if order_count else 0
    # Create a dataframe to display
    result_df = pd.DataFrame({
        'average_order_value': [average_order_value],
        'total_revenue': [total_revenue],
        'order_count': [order_count]
    })
    # Display the result to the user
    show_to_user(result_df)
else:
    print(""No data available for Q1 2023"")
```

This code executes the SQL query to retrieve data for the specified period, calculates the average order value, total revenue, and order count, then displays the result to the user. The error handling ensures the code runs smoothly even if there's no data.","The input code does not account for discounts in calculating total revenue, unlike the reference code.",Base
Which products have the lowest units in stock?,"import pandas as pd
import plotly.express as px

# SQL Query to get products with the lowest units in stock
sql_query = 'SELECT ProductID, ProductName, UnitsInStock FROM products ORDER BY UnitsInStock ASC LIMIT 1;'

# Execute the SQL query to get the data
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)
","import pandas as pd

# SQL query to retrieve products with the lowest units in stock
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
ORDER BY UnitsInStock ASC
LIMIT 10;  -- Adjust the limit as needed
""""""

# Execute the SQL query
low_stock_products = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(low_stock_products)","The input code retrieves the top 10 products with the lowest units in stock instead of just the single product requested by the business analytic. Therefore, it does not match the outcome of the reference implementation.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL Query to retrieve products with the lowest units in stock
sql_query = 'SELECT ProductName, UnitsInStock FROM products ORDER BY UnitsInStock ASC LIMIT 5;'

# Execute the SQL query and get the result as a pandas dataframe
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)

# Additionally, visualize the result with a bar chart
fig = px.bar(products_df, x='ProductName', y='UnitsInStock', title='Products with the Lowest Units in Stock', labels={'ProductName':'Product Name', 'UnitsInStock':'Units In Stock'})
show_to_user(fig)","The input code selects the 5 products with the lowest stock, while the reference implementation selects only the single product with the lowest stock.",None
Which customers placed the highest number of orders last year? Include a data visualization to compare the number of orders placed by these customers.,"
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY CustomerID 
ORDER BY OrderCount DESC
'''

# Execute the SQL query to retrieve data
customer_orders_df = execute_sql_query(sql_query)

# Check if the dataframe has the required columns
if 'CustomerID' in customer_orders_df.columns and 'OrderCount' in customer_orders_df.columns:
    # Generate a plotly bar chart for data visualization
    fig = px.bar(customer_orders_df, x='CustomerID', y='OrderCount', title='Number of Orders by Customer Last Year', labels={'CustomerID':'Customer ID', 'OrderCount':'Order Count'}, text_auto=True)
    
    # Show the visualization to the user
    show_to_user(fig)
else:
    show_to_user(customer_orders_df)
","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to retrieve the top customers by number of orders
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 10
''' 

# Step 2: Execute the SQL query using the provided utility function
order_counts = execute_sql_query(sql_query)

# Step 3: Create a bar chart to visualize the number of orders placed by these customers
fig = px.bar(order_counts, x='CustomerID', y='OrderCount', 
             title='Top Customers by Number of Orders Last Year', 
             labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Step 4: Show the plot to the user
show_to_user(fig)","The input code calculates orders from the last 365 days by using 'DATE_SUB(CURDATE(), INTERVAL 1 YEAR)', which isn't the same as orders from the last calendar year defined by 'YEAR(OrderDate) = YEAR(CURDATE()) - 1' in the reference. This may lead to different results.","import pandas as pd
import plotly.express as px

# SQL query to get the customer orders from the last year
sql_query = '''
SELECT o.CustomerID, COUNT(*) AS NumberOfOrders 
FROM orders o 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY o.CustomerID 
ORDER BY NumberOfOrders DESC;
'''

# Execute the SQL query
customer_orders_df = execute_sql_query(sql_query)

# Create a bar chart using plotly to visualize the number of orders
fig = px.bar(customer_orders_df, x='CustomerID', y='NumberOfOrders', 
             title='Number of Orders Placed by Customers Last Year', 
             labels={'CustomerID': 'Customer ID', 'NumberOfOrders': 'Number of Orders'})

# Display the plot
show_to_user(fig)","The input code correctly addresses the business analytic request by querying customers who placed the highest number of orders last year. It uses the same logic to filter orders by the previous year and groups by CustomerID to count the orders. A bar chart is created with Plotly to visualize the number of orders, fulfilling the request effectively.",Finetuned
Calculate the total revenue generated by each product. Use a bar chart to illustrate the revenue generated by each product.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName;
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the revenue generated by each product
fig = px.bar(result_df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product', labels={'ProductName': 'Product Name', 'TotalRevenue': 'Total Revenue'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue generated by each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalRevenue DESC
'''  

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(result_df, x='ProductName', y='TotalRevenue', title='Total Revenue Generated by Each Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'},
             color='TotalRevenue')

# Display the bar chart to the user
show_to_user(fig)",The input code includes a discount in the revenue calculation which is not present in the reference implementation. This could result in different total revenue values.,"import plotly.express as px

# Step 1: Write the SQL query
sql_query = '''
SELECT p.ProductID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
GROUP BY p.ProductID;
'''

# Step 2: Fetch the data using the provided utility function
df = execute_sql_query(sql_query)

# Step 3: Generate the bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product', labels={'ProductID':'Product ID', 'TotalRevenue':'Total Revenue ($)'})

# Step 4: Display the result using the provided utility function
show_to_user(fig)","The input code differs from the reference implementation in how it uses 'ProductID' instead of 'ProductName' to group the data. The reference implementation requires grouping by 'ProductName' to correctly address the business analytic request. Therefore, the input code does not achieve the same outcome as expected by the business request.",None
Which customers are from the United States?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT CustomerID FROM orders WHERE ShipCountry = 'USA'""

# Execute the query to get the dataframe
customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_df)","import pandas as pd

# SQL query to retrieve customers from the United States
sql_query = """"""
SELECT DISTINCT CustomerID
FROM orders
WHERE ShipCountry = 'USA'
""""""

# Execute the query and get the results in a dataframe
customers_us = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(customers_us)","The input code correctly retrieves distinct CustomerIDs for customers from the United States using the 'ShipCountry = USA' condition and displays the result, which aligns with the business request and reference implementation.","import pandas as pd

# SQL query to get customers from the United States
sql_query = ""SELECT * FROM customers WHERE Country = 'USA';""

# Execute the SQL query
customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_df)","The input code filters customers based on the 'Country' column in the 'customers' table instead of 'ShipCountry' in the 'orders' table. This does not match the reference implementation or fulfill the request, which specifies customers identified by orders shipped to the USA.",Base
List the products that are being sold at a discount (UnitPrice in orders < UnitPrice in products).,"import pandas as pd
import plotly.express as px

# Define the SQL query based on the given business request
sql_query = '''
SELECT p.ProductName 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
WHERE od.UnitPrice < p.UnitPrice;
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the resulting data to the user
show_to_user(result_df)","import pandas as pd

# Query to get products sold at a discount
sql_query = '''
SELECT p.ProductID, p.ProductName, p.UnitPrice AS OriginalPrice, od.UnitPrice AS DiscountedPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.UnitPrice < p.UnitPrice
'''  

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to user
show_to_user(result_df)","The evaluated code correctly implements the business analytic request by listing products sold at a discount by comparing 'UnitPrice' from 'Order Details' to 'UnitPrice' in 'products'. The output includes additional details like ProductID, OriginalPrice, and DiscountedPrice, which are not required for correctness but do not affect the requested outcome.","import pandas as pd
import plotly.express as px

# SQL query to find products sold at a discount
sql_query = '''
SELECT p.ProductID, p.ProductName 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
WHERE od.UnitPrice < p.UnitPrice;
'''

# Execute the SQL query
products_on_discount = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(products_on_discount)","The input code correctly addresses the business analytic request. It retrieves a list of products being sold at a discount by comparing 'UnitPrice' in the 'Order Details' with the 'UnitPrice' in 'products'. The output includes 'ProductID' and 'ProductName', which is slightly more detailed than the reference code, but it still achieves the desired outcome of identifying discounted products.",Base
Which employees generated the highest sales revenue in April 2023? Provide a visualization to compare the sales revenue generated by these employees.,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the data
sql_query = '''
SELECT employees.FirstName, employees.LastName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC
'''

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Concatenate first name and last name to create a full name column
sales_data['EmployeeName'] = sales_data['FirstName'] + ' ' + sales_data['LastName']

# Create the bar chart visualization using Plotly
fig = px.bar(sales_data, x='EmployeeName', y='total_sales', title='Total Sales Revenue by Employee in April 2023', labels={'total_sales': 'Total Sales Revenue', 'EmployeeName': 'Employee Name'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to get employee sales for April 2023
sql_query = '''
SELECT employees.EmployeeID, 
       CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID, EmployeeName 
ORDER BY total_sales DESC;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(result_df)

# Create a bar chart for visualization
fig = px.bar(result_df, x='EmployeeName', y='total_sales', title='Top Employees by Sales Revenue in April 2023',
             labels={'total_sales':'Total Sales Revenue', 'EmployeeName':'Employee Name'},
             color='total_sales')

# Display the figure
show_to_user(fig)","The input code effectively fulfills the business analytic request. It retrieves employees' sales data for April 2023, calculates the total sales for each employee, and visualizes the results using a bar chart. The approach aligns with the reference implementation's outcome, despite minor differences, such as concatenating names directly in the SQL query.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales_total 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY employees.EmployeeID 
ORDER BY employee_sales_total DESC
""""""

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales revenue generated by each employee
fig = px.bar(
    sales_data,
    x='EmployeeID',
    y='employee_sales_total',
    title='Employee Sales Revenue in April 2023',
    labels={'EmployeeID': 'Employee ID', 'employee_sales_total': 'Sales Revenue'},
    text='employee_sales_total'
)

# Update the layout to improve readability
fig.update_layout(
    xaxis_title='Employee ID',
    yaxis_title='Sales Revenue',
    xaxis={'categoryorder': 'total descending'},
    template='plotly_white'
)

# Display the visualization
show_to_user(fig)","The input code does not include employee names in the analysis, making it difficult to determine which employees generated the highest sales. It only retrieves EmployeeID, whereas the reference code concatenates first and last names to form full employee names, providing clearer insights.",Base
What is the average order value handled by each employee? Use a bar chart to compare the average order value handled by each employee.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT employees.EmployeeID, AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderValue 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
'''

# Execute SQL Query to retrieve data
employee_order_data = execute_sql_query(sql_query)

# Create a bar chart for average order value handled by each employee
fig = px.bar(employee_order_data, x='EmployeeID', y='AvgOrderValue', title='Average Order Value Handled by Each Employee')

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve employees and their average order values based on order details
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
'''

# Execute the SQL query and retrieve the data
average_order_value_df = execute_sql_query(sql_query)

# Create a bar chart with Plotly
fig = px.bar(average_order_value_df,
             x='EmployeeID',
             y='AverageOrderValue',
             title='Average Order Value Handled by Each Employee',
             labels={'AverageOrderValue': 'Average Order Value', 'EmployeeID': 'Employee ID'},
             text='AverageOrderValue')

# Show plot to the user
show_to_user(fig)","The input code retrieves the average order value handled by each employee similar to the reference code. While it additionally includes employee names in the SQL query, this does not affect the computed averages or the bar chart visualization. Both codes achieve the same outcome: a bar chart comparing average order values per employee.","To retrieve the average order value handled by each employee from the MDDX database and visualize it using a bar chart, we can achieve this using the following steps:

1. **Execute the SQL Query**: Use the provided SQL query to fetch the data.
2. **Process the Data**: Calculate the average order value for each employee.
3. **Visualize the Data**: Use a bar chart to represent the data using Plotly.

Here's how you can do it in Python:

```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check that the dataframe is loaded correctly
if df.empty:
    raise ValueError('The SQL query returned an empty dataframe.')

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='AverageOrderValue', title='Average Order Value Handled by Each Employee', labels={'EmployeeID': 'Employee ID', 'AverageOrderValue': 'Average Order Value'})

# Show the plot to the user
show_to_user(fig)
```

In this code:

- We execute the provided SQL query using the `execute_sql_query` function.
- We check if the resulting dataframe is empty and raise an error if it is.
- We create a bar chart using `plotly.express`.
- Finally, we display the plot using the `show_to_user` function.","The input code correctly implements the required functionality as specified in the business analytic request. It executes the same SQL query to calculate the average order value handled by each employee and uses Plotly to visualize it as a bar chart. The key logic and result match with the reference implementation, despite minor differences in variable naming or error handling.",Base
Find the total revenue generated by each product. Use a bar chart to illustrate the revenue generated by each product.,"import pandas as pd
import plotly.express as px

# Define and execute the SQL query
sql_query = 'SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue FROM [Order Details] GROUP BY ProductID;'
df = execute_sql_query(sql_query)

# Generate the bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product', labels={'ProductID': 'Product ID', 'TotalRevenue': 'Total Revenue'})

# Display the chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue generated by each product
sql_query = '''
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalRevenue DESC;
'''

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Create a bar chart visualization for the revenue data
fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue',
             title='Total Revenue Generated by Each Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the total revenue generated by each product, including discounts. It adds more detail by also displaying the product name and orders the result by revenue, which aligns with the business request. The visualization is effectively created using Plotly and displayed using the provided utility function.","import plotly.express as px

# SQL query to get the total revenue generated by each product
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM [Order Details] od
INNER JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName;
'''

# Execute the SQL query and retrieve data into a pandas dataframe
# Assume execute_sql_query function is already defined as per the environment given
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the revenue generated by each product
fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Total Revenue Generated by Each Product')

# Show the bar chart to the user
# Assume show_to_user function is already defined as per the environment given
show_to_user(fig)
","The input code correctly calculates the total revenue for each product, including an additional step of joining with the products table for product names. The output is visualized as a bar chart using Plotly, effectively addressing the business analytic request.",Base
Calculate the inventory turnover ratio for each month. Create a line graph to show the inventory turnover ratio trend over the months.,"import pandas as pd
import plotly.express as px

# SQL query to calculate the inventory turnover ratio for each month
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as Month, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) as InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
'''

# Execute the SQL query to retrieve data
inventory_turnover_df = execute_sql_query(sql_query)

# Ensure that the Month column is interpreted as a date
inventory_turnover_df['Month'] = pd.to_datetime(inventory_turnover_df['Month'], format='%Y-%m')

# Sort the dataframe by 'Month'
inventory_turnover_df = inventory_turnover_df.sort_values(by='Month')

# Create the line graph using plotly
fig = px.line(inventory_turnover_df, x='Month', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio Trend Over Months')

# Display the line graph to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate Inventory Turnover Ratio
sql_query = '''
SELECT
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.Quantity * od.UnitPrice) AS COGS,
    AVG(p.UnitsInStock) AS AvgInventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio
FROM
    [Order Details] od
JOIN
    products p ON od.ProductID = p.ProductID
JOIN
    orders o ON od.OrderID = o.OrderID
GROUP BY
    month
ORDER BY
    month;
'''

# Execute the SQL query and retrieve the data
inventory_turnover_df = execute_sql_query(sql_query)

# Creating a line graph to show the inventory turnover ratio trend over the months
fig = px.line(inventory_turnover_df, x='month', y='InventoryTurnoverRatio',
              title='Inventory Turnover Ratio Trend Over Months',
              labels={'month': 'Month', 'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

# Show the graph to the user
show_to_user(fig)",The input code correctly calculates the inventory turnover ratio for each month and creates a line graph to show the trend over the months. It follows the business analytic request and achieves the same outcome as the reference implementation. The slight difference in SQL syntax (`DATE_TRUNC` vs. `DATE_FORMAT`) and extra validation with `NULLIF` for division by zero do not affect the correctness of the analysis.,"import pandas as pd
import plotly.express as px

# SQL Query to calculate inventory turnover ratio for each month
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY Month;'''

# Execute the SQL query
inventory_turnover_df = execute_sql_query(sql_query)

# Ensure the 'Month' column is sorted in chronological order
inventory_turnover_df['Month'] = pd.to_datetime(inventory_turnover_df['Month'], format='%Y-%m')
inventory_turnover_df = inventory_turnover_df.sort_values(by='Month')

# Create a line graph to show the inventory turnover ratio trend over the months
fig = px.line(inventory_turnover_df, x='Month', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio Trend Over Months', labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'Month': 'Month'})

# Show the result to the user
show_to_user(fig)","The input code correctly calculates the inventory turnover ratio for each month and creates a line graph to show the trend over the months. It follows the logic of the reference code in terms of data retrieval, processing, and visualization. The inclusion of an additional join with the 'orders' table does not affect the correctness of the result as the necessary data columns are still correctly used to calculate the inventory turnover ratio. Therefore, the code fulfills the business analytic request effectively.",Base
What is the performance of products based on sales and inventory levels for each month in 2022? Use a combined bar and line chart to illustrate sales and inventory levels.,"import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# Define the SQL query
sql_query = '''
SELECT products.ProductID, MONTH(orders.OrderDate) AS order_month, 
       SUM([Order Details].Quantity) AS product_performance 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, order_month
'''

# Execute the query and get a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Aggregate sales performance per month
monthly_sales = sales_data.groupby('order_month').agg({'product_performance': 'sum'}).reset_index()

# Assuming we have a way to get inventory levels per month
# This part of the data is not provided by the SQL query and needs to be fetched separately
# For the purpose of this example, we will create a placeholder dataframe for inventory levels
inventory_levels = pd.DataFrame({
    'order_month': range(1, 13),
    'inventory_level': [1000, 850, 900, 950, 1100, 1050, 1150, 1200, 750, 800, 950, 1000]
})

# Combine sales and inventory data
combined_data = pd.merge(monthly_sales, inventory_levels, on='order_month')

# Create the combined bar and line chart
fig = go.Figure()

# Add bar chart for sales performance
fig.add_trace(go.Bar(
    x=combined_data['order_month'],
    y=combined_data['product_performance'],
    name='Product Performance',
    marker_color='indigo'
))

# Add line chart for inventory levels
fig.add_trace(go.Scatter(
    x=combined_data['order_month'],
    y=combined_data['inventory_level'],
    name='Inventory Level',
    mode='lines+markers',
    marker_color='gold'
))

# Customize layout
fig.update_layout(
    title='Monthly Product Performance and Inventory Levels for 2022',
    xaxis=dict(title='Month'),
    yaxis=dict(title='Quantity'),
    barmode='group'
)

# Show the plot to the user
show_to_user(fig)
","import pandas as pd
import plotly.graph_objects as go

# SQL query to retrieve monthly total sales and inventory levels for the year 2022
sql_query = '''
SELECT  
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,  
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales,  
    SUM(products.UnitsInStock) AS total_inventory  
FROM orders  
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID  
JOIN products ON [Order Details].ProductID = products.ProductID  
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'  
GROUP BY month
'''

# Execute SQL query to get the data
monthly_data = execute_sql_query(sql_query)

# Create a combined bar and line chart
fig = go.Figure()

# Add bar for total sales
fig.add_trace(go.Bar(x=monthly_data['month'], y=monthly_data['total_sales'], name='Total Sales'))

# Add line for total inventory
fig.add_trace(go.Scatter(x=monthly_data['month'], y=monthly_data['total_inventory'], name='Total Inventory', mode='lines+markers'))

# Update layout
fig.update_layout(
    title='Monthly Product Performance (Sales & Inventory) in 2022',
    xaxis_title='Month',
    yaxis_title='Amount',
    barmode='group'
)

# Show the resulting plot to the user
show_to_user(fig)","The input code calculates total sales based on price and discount, which differs from the reference code focusing solely on quantity (performance). Also, 'total inventory' is computed from 'UnitsInStock' which may reflect current stock, not monthly changes.","To visualize the performance of products based on sales and inventory levels for each month in 2022, you can use a combined bar and line chart in Python. Here's what you need to do step-by-step.

First, execute the SQL query to obtain the required data. Then, process that data to create a combined bar and line chart using Plotly. This chart will represent sales as bars and inventory levels as a line.

### Step 1: Execute SQL Query

The SQL query provided in the request will fetch the sales and inventory data. We will use the given utility function `execute_sql_query` to execute the SQL query.

The SQL query:
```sql
SELECT MONTH(OrderDate) as OrderMonth,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales,
    products.UnitsInStock AS InventoryLevel
FROM [Order Details]
INNER JOIN products ON [Order Details].ProductID = products.ProductID
WHERE YEAR(OrderDate) = 2022
GROUP BY MONTH(OrderDate);
```

### Step 2: Create the Combined Bar and Line Chart

1. **Import required libraries.**
2. **Fetch the data using the provided SQL query.**
3. **Process the data into a format suitable for plotting.**
4. **Generate the combined bar and line chart.**
5. **Display the chart using the provided utility function.**

### Complete Python Code
```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT MONTH(OrderDate) as OrderMonth,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales,
    products.UnitsInStock AS InventoryLevel
FROM [Order Details]
INNER JOIN products ON [Order Details].ProductID = products.ProductID
WHERE YEAR(OrderDate) = 2022
GROUP BY MONTH(OrderDate);
""""""

# Execute the SQL query to retrieve data
sales_inventory_data = execute_sql_query(sql_query)

# Sort by OrderMonth to ensure the plot is in the correct order
sales_inventory_data = sales_inventory_data.sort_values(by='OrderMonth')

# Create a combined bar and line chart
fig = px.bar(sales_inventory_data, x='OrderMonth', y='TotalSales', title='Sales and Inventory Levels for Each Month in 2022')
fig.add_scatter(x=sales_inventory_data['OrderMonth'], y=sales_inventory_data['InventoryLevel'], mode='lines+markers', name='Inventory Level')

# Show the figure to the user
show_to_user(fig)
```

### Explanation of the Code
- The code defines a SQL query to get Total Sales and Inventory Level for each month of 2022.
- Then, it executes the SQL query and retrieves the data into a pandas dataframe.
- After sorting the dataframe by month, a combined bar and line chart is created using Plotly.
- The bar chart represents Total Sales, while the line chart represents Inventory Level.
- Lastly, the generated plot is displayed to the user with `show_to_user`.

Make sure to run this code in an environment where you have access to the `execute_sql_query` and `show_to_user` utility functions, as well as the Plotly and pandas libraries installed.","The input code incorrectly assumes that 'UnitsInStock' can be used for inventory levels by month, which may not accurately reflect monthly inventory changes. Additionally, 'UnitsInStock' is aggregated incorrectly under the 'GROUP BY' clause.",None
What is the total sales revenue generated by each customer? Provide a visualization to compare the sales revenue generated by each customer.,"import pandas as pd
import plotly.express as px

# SQL query to get the total sales revenue generated by each customer
sql_query = '''
SELECT CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY CustomerID 
ORDER BY TotalSales DESC;
'''

# Execute the SQL query and retrieve the data in a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Visualize the sales revenue generated by each customer using a bar chart
fig = px.bar(sales_data, x='CustomerID', y='TotalSales', title='Total Sales Revenue by Customer', labels={'CustomerID':'Customer ID', 'TotalSales':'Total Sales Revenue'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to get total sales by each customer
sql_query = '''
SELECT o.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID
'''  

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Visualize the total sales by each customer
fig = px.bar(sales_data, x='CustomerID', y='TotalSales',
             title='Total Sales Revenue by Customer',
             labels={'TotalSales': 'Total Sales', 'CustomerID': 'Customer ID'},
             color='TotalSales',
             template='plotly_white')

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the total sales by each customer using a SQL query similar to the reference implementation. It then visualizes the data using a Plotly bar chart. Both the SQL logic and visualization achieve the same intended outcome as the reference code, despite minor differences such as color customization in the plot.","import plotly.express as px

# Step 1: Execute the SQL query to retrieve data into a pandas dataframe

sql_query = '''
SELECT customers.CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID;
'''

data = execute_sql_query(sql_query)

# Step 2: Create a bar chart to compare the sales revenue generated by each customer

fig = px.bar(data, x='CustomerID', y='TotalRevenue', 
             title='Total Sales Revenue by Each Customer', 
             labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue ($)'} )

# Step 3: Display the plot to the user
show_to_user(fig)","The input code correctly retrieves the total sales revenue for each customer using an SQL query and visualizes the results using Plotly, just like the reference implementation. The SQL query joins the necessary tables and calculates the total revenue per customer, and the visualization effectively displays the result using a bar chart.",Base
Which employee has processed the most orders for customers in the USA?,"import pandas as pd
import plotly.express as px

# Define the SQL query from the given request
sql_query = '''
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShipCountry = 'USA' 
GROUP BY employees.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","import pandas as pd

# SQL query to retrieve the orders processed by employees in the USA
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShipCountry = 'USA'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
'''  

# Execute the query and get the result
result_df = execute_sql_query(sql_query)

# Display the top employee who processed the most orders
show_to_user(result_df)","The input Python code correctly implements the SQL query to find the employee who processed the most orders for customers in the USA. It matches the steps of the reference implementation by joining the 'employees' and 'orders' tables, filtering for 'USA', grouping by the employee ID, ordering by the number of orders, and limiting to one result. The use of utility functions 'execute_sql_query' and 'show_to_user' is consistent with the requirement.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
    SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
    FROM employees e
    JOIN orders o ON e.EmployeeID = o.EmployeeID
    WHERE o.ShipCountry = 'USA'
    GROUP BY e.EmployeeID
    ORDER BY OrderCount DESC
    LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code does not select the employee's FirstName and LastName, which are shown in the reference implementation.",Base
Which product had the highest sales quantity in the last month? Use a bar chart to show the sales quantities of products.,"import plotly.express as px
import pandas as pd

# SQL query to get product sales quantities for the last month
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalQuantity DESC;
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Check if any data is returned
if not sales_data.empty:
    # Generate a bar chart using plotly
    fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Sales Quantities of Products in the Last Month')
    
    # Show the bar chart to the user
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Message': ['No sales data available for the last month']}))","import pandas as pd
import plotly.express as px

# SQL query to get product sales for the last month
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) as TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID
    FROM orders
    WHERE OrderDate >= DATEADD(MONTH, -1, GETDATE())
)
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 1
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Find the product with the highest sales quantity
highest_sales_product = result_df.iloc[0]

# Prepare data for bar chart
sales_data = execute_sql_query('''
SELECT p.ProductName, SUM(od.Quantity) as TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID
    FROM orders
    WHERE OrderDate >= DATEADD(MONTH, -1, GETDATE())
)
GROUP BY p.ProductName
''')

# Create a bar chart
fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Sales Quantity of Products in the Last Month')

# Show the bar chart to the user
show_to_user(fig)","The code incorrectly attempts to limit the SQL result to one product ('LIMIT 1'), which does not align with visualizing all products. It should consistently be retrieving all product quantities for the bar chart, similar to the reference code, with a separate logic to find the highest sales if needed.","import plotly.express as px

# Define and execute the SQL query to get sales quantities of products in the last month
sql_query = '''
SELECT p.ProductID, SUM(od.Quantity) AS TotalSalesQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE DATEPART(MONTH, od.OrderDate) = DATEPART(MONTH, DATEADD(MONTH, -1, CURRENT_TIMESTAMP))
AND DATEPART(YEAR, od.OrderDate) = DATEPART(YEAR, DATEADD(MONTH, -1, CURRENT_TIMESTAMP))
GROUP BY p.ProductID
ORDER BY TotalSalesQuantity DESC
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ProductID', y='TotalSalesQuantity', title='Sales Quantities of Products in the Last Month')

# Add a vertical line to indicate the product with highest sales quantity
max_product_id = sales_data.iloc[0]['ProductID']
fig.add_vline(x=max_product_id, line_dash=""dash"",
              annotation_text=""Highest Sales Quantity"", 
              annotation_position=""top right"")

# Display the chart
show_to_user(fig)

# Output the product with highest sales quantity
data_highest_sales_quantity = sales_data.iloc[0:1]
show_to_user(data_highest_sales_quantity)","The input code does not correctly address the business analytic request. It calculates sales quantities for the previous month by matching year and month separately, which may incorrectly handle cases across year boundaries (e.g., January). Additionally, it uses only 'ProductID' in the output without including 'ProductName', making it less informative. The code also adds a vertical line in the bar chart, which is not requested. The reference code correctly uses a date-based interval to capture the last month and includes both 'ProductName' and 'TotalQuantity' in the output.",None
"For each employee, what is the average number of orders handled per month in 2023? Use a line graph to show the average number of orders handled each month.","import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = '''
SELECT employees.EmployeeID, AVG(order_count) AS avg_orders_per_month
FROM (SELECT employees.EmployeeID, COUNT(orders.OrderID) AS order_count, 
             MONTH(orders.OrderDate) AS order_month
      FROM employees
      LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID
      GROUP BY employees.EmployeeID, MONTH(orders.OrderDate)) AS temp
GROUP BY employees.EmployeeID
'''

# Execute the SQL query and get the data
employee_avg_orders_df = execute_sql_query(sql_query)

# Extracting month and average orders data for plotting
# Correct the aggregation part as we need month-wise average
avg_orders_per_month_df = employee_avg_orders_df.groupby('order_month')['avg_orders_per_month'].mean().reset_index()

# Creating the line plot with Plotly
fig = px.line(avg_orders_per_month_df, x='order_month', y='avg_orders_per_month',
              title='Average Number of Orders Handled Per Month in 2023',
              labels={'order_month':'Month', 'avg_orders_per_month':'Average Orders Per Month'})

# Show the visualized plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch the number of orders handled by each employee per month in 2023
sql_query = '''
SELECT 
    e.FirstName, e.LastName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') as order_month, 
    COUNT(o.OrderID) as order_count 
FROM 
    orders o 
JOIN 
    employees e ON o.EmployeeID = e.EmployeeID 
WHERE 
    o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY 
    e.EmployeeID, order_month 
ORDER BY 
    order_month;
''' 

# Executing the query and fetching data into a DataFrame
order_data = execute_sql_query(sql_query)

# Calculating the average number of orders handled per month by each employee
average_orders = order_data.groupby(['FirstName', 'LastName'])[
    'order_count'].mean().reset_index()
average_orders = average_orders.rename(columns={'order_count': 'average_orders'})

# Creating a line graph to visualize average orders handled each month
fig = px.line(average_orders,
              x='FirstName',
              y='average_orders',
              title='Average Number of Orders Handled per Month in 2023',
              labels={'FirstName': 'Employee Name', 'average_orders': 'Average Orders'})

# Show the line graph to user
show_to_user(fig)","The input code calculates the average number of orders per employee over all months instead of displaying a line graph for the average number of orders handled each month across all employees. It groups by 'FirstName' and 'LastName' instead of 'order_month', which is required to meet the business request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       COUNT(DISTINCT o.OrderID) / 12.0 AS AvgOrdersPerMonth 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE YEAR(o.OrderDate) = 2023 
GROUP BY e.EmployeeID, e.FirstName, e.LastName''' 

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a long-form DataFrame suitable for line plotting
df_long = df.melt(id_vars=['EmployeeID', 'FirstName', 'LastName'], value_vars=['AvgOrdersPerMonth'], 
                  var_name='Metric', value_name='Value')

# Sort DataFrame by EmployeeID
df_long = df_long.sort_values(by='EmployeeID')

# Plot the data
fig = px.line(df_long, x='EmployeeID', y='Value', title='Average Orders Handled Per Month in 2023 by Employee')

# Display the line graph
show_to_user(fig)","The input code calculates the average orders per employee over the entire year, not per month. The line graph plots this value against EmployeeID, not month. The reference code groups by month and averages orders monthly.",None
How many discontinued products are still in stock?,"import pandas as pd

# Define SQL query
sql_query = ""SELECT COUNT(*) AS DiscontinuedInStock FROM products WHERE Discontinued = 1 AND UnitsInStock > 0;""

# Execute SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Extract count value from the dataframe to display it properly
discontinued_in_stock = result_df['DiscontinuedInStock'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'DiscontinuedInStock': [discontinued_in_stock]}))","import pandas as pd

# SQL query to find the count of discontinued products still in stock
sql_query = """"""
SELECT COUNT(*) AS DiscontinuedInStock
FROM products
WHERE Discontinued = 1 AND UnitsInStock > 0
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code effectively fulfills the business analytic request. It uses a SQL query to count discontinued products that are still in stock, executes the query, and displays the result. The approach and outcome align with the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to find the total units in stock of discontinued products
sql_query = 'SELECT SUM(UnitsInStock) AS TotalDiscontinuedStock FROM products WHERE Discontinued = 1;'

# Execute the SQL query and get the result as pandas dataframe
result_df = execute_sql_query(sql_query)

# Extract the TotalDiscontinuedStock value from the dataframe
if not result_df.empty:
    discontinued_stock = result_df['TotalDiscontinuedStock'].iloc[0]
    result_to_display = pd.DataFrame({'TotalDiscontinuedStock': [discontinued_stock]})
    # Show the result to the user
    show_to_user(result_to_display)
else:
    show_to_user(pd.DataFrame({'TotalDiscontinuedStock': [0]}))","The input code calculates the sum of units in stock for all discontinued products, rather than counting the number of discontinued products that still have units in stock. The business request and reference code focus on counting such products where 'UnitsInStock' is greater than 0.",Base
Determine the most frequently used shipping method. Include a pie chart to show the distribution of shipping methods.,"import plotly.express as px

# SQL query to get the most frequently used shipping method
sql_query = 'SELECT ShipVia, COUNT(OrderID) AS UseCount FROM orders GROUP BY ShipVia ORDER BY UseCount DESC LIMIT 1;'

# Execute the SQL query
most_freq_shipping_df = execute_sql_query(sql_query)

# SQL query to get the distribution of all shipping methods
sql_query_distribution = 'SELECT ShipVia, COUNT(OrderID) AS UseCount FROM orders GROUP BY ShipVia;'

# Execute the SQL query
shipping_distribution_df = execute_sql_query(sql_query_distribution)

# Create a pie chart to show the distribution of shipping methods
fig = px.pie(shipping_distribution_df, names='ShipVia', values='UseCount', title='Distribution of Shipping Methods')

# Display the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to retrieve shipping method data from the orders table
sql_query = """"""
SELECT ShipVia, COUNT(*) as Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
""""""  

# Execute the SQL query
shipping_methods_df = execute_sql_query(sql_query)

# Get the most frequently used shipping method
most_frequent_shipping_method = shipping_methods_df.iloc[0]

# Create a pie chart for the distribution of shipping methods
fig = px.pie(shipping_methods_df, values='Frequency', names='ShipVia', title='Distribution of Shipping Methods')

# Show results to the user
show_to_user(fig)

# Display the most frequently used shipping method
show_to_user(pd.DataFrame([most_frequent_shipping_method]))","The input code accurately retrieves the most frequent shipping method and creates a pie chart for the distribution of shipping methods, matching the outcomes of the reference implementation. The approach differs slightly by using a single query to order shipping methods by frequency, but it effectively addresses the business request.","import pandas as pd
import plotly.express as px

# Step 1: Get the data by executing the provided SQL query
sql_query = """"""
SELECT ShipVia, COUNT(ShipVia) AS UsageCount 
FROM orders 
GROUP BY ShipVia 
ORDER BY UsageCount DESC 
LIMIT 1;
""""""
most_frequent_method_df = execute_sql_query(sql_query)

# Step 2: Get the distribution of all shipping methods for the pie chart
distribution_sql_query = """"""
SELECT ShipVia, COUNT(ShipVia) AS UsageCount 
FROM orders 
GROUP BY ShipVia;
""""""
distribution_df = execute_sql_query(distribution_sql_query)

# Step 3: Create a pie chart using plotly
fig = px.pie(distribution_df, names='ShipVia', values='UsageCount', title='Distribution of Shipping Methods')

# Step 4: Show the pie chart to the user
show_to_user(fig)

# Optional: Show the most frequently used shipping method
most_frequent_method_df.rename(columns={""UsageCount"": ""Usage Count""}).style.set_caption('Most Frequently Used Shipping Method')","The input Python code correctly implements the business analytic request. It determines the most frequently used shipping method by executing a SQL query and creates a pie chart to show the distribution of shipping methods using Plotly, matching the reference implementation's outcome.",Base
Which products have not been ordered in the last three months?,"import pandas as pd
import plotly.express as px

# SQL query to get products not ordered in the last three months
sql_query = '''
SELECT ProductName 
FROM products 
WHERE ProductID NOT IN (
    SELECT DISTINCT ProductID 
    FROM [Order Details] 
    WHERE OrderID IN (
        SELECT OrderID 
        FROM orders 
        WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
    )
);'''

# Execute the SQL query
products_not_ordered = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_not_ordered)","from datetime import datetime, timedelta

# Calculate the date three months ago from today
three_months_ago = datetime.now() - timedelta(days=90)

# Format the date in the required format YYYY-MM-DD
formatted_date = three_months_ago.strftime('%Y-%m-%d')

# SQL query to find products that have not been ordered in the last three months
sql_query = f""""""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID AND od.OrderDate >= '{formatted_date}'
WHERE od.ProductID IS NULL
""""""

# Execute the SQL query and get the results
result_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(result_df)","The input code mistakenly attempts to join with 'Order Details' using a condition on 'OrderDate', which is not a part of 'Order Details'. It results in an incorrect logic for checking product orders in the last three months.","import pandas as pd
import plotly.express as px

# Define the SQL query to find products not ordered in the last three months
sql_query = '''
SELECT ProductName 
FROM products 
WHERE ProductID NOT IN (
    SELECT DISTINCT ProductID 
    FROM [Order Details] 
    WHERE OrderDate > DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
);
'''

# Execute the SQL query using the provided function
products_not_ordered_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_not_ordered_df)
","The evaluated code uses 'OrderDate > DATE_SUB(CURDATE(), INTERVAL 3 MONTH)' in the subquery. This causes the inclusion of records ordered exactly three months ago, which the reference implementation correctly avoids with 'OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)'.",None
What is the average Inventory Turnover Ratio for each month? Use a line graph to show the monthly average Inventory Turnover Ratio.,"import pandas as pd
import plotly.express as px

# Define the SQL query
query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
'''

# Execute the SQL query to get the data
data = execute_sql_query(query)

# Check if the data is retrieved correctly and not empty
def validate_data(data):
    if data.empty or not {'Month', 'InventoryTurnoverRatio'}.issubset(data.columns):
        raise ValueError('Invalid data retrieved from SQL query')

validate_data(data)

# Generate the line graph using plotly
fig = px.line(data, x='Month', y='InventoryTurnoverRatio', 
              title='Monthly Average Inventory Turnover Ratio', 
              labels={'Month': 'Month', 'InventoryTurnoverRatio': 'Average Inventory Turnover Ratio'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate the monthly average Inventory Turnover Ratio
sql_query = '''
SELECT
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS Inventory_Turnover_Ratio
FROM
    [Order Details] od
JOIN
    products p ON od.ProductID = p.ProductID
JOIN
    orders o ON od.OrderID = o.OrderID
WHERE
    o.OrderDate IS NOT NULL
GROUP BY
    Month
ORDER BY
    Month;
'''  

# Execute the SQL query
monthly_inventory_turnover_df = execute_sql_query(sql_query)

# Create a line graph for the monthly average Inventory Turnover Ratio
fig = px.line(monthly_inventory_turnover_df,
              x='Month',
              y='Inventory_Turnover_Ratio',
              title='Monthly Average Inventory Turnover Ratio',
              labels={'Month': 'Month', 'Inventory_Turnover_Ratio': 'Inventory Turnover Ratio'})

# Show the graph to the user
show_to_user(fig)","The input Python code correctly executes an SQL query to compute the monthly average Inventory Turnover Ratio, groups the data by month, and uses Plotly to create and display a line graph. The method used for date truncation and column naming differs slightly, but it effectively achieves the same outcome as the reference implementation.","To provide the solution for the user request, we will execute the following steps using the provided utility functions for executing SQL queries and data visualization.

### Step-by-Step Implementation

1. **Write the SQL query**: We need a valid SQL query to get the average Inventory Turnover Ratio for each month.
2. **Fetch the data**: Use the `execute_sql_query` function to run the SQL query and retrieve the data as a pandas DataFrame.
3. **Plot the data**: Use the `show_plot` function to create and display the line graph based on the DataFrame data.

### SQL Query

The SQL query provided for this computation is:
```sql
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(InventoryTurnoverRatio) AS AvgInventoryTurnoverRatio
FROM (
    SELECT OrderDate, 
        SUM(Quantity * UnitPrice) / AVG(UncontrolledStock) AS InventoryTurnoverRatio
    FROM products 
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
    GROUP BY OrderDate, products.ProductID
) AS temp
GROUP BY Month;
```

### Python Code Implementation

With this SQL query in mind, here’s how we will implement it:

```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(InventoryTurnoverRatio) AS AvgInventoryTurnoverRatio
FROM (
    SELECT OrderDate, 
           SUM(Quantity * UnitPrice) / AVG(UncontrolledStock) AS InventoryTurnoverRatio
    FROM products 
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
    GROUP BY OrderDate, products.ProductID
) AS temp
GROUP BY Month;
""""""
df = execute_sql_query(sql_query)

# Step 2: Check and sort the DataFrame by Month
df['Month'] = pd.to_datetime(df['Month'])
df = df.sort_values(by='Month')

# Step 3: Create the line graph using plotly
fig = px.line(df, x='Month', y='AvgInventoryTurnoverRatio', title='Monthly Average Inventory Turnover Ratio')

# Step 4: Show the plot to the user
show_plot(fig)
```

### Explanation

- **Date Formatting**: The month is formatted to a string in 'YYYY-MM' format using SQL's `DATE_FORMAT`. It is converted to datetime for proper plotting.
- **Plotting**: A line plot is generated with plotly using `plotly.express.line`, displaying the month on the x-axis and the average inventory turnover ratio on the y-axis.
- **Visualization**: Finally, the plot is displayed to the user with the `show_plot` utility function.","The input code calculates InventoryTurnoverRatio by using AVG(UncontrolledStock) instead of AVG(UnitsInStock). UncontrolledStock is not a valid column, leading to likely SQL execution errors. Both codes plot a line graph correctly, but the calculation should match the reference implementation using AVG(p.UnitsInStock).",Base
List the top 5 employees with the highest salaries.,"import pandas as pd

# Define the SQL query to fetch the required data
sql_query = 'SELECT EmployeeID, FirstName, LastName, Salary FROM employees ORDER BY Salary DESC LIMIT 5;'

# Execute the SQL query
employee_df = execute_sql_query(sql_query)

# Display the retrieved data to the user
show_to_user(employee_df)","import pandas as pd

# SQL query to get the top 5 employees with the highest salaries
sql_query = """"""
SELECT EmployeeID, FirstName, LastName, Salary
FROM employees
ORDER BY Salary DESC
LIMIT 5;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code successfully executes a SQL query to retrieve the top 5 employees with the highest salaries, orders them by salary in descending order, and limits the result to 5 entries. It then displays the result using the show_to_user function. This matches the business analytic request and the reference implementation.","import pandas as pd
import plotly.express as px

# Define a function to list the top 5 employees with the highest salaries
def get_top_salaries():
    # SQL query to get the top 5 employees with the highest salaries
    sql_query = """"""SELECT EmployeeID, FirstName, LastName, Salary FROM employees ORDER BY Salary DESC LIMIT 5;""""""
    
    # Execute the SQL query
    top_salaries_df = execute_sql_query(sql_query)
    
    # Show the results to the user
    show_to_user(top_salaries_df)
    
    # Additionally, visualize the salaries using Plotly
    fig = px.bar(top_salaries_df, x='FirstName', y='Salary', title='Top 5 Employees with Highest Salaries', 
                 labels={'FirstName':'Employee', 'Salary':'Salary in USD'}, 
                 hover_data=['EmployeeID', 'LastName'])
    show_to_user(fig)

# Call the function to execute and display the result
get_top_salaries()","The input code correctly fetches the top 5 employees with the highest salaries using an SQL query, similar to the reference implementation. Additionally, it visualizes the salaries with Plotly, which does not contradict the business request.",Base
What's the average discount applied to products?,"import pandas as pd
import plotly.express as px

# SQL Query to get the average discount
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];'

# Execute the query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user using the provided utility function
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the average discount applied to products
sql_query = '''
SELECT AVG(Discount) AS AvgDiscount
FROM [Order Details]
'''  

# Execute the SQL query and fetch the result
df_result = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df_result)","The input Python code correctly retrieves the average discount using a SQL query, similar to the reference implementation. The column name does not need to match exactly, as 'AvgDiscount' in the input is equivalent to 'AverageDiscount' in the reference.","import pandas as pd
import plotly.express as px

# Function to get data from the database
def get_discount_data():
    sql_query = 'SELECT Discount FROM [Order Details];'
    df = execute_sql_query(sql_query)
    return df

# Function to calculate the average discount
def get_average_discount():
    df = get_discount_data()
    average_discount = df['Discount'].mean()
    
    average_discount_df = pd.DataFrame({'Average Discount': [average_discount]})
    show_to_user(average_discount_df)

# Main function to execute the analysis
def main():
    get_average_discount()

# Run the main function
if __name__ == '__main__':
    main()","The input code correctly calculates the average discount by querying the discount information, computing the mean, and displaying the result. It effectively addresses the business analytic request and achieves the same outcome as the reference implementation.",Base
Calculate the total sales revenue generated each month and visualize it to show trends over time.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales revenue generated each month
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY Month;
""""""

# Execute the SQL query and retrieve the data as a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Ensure the Month column is treated as datetime
sales_data['Month'] = pd.to_datetime(sales_data['Month'], format='%Y-%m')

# Sort the dataframe by Month to ensure the line plot will be correctly ordered
sales_data = sales_data.sort_values(by='Month')

# Visualize the data to show trends over time
fig = px.line(sales_data, x='Month', y='MonthlySales', title='Monthly Sales Revenue Trend', labels={'Month': 'Month', 'MonthlySales': 'Sales Revenue'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue generated each month
sql_query = '''
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    `orders` o
JOIN 
    `[Order Details]` od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    Month
''' # Adjusted SQL syntax for date formatting

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Visualizing the sales data trends over time
fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales Revenue per Month', labels={'TotalSales': 'Total Sales ($)', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)","The input Python code successfully calculates the total sales revenue generated each month and visualizes it to show trends over time, achieving the same outcome as the reference implementation. The SQL query and visualization approach align with the business analytic request.","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue each month
sql_query = ""SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID GROUP BY month;""

# Execute the SQL query and retrieve the result
sales_data = execute_sql_query(sql_query)

# Make sure that the 'month' column is treated as a datetime type for correct plotting
sales_data['month'] = pd.to_datetime(sales_data['month'], format='%Y-%m')

# Sort the data by month
sales_data = sales_data.sort_values('month')

# Generate visualization using plotly
fig = px.line(sales_data, x='month', y='total_sales', title='Total Sales Revenue per Month', labels={'month': 'Month', 'total_sales': 'Total Sales Revenue'})

# Show the result to the user
show_to_user(fig)","The input code correctly executes an SQL query to calculate total monthly sales revenue, processes the data using pandas, sorts it by month, and visualizes it using plotly, matching the business analytic request and achieving the same outcome as the reference implementation.",Base
What percentage of orders were shipped after the required date each month? Visualize the percentage to identify any patterns or trends.,"import plotly.express as px

# SQL query to get the percentage of orders shipped after the required date each month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) / COUNT(OrderID) AS LateDeliveryRate 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# Ensure the 'Month' column is sorted
orders_df['Month'] = pd.to_datetime(orders_df['Month'], format='%Y-%m')
orders_df = orders_df.sort_values('Month')
orders_df['Month'] = orders_df['Month'].dt.strftime('%Y-%m')

# Create a line plot to visualize the percentage of late deliveries over time
fig = px.line(orders_df, x='Month', y='LateDeliveryRate', title='Percentage of Orders Shipped After Required Date Each Month')

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Retrieve the orders data from the database
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate > RequiredDate THEN 1 ELSE 0 END) AS LateShipments
FROM orders
GROUP BY Month
ORDER BY Month
""""""
orders_data = execute_sql_query(sql_query)

# Step 2: Calculate the percentage of late shipments
orders_data['LateShipmentPercentage'] = (orders_data['LateShipments'] / orders_data['TotalOrders']) * 100

# Step 3: Create a line plot to visualize the late shipment percentage over time
fig = px.line(orders_data, x='Month', y='LateShipmentPercentage', title='Monthly Late Shipment Percentage', labels={'LateShipmentPercentage':'Percentage of Late Shipments (%)'})

# Step 4: Show the visualization to the user
show_to_user(fig)","The input code accurately calculates the percentage of orders shipped after the required date each month by summing late shipments and dividing by total orders. It then visualizes this percentage using a line plot, addressing the business analytic request effectively and achieving the same outcome as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       (COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID)) AS LateShipmentRate 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Convert the 'Month' column to datetime for better plotting
df['Month'] = pd.to_datetime(df['Month'], format='%Y-%m')

# Sort the dataframe by Month
df = df.sort_values('Month')

# Create a line plot to visualize the Late Shipment Rate over different months
fig = px.line(df, x='Month', y='LateShipmentRate', title='Monthly Late Shipment Rate', labels={'LateShipmentRate': 'Late Shipment Rate (%)', 'Month': 'Month'})

# Display the plot to the user
show_to_user(fig)
```","The input code and the reference code both correctly calculate the percentage of orders shipped after the required date each month. The input code multiplies the percentage by 100, but it does not affect the correctness of the outcome; it just represents the rate in percentage form. Both implementations use Plotly to visualize the data correctly.",Base
Which shipping method was used most frequently? Visualize the frequency to illustrate the distribution.,"import plotly.express as px
import pandas as pd

# SQL Query to fetch shipping method usage counts
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount 
FROM orders 
GROUP BY ShipVia 
ORDER BY UsageCount DESC
""""""

# Execute SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Generate the bar plot using plotly
fig = px.bar(df, x='ShipVia', y='UsageCount', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'UsageCount': 'Usage Count'})

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the frequency of each shipping method
sql_query = '''
SELECT ShipVia, COUNT(*) as Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
'''

# Execute the SQL query to retrieve data
shipping_frequencies = execute_sql_query(sql_query)

# Visualizing the frequency of shipping methods
fig = px.bar(shipping_frequencies, x='ShipVia', y='Frequency',
             title='Shipping Method Frequency',
             labels={'ShipVia': 'Shipping Method', 'Frequency': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)",The evaluated code correctly executes the SQL query to determine the frequency of shipping methods and visualizes the results using a bar chart with Plotly. It effectively answers the business analytic request similar to the reference code.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipVia, COUNT(OrderID) AS Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
'''

# Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the frequency of each shipping method
fig = px.bar(orders_df, x='ShipVia', y='Frequency', title='Frequency of Shipping Methods', labels={'ShipVia':'Shipping Method', 'Frequency':'Number of Orders'})

# Display the plot
show_to_user(fig)
","The input code fulfills the business analytic request by correctly identifying and visualizing the most frequently used shipping method. It executes a similar SQL query to the reference implementation, aggregates the orders by shipping method, sorts them by frequency, and visualizes the results using a plotly bar chart. The column names in the SQL query and plotly visualization differ slightly but achieve the same outcome.",Base
What is the customer retention rate from January 2022 to January 2023? Visualize the retention rate over time.,"import pandas as pd
import plotly.express as px

def calculate_customer_retention():
    # SQL query to get the number of unique customers before January 2022
    sql_query_old_customers = '''
    SELECT CustomerID, MIN(OrderDate) AS FirstOrderDate 
    FROM orders 
    GROUP BY CustomerID
    HAVING MIN(OrderDate) < '2022-01-01'
    '''
    old_customers_df = execute_sql_query(sql_query_old_customers)

    # SQL query to get the number of unique customers from January 2022 to January 2023
    sql_query_new_orders = '''
    SELECT CustomerID, MIN(OrderDate) AS FirstOrderDate 
    FROM orders 
    GROUP BY CustomerID
    ''
    new_orders_df = execute_sql_query(sql_query_new_orders)

    # Filter new customers who have at least one order after '2022-01-01' and before '2023-01-01'
    new_orders_df = new_orders_df[new_orders_df['FirstOrderDate'] >= '2022-01-01']
    new_orders_df = new_orders_df[new_orders_df['FirstOrderDate'] <= '2023-01-01']

    # Find old customers who have placed orders during the new period
    retained_customers_df = pd.merge(new_orders_df, old_customers_df, on='CustomerID', how='inner')

    # Calculate customer retention rate
    if len(old_customers_df) > 0:
        retention_rate = len(retained_customers_df) / len(old_customers_df)
    else:
        retention_rate = 0

    # Create a DataFrame for visualization
    retention_data = {
        'Date': ['2023-01-01'],
        'Retention Rate': [retention_rate]
    }
    retention_df = pd.DataFrame(retention_data)

    # Visualize the retention rate
    fig = px.line(retention_df, x='Date', y='Retention Rate', title='Customer Retention Rate from January 2022 to January 2023')
    show_to_user(fig)

# Calculate and show customer retention rate
calculate_customer_retention()","import pandas as pd
import plotly.express as px

# Define the date range
start_date = '2022-01-01'
end_date = '2023-01-31'

# SQL query to calculate customer retention rate
sql_query = f""""""
SELECT 
    (SELECT COUNT(DISTINCT CustomerID) FROM orders WHERE OrderDate BETWEEN '{start_date}' AND '{end_date}') * 100.0 / 
    (SELECT COUNT(DISTINCT CustomerID) FROM orders WHERE OrderDate < '{start_date}') AS retention_rate,
    DATE_FORMAT(OrderDate, '%Y-%m') AS month 
FROM 
    orders 
WHERE 
    OrderDate BETWEEN '{start_date}' AND '{end_date}' 
GROUP BY 
    month
ORDER BY 
    month;
""""""

# Execute the SQL query and retrieve the data
retention_data = execute_sql_query(sql_query)

# Create a line plot for the retention rate over time
fig = px.line(retention_data, x='month', y='retention_rate',
              title='Customer Retention Rate from January 2022 to January 2023',
              labels={'retention_rate': 'Retention Rate (%)', 'month': 'Month'})

# Show the plot to the user
show_to_user(fig)",The input code calculates a monthly retention rate over the given period by comparing the unique customers in each month against those before the start date. The reference implementation determines overall retention of existing customers within a specified period. These approaches yield different outcomes and don't directly match the business request.,"import pandas as pd
import plotly.express as px

# SQL queries
sql_before = """"""SELECT COUNT(DISTINCT CustomerID) 
                FROM orders 
                WHERE OrderDate < '2022-01-01'""""""

sql_current = """"""SELECT COUNT(DISTINCT CustomerID) 
                 FROM orders 
                 WHERE OrderDate BETWEEN '2022-01-01' AND '2023-01-31'""""""

# Executing SQL queries
df_before = execute_sql_query(sql_before)
df_current = execute_sql_query(sql_current)

# Calculate the retention rate
if df_before.iloc[0, 0] == 0:
    retention_rate = 0
else:
    retention_rate = df_current.iloc[0, 0] / df_before.iloc[0, 0]

# Display the retention rate for the specified period
retention_rate_df = pd.DataFrame({'Yearly Retention Rate': [retention_rate]})
show_to_user(retention_rate_df)

# SQL query to get retention rate over time
sql_retention_over_time = """"""SELECT 
                                YEAR(OrderDate) AS Year, 
                                COUNT(DISTINCT CustomerID) * 100.0 / 
                                (SELECT COUNT(DISTINCT CustomerID) 
                                 FROM orders WHERE OrderDate < '2022-01-01')
                             AS RetentionRate
                             FROM orders 
                             GROUP BY YEAR(OrderDate)""""""

# Execute SQL query for the full retention rate data
df_retention_over_time = execute_sql_query(sql_retention_over_time)

# Visualize the retention rate over time
fig = px.line(df_retention_over_time, x='Year', y='RetentionRate', title='Customer Retention Rate Over Time', labels={'Year':'Year', 'RetentionRate':'Retention Rate (%)'})
show_to_user(fig)","The input code only calculates the retention rate using the count of distinct customers who made purchases in both time periods. It doesn't filter for customers who existed before January 2022 and made a purchase in the specified period, failing to match the business requirement. Additionally, the visualization should represent the retention rate for each month from January 2022 to January 2023, but the input code oversees yearly retention only.",None
What is the average order value for the year 2021?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AverageOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(orders.OrderDate) = 2021;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Process the result to get the average order value
average_order_value = result_df['AverageOrderValue'].iloc[0] if not result_df.empty and 'AverageOrderValue' in result_df else None

# Display the result to the user
result_to_display = pd.DataFrame({'Year': [2021], 'Average Order Value': [average_order_value]})
show_to_user(result_to_display)","import pandas as pd

# SQL query to calculate the average order value for the year 2021
sql_query = '''
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AverageOrderValue
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    YEAR(orders.OrderDate) = 2021
'''  

# Execute the SQL query and retrieve the data
average_order_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_order_value_df)",The input code does not process the average order value to ensure it's a single value extracted from the dataframe. It displays the entire dataframe rather than just extracting the average value as in the reference implementation.,"# Define the SQL query
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = 2021;
'''

# Execute the SQL query to get the result
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The input code effectively calculates and displays the average order value for 2021 using a SQL query. It correctly uses the SUM and COUNT functions to compute the average and the YEAR function to filter the orders by date, matching the logic of the reference implementation. Thus, it addresses the business analytic request correctly.",Finetuned
Identify the top 3 products with the most number of orders and visualize their order counts.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) AS NumberOfOrders 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY NumberOfOrders DESC 
LIMIT 3;
'''

# Execute the query to get the data
product_order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 products with the most orders
fig = px.bar(product_order_data, x='ProductName', y='NumberOfOrders', 
             title='Top 3 Products with the Most Number of Orders', 
             labels={'ProductName': 'Product Name', 'NumberOfOrders': 'Number of Orders'})

# Display the visualization
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the top 3 products with the most number of orders
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrders
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrders DESC
LIMIT 3;
""""""

# Execute the SQL query and get the results in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the order counts
fig = px.bar(top_products_df, x='ProductName', y='TotalOrders', title='Top 3 Products by Order Count', labels={'TotalOrders': 'Number of Orders', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)","The input Python code sums the 'Quantity' column instead of counting 'OrderID'. It calculates 'TotalOrders' based on quantity, not the number of orders as required by the business request.","import pandas as pd
import plotly.express as px

# Function to execute SQL query
# Assuming execute_sql_query(sql_query) is predefined

# SQL query to get the top 3 products with the most number of orders
sql_query = '''
SELECT p.ProductName, COUNT(od.OrderID) AS OrderCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY OrderCount DESC 
LIMIT 3;'''

# Execute the SQL query
product_orders_df = execute_sql_query(sql_query)

# Check if the dataframe is correctly populated and has expected columns
if 'ProductName' in product_orders_df and 'OrderCount' in product_orders_df:
    # Visualize the order counts using plotly
    fig = px.bar(product_orders_df, x='ProductName', y='OrderCount',
                 title='Top 3 Products with the Most Orders',
                 labels={'ProductName': 'Product Name', 'OrderCount': 'Order Count'})

    # Show the visualization to user
    show_to_user(fig)

else:
    print('DataFrame does not contain the expected columns. Please check the query results.')",The input Python code correctly executes the SQL query to retrieve the top 3 products with the most orders by joining the 'products' and '[Order Details]' tables and grouping by 'ProductName'. It then checks for the correct columns and uses Plotly to create a bar chart similar to the reference implementation. It effectively addresses the business analytic request.,Finetuned
What are the average monthly sales generated by each region? Use visualization to compare the sales across regions.,"import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = '''
SELECT territories.RegionID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT DATE_TRUNC('month', orders.OrderDate)) AS avg_monthly_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
GROUP BY territories.RegionID
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if dataframe is empty
if df.empty:
    raise ValueError('The query returned an empty dataframe. Please check the SQL query and the database.')

# Create a bar chart to visualize the average monthly sales by region
fig = px.bar(df, x='RegionID', y='avg_monthly_sales', title='Average Monthly Sales by Region', labels={'RegionID': 'Region ID', 'avg_monthly_sales': 'Average Monthly Sales'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve average monthly sales by region
sql_query = '''
SELECT 
    o.ShipRegion,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS avg_monthly_sales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate IS NOT NULL
GROUP BY 
    o.ShipRegion, month
ORDER BY 
    month, o.ShipRegion
'''

# Execute SQL query and retrieve data into a pandas DataFrame
average_sales_df = execute_sql_query(sql_query)

# Visualization of average monthly sales by region using Plotly
fig = px.line(average_sales_df, 
              x='month', 
              y='avg_monthly_sales', 
              color='ShipRegion', 
              title='Average Monthly Sales by Region', 
              labels={'avg_monthly_sales': 'Average Monthly Sales', 'month': 'Month'})

# Show the visualization to user
show_to_user(fig)","The input code aggregates sales by region and month, but the reference code aggregates by region only. The reference code calculates average monthly sales using region and count of distinct months, while the input code counts distinct orders, leading to different outcomes.","To achieve the goal of finding the average monthly sales generated by each region and visualizing the sales across regions, we'll follow these steps:

1. Use the provided SQL query to fetch the data.
2. Use a visualization library like Matplotlib or Seaborn to create a comparison chart.

The SQL query provided is:
```sql
SELECT region.region_description, 
AVG(SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))) AS avg_monthly_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employee terr on orders.EmployeeID = terr.EmployeeID
JOIN territory ON terr.TerritoryID = territory.TerritoryID 
JOIN region ON territory.RegionID = region.RegionID 
GROUP BY region.region_description 
ORDER BY avg_monthly_sales DESC;
```

Here is the Python code:

```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT region.region_description, 
AVG(SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))) AS avg_monthly_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employee terr on orders.EmployeeID = terr.EmployeeID
JOIN territory ON terr.TerritoryID = territory.TerritoryID 
JOIN region ON territory.RegionID = region.RegionID 
GROUP BY region.region_description 
ORDER BY avg_monthly_sales DESC;''' 

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(sales_data, x='region_description', y='avg_monthly_sales', 
             title='Average Monthly Sales by Region', 
             labels={'region_description': 'Region', 'avg_monthly_sales': 'Average Monthly Sales'})

# Display the visualization
show_to_user(fig)
```

### Explanation:

- **SQL Query**: Retrieves average monthly sales by region.
- **execute_sql_query(sql_query)**: Calls the utility function to execute the SQL query.
- **plotly.express**: Used to create an interactive bar chart for the average monthly sales by region.
- **show_to_user(fig)**: Displays the visualization to the user. 

The chart will allow users to easily compare the average monthly sales across different regions.","The SQL query in the input code is incorrect. The use of AVG(SUM(...)) is invalid. SUM should be used to calculate total sales for each month, then averaged. The structure of the input query differs from the reference code, which correctly calculates the average monthly sales by dividing total sales by the number of distinct months. Also, there are some join and aliasing discrepancies.",None
Find the order with the highest discount applied.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT OrderID, Discount FROM [Order Details] ORDER BY Discount DESC LIMIT 1;'

# Execute the SQL query to retrieve the data
order_data = execute_sql_query(sql_query)

# Display the data analysis result
show_to_user(order_data)","import pandas as pd

# SQL query to find the order with the highest discount applied
discount_query = '''
SELECT o.OrderID, SUM(od.Discount) AS TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderID
ORDER BY TotalDiscount DESC
LIMIT 1
'''

# Execute the SQL query
highest_discount_order = execute_sql_query(discount_query)

# Show the result to the user
show_to_user(highest_discount_order)","The input code calculates the total discount per order by summing up discounts, while the reference implementation finds the order with the highest discount per item directly from the order details. This results in potentially different orders being identified as the one with the highest discount.","
import pandas as pd

# Define the SQL query to find the order with the highest discount
sql_query = ""SELECT OrderID, MAX(Discount) as HighestDiscount FROM [Order Details] GROUP BY OrderID ORDER BY HighestDiscount DESC LIMIT 1;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","The input code uses MAX(Discount) and GROUP BY OrderID, which does not correctly find the order with the highest discount value. Instead, it should simply order by Discount and limit the result to one row, like the reference implementation.",None
Calculate the monthly total sales revenue over the last year and visualize it to show trends and patterns.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT MONTH(o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY MONTH(o.OrderDate) 
ORDER BY Month;
'''

# Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Convert Month Number to Month Name
sales_data['Month'] = sales_data['Month'].apply(lambda x: pd.to_datetime(f'2023-{x}-01').strftime('%B'))

# Plot the data using plotly
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Total Sales Revenue Over the Last Year', labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate monthly total sales revenue over the last year
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
       SUM(OrderDetails.UnitPrice * OrderDetails.Quantity * (1 - OrderDetails.Discount)) AS Total_Sales
FROM orders
JOIN [Order Details] AS OrderDetails ON orders.OrderID = OrderDetails.OrderID
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY Month
ORDER BY Month;
'''

# Execute SQL query and store the result in a dataframe
monthly_sales = execute_sql_query(sql_query)

# Create a line chart to visualize the total sales revenue trends
fig = px.line(monthly_sales, x='Month', y='Total_Sales',
              title='Monthly Total Sales Revenue Over the Last Year',
              labels={'Total_Sales': 'Total Sales Revenue', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)","The input code aggregates data over the last year using 'orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)', while the reference aggregates based on the current calendar year using 'YEAR(o.OrderDate) = YEAR(CURRENT_DATE)'. This leads to differing results if the current date is not at the start of a year.","The task requires the following:

1. Executing a SQL query to get the monthly total sales revenue over the last year.
2. Processing the returned DataFrame to ensure the correct display of dates.
3. Visualizing the data to show trends and patterns.

Here's the complete code to accomplish this:

```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the monthly total sales revenue over the last year
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m') 
ORDER BY Month;
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Sort the data by Month to ensure the trend is correctly displayed
sales_data['Month'] = pd.to_datetime(sales_data['Month'], format='%Y-%m')
sales_data.sort_values(by='Month', inplace=True)

# Generate the plotly visualization
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Total Sales Revenue Over the Last Year', labels={'Month': 'Month', 'TotalSales': 'Total Sales Revenue'})

# Show the visualization to the user
show_to_user(fig)
```

### Explanation:

1. **SQL Query**: A SQL query is executed to retrieve the monthly total sales revenue by joining the `orders` and `[Order Details]` tables.

2. **Data Processing**: The returned DataFrame is processed by converting the 'Month' column to a DateTime format to ensure the data is sorted correctly for visualization.

3. **Visualization**: Using Plotly's `line` chart function, the code generates a line graph showing the trend of monthly sales revenue over the past year.

4. **Display**: The resulting figure is displayed to the user with `show_to_user()` function. 

### Notes:
- Ensure that the `execute_sql_query` and `show_to_user` functions are defined in the environment.","The input code calculates the total sales without considering discounts, which is inconsistent with the reference code that includes discounts in the computation of total sales revenue.",None
How many units are currently in stock for each product?,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = 'SELECT ProductName, UnitsInStock FROM products;'

# Execute the query to get the data
products_df = execute_sql_query(sql_query)

# Display the data to user
show_to_user(products_df)","import pandas as pd

# SQL query to retrieve the number of units in stock for each product
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products
WHERE Discontinued = 0
""""""

# Executing the SQL query
products_in_stock = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_in_stock)","The input code includes a condition WHERE Discontinued = 0, which filters out discontinued products. The reference implementation does not include this condition, which means it counts units in stock for all products, not just those not discontinued. Hence, the input code does not fully match the business request or reference implementation.","import pandas as pd
import plotly.express as px

def get_current_stock():
    # SQL Query to get the current stock for each product
    sql_query = 'SELECT ProductID, UnitsInStock FROM products;'
    
    # Execute the SQL query and retrieve data
    products_df = execute_sql_query(sql_query)
    
    # Display the retrieved data to the user
    show_to_user(products_df)
    
    # Create a bar chart to visualize the current stock for each product
    fig = px.bar(products_df, x='ProductID', y='UnitsInStock', title='Current Stock Levels for Each Product', labels={'ProductID': 'Product ID', 'UnitsInStock': 'Units In Stock'})
    
    # Show the bar chart to the user
    show_to_user(fig)

# Call the function to execute it
get_current_stock()","The input code retrieves and displays the current stock for each product using the 'ProductID' instead of 'ProductName'. This addresses the business analytic request effectively, even though it differs from the reference implementation by using a different column for identification. Additionally, the input code provides a visualization, which is an added feature but does not hinder the fulfillment of the request.",Finetuned
List employees who have birthdays in the current month.,"import pandas as pd
from datetime import datetime

# Utility functions
# In the actual environment, these functions will be already provided.
# Here we define dummy versions to avoid execution errors during code generation.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function definition
    return pd.DataFrame()

def show_to_user(data):
    # Dummy function definition
    print(data)

# Get the current month
current_month = datetime.now().month

# SQL query to get employees with birthdays in the current month
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
WHERE MONTH(e.BirthDate) = {current_month};
""""""

# Execute the query and get the result as a pandas DataFrame
employees_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_df)","import pandas as pd
from datetime import datetime

# Get the current month as a string (MM format)
current_month = datetime.now().strftime('%m')

# SQL query to get employees with birthdays in the current month
sql_query = f""""""
SELECT EmployeeID, LastName, FirstName, BirthDate
FROM employees
WHERE MONTH(BirthDate) = {current_month}
""""""

# Execute the SQL query
df_employees_with_birthday = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df_employees_with_birthday)","The input code successfully identifies employees with birthdays in the current month using a similar approach to the reference implementation. The current month is extracted as a string (MM format) in the input code, which is consistent with how SQL may handle month extraction. The SQL query, execution, and result display processes are consistent with the reference implementation and effectively address the business analytic request.","import pandas as pd

# Define the SQL query to retrieve employees who have birthdays in the current month
sql_query = '''
SELECT EmployeeID, FirstName, LastName, BirthDate
FROM employees
WHERE MONTH(BirthDate) = MONTH(CURDATE());
'''

# Execute the SQL query and get the dataframe
employees_df = execute_sql_query(sql_query)

# Additional formatting can be done if necessary
# Convert the BirthDate to a more readable format (Optional)
# employees_df['BirthDate'] = pd.to_datetime(employees_df['BirthDate']).dt.strftime('%B %d, %Y')

# Display the resulting data to the user
show_to_user(employees_df)","The input code correctly implements the business analytic request by selecting employees who have birthdays in the current month using the SQL function MONTH in combination with CURDATE(). While the implementation slightly differs from the reference code, both effectively achieve the same result. The current month is dynamically obtained in both cases, meeting the requirement.",Base
What is the total sales revenue for each product? Visualize the revenue to compare product performances.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT P.ProductID, SUM(OD.Quantity * OD.UnitPrice) AS TotalSalesRevenue 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY P.ProductID;'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Generate a bar chart to visualize the total sales revenue per product
fig = px.bar(sales_data, x='ProductID', y='TotalSalesRevenue', title='Total Sales Revenue per Product', labels={'ProductID':'Product ID', 'TotalSalesRevenue':'Total Sales Revenue'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales revenue for each product
sql_query = '''
SELECT p.ProductID, p.ProductName,
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
''' 

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Visualize the total sales revenue for each product
fig = px.bar(sales_data, x='ProductName', y='TotalRevenue',
             title='Total Sales Revenue for Each Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

# Display the visualization to the user
show_to_user(fig)","The input code correctly calculates the total sales revenue for each product, including discounts, and visualizes it using Plotly. The inclusion of 'ProductName' enhances the visualization, aligning with the business analytic request to compare product performances. The core outcome aligns with the reference implementation, even though the inclusion of discounts results in slight logical variation.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT OD.ProductID, SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSalesRevenue 
FROM [Order Details] OD 
GROUP BY OD.ProductID
'''

# Step 2: Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Step 3: Visualize the total sales revenue for each product
fig = px.bar(sales_data, x='ProductID', y='TotalSalesRevenue', title='Total Sales Revenue per Product', labels={'ProductID': 'Product ID', 'TotalSalesRevenue': 'Total Sales Revenue'})

# Step 4: Display the result to the user
show_to_user(fig)","The input code includes a discount factor in the sales revenue calculation, which is not present in the reference implementation. This may lead to different results if discounts are applied in the order details.",Base
Who is the highest paid employee and what is their total sales?,"import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query
sql_query = '''
SELECT e.EmployeeID, e.Salary, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY e.Salary DESC
LIMIT 1;
'''

# Step 2: Execute the SQL query using execute_sql_query function
result_df = execute_sql_query(sql_query)

# Step 3: Add readability by renaming the columns
result_df.columns = ['EmployeeID', 'Salary', 'TotalSales']

# Step 4: Display the result using show_to_user function
show_to_user(result_df)
","import pandas as pd

# SQL query to find the highest paid employee and their total sales
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Salary
ORDER BY e.Salary DESC
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code correctly finds the highest paid employee and their total sales, similar to the reference code. It includes additional columns for employee FirstName and LastName, which does not affect the correctness of fulfilling the analytic request.","import pandas as pd
import plotly.express as px

# Define the SQL query
query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Title, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Title 
ORDER BY e.Salary DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(query)

# Display the result to the user
show_to_user(result_df)
","The input code does not order by salary to find the highest paid employee. It orders based on the total sales but not the salary, which is the key requirement. Hence, it does not fulfill the business analytic request.",Base
What is the average discount given for each supplier's products? Visualize the discounts to compare between suppliers.,"import plotly.express as px

# SQL query to get the average discount for each supplier's products
sql_query = '''
SELECT p.SupplierID, AVG(od.Discount) AS AvgDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discounts for each supplier
fig = px.bar(result_df, x='SupplierID', y='AvgDiscount',
             labels={'SupplierID': 'Supplier ID', 'AvgDiscount': 'Average Discount'},
             title='Average Discount Given for Each Supplier')

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate the average discount for each supplier's products
sql_query = '''
SELECT p.SupplierID, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
'''

# Execute the SQL query and retrieve the data
average_discount_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discount by supplier
fig = px.bar(average_discount_df, x='SupplierID', y='AverageDiscount',
             title='Average Discount Given for Each Supplier',
             labels={'AverageDiscount': 'Average Discount', 'SupplierID': 'Supplier ID'},
             color='AverageDiscount')

# Show the visualized data to the user
show_to_user(fig)","The input code correctly implements the business requirement. It calculates the average discount for each supplier and visualizes this data using a bar chart. While there are minor differences in column naming, it does not affect the overall functionality or correctness in addressing the request.","import plotly.express as px
import pandas as pd

# SQL Query to retrieve the average discounts per supplier
sql_query = '''
SELECT s.SupplierID, AVG(od.Discount) AS AverageDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY s.SupplierID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Correcting the column names due to SQL queries
result_df.columns = ['SupplierID', 'AverageDiscount']

# Visualizing the average discount per supplier
fig = px.bar(result_df, x='SupplierID', y='AverageDiscount', title='Average Discount per Supplier', labels={'SupplierID':'Supplier ID', 'AverageDiscount':'Average Discount'})

# Display the result
show_to_user(fig)
","The input code correctly retrieves the average discount for each supplier using SQL and visualizes it using a bar chart, fulfilling the business analytic request. The approach may differ slightly from the reference implementation, particularly in SQL query details, but it achieves the same outcome.",Base
Calculate the total sales revenue generated in the last month.,"import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue generated in the last month
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Get the current date and calculate the date range for last month
from datetime import datetime, timedelta

# Function to get the first and last date of the last month
def get_last_month_date_range():
    today = datetime.today()
    first_day_of_current_month = today.replace(day=1)
    last_day_of_last_month = first_day_of_current_month - timedelta(days=1)
    first_day_of_last_month = last_day_of_last_month.replace(day=1)
    return first_day_of_last_month, last_day_of_last_month

# Get the date range for last month
first_day, last_day = get_last_month_date_range()

# SQL query to calculate total sales revenue from orders in the last month
sql_query = f""""""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= '{first_day.strftime('%Y-%m-%d')}' 
AND o.OrderDate <= '{last_day.strftime('%Y-%m-%d')}'
""""""

# Execute SQL query and get results
result_df = execute_sql_query(sql_query)

# Show the total sales revenue to the user
show_to_user(result_df)","The input code correctly calculates the total sales revenue for the last month by determining the first and last days of the previous month. The SQL query is constructed to sum the sales revenue for orders within the specified date range, which matches the intended business analytic request. The approach differs in date calculation but achieves the same result as the reference implementation.","import pandas as pd
from datetime import datetime, timedelta
import plotly.express as px

# Define the SQL query
date_one_month_ago = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1).strftime('%Y-%m-%d')
sql_query = f""""""
    SELECT SUM(oi.UnitPrice * oi.Quantity) AS TotalSales 
    FROM orders o 
    JOIN [Order Details] oi ON o.OrderID = oi.OrderID 
    WHERE o.OrderDate >= '{date_one_month_ago}';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Get the total sales value
if not result_df.empty:
    total_sales = result_df.iloc[0]['TotalSales']
else:
    total_sales = 0

# Create a DataFrame to show the result
result_to_show = pd.DataFrame({'TotalSales': [total_sales]})

# Display the result to the user
show_to_user(result_to_show)","The input code differs from the reference by not accounting for the discount in calculating the total sales. The reference multiplies by (1 - Discount), which is missing in the input code.",Base
What is the total sales per employee for each month? Use visualization to compare performance across months.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, strftime('%Y-%m', o.OrderDate) as OrderMonth, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, OrderMonth;
'''

# Execute the SQL query and retrieve the data into a DataFrame
df = execute_sql_query(sql_query)

# Convert 'OrderMonth' to datetime for better plotting
df['OrderMonth'] = pd.to_datetime(df['OrderMonth'], format='%Y-%m')

# Use plotly to create a line plot
fig = px.line(df, x='OrderMonth', y='TotalSales', color='EmployeeID', markers=True,
              title='Total Sales per Employee for Each Month',
              labels={'OrderMonth': 'Order Month', 'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales per employee for each month
sql_query = '''
SELECT 
    e.EmployeeID, 
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, Month
ORDER BY 
    Month, EmployeeName
'''

# Executing the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Visualizing the total sales per employee for each month
fig = px.line(monthly_sales_df, x='Month', y='TotalSales', color='EmployeeName',
              title='Total Sales per Employee for Each Month',
              labels={'TotalSales': 'Total Sales', 'Month': 'Month'})
show_to_user(fig)","The input code effectively addresses the business analytic request by calculating the total sales per employee for each month using the provided SQL query. It uses Plotly to create a line plot for comparison across months. The output difference is in using 'EmployeeName' instead of 'EmployeeID' for visualization, which is a valid variation and still answers the business request.","To achieve the goal of comparing total sales per employee for each month using Python, we'll take the following steps:

1. Execute the SQL query to retrieve the data.
2. Process the data into a suitable format.
3. Visualize the data using a line plot to observe changes in performance across months.

Here’s how we can implement this in Python:

### Step 1: Execute the SQL query

```python
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, Month;
""""""

# Fetch data
employee_sales_df = execute_sql_query(sql_query)
```

### Step 2: Process the data

We will ensure that the `Month` column is treated as a datetime object for better plotting. 

```python
# Convert 'Month' to datetime for better plotting
employee_sales_df['Month'] = pd.to_datetime(employee_sales_df['Month'])

# Sort the data by Month
employee_sales_df = employee_sales_df.sort_values('Month')
```

### Step 3: Visualize the data

Using Plotly's line chart functionality to visualize total sales per employee for each month.

```python
import plotly.express as px

# Create a line plot for each employee
fig = px.line(employee_sales_df, x='Month', y='TotalSales', color='EmployeeID', 
              title='Total Sales per Employee for Each Month')

# Show the plot to the user
show_to_user(fig)
```

### Complete Code

Putting all the code snippets together:

```python
def main():
    # SQL query to get total sales per employee per month
    sql_query = """"""
    SELECT e.EmployeeID, e.FirstName, e.LastName, DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
    FROM employees e 
    JOIN orders o ON e.EmployeeID = o.EmployeeID 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    GROUP BY e.EmployeeID, Month;
    """"""

    # Fetch the data
    employee_sales_df = execute_sql_query(sql_query)
    
    # Convert 'Month' to datetime
    employee_sales_df['Month'] = pd.to_datetime(employee_sales_df['Month'])
    
    # Sort by Month
    employee_sales_df = employee_sales_df.sort_values('Month')

    # Create a line plot
    fig = px.line(employee_sales_df, x='Month', y='TotalSales', color='EmployeeID', 
                  title='Total Sales per Employee for Each Month')

    # Display the plot
    show_to_user(fig)

# Run the main function
main()
```

### Key Points:
- The `SHOW_TO_USER` function is presumed to be predefined and is employed to display the results.
- Plotly is utilized for interactive visualizations, enhancing data analysis by allowing zooming, hovering, and other interactive features.
- Ensure proper handling and sorting of the date data to make the visualizations accurate and interpretable.","The input code effectively addresses the business analytic request by executing an SQL query to calculate total sales per employee per month, processes the data by converting the date format for accurate plotting, and visualizes the total sales using a line plot. The output is similar to the reference implementation, fulfilling the request requirements.",Base
How does the total number of units sold compare between discontinued and active products? Visualize the comparison for better understanding.,"import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT products.Discontinued, SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.Discontinued
'''

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Ensure the column types are correct
result_df['Discontinued'] = result_df['Discontinued'].astype(bool)
result_df['TotalUnitsSold'] = result_df['TotalUnitsSold'].astype(int)

# Visualize the comparison using Plotly
fig = px.bar(result_df, x='Discontinued', y='TotalUnitsSold', title='Total Units Sold: Discontinued vs Active Products', labels={'Discontinued': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'}, barmode='group')

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to retrieve total units sold for discontinued and active products
sql_query = '''
SELECT p.Discontinued, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.Discontinued
'''

# Execute SQL query
units_sold_df = execute_sql_query(sql_query)

# Map Boolean values to more readable categories
units_sold_df['ProductStatus'] = units_sold_df['Discontinued'].map({0: 'Active', 1: 'Discontinued'})

# Create a bar chart to visualize the comparison
fig = px.bar(units_sold_df, x='ProductStatus', y='TotalUnitsSold',
             title='Total Units Sold Comparison: Active vs Discontinued Products',
             labels={'ProductStatus': 'Product Status', 'TotalUnitsSold': 'Total Units Sold'})

# Show the figure to the user
show_to_user(fig)",The input code correctly addresses the business request by executing a SQL query to compare total units sold for discontinued and active products. It visualizes the result with a bar chart using Plotly. The mapping of discontinued status to readable categories doesn't affect correctness and ensures clarity.,"import plotly.express as px

# SQL query to get the total number of units sold for both discontinued and active products
distribution_query = '''
SELECT p.Discontinued AS Is_Discontinued, SUM(od.Quantity) AS Total_Quantity_Sold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.Discontinued;
'''

# Execute the SQL query
dist_data = execute_sql_query(distribution_query)

# Ensure `Is_Discontinued` column is treated as a boolean for correct plotting
dist_data['Is_Discontinued'] = dist_data['Is_Discontinued'].astype(str)

# Generate the bar chart
fig = px.bar(dist_data, x='Is_Discontinued', y='Total_Quantity_Sold', 
             title='Total Units Sold Comparison: Discontinued vs Active Products', 
             labels={'Is_Discontinued': 'Product Status', 'Total_Quantity_Sold': 'Total Quantity Sold'})

# Show the plot to the user
show_to_user(fig)","Both implementations execute a SQL query that groups the total units sold by product status (discontinued or active). They differ slightly in the naming of columns but effectively provide the same data for visualization. The conversion of the 'Discontinued' status to a boolean in the reference and a string in the input code does not affect the outcome. Both generate a bar chart to compare units sold between the two categories, fulfilling the business analytic request.",Base
Count the total number of orders placed by each customer.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT CustomerID, COUNT(*) AS total_orders FROM orders GROUP BY CustomerID;'

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(orders_df)

# Optional: Visualize the result using a bar chart
fig = px.bar(orders_df, x='CustomerID', y='total_orders', title='Total Orders by Customer')
show_to_user(fig)","import pandas as pd

# SQL query to count total orders placed by each customer
sql_query = '''
SELECT customers.CustomerID, customers.CompanyName, COUNT(orders.OrderID) AS TotalOrders
FROM customers
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID, customers.CompanyName
ORDER BY TotalOrders DESC;
'''  

# Execute the SQL query and store the results in a DataFrame
orders_count_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(orders_count_df)","The input Python code correctly obtains the total number of orders placed by each customer. It uses a LEFT JOIN to ensure all customers are included and orders are counted correctly. The GROUP BY clause aggregates orders per customer, and despite additional ordering and displaying company names—not in the reference code—the essential requirement is met.","import pandas as pd
import plotly.express as px

# SQL Query to count total number of orders placed by each customer
sql_query = 'SELECT CustomerID, COUNT(*) AS TotalOrders FROM orders GROUP BY CustomerID;'

# Execute the SQL query and retrieve the data into a pandas dataframe
order_data = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(order_data)

# Optionally, visualize the data using a bar chart
fig = px.bar(order_data, x='CustomerID', y='TotalOrders', title='Total Number of Orders by Each Customer')

# Show the visualization to the user
show_to_user(fig)",The input code effectively meets the business analytic request by executing a SQL query to count total orders per customer and displays the result using the same logic as the reference implementation. The variable names differ but the functionality is equivalent.,Base
Identify the product categories with the lowest total sales revenue. Use visualization to highlight categories with low performance.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.CategoryID 
ORDER BY TotalRevenue ASC
LIMIT 5
'''

# Execute the SQL query to retrieve the data
categories_revenue_df = execute_sql_query(sql_query)

# Create a bar chart to highlight categories with low performance
fig = px.bar(categories_revenue_df, x='CategoryID', y='TotalRevenue', title='Categories with Lowest Total Sales Revenue', labels={'CategoryID':'Category ID', 'TotalRevenue':'Total Revenue'})

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Execute SQL query to get product sales data.
sales_query = '''
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY TotalSales ASC
'''

# Step 2: Retrieve the data into a pandas DataFrame.
sales_data = execute_sql_query(sales_query)

# Step 3: Visualize categories with low sales performance.
fig = px.bar(sales_data,
             x='CategoryID',
             y='TotalSales',
             title='Product Categories with Lowest Total Sales Revenue',
             labels={'CategoryID': 'Product Category ID', 'TotalSales': 'Total Sales Revenue'},
             color='TotalSales',
             color_continuous_scale='Viridis')

# Step 4: Show the figure to user.
show_to_user(fig)","Both the reference and input code correctly identify the product categories with the lowest total sales revenue by executing a similar SQL query. Although the input code does not include a LIMIT clause, it effectively visualizes the low-performing categories using a bar chart with Plotly, highlighting them with a continuous color scale. The outcome aligns with the business request.","The request is to identify product categories with the lowest total sales revenue and highlight them through visualization. Here's how we can achieve this step-by-step.

### Step 1: Database Query
We need to get the product categories with their total sales revenue. The SQL query for this purpose is:

```sql
SELECT CategoryID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalSalesRevenue
FROM [Order Details]
JOIN products ON products.ProductID = [Order Details].ProductID
GROUP BY CategoryID
ORDER BY TotalSalesRevenue ASC;
```

### Step 2: Fetching Data
We can execute this SQL query to retrieve the data. Let’s use the provided utility function `execute_sql_query(sql_query)` to fetch the data.

### Step 3: Visualization
Let's use the provided utility function `show_to_user(visual_obj)` to display the resulting plot.

Here's how we can achieve the full request:

```python
import pandas as pd
import plotly.express as px

# Step 1: Execute SQL query
sql_query = '''
SELECT CategoryID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalSalesRevenue 
FROM [Order Details] 
JOIN products ON products.ProductID = [Order Details].ProductID 
GROUP BY CategoryID 
ORDER BY TotalSalesRevenue ASC;
'''

# Fetch the data
data = execute_sql_query(sql_query)

# Step 2: Create a bar chart to visualize the categories with the lowest total sales revenue
fig = px.bar(data, x='CategoryID', y='TotalSalesRevenue', title='Product Categories with Lowest Total Sales Revenue', labels={'CategoryID':'Product Category', 'TotalSalesRevenue':'Total Sales Revenue'})

# Step 3: Highlight the bars that correspond to the lowest total sales revenue
fig.update_traces(marker_color='indianred')

# Step 4: Show the visualization to the user
show_to_user(fig)
```

### Explanation of the Code:
1. **Data Retrieval**: We use the `execute_sql_query` function to retrieve the data from the database.
2. **Data Visualization**: We utilize `plotly.express` to create a bar chart showing the product categories and their corresponding total sales revenue.
3. **Highlighting Low Performance**: The bars representing low performance are given a color highlight by modifying the default trace color.
4. **Result Display**: Finally, we present the visualization to the user with `show_to_user`.

By executing this complete code block, we will fetch the required data and create a visualization that highlights the product categories with the lowest total sales revenue.","The input code does not limit the number of categories displayed, unlike the reference which limits to the lowest 5 categories.",Base
Find the product categories with the highest average unit price.,"import pandas as pd
import plotly.express as px

# The SQL query to retrieve the required data
sql_query = '''
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice 
FROM products 
GROUP BY CategoryID 
ORDER BY AverageUnitPrice DESC;'''

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(df)

# Ensure df is not empty before plotting to prevent errors
if not df.empty:
    # Optionally, create a plotly figure for visualization
    fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Product Categories with Highest Average Unit Price')

    # Display the plot to the user
    show_to_user(fig)","import pandas as pd

# SQL query to find product categories with the highest average unit price
sql_query = '''
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
ORDER BY AverageUnitPrice DESC
'''

# Execute the SQL query and get the data
average_unit_price_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_unit_price_df)","The input code accurately performs the required SQL query and retrieves the product categories with the highest average unit price. It then displays the result, matching the core functionality of the reference implementation.","import pandas as pd

# Step 1: Define the SQL Query
sql_query = '''
SELECT c.CategoryName, AVG(p.UnitPrice) AS AvgUnitPrice 
FROM products p 
JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryName 
ORDER BY AvgUnitPrice DESC;
'''

# Step 2: Execute the query and get the results
result_df = execute_sql_query(sql_query)

# Step 3: Display the results
show_to_user(result_df)","The input code correctly retrieves and displays the product categories with the highest average unit price. It includes a JOIN to get category names and orders by descending average unit price, which matches the reference implementation's intended outcome.",Base
How many orders included products with a discount of more than 10%?,"import pandas as pd

# SQL query to count orders with a discount of more than 10%
sql_query = '''
SELECT COUNT(*) as order_count
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0.1;
'''

# Execute the SQL query to get the desired data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to fetch orders with products that have more than 10% discount
sql_query = '''
SELECT COUNT(DISTINCT o.OrderID) AS NumberOfOrders
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0.1
'''

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly counts distinct orders with a product discount of more than 10%, aligning with the business analytic request and achieving the same outcome as the reference implementation.","import pandas as pd

# Define the SQL query
sql_query = '''
SELECT COUNT(DISTINCT OrderID) AS OrdersWithHighDiscount 
FROM [Order Details] 
WHERE Discount > 0.10
'''

# Execute the SQL query and retrieve the result in a pandas dataframe
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result)
","The evaluated code counts distinct OrderIDs from the 'Order Details' table when Discount > 10%, while the reference code counts orders by joining the 'orders' table with 'Order Details'. These may differ if there are duplicate OrderIDs in 'Order Details' for the same order.",Base
What is the performance ranking of products based on sales quantity?,"import pandas as pd
import plotly.express as px

# Define the SQL query to get the performance ranking of products based on sales quantity
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalQuantity DESC;
'''

# Execute the SQL query and get the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Visualize the result using plotly
fig = px.bar(result_df, x='ProductName', y='TotalQuantity', title='Performance Ranking of Products Based on Sales Quantity', labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity Sold'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd

# SQL query to get the performance ranking of products based on sales quantity
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalSalesQuantity
FROM products
LEFT JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY TotalSalesQuantity DESC;
'''

# Execute the SQL query
product_performance_df = execute_sql_query(sql_query)

# Show the resulting dataframe to the user
show_to_user(product_performance_df)","The input code correctly addresses the business request to generate a performance ranking of products based on sales quantity. Both the input code and reference implementation query the required data by joining the 'products' and 'Order Details' tables, use SUM to calculate the total sales quantity, and order the results in descending order by total quantity. While the visualization step using Plotly is omitted in the input code, this does not affect the correctness with respect to the analytic request, which is focused on generating the ranking data. Therefore, the input code achieves the same outcome as the reference implementation.","Чтобы получить рейтинг производительности продуктов по количеству продаж, вы можете использовать SQL-запрос для извлечения необходимых данных из базы данных. Поскольку в вашем описании не указаны конкретные ограничения на количество отображаемых результатов, мы не будем ограничивать выборку. Передайте этот SQL-запрос в функцию `execute_sql_query()` и затем используйте `show_to_user()` для отображения данных:

```python
import pandas as pd

# SQL query to get performance ranking of products based on sales quantity
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC;
'''

# Execute the SQL query to get data
product_performance_df = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(product_performance_df)
```

# Объяснение кода:
1. **SQL-запрос:** Он выбирает `ProductName` и сумму `Quantity`, группируя по `ProductName` и сортируя по `TotalQuantity` по убыванию, чтобы получить рейтинг производительности продуктов.
2. **Выполнение SQL-запроса:** Используйте функцию `execute_sql_query`, чтобы получить DataFrame с результатами запроса.
3. **Показ данных пользователю:** С помощью функции `show_to_user` данные показываются пользователю в виде DataFrame.","The input code correctly addresses the business analytic request by executing an SQL query that retrieves the performance ranking of products based on sales quantity, and uses 'show_to_user' to display the results, matching the outcome of the reference implementation.",Base
List the orders grouped by required dates and their total freight costs.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT RequiredDate, SUM(Freight) AS TotalFreightCost
FROM orders
GROUP BY RequiredDate;
'''

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Display the data
show_to_user(orders_df)

# Create a new column with formatted RequiredDate for better visualization
date_format = '%Y-%m-%d'
orders_df['FormattedDate'] = pd.to_datetime(orders_df['RequiredDate']).dt.strftime(date_format)

# Visualize the data using plotly
fig = px.bar(orders_df, x='FormattedDate', y='TotalFreightCost', title='Total Freight Cost by Required Date')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd

# SQL query to list the orders grouped by required dates and their total freight costs
sql_query = '''
SELECT RequiredDate, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY RequiredDate
ORDER BY RequiredDate
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly executes a SQL query to group orders by 'RequiredDate' and calculates the total freight costs, matching the business request and reference implementation. Visualizations are not required for correctness.","import pandas as pd
import plotly.express as px

# SQL query to retrieve orders grouped by required dates and their total freight costs
sql_query = 'SELECT RequiredDate, SUM(Freight) AS TotalFreightCost FROM orders GROUP BY RequiredDate;'

# Execute the SQL query to fetch data
orders_df = execute_sql_query(sql_query)

# Group the data by RequiredDate and calculate the total freight cost
# orders_df = orders_df.groupby('RequiredDate').agg({'Freight': 'sum'}).reset_index()

# Display the data to the user
show_to_user(orders_df)

# Optional: Visualization using Plotly
fig = px.bar(orders_df, x='RequiredDate', y='TotalFreightCost', title='Total Freight Cost by Required Date')

# Show the plot to the user
show_to_user(fig)","The input code correctly implements the business request by retrieving the total freight costs grouped by required dates using SQL. It also effectively displays and visualizes the results using Plotly, matching the reference implementation's outcome.",Base
Calculate the month-over-month growth rate of total sales for December 2023 and visualize the trend.,"import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = '''
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
       (SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) - LAG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) OVER (ORDER BY DATE_FORMAT(o.OrderDate, '%Y-%m'))) / LAG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) OVER (ORDER BY DATE_FORMAT(o.OrderDate, '%Y-%m')) AS MoM_GrowthRate 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') IN ('2023-11', '2023-12')
GROUP BY DATE_FORMAT(o.OrderDate, '%Y-%m')
ORDER BY DATE_FORMAT(o.OrderDate, '%Y-%m');
'''

# Execute SQL query
sales_data = execute_sql_query(sql_query)

# Ensure dataframe is not empty
if sales_data.empty:
    raise ValueError('The query returned no results.')

# Extract the month-over-month growth rate from the sales_data
mom_growth_rate_november = sales_data['MoM_GrowthRate'].iloc[0]
mom_growth_rate_december = sales_data['MoM_GrowthRate'].iloc[1]

# Preparing data for visualization
trend_data = pd.DataFrame({
    'Month': ['2023-11', '2023-12'],
    'MoM_GrowthRate': [mom_growth_rate_november, mom_growth_rate_december]
})

# Plot the trend
fig = px.line(trend_data, x='Month', y='MoM_GrowthRate', title='Month-over-Month Growth Rate of Total Sales', labels={'MoM_GrowthRate': 'MoM Growth Rate'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL queries to fetch monthly total sales
query = '''
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM
    orders o
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
WHERE
    OrderDate >= '2023-11-01' AND OrderDate <= '2023-12-31'
GROUP BY
    month
ORDER BY
    month;
'''

# Execute SQL query
monthly_sales = execute_sql_query(query)

# Calculate month-over-month growth rate
monthly_sales['growth_rate'] = monthly_sales['total_sales'].pct_change()*100

# Visualization of the trend
fig = px.line(monthly_sales, x='month', y='growth_rate',
              title='Month-over-Month Growth Rate of Total Sales',
              labels={'growth_rate': 'Growth Rate (%)', 'month': 'Month'})

# Show visualization to user
show_to_user(fig)","The input code calculates the month-over-month growth rate of total sales for December 2023 by querying the necessary data, computing the percentage change using `pct_change`, and visualizing it with Plotly. It successfully addresses the business analytic request and achieves the same outcome as the reference implementation, albeit with a slightly different approach.","To calculate the month-over-month growth rate of total sales for December 2023 and visualize the trend, you can follow these steps:

1. **Calculate total sales for December 2023.**
2. **Calculate total sales for November 2023.**
3. **Compute the month-over-month growth rate.**
4. **Visualize the trend data leading up to December 2023.**

Here’s a detailed Python code to achieve this:

```python
import pandas as pd
import plotly.express as px

# SQL queries to fetch the total sales for December 2023 and November 2023
december_sales_query = '''
SELECT o.OrderDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-12-01' AND '2023-12-31'
GROUP BY o.OrderDate;
'''

november_sales_query = '''
SELECT o.OrderDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-11-01' AND '2023-11-30'
GROUP BY o.OrderDate;
'''

# Execute SQL queries
december_sales = execute_sql_query(december_sales_query)
november_sales = execute_sql_query(november_sales_query)

# Calculate the total sales for November 2023 and December 2023
december_total_sales = december_sales['TotalSales'].sum()
november_total_sales = november_sales['TotalSales'].sum()

# Compute the month-over-month growth rate for December 2023
if november_total_sales != 0:  # To avoid division by zero
    month_over_month_growth = (december_total_sales - november_total_sales) / november_total_sales * 100
else:
    month_over_month_growth = december_total_sales  # If November sales is 0, growth is equal to December sales

# Display the growth rate
print(f'Month-over-Month Growth Rate for December 2023: {month_over_month_growth:.2f}%')

# Prepare data for visualization
# Merging the sales data for November and December to visualize the trend
nov_dec_sales_data = pd.DataFrame({
    'Month': ['November', 'December'],
    'TotalSales': [november_total_sales, december_total_sales],
    'GrowthRate': [0, month_over_month_growth]  # Growth rate for November is 0 as it is the baseline
})

# Plotting the trend using Plotly
fig = px.bar(nov_dec_sales_data, x='Month', y='TotalSales',
             hover_data=['GrowthRate'], # Show growth rate in tooltip
             title='Month-over-Month Sales Trend (Nov-Dec 2023)',
             labels={'TotalSales': 'Total Sales ($)', 'GrowthRate': 'Growth Rate (%)'}
            )

# Show the plot to the user
show_to_user(fig)
```

### Explanation:
- **SQL Queries:** We are fetching the sales data for November and December 2023.
- **Calculations:** The script calculates the total sales for both months and derives the growth rate for December compared to November.
- **Data Visualization:** The sales data and growth rate are visualized using a bar chart, with appropriate labels.
- **Displaying Result:** Finally, the result is shown to the user, which is normally done within the function defined in the environment.

Before executing the code, make sure that the utility functions `execute_sql_query` and `show_to_user` are defined in your environment as they are crucial for running this code. Also, ensure you have `plotly` and other visualization libraries installed in your Python environment.","The input code incorrectly calculates the month-over-month growth rate. It sums daily sales for November and December separately, then calculates the growth rate, whereas the reference implementation computes total sales by month and calculates growth using SQL with LAG for accurate calculation. The input methodology may fail if November has zero sales as it uses the sum of daily totals.",Base
How does the average unit price of products vary across categories? Provide a visualization to compare the categories.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT products.CategoryID, AVG(products.UnitPrice) AS AverageUnitPrice FROM products GROUP BY products.CategoryID;'

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Create a bar chart to compare the average unit price across categories
fig = px.bar(result_df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price Across Categories', 
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'},
             template='plotly_white')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average unit price per category
sql_query = '''
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
'''

# Execute SQL query to get the data
average_price_df = execute_sql_query(sql_query)

# Creating a visualization using plotly
fig = px.bar(average_price_df, x='CategoryID', y='AverageUnitPrice',
             title='Average Unit Price of Products by Category',
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})

# Show the visualization to the user
show_to_user(fig)","The input code includes a JOIN with the 'Order Details' table, which alters the logic compared to the reference implementation by potentially affecting the aggregation of Unit Prices. The reference only considers the products table for calculating average unit prices by category.","import pandas as pd
import plotly.express as px

# SQL Query to fetch average unit price per category
sql_query = '''
SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice 
FROM products 
GROUP BY CategoryID 
ORDER BY AverageUnitPrice DESC;'''

# Execute the SQL Query
categories_avg_price_df = execute_sql_query(sql_query)

# Visualizing the data using plotly
fig = px.bar(categories_avg_price_df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Category')

# Display the result to the user
show_to_user(fig)","The input code successfully performs the required task of calculating and visualizing the average unit price of products across categories. It uses the same SQL query logic to retrieve the correct data and employs Plotly to create a bar chart for visualization, similar to the reference implementation. The order of categories by average price does not affect the correctness as it still addresses the business analytic request.",Finetuned
What is the most common shipping city for the current year?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if result is empty
if not result_df.empty:
    most_common_city = result_df.iloc[0]['ShipCity']
    order_count = result_df.iloc[0]['OrderCount']
    
    # Display the result
    show_to_user(result_df)
else:
    print(""No data available for the current year."")","import pandas as pd

# Define the SQL query to get the most common shipping city for the current year
current_year = pd.to_datetime('now').year
sql_query = f""""""
SELECT ShipCity, COUNT(*) as city_count
FROM orders
WHERE YEAR(OrderDate) = {current_year}
GROUP BY ShipCity
ORDER BY city_count DESC
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly addresses the business analytic request. Both the input and reference implementations execute an SQL query to retrieve the most common shipping city for the current year, then display the results. The logic and outcome are consistent between the two codes.","import pandas as pd
import plotly.express as px

def main():
    # Construct the SQL query to find the most common shipping city
    sql_query = '''
    SELECT ShipCity, COUNT(*) AS ShippingCount 
    FROM orders 
    WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
    GROUP BY ShipCity 
    ORDER BY ShippingCount DESC 
    LIMIT 1;
    '''
    
    # Execute the SQL query using the provided function
    result_df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(result_df)

def execute_sql_query(query):
    # This function is provided to run SQL queries
    pass

def show_to_user(data):
    # This function is provided to display data to the user
    pass

# Call the main function to execute the script
main()","The input code correctly constructs and executes an SQL query to find the most common shipping city for the current year, matching the logic of the reference implementation. It effectively addresses the business analytic request by ordering cities by count and retrieving the top result.",Base
How many products have a reorder level of zero?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS ZeroReorderProducts FROM products WHERE ReorderLevel = 0""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to count the number of products with a reorder level of zero
sql_query = """"""
SELECT COUNT(*) AS ProductCount
FROM products
WHERE ReorderLevel = 0
""""""

# Execute SQL query and get the results in a dataframe
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly executes a SQL query to count products with a reorder level of zero, similar to the reference implementation. The minor difference in the column alias name does not affect the correctness.","import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS ProductsAtZeroReorderLevel FROM products WHERE ReorderLevel = 0""

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly addresses the business analytic request by executing an SQL query that counts the number of products with a ReorderLevel of 0. The output is displayed using the provided utility functions, achieving the same outcome as the reference implementation.",Base
What is the total revenue generated by each product? Provide a visualization to compare the revenue per product.,"import pandas as pd
import plotly.express as px

# Function to execute SQL query
sql_query = """"""
SELECT p.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
INNER JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID;
""""""

data_frame = execute_sql_query(sql_query)

# Ensure the data frame column names match the SQL query
if 'ProductID' not in data_frame.columns or 'TotalRevenue' not in data_frame.columns:
    raise ValueError('Unexpected dataframe structure')

# Create a plotly bar chart to compare revenue per product
df = pd.DataFrame(data_frame)
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Total Revenue per Product', labels={'ProductID':'Product ID', 'TotalRevenue':'Total Revenue'})

# Show the plotly figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue generated by each product
sql_query = '''
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalRevenue DESC;
'''

# Execute the SQL query and retrieve data into a pandas DataFrame
revenue_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total revenue generated by each product
fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue',
             title='Total Revenue Generated by Each Product',
             labels={'ProductName': 'Product Name', 'TotalRevenue': 'Total Revenue'},
             color='TotalRevenue',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the visualization to the user
show_to_user(fig)","The input code calculates total revenue by each product using ProductName instead of ProductID, which effectively fulfills the business analytic request. It also visualizes the result with a Plotly bar chart, similar to the reference implementation. The differences in column names and color scaling do not affect the correctness of the outcome.","import plotly.express as px
import pandas as pd

# Execute the SQL query to retrieve the data
sql_query = '''
SELECT p.ProductID, p.UnitPrice * SUM(od.Quantity) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID; 
'''

# Fetch the data
product_revenue_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue per product
fig = px.bar(product_revenue_df, x='ProductID', y='TotalRevenue', title='Total Revenue per Product', labels={'ProductID': 'Product ID', 'TotalRevenue': 'Total Revenue'}, text='TotalRevenue')

# Show the plot to the user
show_to_user(fig)","The input code computes revenue incorrectly by multiplying UnitPrice by the sum of Quantity, without accounting for any Discount applied. The reference implementation correctly adjusts for Discount in calculating TotalRevenue. Therefore, the input code does not match the intended business analytic request.",Base
"Find the total quantity sold for each product, excluding discontinued products.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalQuantitySold 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE products.Discontinued = 0 
GROUP BY products.ProductID, products.ProductName;
''' 

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result dataframe to user
show_to_user(result_df)

# Create a bar chart to visualize the total quantity sold for each product
fig = px.bar(result_df, x='ProductName', y='TotalQuantitySold', title='Total Quantity Sold for Each Product', labels={'ProductName': 'Product Name', 'TotalQuantitySold': 'Total Quantity Sold'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd

# SQL query to get the total quantity sold for each product excluding discontinued products
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductID, p.ProductName
'''  

# Executing the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Displaying the result to the user
show_to_user(result_df)","The input code accurately executes the SQL query to calculate the total quantity sold for each product excluding discontinued ones, matching the business analytic request. Although it doesn't include visualization, this wasn't explicitly required by the business request.","import pandas as pd
import plotly.express as px

# SQL query to find total quantity sold for each product, excluding discontinued products
sql_query = '''
SELECT p.ProductID, SUM(od.Quantity) AS TotalQuantitySold
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductID;
'''

# Execute the SQL query
data = execute_sql_query(sql_query)

# Validate data to ensure 'TotalQuantitySold' is present
if 'TotalQuantitySold' not in data.columns:
    raise ValueError('TotalQuantitySold column is missing from the result.')

# Display the result to the user
show_to_user(data)

# Create a bar chart for better visualization
fig = px.bar(data, x='ProductID', y='TotalQuantitySold', title='Total Quantity Sold for Each Product', labels={'ProductID':'Product ID', 'TotalQuantitySold':'Total Quantity Sold'})

# Show the bar chart to the user
show_to_user(fig)","The evaluated code does not include the 'ProductName' column in the result, which is used in the reference code for visualization. This could hinder correct identification of products by name in the output.",Base
Determine the average discount applied across all products.,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details]'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the result is displayed
show_to_user(result_df)","import pandas as pd

# Query to retrieve the discount data from the [Order Details] table
sql_query = ""SELECT Discount FROM [Order Details]""

# Execute the SQL query and retrieve the data in a pandas dataframe
discount_data = execute_sql_query(sql_query)

# Calculate the average discount applied across all products
average_discount = discount_data['Discount'].mean()

# Prepare the result as a dataframe for displaying to the user
result_df = pd.DataFrame({'Average Discount': [average_discount]})

# Show the result to the user
show_to_user(result_df)","The input Python code correctly calculates the average discount using SQL to fetch the discount data, computes the mean, and displays the result in a dataframe, matching the intent of the reference implementation and the business analytic request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG(Discount) AS AvgDiscount FROM [Order Details];'

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the retrieved data to the user
show_to_user(result_df)

# Since the result is likely to be a single value in a dataframe,
# we can extract and display it directly if needed
avg_discount = result_df.iloc[0]['AvgDiscount']
avg_discount_series = pd.Series({'AvgDiscount': avg_discount})
show_to_user(avg_discount_series)","The input code correctly calculates the average discount using the SQL query and displays the result just like the reference implementation. The additional processing to extract and potentially display the average discount as a separate series is correct and does not affect the outcome. Therefore, it successfully addresses the business analytic request.",Base
How many orders were placed each month in the last year? Visualize the monthly order counts.,"import pandas as pd
import plotly.express as px

# SQL query to get the monthly order counts
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query and get the result in a pandas dataframe
order_counts_df = execute_sql_query(sql_query)

# Create a line plot to visualize the monthly order counts
fig = px.line(order_counts_df, x='Month', y='OrderCount', title='Monthly Order Counts in the Last Year', labels={'Month': 'Month', 'OrderCount': 'Order Count'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to get the count of orders placed each month in the last year
query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query
monthly_orders = execute_sql_query(query)

# Check that we received data
if not monthly_orders.empty:
    # Create a line plot using Plotly 
    fig = px.line(monthly_orders, x='OrderMonth', y='OrderCount',
                  title='Monthly Orders Placed in the Last Year',
                  labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'})
    
    # Display the plot to the user
    show_to_user(fig)
else:
    print('No data available for the given period.')",The input code correctly addresses the business analytic request by executing an SQL query to obtain monthly order counts for the last year and visualizes these counts using a Plotly line plot. It properly handles the case where no data is available and uses the provided utility functions as required.,"
```python
# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to get monthly order counts for the last year
sql_query = '''
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, COUNT(*) AS OrderCount 
FROM orders 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY Month 
ORDER BY Month;'''

# Execute the SQL query and get the results in a dataframe
orders_df = execute_sql_query(sql_query)

# Ensure the Month column is treated as a string for correct sorting in the graph
orders_df['Month'] = orders_df['Month'].astype(str)

# Create a bar chart to visualize the monthly order counts
fig = px.bar(orders_df, x='Month', y='OrderCount', title='Monthly Order Counts for the Last Year', labels={'OrderCount':'Number of Orders', 'Month':'Month'})

# Display the figure
show_to_user(fig)
```","The input code incorrectly extracts the month using EXTRACT(MONTH FROM OrderDate), which results in numeric month values. The reference implementation uses DATE_FORMAT(OrderDate, '%Y-%m') to ensure the year and month in 'YYYY-MM' format, allowing it to differentiate between months of different years. This is crucial for accurate analysis, especially when dealing with overlapping months from different years. Additionally, the input code uses a bar chart instead of a line plot, which is not a critical issue but deviates from the reference solution visualization approach.",Base
"List the count of products in each category, supplied by supplier.","import pandas as pd
import plotly.express as px

# SQL query to get the count of products in each category supplied by supplier
sql_query = '''
SELECT s.SupplierID, s.CompanyName, p.CategoryID, COUNT(p.ProductID) AS ProductCount
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID, s.CompanyName, p.CategoryID;''' 

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, if you want a visualization, you can use plotly to create a bar chart
fig = px.bar(result_df, x='CompanyName', y='ProductCount', color='CategoryID', 
             title='Product Count by Supplier and Category', labels={
                 'CompanyName': 'Supplier',
                 'ProductCount': 'Number of Products',
                 'CategoryID': 'Category ID'
             })

# Show the visualization to the user
show_to_user(fig)","import pandas as pd

# SQL query to count products in each category, supplied by supplier
sql_query = '''
SELECT
    s.SupplierID,
    s.CompanyName,
    p.CategoryID,
    COUNT(p.ProductID) AS ProductCount
FROM
    suppliers s
JOIN
    products p ON s.SupplierID = p.SupplierID
GROUP BY
    s.SupplierID, s.CompanyName, p.CategoryID
ORDER BY
    s.CompanyName, p.CategoryID
'''

# Execute the SQL query
supplier_product_count_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(supplier_product_count_df)","The input Python code correctly implements the business analytic request by listing the count of products in each category, supplied by supplier. It executes the same SQL query as the reference implementation to achieve the same outcome. The only difference is the inclusion of an ORDER BY clause, which does not affect the correctness of the data aggregation result.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CategoryID, COUNT(p.ProductID) AS ProductCount, p.SupplierID
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID, p.SupplierID;
'''

# Execute the SQL query and get the result in a pandas dataframe
products_info_df = execute_sql_query(sql_query)

# Display the result dataframe to the user
data_display = []
data_display.append(products_info_df)
show_to_user(products_info_df)

# Create a visualization using plotly
fig = px.bar(products_info_df, x='SupplierID', y='ProductCount', color='CategoryID', barmode='group',
            title='Count of Products in Each Category, Supplied by Supplier',
            labels={'ProductCount': 'Count of Products', 'SupplierID': 'Supplier ID', 'CategoryID': 'Category ID'})

# Display the plotly visualization
show_to_user(fig)","The input code groups by CategoryID and SupplierID, omitting the CompanyName. The reference groups by SupplierID and CompanyName, CategoryID. Results could differ if SupplierID maps to multiple CompanyNames.",Base
What is the average order fulfillment time for March 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageFulfillmentTime 
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-03-31';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to calculate the average order fulfillment time for March 2023
sql_query = '''
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE OrderDate >= '2023-03-01' AND OrderDate < '2023-04-01'
'''  

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly calculates the average order fulfillment time for March 2023. It uses the same logic as the reference implementation: calculating the average of the difference between 'ShippedDate' and 'OrderDate'. The date range is equivalent to March 2023, and both codes display the result using the utility functions provided.","import pandas as pd
import datetime

# Executing the SQL query to get the data
sql_query = ""SELECT * FROM orders WHERE SHIPPED_DATE BETWEEN '2023-03-01' AND '2023-03-31'""

# Fetch the orders data for March 2023
orders_data = execute_sql_query(sql_query)

# Convert the ORDER_DATE and SHIPPED_DATE to datetime if not already in datetime format
orders_data['ORDER_DATE'] = pd.to_datetime(orders_data['ORDER_DATE'])
orders_data['SHIPPED_DATE'] = pd.to_datetime(orders_data['SHIPPED_DATE'])

# Calculate order fulfillment time
orders_data['FULFILLMENT_TIME'] = orders_data['SHIPPED_DATE'] - orders_data['ORDER_DATE']

# Filter data only for the month of March 2023
march_fulfillment_times = orders_data[(orders_data['ORDER_DATE'].dt.month == 3) & (orders_data['ORDER_DATE'].dt.year == 2023)]

# Calculate the average fulfillment time
average_fulfillment_time = march_fulfillment_times['FULFILLMENT_TIME'].mean()

# Create a DataFrame to display
result_df = pd.DataFrame({'Average Fulfillment Time (March 2023)': [average_fulfillment_time]})

# Display the result to the user
show_to_user(result_df)","The input code calculates fulfillment time using both ORDER_DATE and SHIPPED_DATE from the same month (March). This may exclude orders placed before March but shipped during March, which the reference implementation captures. The SQL query in the input code should compare ORDER_DATE for the entire March range as in the reference code.",Base
Identify the top 3 suppliers based on the total sales value of their products. Visualize the sales value comparison.,"
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT SupplierID, SUM([Order Details].UnitPrice * Quantity) AS TotalSalesValue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY SupplierID 
ORDER BY TotalSalesValue DESC 
LIMIT 3;'''

# Execute SQL query to get the data
supplier_sales_df = execute_sql_query(sql_query)

# Create a bar chart for sales value comparison
fig = px.bar(supplier_sales_df, x='SupplierID', y='TotalSalesValue', title='Top 3 Suppliers based on Total Sales Value', labels={'SupplierID': 'Supplier ID', 'TotalSalesValue': 'Total Sales Value'})

# Show the plot to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales value for each supplier
sql_query = '''
SELECT p.SupplierID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalSales DESC
LIMIT 3
'''  

# Execute SQL query to retrieve top 3 suppliers based on total sales value
suppliers_df = execute_sql_query(sql_query)

# Visualization of sales value comparison
fig = px.bar(suppliers_df, x='SupplierID', y='TotalSales',
             title='Top 3 Suppliers by Total Sales Value',
             labels={'SupplierID': 'Supplier ID', 'TotalSales': 'Total Sales Value'})

# Show the result to the user
show_to_user(fig)","The input code differs from the reference code in that it accounts for a discount in the sales calculation, which is not considered in the reference implementation. This leads to a potentially different outcome, and therefore it does not meet the specified business analytic request exactly as intended by the reference.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSalesValue 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID, s.CompanyName 
ORDER BY TotalSalesValue DESC 
LIMIT 3;
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales value comparison
fig = px.bar(result_df, x='CompanyName', y='TotalSalesValue', title='Top 3 Suppliers by Total Sales Value',
             labels={'CompanyName': 'Supplier', 'TotalSalesValue': 'Total Sales Value'})

# Show the plot to the user
show_to_user(fig)","The input code correctly identifies the top 3 suppliers based on total sales value. It handles the same data by executing a SQL query, similar to the reference implementation, with an additional calculation incorporating discounts. The visualization displays the sales values, fulfilling the business request.",Finetuned
List all products that need reordering.,"import pandas as pd

# Business Analytic Request: List all products that need reordering
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;'

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(products_df)","import pandas as pd

# SQL query to list products that need reordering based on their stock levels
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;
""""""

# Execute the SQL query and retrieve the data
reordering_products = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(reordering_products)","The input code filters products based on the 'Discontinued' status, which the reference implementation does not. Therefore, the outcomes might differ, and it does not fully address the business analytic request as specified.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock <= ReorderLevel;'

# Execute the SQL query to retrieve data
products_needing_reorder = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not products_needing_reorder.empty:
    # Display the result to the user
    show_to_user(products_needing_reorder)
else:
    print('No products require reordering.')","The input code correctly lists products that need reordering by executing a SQL query that selects products where UnitsInStock is less than or equal to ReorderLevel, consistent with the reference implementation. It also checks if the result is empty, providing output only when necessary.",Finetuned
What is the average order fulfillment time by month for 2023? Provide a visualization to show the monthly average fulfillment times.,"import pandas as pd
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the month column is treated as a datetime object
# This will allow plotly to sort the x-axis correctly by month
# Convert month column to datetime
df['month'] = pd.to_datetime(df['month'], format='%Y-%m')

# Sort the DataFrame by month to ensure correct plotting order
df = df.sort_values('month')

# Create a line plot of the average fulfillment time by month
fig = px.line(df, x='month', y='avg_fulfillment_time', title='Average Order Fulfillment Time by Month for 2023', labels={'month': 'Month', 'avg_fulfillment_time': 'Average Fulfillment Time (Days)'})

# Show the resulting plot to the user
show_to_user(fig)
}","import pandas as pd
import plotly.express as px

# SQL query to get average order fulfillment time by month for 2023
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS order_month, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM orders 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY order_month
""""""

# Execute the SQL query and store the results in a DataFrame
fulfillment_data = execute_sql_query(sql_query)

# Visualize the average order fulfillment times by month
fig = px.line(fulfillment_data, x='order_month', y='avg_fulfillment_time', title='Average Order Fulfillment Time by Month in 2023')

# Show the visualization to the user
show_to_user(fig)","The input code does not ensure that the 'order_month' column is converted to a datetime object, which might lead to incorrect sorting on the x-axis of the plot. The reference implementation converts the 'month' to datetime to address this issue.","import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
WHERE DATE_FORMAT(OrderDate, '%Y') = '2023' 
GROUP BY Month
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Ensure the Month column is treated as a datetime type
orders_df['Month'] = pd.to_datetime(orders_df['Month'] + '-01')

# Convert Month to string for better sorting during visualization
orders_df['Month'] = orders_df['Month'].dt.strftime('%Y-%m')

# Sort the dataframe by Month
orders_df = orders_df.sort_values(by='Month')

# Create a line plot to visualize the data
fig = px.line(orders_df, x='Month', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Month for 2023', labels={'Month': 'Month', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'})

# Show the plot to the user
show_to_user(fig)
","The input code correctly calculates the average order fulfillment time by month for 2023. It retrieves and processes the data using a SQL query, formats the 'Month' column appropriately to ensure correct sorting for visualization, and creates a line plot. The output has the same functionality as the reference implementation, despite minor differences in handling the 'Month' column. Both codes provide the required visualization for analysis.",Finetuned
Which products have less than 10 units in stock?,"import pandas as pd
import plotly.express as px

# SQL query to find products with less than 10 units in stock
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE UnitsInStock < 10;""

# Execute the SQL query and retrieve the data as a pandas dataframe
# Utilize the provided utility function `execute_sql_query` to fetch the data
data = execute_sql_query(sql_query)

# Ensure that the dataframe is indeed fetched successfully
display(data)

# Display the data to the user
show_to_user(data)

# Optional: Create a bar chart to visualize the products and their stock levels
fig = px.bar(data, x='ProductName', y='UnitsInStock', title='Products with Less Than 10 Units in Stock', labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units In Stock'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd

# Define the SQL query to find products with less than 10 units in stock
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
WHERE UnitsInStock < 10
""""""

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)",The provided code successfully fulfills the business analytic request by executing a SQL query to find products with less than 10 units in stock and uses the 'show_to_user' function to display the result. The inclusion of additional fields like ProductID does not impact the fulfillment of the request.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock < 10;'

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the resultant dataframe to the user
show_to_user(products_df)","The input code only selects the 'ProductName' column from products where 'UnitsInStock' is less than 10. However, the business request is also to report the 'UnitsInStock'. The output does not include the 'UnitsInStock', unlike the reference implementation which selects both 'ProductName' and 'UnitsInStock'.",Base
Which employee processed the most orders?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT EmployeeID, COUNT(OrderID) AS TotalOrders FROM orders GROUP BY EmployeeID ORDER BY TotalOrders DESC LIMIT 1;""

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to find the employee who processed the most orders
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
'''  

# Execute the SQL query and fetch the results
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code executes a SQL query to find the employee who processed the most orders, identical to the reference implementation in logic and outcome. Both scripts group by EmployeeID, count OrderID, order by the count in descending order, and limit the result to the top entry. Therefore, it fulfills the business request correctly.","import pandas as pd
import plotly.express as px

# SQL Query to find the employee who processed the most orders
df = execute_sql_query(""SELECT EmployeeID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY EmployeeID ORDER BY OrderCount DESC LIMIT 1;"")

# Display the result to the user
show_to_user(df)","The input code accurately addresses the business request by executing a SQL query to find the employee with the most processed orders. It matches the reference implementation's logic and outcome, differing only in non-essential column naming.",Base
Identify the customer with the most late shipments.,"import pandas as pd
import plotly.express as px

# SQL query to identify the customer with the most late shipments
sql_query = '''
SELECT c.CustomerID, COUNT(o.OrderID) AS LateOrderCount 
FROM customers c JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.RequiredDate < o.ShippedDate 
GROUP BY c.CustomerID 
ORDER BY LateOrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query and get the result into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","import pandas as pd

# SQL query to retrieve customers with the number of late shipments
sql_query = '''
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS LateShipments
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY c.CustomerID, c.CompanyName
ORDER BY LateShipments DESC
LIMIT 1;
'''

# Execute the SQL query and store the results in a dataframe
late_shipments_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(late_shipments_df)","The input code effectively accomplishes the same business analytic request as the reference implementation by identifying the customer with the most late shipments. It correctly counts late shipments, includes the company name, and limits the result to the top customer, thus achieving the same outcome using slightly adjusted SQL syntax.","
import pandas as pd
import plotly.express as px

# SQL query to identify the customer with the most late shipments
sql_query = '''
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS LateCount 
FROM customers c 
JOIN orders o 
ON c.CustomerID = o.CustomerID 
WHERE o.ShippedDate > o.RequiredDate 
GROUP BY c.CustomerID, c.CompanyName 
ORDER BY LateCount DESC 
LIMIT 1;
'''

# Execute the SQL query and fetch the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, create a bar plot for better visualization (comment this out if not needed)
fig = px.bar(result_df, x='CustomerID', y='LateCount', title='Customer with Most Late Shipments')
show_to_user(fig)
","The input code correctly identifies the customer with the most late shipments by executing a SQL query to count orders where the shipped date is later than the required date. The query orders the results by the count in descending order and limits the output to one customer, similar to the reference implementation. The additional inclusion of 'CompanyName' in the query does not affect the correctness regarding the business analytic request, as it still identifies the correct customer by the maximum late shipments.",Base
Find the orders placed in the last 30 days and their total freight cost.,"import pandas as pd
import plotly.express as px

# Execute the SQL Query to get the orders placed in the last 30 days
df_orders = execute_sql_query(""SELECT o.OrderID, o.OrderDate, o.ShippedDate, o.Freight FROM orders o WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 30 DAY);"")

# Display the dataframe to the user
show_to_user(df_orders)

# Calculate the total freight cost
total_freight = df_orders['Freight'].sum()

# Display the total freight cost to the user
show_to_user(pd.DataFrame({'TotalFreight': [total_freight]}))","import pandas as pd
from datetime import datetime, timedelta

# Calculate the date 30 days ago from today
thirty_days_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')

# Prepare the SQL query to retrieve orders placed in the last 30 days and their total freight cost
sql_query = f""""""
SELECT OrderDate, SUM(Freight) as TotalFreight
FROM orders
WHERE OrderDate >= '{thirty_days_ago}'
GROUP BY OrderDate
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)","The input code incorrectly groups by OrderDate and sums the Freight for each date, which differs from the reference implementation that aggregates the total freight cost over all orders in the last 30 days without grouping by date.","import pandas as pd
from datetime import datetime, timedelta

# Define the query to execute
sql_query = """"""
SELECT o.OrderID, o.Freight 
FROM orders o 
WHERE o.OrderDate >= CURDATE() - INTERVAL 30 DAY;
""""""

# Execute the SQL query to retrieve the necessary data
order_data = execute_sql_query(sql_query)

# Check the data retrieved
if not order_data.empty:
    # Group by OrderID to ensure uniqueness and get the total freight cost
    result_data = order_data.groupby('OrderID')['Freight'].sum().reset_index()
    
    # Displaying the result for the user
    show_to_user(result_data)
else:
    show_to_user('No orders found in the last 30 days.')","The input code does not sum the total freight for all orders. Instead, it groups by OrderID and calculates freight for each, which deviates from the business request to find the total freight cost of all orders in the last 30 days.",None
Determine the number of discontinued products.,"import pandas as pd

# SQL query to determine the number of discontinued products
sql_query = ""SELECT COUNT(*) AS DiscontinuedProducts FROM products WHERE Discontinued = 1;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to count the number of discontinued products
sql_query = """"""
SELECT COUNT(*) AS DiscontinuedProductCount
FROM products
WHERE Discontinued = 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The evaluated code correctly counts the number of discontinued products using a SQL query. It performs the same task with equivalent logic and achieves the same outcome as the reference implementation, satisfying the business analytic request.","# Python code to determine the number of discontinued products

import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(*) AS DiscontinuedCount FROM products WHERE Discontinued = 1;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the count from the resulting dataframe
discontinued_count = result_df['DiscontinuedCount'].iloc[0]

# Optionally, convert the count to a DataFrame for consistent output format
final_df = pd.DataFrame({'DiscontinuedCount': [discontinued_count]})

# Display the result to the user
show_to_user(final_df)","The evaluated code correctly executes an SQL query to count discontinued products, extracts the result, formats it as a DataFrame, and uses the function 'show_to_user' to display the result. This matches the logic of the reference implementation, achieving the same business objective.",Base
What is the average shipping cost per order per month? Include a visualization to compare shipping costs across different months.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as a datetime type for proper plotting and sorting
orders_df['Month'] = pd.to_datetime(orders_df['Month'], format='%Y-%m')

# Sort the dataframe by 'Month' to ensure the plot is ordered chronologically
orders_df = orders_df.sort_values(by='Month')

# Create the line plot using plotly
fig = px.line(orders_df, x='Month', y='AvgShippingCost', title='Average Shipping Cost Per Order Per Month', labels={'Month': 'Month', 'AvgShippingCost': 'Average Shipping Cost'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get average shipping cost per order grouped by month
sql_query = '''
SELECT  
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(Freight) AS Avg_Shipping_Cost 
FROM 
    orders 
GROUP BY 
    Month
ORDER BY 
    Month;
''' 

# Execute the SQL query and store the result in a DataFrame
df_shipping_cost = execute_sql_query(sql_query)

# Create a line plot to visualize average shipping costs per month
fig = px.line(df_shipping_cost, x='Month', y='Avg_Shipping_Cost', 
              title='Average Shipping Cost per Order per Month', 
              labels={'Avg_Shipping_Cost': 'Average Shipping Cost', 'Month': 'Month'})

# Show the data visualization to the user
show_to_user(fig)","The input code effectively addresses the business analytic request by calculating and visualizing the average shipping cost per order per month. Despite slight differences in variable naming and code order, it achieves the same outcome as the reference implementation.","
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       AVG(Freight) AS AvgShippingCost
FROM orders
GROUP BY Month;
""""""

# Step 2: Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Step 3: Ensure 'Month' column is treated as a datetime type for accurate sorting
orders_df['Month'] = pd.to_datetime(orders_df['Month'])

# Step 4: Sort the dataframe by 'Month'
orders_df = orders_df.sort_values(by='Month')

# Step 5: Visualize the data using plotly
fig = px.line(orders_df, x='Month', y='AvgShippingCost', title='Average Shipping Cost per Order per Month', labels={'Month': 'Month', 'AvgShippingCost': 'Average Shipping Cost'})

# Step 6: Show the visualization to the user
show_to_user(fig)
",The input code correctly executes the SQL query to calculate the average shipping cost per order per month. It processes the data by converting 'Month' to datetime for proper sorting and visualizes the result using Plotly. The solution is aligned with the reference implementation in terms of function and output.,Base
Find out how many orders each employee managed in a specific date range. Provide a bar chart to visualize the distribution of orders among employees.,"import pandas as pd
import plotly.express as px

# Define the specific date range
start_date = '2023-01-01'
end_date = '2023-12-31'

# Craft the SQL query
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY e.EmployeeID;""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of orders among employees
fig = px.bar(data, x='EmployeeID', y='OrderCount', title='Number of Orders Managed by Each Employee', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})

# Show the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the start and end date for the specific date range.
date_start = '2023-01-01'
date_end = '2023-12-31'

# SQL query to find the number of orders each employee managed in the specific date range.
sql_query = f""""""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{date_start}' AND '{date_end}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

# Execute the SQL query to get the data.
order_counts_df = execute_sql_query(sql_query)

# Visualize the distribution of orders among employees with a bar chart.
fig = px.bar(order_counts_df, x='EmployeeName', y='OrderCount',
             title='Number of Orders Managed by Each Employee',
             labels={'OrderCount': 'Number of Orders', 'EmployeeName': 'Employee'},
             color='OrderCount')

# Show the figure to the user.
show_to_user(fig)","The input code correctly executes the task. It retrieves the number of orders each employee managed within the specified date range using SQL, groups by employee, and visualizes the data using a bar chart. Although it adds employee names, this does not affect the core requirement. The outcomes effectively answer the business analytic request.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Utility functions are assumed to be available based on the environment provided

# Define the date range
start_date = '2023-01-01'
end_date = '2023-12-31'

# SQL query to find the number of orders each employee managed in the specific date range
sql_query = f""""""
SELECT e.EmployeeID, COUNT(o.OrderID) AS NumberOfOrders 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '{start_date}' AND '{end_date}' 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query to retrieve the data
employee_orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of orders among employees
fig = px.bar(employee_orders_df, x='EmployeeID', y='NumberOfOrders', 
             title='Number of Orders Managed by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'NumberOfOrders': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)","The input Python code correctly fulfills the business analytic request. It defines the same date range, executes a SQL query to count the number of orders managed by each employee within that date range, and uses Plotly to create a bar chart. Even though the column name 'NumberOfOrders' differs from 'OrderCount' in the reference implementation, it effectively answers the analytic request.",Base
Which products have been discontinued?,"import pandas as pd
import plotly.express as px

# Define the SQL query to fetch discontinued products
sql_query = 'SELECT ProductName FROM products WHERE Discontinued = 1;'

# Execute the SQL query using the provided utility function
discontinued_products_df = execute_sql_query(sql_query)

# Display the result to the user using the provided utility function
show_to_user(discontinued_products_df)","query = """"""
SELECT ProductID, ProductName
FROM products
WHERE Discontinued = 1;
""""""

# Execute the SQL query to get the discontinued products
discontinued_products_df = execute_sql_query(query)

# Show the results to the user
show_to_user(discontinued_products_df)","The input code correctly retrieves the products that have been discontinued by querying the database for products where 'Discontinued = 1'. It successfully displays these discontinued products using the same utilities as the reference implementation, and although the selected columns differ slightly, the primary objective is met.","import pandas as pd

# Define the SQL query to get discontinued products
sql_query = 'SELECT ProductID, ProductName FROM products WHERE Discontinued = 1;'

# Execute the SQL query using the provided utility function
products_df = execute_sql_query(sql_query)

# Display the retrieved data to the user
show_to_user(products_df)","The input code effectively addresses the business analytic request by selecting products with a 'Discontinued' status using a SQL query. While it includes 'ProductID' in the query results, which differs from the reference implementation, it still successfully identifies discontinued products as requested.",Base
What is the monthly inventory turnover ratio? Visualize the inventory turnover ratio over time using a line chart.,"import pandas as pd
import plotly.express as px

# SQL query to get the monthly inventory turnover ratio
df = execute_sql_query(""SELECT DATEPART(month, OrderDate) AS Month, SUM(OD.Quantity * OD.UnitPrice) / AVG(P.UnitsInStock) AS InventoryTurnoverRatio FROM [Order Details] OD JOIN products P ON OD.ProductID = P.ProductID GROUP BY DATEPART(month, OrderDate);"")

# Ensure the 'Month' column is in the correct order (1 to 12)
df['Month'] = df['Month'].astype(int)
df = df.sort_values(by='Month')

# Visualize the inventory turnover ratio over time using a line chart
fig = px.line(df, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio', labels={'Month': 'Month', 'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

# Display the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate monthly inventory turnover ratio
sql_query = '''
SELECT DATE_FORMAT(order_date, '%Y-%m') AS month,
       SUM(od.Quantity * od.UnitPrice) AS COGS,
       AVG(p.UnitsInStock) AS Avg_Units_In_Stock,
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS Inventory_Turnover_Ratio
FROM `Order Details` od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY month
ORDER BY month
'''

# Execute SQL query and get the data
inventory_turnover_df = execute_sql_query(sql_query)

# Visualize the inventory turnover ratio over time
fig = px.line(inventory_turnover_df, x='month', y='Inventory_Turnover_Ratio',\n              title='Monthly Inventory Turnover Ratio',
              labels={'month': 'Month', 'Inventory_Turnover_Ratio': 'Turnover Ratio'})

# Show the result to the user
show_to_user(fig)",The input code correctly calculates and visualizes the monthly inventory turnover ratio. It uses an SQL query to aggregate data by month and computes the turnover ratio similarly to the reference implementation. The chart is also presented effectively using Plotly.,"To accomplish the given task, we'll follow a structured approach:

1. **SQL Query**: We'll use a SQL query to fetch the monthly inventory turnover ratio.
2. **Python Execution**: We'll execute the SQL query and process the result.
3. **Data Visualization**: Finally, we'll visualize the inventory turnover ratio over time using a line chart.

Here's the complete Python code to execute the above steps:

```python
import pandas as pd
import plotly.express as px

# Step 1: Identify the SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
(SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock)) AS InventoryTurnoverRatio 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY DATE_FORMAT(orders.OrderDate, '%Y-%m') 
ORDER BY Month
""""""

# Step 2: Fetch the data
data = execute_sql_query(sql_query)

# Ensure the data is sorted by month
data = data.sort_values(by='Month')

# Step 3: Data visualization
fig = px.line(data, x='Month', y='InventoryTurnoverRatio', title='Monthly Inventory Turnover Ratio for 2022')

# Show the result to the user
show_to_user(fig)
```
### Explanation of the Code:

1. **SQL Query**: The given SQL query calculates the monthly inventory turnover ratio by joining the required tables and grouping the data by month.

2. **Data Retrieval**: The `execute_sql_query` function retrieves the data from the database, which is then sorted by month to ensure proper chronological display.

3. **Visualization**: The `plotly.express` is used to create a line chart. The x-axis represents the month, and the y-axis represents the inventory turnover ratio.

4. **Display the Result**: The `show_to_user` function is used to display the plotly figure to the user, allowing them to visualize the data directly.","The input code restricts the data to the year 2022 with the WHERE clause, whereas the reference implementation does not filter by a specific year. This could lead to different results if the data set spans multiple years.",Base
Which products are associated with the highest total order quantities? Use a bar chart to illustrate products with the highest order quantities.,"import plotly.express as px

# SQL Query to retrieve the data
dataset_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrderedQuantity 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalOrderedQuantity DESC;
'''

# Execute the SQL query using the provided function
df = execute_sql_query(dataset_query)

# Create a bar chart using plotly.express
fig = px.bar(df, x='ProductName', y='TotalOrderedQuantity', title='Products with the Highest Total Order Quantities', labels={'ProductName': 'Product Name', 'TotalOrderedQuantity': 'Total Ordered Quantity'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query to fetch product ID and total order quantities
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrderQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrderQuantity DESC
LIMIT 10
'''  # Adjust limit as necessary

# Step 2: Execute the SQL query using the provided utility function
product_data = execute_sql_query(sql_query)

# Step 3: Create a bar chart to visualize the products with the highest order quantities
fig = px.bar(product_data, x='ProductName', y='TotalOrderQuantity',
             title='Top Products by Total Order Quantities',
             labels={'TotalOrderQuantity': 'Total Order Quantity', 'ProductName': 'Product Name'},
             text='TotalOrderQuantity')

# Step 4: Show the visualization to the user
show_to_user(fig)","The evaluated code correctly retrieves products with their total order quantities, sorts them in descending order, and visualizes the result with a bar chart. The LIMIT clause in the evaluated code is an acceptable addition for focusing on top products.","import plotly.express as px
import pandas as pd

# Step 1: Execute the SQL query to get product order quantities
sql_query = 'SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID ORDER BY TotalQuantity DESC;'
df = execute_sql_query(sql_query)

# Step 2: Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Products with Highest Total Order Quantities', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Order Quantity'})

# Step 3: Show the chart to the user
show_to_user(fig)","The input code only retrieves ProductID and not ProductName, missing the join with the 'products' table which is needed to associate products with their names for a more informative bar chart.",Base
What are the names of products that are currently discontinued?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT ProductName FROM products WHERE Discontinued = 1;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to get the names of discontinued products
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE Discontinued = 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code fulfills the business analytic request by querying and displaying the names of discontinued products, matching the functionality of the reference implementation.","import pandas as pd

# Define the SQL query to find discontinued products

sql_query = ""SELECT ProductName FROM products WHERE Discontinued = 1;""

# Execute the SQL query to retrieve the data
product_df = execute_sql_query(sql_query)

# Display the names of the products that are currently discontinued
show_to_user(product_df)","The input code executes a SQL query that selects product names from the 'products' table where the 'Discontinued' column is set to 1, just like the reference implementation. It then displays the result. Both the input and reference code achieve the same outcome.",Base
What is the total freight cost for all orders made in the year 2022?,"import pandas as pd
import plotly.express as px

def get_total_freight_cost_for_2022():
    sql_query = """"""
    SELECT SUM(Freight) AS TotalFreightCost 
    FROM orders 
    WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31';
    """"""
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Display the result to the user as a table
    show_to_user(df)
    
    # Additional: Display the result as a simple print statement
    total_cost = df['TotalFreightCost'][0] if not df.empty else 0
    print(f'Total Freight Cost for 2022: {total_cost}')

# Call the function to execute the process
get_total_freight_cost_for_2022()","import pandas as pd

# SQL query to calculate the total freight cost for all orders made in the year 2022
sql_query = """"""
SELECT SUM(Freight) AS TotalFreight
FROM orders
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'""""""

# Executing the SQL query and fetching the result
result_df = execute_sql_query(sql_query)

# Displaying the result to the user
show_to_user(result_df)","The input code correctly executes an SQL query to calculate the total freight cost for orders made in 2022 and displays the result using the `show_to_user` function. Although it doesn't print the total cost explicitly as the reference, it meets the primary requirement of the task.","import pandas as pd

# SQL query to get the total freight cost for all orders made in the year 2022
sql_query = '''
SELECT SUM(Freight) AS total_freight_cost 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total freight cost value from the dataframe
if not result_df.empty:
    total_freight_cost = result_df.iloc[0]['total_freight_cost']
else:
    total_freight_cost = 0

# Create a dataframe to display the result clearly
result_to_display = pd.DataFrame({'total_freight_cost': [total_freight_cost]})

# Display the result to the user
show_to_user(result_to_display)","The evaluated code correctly formulates the SQL query to calculate the total freight cost for orders in the year 2022. It executes the query, checks if the result is empty, and extracts the total freight cost. Finally, it uses the `show_to_user` function to display the result, meeting the requirements of the business analytic request.",Base
What is the total sales revenue generated in each month? Present the results with a bar chart to show monthly revenue.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query string
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY month;
'''

# Execute the SQL query to get the result in a pandas dataframe
sales_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(sales_data, x='month', y='TotalSales', title='Monthly Sales Revenue')

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue for each month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query and retrieve data
monthly_sales = execute_sql_query(sql_query)

# Create a bar chart to visualize monthly sales revenue
fig = px.bar(monthly_sales, x='Month', y='TotalSales', title='Total Sales Revenue by Month',
             labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})

# Show the results to the user
show_to_user(fig)","The input Python code correctly executes the SQL query to calculate total sales revenue for each month. It retrieves the data, then uses Plotly to create a bar chart showing monthly sales revenue, which is displayed to the user. The implementation effectively fulfills the business analytic request, matching the outcome of the reference code.","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales revenue generated in each month.
sql_query = 'SELECT DATE_FORMAT(Orders.OrderDate, ""%Y-%m"") AS Month, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales FROM Orders JOIN [Order Details] ON Orders.OrderID = [Order Details].OrderID GROUP BY Month;'

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Check the first few rows of the dataframe to ensure it's loaded correctly
print(sales_data.head())

# Create a bar chart to visualize monthly sales revenue
fig = px.bar(sales_data, x='Month', y='TotalSales', title='Monthly Sales Revenue', labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})

# Show the bar chart to the user
show_to_user(fig)","The input Python code correctly fulfills the business analytic request by executing a SQL query to calculate monthly sales revenue. It matches the reference implementation in logic and uses Plotly to create a bar chart of the results. Column name differences do not impact correctness, and the visual output effectively answers the request.",Base
Find the CustomerID and the total number of orders for each customer who has ordered more than 10 times.,"
import pandas as pd
import plotly.express as px

# Define the SQL query to get CustomerID and order count for customers with more than 10 orders
sql_query = '''
SELECT customers.CustomerID, COUNT(orders.OrderID) AS order_count 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
GROUP BY customers.CustomerID 
HAVING COUNT(orders.OrderID) > 10
'''

# Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the resulting dataframe has the required columns
if 'CustomerID' in df.columns and 'order_count' in df.columns:
    # Display the resulting dataframe to the user
    show_to_user(df)

    # Optionally, create a visualization using plotly (e.g., a bar chart)
    fig = px.bar(df, x='CustomerID', y='order_count', title='Customers with More Than 10 Orders',
                 labels={'CustomerID': 'Customer ID', 'order_count': 'Total Number of Orders'})

    # Display the visualization to the user
    show_to_user(fig)
else:
    show_to_user('The SQL query did not return the expected columns.')
","sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10
'''

data = execute_sql_query(sql_query)

show_to_user(data)","The input code correctly queries the database to find CustomerID and total number of orders for customers with more than 10 orders, which matches the business analytic request. It may not include visualization, but the primary data retrieval goal is achieved as in the reference code.","import pandas as pd
import plotly.express as px

# Execute the SQL query to get the data
sql_query = '''SELECT CustomerID, COUNT(*) as OrderCount FROM orders GROUP BY CustomerID HAVING COUNT(*) > 10;'''
df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(df)

# Optionally, if you want to visualize the data in a bar chart
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Total Number of Orders per Customer Who Ordered More Than 10 Times')
show_to_user(fig)","The input code meets the business analytic request by selecting CustomerID and counting the number of orders, filtering customers with more than 10 orders. It differs from the reference code slightly but achieves the same result.",Base
How many orders were shipped over a week late in August 2023?,"import pandas as pd

# Construct the SQL query
sql_query = '''
SELECT COUNT(OrderID) AS LateOrders 
FROM orders 
WHERE DATEDIFF(ShippedDate, RequiredDate) > 7 
AND OrderDate BETWEEN '2023-08-01' AND '2023-08-31';
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to count orders shipped over a week late in August 2023
sql_query = '''
SELECT COUNT(*) AS LateOrdersCount
FROM orders
WHERE ShippedDate > RequiredDate + INTERVAL '7 days'
AND ShippedDate >= '2023-08-01'
AND ShippedDate < '2023-09-01'
''' 

# Execute the SQL query using provided utility function
result = execute_sql_query(sql_query)  

# Show the result to the user
show_to_user(result)",The input code correctly counts orders shipped over a week late in August 2023. It uses a slightly different SQL syntax than the reference code but achieves the same result by specifying the correct date range and condition for delay.,"import pandas as pd

# Define the SQL query
date_condition = ""datepart(DAY, OrderDate) BETWEEN 1 AND 31 AND datepart(MONTH, OrderDate) = 8 AND datepart(YEAR, OrderDate) = 2023""
over_week_late_condition = ""DATEDIFF(DAY, OrderDate, ShippedDate) > 7""

sql_query = f""""""
SELECT COUNT(OrderID) AS LateOrders 
FROM orders
WHERE {date_condition} 
AND {over_week_late_condition}
""""""

# Execute the SQL query and get the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code incorrectly uses OrderDate instead of RequiredDate for calculating the lateness with DATEDIFF. It checks if orders were shipped more than 7 days after the OrderDate, while the reference checks for 7 days after the RequiredDate. Additionally, the date condition in the input code is unnecessarily complex compared to the reference implementation.",Base
Which employee achieved the highest sales in 2022? Use a bar chart to display employees and their respective sales figures.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT o.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY o.EmployeeID 
ORDER BY TotalSales DESC
""""""

# Execute SQL Query
sales_df = execute_sql_query(sql_query)

# Generate Bar Chart
fig = px.bar(sales_df, x='EmployeeID', y='TotalSales', title='Employee Sales in 2022', 
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales'}, 
             text='TotalSales')

# Show bar chart to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch total sales by employee for 2022
sql_query = '''
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN employees e ON o.EmployeeID = e.EmployeeID
WHERE YEAR(o.OrderDate) = 2022
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Identify the employee with the highest sales
highest_sales_employee = sales_data.iloc[0]

# Create a bar chart for sales figures
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Employee Sales in 2022', labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales'})

# Show the results to the user
show_to_user(fig)

# Display the employee with the highest sales
highest_sales_employee","The input code correctly identifies the employee with the highest sales in 2022 using a similar SQL query and displays a bar chart of employees' sales figures. The minor differences in the SQL query, such as an additional JOIN with the employees table, do not affect the overall result. The output matches the business request and aligns with the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to retrieve sales data for 2022
sql_query_2022 = '''
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY employees.EmployeeID
'''

# Execute the SQL query
sales_data_2022 = execute_sql_query(sql_query_2022)

# Create a bar chart using Plotly
fig = px.bar(sales_data_2022, x='EmployeeID', y='employee_sales', title='Employee Sales in 2022',
             labels={'EmployeeID': 'Employee ID', 'employee_sales': 'Total Sales'},
             text='employee_sales')

# Display the bar chart using the provided function
show_to_user(fig)

# Find the employee with the highest sales
highest_sales_employee = sales_data_2022.loc[sales_data_2022['employee_sales'].idxmax()]
show_to_user(highest_sales_employee)
","The input code correctly queries the database for employee sales in 2022, generates a bar chart for visualization using Plotly, and identifies the employee with the highest sales. It achieves the same outcome as the reference implementation, satisfying the business analytic request.",Base
What are the top 5 best-selling products? Present the data using a bar chart.,"import plotly.express as px

# Define the SQL query
df = execute_sql_query('SELECT p.ProductName, SUM(od.Quantity) AS TotalSales FROM products p JOIN [Order Details] od ON p.ProductID = od.ProductID GROUP BY p.ProductName ORDER BY TotalSales DESC LIMIT 5;')

# Create bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalSales', title='Top 5 Best-Selling Products', labels={'ProductName':'Product Name', 'TotalSales':'Total Sales'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get sales data for products
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 5;
'''

# Execute the SQL query to get the top 5 best-selling products
best_selling_products = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(best_selling_products, x='ProductName', y='TotalSales',
             title='Top 5 Best-Selling Products',
             labels={'TotalSales': 'Total Units Sold', 'ProductName': 'Product Name'})

# Show the result to the user
show_to_user(fig)","The input code correctly executes an SQL query to retrieve the top 5 best-selling products by total units sold. It uses the data to create a bar chart with Plotly, displaying 'ProductName' on the x-axis and 'TotalSales' on the y-axis, satisfying the business request similarly to the reference code.","import plotly.express as px

# Step 1: Execute the query to retrieve top 5 best-selling products
sql_query = '''
SELECT P.ProductID, P.ProductName, SUM(OD.Quantity) AS TotalQuantity 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY P.ProductID, P.ProductName 
ORDER BY TotalQuantity DESC 
LIMIT 5;
'''

# Execute the query
df = execute_sql_query(sql_query)

# Step 2: Present the data using a bar chart
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Top 5 Best-Selling Products', labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity Sold'})

# Step 3: Show the visualization to the user
show_to_user(fig)",The input code correctly executes a SQL query to retrieve the top 5 best-selling products and uses Plotly to present this data as a bar chart. The SQL logic and visualization approach align with the business request and the reference code.,Base
Which products have a discount applied in more than 10 orders? Include a visualization to highlight these products.,"import pandas as pd
import plotly.express as px

# Define the SQL query to fetch data
sql_query = """"""
SELECT p.ProductName, COUNT(*) AS OrderCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0.0 
GROUP BY p.ProductName 
HAVING COUNT(*) > 10;  # Correct the HAVING clause
""""""

# Execute the query and retrieve the data
data = execute_sql_query(sql_query)

# Generate a bar chart visualization by using Plotly
fig = px.bar(data, x='ProductName', y='OrderCount', title='Products with Discount Applied in More Than 10 Orders', labels={'ProductName': 'Product Name', 'OrderCount': 'Order Count'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to find products with discounts applied in more than 10 orders
sql_query = '''
SELECT p.ProductID, p.ProductName, COUNT(od.OrderID) AS OrderCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
GROUP BY p.ProductID, p.ProductName
HAVING COUNT(od.OrderID) > 10
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualization of the products
fig = px.bar(result_df, x='ProductName', y='OrderCount', title='Products with Discounts Applied in More than 10 Orders')
show_to_user(fig)","The input code performs the same business logic as the reference code. Both SQL queries aggregate orders with a discount higher than 0, group by product, and filter for those with more than 10 such orders. The visualization part also aligns with the reference, using Plotly to create a bar chart. The minor difference in SQL syntax (product IDs included) does not affect the outcome.","import pandas as pd
import plotly.express as px

def get_discounted_products():
    # SQL query to fetch products with discounts in more than 10 orders
    sql_query = """"""
    SELECT products.ProductID, COUNT(*) AS DiscountedOrders 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    WHERE Discount > 0 
    GROUP BY products.ProductID 
    HAVING COUNT(*) > 10;
    """"""
    
    # Execute the SQL query and get the result as a pandas dataframe
    df = execute_sql_query(sql_query)
    
    # Check if the dataframe is empty
    if df.empty:
        show_to_user(""No products have a discount applied in more than 10 orders."")
        return

    # Create a bar chart to visualize the products with discount applied in more than 10 orders
    fig = px.bar(df, x='ProductID', y='DiscountedOrders', 
                 title='Products with Discount Applied in More Than 10 Orders', 
                 labels={'ProductID': 'Product ID', 'DiscountedOrders': 'Number of Discounted Orders'})
    
    # Show the result to the user
    show_to_user(fig)

# Execute the function to perform the task
get_discounted_products()","The input code correctly addresses the business analytic request. Both implementations execute a similar SQL query filtering out products with discounts applied in more than 10 orders. Although the input code uses ProductID instead of ProductName for the visualization, the essential business requirement is met. Visualization is achieved using Plotly, and the result is shown using the 'show_to_user' function as specified.",Base
What is the average order value for June 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query to get the average order value for June 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to calculate the Average Order Value for June 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
""""""

# Execute the SQL query
average_order_value_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_order_value_df)",The input code effectively replicates the functionality of the reference implementation. Both codes execute the same SQL query to calculate the average order value for June 2023 and display the result using the same utility functions. The logic and outcome are identical.,"import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30';
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average order value
avg_order_value = result_df.loc[0, 'avg_order_value']

# Prepare the data to show
display_df = pd.DataFrame({'Avg Order Value for June 2023': [avg_order_value]})

# Display the result
show_to_user(display_df)","The input code correctly calculates the average order value for June 2023 by executing a SQL query similar to the reference implementation. It then extracts the average order value from the result and prepares it for display in a DataFrame, which only changes the format of presentation, not the calculation itself.",Base
What is the average value of orders placed in January 2023?,"
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31' 
'''

# Execute the query and get the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)
","import pandas as pd

# SQL query to calculate the average value of orders placed in January 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly computes the average order value for January 2023. It executes a SQL query to sum the total sales from order details, adjusted for discounts, and divides by the count of unique orders within the specified date range. The results are retrieved and displayed using the given utility functions, matching the logic of the reference implementation.","import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity) AS OrderValue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY orders.OrderID
'''

# Step 2: Execute the SQL query to get the data
orders_data = execute_sql_query(sql_query)

# Step 3: Calculate the average order value
average_order_value = orders_data['OrderValue'].mean()

# Step 4: Display the result to the user
result_df = pd.DataFrame({'AverageOrderValue': [average_order_value]})
show_to_user(result_df)","The input code does not account for discounts, unlike the reference. This causes the average order value to be potentially higher than it should be when discounts are applied.",Base
"List the customers along with their total spent amounts, ordered by highest to lowest total spent. Provide a sorted bar chart for better illustration.","import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent 
             FROM customers c 
             JOIN orders o ON c.CustomerID = o.CustomerID 
             JOIN [Order Details] od ON o.OrderID = od.OrderID 
             GROUP BY c.CustomerID 
             ORDER BY TotalSpent DESC;'''

# Execute the SQL query and get the dataframe
customer_spending_df = execute_sql_query(sql_query)

# Create and show the bar chart
fig = px.bar(customer_spending_df, x='CustomerID', y='TotalSpent', title='Total Spent by Customers',
             labels={'CustomerID':'Customer ID', 'TotalSpent':'Total Spent'},
             text='TotalSpent')
fig.update_layout(xaxis={'categoryorder':'total descending'}, yaxis_title='Total Spent', xaxis_title='Customer ID')

# Display the total spent values within the bars
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total spent by each customer
sql_query = '''
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalSpent DESC
'''  

# Execute the SQL query and get the data
customer_spending_df = execute_sql_query(sql_query)

# Plotting the total spent using a bar chart
fig = px.bar(customer_spending_df, x='CompanyName', y='TotalSpent', title='Customer Total Spent Amounts',
             labels={'TotalSpent': 'Total Spent', 'CompanyName': 'Customer'},
             color='TotalSpent', color_continuous_scale=px.colors.sequential.Viridis)

# Show the results to the user
show_to_user(fig)","The input code correctly calculates the total spent per customer using SQL, similar to the reference. It includes 'CompanyName' in the grouping and labeling for clarity. The code generates a bar chart ordered by 'TotalSpent' and utilizes color to enhance the visualization, fulfilling the business request.","import pandas as pd
import plotly.express as px

# SQL query to fetch the data
df = execute_sql_query(""""""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpending
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID;
"""""")

# Sort the dataframe by TotalSpending in descending order
df_sorted = df.sort_values(by='TotalSpending', ascending=False)

# Create a bar chart using plotly
fig = px.bar(df_sorted, x='CustomerID', y='TotalSpending',
             title='Customers and Their Total Spent Amounts',
             labels={'CustomerID': 'Customer ID', 'TotalSpending': 'Total Spent Amount'},
             template='plotly_dark')

# Display the sorted bar chart to the user
show_to_user(fig)","The provided code correctly calculates the total spent by each customer, sorts them in descending order, and creates a bar chart using Plotly. Although the output column name 'TotalSpending' differs from 'TotalSpent' in the reference, the functionality and outcome are equivalent.",Base
What is the average order value for Q1 2023?,"import pandas as pd
import plotly.express as px

# SQL query to calculate the average order value for Q1 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Extracting avg_order_value from the dataframe
avg_order_value = result_df['avg_order_value'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'avg_order_value': [avg_order_value]}))
","import pandas as pd

# SQL query to calculate the average order value for Q1 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the average order value to the user
show_to_user(result_df)","The input code does not extract 'avg_order_value' from 'result_df' before displaying to the user, unlike the reference code which does so.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the average order value for Q1 2023
sql_query = '''
SELECT SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) / COUNT(DISTINCT O.OrderID) AS avg_order_value 
FROM orders O 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
WHERE O.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
''' 

# Execute the SQL query
df = execute_sql_query(sql_query)

# Extract the average order value from the dataframe
avg_order_value = df.at[0, 'avg_order_value']

# Display the result using show_to_user function
show_to_user(pd.DataFrame({'Average Order Value for Q1 2023': [avg_order_value]}))
","The input code correctly calculates the average order value for Q1 2023. It uses a SQL query to compute the average and retrieves data using 'execute_sql_query'. The 'show_to_user' function is then used to display the result. The logic and operations in the input code align with the reference implementation, achieving the same outcome.",Finetuned
List orders where the shipping cost was above average.,"import pandas as pd
import plotly.express as px

# Execute the SQL query to get the orders where the shipping cost is above average
sql_query = '''
SELECT * FROM orders WHERE Freight > (SELECT AVG(Freight) FROM orders);
'''

# Fetch the data using the execute_sql_query function
orders_above_average_freight = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_above_average_freight)","import pandas as pd

# Step 1: Retrieve the average shipping cost
average_shipping_cost_query = ""SELECT AVG(Freight) as AvgFreight FROM orders""
average_shipping_cost_df = execute_sql_query(average_shipping_cost_query)
average_shipping_cost = average_shipping_cost_df['AvgFreight'][0]

# Step 2: Retrieve orders where the shipping cost is above the average
above_average_shipping_cost_query = f""SELECT * FROM orders WHERE Freight > {average_shipping_cost}""
above_average_orders_df = execute_sql_query(above_average_shipping_cost_query)

# Step 3: Show the results to the user
show_to_user(above_average_orders_df)","The input code correctly retrieves the average shipping cost and uses it to filter orders where the shipping cost is above average, just like the reference code.","
import pandas as pd
import plotly.express as px

def list_orders_shipping_above_average():
    # SQL query to get orders where shipping cost is above average
    sql_query = ""SELECT * FROM orders WHERE Freight > (SELECT AVG(Freight) FROM orders)""
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(df)
    
    return df

# Call the function
list_orders_shipping_above_average()
",The input code correctly executes the SQL query to list orders where the shipping cost is above average. It effectively matches the business analytic request and achieves the same outcome as the reference implementation by using a similar SQL query and functions to fetch and display data.,Base
What is the average freight cost for orders shipped to Europe?,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve data
sql_query = """"""
SELECT AVG(Freight) AS AverageFreightCost FROM orders WHERE ShipCountry IN ('Austria', 'Belgium', 'Denmark', 'Finland', 'France', 'Germany', 'Greece', 'Ireland', 'Italy', 'Netherlands', 'Norway', 'Poland', 'Portugal', 'Spain', 'Sweden', 'Switzerland', 'United Kingdom');
""""""

# Execute the SQL query and retrieve data
average_freight_df = execute_sql_query(sql_query)

# Since the result is a single value, we can print it or show it as dataframe
show_to_user(average_freight_df)","import pandas as pd

# SQL query to get the average freight cost for orders shipped to Europe
sql_query = """"""
SELECT AVG(Freight) AS AverageFreight
FROM orders
WHERE ShipCountry IN ('France', 'Germany', 'Spain', 'Italy', 'United Kingdom', 'Netherlands', 'Sweden', 'Belgium', 'Austria', 'Denmark', 'Finland', 'Norway', 'Switzerland', 'Ireland', 'Poland')
""""""

# Execute the query
average_freight_df = execute_sql_query(sql_query)

# Show the result to user
show_to_user(average_freight_df)","The input code is missing several European countries compared to the reference implementation, including Greece and Portugal.","import pandas as pd

# Step 1: Write the SQL query to get average freight cost for orders shipped to Europe
sql_query = """"""
SELECT AVG(Freight) AS AverageFreight 
FROM orders o
WHERE o.ShipCountry IN (
    SELECT Country 
    FROM countries 
    WHERE Continent = 'Europe'
);
""""""

# Step 2: Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Step 3: Display the result to the user
show_to_user(result_df)","The input code successfully calculates the average freight cost for orders shipped to European countries by dynamically determining the list of countries in Europe from a 'countries' table. This approach ensures scalability for any changes in European countries, compared to the reference implementation that uses a hardcoded list. Assuming the 'countries' table accurately reflects European countries, both implementations achieve the same result.",Finetuned
"What is the average salary of employees by title, and can you visualize the distribution of salaries across different titles?","import plotly.express as px
import pandas as pd

# Execute the SQL query to get average salary by title
sql_query = 'SELECT Title, AVG(Salary) AS AvgSalary FROM employees GROUP BY Title;'
df_avg_salary = execute_sql_query(sql_query)

# Visualize the distribution of salaries across different titles
fig = px.bar(df_avg_salary, x='Title', y='AvgSalary', title='Average Salary by Title')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Write SQL query to get average salary by title
sql_query = '''
SELECT Title, AVG(Salary) AS AverageSalary
FROM employees
GROUP BY Title
'''

# Step 2: Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Step 3: Visualize the distribution of salaries across different titles
fig = px.box(df, x='Title', y='AverageSalary', title='Distribution of Average Salaries by Title')

# Show average salary data to user
show_to_user(df)

# Show the box plot to user
show_to_user(fig)","The input code creates a box plot using 'AverageSalary' which represents averaged values, not the raw salary data needed to show distributions. Additionally, it shows both the raw data and the plot separately, which deviates from just visualizing the averages as a bar chart like the reference code.","import pandas as pd
import plotly.express as px

# SQL query to get the average salary of employees by title
sql_query = 'SELECT Title, AVG(Salary) AS AverageSalary FROM employees GROUP BY Title;'

# Execute the SQL query
avg_salary_df = execute_sql_query(sql_query)

# Display the average salary data to the user
show_to_user(avg_salary_df)

# Visualize the distribution of salaries across different titles
fig = px.box(avg_salary_df, x='Title', y='AverageSalary', points='all', title='Salary Distribution by Title', labels={'AverageSalary': 'Average Salary', 'Title': 'Job Title'})

# Show the plot to the user
show_to_user(fig)","The input code calculates and visualizes the average salary correctly. However, it uses a box plot instead of a bar plot, which doesn't align with the reference implementation of a bar chart to visualize the average salary distribution.",None
What is the total number of orders for each product and can this be visualized to highlight the most and least ordered products?,"import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, COUNT(od.OrderID) AS OrderCount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query and retrieve data
products_order_count_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total number of orders for each product
fig = px.bar(
    products_order_count_df,
    x='ProductName',
    y='OrderCount',
    title='Total Number of Orders for Each Product',
    labels={'ProductName': 'Product Name', 'OrderCount': 'Order Count'},
    template='plotly_dark'
)

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total number of orders for each product
sql_query = '''
SELECT pd.ProductID, pr.ProductName, SUM(od.Quantity) AS TotalOrders
FROM [Order Details] od
JOIN products pr ON od.ProductID = pr.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY pr.ProductID, pr.ProductName
ORDER BY TotalOrders DESC
'''

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total number of orders for each product
fig = px.bar(order_data, x='ProductName', y='TotalOrders',
             title='Total Number of Orders for Each Product',
             labels={'TotalOrders': 'Number of Orders', 'ProductName': 'Product Name'},
             color='TotalOrders',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the result to the user
show_to_user(fig)","The input code retrieves the total number of orders for each product, visualizes the data using a bar chart, and meets the business analytic request. Although it uses 'SUM(od.Quantity)' instead of 'COUNT(od.OrderID)', it's reasonable if each order line contributes to the order count. The process correctly highlights the most and least ordered products.","import plotly.express as px

# Query to get the total number of orders for each product
query = '''
SELECT p.ProductName, COUNT(od.OrderID) AS TotalOrders 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName;
'''

# Execute the SQL query
orders_df = execute_sql_query(query)

# Sort the dataframe for better visualization
orders_df = orders_df.sort_values(by='TotalOrders', ascending=False)

# Visualize the total number of orders for each product
fig = px.bar(orders_df, x='ProductName', y='TotalOrders',
             title='Total Orders for Each Product', 
             labels={'ProductName': 'Product Name', 'TotalOrders': 'Total Orders'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly executes the SQL query to count orders by product. It matches the logic of the reference implementation by joining the 'Order Details' and 'products' tables, grouping by 'ProductName', and counting 'OrderID'. Although it sorts the dataframe for visualization, this does not affect correctness. The visualization effectively highlights order counts, meeting the business analytic request.",Base
List the top 5 products with the highest unit price.,"
import plotly.express as px

# Define the SQL query
top_products_query = """"""
SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;
""""""

# Execute the SQL query to retrieve data
top_products_df = execute_sql_query(top_products_query)

# Display the data to the user
show_to_user(top_products_df)

# Optionally, visualize the data using a plotly bar chart
fig = px.bar(top_products_df, x='ProductName', y='UnitPrice', title='Top 5 Products by Unit Price', labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price'})
show_to_user(fig)
","import pandas as pd

# SQL query to get the top 5 products with the highest unit price
sql_query = '''
SELECT ProductName, UnitPrice 
FROM products 
ORDER BY UnitPrice DESC 
LIMIT 5;
'''

# Execute the SQL query and retrieve the data as a DataFrame
top_products = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(top_products)","The evaluated code correctly executes a SQL query to list the top 5 products with the highest unit price and shows the results, which meets the business analytic request.","import pandas as pd
import plotly.express as px

def get_top_products():
    # SQL query to get the top 5 products with the highest unit price
    sql_query = 'SELECT ProductID, ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;'
    
    # Execute the SQL query to retrieve the data
    data = execute_sql_query(sql_query)
    
    # Display the data to the user
    show_to_user(data)
    
    # Optionally, you can also visualize the data using Plotly
    fig = px.bar(data, x='ProductName', y='UnitPrice', title='Top 5 Products with the Highest Unit Price')
    show_to_user(fig)

# Call the function to run the complete process
get_top_products()","The input code correctly queries for the top 5 products with the highest unit price using SQL. It retrieves the data, displays it using 'show_to_user', and visualizes it with a Plotly bar chart, similar to the reference implementation. The addition of 'ProductID' in the query does not affect the primary task.",Base
Calculate the total freight cost for each shipping company in 2023 and visualize the costs to compare between companies.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight_cost 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY shippers.CompanyName
'''

# Execute the SQL query
freight_data_df = execute_sql_query(sql_query)

# Generate the bar plot using plotly
fig = px.bar(freight_data_df, x='CompanyName', y='total_freight_cost', 
             title='Total Freight Cost by Shipping Company in 2023', 
             labels={'CompanyName': 'Shipping Company', 'total_freight_cost': 'Total Freight Cost'}, 
             text='total_freight_cost')

# Update layout to improve visualization
fig.update_layout(xaxis_title='Shipping Company', yaxis_title='Total Freight Cost')
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total freight cost for each shipping company in 2023
sql_query = """"""
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY shippers.CompanyName
""""""

# Execute the SQL query to retrieve the data
freight_data = execute_sql_query(sql_query)

# Create a bar chart to visualize total freight costs per shipping company
fig = px.bar(freight_data, x='CompanyName', y='total_freight',
             title='Total Freight Cost by Shipping Company in 2023',
             labels={'total_freight': 'Total Freight Cost', 'CompanyName': 'Shipping Company'},
             color='total_freight',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the visualization to the user
show_to_user(fig)","The input Python code effectively achieves the requested business analytic task by calculating the total freight cost for each shipping company in 2023. It successfully uses an SQL query to aggregate the costs and generates a visualization using plotly. Although there are some differences, such as the color gradient applied to the bars in the visualization, the input still visualizes the cost comparison effectively, meeting the requirements of the business analytic request.","import plotly.express as px

# SQL query to fetch the total freight cost for each shipping company in 2023
sql_query = '''
SELECT shippers.CompanyName, SUM(orders.Freight) AS total_freight 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY shippers.CompanyName;
'''

# Execute the SQL query
data = execute_sql_query(sql_query)

# Visualize the costs to compare between companies
fig = px.bar(data, x='CompanyName', y='total_freight', title='Total Freight Cost for Each Shipping Company in 2023', labels={'CompanyName': 'Shipping Company', 'total_freight': 'Total Freight Cost'})

# Display the plot
show_to_user(fig)","The given code correctly executes the SQL query to calculate the total freight cost for each shipping company in 2023 and visualizes it using Plotly. It achieves the same outcome as the reference implementation, despite minor differences such as column name ('total_freight' vs. 'total_freight_cost').",Base
What is the percentage of orders that were shipped within 3 days of being placed?,"import pandas as pd
import plotly.express as px

# Define the SQL query to get the count of orders shipped within 3 days and the total count of orders
datediff_query = '''
SELECT 
    COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 3 THEN 1 END) AS ShippedWithinThreeDays,
    COUNT(*) AS TotalOrders
FROM orders;
'''

# Execute the SQL query and retrieve the results into a dataframe
df = execute_sql_query(datediff_query)

# Calculate the percentage of orders shipped within 3 days
percentage_within_three_days = (df['ShippedWithinThreeDays'][0] / df['TotalOrders'][0]) * 100

# Create a dataframe to hold the result
result_df = pd.DataFrame({'Metric': ['Orders Shipped Within 3 Days'], 'Percentage': [percentage_within_three_days]})

# Create a bar plot to visualize the percentage
fig = px.bar(result_df, x='Metric', y='Percentage', title='Percentage of Orders Shipped Within 3 Days')

# Display the result to the user
show_to_user(fig)
","import pandas as pd

# SQL query to get the count of orders and the count of orders shipped within 3 days
sql_query = """"""
SELECT COUNT(OrderID) AS total_orders,
       COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 3 THEN OrderID END) AS shipped_within_3_days
FROM orders;
""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Calculate the percentage of orders shipped within 3 days
total_orders = result_df['total_orders'][0]
shipped_within_3_days = result_df['shipped_within_3_days'][0]

# Adding a condition to avoid division by zero
percentage_shipped_within_3_days = (shipped_within_3_days / total_orders * 100) if total_orders > 0 else 0

# Create a DataFrame to show the result
percentage_df = pd.DataFrame({
    'Percentage of Orders Shipped Within 3 Days': [percentage_shipped_within_3_days]
})

# Show result to user
show_to_user(percentage_df)","The input code correctly calculates the percentage of orders shipped within 3 days by counting the orders with a shipped date within three days of the order date and dividing by the total order count. There is an added condition to avoid division by zero, which is a good practice, even though it's not covered in the reference. The use of different column names in the output ('Percentage of Orders Shipped Within 3 Days') is acceptable as it effectively answers the business analytic request.","# Define the SQL Query
sql_query = '''
SELECT 
    (COUNT(CASE WHEN DATEDIFF(OrderDate, ShippedDate) <= 3 THEN 1 END) * 100.0 / COUNT(*)) AS PercentShippedWithin3Days 
FROM 
    orders;'''


# Execute the SQL query to get the result
result_df = execute_sql_query(sql_query)


# Extracting the percentage from the result dataframe
percent_shipped_within_3_days = result_df['PercentShippedWithin3Days'][0]


# Display the percentage to the user
show_to_user(percent_shipped_within_3_days)",The input code correctly calculates the percentage of orders shipped within 3 days by directly computing it in the SQL query. The approach is slightly different but achieves the same result as the reference implementation.,Base
Which products have been ordered with a discount?,"import pandas as pd
import plotly.express as px

# SQL query to find products that have been ordered with a discount
sql_query = '''
SELECT DISTINCT p.ProductName 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0;
'''

# Execute the SQL query to get the data
product_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(product_df)
","import pandas as pd

# SQL query to fetch products that have been ordered with a discount
sql_query = '''
SELECT DISTINCT p.ProductID, p.ProductName
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0;
'''

# Execute the SQL query and fetch the results
products_with_discount = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(products_with_discount)","The input code correctly implements the business analytic request. It determines which products have been ordered with a discount by executing an SQL query similar to the reference code. Both codes achieve the same outcome by selecting distinct products from orders with a discount, even though the input code selects ProductID as well. Since this additional column does not affect the correctness regarding the request, the input code meets the requirements.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT ProductName, Units * UnitPrice * (1 - Discount) AS DiscountedPrice FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID WHERE Discount > 0;'

# Execute the SQL SQL query
discounted_products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(discounted_products_df)",The input code does not align with the reference implementation's goal. It calculates a 'DiscountedPrice' but does not ensure the ProductName list is distinct as required by the business request.,Base
"What is the total number of orders shipped via each shipping method per month, and can you illustrate the monthly trends with a visualization?","
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, ShipVia, COUNT(OrderID) AS OrdersShipped
FROM orders
GROUP BY Month, ShipVia;
""""""

# Execute the SQL query and get the data in a pandas dataframe
data = execute_sql_query(sql_query)

# Create a line plot to illustrate monthly trends of orders shipped via each shipping method
fig = px.line(data, x='Month', y='OrdersShipped', color='ShipVia', title='Monthly Trends of Orders Shipped via Each Shipping Method')

# Show the visualization to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to get total number of orders shipped via each shipping method per month
sql_query = '''
SELECT
    DATE_TRUNC('month', ShippedDate) AS Month,
    ShipVia,
    COUNT(OrderID) as TotalOrders
FROM
    orders
WHERE
    ShippedDate IS NOT NULL
GROUP BY
    Month, ShipVia
ORDER BY
    Month, ShipVia;
'''  

# Execute the SQL query
orders_by_shipping_method = execute_sql_query(sql_query)

# Visualize the data
fig = px.line(
    orders_by_shipping_method,
    x='Month',
    y='TotalOrders',
    color='ShipVia',
    title='Total Orders Shipped via Each Shipping Method per Month',
    labels={'TotalOrders': 'Total Orders', 'Month': 'Month', 'ShipVia': 'Shipping Method'}
)

# Show the visualization
show_to_user(fig)
","The input code correctly addresses the business analytic request by executing an SQL query to count orders shipped via each shipping method per month and visualizing the results. Both the input and reference implementations perform the same operations: querying, grouping by month and shipping method, counting orders, and visualizing with a line plot. Differences in SQL functions (DATE_TRUNC vs. DATE_FORMAT) are due to SQL dialects but achieve the same results.","import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = '''
SELECT ShipVia, 
       DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       COUNT(*) AS OrderCount 
FROM orders 
GROUP BY ShipVia, Month;
'''

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as a datetime
orders_data['Month'] = pd.to_datetime(orders_data['Month'], format='%Y-%m')

# Plot the data using Plotly
fig = px.line(orders_data, x='Month', y='OrderCount', color='ShipVia', title='Monthly Order Count by Shipping Method')

# Show the plot to the user
show_to_user(fig)","The input code correctly queries the total number of orders shipped via each method per month, just like the reference implementation. Although the column names differ ('OrderCount' vs. 'OrdersShipped'), both implementations group by 'ShipVia' and 'Month' and count the orders. Both use Plotly to generate a line plot to visualize monthly trends, satisfying the business request. Therefore, the input code is correct.",Base
Find the total number of products supplied by each supplier and visualize it to show which suppliers contribute the most products.,"import plotly.express as px

# Execute the SQL query
sql_query = 'SELECT SupplierID, COUNT(ProductID) AS TotalProducts FROM products GROUP BY SupplierID;'
dataframe = execute_sql_query(sql_query)

# Create a bar chart to visualize the data
fig = px.bar(dataframe, x='SupplierID', y='TotalProducts', title='Total Products Supplied by Each Supplier')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count total products supplied by each supplier
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(p.ProductID) AS TotalProducts 
FROM suppliers s 
LEFT JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalProducts DESC
""""""

# Execute SQL query and get data
supplier_products_df = execute_sql_query(sql_query)

# Visualize the data using Plotly
fig = px.bar(supplier_products_df, x='CompanyName', y='TotalProducts', 
             title='Total Products Supplied by Each Supplier', 
             labels={'TotalProducts': 'Number of Products', 'CompanyName': 'Supplier'}
            )

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly calculates the total number of products supplied by each supplier and visualizes it. It uses a SQL query to join suppliers and products, counts the products for each supplier, and orders the results by the total number of products. The visualization part correctly uses Plotly to create a bar chart, fulfilling the business request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT SupplierID, COUNT(ProductID) AS TotalProducts FROM products GROUP BY SupplierID;'

# Execute the SQL query to retrieve the data
data = execute_sql_query(sql_query)

# Ensure the result is sorted by TotalProducts in descending order
data_sorted = data.sort_values(by='TotalProducts', ascending=False)

# Create a bar chart visualization using plotly
fig = px.bar(data_sorted, x='SupplierID', y='TotalProducts', title='Total Number of Products Supplied by Each Supplier', labels={'SupplierID': 'Supplier ID', 'TotalProducts': 'Total Products'})

# Display the visualization to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by counting products supplied by each supplier, sorting them, and visualizing the result using a bar chart. It achieves the requested outcome effectively, despite an additional sorting step, which does not affect the correctness.",Base
Which products need to be reordered?,"import pandas as pd
import plotly.express as px

# SQL query to retrieve products that need to be reordered
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query using the provided utility function
products_to_reorder_df = execute_sql_query(sql_query)

# Display the products that need to be reordered to the user
df_display = products_to_reorder_df
show_to_user(df_display)","import pandas as pd

# SQL query to fetch products that need to be reordered
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0
""""""

# Execute the SQL query
products_to_reorder = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(products_to_reorder)","The input code includes a condition 'Discontinued = 0' which filters out discontinued products. This additional condition results in a different set of products being reordered compared to the reference implementation, which only checks if 'UnitsInStock <= ReorderLevel'.","import pandas as pd
import plotly.express as px

def get_reorder_products():
    # SQL Query to get products needing reorder
    sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;'
    
    # Execute the SQL query and retrieve the data
    products_needing_reorder = execute_sql_query(sql_query)
    
    # Display the dataframe to the user
    show_to_user(products_needing_reorder)
    
    # Optionally, visualize the data using a bar chart
    fig = px.bar(products_needing_reorder, x='ProductName', y='ProductID', title='Products Needing Reorder')
    show_to_user(fig)

# Call the function
get_reorder_products()","The input code effectively retrieves products that need reordering and outputs this information to the user. It aligns with the business request by using the condition where 'UnitsInStock < ReorderLevel', which is logically equivalent to '<= ReorderLevel' in the reference code. Although it adds a visualization step and includes 'ProductID', this does not impact the correctness in meeting the primary business request.",Finetuned
Which products have the highest total sales volume in quantity and can you visualize the distribution to highlight the top sellers?,"import plotly.express as px
import pandas as pd

# SQL Query to fetch required data
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalSalesQuantity DESC;
'''

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Display the retrieved data (if needed to show tabular data to user)
show_to_user(sales_data)

# Visualization of the distribution to highlight the top sellers
fig = px.bar(sales_data, x='ProductName', y='TotalSalesQuantity', title='Top Selling Products by Quantity', labels={'ProductName': 'Product Name', 'TotalSalesQuantity': 'Total Sales Quantity'})

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales volume grouped by product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) as TotalSalesVolume
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSalesVolume DESC;
'''

# Execute the SQL query and get the data
sales_data = execute_sql_query(sql_query)

# Visualize the distribution of total sales volume
fig = px.bar(sales_data, x='ProductName', y='TotalSalesVolume',
             title='Total Sales Volume by Product',
             labels={'TotalSalesVolume': 'Total Sales Volume', 'ProductName': 'Product'},
             color='TotalSalesVolume',
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the visualization to the user
show_to_user(fig)","The input code successfully retrieves the total sales volume for each product and visualizes the distribution using a bar chart, similar to the reference implementation. Though the column names are different ('TotalSalesVolume' vs. 'TotalSalesQuantity'), the business request is effectively addressed by identifying top-selling products by quantity and visualizing them.","import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalQuantitySold DESC;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Check if we have data
if data.empty:
    print(""No sales data available."")
else:
    # Visualize the distribution of total sales volume
    fig = px.bar(data, x='ProductName', y='TotalQuantitySold', title='Total Sales Volume by Product', labels={'TotalQuantitySold': 'Total Quantity Sold'})
    
    # Display the visualization to the user
    show_to_user(fig)","The input Python code successfully retrieves and visualizes the products with the highest total sales volume in quantity. It achieves the same outcome as the reference implementation by executing a similar SQL query and using Plotly to create a bar chart for visualization. Despite minor differences in SQL syntax and variable naming, the code effectively addresses the business analytic request.",Base
"How many orders were placed and fulfilled in each month of 2023, and can you illustrate the monthly trends with a visualization?","import plotly.express as px
import pandas as pd

# SQL Query from the business analytic request
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       COUNT(orders.OrderID) AS orders_placed, 
       COUNT(CASE WHEN orders.ShippedDate IS NOT NULL THEN 1 END) AS orders_fulfilled 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month 
ORDER BY month
'''

# Execute the SQL query and retrieve data in a pandas dataframe
df = execute_sql_query(sql_query)

# Verify the dataframe content
print(df.head())

# Correct the column names to match the query output
df.columns = ['month', 'orders_placed', 'orders_fulfilled']

# Create a line plot to show monthly trends for orders placed and fulfilled
fig = px.line(df, x='month', y=['orders_placed', 'orders_fulfilled'], 
              labels={'value': 'Count', 'variable': 'Order Status'}, 
              title='Monthly Trends for Orders Placed and Fulfilled in 2023')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to retrieve the number of orders placed and fulfilled by month in 2023
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
    COUNT(OrderID) AS orders_placed, 
    COUNT(CASE WHEN ShippedDate IS NOT NULL THEN OrderID END) AS orders_fulfilled 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month
ORDER BY month
""""""  

# Execute the SQL query and retrieve the results
monthly_orders = execute_sql_query(sql_query)

# Create a line plot for monthly trends of placed and fulfilled orders
fig = px.line(monthly_orders, x='month', y=['orders_placed', 'orders_fulfilled'],
              labels={'value': 'Number of Orders', 'month': 'Month'},
              title='Monthly Trends of Orders Placed and Fulfilled in 2023')

# Show the result to the user
show_to_user(fig)","The input code correctly executes a SQL query to retrieve the number of orders placed and fulfilled by month in 2023. It then creates a line plot using Plotly to visualize monthly trends, fulfilling the business analytic request. The implementation aligns with the reference code in functionality, even if minor details, such as column names and labels, differ slightly.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
    COUNT(orders.OrderID) AS order_count 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY month
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the dataframe by month for better visualization
df = df.sort_values(by='month')

# Create the line plot to show monthly trends
fig = px.line(df, x='month', y='order_count', title='Monthly Order Count in 2023', labels={'month': 'Month', 'order_count': 'Number of Orders'})

# Display the result to the user
show_to_user(fig)","The input code only calculates the total count of orders placed per month and does not differentiate between placed and fulfilled orders, which is required by the business request. It also does not reflect the orders fulfilled count which is a key part of the analysis.",Base
What was the total sales revenue generated in the year 2023?,"
import pandas as pd

# SQL query to get total sales revenue for the year 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Extract the total sales value
if not sales_data.empty:
    total_sales = sales_data['total_sales'][0]
else:
    total_sales = 0

# Create a DataFrame to display the result
df_total_sales = pd.DataFrame({'Year': [2023], 'Total Sales Revenue': [total_sales]})

# Display the total sales revenue to the user
show_to_user(df_total_sales)
","import pandas as pd

# SQL query to calculate total sales revenue for the year 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code does not extract and format the total sales revenue into a DataFrame with the 'Year' and 'Total Sales Revenue' columns like the reference implementation does. It directly displays the SQL query result, which might not have the same structure.","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve total sales revenue for the year 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales_revenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the total sales revenue to the user
show_to_user(df.iloc[0]['total_sales_revenue'])","The input code correctly executes a SQL query to calculate the total sales revenue for the year 2023 and displays the result using the provided utility function. It produces the same outcome as the reference implementation, despite some differences in output format.",Finetuned
Which supplier supplies the highest number of different products?,"import pandas as pd
import plotly.express as px

# Define the SQL query to find the supplier with the highest number of different products
sql_query = '''
SELECT SupplierID, COUNT(DISTINCT ProductID) AS ProductCount 
FROM products 
GROUP BY SupplierID 
ORDER BY ProductCount DESC 
LIMIT 1;
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to find the supplier with the highest number of different products
sql_query = '''
SELECT suppliers.SupplierID, suppliers.CompanyName, COUNT(DISTINCT products.ProductID) AS ProductCount
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY ProductCount DESC
LIMIT 1;
'''

# Execute the query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly finds the supplier who supplies the highest number of different products. It includes the supplier's company name as additional information, but the main task is achieved, matching the reference implementation's outcome.","import pandas as pd
import plotly.express as px

# SQL query to find the supplier who supplies the highest number of different products
sql_query = '''
SELECT suppliers.SupplierID, COUNT(products.ProductID) AS ProductCount
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
GROUP BY suppliers.SupplierID
ORDER BY ProductCount DESC
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code does not use COUNT(DISTINCT ProductID) as required. It counts all product IDs, not distinct ones, leading to a potentially incorrect result.",Base
What is the average shipping cost per order for 2023?,"
import pandas as pd
import plotly.express as px

# Given utility functions
# def execute_sql_query(sql_query: str) -> pd.DataFrame:
#     # Function to execute an SQL query and return a pandas DataFrame
#     pass

# def show_to_user(data):
#     # Function to display data analysis and visualization results
#     pass

# Define the SQL query
sql_query = '''
SELECT AVG(orders.Freight) AS shipping_cost_per_order
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query and retrieve the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","import pandas as pd

# SQL query to calculate the average shipping cost per order for 2023
sql_query = """"""
SELECT AVG(orders.Freight) AS shipping_cost_per_order 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and retrieve the data
shipping_cost_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(shipping_cost_data)","The input code effectively addresses the business analytic request by calculating the average shipping cost per order for 2023 using an SQL query. The SQL query matches the reference implementation, and the functions 'execute_sql_query' and 'show_to_user' are applied correctly. Therefore, the input code achieves the same outcome as the reference implementation.","import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT AVG(Freight) AS ShippingCostPerOrder
FROM orders
WHERE YEAR(OrderDate) = 2023;
""""""

# Execute the query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly calculates the average shipping cost for orders in 2023 using SQL. Both the reference and input code focus on orders made in 2023 and compute the average Freight cost, satisfying the business analytic request. The SQL query constructs, though slightly different, achieve the same result. Therefore, the implementation is correct.",Base
What is the total value of orders shipped in the first quarter of 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
    SELECT QUARTER(o.OrderDate) AS OrderQuarter, 
           SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue 
    FROM orders o 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    WHERE YEAR(o.OrderDate) = 2023 
    GROUP BY OrderQuarter;
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Filter to only include the first quarter
result_df = result_df[result_df['OrderQuarter'] == 1]

# Display the results to the user
show_to_user(result_df)

# Optionally, visualize the total value by quarter
fig = px.bar(result_df, x='OrderQuarter', y='TotalValue', title='Total Value of Orders Shipped in First Quarter of 2023')
show_to_user(fig)
","sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.ShippedDate >= '2023-01-01' AND o.ShippedDate <= '2023-03-31'
'''

result_df = execute_sql_query(sql_query)
show_to_user(result_df)","Both implementations correctly calculate the total value of orders shipped in the first quarter of 2023. The input code computes the sum directly by filtering orders shipped within the specified date range without grouping by quarter, whereas the reference code aggregates data by quarter and filters for the first quarter. Despite the difference in approach, the input code fulfills the business analytic request accurately.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to get the total value of orders shipped in the first quarter of 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.ShippedDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df.head())

# Display the total sales value
total_sales = result_df['total_sales'].iloc[0]
show_to_user(pd.DataFrame({'total_sales': [total_sales]}))","The input code calculates the total value of orders shipped in Q1 of 2023 by filtering the data based on the shipped date, which effectively addresses the business request. It sums up the order values in the specified period and outputs the result, matching the intent and outcome of the reference implementation.",Base
What is the Customer Retention Rate for the last 6 months?,"import pandas as pd

# SQL query to get the number of distinct customers in the last 6 months
customers_last_6_months_query = '''
SELECT COUNT(DISTINCT orders.CustomerID) AS CustomerCount 
FROM orders 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 6 MONTH) AND CURDATE()'''

# SQL query to get the number of distinct customers before the last 6 months
customers_before_6_months_query = '''
SELECT COUNT(DISTINCT orders.CustomerID) AS CustomerCount 
FROM orders 
WHERE orders.OrderDate < DATE_SUB(CURDATE(), INTERVAL 6 MONTH)'''

# Execute the SQL queries
last_6_months_df = execute_sql_query(customers_last_6_months_query)
before_6_months_df = execute_sql_query(customers_before_6_months_query)

# Extract the customer counts
customer_count_last_6_months = last_6_months_df.iloc[0]['CustomerCount']
customer_count_before_6_months = before_6_months_df.iloc[0]['CustomerCount']

# Calculate the Customer Retention Rate
if customer_count_before_6_months != 0:
    customer_retention_rate = customer_count_last_6_months / customer_count_before_6_months
else:
    customer_retention_rate = 0  # To handle division by zero

# Create a DataFrame to show the result
result_df = pd.DataFrame({'CustomerRetentionRate': [customer_retention_rate]})

# Display the result
show_to_user(result_df)","from datetime import datetime, timedelta
import pandas as pd

# Calculate the date range for the last 6 months
today = datetime.today()
date_6_months_ago = today - timedelta(days=6*30)
start_date = date_6_months_ago.strftime('%Y-%m-%d')
end_date = today.strftime('%Y-%m-%d')

# SQL Query to calculate Customer Retention Rate
sql_query = f""""""
SELECT
    (COUNT(DISTINCT CASE WHEN OrderDate BETWEEN '{start_date}' AND '{end_date}' THEN CustomerID END) * 1.0 /
    NULLIF(COUNT(DISTINCT CustomerID) FILTER (WHERE OrderDate < '{start_date}'), 0)) * 100
) AS CustomerRetentionRate
FROM
    orders
""""""  

# Execute the SQL query and get the result
df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)","The input code calculates customer retention rate using a formula that assumes retention is the percentage of customers retained from a time period before 6 months to the last 6 months period. The reference code calculates retention rate as a ratio of customers in the last 6 months to those before this period, not considering percentage format. Also, the addition of NULLIF in the input code handles division by zero differently, as compared to a simple if condition in the reference code.","To calculate the Customer Retention Rate (CRR) for the last 6 months from the MDDX database, we will perform the following steps:

1. **Identify Active Customers in the Last 6 Months**: Determine the number of unique customers who placed orders in the last 6 months.
2. **Identify Customers Before the Last 6 Months**: Count the number of unique customers who placed orders before the last 6 months.
3. **Calculate CRR**: Use the CRR formula \( \text{CRR} = \frac{\text{Active Customers in the Last 6 Months}}{\text{Customers Before the Last 6 Months}} \).

Here is the Python code to achieve this task using the provided utility functions.

```python
import pandas as pd

# SQL queries
query_last_6_months = '''SELECT DISTINCT CustomerID FROM orders WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH);'''

# This assumes the interval before the last 6 months is enough to determine retention, for example checking 1 year ago
query_before_last_6_months = '''SELECT DISTINCT CustomerID FROM orders WHERE OrderDate < DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH);'''

# Execute SQL queries
customers_last_6_months = execute_sql_query(query_last_6_months)
customers_before_last_6_months = execute_sql_query(query_before_last_6_months)

# Calculate distinct counts
num_active_customers_last_6_months = customers_last_6_months['CustomerID'].nunique()
num_customers_before_last_6_months = customers_before_last_6_months['CustomerID'].nunique()

# Handle case where there are no customers before the last 6 months
if num_customers_before_last_6_months == 0:
    # If no customers were there before the last 6 months, consider retention as 0
    customer_retention_rate = 0
    print(""No customers were there before the last 6 months."")
else:
    # Calculate retention rate
    customer_retention_rate = num_active_customers_last_6_months / num_customers_before_last_6_months

# Prepare resulting dataframe to visualize
result_df = pd.DataFrame({'CustomerRetentionRate': [customer_retention_rate]})

# Display the result to user
show_to_user(result_df)
```

### Explanation:
- The code uses two SQL queries to get the distinct customer IDs from the orders table for the appropriate periods.
- We compute the number of unique customers who ordered in the past 6 months and those who ordered before that.
- The Customer Retention Rate (CRR) is then calculated optionally ensuring that if no prior customers exist, the retention rate is handled appropriately.
- Finally, the computed retention rate is shown to the user.","The input code correctly calculates the Customer Retention Rate for the last 6 months by determining the number of distinct customers in both the last 6 months and before that period, just like the reference implementation. It handles the division by zero appropriately and follows the same logic, even though the column naming conventions and SQL details differ slightly.",Finetuned
What is the most common job title among the employees?,"import pandas as pd
import plotly.express as px

# SQL query to find the most common job title among employees
sql_query = '''
SELECT Title, COUNT(*) AS TitleCount 
FROM employees 
GROUP BY Title 
ORDER BY TitleCount DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to count the occurrences of each job title
sql_query = """"""
SELECT Title, COUNT(*) as TitleCount
FROM employees
GROUP BY Title
ORDER BY TitleCount DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly follows the business analytic request by using an SQL query to find and display the most common job title among employees, similar to the reference implementation.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the main function to execute the request
def main():
    # SQL query to get the most common job title
    sql_query = '''
    SELECT JobTitle, COUNT(*) AS JobCount 
    FROM employees 
    GROUP BY JobTitle 
    ORDER BY JobCount DESC 
    LIMIT 1;
    '''
    
    # Execute the SQL query
    result_df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(result_df)

# Execute the main function
if __name__ == '__main__':
    main()","The evaluated code correctly implements the SQL query to find the most common job title by grouping and ordering by count. The difference in column names (`JobTitle` vs. `Title`) does not affect the logic, fulfilling the business analytic request.",Base
Find the difference in days between the hire date and the birthdate of employees.,"import pandas as pd
import plotly.express as px

# SQL query to fetch EmployeeID, HireDate, and BirthDate
sql_query = ""SELECT EmployeeID, HireDate, BirthDate FROM employees;""

dataframe = execute_sql_query(sql_query)

# Calculating the difference in days between HireDate and BirthDate
# First, convert the columns to datetime
if not pd.api.types.is_datetime64_any_dtype(dataframe['HireDate']):
    dataframe['HireDate'] = pd.to_datetime(dataframe['HireDate'])

if not pd.api.types.is_datetime64_any_dtype(dataframe['BirthDate']):
    dataframe['BirthDate'] = pd.to_datetime(dataframe['BirthDate'])

# Calculate the difference in days
dataframe['DaysDifference'] = (dataframe['HireDate'] - dataframe['BirthDate']).dt.days

# Select only EmployeeID and DaysDifference for the final result
result_df = dataframe[['EmployeeID', 'DaysDifference']]

# Display the result to the user
show_to_user(result_df)","import pandas as pd
from datetime import datetime

# SQL query to retrieve the relevant employee data
sql_query = '''
SELECT EmployeeID, BirthDate, HireDate 
FROM employees
'''  

# Execute the SQL query and load the data into a DataFrame
df_employees = execute_sql_query(sql_query)

# Convert the BirthDate and HireDate columns to datetime format  
df_employees['BirthDate'] = pd.to_datetime(df_employees['BirthDate'])

df_employees['HireDate'] = pd.to_datetime(df_employees['HireDate'])

# Calculate the difference in days between HireDate and BirthDate  
df_employees['DaysDifference'] = (df_employees['HireDate'] - df_employees['BirthDate']).dt.days

# Display the resulting DataFrame to the user
show_to_user(df_employees[['EmployeeID', 'DaysDifference']])","The input code correctly executes the SQL query, converts the 'BirthDate' and 'HireDate' columns to datetime, and calculates the difference in days between these two dates. The result is then displayed similarly to the reference implementation.","import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT EmployeeID, DATEDIFF(HireDate, BirthDate) AS AgeAtHire FROM employees;
""""""

# Execute the SQL query using execute_sql_query function
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The input code effectively calculates the difference in days between HireDate and BirthDate using an SQL query that leverages the DATEDIFF function, achieving the same outcome as the reference Python code.",Base
How many products are discontinued?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(*) AS discontinued_products FROM products WHERE products.Discontinued = 1'

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","sql_query = """"""
SELECT COUNT(*) AS discontinued_count
FROM products
WHERE Discontinued = 1;
""""""

# Execute the SQL query to get the count of discontinued products
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code correctly counts the number of discontinued products using an SQL query, which matches the logical outcome of the reference implementation.","# Import necessary libraries
import pandas as pd

# Define the SQL query to count discontinued products
sql_query = 'SELECT COUNT(*) AS DiscontinuedProducts FROM products WHERE Discontinued = 1;'

# Execute the SQL query and get the result
product_count_df = execute_sql_query(sql_query)

# Extract the count from the resulting dataframe
discontinued_count = product_count_df['DiscontinuedProducts'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'DiscontinuedProducts': [discontinued_count]}))
","The input code correctly executes an SQL query to count discontinued products and displays the result, matching the business analytic request and reference implementation outcome.",Base
List all orders that took more than 10 days to fulfill in 2021.,"import pandas as pd
import plotly.express as px

# SQL query to get orders from 2021 that took more than 10 days to fulfill
sql_query = '''
SELECT OrderID 
FROM orders 
WHERE YEAR(OrderDate) = 2021 
AND DATEDIFF(ShippedDate, OrderDate) > 10;
'''

# Execute the SQL query
order_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_df)","import pandas as pd

# SQL query to retrieve all orders that took more than 10 days to fulfill in 2021
sql_query = '''
SELECT OrderID, OrderDate, ShippedDate, (DATEDIFF(ShippedDate, OrderDate)) AS FulfillmentTime
FROM orders
WHERE YEAR(OrderDate) = 2021 AND DATEDIFF(ShippedDate, OrderDate) > 10
'''  

# Execute the SQL query using the utility function
orders_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(orders_df)","The input code correctly fulfills the business analytic request of listing orders from 2021 that took more than 10 days to fulfill. Although it includes more columns than the reference code, it still achieves the same desired outcome of identifying the orders of interest.","import pandas as pd
import plotly.express as px

# SQL query to list all orders that took more than 10 days to fulfill in 2021
sql_query = '''
SELECT OrderID, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTimeInDays 
FROM orders 
WHERE YEAR(OrderDate) = 2021 AND DATEDIFF(ShippedDate, OrderDate) > 10;
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Validate the dataframe columns
if 'OrderID' not in orders_df.columns or 'FulfillmentTimeInDays' not in orders_df.columns:
    raise ValueError('Unexpected columns in the dataframe')

# Display the retrieved orders
show_to_user(orders_df)

# (Optional) Visualization: histogram of Fulfillment Time
fig = px.histogram(orders_df, x='FulfillmentTimeInDays', nbins=20, title='Fulfillment Time Distribution for Orders in 2021')
show_to_user(fig)","The input code correctly retrieves all orders that took more than 10 days to fulfill in 2021. It includes the necessary column 'OrderID' as per the reference implementation, but also adds 'FulfillmentTimeInDays' which does not affect the correctness. The additional visualization step does not impact the fulfillment of the business request.",Base
What was the total sales revenue generated each month in the year 2022? Please include a line chart or bar graph to visualize the monthly sales revenue.,"
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales revenue generated each month in the year 2022
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(OrderDate) = 2022 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query using the provided utility function
sales_data_df = execute_sql_query(sql_query)

# Generate a bar graph to visualize the monthly sales revenue
fig = px.bar(sales_data_df, x='Month', y='TotalSales', title='Monthly Sales Revenue for 2022', labels={'Month': 'Month', 'TotalSales': 'Total Sales Revenue'})

# Display the figure to the user using the provided utility function
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales revenue for each month in 2022
sql_query = '''
SELECT
year(OrderDate) AS Year,
month(OrderDate) AS Month,
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE year(OrderDate) = 2022
GROUP BY year(OrderDate), month(OrderDate)
ORDER BY Month
'''

# Execute the SQL query
monthly_sales = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly sales revenue
fig = px.line(monthly_sales, x='Month', y='TotalSales', title='Total Sales Revenue Each Month in 2022', labels={'TotalSales': 'Sales Revenue', 'Month': 'Month'})

# Display the chart to the user
show_to_user(fig)","The input code correctly calculates and visualizes the total sales revenue generated each month in 2022. It uses the same aggregation logic and criteria as the reference code, despite differing in SQL syntax and chart type. The input code creates a line chart whereas the reference uses a bar graph, but both effectively answer the business analytic request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders 
JOIN ""Order Details"" ON orders.OrderID = ""Order Details"".OrderID 
WHERE YEAR(OrderDate) = 2022 
GROUP BY DATE_TRUNC('month', OrderDate);'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Convert Month to datetime for proper sorting and formatting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Sort the data by Month
sales_data = sales_data.sort_values(by='Month')

# Create a line chart to visualize the monthly sales revenue
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Sales Revenue for 2022', labels={'TotalSales':'Revenue ($)', 'Month':'Month'})

# Display the plot to the user
show_to_user(fig)
","The input code meets the business analytic request by querying for total monthly sales revenue in 2022, ensuring the data is sorted by month, and visualizing it using a line chart. Although the visualization type is different, it is within the scope of the request to display the data effectively.",Base
What was the total sales revenue for the month of January 2023?,"import pandas as pd
import plotly.express as px

def get_total_sales_revenue():
    # SQL query to calculate the total sales revenue for January 2023
    sql_query = """"""
    SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
    FROM orders o
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-01';
    """"""

    # Execute the SQL query
    result_df = execute_sql_query(sql_query)

    # Check if the result_df has the data, as SUM could return None if there are no matching records
    if not result_df.empty:
        total_sales = result_df.iloc[0]['TotalSales']
    else:
        total_sales = 0

    # Create a DataFrame to display the result
    display_df = pd.DataFrame({'TotalSales': [total_sales]})

    # Display the results
    show_to_user(display_df)

# Invoke the function to get and display the total sales revenue
get_total_sales_revenue()","import pandas as pd

# SQL query to calculate total sales revenue for January 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
'''  

# Execute the SQL query and get the result
result_df = execute_sql_query(sql_query)  

# Show the total sales revenue to the user
show_to_user(result_df)","The input code successfully calculates the total sales revenue for January 2023 using a SQL query that sums the sales amounts. It matches the logic of the reference implementation by using SQL to retrieve data for January 2023 and displaying the result using the utility function. The SQL query conditions are equivalent in both the input and reference codes, effectively addressing the business request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Extract the total sales value
TotalSales = df['TotalSales'].iloc[0]

# Convert the result to a dataframe for display
output_df = pd.DataFrame({'TotalSales': [TotalSales]})

# Display the result to the user
show_to_user(output_df)","The input code accurately calculates the total sales revenue for January 2023 using the same method as the reference. Both calculate the sum of sales for January by joining 'orders' and 'Order Details', and the output is correctly displayed using `show_to_user`. There are slight differences such as the date filtering method, but the outcome is equivalent.",Base
"What is the average order value for orders placed between January 1, 2023, and December 31, 2023?","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
'''

# Execute the SQL query and get the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
""""""

avg_order_value_df = execute_sql_query(sql_query)
show_to_user(avg_order_value_df)","The input code correctly calculates the average order value for the specified date range using an SQL query identical to the reference implementation, ensuring the same outcome.","import pandas as pd
import plotly.express as px

# SQL query to get the total revenue and total order count for the specified date range
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue,
       COUNT(DISTINCT orders.OrderID) AS TotalOrders
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure result is not empty
if not result_df.empty:
    # Calculate the average order value
    avg_order_value = result_df['TotalRevenue'].iloc[0] / result_df['TotalOrders'].iloc[0]
    
    # Convert to DataFrame for display& visualization, if needed
    avg_order_value_df = pd.DataFrame({'AverageOrderValue': [avg_order_value]})
    
    # Display the result to the user
    show_to_user(avg_order_value_df)
    
    # Optional: create a bar chart for visualization
    fig = px.bar(avg_order_value_df, x=avg_order_value_df.index, y='AverageOrderValue', title='Average Order Value (2023)')
    show_to_user(fig)
else:
    print(""No data available for the specified date range."")",The input code correctly calculates the average order value by dividing the total revenue by the total number of distinct orders. This matches the logic of the reference implementation and addresses the business analytic request accurately. Additional visualizations and checks for empty results enhance the robustness without altering the core functionality.,Base
Which city has received the highest number of orders? Please include a bar graph to visualize the number of orders by city.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''SELECT ShipCity, COUNT(OrderID) as TotalOrders FROM orders GROUP BY ShipCity ORDER BY TotalOrders DESC'''

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Create a bar graph of the number of orders by city
fig = px.bar(orders_df, x='ShipCity', y='TotalOrders', title='Number of Orders by City')

# Show the bar graph to the user
show_to_user(fig)

# Find the city with the highest number of orders
city_with_highest_orders_df = orders_df.head(1)

# Show the city with the highest number of orders to the user
show_to_user(city_with_highest_orders_df)","import pandas as pd
import plotly.express as px

# SQL query to get the number of orders by city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) as OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
city_orders = execute_sql_query(sql_query)

# Get the city with the highest number of orders
highest_city = city_orders.iloc[0]
print(f""City with the highest number of orders: {highest_city['ShipCity']} with {highest_city['OrderCount']} orders"")

# Create a bar graph to visualize the number of orders by city
fig = px.bar(city_orders, x='ShipCity', y='OrderCount', title='Number of Orders by City')

# Show the graph to the user
show_to_user(fig)","The input code correctly implements the required functionality. It uses the same SQL query to retrieve the number of orders per city, sorts them in descending order, and determines the city with the highest number of orders. A bar graph is then generated using Plotly to show the number of orders by city, fulfilling the business analytic request.","import pandas as pd
import plotly.express as px

# Define the SQL query to get order count by city
sql_query = 'SELECT ShipCity, COUNT(*) AS order_count FROM orders GROUP BY ShipCity ORDER BY order_count DESC;'

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Visualize the number of orders by city using a bar graph
fig = px.bar(orders_df, x='ShipCity', y='order_count', title='Number of Orders by City', labels={'ShipCity': 'City', 'order_count': 'Number of Orders'})

# Show the result to the user
show_to_user(fig)

# Find the city with the highest number of orders
highest_orders_city = orders_df.iloc[0]

# Show the city with the highest number of orders to the user
show_to_user(pd.DataFrame([highest_orders_city]))","The evaluated code correctly implements the business analytic request by executing a SQL query to count orders by city, visualizing the results with a bar graph, and identifying the city with the highest orders. These actions match the purpose of the reference code, even with slight differences in column naming.",Base
Which product category has the highest total sales in 2023? Please include a bar graph or pie chart to visualize the sales by product category.,"import plotly.express as px
import pandas as pd

# SQL Query to get the total sales by product category for the year 2023
sql_query = '''
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName 
ORDER BY total_sales DESC
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Visualize the sales data using a bar graph
fig = px.bar(sales_data, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023', labels={'CategoryName': 'Product Category', 'total_sales': 'Total Sales'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales by product category for the year 2023
sql_query = '''
SELECT c.CategoryName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY c.CategoryName
ORDER BY total_sales DESC
'''

# Execute the SQL query and get the data
sales_data = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(sales_data)

# Create a bar graph to visualize the total sales by product category
fig = px.bar(sales_data, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')

# Show the graph to the user
show_to_user(fig)","The input code correctly executes the SQL query to get total sales by product category for 2023, retrieves the data, and visualizes it using a bar graph with Plotly, matching the intended business requirement and reference outcome.","import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT 
    categories.CategoryName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    [Order Details]
JOIN 
    products ON [Order Details].ProductID = products.ProductID
JOIN 
    categories ON products.CategoryID = categories.CategoryID
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    YEAR(orders.OrderDate) = 2023
GROUP BY 
    categories.CategoryName
ORDER BY 
    total_sales DESC
'''

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Visualize the data; let's use a bar graph for better clarity
fig = px.bar(sales_data, x='CategoryName', y='total_sales', title='Total Sales by Product Category in 2023')

# Display the visualization to the user
show_to_user(fig)","The input code correctly fulfills the business analytic request by determining the product category with the highest total sales in 2023. It uses an appropriate SQL query to calculate total sales and visualizes this data using a bar chart, meeting the requirements set by the reference implementation.",Base
What is the average reorder level across all products?,"import pandas as pd
import plotly.express as px

# Define SQL query to get the average reorder level
sql_query = 'SELECT AVG(ReorderLevel) AS AverageReorderLevel FROM products;'

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to retrieve the average reorder level across all products
sql_query = """"""
SELECT AVG(ReorderLevel) AS AverageReorderLevel 
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code filters out discontinued products with 'WHERE Discontinued = 0', which results in a different outcome than the reference implementation that calculates the average using all products.","import pandas as pd

# SQL Query to get the average reorder level
sql = 'SELECT AVG(ReorderLevel) AS AvgReorderLevel FROM products;'

# Execute the SQL query
result_df = execute_sql_query(sql)

# Extract the average reorder level
avg_reorder_level = result_df['AvgReorderLevel'][0]

# Convert the result to a DataFrame for display purposes
result_to_display = pd.DataFrame({'Average Reorder Level': [avg_reorder_level]})

# Display the result to the user
show_to_user(result_to_display)","The input code correctly computes the average reorder level by executing an SQL query similar to the reference code. Although it processes the result differently by creating a new DataFrame, it effectively addresses the request and delivers the same output to the user.",Finetuned
What is the total inventory value of products currently in stock?,"import pandas as pd
# SQL Query to get the total inventory value
sql_query = 'SELECT SUM(UnitsInStock * UnitPrice) AS TotalInventoryValue FROM products;'

# Execute the SQL query
inventory_df = execute_sql_query(sql_query)

total_inventory_value = inventory_df['TotalInventoryValue'][0]

# Display the result to the user
show_to_user(pd.DataFrame({'Total Inventory Value': [total_inventory_value]}))","import pandas as pd

# SQL query to calculate total inventory value
sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query
inventory_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(inventory_df)","The input code includes a condition 'WHERE Discontinued = 0', which filters out discontinued products. This constraint is not present in the reference implementation, potentially leading to a lower total inventory value. Thus, the implementations would yield different results.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT SUM(UnitsInStock * UnitPrice) AS TotalInventoryValue FROM products;""

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Check the result to ensure it contains the expected column
if not result_df.empty and 'TotalInventoryValue' in result_df.columns:
    total_inventory_value = result_df['TotalInventoryValue'][0]
    
    # Create a DataFrame to display the total inventory value
    display_df = pd.DataFrame({'Total Inventory Value': [total_inventory_value]})
    
    # Visualization not applicable since we are only showing a single value
    display_df['Total Inventory Value'] = display_df['Total Inventory Value'].apply(lambda x: f""${x:.2f}"")
    
    # Use the show_to_user function to display the result
    show_to_user(display_df)
else:
    print(""No data available or the expected column is missing."")","The input code correctly calculates the total inventory value using the same SQL query as the reference implementation. It checks for the presence of data and handles the scenario where the expected column is missing. The final result is formatted as currency and displayed using the provided utility function, achieving the same outcome as the reference code.",Finetuned
Find the average quantity of products ordered per order.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to find the average quantity of products ordered per order
delivered_query = '''
SELECT AVG(Quantity) AS AverageQuantity
FROM [Order Details]
GROUP BY OrderID
'''

# Execute the SQL query and retrieve the data
data = execute_sql_query(delivered_query)

# Calculate the average quantity per order
average_quantity = data['AverageQuantity'].mean()

# Create a DataFrame to display the result
result_df = pd.DataFrame({'Average Quantity': [average_quantity]})

# Show the result to the user
show_to_user(result_df)","The input code calculates and displays the mean of averages, grouping by OrderID, which differs from the reference code's direct average of Quantity for all rows in [Order Details]. Therefore, it does not achieve the same outcome.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code is identical to the reference code. It makes use of the 'execute_sql_query' function to fetch the average quantity of products ordered per order and utilizes 'show_to_user' to display the result. Since this approach correctly retrieves and displays the necessary data, it fulfills the business analytic request as expected.",Finetuned
What is the percentage of orders shipped within the same country as the customer?,"import pandas as pd
import plotly.express as px

# SQL query to get the percentage of orders shipped within the same country as the customer
sql_query = '''
    SELECT (COUNT(*) / (SELECT COUNT(*) from orders) * 100) as percent_same_country 
    FROM orders o
    JOIN customers c ON o.CustomerID = c.CustomerID 
    WHERE o.ShipCountry = c.Country;
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the percentage of same country shipments
show_to_user(result_df)

# Additionally, manually construct a DataFrame for the plotly visualization
visualization_df = pd.DataFrame({'percent_same_country': [result_df.iloc[0]['percent_same_country']]})
# Since the index naturally starts at 0, we'll use that as the x-axis.
visualization_df.index = ['Percentage']  # Give a meaningful label for the x-axis

# Visualize the result as a bar plot (for demonstration purposes)
fig = px.bar(visualization_df, x=visualization_df.index, y='percent_same_country', title='Percentage of Orders Shipped Within the Same Country')
show_to_user(fig)","import pandas as pd

# SQL query to get the necessary data
def calculate_percentage_shipped_within_same_country():
    sql_query = '''
    SELECT
        COUNT(CASE WHEN o.ShipCountry = c.Country THEN 1 END) AS same_country_shipped,
        COUNT(*) AS total_orders
    FROM
        orders o
    JOIN
        customers c ON o.CustomerID = c.CustomerID
    '''
    result_df = execute_sql_query(sql_query)
    return result_df

# Calculate the percentage
result_df = calculate_percentage_shipped_within_same_country()
if result_df['total_orders'][0] > 0:
    percentage = (result_df['same_country_shipped'][0] / result_df['total_orders'][0]) * 100
else:
    percentage = 0

# Create a new dataframe to display the result
output_df = pd.DataFrame({'Percentage of Orders Shipped Within Same Country': [percentage]})

# Show the result to the user
show_to_user(output_df)","The input code correctly calculates the percentage of orders shipped within the same country by using the SQL query to count such orders and total orders, then computes and displays the percentage. The logic matches the reference code's outcome even though the implementation differs.","import pandas as pd

# Define the SQL queries
all_orders_query = 'SELECT COUNT(OrderID) AS TotalOrders FROM orders;'
same_country_orders_query = 'SELECT COUNT(OrderID) AS SameCountryOrders FROM orders O JOIN customers C ON O.CustomerID = C.CustomerID WHERE O.ShipCountry = C.Country;'

# Execute the SQL queries
all_orders_df = execute_sql_query(all_orders_query)
same_country_orders_df = execute_sql_query(same_country_orders_query)

# Extract the counts from the dataframes
total_orders = all_orders_df.at[0, 'TotalOrders']
same_country_orders = same_country_orders_df.at[0, 'SameCountryOrders']

# Calculate the percentage
if total_orders > 0:
    percentage_same_country = (same_country_orders / total_orders) * 100
else:
    percentage_same_country = 0

# Create a dataframe to display the result
result_df = pd.DataFrame({'Metric': ['Percentage of Orders Shipped Within Same Country'], 'Percentage': [percentage_same_country]})

# Display the resulting dataframe to the user
show_to_user(result_df)","The input code successfully calculates the percentage of orders shipped within the same country as the customer by executing two SQL queries to get the total number of orders and the number of orders shipped within the same country, and then dividing the latter by the former. The calculation matches the logic of the reference implementation.",Base
List all employees who were hired this year.,"import pandas as pd
import datetime as dt
from util_functions import execute_sql_query, show_to_user

# SQL query to get all employees hired this year
current_year = dt.datetime.now().year
sql_query = f'SELECT * FROM employees WHERE YEAR(HireDate) = {current_year};'

# Execute the SQL query and fetch the results into a DataFrame
employees_hired_this_year = execute_sql_query(sql_query)

# Display the resulting DataFrame to the user
show_to_user(employees_hired_this_year)","import pandas as pd

# Get the current year
current_year = pd.to_datetime('now').year

# SQL query to retrieve employees hired this year
sql_query = f""""""
SELECT EmployeeID, FirstName, LastName, HireDate 
FROM employees 
WHERE YEAR(HireDate) = {current_year}
""""""

# Execute the SQL query
hired_this_year_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(hired_this_year_df)","The input code achieves the same business goal as the reference implementation by listing all employees hired this year. It correctly retrieves and displays the relevant data using the current year and provided utility functions, even if some details, like selected columns, differ.","import pandas as pd
from datetime import datetime

# Define the SQL query to list all employees who were hired this year
current_year = datetime.now().year
sql_query = f""SELECT * FROM employees WHERE HireDate >= '{current_year}-01-01';""

# Execute the SQL query
employees_hired_this_year = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(employees_hired_this_year)","Both implementations correctly identify employees hired in the current year. The evaluated code uses a condition that checks if the 'HireDate' is greater than or equal to January 1st of the current year, which effectively captures all employees hired this year, similar to the reference code's condition.",Base
What is the total revenue generated each year? Please include a bar graph or line chart to visualize the yearly revenue.,"import plotly.express as px

# SQL query to fetch the total revenue generated each year
sql_query = '''
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS YearlyRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Year 
ORDER BY Year;
'''

# Execute the SQL query and retrieve the data
revenue_df = execute_sql_query(sql_query)

# Make sure the data types are correct for plotting
revenue_df['Year'] = revenue_df['Year'].astype(int)
revenue_df['YearlyRevenue'] = revenue_df['YearlyRevenue'].astype(float)

# Create a bar chart using plotly express
fig = px.bar(revenue_df, x='Year', y='YearlyRevenue', title='Total Revenue Generated Each Year', labels={'Year': 'Year', 'YearlyRevenue': 'Total Revenue'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to fetch total revenue generated each year
sql_query = '''
SELECT
    DATE_FORMAT(OrderDate, '%Y') AS Year,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM
    `orders` o
JOIN
    `[Order Details]` od ON o.OrderID = od.OrderID
GROUP BY
    Year
ORDER BY
    Year;
'''

# Execute the SQL query
revenue_df = execute_sql_query(sql_query)

# Create a line chart for total revenue per year
fig = px.line(revenue_df, x='Year', y='TotalRevenue', title='Total Revenue Generated Each Year', labels={'TotalRevenue': 'Total Revenue', 'Year': 'Year'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly queries the total revenue generated each year and visualizes it using a line chart, which addresses the business analytic request. The differences between the reference and input codes, such as SQL syntax and chart type, do not affect the correctness of the result.","import pandas as pd
import plotly.express as px

# SQL query to retrieve the total revenue generated each year
sql_query = '''
SELECT EXTRACT(YEAR FROM o.OrderDate) AS OrderYear, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY OrderYear;'''

# Execute SQL query using provided util function
revenue_df = execute_sql_query(sql_query)

# Ensure the DataFrame column types are correct
revenue_df['OrderYear'] = revenue_df['OrderYear'].astype(int)
revenue_df['TotalRevenue'] = revenue_df['TotalRevenue'].astype(float)

# Create a bar chart to visualize the yearly revenue
fig = px.bar(revenue_df, x='OrderYear', y='TotalRevenue', title='Total Revenue Generated Each Year', labels={'OrderYear': 'Year', 'TotalRevenue': 'Total Revenue ($)'})

# Display the bar chart to the user
show_to_user(fig)","The input Python code correctly addresses the business request by fetching the total revenue generated each year and visualizing it with a bar chart. The SQL query, data processing, and visualization steps match the reference implementation's outcome, even though column names differ slightly.",Base
Find the total quantity ordered for each product. Please include a bar graph to visualize the total quantity ordered by product.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductID, SUM(Quantity) AS total_quantity FROM [Order Details] GROUP BY ProductID;'

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Convert ProductID to string for better bar graph visualization
result_df['ProductID'] = result_df['ProductID'].astype(str)

# Create a bar graph using plotly
fig = px.bar(result_df, x='ProductID', y='total_quantity', title='Total Quantity Ordered by Product', labels={'ProductID': 'Product ID', 'total_quantity': 'Total Quantity Ordered'})

# Display the bar graph to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total quantity ordered for each product
sql_query = '''
SELECT od.ProductID, SUM(od.Quantity) as TotalQuantityOrdered 
FROM [Order Details] od 
GROUP BY od.ProductID
'''

# Execute SQL query and get the data
product_quantity_df = execute_sql_query(sql_query)

# Create a bar graph to visualize the total quantity ordered by product
fig = px.bar(product_quantity_df, x='ProductID', y='TotalQuantityOrdered', 
             title='Total Quantity Ordered by Product', 
             labels={'ProductID': 'Product ID', 'TotalQuantityOrdered': 'Total Quantity Ordered'})

# Show the results to the user
show_to_user(fig)","The evaluated code correctly implements the business request by retrieving the total quantity ordered for each product using a SQL query. It matches the reference code in functionality by executing the SQL query, storing the result in a DataFrame, and generating a bar chart using Plotly. Despite minor differences in column naming ('TotalQuantityOrdered' instead of 'total_quantity'), it fulfills the requirements and visualizes the data appropriately.","import plotly.express as px

# SQL query to find total quantity ordered for each product
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID;""

# Execute the SQL query and get the result as a pandas dataframe
try:
    df = execute_sql_query(sql_query)
except Exception as e:
    print(f""An error occurred: {e}"")
    df = pd.DataFrame()

# Ensure the dataframe has the correct columns
if not df.empty and {""ProductID"", ""TotalQuantity""}.issubset(df.columns):
    # Create a bar graph using Plotly
    fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Quantity Ordered by Product', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})
    
    # Show the plot to the user
    show_to_user(fig)
else:
    print(""Dataframe is empty or does not contain the required columns."")","The input code correctly executes an SQL query to retrieve the total quantity ordered per product and visualizes the results using a Plotly bar graph. It checks for the necessary columns and handles exceptions, aligning with the business request and reference implementation objectives.",Base
How many orders have been placed by customers in Germany in the year 2023?,"import pandas as pd

# Define the SQL query
sql_query = '''
SELECT COUNT(o.OrderID) as OrderCount
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
WHERE c.Country = 'Germany'
AND o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Since the result is a single value count, we can extract the value for display
order_count = result_df['OrderCount'].iloc[0]

# Display the result
show_to_user(order_count)","import pandas as pd

# Define the SQL query to count the number of orders placed by customers in Germany in 2023
sql_query = """"""
SELECT COUNT(orders.OrderID) AS number_of_orders
FROM orders
JOIN customers ON orders.CustomerID = customers.CustomerID
WHERE customers.Country = 'Germany' AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query using the provided utility function
order_counts_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_counts_df)",The input code displays the entire DataFrame instead of extracting and displaying just the order count value.,"import pandas as pd

# SQL Query to count the number of orders by customers in Germany in 2023
sql_query = '''
SELECT COUNT(*) AS order_count
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
WHERE c.Country = 'Germany'
  AND o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly implements the logic to count orders by customers in Germany for the year 2023. It matches the outcome of the reference implementation by using a similar SQL query and executing it properly. The way it displays the result differs slightly, but it effectively answers the business request.",Finetuned
Calculate the average age of employees.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT AVG((CURRENT_DATE - BirthDate) / 365.25) AS AvgAge FROM employees;""

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Extract the average age from the result
avg_age = result_df.loc[0, 'AvgAge']

# Prepare the data for visualization
visualization_df = pd.DataFrame({'Metric': ['Average Age'], 'Value': [avg_age]})

# Create a bar chart using plotly
fig = px.bar(visualization_df, x='Metric', y='Value', title='Average Age of Employees')

# Display the result to the user
show_to_user(fig)","import pandas as pd

# Define the SQL query to get employee birth dates
sql_query = """"""
SELECT BirthDate
FROM employees
""""""

# Execute the SQL query to retrieve data
employees_df = execute_sql_query(sql_query)

# Convert BirthDate to datetime format
employees_df['BirthDate'] = pd.to_datetime(employees_df['BirthDate'])

# Calculate the current age of each employee
current_date = pd.Timestamp('now')
employees_df['Age'] = (current_date - employees_df['BirthDate']).dt.days // 365

# Calculate the average age
average_age = employees_df['Age'].mean()

# Prepare the result for display
result_df = pd.DataFrame({'Average Age': [average_age]})

# Show the result to the user
show_to_user(result_df)","The input code correctly calculates the average age of employees by retrieving birth dates from the database, converting them to age in years, and then calculating the mean. It displays the result using 'show_to_user', effectively addressing the business analytic request.","import pandas as pd

# SQL query to calculate the average age of employees
sql_query = 'SELECT AVG(DATEDIFF(CURDATE(), BirthDate) / 365.25) AS AverageAge FROM employees;'

# Execute the SQL query and retrieve the result
result_df = execute_sql_query(sql_query)

# Extract the average age value from the dataframe
average_age = result_df.loc[0, 'AverageAge']

# Convert the average age to a dataframe for display purposes
average_age_df = pd.DataFrame({'AverageAge': [average_age]})

# Display the result to the user
show_to_user(average_age_df)","The input code correctly calculates the average age of employees using an SQL query. It retrieves the result with `execute_sql_query`, extracts the average age, and displays it with `show_to_user`. The main difference from the reference code is the absence of a Plotly visualization, but since visualization isn't required by the task, the code meets the business request.",Base
What is the total discount given on orders placed in 2022?,"import pandas as pd
import plotly.express as px

# SQL query from the business request
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS total_discount 
FROM orders 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(orders.OrderDate) = 2022
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Assuming the result_df has a column called 'total_discount'
total_discount = result_df['total_discount'].iloc[0]

# Prepare the data to show to user
show_df = pd.DataFrame({'Total Discount': [total_discount]})

# Visualize the result using plotly
fig = px.bar(show_df, x=['Total Discount'], y=show_df['Total Discount'], title='Total Discount Given on Orders Placed in 2022')

# Show the result to the user
show_to_user(fig)
","import pandas as pd

# SQL query to retrieve total discount for orders placed in 2022
sql_query = """"""
SELECT SUM([Order Details].Discount) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
""""""

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The evaluated code only sums the discount percentage, not the total discount amount. It misses multiplying by 'UnitPrice' and 'Quantity' as in the reference code, leading to an incorrect total discount computation.","
import pandas as pd

# Step 1: Write the SQL query to calculate the total discount on orders placed in 2022
sql_query = ""SELECT SUM(Discount * Quantity * UnitPrice) AS TotalDiscountGiven FROM [Order Details] WHERE OrderID IN (SELECT OrderID FROM orders WHERE YEAR(OrderDate) = 2022);""

# Step 2: Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Step 3: Display the result to the user
show_to_user(result_df)",The evaluated code correctly calculates the total discount on orders placed in 2022 using an SQL query. It joins the 'Order Details' with 'orders' using OrderID and filters the orders by the year 2022. The result is then displayed using the show_to_user function. The methodology matches the reference implementation in terms of functionality.,Finetuned
Which customer region had the highest average order fulfillment time in the past month? Please include a bar graph to visualize the average fulfillment time by region.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = '''
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE OrderDate >= CURDATE() - INTERVAL 1 MONTH
GROUP BY ShipRegion
ORDER BY AvgFulfillmentTime DESC;
'''

# Execute the SQL query and get the results in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Generate the bar graph using plotly
fig = px.bar(result_df, x='ShipRegion', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Region in the Past Month')

# Show the bar graph to the user
show_to_user(fig)

# Corrected code to properly retrieve and display the region with the highest average fulfillment time
highest_avg_fulfillment_time_region = result_df[['ShipRegion', 'AvgFulfillmentTime']].iloc[0]

# Show the region with the highest average fulfillment time to the user
show_to_user(highest_avg_fulfillment_time_region)","import pandas as pd
import plotly.express as px

# SQL query to retrieve average order fulfillment time by region for the past month
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
GROUP BY ShipRegion
ORDER BY AvgFulfillmentTime DESC
""""""

# Execute the query using the provided function
avg_fulfillment_by_region = execute_sql_query(sql_query)

# Find the region with the highest average fulfillment time
highest_avg_region = avg_fulfillment_by_region.head(1)

# Create a bar graph to visualize average fulfillment time by region
fig = px.bar(avg_fulfillment_by_region, x='ShipRegion', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Region', labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'ShipRegion': 'Region'})

# Show the figure and the highest average region to user
show_to_user(fig)
show_to_user(highest_avg_region)","The input code correctly retrieves and visualizes average fulfillment times by region. It identifies the region with the highest average using 'head(1)', which is equivalent to 'iloc[0]' in the reference. Both bars and data presentation cover the requirements effectively.","import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.Region, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time
FROM orders
INNER JOIN customers ON orders.CustomerID = customers.CustomerID
WHERE orders.OrderDate >= CURDATE() - INTERVAL 1 MONTH
GROUP BY customers.Region
ORDER BY avg_fulfillment_time DESC
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar graph to visualize the average fulfillment time by region
fig = px.bar(df, x='Region', y='avg_fulfillment_time', title='Average Order Fulfillment Time by Region (Past Month)', labels={'avg_fulfillment_time':'Average Fulfillment Time (Days)', 'Region':'Region'})

# Display the bar graph to the user
show_to_user(fig)","The input code correctly joins the orders and customers tables, calculates the average fulfillment time for regions, and displays a bar graph using Plotly. It effectively addresses the business request to find the region with the highest average order fulfillment time. Although it doesn't explicitly output the top region, the bar chart includes this information, fulfilling the request similar to the reference implementation.",Base
What is the average price per unit of all products?,"import pandas as pd

# SQL Query to get the average price per unit of all products
sql_query = 'SELECT AVG(UnitPrice) AS AveragePrice FROM products;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the AveragePrice value and create a new dataframe to format the result
average_price = result_df['AveragePrice'][0]
formatted_result_df = pd.DataFrame({'AveragePrice': [average_price]})

# Display the result to the user
show_to_user(formatted_result_df)","import pandas as pd

# SQL query to get the average price per unit of all products
sql_query = 'SELECT AVG(UnitPrice) AS AveragePrice FROM products WHERE Discontinued = 0'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code includes a filter (WHERE Discontinued = 0) that was not present in the reference implementation. This alters the business request by only considering non-discontinued products, which may lead to a different average price than calculating it across all products.","import pandas as pd

# Execute the SQL query to get the average price per unit of all products
sql_query = 'SELECT AVG(UnitPrice) AS AveragePrice FROM products;'
result_df = execute_sql_query(sql_query)

# Display the average price to the user
show_to_user(result_df)","The input Python code correctly addresses the business analytic request by executing the SQL query to calculate the average price per unit of all products and displays the result using the available utility function. While it does not reformat the result into a new dataframe, this step is not necessary to meet the requirement of showing the average price to the user.",Finetuned
Find the average order value for each customer.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CustomerID, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) as average_order_value 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
'''

# Execute the SQL query and retrieve data in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, you can visualize the average order value per customer using a bar chart
fig = px.bar(result_df, x='CustomerID', y='average_order_value', title='Average Order Value per Customer')
show_to_user(fig)","import pandas as pd

# SQL query to calculate the average order value for each customer
sql_query = '''
SELECT c.CustomerID, c.CompanyName, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM customers AS c
JOIN orders AS o ON c.CustomerID = o.CustomerID
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
''' 

# Execute the SQL query and retrieve the data
average_order_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_order_value_df)","The input code fulfills the business analytic request by accurately calculating the average order value for each customer. The inclusion of the CompanyName in the GROUP BY clause does not affect the calculation of the average values per CustomerID, and the output is consistent with the reference implementation's intent.","
import pandas as pd
import plotly.express as px

# SQL query to find the average order value for each customer
sql_query = '''
    SELECT c.CustomerID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
    FROM customers c
    JOIN orders o ON c.CustomerID = o.CustomerID
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    GROUP BY c.CustomerID;
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the data analysis result to the user
show_to_user(result_df)

# Optionally, visualize the result using a bar chart
fig = px.bar(result_df, x='CustomerID', y='AverageOrderValue', title='Average Order Value for Each Customer',
             labels={'CustomerID': 'Customer ID', 'AverageOrderValue': 'Average Order Value'})

# Show the visualization to the user
show_to_user(fig)
","The input code accurately fulfills the business request to find the average order value for each customer. It uses the correct SQL query to calculate the average by multiplying UnitPrice, Quantity, and the Discount. The results are grouped by CustomerID, and the output is displayed to the user. Similarly, the input code produces a bar chart visualization of the same data, consistent with the reference implementation outcomes.",Base
What is the on-time delivery rate for the month of April 2023? Please include a bar graph or line chart to visualize the on-time delivery rate.,"import plotly.express as px
import pandas as pd

# SQL query to get the on-time delivery rate for April 2023
sql_query = '''SELECT COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30''' 

# Execute the SQL query
df = execute_sql_query(sql_query)

# Verify if the query result is not empty
if not df.empty:
    # Extract the on-time delivery rate
    on_time_delivery_rate = df['on_time_delivery_rate'][0]
    on_time_delivery_rate_df = pd.DataFrame({'Date': ['April 2023'], 'On-time Delivery Rate': [on_time_delivery_rate]})

    # Create a bar chart to visualize the on-time delivery rate
    fig = px.bar(on_time_delivery_rate_df, x='Date', y='On-time Delivery Rate', title='On-time Delivery Rate for April 2023')

    # Show the result to the user
    show_to_user(fig)
else:
    print('No data available for the specified period.')","import pandas as pd
import plotly.express as px

# SQL query to calculate the on-time delivery rate for April 2023
sql_query = '''
SELECT 
    COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM orders
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30'
'''  

# Execute the SQL query and retrieve the results
on_time_delivery_rate_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the on-time delivery rate
fig = px.bar(on_time_delivery_rate_df, 
             x=['On-time Delivery Rate'], 
             title='On-time Delivery Rate for April 2023', 
             labels={'value': 'On-time Delivery Rate', 'variable': 'Metrics'})

# Show the result to the user
show_to_user(fig)",The input code correctly calculates the on-time delivery rate for April 2023 using SQL and visualizes it with a bar chart using plotly. It achieves the same outcome as the reference implementation.,"import pandas as pd
import plotly.express as px

# Step 1: Define the SQL queries
orders_sql = """"""
SELECT o.OrderID
FROM orders o
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-04'
AND o.ShippedDate <= o.RequiredDate;
""""""

total_orders_sql = """"""
SELECT COUNT(o.OrderID) AS total_orders
FROM orders o
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-04';
""""""

# Step 2: Execute the SQL queries to get the data
orders_df = execute_sql_query(orders_sql)
total_orders_df = execute_sql_query(total_orders_sql)

# Step 3: Calculate the on-time delivery rate
on_time_delivery_count = len(orders_df)
total_orders_count = total_orders_df.iloc[0, 0]  # Extract total count from dataframe
on_time_delivery_rate = (on_time_delivery_count / total_orders_count) * 100 if total_orders_count > 0 else 0

# Step 4: Create a DataFrame for visualization purposes
rate_df = pd.DataFrame({
    'Month': ['April 2023'],
    'On_Time_Delivery_Rate': [on_time_delivery_rate]
})

# Step 5: Plot the on-time delivery rate
fig = px.bar(rate_df, x='Month', y='On_Time_Delivery_Rate', title='On-Time Delivery Rate for April 2023')

# Step 6: Display the visualization
show_to_user(fig)","The input code correctly calculates and visualizes the on-time delivery rate for April 2023. It executes two SQL queries to determine the number of on-time deliveries and the total number of deliveries, calculates the rate, and creates a bar chart to display the result. The approach differs from the reference but meets the business request requirements.",Base
What is the on-time delivery rate for each month in 2023? Include a line chart visualization for better illustration.,"import pandas as pd
import plotly.express as px

# SQL query to get on-time delivery rate for each month in 2023
date_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE NULL END) * 1.0 / COUNT(*) AS on_time_delivery_rate 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY month;
""""""

# Execute the SQL query against the database and get the result as a DataFrame
data_frame = execute_sql_query(date_query)

# Ensure the month column is ordered correctly
data_frame['month'] = pd.to_datetime(data_frame['month'], format='%Y-%m')
data_frame = data_frame.sort_values('month')

# Create a line chart visualization using plotly
fig = px.line(data_frame, x='month', y='on_time_delivery_rate', title='On-time Delivery Rate for Each Month in 2023')
fig.update_xaxes(tickformat=""%Y-%m"")

# Show the line chart to the user
show_to_user(fig)

# Additionally, show the data table to the user
show_to_user(data_frame)","import pandas as pd
import plotly.express as px

# SQL query to calculate the on-time delivery rate for each month in 2023
sql_query = '''
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS TotalOrders, 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeOrders
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2023
GROUP BY 
    Month
ORDER BY 
    Month;
'''  

# Execute the SQL query to get the data
on_time_delivery_data = execute_sql_query(sql_query)

# Calculate the on-time delivery rate
on_time_delivery_data['OnTimeRate'] = (on_time_delivery_data['OnTimeOrders'] / on_time_delivery_data['TotalOrders']) * 100

# Visualization
fig = px.line(on_time_delivery_data, x='Month', y='OnTimeRate', title='On-Time Delivery Rate for Each Month in 2023',
              labels={'OnTimeRate': 'On-Time Delivery Rate (%)', 'Month': 'Month'}, markers=True)

# Show the results to the user
show_to_user(fig)","The input code correctly calculates the on-time delivery rate for each month in 2023. It performs a SQL query to fetch total and on-time orders, calculates the rate, and visualizes it using a line chart. The approach and outcomes align with the reference implementation.","import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
(SUM(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 ELSE 0 END) / COUNT(orders.OrderID)) * 100 AS OnTimeDeliveryRate 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY Month;
'''

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Ensure the month column is in datetime format for proper sorting
results_df['Month'] = pd.to_datetime(results_df['Month'])

# Sort the results by Month to make sure the line chart is in chronological order
results_df = results_df.sort_values('Month')

# Create a line chart using plotly
fig = px.line(results_df, x='Month', y='OnTimeDeliveryRate', title='On-Time Delivery Rate for Each Month in 2023', labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'Month': 'Month'})

# Display the chart to the user
show_to_user(fig)","The input code successfully calculates the on-time delivery rate for each month in 2023 and visualizes it using a line chart. It effectively handles date formatting and sorting, mirroring the required functionality of the reference implementation. Minor differences, like multiplying by 100 for a percentage, do not affect the correctness of the answer.",Base
What is the total number of units on order for each product in 2022? Include a bar chart visualization to better illustrate the results.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, SUM(products.UnitsOnOrder) AS units_on_order
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
'''

# Execute the SQL query and get the result in a pandas dataframe
df = execute_sql_query(sql_query)

# Create the bar chart using plotly express
fig = px.bar(df, x='ProductID', y='units_on_order', title='Total Units on Order for Each Product in 2022', labels={'ProductID': 'Product ID', 'units_on_order': 'Units On Order'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total units on order for each product in 2022
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS total_units_on_order 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID
""""""

# Execute the SQL query and retrieve the data
units_on_order_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(units_on_order_df, x='ProductID', y='total_units_on_order', 
             title='Total Units on Order for Each Product in 2022',
             labels={'total_units_on_order': 'Total Units on Order', 'ProductID': 'Product ID'})

# Show the figure to the user
show_to_user(fig)","The input code retrieves 'SUM([Order Details].Quantity)' while the reference code retrieves 'SUM(products.UnitsOnOrder)'. The 'UnitsOnOrder' attribute should be summed, not the 'Quantity' from the 'Order Details' table.","import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_units
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductName
""""""

# Execute the SQL query and get the data
data_df = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(data_df, x='ProductName', y='total_units', title='Total Units on Order for Each Product in 2022', labels={'ProductName': 'Product Name', 'total_units': 'Total Units'})

# Show the figure to the user
show_to_user(fig)","The input code calculates total units based on 'Order Details.Quantity', while the reference uses 'products.UnitsOnOrder'. Additionally, the input groups by 'ProductName', whereas the reference groups by 'ProductID'.",None
What are the names and prices of products that have less than 20 units in stock?,"import pandas as pd

# Define the SQL query to retrieve the required data
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the data to the user using the provided utility function
show_to_user(result_df)","import pandas as pd

# SQL query to retrieve product names and prices of products with less than 20 units in stock
sql_query = '''
SELECT ProductName, UnitPrice
FROM products
WHERE UnitsInStock < 20
''' 

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code successfully retrieves and displays the names and prices of products with less than 20 units in stock, matching the functionality of the reference code.","import pandas as pd
import plotly.express as px

# SQL query to get names and prices of products with less than 20 units in stock
sql_query = 'SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock < 20;'

# Execute the SQL query and retrieve the data
products_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(products_df)

# Optional: visualization of the data
fig = px.bar(products_df, x='ProductName', y='UnitPrice', title='Products with Less Than 20 Units in Stock and Their Prices')
show_to_user(fig)","The input code effectively retrieves the names and prices of products with less than 20 units in stock, matching the functionality of the reference implementation. The code additionally provides a plotly visualization, which is optional but doesn't alter the correctness of the code regarding the business request.",Base
Calculate the total quantity of products sold per product category. Use a bar chart to visualize the quantities per category.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CategoryID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY CategoryID
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='CategoryID', y='TotalQuantity', title='Total Quantity of Products Sold per Category', labels={'CategoryID': 'Product Category', 'TotalQuantity': 'Total Quantity Sold'})

# Display the result
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total quantity of products sold per product category
sql_query = '''
SELECT p.ProductCategory, SUM(od.Quantity) as TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductCategory
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities per category
fig = px.bar(result_df, x='ProductCategory', y='TotalQuantity', title='Total Quantity of Products Sold per Category')

# Show the plot to the user
show_to_user(fig)","The input code successfully fulfills the business request by calculating and visualizing the total quantity of products sold per product category. The SQL query correctly joins the 'Order Details' and 'products' tables, grouping by 'ProductCategory' and summing up the quantities. The bar chart is generated using Plotly with appropriate axes. Despite using different column names from the reference code, it achieves the same objective.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.CategoryID, SUM(od.Quantity) AS TotalQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.CategoryID;'''

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='TotalQuantity', title='Total Quantity of Products Sold per Category', 
             labels={'CategoryID': 'Category ID', 'TotalQuantity': 'Total Quantity Sold'})

# Show the bar chart to the user
show_to_user(fig)",The input code correctly executes an SQL query to obtain total quantities sold per product category and visualizes the result with a Plotly bar chart. It matches the reference implementation's logic and achieves the requested business outcome.,Base
List all orders that were shipped to Germany.,"import pandas as pd
import plotly.express as px

# SQL query to list all orders shipped to Germany
sql_query = ""SELECT * FROM orders WHERE ShipCountry = 'Germany';""

# Execute the query and retrieve the data as a pandas dataframe
# Ensure execute_sql_query function is properly used to retrieve the data
try:
    df_orders_germany = execute_sql_query(sql_query)
except Exception as e:
    raise RuntimeError('Error executing SQL query') from e

# Display the retrieved data to the user
show_to_user(df_orders_germany)","import pandas as pd

# SQL query to get all orders shipped to Germany
sql_query = """"""
SELECT * 
FROM orders 
WHERE ShipCountry = 'Germany'
""""""

# Execute the SQL query and retrieve data
orders_shipped_to_germany = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(orders_shipped_to_germany)
",The input code correctly executes the SQL query to list all orders shipped to Germany using the `execute_sql_query` function and displays the results with `show_to_user`. This matches the desired outcome specified in the business analytic request and the reference implementation.,"import pandas as pd
import plotly.express as px

# SQL query to fetch orders shipped to Germany
sql_query = ""SELECT OrderID, OrderDate, CustomerID, ShipCity, ShipPostalCode FROM orders WHERE ShipCountry = 'Germany';""

# Execute the SQL query
germany_orders_df = execute_sql_query(sql_query)

# Display the resultant dataframe to the user
show_to_user(germany_orders_df)

# Optional: Visualize the number of orders per month shipped to Germany
germany_orders_df['OrderDate'] = pd.to_datetime(germany_orders_df['OrderDate'])
germany_orders_df['OrderDate'] = germany_orders_df['OrderDate'].dt.to_period('M')
month_counts_df = germany_orders_df.groupby('OrderDate').size().reset_index(name='OrderCount')

# Plotting the data using plotly
fig = px.line(month_counts_df, x='OrderDate', y='OrderCount', title='Monthly Orders Shipped to Germany')

# Display the plot to the user
show_to_user(fig)","The Python code correctly filters orders shipped to Germany and visualizes the monthly order count, addressing the business request effectively.",Base
Who are the top 3 employees based on total sales generated? Include a bar chart visualization for better illustration.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result dataframe to the user
show_to_user(result_df)

# Create bar chart visualization
fig = px.bar(result_df, x='EmployeeID', y='TotalSales', title='Top 3 Employees Based on Total Sales Generated')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales by each employee
sql_query = '''
SELECT 
    e.EmployeeID, 
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
ORDER BY 
    TotalSales DESC
LIMIT 3;
'''

# Execute the SQL query and load the data into a pandas dataframe
employee_sales_df = execute_sql_query(sql_query)

# Create a bar chart for the total sales of the top 3 employees
fig = px.bar(employee_sales_df, 
             x='EmployeeName', 
             y='TotalSales', 
             title='Top 3 Employees by Total Sales', 
             labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee'}, 
             color='TotalSales')

# Show the result to the user
show_to_user(fig)","The input Python code successfully addresses the business analytic request by retrieving the top 3 employees based on total sales generated. While it includes the employees' full names, this additional detail does not affect the correctness. The visualization is effectively created and displayed using Plotly, similar to the reference implementation.","import plotly.express as px

# SQL query to get top 3 employees based on total sales
sql_query = '''
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', 
             title='Top 3 Employees Based on Total Sales', 
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales ($)'})

# Show the bar chart to the user
show_to_user(fig)","The input code correctly executes a SQL query to find the top 3 employees based on total sales. It then visualizes the results with a bar chart using Plotly and displays it using the show_to_user function, which aligns with the business analytic request and achieves the same outcome as the reference implementation.",Base
What are the total sales for each product? Use a bar chart to visualize the total sales per product.,"import plotly.express as px

# SQL query to get total sales for each product
sql_query = '''
SELECT products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName;
'''

# Execute SQL query to retrieve data
df = execute_sql_query(sql_query)

# Create bar chart using plotly
fig = px.bar(df, x='ProductName', y='TotalSales', title='Total Sales per Product', 
             labels={'ProductName': 'Product Name', 'TotalSales': 'Total Sales'}, 
             height=600)

# Show the bar chart to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales per product
sql_query = '''
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
''' 

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart for total sales per product
fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Total Sales per Product')

# Show the bar chart to the user
show_to_user(fig)","The input Python code accurately fulfills the business analytic request by calculating the total sales for each product using a SQL query and visualizing the results in a bar chart using Plotly. The approach is equivalent to the reference implementation, and the output will match in terms of business logic.","import plotly.express as px

# Define the SQL query
sql_query = 'SELECT p.ProductID, SUM(od.Quantity) AS TotalUnitsSold FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.ProductID;'

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales per product
fig = px.bar(sales_data, x='ProductID', y='TotalUnitsSold', title='Total Sales per Product', labels={'ProductID': 'Product ID', 'TotalUnitsSold': 'Total Units Sold'})

# Display the visualization to the user
show_to_user(fig)",The input code calculates 'TotalUnitsSold' instead of 'TotalSales'. It sums quantities rather than multiplying by UnitPrice and applying discount as required by the business analytic request and reference implementation.,Base
List the orders that have not been shipped within the required date.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT orders.OrderID, orders.RequiredDate, orders.ShippedDate
FROM orders
WHERE orders.ShippedDate IS NULL OR orders.ShippedDate > orders.RequiredDate;
'''

# Execute the SQL query and store the result in a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)","import pandas as pd

# SQL query to get orders that have not been shipped by the required date
sql_query = '''
SELECT *
FROM orders
WHERE ShippedDate IS NULL OR ShippedDate > RequiredDate
'''

# Execute the SQL query to get the data
unshipped_orders = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(unshipped_orders)","The input code correctly fulfills the business analytic request by querying orders where the shipped date is either null or later than the required date. The output will match the result of the reference implementation, as the SQL query logic is identical. Though column selection in the query is different ('SELECT *' vs. 'SELECT specific columns'), it doesn't affect the outcome in addressing the request.","import pandas as pd
import plotly.express as px

# SQL query to get orders that have not been shipped within the required date
query = '''
SELECT o.OrderID, o.OrderDate, o.RequiredDate, o.ShippedDate 
FROM orders o 
WHERE o.ShippedDate > o.RequiredDate;
'''

# Execute the SQL query
orders_not_shipped_on_time = execute_sql_query(query)

# Display the result to the user
show_to_user(orders_not_shipped_on_time)

# Optional: Creating a visualization of the data
fig = px.bar(orders_not_shipped_on-time, x='OrderID', y='ShippedDate', title='Orders Not Shipped Within Required Date', 
             labels={'ShippedDate': 'Shipped Date'})

# Show the visualization
show_to_user(fig)","The input code fails to account for orders where the ShippedDate is NULL, which was specified in the business request and handled by the reference implementation.",Base
How many products have been discontinued?,"import pandas as pd

# SQL query to get the count of discontinued products
sql_query = 'SELECT COUNT(*) AS discontinued_count FROM products WHERE products.Discontinued = 1'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to user
show_to_user(result_df)","import pandas as pd

# SQL query to count the number of discontinued products
sql_query = """"""
SELECT COUNT(*) AS discontinued_count 
FROM products 
WHERE Discontinued = 1
""""""

# Execute the SQL query and retrieve the data
result = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result)","The input code correctly queries the number of discontinued products using the same SQL logic as the reference code, executes the query with 'execute_sql_query', and displays the result with 'show_to_user'.","import pandas as pd

# Step 1: Define the SQL query to count discontinued products
count_discontinued_products_sql = 'SELECT COUNT(*) FROM products WHERE Discontinued = 1;'

# Step 2: Execute the SQL query
result_df = execute_sql_query(count_discontinued_products_sql)

# Step 3: Extract the count from the resulting dataframe
count_discontinued_products = result_df.iloc[0, 0]

# Step 4: Prepare the result for display
result_to_display = pd.DataFrame({'Count of Discontinued Products': [count_discontinued_products]})

# Step 5: Display the result to the user
show_to_user(result_to_display)","The input code correctly executes a SQL query to count discontinued products, extracts the count from the resulting DataFrame, and displays it to the user. It achieves the same outcome as the reference implementation—correctly counts the number of discontinued products.",Base
What are the total units ordered for each supplier? Include a bar chart to illustrate the data better.,"import pandas as pd
import plotly.express as px

# SQL query to get total units ordered for each supplier
sql_query = '''
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Generate bar chart to illustrate the data
fig = px.bar(result_df, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered for Each Supplier', labels={'SupplierID': 'Supplier ID', 'TotalUnitsOrdered': 'Total Units Ordered'})

# Display the bar chart to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total units ordered for each supplier
sql_query = '''
SELECT p.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.SupplierID
'''  

# Execute the SQL query and fetch the data
supplier_units_df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the total units ordered for each supplier
fig = px.bar(supplier_units_df, x='SupplierID', y='TotalUnitsOrdered',
             title='Total Units Ordered for Each Supplier',
             labels={'SupplierID': 'Supplier ID', 'TotalUnitsOrdered': 'Total Units Ordered'})

# Show the figure to the user
show_to_user(fig)","The input code correctly calculates the total units ordered for each supplier by joining the 'Order Details' and 'products' tables, and then grouping by the SupplierID. The resulting dataframe matches the reference implementation in terms of data content. Both implementations produce a bar chart using Plotly to illustrate the data. The difference in the join order does not affect the outcome of the query.","import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = ""SELECT p.SupplierID, SUM(od.Quantity) AS TotalUnitsOrdered FROM [Order Details] od JOIN products p ON od.ProductID = p.ProductID GROUP BY p.SupplierID;""

# Execute the SQL query to get the data
supplier_units_df = execute_sql_query(sql_query)

# Check if the dataframe is empty
if not supplier_units_df.empty:
    # Create a bar chart using plotly
    fig = px.bar(supplier_units_df, x='SupplierID', y='TotalUnitsOrdered', title='Total Units Ordered for Each Supplier', labels={'SupplierID': 'Supplier ID', 'TotalUnitsOrdered': 'Total Units Ordered'})
    
    # Display the bar chart to the user
    show_to_user(fig)
else:
    print('No data available to display.')
",The input code misses the JOIN with 'suppliers' to ensure correct SupplierIDs and totals. It uses 'p.SupplierID' instead of 's.SupplierID'. This could result in incorrect grouping and totals if there are discrepancies between product and supplier data.,Base
Identify the orders that were placed but never shipped in 2022.,"import pandas as pd
import plotly.express as px

# Define the SQL query to identify orders placed but never shipped in 2022
sql_query = """"""
SELECT OrderID 
FROM orders 
WHERE ShippedDate IS NULL 
AND DATE_FORMAT(OrderDate, '%Y') = '2022'""""""

# Execute the SQL query to retrieve the data
orders_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(orders_df)
","sql_query = """"""
SELECT *
FROM orders
WHERE YEAR(OrderDate) = 2022 AND ShippedDate IS NULL;
""""""

# Execute the SQL query and retrieve the data
unshipped_orders = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(unshipped_orders)","The input code correctly executes an SQL query to identify orders placed in 2022 but never shipped, using conditions that match the business analytic request and reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query based on business logic
sql_query = '''
SELECT o.OrderID, o.OrderDate 
FROM orders o 
WHERE o.ShippedDate IS NULL 
AND o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
'''

# Execute the SQL query to get the required data
df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(df)","The input code correctly identifies orders placed in 2022 that were never shipped. It uses the condition 'WHERE ShippedDate IS NULL AND OrderDate BETWEEN '2022-01-01' AND '2022-12-31'' to filter the orders, which matches the intent of the reference implementation. The use of 'BETWEEN' ensures the dates are correctly captured within the year 2022, equivalent to the DATE_FORMAT condition in the reference implementation.",Base
What is the total revenue generated by each customer? Use a bar chart to visualize the revenue per customer.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID;'''

# Execute SQL query and retrieve the data
customer_revenue_df = execute_sql_query(sql_query)

# Plot the bar chart
fig = px.bar(customer_revenue_df, x='CustomerID', y='TotalRevenue', title='Total Revenue per Customer', labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue ($)'})

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue per customer
sql_query = '''
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalRevenue DESC;
'''

# Execute the SQL query and retrieve data
revenue_per_customer_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue per customer
fig = px.bar(revenue_per_customer_df, x='CompanyName', y='TotalRevenue',
             title='Total Revenue Generated by Each Customer',
             labels={'CompanyName': 'Customer Name', 'TotalRevenue': 'Total Revenue ($)'})

# Show the plot to the user
show_to_user(fig)","The input code correctly calculates total revenue per customer and visualizes it using a bar chart. Although it includes CompanyName in the query and groups by it, this does not affect the correctness of the task, which is to calculate and plot revenue per customer. Both implementations achieve the same analytic result.","To achieve the task of calculating the total revenue generated by each customer and visualizing it using a bar chart, follow these steps:

1. Execute the SQL query to retrieve the data.
2. Process the resulting dataframe to ensure proper data types and sorting.
3. Create a bar chart using Plotly (or any other library of your choice).
4. Display the visualization to the user.

Here's how you can implement it in Python:

```python
import pandas as pd
import plotly.express as px

# 1. Execute the SQL query
sql_query = '''
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
'''

# Fetch the data using the provided utility function
df = execute_sql_query(sql_query)

# 2. Ensure the data types are correct (Optional, but good practice)
# df['CustomerID'] = df['CustomerID'].astype(str)
# df['TotalRevenue'] = df['TotalRevenue'].astype(float)

# 3. Visualize the revenue per customer using a bar chart
fig = px.bar(df, x='CustomerID', y='TotalRevenue', title='Total Revenue per Customer')

# 4. Display the visualization to the user
show_to_user(fig)
```

In this code:

- We retrieve the required data using the `execute_sql_query` function.
- We use Plotly's `px.bar` function to create a bar chart where the x-axis is `CustomerID` and the y-axis is `TotalRevenue`.
- Finally, we display the chart using the `show_to_user` utility function.

Ensure that the necessary libraries (`pandas`, `plotly`) are installed in your Python environment.","The input code correctly executes the SQL query to calculate the total revenue per customer and visualizes it using a Plotly bar chart. It achieves the same outcome as the reference implementation, despite minor differences in comments and optional data type checks.",Base
What is the total sales revenue generated in the month of January 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# Execute the SQL query and get the result dataframe
df = execute_sql_query(sql_query)

# Check if df has data before displaying
if not df.empty:
    # Display the total sales revenue to the user
    show_to_user(df)
else:
    show_to_user(pd.DataFrame({'TotalSales': [0]}))
","import pandas as pd

# Define the SQL query to retrieve total sales revenue for January 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
""""""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code accurately executes the SQL query to sum sales revenue for January 2023, matching the reference implementation. Both use the correct date range and operations to calculate total sales. Although date filtering syntax differs slightly, the logic is equivalent, and both handle potential empty results correctly.","import pandas as pd
import plotly.express as px

# SQL query to get the total sales revenue for January 2023
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';
'''

# Execute the SQL query
sales_df = execute_sql_query(sql_query)

# Ensure the result is a single scalar value
if not sales_df.empty and 'TotalSales' in sales_df.columns:
    total_sales = sales_df['TotalSales'].iloc[0]
else:
    total_sales = 0

# Display the total sales revenue to the user
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))",The input code successfully calculates the total sales revenue for January 2023 using a SQL query. It checks for the presence of data and extracts the 'TotalSales' correctly before displaying it. This matches the intent of the reference code.,Base
What is the total quantity of each product sold? Include a bar chart to better illustrate the results.,"
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(result_df, x='ProductID', y='TotalQuantity', title='Total Quantity of Each Product Sold', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})

# Display the result to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query to get the total quantity sold for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantitySold DESC;
'''

# Step 2: Execute the SQL query
result_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart to visualize total quantity sold for each product
fig = px.bar(result_df, x='ProductName', y='TotalQuantitySold',
             title='Total Quantity of Each Product Sold',
             labels={'TotalQuantitySold': 'Total Quantity Sold', 'ProductName': 'Product Name'})

# Step 4: Show the result to the user
show_to_user(fig)","The input code effectively addresses the business analytic request by calculating the total quantity sold for each product and creating a bar chart. It includes both the ProductID and ProductName, which is additional information but does not affect correctness. The inclusion of ProductName provides a more informative bar chart.","import plotly.express as px


def get_total_quantity_per_product():
    # Define the SQL query
    sql_query = '''
    SELECT ProductName, SUM(od.Quantity) AS TotalQuantitySold 
    FROM [Order Details] od 
    JOIN products p ON od.ProductID = p.ProductID 
    GROUP BY ProductName;
    '''
    
    # Execute the SQL query and get the result as a pandas dataframe
    df = execute_sql_query(sql_query)
    
    # Create a bar chart using plotly
    fig = px.bar(df, x='ProductName', y='TotalQuantitySold', 
                 title='Total Quantity Sold per Product', 
                 labels={'ProductName': 'Product Name', 'TotalQuantitySold': 'Total Quantity Sold'})
    
    # Show the bar chart to the user
    show_to_user(fig)


# Execute the function to get the total quantities and display the chart
get_total_quantity_per_product()","The input code correctly calculates the total quantity of each product sold and displays a bar chart, matching the business analytic request. It groups by 'ProductName' instead of 'ProductID', which is acceptable as it effectively answers the question. The SQL query execution and visualization steps are correctly implemented.",Base
What are the top 5 customers by order value? Visualize this using a bar chart.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalOrderValue 
FROM customers 
INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5;''' 

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(result_df, x='CustomerID', y='TotalOrderValue', title='Top 5 Customers by Order Value', labels={'CustomerID':'Customer ID', 'TotalOrderValue':'Total Order Value'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total order value for each customer
sql_query = '''
SELECT  c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue
FROM customers AS c
JOIN orders AS o ON c.CustomerID = o.CustomerID
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalOrderValue DESC
LIMIT 5
'''

# Execute SQL query
top_customers = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 customers by order value
fig = px.bar(top_customers, x='CompanyName', y='TotalOrderValue',
             title='Top 5 Customers by Order Value',
             labels={'TotalOrderValue': 'Total Order Value', 'CompanyName': 'Customer Name'},
             color='TotalOrderValue')

# Show the plot to the user
show_to_user(fig)","The input code successfully retrieves the top 5 customers by total order value using a SQL query. It then visualizes the results in a bar chart, using Plotly, by 'TotalOrderValue'. The primary difference from the reference code is the inclusion of 'CompanyName' for labeling the x-axis instead of 'CustomerID', which still effectively answers the business analytic request.","The requested task involves executing an SQL query to retrieve the data, followed by visualizing the data using a bar chart in Python. Here’s how you can do that step-by-step.

### Step 1: Define the SQL Query
The given SQL query is:

```sql
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5;
```

### Step 2: Execute the SQL Query
You can use the provided utility function `execute_sql_query` to run the SQL query and retrieve the data.

### Step 3: Visualize the Data
Use `matplotlib` or `plotly` to create a bar chart of the top 5 customers by order value.

### Complete Python Code
Below is the complete code that executes the SQL query and visualizes the result:

```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY TotalOrderValue DESC 
LIMIT 5;
'''

# Execute the SQL query to get data into a pandas dataframe
df_top_customers = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(df_top_customers, x='CustomerID', y='TotalOrderValue', title='Top 5 Customers by Order Value')

# Display the visualization to the user
show_to_user(fig)
```

### Explanation
1. The SQL query fetches the top 5 customers based on their total order value by joining three tables.
2. The result of the SQL query is stored in `df_top_customers`, a pandas dataframe.
3. The bar chart is created using the `plotly.express` library, specifying 'CustomerID' as the x-axis and 'TotalOrderValue' as the y-axis.
4. Finally, the created chart is displayed using the `show_to_user` function.

### Note
Ensure that you have the required libraries installed (`pandas`, `plotly`), and that the database connection is properly handled in the `execute_sql_query` function.
","The input Python code correctly executes the SQL query to retrieve the top 5 customers by order value and visualizes the data using a bar chart with Plotly, matching the business analytic request. It aligns with the logic of the reference implementation.",Base
How many products are in each category? Include a pie chart to better illustrate the products per category.,"import plotly.express as px

# SQL Query
sql_query = 'SELECT CategoryID, COUNT(ProductID) AS ProductCount FROM products GROUP BY CategoryID;'

# Execute the SQL query to retrieve data
products_per_category_df = execute_sql_query(sql_query)

# Create a pie chart to illustrate the products per category
fig = px.pie(products_per_category_df, names='CategoryID', values='ProductCount', title='Products per Category')

# Show the pie chart to the user
show_to_user(fig)","
import pandas as pd
import plotly.express as px

# SQL query to count products by category
sql_query = '''
SELECT  CategoryID, COUNT(*) as ProductCount 
FROM products 
WHERE Discontinued = 0
GROUP BY CategoryID
'''  

# Execute the query and get the result in a pandas DataFrame
category_counts = execute_sql_query(sql_query)

# Creating a pie chart to visualize the product counts per category
fig = px.pie(category_counts, names='CategoryID', values='ProductCount', title='Products per Category')

# Show the results to the user
show_to_user(fig)  
","The input code adds a condition 'WHERE Discontinued = 0', which filters out discontinued products. This may lead to a different product count per category compared to the reference implementation, which counts all products regardless of their discontinued status.","import plotly.express as px

# Execute the SQL query to get the data
sql_query = 'SELECT CategoryID, COUNT(*) AS NumProducts FROM products GROUP BY CategoryID;'
df = execute_sql_query(sql_query)

# Ensure CategoryID is treated as a string for better visualization
df['CategoryID'] = df['CategoryID'].astype(str)

# Create a pie chart to visualize the number of products per category
fig = px.pie(df, names='CategoryID', values='NumProducts', title='Products per Category')

# Show the pie chart to the user
show_to_user(fig)","The input code achieves the same outcome as the reference code. It counts the number of products in each category and uses a pie chart to visualize this data. The column names differ slightly ('NumProducts' vs. 'ProductCount'), but this does not affect the correctness of the solution.",Finetuned
Identify the employees who report to each manager.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT Manager.LastName AS ManagerLastName, Manager.FirstName AS ManagerFirstName, 
       Subordinate.LastName AS EmployeeLastName, Subordinate.FirstName AS EmployeeFirstName 
FROM employees AS Subordinate 
JOIN employees AS Manager ON Subordinate.ReportsTo = Manager.EmployeeID;
'''

# Execute the SQL query
employee_manager_df = execute_sql_query(sql_query)

# Check the result
print(employee_manager_df.head())  # Optional: To display the top rows of the dataframe

# Show the result to the user
show_to_user(employee_manager_df)","sql_query = '''
SELECT e1.LastName AS ManagerLastName, e1.FirstName AS ManagerFirstName,
       e2.LastName AS EmployeeLastName, e2.FirstName AS EmployeeFirstName
FROM employees e1
JOIN employees e2 ON e1.EmployeeID = e2.ReportsTo
ORDER BY e1.EmployeeID, e2.LastName;'''
df_managers = execute_sql_query(sql_query)
show_to_user(df_managers)","The input code successfully identifies employees reporting to each manager by correctly joining the employees table on 'ReportsTo' and 'EmployeeID'. The SQL query logic matches the reference implementation, even if the specifics like column ordering differ. Both implementations effectively answer the business request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, e.ReportsTo 
FROM employees e 
JOIN employees m ON e.ReportsTo = m.EmployeeID 
ORDER BY e.ReportsTo;
'''

# Execute the SQL query to get the employee data
employee_data = execute_sql_query(sql_query)

# Display the employee data to the user
show_to_user(employee_data)

# Optional: Visualize the reporting structure (Hierarchical Tree)
fig = px.treemap(employee_data, path=['ReportsTo', 'EmployeeID'], values='EmployeeID',
                 title='Employees Reporting to Each Manager')

show_to_user(fig)
","The input code does not achieve the same outcome as the reference implementation. The reference implementation returns a list of employees with their respective managers, while the input code returns a list of employees along with their 'ReportsTo' field, and orders by this field. The visualization in the input does not replace the need for a separate listing of employees reporting to each manager.",Base
Which employee generated the most sales in the last year? Include a bar chart visualization to better illustrate this.,"import pandas as pd
import plotly.express as px

# SQL query to find the employee who generated the most sales in the last year.
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = YEAR(CURDATE())
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the SQL query and get the result into a pandas dataframe.
df = execute_sql_query(sql_query)

# Validate if the dataframe is not empty
if df.empty:
    raise ValueError('The query returned no results. Please check the data or query.')

# Bar chart visualization of the employee with the highest sales.
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Employee with the Most Sales in the Last Year')

# Display the bar chart visualization to the user.
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to get total sales by each employee in the last year
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the SQL query to get the employee with the most sales
most_sales_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(most_sales_df)

# Define the SQL query to get total sales by all employees for bar chart
sql_query_bar = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
""""""

# Execute the SQL query to get sales data for all employees
all_sales_df = execute_sql_query(sql_query_bar)

# Create a bar chart visualization using Plotly
fig = px.bar(all_sales_df, x='FirstName + LastName', y='TotalSales',
             labels={'FirstName + LastName': 'Employee Name', 'TotalSales': 'Total Sales'},
             title='Total Sales by Employee in the Last Year')

# Show the bar chart to the user
show_to_user(fig)","The input code correctly retrieves the employee with the most sales in the last year and visualizes the sales of all employees. The additional information of employee names enhances clarity without affecting correctness. The bar chart allows comparison among all employees' sales, and both components fulfill the business request effectively.","import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
    SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
    FROM employees 
    JOIN orders ON employees.EmployeeID = orders.EmployeeID 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE() 
    GROUP BY employees.EmployeeID 
    ORDER BY TotalSales DESC 
    LIMIT 1
'''

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Visualization with Plotly
figure = px.bar(df, x='EmployeeID', y='TotalSales', title='Top Employee by Sales in the Last Year')

# Displaying the data and the plot
show_to_user(df)
show_to_user(figure)
","The input code correctly identifies the employee with the most sales in the last year using a SQL query. The query calculates total sales and sorts the results in descending order, limiting the output to the top employee. It also includes a bar chart visualization using Plotly to illustrate the findings, and both the results and visualization are displayed to the user. This aligns with the business analytic request and reference implementation.",Base
Which products need to be reordered soon?,"import pandas as pd
import plotly.express as px

def get_products_to_reorder():
    sql_query = ''' 
    SELECT products.ProductName 
    FROM products 
    WHERE products.UnitsInStock <= products.ReorderLevel;
    '''
    
    # Execute the SQL query to retrieve the data
    df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(df)
    
    # Check if the dataframe is not empty before plotting
    if not df.empty:
        # Optionally, we can also visualize the number of products to be reordered
        fig = px.bar(df, x='ProductName', title='Products to Reorder')
        show_to_user(fig)

# Call the function to execute the process
get_products_to_reorder()","import pandas as pd

# SQL query to find products that need to be reordered soon
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0
AND UnitsInStock <= ReorderLevel
""""""

# Execute the query
products_to_reorder = execute_sql_query(sql_query)

# Show results to the user
show_to_user(products_to_reorder)","The evaluated code correctly retrieves products that need reordering, similar to the reference code, by using a SQL query with conditions on UnitsInStock and ReorderLevel. It differs slightly by including Discontinued=0, which refines the query by excluding discontinued products. The output is shown using the provided 'show_to_user' function, meeting the requirements of the business analytic request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ProductID, ProductName 
FROM products 
WHERE UnitsInStock < ReorderLevel 
''' 

# Execute the SQL query to retrieve data
products_to_reorder = execute_sql_query(sql_query)

# Optionally, visualize the products that need to be reordered
fig = px.bar(products_to_reorder, x='ProductName', y='ProductID', 
             title='Products to be Reordered', 
             labels={'ProductID': 'Product ID', 'ProductName': 'Product Name'})

# Show the result
show_to_user(fig)

# Show the DataFrame result as well (optional)
show_to_user(products_to_reorder)","The input code correctly retrieves products that need to be reordered by checking if 'UnitsInStock' is less than 'ReorderLevel', matching the logic from the reference implementation. While the input code includes 'ProductID' in the query and visualization, this does not impact the correctness regarding the business analytic request, which is to identify products needing reorder. Both implementations use visualization appropriately, and use the utility functions as required.",Base
How many orders did each employee handle in the first quarter of this year? Include a bar chart for better illustration.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID;
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(result_df, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Each Employee in Q1 2023', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count orders handled by each employee in the first quarter of this year (2023)
sql_query = '''
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrdersHandled
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-04-01'
GROUP BY e.EmployeeID
ORDER BY OrdersHandled DESC;
'''

# Execute the SQL query and retrieve the data in a pandas dataframe
orders_handled_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders handled by each employee
fig = px.bar(orders_handled_df, x='EmployeeName', y='OrdersHandled',
             title='Orders Handled by Each Employee in Q1 2023',
             labels={'OrdersHandled': 'Number of Orders', 'EmployeeName': 'Employee'},
             color='OrdersHandled')

# Show the data visualization to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by calculating the number of orders handled by each employee in the first quarter of 2023. It utilizes a similar SQL query structure to count orders per employee, including a join between employees and orders tables, and uses the correct date range. Although the input code includes additional employee name data and orders the output by the number of orders, it still effectively retrieves the necessary information. The visualization is created using Plotly and displayed, fulfilling the request.","import pandas as pd
import plotly.express as px

# SQL query as specified
sql_query = '''
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS order_count 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY employees.EmployeeID;
'''

# Executing the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Ensure the data is sorted for better visualization
data = data.sort_values(by='order_count', ascending=False)

# Create a bar chart using plotly
fig = px.bar(data, x='EmployeeID', y='order_count', 
             title='Employee Orders Count in Q1 2023', 
             labels={'EmployeeID': 'Employee ID', 'order_count': 'Order Count'})

# Display the visualization result
show_to_user(fig)
","The input Python code correctly executes the SQL query to count how many orders each employee handled in the first quarter of the year. It groups the data by employee and counts the orders, then creates and displays a bar chart using Plotly. Although the variable names and some minor ordering differ from the reference code, the outcome effectively answers the business analytic request.",Base
"What is the total sales for each product category this year, and can you provide a bar chart to visualize the results?","import pandas as pd
import plotly.express as px

# SQL query to get total sales for each product category this year
sql_query = '''
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY categories.CategoryName
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(sales_data, x='CategoryName', y='TotalSales', title='Total Sales for Each Product Category This Year', labels={'CategoryName': 'Product Category', 'TotalSales': 'Total Sales'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales by product category for the current year
sql_query = '''
SELECT p.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY p.CategoryID
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Assuming CategoryID is numeric, we may need to convert it to a category name,
# for demonstration, let's assume we have a mapping from CategoryID to CategoryName
category_mapping = {1: 'Beverages', 2: 'Condiments', 3: 'Confections', 4: 'Dairy Products'}

# Map CategoryID to CategoryName
sales_data['CategoryName'] = sales_data['CategoryID'].map(category_mapping)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='CategoryName', y='TotalSales', title='Total Sales by Product Category This Year', labels={'TotalSales': 'Total Sales', 'CategoryName': 'Product Category'})

# Show the results to the user
show_to_user(fig)",The input code correctly calculates the total sales for each product category this year and visualizes the results in a bar chart. It maps CategoryID to CategoryName which is a valid approach to ensure the same outcome as the reference implementation.,"import pandas as pd
import plotly.express as px

# Define the SQL query
this_year_query = """"""
SELECT categories.CategoryID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE YEAR([Order Details].OrderDate) = YEAR(CURDATE()) 
GROUP BY categories.CategoryID;""""""

# Execute the query to retrieve data
sales_data = execute_sql_query(this_year_query)

# Check if sales_data has the expected columns
if 'CategoryID' not in sales_data.columns or 'total_sales' not in sales_data.columns:
    raise ValueError('Unexpected columns in sales_data')

# Create a bar chart using plotly
fig = px.bar(sales_data, x='CategoryID', y='total_sales', title='Total Sales for Each Product Category This Year')

# Display the figure
show_to_user(fig)","The input code uses 'CategoryID' instead of 'CategoryName', resulting in different logic from the reference implementation. It also uses 'Order Details.OrderDate' instead of 'orders.OrderDate', which may affect data accuracy.",Base
"Find the total freight cost for all orders shipped via each shipping method in 2022, and create a pie chart to illustrate the distribution.","import plotly.express as px

# Define the SQL query
sql_query = '''
    SELECT ShipVia, SUM(Freight) AS TotalFreight
    FROM orders
    WHERE YEAR(OrderDate) = 2022
    GROUP BY ShipVia;
'''

# Execute the SQL query to get the data
freight_data = execute_sql_query(sql_query)

# Check if the resulting dataframe is empty
if freight_data.empty:
    raise ValueError('No freight data found for the year 2022')

# Create a pie chart using plotly express
fig = px.pie(freight_data, values='TotalFreight', names='ShipVia', title='Total Freight Cost by Shipping Method in 2022')

# Display the pie chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the total freight cost by shipping method for the year 2022
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
WHERE YEAR(OrderDate) = 2022
GROUP BY ShipVia
""""""

# Execute the SQL query and store the result in a dataframe
freight_data = execute_sql_query(sql_query)

# Create a pie chart to illustrate the distribution of freight costs by shipping method
fig = px.pie(freight_data, names='ShipVia', values='TotalFreight', title='Total Freight Cost Distribution by Shipping Method (2022)')

# Show the plot to the user
data = show_to_user(fig)",The input Python code correctly executes an SQL query to get total freight cost by shipping method for 2022 and visualizes the data using a pie chart. It achieves the same outcome as the reference implementation.,"import pandas as pd
import plotly.express as px

# SQL Query to get the total freight cost for all orders shipped via each shipping method in 2022
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight 
FROM orders 
WHERE YEAR(OrderDate) = 2022 
GROUP BY ShipVia;
""""""

# Execute the SQL query and get the result in a pandas dataframe
data = execute_sql_query(sql_query)

# Create a pie chart using plotly
fig = px.pie(data, values='TotalFreight', names='ShipVia', title='Total Freight Cost by Shipping Method in 2022')

# Display the pie chart to the user using the provided utility function
show_to_user(fig)","The input code correctly executes the SQL query to sum freight costs by shipping method for the year 2022, creates a pie chart with Plotly, and uses the correct utility functions for executing the query and displaying the chart. The logic matches the reference implementation.",Base
What are the five cities with the highest total sales? Can you provide a bar chart to visualize this information?,"import plotly.express as px

# Define the SQL Query
sql_query = '''
SELECT ShipCity, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY ShipCity
ORDER BY TotalSales DESC
LIMIT 5;
'''

# Execute the SQL query to get the dataframe
sales_df = execute_sql_query(sql_query)

# Create the bar chart using Plotly Express
fig = px.bar(sales_df, x='ShipCity', y='TotalSales', title='Top 5 Cities with Highest Total Sales', labels={'ShipCity':'City', 'TotalSales':'Total Sales'})

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales per city
sql_query = '''
SELECT
    o.ShipCity,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM
    [Order Details] od
JOIN
    orders o ON od.OrderID = o.OrderID
JOIN
    employees e ON o.EmployeeID = e.EmployeeID
GROUP BY
    o.ShipCity
ORDER BY
    TotalSales DESC
LIMIT 5
'''  

# Execute the SQL query and get the data
city_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales by city
fig = px.bar(city_sales_df, x='ShipCity', y='TotalSales', title='Top 5 Cities by Total Sales')

# Show the plot to the user
show_to_user(fig)",The input code achieves the same business objective as the reference implementation. Both codes execute a SQL query to get the top five cities by total sales and then create a bar chart using Plotly Express to visualize this data. The additional join with the employees table in the input code does not affect the result as it still groups by and orders sales correctly. The output remains consistent with the analytic request.,"
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT ShipCity, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ShipCity
ORDER BY TotalSales DESC
LIMIT 5;
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Create the bar chart using plotly
fig = px.bar(result_df, x='ShipCity', y='TotalSales', title='Top 5 Cities with Highest Total Sales')

# Show the visualization to the user
show_to_user(fig)
",The input code matches the logic and outcome of the reference implementation by selecting the top five cities with the highest total sales and visualizing it with a bar chart using Plotly. Column names and function usage are consistent with the provided utilities.,Base
"Calculate the total number of units ordered for each product category, and represent this data using a bar chart.","
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM [Order Details] od 
INNER JOIN products p ON od.ProductID = p.ProductID 
INNER JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryID;
'''

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(results_df, x='CategoryID', y='TotalUnitsOrdered', 
             title='Total Units Ordered per Product Category', 
             labels={'CategoryID': 'Product Category', 'TotalUnitsOrdered': 'Total Units Ordered'})

# Display the bar chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to calculate total units ordered for each product category
sql_query = '''
SELECT p.CategoryID, SUM(od.Quantity) AS TotalUnitsOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID;
'''

# Execute the SQL query
category_units_df = execute_sql_query(sql_query)

# Check if data is not empty and create a bar chart
if not category_units_df.empty:
    # Creating bar chart
    fig = px.bar(category_units_df, x='CategoryID', y='TotalUnitsOrdered', 
                 title='Total Units Ordered by Product Category', 
                 labels={'CategoryID': 'Product Category', 'TotalUnitsOrdered': 'Total Units Ordered'})
    
    # Show the figure to the user
    show_to_user(fig)
else:
    print('No data available for the given query.')","The input code fulfills the business analytic request by calculating the total units ordered for each product category and representing the data with a bar chart using Plotly, similar to the reference implementation. Differences do not impact the outcome.","import plotly.express as px

# Step 1: Execute the SQL query to get the data
sql_query = '''
SELECT c.CategoryID, SUM(od.Quantity) AS TotalQuantityOrdered 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN categories c ON p.CategoryID = c.CategoryID 
GROUP BY c.CategoryID;
'''

data = execute_sql_query(sql_query)

# Step 2: Create a bar chart using Plotly
fig = px.bar(data, x='CategoryID', y='TotalQuantityOrdered', 
             title='Total Units Ordered for Each Product Category', 
             labels={'CategoryID': 'Product Category', 'TotalQuantityOrdered': 'Total Quantity Ordered'})

# Step 3: Display the chart to the user
show_to_user(fig)","The input code correctly calculates the total number of units ordered for each product category and displays the data using a bar chart. Although the column name for total quantities differs ('TotalUnitsOrdered' vs. 'TotalQuantityOrdered'), both implementations perform the same SQL query logic and achieve the desired outcome.",Base
What is the monthly trend of order placements for the current year? Please include a line graph to illustrate the trend.,"import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT MONTH(OrderDate) AS Month, COUNT(*) AS NumberOfOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY MONTH(OrderDate);
'''

# Execute the SQL query and get the data
order_data = execute_sql_query(sql_query)

# Ensure the Month column is treated as integer for correct sorting
order_data['Month'] = order_data['Month'].astype(int)

# Sort the data by Month to ensure the line graph is in chronological order
order_data = order_data.sort_values(by='Month')

# Create the line graph using plotly
fig = px.line(order_data, x='Month', y='NumberOfOrders', title='Monthly Trend of Order Placements for the Current Year')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get monthly order placements for the current year
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       COUNT(OrderID) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURDATE())
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query and get the data
monthly_orders = execute_sql_query(sql_query)

# Create a line graph to illustrate the trend
fig = px.line(monthly_orders, x='Month', y='OrderCount', title='Monthly Trend of Order Placements for Current Year',
              labels={'Month': 'Month', 'OrderCount': 'Number of Orders'})

# Show the result to user
show_to_user(fig)","Both implementations correctly query the orders for the current year and create a line graph to display the monthly trend. While the input code formats the month as 'YYYY-MM', it still achieves the desired trend analysis. Sorting is inherent due to the SQL ORDER BY clause, so both approaches produce functionally equivalent outputs.","import pandas as pd
import plotly.express as px

# SQL query to retrieve the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY Month 
ORDER BY Month ASC
""""""

# Execute the SQL query using the provided utility function
month_order_data = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as a datetime type
month_order_data['Month'] = pd.to_datetime(month_order_data['Month'], format='%Y-%m')

# Create a line graph using plotly
fig = px.line(month_order_data, x='Month', y='OrderCount', title='Monthly Trend of Order Placements', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})

# Show the created plot to the user
show_to_user(fig)","The input code satisfies the business analytic request by calculating the monthly trend of order placements for the current year and visualizing it with a line graph. The differences in column name formats and methods used do not affect the overall outcome, as both approaches result in the necessary chronological line graph displaying the trend.",Base
How long has each employee been working at the company?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT employees.EmployeeID, DATEDIFF(CURDATE(), employees.HireDate) AS DaysWorked FROM employees;'

# Execute the SQL query to retrieve the data
employee_data = execute_sql_query(sql_query)

# Ensure the data is sorted by EmployeeID
employee_data = employee_data.sort_values(by='EmployeeID')

# Display the result to the user using the provided utility function
show_to_user(employee_data)","import pandas as pd

# Define the SQL query to calculate the duration of employment for each employee
sql_query = '''
SELECT
    EmployeeID,
    FirstName,
    LastName,
    DATEDIFF(CURRENT_DATE, HireDate) AS DaysWorked
FROM
    employees
'''

# Execute the SQL query to retrieve data
employees_data = execute_sql_query(sql_query)

# Display the resulting data to the user
show_to_user(employees_data)","The input code accurately calculates the number of days each employee has worked at the company using similar logic as the reference code. Both codes achieve the same outcome by using the DATEDIFF function, even though the input code includes additional columns (FirstName, LastName). The core requirement of determining employment duration is successfully met and displayed using the provided utility functions.","import pandas as pd
import plotly.express as px
from datetime import datetime

# SQL query to get the required details
sql_query = '''
SELECT employees.EmployeeID, 
       DATEDIFF(CURDATE(), employees.HireDate) / 365 AS YearsAtCompany 
FROM employees;
'''

# Execute the SQL query
employee_data = execute_sql_query(sql_query)

# Ensure the dataframe is displayed correctly
show_to_user(employee_data)
","The input code calculates years at the company, not days, which differs from the request to calculate total days worked.",Base
Which products need reordering?,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;'

# Execute the SQL query
data = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(data)
","import pandas as pd

# Query to get products that need reordering
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND (UnitsInStock + UnitsOnOrder) <= ReorderLevel
""""""

# Execute the SQL query and retrieve the data
products_to_reorder = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_to_reorder)","The input code includes a condition for 'Discontinued = 0' and uses '(UnitsInStock + UnitsOnOrder) <= ReorderLevel' which adds 'UnitsOnOrder' in the calculation, whereas the reference only checks 'UnitsInStock <= ReorderLevel'.","import pandas as pd
import plotly.express as px

# SQL Query to find products that need reordering
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query
products_to_reorder = execute_sql_query(sql_query)

# Display the result
show_to_user(products_to_reorder)","The input code correctly retrieves products that need reordering by checking where 'UnitsInStock' is less than 'ReorderLevel'. Although the input code retrieves 'ProductID' in addition to 'ProductName', it still effectively answers the business analytic request of identifying products needing reordering. The logic aligns with the reference implementation despite the minor difference in the SQL query condition ('<' vs '<=').",Finetuned
How many products have a reorder level higher than 20?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS HighReorderProducts FROM products WHERE ReorderLevel > 20;""

# Execute the SQL query and get the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the count of high reorder products to the user
show_to_user(result_df.iloc[0, 0])","import pandas as pd

# SQL query to count the number of products with a reorder level higher than 20
sql_query = """"""
SELECT COUNT(*) AS ProductCount
FROM products
WHERE ReorderLevel > 20;
""""""

# Execute the SQL query and retrieve the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The evaluated code displays the entire DataFrame instead of just the count value, which doesn't match the reference implementation's functionality.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(ProductID) AS product_count FROM products WHERE ReorderLevel > 20;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the count from the dataframe assuming the column name is 'product_count'
product_count = result_df['product_count'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'product_count': [product_count]}))","The input code correctly counts the number of products with a reorder level greater than 20. The SQL queries in both implementations achieve the same result by counting entries in the 'products' table where 'ReorderLevel' is greater than 20. The output, while formatted differently, displays the correct result to the user.",Finetuned
Find the customers who have not placed any orders in the current year.,"# Importing necessary library
import pandas as pd

# SQL query to find customers who have not placed any orders in the current year
sql_query = '''
SELECT CustomerID 
FROM customers 
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID 
    FROM orders 
    WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
);'''

# Execute the SQL query
customers_no_orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_no_orders_df)
","import pandas as pd

# Define the SQL query to find customers who have not placed any orders in the current year
current_year = pd.Timestamp.now().year
sql_query = f""""""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID 
    FROM orders 
    WHERE YEAR(OrderDate) = {current_year}
) 
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code erroneously selects customers who placed orders at any time besides the current year, as it selects from the 'orders' table instead of the 'customers' table. The reference code correctly identifies customers who have made no orders in the current year by verifying presence in the 'customers' table.","import pandas as pd
import plotly.express as px

# Query to find customers who have not placed any orders in the current year
sql_query = '''
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o 
ON c.CustomerID = o.CustomerID 
AND extract(YEAR FROM o.OrderDate) = extract(YEAR FROM CURRENT_DATE) 
WHERE o.OrderID IS NULL;
'''

# Execute SQL query to retrieve data
customers_no_orders = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_no_orders)","The input code correctly identifies customers who have not placed any orders in the current year using a SQL LEFT JOIN and filtering for NULL values in the orders. It achieves the same outcome as the reference implementation, which uses a NOT IN clause to filter out customers with orders. Both approaches are valid and achieve the desired business analytic request.",Finetuned
Identify the top 5 customers who have incurred the highest total freight costs. Can you also include a bar chart to show this data?,"import plotly.express as px
import pandas as pd

# SQL Query to get the top 5 customers by total freight costs
sql_query = '''
SELECT CustomerID, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY CustomerID 
ORDER BY TotalFreight DESC 
LIMIT 5;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(result_df, x='CustomerID', y='TotalFreight', title='Top 5 Customers by Total Freight Costs', labels={'CustomerID': 'Customer ID', 'TotalFreight': 'Total Freight Cost'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to get total freight costs per customer and fetch top 5 customers
sql_query = '''
SELECT CustomerID, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY CustomerID
ORDER BY TotalFreight DESC
LIMIT 5
'''  

# Execute SQL query to retrieve data
customer_freight_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 customers with highest freight costs
fig = px.bar(customer_freight_data, x='CustomerID', y='TotalFreight',
             title='Top 5 Customers by Total Freight Costs',
             labels={'CustomerID': 'Customer ID', 'TotalFreight': 'Total Freight Cost'})

# Show the data and the bar chart to the user
show_to_user(customer_freight_data)
show_to_user(fig)","The input code fulfills the business analytic request by executing the correct SQL query to identify the top 5 customers by total freight costs, similar to the reference code. It also generates and displays a bar chart using Plotly to visualize the data, as required. The code includes an additional step to display the data frame, but it doesn't affect the successful completion of the request.","import plotly.express as px

# SQL query to get the top 5 customers with the highest total freight costs
sql_query = '''
SELECT CustomerID, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY CustomerID 
ORDER BY TotalFreight DESC 
LIMIT 5;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Rename columns for better clarity
df.columns = ['CustomerID', 'TotalFreight']

# Create a bar chart using plotly
fig = px.bar(df, x='CustomerID', y='TotalFreight', title='Top 5 Customers by Total Freight Cost', labels={'CustomerID': 'Customer ID', 'TotalFreight': 'Total Freight Cost'})

# Display the chart to the user
show_to_user(fig)

# Show the dataframe to the user as well, if needed
show_to_user(df)","The input code correctly retrieves the top 5 customers by total freight costs using a SQL query and displays the result as a bar chart using Plotly. Additionally, it displays the dataframe, which is an added feature not present in the reference code. However, this does not affect the correctness regarding the business request.",Base
How many units of each product were sold in the first quarter of 2023? Can you provide a bar chart to visualize this data?,"import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS units_sold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY products.ProductID
""""""

# Execute the SQL query and get the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(sales_data, x='ProductID', y='units_sold', title='Units Sold per Product in Q1 2023', labels={'ProductID': 'Product ID', 'units_sold': 'Units Sold'})

# Display the bar chart
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to get the total quantity sold for each product in Q1 2023
sql_query = """"""
SELECT [Order Details].ProductID, SUM([Order Details].Quantity) AS total_quantity_sold 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY [Order Details].ProductID
""""""

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the data
fig = px.bar(results_df, x='ProductID', y='total_quantity_sold', 
             title='Units Sold per Product in Q1 2023', 
             labels={'ProductID': 'Product ID', 'total_quantity_sold': 'Total Quantity Sold'})

# Show the bar chart to the user
show_to_user(fig)","The input code successfully addresses the business analytic request. It executes a SQL query to retrieve the total quantity of products sold in Q1 2023 and visualizes the data in a bar chart, similar to the reference implementation. The differences in column naming do not affect the correctness of the analysis.","import pandas as pd
import plotly.express as px

# SQL query to get total units sold for each product in the first quarter of 2023
sql_query = """"""
SELECT p.ProductID, SUM(od.Quantity) AS TotalUnitsSold 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY p.ProductID;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Plot the data using plotly
fig = px.bar(data, x='ProductID', y='TotalUnitsSold', title='Units Sold by Product in Q1 2023')

# Display the plot to the user
show_to_user(fig)","The input code correctly executes a SQL query to get the total units sold for each product in Q1 2023 and creates a bar chart using Plotly. It achieves the same outcome as the reference implementation, addressing the business analytic request effectively.",Base
How many orders were shipped via each shipping method in 2023? Please include a pie chart to represent this information.,"import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY ShipVia
""""""

# Execute the SQL query to retrieve the data
orders_df = execute_sql_query(sql_query)

# Create a pie chart using plotly
fig = px.pie(orders_df, names='ShipVia', values='OrderCount', title='Orders Shipped via Each Shipping Method in 2023')

# Display the pie chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the number of orders shipped via each shipping method in 2023
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY ShipVia
""""""

# Execute the SQL query and store the results
order_counts = execute_sql_query(sql_query)

# Create a pie chart using the results
fig = px.pie(order_counts, values='OrderCount', names='ShipVia', title='Orders Shipped by Method in 2023')

# Show the pie chart to the user
show_to_user(fig)",The input code correctly executes a SQL query to retrieve the number of orders shipped via each method in 2023 and creates a pie chart using Plotly to visualize the results. It follows the same logic as the reference implementation.,"import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ShipVia, COUNT(OrderID) AS OrderCount FROM orders WHERE YEAR(OrderDate) = 2023 GROUP BY ShipVia""

# Execute the SQL query to fetch data
orders_data = execute_sql_query(sql_query)

# Create a pie chart using plotly
fig = px.pie(orders_data, values='OrderCount', names='ShipVia', title='Orders Shipped via Each Shipping Method in 2023')

# Show the pie chart to the user
show_to_user(fig)","The input code correctly addresses the business analytic request. It uses a SQL query to count the number of orders for each shipping method in 2023, similar to the reference code. It creates a pie chart with Plotly and displays it using the 'show_to_user' function. The logic and outcome are consistent with the reference implementation.",Base
How many orders were placed each month in the current year? Provide a line graph to show the monthly order placements.,"import pandas as pd
import plotly.express as px

# SQL query to retrieve the required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY OrderMonth 
ORDER BY OrderMonth;
""""""

# Execute the SQL query and store the result in a DataFrame
order_data = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(order_data, x='OrderMonth', y='TotalOrders', title='Monthly Orders for the Current Year', labels={'OrderMonth': 'Month', 'TotalOrders': 'Number of Orders'})

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the current year
from datetime import datetime
current_year = datetime.now().year

# SQL query to get the number of orders placed each month in the current year
sql_query = f""""""
SELECT EXTRACT(MONTH FROM OrderDate) AS month, COUNT(OrderID) AS order_count 
FROM orders 
WHERE EXTRACT(YEAR FROM OrderDate) = {current_year} 
GROUP BY month 
ORDER BY month;
""""""

# Execute the SQL query
monthly_orders = execute_sql_query(sql_query)

# Create a line graph to show the monthly order placements
fig = px.line(monthly_orders, x='month', y='order_count',
              title='Monthly Orders in {current_year}',
              labels={'month': 'Month', 'order_count': 'Number of Orders'})

# Display the result to the user
show_to_user(fig)","The input Python code correctly retrieves the number of orders placed each month for the current year and visualizes this data as a line graph using Plotly. Although the method of extracting the month from the date differs from the reference code, both implementations achieve the same outcome.","import pandas as pd
import plotly.express as px

# SQL Query to get the number of orders placed each month in the current year
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, COUNT(*) AS OrderCount 
FROM orders 
WHERE EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
GROUP BY Month 
ORDER BY Month
""""""

# Execute the SQL query using the provided utility function
orders_df = execute_sql_query(sql_query)

# Create a line graph using Plotly express
fig = px.line(orders_df, x='Month', y='OrderCount', title='Monthly Orders for Current Year', labels={'Month': 'Month', 'OrderCount': 'Number of Orders'})

# Display the line graph to the user
show_to_user(fig)","The input code correctly calculates the number of orders placed each month in the current year. Although it uses a different format for extracting month and year, it achieves the same outcome by grouping and counting orders monthly. The line graph visualization using Plotly is also implemented correctly, matching the reference implementation's requirements.",Base
Which product had the highest average discount?,"import pandas as pd
# Define the SQL query to find the product with the highest average discount
sql_query = '''
SELECT ProductID, AVG(Discount) AS AvgDiscount
FROM [Order Details]
GROUP BY ProductID
ORDER BY AvgDiscount DESC
LIMIT 1;
'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
table_to_show = result_df
show_to_user(table_to_show)","import pandas as pd

# SQL query to calculate the average discount for each product
sql_query = '''
SELECT [Order Details].ProductID, AVG([Order Details].Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY [Order Details].ProductID
ORDER BY AverageDiscount DESC
LIMIT 1
'''  

# Execute the SQL query and retrieve the results
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code effectively addresses the business analytic request by querying the product with the highest average discount. It groups by ProductID, calculates the average discount, orders by the average in descending order, and limits the result to one, just like the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to find the product with the highest average discount
sql_query = '''
SELECT ProductID, AVG(Discount) AS AvgDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY AvgDiscount DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly executes the same SQL query as the reference code to find the product with the highest average discount. It also displays the result using the provided utility function. The inclusion of plotly is unnecessary, but it doesn't affect the correctness of the analysis.",Base
What percentage of total stock does each product contribute? Please illustrate this using a pie chart.,"import pandas as pd
import plotly.express as px

# SQL query to retrieve stock percentage data
sql_query = '''
SELECT p.ProductID, ROUND(p.UnitsInStock / (SELECT SUM(UnitsInStock) FROM products) * 100, 2) AS StockPercentage FROM products p;
'''

# Execute the query and get the data in a pandas dataframe
df = execute_sql_query(sql_query)

# Plot a pie chart using plotly
fig = px.pie(df, values='StockPercentage', names='ProductID', title='Percentage of Total Stock by Product')

# Show the pie chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Query to get total units in stock per product
sql_query = """"""
SELECT ProductID, ProductName, SUM(UnitsInStock) AS TotalUnitsInStock
FROM products
GROUP BY ProductID, ProductName
""""""

# Execute the SQL query to retrieve products data
products_df = execute_sql_query(sql_query)

# Calculate total stock across all products
total_stock = products_df['TotalUnitsInStock'].sum()

# Calculate percentage contribution for each product
products_df['PercentageContribution'] = (products_df['TotalUnitsInStock'] / total_stock) * 100

# Create a pie chart to illustrate the percentage contribution
fig = px.pie(products_df, names='ProductName', values='PercentageContribution',
             title='Percentage Contribution of Each Product to Total Stock')

# Show the pie chart to the user
show_to_user(fig)","The input code correctly calculates the percentage contribution of each product to the total stock and displays this using a pie chart. It achieves the same outcome as the reference implementation by calculating the percentages and visualizing them through Plotly, albeit with additional product names in the chart.","import plotly.express as px

# Define the SQL query to get each product's percentage of total stock
sql_query = '''
SELECT products.ProductName, 
       (products.UnitsInStock / (SELECT SUM(UnitsInStock) FROM products)) * 100 AS PercentOfTotalStock 
FROM products;
'''

# Execute the SQL query and fetch the data
products_df = execute_sql_query(sql_query)

# Create the pie chart using Plotly
fig = px.pie(products_df, names='ProductName', values='PercentOfTotalStock', title='Percentage of Total Stock per Product')

# Display the pie chart
show_to_user(fig)","The input code accurately computes the percentage of total stock for each product and visualizes it using a pie chart. It uses 'ProductName' instead of 'ProductID', which is acceptable since it addresses the business analytic request. Both codes achieve the desired outcome correctly.",Base
Which employee processed the highest number of orders last month? Can you include a bar chart to visualize this data?,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) 
AND MONTH(o.OrderDate) = MONTH(CURDATE()) - 1 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Assuming result_df contains columns ['EmployeeID', 'OrderCount']

# Bar chart visualization
fig = px.bar(result_df, x='EmployeeID', y='OrderCount', title='Top Employee by Order Count Last Month')

# Display the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve number of orders processed by each employee last month
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' 
AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE)
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OrderCount DESC
LIMIT 1
'''

# Execute the query and store the result in a DataFrame
employee_with_most_orders = execute_sql_query(sql_query)

# Print the employee with the most processed orders
print(employee_with_most_orders)

# Prepare data for visualization to include all employees' order counts for the chart
sql_query_all = '''
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' 
AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE) 
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OrderCount DESC
'''

# Execute the query for visualization
all_employee_order_counts = execute_sql_query(sql_query_all)

# Create a bar chart using Plotly
fig = px.bar(all_employee_order_counts, x='EmployeeName', y='OrderCount', 
             title='Number of Orders Processed by Employees Last Month', 
             labels={'EmployeeName': 'Employee', 'OrderCount': 'Order Count'})

# Show the result to the user
show_to_user(fig)","The input code effectively queries and determines which employee processed the highest number of orders last month, addressing the business analytic request. It also includes a bar chart visualization of order counts for all employees. It achieves the same outcome as the reference implementation even though it has additional information like employee names.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrdersCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
GROUP BY e.EmployeeID
ORDER BY OrdersCount DESC
LIMIT 1;
'''

# Execute the SQL query to get the employee with the highest number of orders
result_df = execute_sql_query(sql_query)

# Display the result
show_to_user(result_df)

# Prepare data for visualization: counting orders per employee
sql_query_full = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrdersCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
GROUP BY e.EmployeeID
ORDER BY OrdersCount DESC;
'''
result_full_df = execute_sql_query(sql_query_full)

# Create a bar chart using plotly
fig = px.bar(result_full_df, x='EmployeeID', y='OrdersCount', title='Number of Orders Processed by Employees Last Month')

# Show the bar chart to the user
show_to_user(fig)
```","The input code calculates the last 30 days instead of the previous month, which can lead to incorrect results. The reference implementation correctly checks for the previous calendar month.",Base
"Determine the month with the highest total sales, and visualize this information with a bar chart.","import pandas as pd
import plotly.express as px

# SQL query to get the monthly total sales
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as order_month, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as total_sales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY order_month 
ORDER BY total_sales DESC 
LIMIT 1;'''

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Ensure the DataFrame is not empty
if not df.empty:
    # Create a bar chart to visualize the total sales for the month with highest sales
    fig = px.bar(df, x='order_month', y='total_sales', title='Month with Highest Total Sales')

    # Display the visualization to the user
    show_to_user(fig)
else:
    print('No data available for the given query.')","import pandas as pd
import plotly.express as px

# SQL query to get total sales per month
sql_query = """"""
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM
    orders
JOIN
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY
    Month
ORDER BY
    TotalSales DESC
LIMIT 1
""""""

# Execute the SQL query
monthly_sales = execute_sql_query(sql_query)

# Get the month with the highest sales
date_with_highest_sales = monthly_sales.iloc[0]
highest_month = date_with_highest_sales['Month']
highest_sales = date_with_highest_sales['TotalSales']

# Prepare data for bar chart
bar_chart_data = monthly_sales.sort_values(by='Month')  # Sort by month for proper plotting

# Create a bar chart
fig = px.bar(bar_chart_data, x='Month', y='TotalSales',
             title='Total Sales per Month',
             labels={'Month': 'Month', 'TotalSales': 'Total Sales'})

# Show the bar chart to the user
show_to_user(fig)","The code creates a bar chart for all months instead of only for the month with the highest total sales. It sorts the data by month, which suggests it visualizes multiple months, not just the highest one.","import plotly.express as px

# SQL query to fetch the month with highest total sales
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Month 
ORDER BY TotalSales DESC 
LIMIT 1;
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Visualize the data with bar chart (even if it's just one bar)
fig = px.bar(result_df, x='Month', y='TotalSales', title='Month with Highest Total Sales', labels={'Month': 'Month', 'TotalSales': 'Total Sales ($)'})

# Show the visualization to the user
show_to_user(fig)","The evaluated code fulfills the business request by querying for the month with the highest sales and visualizing it with a bar chart, matching the reference implementation's outcome.",Finetuned
Identify the top 5 suppliers based on the total sales revenue. Provide a bar chart to illustrate this data.,"import pandas as pd
import plotly.express as px

# SQL query to get top 5 suppliers based on total sales revenue
sql_query = '''
SELECT p.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID, s.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(result_df, x='CompanyName', y='TotalRevenue', title='Top 5 Suppliers by Total Sales Revenue', labels={'CompanyName': 'Supplier', 'TotalRevenue': 'Total Sales Revenue'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue per supplier
sql_query = '''
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalSales DESC
LIMIT 5
'''  

# Execute the SQL query
suppliers_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 suppliers by total sales revenue
fig = px.bar(suppliers_sales_df,
             x='CompanyName',
             y='TotalSales',
             title='Top 5 Suppliers by Total Sales Revenue',
             labels={'CompanyName': 'Supplier Company Name', 'TotalSales': 'Total Sales Revenue'},
             color='TotalSales',
             text='TotalSales')
             
# Show the bar chart to the user
show_to_user(fig)  
","The input code correctly implements the requested task, retrieving the top 5 suppliers based on total sales revenue using a similar SQL query as the reference code. It then uses Plotly to create and display a bar chart illustrating this data. The modifications, such as additional joins, do not alter the correctness of the outcome.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to identify the top 5 suppliers based on total sales revenue
sql_query = '''
SELECT suppliers.SupplierID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.SupplierID 
ORDER BY TotalRevenue DESC 
LIMIT 5;
'''

# Execute the SQL query and retrieve data
result_df = execute_sql_query(sql_query)

# Generate the bar chart from the retrieved data
fig = px.bar(result_df, x='SupplierID', y='TotalRevenue', title='Top 5 Suppliers by Total Sales Revenue', labels={'SupplierID':'Supplier ID', 'TotalRevenue':'Total Revenue'})

# Display the figure
show_to_user(fig)","The input code does not include the 'CompanyName' from the 'suppliers' table, which is included in the reference implementation. This means that the resulting chart will lack the company names, displaying only SupplierID, which does not fully align with the business analytic request to identify suppliers by name.",Base
Which customer generated the highest lifetime value?,"import pandas as pd
import plotly.express as px

def get_highest_lifetime_value_customer():
    # Define SQL query to get customer with highest lifetime value
    sql_query = '''
    SELECT customers.CustomerID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * 
               (1 - [Order Details].Discount)) AS CustomerLifetimeValue 
    FROM customers 
    INNER JOIN orders ON customers.CustomerID = orders.CustomerID 
    INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    GROUP BY customers.CustomerID 
    ORDER BY CustomerLifetimeValue DESC 
    LIMIT 1;
    '''
    
    # Execute SQL query and retrieve the result as a pandas dataframe
    result_df = execute_sql_query(sql_query)
    
    # Display result to user
    show_to_user(result_df)

# Call the function
get_highest_lifetime_value_customer()
","import pandas as pd

# SQL query to calculate Customer Lifetime Value
sql_query = '''
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY LifetimeValue DESC
LIMIT 1
'''

# Execute the SQL query to get the customer with the highest Lifetime Value
lifetime_value_df = execute_sql_query(sql_query)

# Show results to user
show_to_user(lifetime_value_df)","The input code successfully calculates the customer with the highest lifetime value by summing the product of UnitPrice, Quantity, and (1 - Discount) for each order detail and grouping by CustomerID. It uses the same logic as the reference implementation, though it includes the CompanyName in the output, which does not affect the outcome. The ORDER BY and LIMIT clauses ensure only the top customer with the highest lifetime value is selected. Therefore, the input code meets the business analytic request effectively.","import pandas as pd
import plotly.express as px

# Define the SQL query to find the customer with the highest lifetime value
sql_query = '''
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS CustomerLifetimeValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY CustomerLifetimeValue DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Verify the result
if not result_df.empty:
    # Display the result to the user
    show_to_user(result_df)
else:
    show_to_user(pd.DataFrame({'Message': ['No data found']}))","The input code correctly implements the business analytic request. It constructs an appropriate SQL query to calculate and identify the customer with the highest lifetime value, executes it, and displays the result. The logic matches the reference implementation, ensuring that the outcome will be the same.",Base
How many employees live in each country? Can you provide a map or bar chart to visualize this information?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT Country, COUNT(EmployeeID) AS EmployeeCount FROM employees GROUP BY Country;'

# Execute the SQL query
employee_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of employees per country
fig = px.bar(employee_data, x='Country', y='EmployeeCount', title='Number of Employees per Country', labels={'EmployeeCount': 'Number of Employees'})

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Query to count employees by country
sql_query = """"""
SELECT Country, COUNT(EmployeeID) AS EmployeeCount
FROM employees
GROUP BY Country
""""""

# Step 2: Execute the SQL query
employee_counts = execute_sql_query(sql_query)

# Step 3: Create a bar chart to visualize the employee counts by country
fig = px.bar(employee_counts,
             x='Country',
             y='EmployeeCount',
             title='Number of Employees by Country',
             labels={'EmployeeCount': 'Number of Employees', 'Country': 'Country'})

# Step 4: Show the visualization to the user
show_to_user(fig)","The input Python code correctly executes the SQL query to count employees by country and visualizes the data using a Plotly bar chart. It matches the reference implementation in functionality, achieving the same outcome.","import pandas as pd
import plotly.express as px

# SQL query to get the number of employees living in each country
sql_query = ""SELECT Country, COUNT(*) AS EmployeeCount FROM employees GROUP BY Country""

# Execute the SQL query and fetch the data
employee_data = execute_sql_query(sql_query)

# Ensure the data is in the correct format
country_data = pd.DataFrame(employee_data).rename(columns={0: 'Country', 1: 'EmployeeCount'})

# Create a bar chart to visualize the number of employees living in each country
fig = px.bar(country_data, x='Country', y='EmployeeCount', title='Number of Employees by Country')

# Display the visualization to the user
show_to_user(fig)","The input code correctly executes the SQL query to count the number of employees per country. It uses a bar chart to visualize the data, which is consistent with the business requirement. Although it includes an extra step to rename columns in the DataFrame, this step does not affect the correctness of the outcome.",Base
Display the total sales revenue for the month of January 2023 with a visualization.,"import plotly.express as px
import pandas as pd

# SQL query to retrieve the total sales revenue for January 2023
sql_query = '''
    SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
    FROM orders 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    WHERE MONTH(OrderDate) = 1 AND YEAR(OrderDate) = 2023;
'''

# Execute the SQL query and get the result in a dataframe
result_df = execute_sql_query(sql_query)

total_sales = result_df['TotalSales'].iloc[0]

# Create a dataframe for visualization
vis_df = pd.DataFrame({'Month': ['January 2023'], 'Total Sales': [total_sales]})

# Create a bar chart using plotly
fig = px.bar(vis_df, x='Month', y='Total Sales', title='Total Sales Revenue for January 2023')

# Display the visualization
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue for January 2023
sql_query = '''
SELECT   
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales 
FROM   
    orders 
JOIN   
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE  
    orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
'''  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Creating a bar plot to visualize the total sales revenue
fig = px.bar(result_df, x=['January 2023'], y='Total_Sales', title='Total Sales Revenue for January 2023')

# Show the plot to the user
show_to_user(fig)","The input code correctly calculates the total sales revenue for January 2023 using an equivalent SQL query. Both the input and reference implementations produce the same result, and the visualization is correctly displayed using a bar chart.","import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a DataFrame for visualization
df_viz = pd.DataFrame({'Month': ['January 2023'], 'TotalSales': sales_data['TotalSales']})

# Generate a bar chart using Plotly
fig = px.bar(df_viz, x='Month', y='TotalSales', title='Total Sales Revenue for January 2023')

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the total sales for January 2023 and generates a visualization. Although the date filter is implemented with a different SQL condition, it achieves the same result as the reference code.",Base
Visualize the top 5 cities with the highest average shipping cost.,"import plotly.express as px

# SQL Query to get the required data
sql_query = '''SELECT ShipCity, AVG(Freight) AS AverageFreight FROM orders GROUP BY ShipCity ORDER BY AverageFreight DESC LIMIT 5;'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Create a bar plot to visualize the top 5 cities with the highest average shipping cost
fig = px.bar(result_df, x='ShipCity', y='AverageFreight', title='Top 5 Cities with Highest Average Shipping Cost', labels={'ShipCity': 'City', 'AverageFreight': 'Average Shipping Cost'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to get the average shipping cost per city
sql_query = '''
SELECT ShipCity, AVG(Freight) AS AvgShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AvgShippingCost DESC
LIMIT 5;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar plot to visualize the top 5 cities with the highest average shipping cost
fig = px.bar(result_df, x='ShipCity', y='AvgShippingCost',
             title='Top 5 Cities with Highest Average Shipping Cost',
             labels={'AvgShippingCost': 'Average Shipping Cost', 'ShipCity': 'City'})

# Show the resulting plot to the user
show_to_user(fig)","The input Python code fulfills the business analytic request by retrieving and visualizing the top 5 cities with the highest average shipping cost. The results from the SQL query and the plot created are consistent with the reference implementation, even though there are slight differences in variable names.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ShipCity, AVG(Freight) AS AvgShippingCost FROM orders GROUP BY ShipCity ORDER BY AvgShippingCost DESC LIMIT 5;'

# Execute the SQL query to get the DataFrame
result_df = execute_sql_query(sql_query)

# Rename columns to match the expected lowercased format
result_df.columns = result_df.columns.str.lower()

# Create a bar chart using Plotly
fig = px.bar(result_df, x='shipcity', y='avgshippingcost', title='Top 5 Cities with Highest Average Shipping Cost', labels={'shipcity': 'City', 'avgshippingcost': 'Average Shipping Cost'})

# Display the result to the user
show_to_user(fig)","The input code correctly executes the SQL query to retrieve the top 5 cities with the highest average shipping cost using `execute_sql_query`. It properly visualizes the data using a Plotly bar chart, with columns renamed to match the case expected in the plotting function. The key functionality aligns with the reference implementation, successfully addressing the business analytic request.",Base
Which products need to be reordered (units in stock less than reorder level)?,"import pandas as pd
import plotly.express as px

# SQL query to select products that need to be reordered
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query using the provided utility function
products_to_reorder_df = execute_sql_query(sql_query)

# Display the resulting DataFrame using the provided utility function
show_to_user(products_to_reorder_df)

# Add a check if the DataFrame is not empty before plotting
if not products_to_reorder_df.empty:
    # Additionally, we can visualize the data using a plotly bar chart
    fig = px.bar(products_to_reorder_df, x='ProductName', y='ProductID', title='Products Needing Reorder')
    
    # Show the plotly figure
    show_to_user(fig)
else:
    print('No products need to be reordered.')","import pandas as pd

# SQL query to find products that need to be reordered
sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
'''  

# Execute the SQL query using the provided utility function
products_to_reorder = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(products_to_reorder)","The input code filters out discontinued products with 'Discontinued = 0', which is not accounted for in the reference code. This may lead to different results.","import pandas as pd
import plotly.express as px

def analysis_and_visualization():
    # Define the SQL query
    sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;'
    
    # Execute the SQL query
    products_df = execute_sql_query(sql_query)
    
    # Check the resulting dataframe and visualize it
    if not products_df.empty:
        fig = px.bar(products_df, x='ProductName', title='Products to Reorder')
        # Show to user
        show_to_user(fig)
    else:
        show_to_user('No products need to be reordered.') 

# Call the function
analysis_and_visualization()","The evaluated code does not include 'ProductID' in the SQL query, which is a key part of the reference implementation for identifying which specific products need to be reordered.",None
Visualize the top 5 products by sales revenue.,"import plotly.express as px
import pandas as pd

# The SQL query to fetch the top 5 products by sales revenue
sql_query = (
    ""SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales ""
    ""FROM [Order Details] ""
    ""GROUP BY ProductID ""
    ""ORDER BY TotalSales DESC ""
    ""LIMIT 5;""
)

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty before proceeding with visualization
if not df.empty:
    # Create a bar chart using plotly express
    fig = px.bar(df, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue',
                 labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales Revenue'})

    # Display the figure to the user
    show_to_user(fig)
else:
    # Handle the case where the dataframe is empty
    print('No data available to display.')","import pandas as pd
import plotly.express as px

# SQL query to retrieve top 5 products by sales revenue
sql_query = '''
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalSales DESC
LIMIT 5;
'''

# Execute the SQL query and store the result in a DataFrame
top_products = execute_sql_query(sql_query)

# Visualize the top 5 products by sales revenue
fig = px.bar(top_products, x='ProductID', y='TotalSales', title='Top 5 Products by Sales Revenue')
show_to_user(fig)","The code correctly retrieves the top 5 products by sales revenue using an SQL query, visualizes the data with a bar chart using Plotly, and displays the chart with the utility function. Although it uses a JOIN with the 'orders' table, this doesn't affect the result, assuming 'OrderID' is used correctly. The purpose of the JOIN is not clear, but it doesn't alter the final output.","import pandas as pd
import plotly.express as px

# SQL query to fetch top 5 products by sales revenue
sql_query = '''
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS SalesRevenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID 
ORDER BY SalesRevenue DESC 
LIMIT 5;'''

# Execute the SQL query and get the data
sales_data = execute_sql_query(sql_query)

# visualization
fig = px.bar(sales_data, x='ProductID', y='SalesRevenue', title='Top 5 Products by Sales Revenue', labels={'ProductID': 'Product ID', 'SalesRevenue': 'Sales Revenue'})

# Display the bar chart
show_to_user(fig)","The input code correctly implements the business analytic request. It fetches the top 5 products by sales revenue, performs the necessary joins, and creates a bar chart using Plotly Express to visualize the data. The output matches the expected outcome of the reference implementation.",Base
Visualize the correlation between employee hire date and performance.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, employees.HireDate, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, employees.HireDate 
ORDER BY employees.HireDate;
'''

# Execute the SQL query and get the result as a pandas dataframe
employee_sales_df = execute_sql_query(sql_query)

# Convert HireDate to datetime format
employee_sales_df['HireDate'] = pd.to_datetime(employee_sales_df['HireDate'])

# Visualize the correlation between hire date and total sales
fig = px.scatter(employee_sales_df, x='HireDate', y='TotalSales',
 title='Correlation between Employee Hire Date and Performance',
 labels={'HireDate': 'Hire Date', 'TotalSales': 'Total Sales'},
 trendline='ols')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: SQL query to fetch the required data
sql_query = '''
SELECT e.HireDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.HireDate
'''

# Step 2: Execute the SQL query
result_df = execute_sql_query(sql_query)

# Step 3: Visualize the correlation using plotly
fig = px.scatter(result_df, x='HireDate', y='TotalSales',
                 title='Correlation between Employee Hire Date and Performance (Total Sales)',
                 labels={'HireDate': 'Hire Date', 'TotalSales': 'Total Sales'})

# Step 4: Show the figure to user
show_to_user(fig)","The input code groups by HireDate, which can lead to incorrect aggregation. The reference code groups by EmployeeID and HireDate, ensuring each employee's sales are considered separately. The input might aggregate multiple employees' sales incorrectly if they share the same hire date.","
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, e.HireDate, d.Performance
FROM employees e
JOIN employee_performance d ON e.EmployeeID = d.EmployeeID;
'''

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Convert the 'HireDate' to datetime format if it's not already
data['HireDate'] = pd.to_datetime(data['HireDate'])

# Create a scatter plot to visualize the correlation
fig = px.scatter(data, x='HireDate', y='Performance', trendline='ols', title='Correlation between Employee Hire Date and Performance')

# Show the plot to the user
show_to_user(fig)","The input code evaluates a different metric ('Performance') from a different table ('employee_performance'), rather than calculating 'TotalSales' to measure performance as in the reference code. It doesn't align with the reference implementation's approach to determining employee performance.",None
How many new customers were acquired in May 2023?,"import pandas as pd

# Step 1: Define the SQL query to get new customers acquired in May 2023
sql_query = '''
SELECT COUNT(DISTINCT customers.CustomerID) AS new_customers
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
WHERE orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
'''

# Step 2: Execute the SQL query
new_customers_df = execute_sql_query(sql_query)

# Step 3: Show the result to the user
show_to_user(new_customers_df)","import pandas as pd

# SQL query to count new customers acquired in May 2023
sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS new_customers
FROM orders
WHERE OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
""""""

# Execute the query
new_customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(new_customers_df)","The input code queries 'orders' directly for CustomerID without considering if these are new customers. It doesn't verify if CustomerID matches any in 'customers', lacking a correct join between 'customers' and 'orders' as seen in the reference code.","import pandas as pd

# Define the SQL query to count new customers acquired in May 2023
sql_query = ""SELECT COUNT(DISTINCT CustomerID) AS NewCustomers FROM orders WHERE OrderDate BETWEEN '2023-05-01' AND '2023-05-31';""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code only considers the 'orders' table to count new customers, whereas the reference code joins 'customers' and 'orders' to ensure all customers with orders in May 2023 are counted correctly.",None
Which suppliers provide products that are currently in stock?,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = 'SELECT DISTINCT SupplierID FROM products WHERE UnitsInStock > 0;'

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Optionally, display the raw results to the user
show_to_user(result_df)

# If you would like to visualize the data further, e.g., a bar plot of supplier counts
# Since we only have distinct SupplierID and not their counts, we just visualize SupplierID count itself
supplier_counts = result_df['SupplierID'].value_counts().reset_index()
supplier_counts.columns = ['SupplierID', 'Count']

# Create a bar plot
fig = px.bar(supplier_counts, x='SupplierID', y='Count', title='Number of In-Stock Products by Supplier')

# Show the plot to the user
show_to_user(fig)
","import pandas as pd

# SQL query to retrieve suppliers providing products that are currently in stock
sql_query = '''
SELECT p.SupplierID, p.ProductName, p.UnitsInStock
FROM products AS p
WHERE p.UnitsInStock > 0
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly retrieves and displays suppliers with products currently in stock by executing a SQL query that filters for products with 'UnitsInStock > 0'. Although it includes additional columns 'ProductName' and 'UnitsInStock' in the query, it still effectively answers the business question by identifying relevant 'SupplierID's. The output meets the requirement without necessitating a visualization.","Here's the complete Python code to retrieve the suppliers providing products that are currently in stock.

### Step 1: Define the SQL Query
The SQL query to retrieve the suppliers providing products that are in stock is as follows:

```sql
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.UnitsInStock > 0;
```

### Step 2: Execute the Query
This query is executed using the provided utility function `execute_sql_query(sql_query)`. The result is expected to be a DataFrame.

### Step 3: Visualize the Result
Finally, we will use the `show_to_user(data)` utility function to display the retrieved data to the user.

### Complete Code:
Here's the complete code that performs all the necessary steps.

```python
# Import necessary libraries
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.UnitsInStock > 0;
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```

### Important Notes:
- Ensure that the utilities `execute_sql_query` and `show_to_user` are correctly implemented and imported.
- This code assumes that the environment is set up for running the SQL query and displaying the result correctly (e.g., within a Jupyter notebook or similar).","The input code correctly retrieves suppliers providing in-stock products using a SQL query with JOIN, as compared to the reference, which only selects SupplierID from products table. Both result in identifying suppliers with in-stock products, fulfilling the business request.",Base
Visualize how many employees are there in each country.,"import plotly.express as px

# Define the SQL query to get the number of employees per country
sql_query = ""SELECT Country, COUNT(*) AS NumEmployees FROM employees GROUP BY Country;""

# Execute the SQL query and get the data in a pandas dataframe
employee_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly Express
fig = px.bar(employee_data, x='Country', y='NumEmployees', title='Number of Employees in Each Country')

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to count the number of employees in each country
sql_query = """"""
SELECT Country, COUNT(EmployeeID) as EmployeeCount
FROM employees
GROUP BY Country
""""""

# Execute the SQL query and get the data in a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the employee count by country
fig = px.bar(df, x='Country', y='EmployeeCount', title='Number of Employees in Each Country')

# Show the figure to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by querying the number of employees per country and visualizing the results using a bar chart. The key logic of counting employees grouped by country and visualizing it with Plotly is consistent with the reference implementation. The output will display the same analysis, despite the slight difference in column naming in the SQL query ('EmployeeID' vs '*') and result ('EmployeeCount' vs 'NumEmployees').","import pandas as pd
import plotly.express as px

# Step 1: Run the SQL query to get the employee count per country
sql_query = '''
SELECT Country, COUNT(*) AS NumberOfEmployees
FROM employees
GROUP BY Country;
'''

# Execute the SQL query
employees_df = execute_sql_query(sql_query)

# Step 2: Create a bar chart visualization using plotly
fig = px.bar(employees_df, x='Country', y='NumberOfEmployees', title='Number of Employees per Country')

# Step 3: Display the visualization to the user
show_to_user(fig)","The input code correctly executes the SQL query to retrieve the number of employees per country and uses Plotly to create a bar chart visualization. It then displays the chart to the user. This matches the intended functionality of the reference implementation, fulfilling the business analytic request.",Base
Visualize the average fulfillment time for orders by month.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, AVG(DATEDIFF(DAY, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY EXTRACT(MONTH FROM OrderDate)
""""""

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Create a bar plot of the average fulfillment time by month
fig = px.bar(orders_df, x='Month', y='AvgFulfillmentTime', title='Average Fulfillment Time by Month', 
             labels={'Month': 'Month', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to compute the average order fulfillment time by month
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS Avg_Fulfillment_Time
FROM 
    orders 
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute SQL query and retrieve the data
fulfillment_data = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.line(fulfillment_data, x='Month', y='Avg_Fulfillment_Time', 
              title='Average Order Fulfillment Time by Month',
              labels={'Avg_Fulfillment_Time': 'Average Fulfillment Time (Days)', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly visualizes the average fulfillment time by month. The main difference from the reference is the use of a line plot instead of a bar plot. The SQL query uses DATE_FORMAT to extract month and year, which is valid and groups orders similarly for visualization. Both codes achieve the same outcome.","import plotly.express as px
import pandas as pd

# Define the SQL query
db_query = """"""
SELECT DATE_PART('month', OrderDate) AS Month, 
       AVG(DATE_PART('day', (ShippedDate - OrderDate))) AS AvgFulfillmentTime
FROM orders
GROUP BY Month
ORDER BY Month
""""""

# Execute the SQL query
result_df = execute_sql_query(db_query)

# Visualize the data using Plotly
fig = px.line(result_df, x='Month', y='AvgFulfillmentTime', 
              title='Average Fulfillment Time for Orders by Month', 
              labels={""Month"": ""Month"", ""AvgFulfillmentTime"": ""Average Fulfillment Time (days)""})

# Display the visualization
show_to_user(fig)","The input code satisfies the business analytic request by visualizing average fulfillment time by month. Despite differences in SQL syntax (using DATE_PART vs. EXTRACT) and visualization type (line plot vs. bar plot), the outcome aligns with the reference.",Base
How many days on average does it take to fulfill an order?,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the average fulfillment time
sql_query = '''
SELECT AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
FROM orders
'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# If there is no column named 'AvgFulfillmentTime', rename it.
if 'AvgFulfillmentTime' not in result_df.columns:
    result_df.columns = ['AvgFulfillmentTime']

# Display the result to the user
show_to_user(result_df)
","import pandas as pd

# SQL query to calculate the average order fulfillment time
sql_query = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL
""""""  

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code uses 'AVG(DATEDIFF(ShippedDate, OrderDate))', but DATEDIFF should be 'DATEDIFF(day, OrderDate, ShippedDate)' to match the reference implementation. The SQL function DATEDIFF requires specifying the unit of time first, e.g., 'day'.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime FROM orders;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Since the result of the query will have one row with one column, we can directly extract that value
avg_fulfillment_time = result_df.iloc[0, 0]

# Convert the average fulfillment time into a DataFrame for display
avg_fulfillment_time_df = pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]})

# Display the result to the user
show_to_user(avg_fulfillment_time_df)","The input code uses a SQL query with DATEDIFF parameters reversed (ShippedDate, OrderDate) compared to the reference code (OrderDate, ShippedDate). This results in a negative average duration, differing from the intended calculation of days taken to fulfill an order.",None
What is the average discount applied per product?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];'

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the average discount per product
sql_query = '''
SELECT ProductID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY ProductID
'''

# Execute the SQL query
average_discount_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_discount_df)","The input code calculates the average discount per product, while the business request is to find the overall average discount applied per product, matching the reference implementation which calculates a single average discount value.","import pandas as pd
import plotly.express as px

# Function to execute SQL query
sql_query = ""SELECT ProductID, AVG(Discount) AS AverageDiscount FROM [Order Details] GROUP BY ProductID;""
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optional: Plotting the average discount per product
fig = px.bar(result_df, x='ProductID', y='AverageDiscount', title='Average Discount per Product', labels={'ProductID': 'Product ID', 'AverageDiscount': 'Average Discount'})

# Show the plotly figure to the user
show_to_user(fig)
","The input code calculates the average discount per ProductID by grouping, while the reference code calculates the average discount across all products without grouping. They achieve different outcomes.",None
Visualize which suppliers have supplied the most products.,"import plotly.express as px

# SQL query
sql_query = '''
SELECT s.SupplierID, COUNT(p.ProductID) AS TotalProductsSupplied 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID 
ORDER BY TotalProductsSupplied DESC;
'''

# Execute the SQL query and get the data
suppliers_df = execute_sql_query(sql_query)

# Ensure that the columns are correctly named and any potential issues with the data are resolved
df.columns = [col.strip() for col in df.columns]
# Create a bar chart to visualize the result
fig = px.bar(suppliers_df, x='SupplierID', y='TotalProductsSupplied',
             title='Suppliers with Most Products Supplied',
             labels={'SupplierID': 'Supplier ID', 'TotalProductsSupplied': 'Total Products Supplied'},
             template='plotly_dark')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the count of products supplied by each supplier
sql_query = '''
SELECT SupplierID, COUNT(ProductID) AS ProductCount 
FROM products 
GROUP BY SupplierID 
ORDER BY ProductCount DESC
'''  

# Execute the SQL query and get the results in a DataFrame
df_suppliers = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of products supplied by each supplier
fig = px.bar(df_suppliers, x='SupplierID', y='ProductCount',
             title='Number of Products Supplied by Each Supplier',
             labels={'SupplierID': 'Supplier ID', 'ProductCount': 'Number of Products Supplied'})

# Show the visualization to the user
show_to_user(fig)","The evaluated code does not correctly join the 'suppliers' table with the 'products' table, potentially leading to inaccurate counts of products supplied by each supplier. It only counts products in the 'products' table without considering the 'suppliers' table, which may exclude suppliers with no associated products.","import plotly.express as px

# Define the SQL query
sql_query = ""SELECT SupplierID, COUNT(ProductID) AS ProductCount FROM products GROUP BY SupplierID ORDER BY ProductCount DESC;""

# Execute the query to retrieve the data
supplier_data = execute_sql_query(sql_query)

# Create a bar chart to visualize which suppliers have supplied the most products
fig = px.bar(supplier_data, x='SupplierID', y='ProductCount', title='Number of Products Supplied by Each Supplier', labels={'SupplierID': 'Supplier ID', 'ProductCount': 'Number of Products'})

# Show the plot to the user
show_to_user(fig)","The input code does not join the 'suppliers' and 'products' tables, so it cannot determine which suppliers supplied the most products. The SQL query only considers the 'products' table rather than relating it to specific suppliers as in the reference.",None
Visualize which regions have the highest on-time delivery rates.,"import plotly.express as px
import pandas as pd

# SQL query to get the on-time delivery rates by region
sql_query = """"""
SELECT ShipRegion, (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID)) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the on-time delivery rates by region
fig = px.bar(df, x='ShipRegion', y='OnTimeDeliveryRate', title='On-Time Delivery Rates by Region', 
             labels={'ShipRegion': 'Region', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'}, 
             template='plotly_white')

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rates by region
sql_query = '''
SELECT 
    ShipRegion,
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeOrders,
    (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID)) * 100 AS OnTimeDeliveryRate
FROM 
    orders
GROUP BY 
    ShipRegion
ORDER BY 
    OnTimeDeliveryRate DESC;
'''  

# Execute the SQL query and load the data into a DataFrame
on_time_delivery_df = execute_sql_query(sql_query)

# Visualization of on-time delivery rates by region
fig = px.bar(on_time_delivery_df, 
             x='ShipRegion', 
             y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rates by Region', 
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'ShipRegion': 'Region'}, 
             color='OnTimeDeliveryRate', 
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the figure to the user
show_to_user(fig)","The input code accurately calculates on-time delivery rates by counting on-time orders and total orders, then calculates the percentage. It then visualizes the data using a Plotly bar chart with a color scale, fulfilling the business analytic request. The outcome matches the reference implementation, even though the visualization styling differs.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipRegion, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(*)) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OnTimeDeliveryRate DESC
'''

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the on-time delivery rates by region
fig = px.bar(orders_df, x='ShipRegion', y='OnTimeDeliveryRate',
             labels={'ShipRegion': 'Region', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'},
             title='On-Time Delivery Rates by Region')

# Display the chart to the user
show_to_user(fig)","The input code correctly calculates the on-time delivery rate by region using a SQL query. It creates a bar chart similar to the reference implementation, achieving the goal of visualizing which regions have the highest on-time delivery rates. The slight difference in the COUNT(*) function for the total count does not affect the result as both correctly compute the on-time rate. Overall, it meets the business analytic request.",Base
How many orders were handled by employees who were hired in the year 2020?,"import pandas as pd
import plotly.express as px

# SQL Query to get the number of orders by employees hired in 2020
total_orders_query = '''
SELECT COUNT(orders.OrderID) AS TotalOrders 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE YEAR(HireDate) = 2020;
'''

# Execute the query and store the result in a dataframe
df_total_orders = execute_sql_query(total_orders_query)

# Assuming the result is a single row with a single column
# We can extract the total orders and print it
if not df_total_orders.empty:
    total_orders = df_total_orders.iloc[0]['TotalOrders']
    print(f'Total Orders handled by employees hired in 2020: {total_orders}')
else:
    print('No orders found for employees hired in 2020.')

# Display the result to the user
show_to_user(df_total_orders)","import pandas as pd

# SQL query to count orders handled by employees hired in 2020
sql_query = '''
SELECT COUNT(o.OrderID) AS TotalOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE YEAR(e.HireDate) = 2020
'''

# Execute the SQL query and fetch the data
order_count_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(order_count_df)","The input code correctly constructs and executes the SQL query to count orders handled by employees hired in 2020. It uses the same logic as the reference implementation to join employees and orders on EmployeeID and filters by YEAR(HireDate) = 2020. The result is stored in a DataFrame and displayed using the show_to_user function, achieving the same outcome as the reference.","
import pandas as pd
import plotly.express as px

# Define the SQL query as a string
sql_query = '''
SELECT COUNT(*) AS OrdersCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE employees.HireDate BETWEEN '2020-01-01' AND '2020-12-31';
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
```","Both code implementations successfully calculate the number of orders handled by employees hired in 2020. The input code uses a SQL query with a BETWEEN clause for the date range in 2020, while the reference code uses the YEAR function, but both strategies achieve the same result. The slight difference in column naming ('OrdersCount' instead of 'TotalOrders') is acceptable as per the requirements.",Base
Visualize the average discount applied to products per month.,"import pandas as pd
import plotly.express as px

# SQL Query to fetch required data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, AVG(Discount) AS AverageDiscount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY month;
""""""

# Execute the SQL query
dataframe = execute_sql_query(sql_query)

# Convert month column to datetime
dataframe['month'] = pd.to_datetime(dataframe['month'], format='%Y-%m')
dataframe.sort_values('month', inplace=True)

# Visualize the data using plotly
fig = px.line(dataframe, x='month', y='AverageDiscount', title='Average Discount per Month', labels={'month': 'Month', 'AverageDiscount': 'Average Discount'})

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Create the SQL query to calculate the average discount per month
sql_query = '''
SELECT
    DATE_TRUNC('month', o.OrderDate) AS month,
    AVG(od.Discount) AS average_discount
FROM
    orders o
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY
    month
ORDER BY
    month;
'''

# Step 2: Execute the SQL query
average_discount_df = execute_sql_query(sql_query)

# Step 3: Visualize the average discount applied to products per month using Plotly
fig = px.line(average_discount_df, x='month', y='average_discount',
              title='Average Discount Applied to Products per Month',
              labels={'month': 'Month', 'average_discount': 'Average Discount'})

# Step 4: Show the visualization to the user
show_to_user(fig)","The evaluated code correctly calculates the average discount per month using a similar SQL query to the reference implementation. Both implementations prepare a dataframe and use Plotly to create a line plot, showing the average discount per month. The output effectively answers the business request, despite minor differences such as SQL syntax specifics and column aliasing.","import plotly.express as px

# Define the SQL query
sql_query = '''
    SELECT DATE_FORMAT(O.OrderDate, '%Y-%m') AS Month, 
           AVG(OD.Discount) AS AverageDiscount 
    FROM orders O 
    JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
    CALL monthly_sales 
    GROUP BY Month
'''

# Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Ensure 'Month' is treated as a datetime type for better plotting
sales_data['Month'] = pd.to_datetime(sales_data['Month'], format='%Y-%m')

# Generate the plot using plotly
fig = px.line(sales_data, x='Month', y='AverageDiscount', title='Average Discount per Month')

# Display the plot
show_to_user(fig)
","The input code includes an unnecessary 'CALL monthly_sales' in the SQL query, which is not present in the reference implementation.",Base
What is the average time between order date and required date?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT DATEDIFF(RequiredDate, OrderDate) AS LeadTime FROM orders;'

# Execute the SQL query to retrieve the lead times
lead_times_df = execute_sql_query(sql_query)

# Calculate the average lead time
average_lead_time = lead_times_df['LeadTime'].mean()

# Create a DataFrame to display the average lead time
average_lead_time_df = pd.DataFrame({'AverageLeadTime': [average_lead_time]})

# Display the average lead time to the user
show_to_user(average_lead_time_df)","import pandas as pd

# SQL query to retrieve the order data needed for analysis
sql_query = """"""
SELECT OrderDate, RequiredDate
FROM orders
""""""

# Execute the SQL query and retrieve the data
orders_data = execute_sql_query(sql_query)

# Convert the 'OrderDate' and 'RequiredDate' columns to datetime type
date_columns = ['OrderDate', 'RequiredDate']
for col in date_columns:
    orders_data[col] = pd.to_datetime(orders_data[col])

# Calculate the time difference between OrderDate and RequiredDate
orders_data['TimeDifference'] = (orders_data['RequiredDate'] - orders_data['OrderDate']).dt.days

# Calculate the average time difference
average_time_difference = orders_data['TimeDifference'].mean()

# Create a DataFrame to show the result
result_df = pd.DataFrame({'AverageTimeDifference (days)': [average_time_difference]})

# Display the result to the user
show_to_user(result_df)","The input code correctly calculates the average time between order date and required date by computing the difference in days and then taking the mean, which matches the reference implementation's outcome.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(DATEDIFF(RequiredDate, OrderDate)) AS AvgOrderTime FROM orders;'

# Execute the SQL query to get the data
order_data_df = execute_sql_query(sql_query)

# Extract the average order time value
avg_order_time = order_data_df['AvgOrderTime'][0]

# Convert the result to a DataFrame for display
result_df = pd.DataFrame({'Average Order Time': [avg_order_time]})

# Display the result to the user
show_to_user(result_df)","The input code correctly calculates the average time between the order date and the required date by using the AVG function in the SQL query. It retrieves the average directly from the database and displays it. Although the implementation differs from the reference code, it effectively answers the business analytic request and achieves the same outcome.",Base
How many products have a stock level below their reorder level?,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to retrieve products with stock level below reorder level
sql_query = 'SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df[['ProductName']])","import pandas as pd

# SQL query to retrieve products with stock level below reorder level
sql_query = '''
SELECT COUNT(*) as Products_Below_Reorder_Level 
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
'''  

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code counts the number of products with stock levels below their reorder level and also filters out discontinued products. The reference implementation does not include a filter for discontinued products, which may result in a different count.","import pandas as pd
import plotly.express as px

# Execute the SQL query to retrieve product data.
sql_query = 'SELECT ProductID FROM products WHERE UnitsInStock < ReorderLevel;'
products_below_reorder_level_df = execute_sql_query(sql_query)

# Count how many products have a stock level below their reorder level.
stock_below_reorder_level_count = products_below_reorder_level_df.shape[0]

# Show the result to the user.
result_df = pd.DataFrame({'Count': [stock_below_reorder_level_count]})
show_to_user(result_df)","The input code fulfills the business analytic request by counting the number of products with stock levels below their reorder levels. The reference code retrieves the product names that meet this condition, whereas the input code counts these products, which effectively addresses the same business question. Both implementations lead to understanding the stock situation relative to reorder levels, complying with the business request.",Finetuned
Which orders were delayed more than five days past the required date?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT OrderID FROM orders WHERE DATEDIFF(ShippedDate, RequiredDate) > 5;""

# Execute the query and get the results in a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(orders_df)","import pandas as pd

# SQL query to retrieve orders that were delayed more than five days past the required date
sql_query = """"""
SELECT * FROM orders 
WHERE DATEDIFF(ShippedDate, RequiredDate) > 5
""""""

# Execute the SQL query and retrieve the data
delayed_orders = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(delayed_orders)","The input code correctly executes a SQL query to determine orders that were delayed more than five days past the required date using the DATEDIFF function, which aligns with the business request. The only difference from the reference code is that it selects all columns instead of just the OrderID, which still satisfies the request's requirement to identify delayed orders.","import pandas as pd
from datetime import datetime
import plotly.express as px

def main():
    # SQL Query to find orders delayed more than five days past the required date
    sql_query = ""SELECT * FROM orders WHERE DATEDIFF(ShippedDate, RequiredDate) > 5;""
    
    # Execute the SQL query and retrieve the result
    df = execute_sql_query(sql_query)
    
    # Display the data to the user
    show_to_user(df)
    
    # Optionally, visualize the number of delayed orders over time
    if not df.empty:
        df['ShippedDate'] = pd.to_datetime(df['ShippedDate'])
        df.sort_values(by='ShippedDate', inplace=True)  # Sort data by ShippedDate for better visualization
        fig = px.histogram(df, x='ShippedDate', nbins=20, title='Number of Delayed Orders Over Time')
        show_to_user(fig)

if __name__ == ""__main__"":
    main()
","The input code correctly retrieves orders with a delay of more than five days past the required date using a SQL query similar to the reference implementation. It uses the `DATEDIFF` function and selects all columns instead of just `OrderID`, which is still valid for addressing the business request. Additionally, it visualizes the data, which is an extra but not conflicting feature.",Base
What is the average time taken to fulfill an order?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT AVG(DATE_PART('day', ShippedDate::timestamp - OrderDate::timestamp)) AS AverageFulfillmentTime FROM orders;""

# Execute the SQL query to get the result
result_df = execute_sql_query(sql_query)

# Extract the average fulfillment time from the result
average_fulfillment_time = result_df['AverageFulfillmentTime'][0]

# Create a DataFrame to display the result
average_fulfillment_df = pd.DataFrame({'AverageFulfillmentTime': [average_fulfillment_time]})

# Display the result to the user
show_to_user(average_fulfillment_df)
","import pandas as pd

# Define the SQL query to calculate the average order fulfillment time
sql_query = '''
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders
WHERE ShippedDate IS NOT NULL
'''

# Execute the SQL query to retrieve the data
average_fulfillment_time_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_fulfillment_time_df)","The input code correctly calculates the average fulfillment time using a SQL query. It uses DATEDIFF to calculate the difference between the ShippedDate and OrderDate, ensuring ShippedDate is not null, which aligns with the given reference implementation that calculates the average time between OrderDate and ShippedDate.","
import pandas as pd
import plotly.express as px

# SQL query to get average order fulfillment time
sql_query = 'SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageOrderFulfillmentTime FROM orders;'

# Execute the SQL query
order_fulfillment_df = execute_sql_query(sql_query)

# Since the result is a single value, we can extract that value directly
average_fulfillment_time = order_fulfillment_df.at[0, 'AverageOrderFulfillmentTime']

# Display the average fulfillment time to the user
message_df = pd.DataFrame({'AverageOrderFulfillmentTime': [average_fulfillment_time]})
show_to_user(message_df)
","The input code correctly calculates the average fulfillment time using the SQL query, retrieves the result using a similar process as the reference code, and displays it to the user. The use of DATEDIFF in the SQL query is an equivalent approach to DATE_PART and the difference in column names does not impact the correctness of the result.",Base
Calculate the total value of current inventory (UnitPrice * UnitsInStock) for all products.,"import pandas as pd

# SQL query to calculate the total value of current inventory
sql_query = 'SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue FROM products;'

# Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Ensure df is not empty and has the expected column
if not df.empty and 'TotalInventoryValue' in df.columns:
    # Extract the total inventory value from the dataframe
    total_inventory_value = df['TotalInventoryValue'].iloc[0]

    # Convert the result to a dataframe for display
    result_df = pd.DataFrame({'TotalInventoryValue': [total_inventory_value]})

    # Display the result to the user
    show_to_user(result_df)
else:
    # Handle the case when the query results are not as expected
    show_to_user(pd.DataFrame({'Error': ['No data retrieved or unexpected result format']}))","import pandas as pd

# SQL query to calculate total inventory value
sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query
inventory_value_df = execute_sql_query(sql_query)

# Extract the total inventory value from the dataframe
total_inventory_value = inventory_value_df['TotalInventoryValue'].iloc[0]

# Display the total inventory value to the user
show_to_user(pd.DataFrame({'Total Inventory Value': [total_inventory_value]}))","The input code filters products that are not discontinued (Discontinued = 0), which may result in a different total inventory value compared to the reference implementation that includes all products.","import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SUM(UnitPrice * UnitsInStock) AS TotalInventoryValue 
FROM products;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the single value from the result
TotalInventoryValue = result_df.iloc[0, 0]

# Display the result to the user
show_to_user(pd.DataFrame({'TotalInventoryValue': [TotalInventoryValue]}))","The evaluated Python code correctly calculates the total inventory value in the same way as the reference implementation. It executes the same SQL query, extracts the result, and displays it using the provided utility functions.",Finetuned
What is the average lead time for each supplier? (Include a visualization to illustrate the average lead time for comparison among suppliers.),"import plotly.express as px
import pandas as pd

# SQL query to retrieve the required data
sql_query = '''
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY products.SupplierID;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the data is available and correct
if df.empty or 'SupplierID' not in df.columns or 'AverageLeadTime' not in df.columns:
    raise ValueError('Data retrieval failed or data format is incorrect')

# Visualization of average lead time for each supplier
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', title='Average Lead Time for Each Supplier',
             labels={'SupplierID': 'Supplier ID', 'AverageLeadTime': 'Average Lead Time (days)'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average lead time for each supplier
sql_query = '''
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShingedDate, o.OrderDate)) as AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
GROUP BY s.SupplierID, s.CompanyName
''' 

# Execute the SQL query
average_lead_time_df = execute_sql_query(sql_query)

# Visualize the average lead time
fig = px.bar(average_lead_time_df, x='CompanyName', y='AverageLeadTime',
             title='Average Lead Time by Supplier',
             labels={'AverageLeadTime':'Average Lead Time (Days)', 'CompanyName':'Supplier'},
             color='AverageLeadTime')

# Show the visualization to the user
show_to_user(fig)","The input code has a typo in the SQL query. 'ShingedDate' should be 'ShippedDate'. This will result in a SQL error, preventing correct data retrieval. If corrected, the code would achieve the same outcome with additional supplier details.","
import pandas as pd
import plotly.express as px

# SQL query to get the average lead time for each supplier.
sql_query = ('''
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID = o.ProductID
GROUP BY s.CompanyName;
''')

# Execute the SQL query.
supplier_lead_time_df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(supplier_lead_time_df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time for Each Supplier', labels={'CompanyName': 'Supplier', 'AverageLeadTime': 'Average Lead Time (Days)'} )

# Display the plot.
show_to_user(fig)","The input code incorrectly joins the 'orders' directly with 'products' using 'ProductID', while the reference code joins 'orders' through 'Order Details'. The reference code ensures each order item's lead time is considered, while the input code may result in incorrect data structure or missing items.",None
List all orders including the details of the employee who handled them.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT orders.OrderID, orders.CustomerID, orders.OrderDate, employees.LastName, employees.FirstName 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID;
'''

# Execute the SQL query and retrieve the data into a pandas dataframe
orders_df = execute_sql_query(sql_query)

# Optional: Display the retrieved data to ensure it's correct (Uncomment to debug)
# print(orders_df)

# Visualizing the data (if needed)
fig = px.scatter(orders_df, x='OrderDate', y='OrderID', color='LastName', title='Orders and Handling Employees')

# Ensure the correct display of dates in the plot
fig.update_xaxes(type='category')

# Show the result to the user
show_to_user(fig)

# Alternatively, if just displaying the dataframe is required without visualization, use the following line instead:
# show_to_user(orders_df)","import pandas as pd

# SQL query to retrieve all orders and their corresponding employee details
sql_query = '''
SELECT 
    o.OrderID,
    o.OrderDate,
    o.RequiredDate,
    o.ShippedDate,
    o.ShipName,
    o.ShipAddress,
    o.ShipCity,
    o.ShipRegion,
    o.ShipPostalCode,
    o.ShipCountry,
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    e.Title
FROM 
    orders o
JOIN 
    employees e ON o.EmployeeID = e.EmployeeID
'''

# Execute the query and retrieve data
orders_with_employee_details = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_with_employee_details)","The input code correctly joins the orders with employee details, fulfilling the business request. It fetches more columns than the reference, but still addresses the requirement to list all orders with employee information.","import pandas as pd
import plotly.express as px

def list_orders_with_employee_details():
    # Define the SQL query
    sql_query = 'SELECT o.*, e.* FROM orders o JOIN employees e ON o.EmployeeID = e.EmployeeID;'
    
    # Execute the SQL query
    orders_with_employees_df = execute_sql_query(sql_query)
    
    # Display the data to user
    show_to_user(orders_with_employees_df)
    
    # Optionally, visualize the data (example: bar chart of order counts by employee)
    fig = px.bar(orders_with_employees_df, x='EmployeeID', title='Order Counts by Employee', labels={'EmployeeID':'Employee ID', 'count':'Number of Orders'})
    show_to_user(fig)

# Call the function to execute the above process
list_orders_with_employee_details()","The input code retrieves more columns than necessary by selecting all columns from both tables, instead of just the required ones.",Base
What is the total quantity of products ordered from each employee? (Include a visualization such as a bar chart to compare the total quantities ordered from each employee.),"import plotly.express as px

# SQL query to get the total quantity of products ordered from each employee
sql_query = '''
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
'''

# Execute the SQL query using the provided utility function `execute_sql_query`
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total quantities ordered from each employee
fig = px.bar(df, x='EmployeeID', y='TotalQuantity', title='Total Quantity of Products Ordered from Each Employee', labels={'EmployeeID': 'Employee ID', 'TotalQuantity': 'Total Quantity'})

# Use the provided utility function `show_to_user` to display the bar chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to retrieve total quantity of products ordered by each employee
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.Quantity) as TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
'''

# Execute the SQL query and retrieve the results
employee_order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize total quantities ordered by each employee
fig = px.bar(employee_order_data, x='FirstName + LastName', y='TotalQuantity',
             labels={'x': 'Employee', 'TotalQuantity': 'Total Quantity Ordered'},
             title='Total Quantity of Products Ordered by Each Employee')

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the total quantity of products ordered from each employee and visualizes the result using a bar chart. It includes the employees' full names, which is an acceptable enhancement. The output achieves the same outcome as the reference implementation.","import pandas as pd
import plotly.express as px

# SQL Query to get the data
sql_query = '''
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalQuantityOrdered 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not df.empty:
    # Create a bar chart
    fig = px.bar(df, x='EmployeeID', y='TotalQuantityOrdered', title='Total Quantity of Products Ordered by Each Employee')
    
    # Display the bar chart to the user
    show_to_user(fig)
else:
    print('No data available to display.')","The input Python code accurately retrieves the total quantity of products ordered from each employee, similar to the reference implementation. Although it differs in checking for an empty DataFrame, it achieves the same business analytic request and correctly visualizes the data using a bar chart from Plotly.",Base
How many orders were shipped late in the last month? (Include a time series visualization to show trends over the last few months.),"import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Utility function provided for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    pass  # placeholder for actual implementation

# Utility function provided for displaying data to the user
def show_to_user(data):
    pass  # placeholder for actual implementation

# Calculate date range for the last few months (assuming we want trends for the last 6 months)
end_date = datetime.now()
start_date = end_date - timedelta(days=180)

# SQL Query to get the number of orders shipped late in the last month
sql_query_last_month = '''
SELECT COUNT(orders.OrderID) AS Late_Orders 
FROM orders 
WHERE orders.RequiredDate < orders.ShippedDate 
AND MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
'''

df_late_orders_last_month = execute_sql_query(sql_query_last_month)

# SQL Query to get the number of orders shipped late over the last few months for trend analysis
sql_query_trend = f'''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS OrderMonth, COUNT(orders.OrderID) AS Late_Orders 
FROM orders 
WHERE orders.RequiredDate < orders.ShippedDate 
AND orders.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}' 
GROUP BY OrderMonth 
ORDER BY OrderMonth;
'''

df_trend = execute_sql_query(sql_query_trend)

# Plot the trend data
fig = px.line(df_trend, x='OrderMonth', y='Late_Orders', title='Late Orders Trend Over the Last Few Months')

# Display the trend plot to the user
show_to_user(fig)

# Optionally, display the number of late orders last month
display_text = f'Total number of late orders last month: {df_late_orders_last_month.iloc[0]['Late_Orders']}'
show_to_user(pd.DataFrame({'': [display_text]}))","import pandas as pd
import plotly.express as px

# SQL query to get late shipped orders in the last month
last_month = pd.to_datetime('now') - pd.DateOffset(months=1)
query = f""""""
SELECT
    DATE_FORMAT(ShippedDate, '%Y-%m') AS month,
    COUNT(OrderID) as late_orders
FROM
    orders
WHERE
    ShippedDate > RequiredDate
    AND ShippedDate >= '{last_month.strftime('%Y-%m-01')}'
GROUP BY
    month
ORDER BY
    month
""""""

# Execute the SQL query
late_orders_df = execute_sql_query(query)

# Show total late orders last month
total_late_orders = late_orders_df['late_orders'].sum()

# Time series visualization
fig = px.line(late_orders_df, x='month', y='late_orders', title='Monthly Late Shipments',
              labels={'month': 'Month', 'late_orders': 'Number of Late Orders'})

# Display results to the user
show_to_user(late_orders_df)
show_to_user(fig)

# Output total late orders last month
print(f'Total late orders last month: {total_late_orders}')","The input code calculates the late orders for the entire last month, not just those that were ordered in the last month but shipped late. The query also doesn't filter based on the order date being in the last month. It groups by the month of the shipped date, not the order date.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT COUNT(*) AS LateOrders
FROM orders o
WHERE o.ShippedDate > o.RequiredDate
AND DATE_PART('month', o.OrderDate) = DATE_PART('month', CURRENT_DATE - INTERVAL '1 month')
AND DATE_PART('year', o.OrderDate) = DATE_PART('year', CURRENT_DATE - INTERVAL '1 month');
'''

# Execute the SQL query and retrieve the result in a pandas dataframe
late_orders_df = execute_sql_query(sql_query)

# #### Part 1: Count of Late Orders in the Last Month ####
# Display the result to the user
show_to_user(late_orders_df)

# #### Part 2: Time Series Visualization ####
# SQL query to get the count of late orders for the last few months
sql_query_time_series = '''
SELECT DATE_TRUNC('month', o.OrderDate) AS OrderMonth, COUNT(*) AS LateOrders
FROM orders o
WHERE o.ShippedDate > o.RequiredDate
GROUP BY OrderMonth
ORDER BY OrderMonth;
'''

# Execute the SQL query and retrieve the data in a pandas dataframe
time_series_df = execute_sql_query(sql_query_time_series)

# Create a time series plot
fig = px.line(time_series_df, x='OrderMonth', y='LateOrders', title='Late Orders Over the Last Few Months', labels={'OrderMonth': 'Month', 'LateOrders': 'Number of Late Orders'})

# Display the time series plot to the user
show_to_user(fig)","The evaluated code does not filter the time series data to only include the last few months, missing the trend definition as given in the reference code which includes a specific date range. This leads to an incorrect trend visualization as it shows all data from the start of the records.",None
"How many orders were shipped late (i.e., shipped after the required date)? (Visualize the frequency of late shipments over time.)","import pandas as pd
import plotly.express as px

# Execute the SQL query to find late orders
sql_query = 'SELECT COUNT(*) AS LateOrders FROM orders WHERE ShippedDate > RequiredDate;'
data = execute_sql_query(sql_query)

# Calculate the frequency of late shipments over time
sql_query_late_shipments = 'SELECT ShippedDate, COUNT(*) as LateOrders FROM orders WHERE ShippedDate > RequiredDate GROUP BY ShippedDate;'
late_shipments_data = execute_sql_query(sql_query_late_shipments)

# Convert ShippedDate to datetime
late_shipments_data['ShippedDate'] = pd.to_datetime(late_shipments_data['ShippedDate'])

# Visualize the frequency of late shipments over time
fig = px.line(late_shipments_data, x='ShippedDate', y='LateOrders', title='Frequency of Late Shipments Over Time')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch orders that were shipped late
sql_query = '''
SELECT
    ShippedDate,
    COUNT(*) AS late_shipments
FROM
    orders
WHERE
    ShippedDate > RequiredDate
GROUP BY
    ShippedDate
ORDER BY
    ShippedDate;
'''  

# Execute the SQL query and retrieve the data
late_shipments_df = execute_sql_query(sql_query)

# Plot the frequency of late shipments over time
fig = px.line(late_shipments_df, x='ShippedDate', y='late_shipments', title='Frequency of Late Shipments Over Time')
show_to_user(fig)","The input code correctly retrieves and visualizes the frequency of late shipments over time. It groups shipments by ShippedDate where ShippedDate is greater than RequiredDate, mirroring the reference implementation's logic and producing the same outcome.","import pandas as pd
import plotly.express as px

# SQL query to get the count of late orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS LateOrders
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Check for successful retrieval of data
if not late_orders_df.empty:
    # Visualize the frequency of late shipments over time
    fig = px.line(late_orders_df, x='Month', y='LateOrders', title='Late Orders Over Time', labels={'Month': 'Month', 'LateOrders': 'Number of Late Orders'})
    
    # Display the plot to the user
    show_to_user(fig)
else:
    show_to_user(""No late orders data available"")","The input code does not match the business analytic request or reference implementation. It groups the late orders by month, not by shipment date. The reference implementation calculates late shipments per shipped date and uses `ShippedDate` for time series analysis. Hence, the input code doesn't address the request correctly.",Base
Which employee has the most orders shipped on time? (Include a visualization to compare the on-time shipment rates among employees.),"import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
top_employee_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OnTimeOrders 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.ShippedDate <= o.RequiredDate 
GROUP BY e.EmployeeID;'''

# Step 2: Execute the SQL query to get the data
employees_df = execute_sql_query(top_employee_query)

# Step 3: Find the employee with the most on-time orders
max_ontime_employee = employees_df.loc[employees_df['OnTimeOrders'].idxmax()]

# Display the employee with the most on-time orders
top_employee_data = pd.DataFrame([max_ontime_employee])
show_to_user(top_employee_data)

# Step 4: Visualize the on-time shipment rates among employees
fig = px.bar(employees_df, x='EmployeeID', y='OnTimeOrders', 
             title='On-Time Orders per Employee', 
             labels={'EmployeeID': 'Employee ID', 'OnTimeOrders': 'On-Time Orders'})

# Step 5: Show the visualization to the user
show_to_user(fig)

","import pandas as pd
import plotly.express as px

# SQL query to retrieve data on orders, employees, and their shipment status
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS TotalOrders,
       SUM(CASE WHEN o.RequiredDate >= o.ShippedDate THEN 1 ELSE 0 END) AS OnTimeOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
'''

# Execute the query and load the data into a DataFrame
employee_orders_df = execute_sql_query(sql_query)

# Calculate on-time shipment rate for each employee
employee_orders_df['OnTimeRate'] = employee_orders_df['OnTimeOrders'] / employee_orders_df['TotalOrders']

# Get the employee with the most orders shipped on time
best_employee = employee_orders_df.loc[employee_orders_df['OnTimeOrders'].idxmax()]
print(f""Employee with most on-time orders: {best_employee.FirstName} {best_employee.LastName} with {best_employee.OnTimeOrders} on-time orders."")

# Visualization to compare on-time shipment rates among employees
fig = px.bar(employee_orders_df, x='LastName', y='OnTimeRate',
             title='On-Time Shipment Rates by Employee',
             labels={'OnTimeRate': 'On-Time Shipment Rate', 'LastName': 'Employee Last Name'},
             text='OnTimeOrders')

# Show the visualization to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by calculating the employee with the most on-time orders and visualizing the on-time shipment rates among employees. Although the code includes additional details like 'FirstName' and 'LastName', the core outcome matches the reference implementation in terms of identifying the correct employee and visualizing the data using Plotly. Thus, the code is considered correct.","To solve the problem, we will perform the following steps:
1. Run a SQL query to get the number of on-time shipments for each employee.
2. Find the employee with the most orders shipped on time.
3. Create a visualization to compare the on-time shipment rates among employees.
4. Display the result to the user.

Let’s go ahead and implement this in Python:

```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get on-time shipment counts
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OnTimeShipments 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.ShippedDate <= o.RequiredDate 
GROUP BY e.EmployeeID 
ORDER BY OnTimeShipments DESC;
'''

# Execute the SQL query
employee_on_time_shipments = execute_sql_query(sql_query)

# Find the employee with the most on-time shipments
if not employee_on_time_shipments.empty:
    most_orders_employee = employee_on_time_shipments.iloc[0]
else:
    most_orders_employee = pd.Series({'EmployeeID': None, 'OnTimeShipments': 0})

# Display the employee with the most on-time shipments
show_to_user(most_orders_employee)

# Create a visualization for on-time shipment rates among employees
fig = px.bar(employee_on_time_shipments, x='EmployeeID', y='OnTimeShipments',
             title='On-Time Shipment Rates by Employee',
             labels={'EmployeeID': 'Employee ID', 'OnTimeShipments': 'Number of On-Time Shipments'})

# Display the visualization
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: This SQL query retrieves the count of on-time shipments grouped by EmployeeID. It orders the results descending to easily find the top performer. 

2. **Finding the Top Employee**: We use `iloc[0]` to get the first row, which corresponds to the employee with the most on-time shipments. 

3. **Visualization**: We use Plotly to create a bar chart showing the number of on-time shipments for each employee.

4. **Display Results**: Finally, the results and visualization are displayed using the provided `show_to_user` function.","The input code correctly addresses the business analytic request by running an SQL query to get the number of on-time shipments for each employee, identifying the employee with the most on-time shipments, and visualizing the on-time shipment rates among employees using Plotly. The logic and outcome match the reference implementation.",Base
What is the most frequently ordered product? (Include a pie chart or bar chart to show the frequency of orders for different products.),"import plotly.express as px

# SQL query to fetch the frequency of orders for different products
sql_query = '''
SELECT p.ProductName, COUNT(od.ProductID) AS OrderCount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY OrderCount DESC;''' 

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Create a bar chart to show the frequency of orders for different products
fig = px.bar(order_data, x='ProductName', y='OrderCount', title='Frequency of Orders for Different Products')

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Execute SQL query to retrieve order details
sql_query = '''
SELECT od.ProductID,
       SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
'''

order_details_df = execute_sql_query(sql_query)

# Step 2: Get the most frequently ordered product
most_frequent_product = order_details_df.iloc[0]

# Step 3: Visualize the frequency of orders for different products
fig = px.bar(order_details_df,
             x='ProductID', 
             y='TotalQuantity',
             title='Frequency of Orders for Different Products',
             labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity Ordered'})

# Step 4: Show the visualization to the user
show_to_user(fig)

# Optionally, display the most frequently ordered product details
most_frequent_product","The input code calculates the total quantity instead of the order count for each product. It doesn't join with the 'products' table, missing product names in the visualization, while the reference code uses order count to determine the most frequently ordered product and correctly joins with the 'products' table.","
import plotly.express as px
import pandas as pd

# Step 1: Retrieve the data

# SQL query to get the count of orders for each product
sql_query = '''
SELECT ProductID, COUNT(*) AS OrderCount
FROM [Order Details]
GROUP BY ProductID
ORDER BY OrderCount DESC
LIMIT 1;''' 

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the most frequently ordered product using the provided utility function
show_to_user(result_df)

# Step 2: Retrieve data for the bar chart
sql_query_all = '''
SELECT ProductID, COUNT(*) AS OrderCount
FROM [Order Details]
GROUP BY ProductID
ORDER BY OrderCount DESC;''' 

# Execute the SQL query to get all product frequencies
all_products_df = execute_sql_query(sql_query_all)

# Step 3: Create a bar chart to show the frequency of orders for different products
fig = px.bar(all_products_df, x='ProductID', y='OrderCount', title='Frequency of Orders for Different Products')

# Step 4: Display the bar chart
show_to_user(fig)","The input code correctly creates a bar chart showing order frequencies for all products, but incorrectly first limits the queried data to only the most frequently ordered product. The chart still depicts accurate frequency data for all products, consistent with the reference code's intent, but displaying only the top in initial query is unnecessary and irrelevant to visual request.",None
Which products have a unit price greater than 50?,"import pandas as pd

# SQL query to retrieve product names with unit price greater than 50
sql_query = 'SELECT ProductName FROM products WHERE UnitPrice > 50;'

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Check if the result_df is not empty and has the required data
if not result_df.empty:
    # Display the result to the user
    show_to_user(result_df)
else:
    print('No products found with unit price greater than 50.')","import pandas as pd

# Define SQL query to find products with a unit price greater than 50
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice
FROM products
WHERE UnitPrice > 50
""""""

# Execute the SQL query and get the results in a DataFrame
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly queries products with a unit price greater than 50 and displays them to the user, satisfying the business analytic request. The additional ProductID and UnitPrice columns do not impact the correctness related to the request.","import pandas as pd
import plotly.express as px

# Define the SQL query to get products with UnitPrice > 50
sql_query = 'SELECT ProductID, ProductName, UnitPrice FROM products WHERE UnitPrice > 50;'

# Execute the SQL query
product_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(product_df)","The input code effectively retrieves and displays products with a unit price greater than 50, which aligns with the business analytic request and achieves the same outcome as the reference implementation.",Base
How many units of each product were ordered last month? (Include a bar chart to compare the number of units ordered per product.),"import plotly.express as px

# Define the SQL query to fetch data
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS UnitsOrderedLastMonth 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderDate >= DATEADD(month, -1, GETDATE()) 
GROUP BY products.ProductID;
'''

# Execute the SQL query and retrieve the data as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty before creating the bar chart
if not df.empty:
    # Create a bar chart using plotly
    fig = px.bar(df, x='ProductID', y='UnitsOrderedLastMonth', 
                 title='Units Ordered Last Month per Product',
                 labels={'ProductID': 'Product ID', 'UnitsOrderedLastMonth': 'Units Ordered Last Month'})

    # Display the bar chart to the user
    show_to_user(fig)
else:
    print('No data found for the given query.')
","import pandas as pd
import plotly.express as px

# SQL query to get the total units ordered last month by product
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalUnitsOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE od.OrderID IN (
    SELECT OrderID FROM Orders WHERE OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1' MONTH) 
    AND OrderDate < DATE_TRUNC('month', CURRENT_DATE)
)
GROUP BY p.ProductID, p.ProductName
'''

# Execute SQL query and retrieve data
ordered_units_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(ordered_units_df, x='ProductName', y='TotalUnitsOrdered',
             title='Units Ordered Last Month by Product',
             labels={'TotalUnitsOrdered': 'Total Units Ordered', 'ProductName': 'Product Name'})

# Show the result to the user
show_to_user(fig)","The input code correctly retrieves the number of units ordered for each product last month and visualizes it in a bar chart. The output column names differ, but the query logic and visualization meet the analytical requirements.","import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to get the data
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 MONTH) AND CURDATE() 
GROUP BY p.ProductName;
""""""
product_orders_df = execute_sql_query(sql_query)

# Step 2: Create a bar chart using plotly
fig = px.bar(product_orders_df, x='ProductName', y='TotalQuantity', title='Units Ordered per Product Last Month', labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity Ordered'})

# Step 3: Visualize the bar chart to the user
show_to_user(fig)","The input code successfully retrieves the total quantity of each product ordered in the last month and displays a bar chart. It uses 'ProductName' instead of 'ProductID', but this still answers the business request effectively by showing the number of units ordered per product. It aligns with the reference implementation in terms of objective and visualization.",Base
Which shipping company has the highest on-time delivery rate? (Include a visualization comparing on-time delivery rates among shipping companies.),"import pandas as pd
import plotly.express as px

# SQL Query to retrieve on-time delivery rates of shipping companies
sql_query = '''
SELECT shippers.CompanyName, 
       COUNT(orders.OrderID) AS total_orders, 
       SUM(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 ELSE 0 END) AS on_time_orders
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY on_time_orders / CAST(COUNT(orders.OrderID) AS FLOAT) DESC
LIMIT 1
''' 

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Data preprocessing if needed
result_df['on_time_delivery_rate'] = result_df['on_time_orders'] / result_df['total_orders']

# Create a bar chart visualization with Plotly
fig = px.bar(result_df, x='CompanyName', y='on_time_delivery_rate', 
             title='On-time Delivery Rates by Shipping Companies',
             labels={'on_time_delivery_rate': 'On-Time Delivery Rate', 'CompanyName': 'Shipping Company'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rate by shipping company
sql_query = '''
SELECT shippers.CompanyName,
       COUNT(orders.OrderID) AS total_orders,
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) AS on_time_deliveries,
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
ORDER BY on_time_delivery_rate DESC
'''

# Execute the SQL query and retrieve the data
on_time_delivery_df = execute_sql_query(sql_query)

# Show the data in tabular format
show_to_user(on_time_delivery_df)

# Create a bar chart for visualization of on-time delivery rates
fig = px.bar(on_time_delivery_df, x='CompanyName', y='on_time_delivery_rate',
             title='On-time Delivery Rate by Shipping Company',
             labels={'on_time_delivery_rate': 'On-time Delivery Rate', 'CompanyName': 'Shipping Company'})

# Show the figure to the user
show_to_user(fig)","The input code correctly calculates the on-time delivery rate for each shipping company by counting the number of on-time deliveries and dividing by the total number of orders. It then visualizes the result using a bar chart, which aligns with the business analytic request. The approach taken is slightly different from the reference code, but it achieves the same outcome effectively.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT shippers.ShipperID, 
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 100.0 / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM shippers 
JOIN orders ON shippers.ShipperID = orders.ShipVia 
GROUP BY shippers.ShipperID 
ORDER BY on_time_delivery_rate DESC 
LIMIT 1
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# To visualize the on-time delivery rate, we need to get all shippers' data
all_shippers_query = '''
SELECT shippers.ShipperID, 
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 100.0 / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM shippers 
JOIN orders ON shippers.ShipperID = orders.ShipVia 
GROUP BY shippers.ShipperID 
ORDER BY on_time_delivery_rate DESC
'''

all_shippers_df = execute_sql_query(all_shippers_query)

# Create a plotly bar chart to visualize the on-time delivery rates
fig = px.bar(all_shippers_df, x='ShipperID', y='on_time_delivery_rate', 
             title='On-Time Delivery Rates by Shipping Company', 
             labels={'ShipperID':'Shipping Company', 'on_time_delivery_rate':'On-Time Delivery Rate (%)'})

# Show the visualization to the user
show_to_user(fig)","The input code retrieves both the highest on-time delivery rate and visualizes on-time delivery rates for all shippers. Although it does not directly return the name of the top company like the reference, it still effectively addresses the request through visualization. The approach is correct because it ultimately identifies which shipping company has the highest rate and visualizes the comparison.",Base
What is the total discount amount given for each product? (Include a bar chart to compare the total discount amounts among products.),"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName;
'''

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Ensure the dataframe is not empty
if not df.empty:
    # Generate the bar chart using plotly
    fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Total Discount Amount for Each Product')
    # Show the bar chart to the user
    show_to_user(fig)
else:
    show_to_user('No data available for the query.')","import pandas as pd
import plotly.express as px

# SQL query to calculate total discount amount for each product
sql_query = '''
SELECT p.ProductName, SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalDiscount DESC
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Create a bar chart to compare total discount amounts among products
fig = px.bar(result_df, x='ProductName', y='TotalDiscount', title='Total Discount Amount by Product', labels={'TotalDiscount': 'Total Discount Amount', 'ProductName': 'Product Name'})

# Show the bar chart
show_to_user(fig)","The evaluated code lacks the multiplication of the Discount by the UnitPrice, which is necessary as shown in the reference implementation.","import plotly.express as px

# SQL query to retrieve total discount amount for each product
sql_query = '''
SELECT products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscountAmount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName;'''

# Execute the SQL query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Create a bar chart with Plotly
fig = px.bar(result_df, x='ProductName', y='TotalDiscountAmount', title='Total Discount Amount for Each Product', labels={'ProductName':'Product Name', 'TotalDiscountAmount':'Total Discount Amount'})

# Show the resulting visualization to the user
show_to_user(fig)","The evaluated code correctly executes a SQL query to calculate the total discount amount for each product, similar to the reference implementation. It groups by 'ProductName' and sums the discounts by multiplying unit price, quantity, and discount rate, which matches the reference logic. Additionally, it uses Plotly to create a bar chart to visualize the results and displays it using 'show_to_user'. Thus, it fulfills the business analytic request effectively.",Finetuned
Calculate the total number of products sold by each employee. (Include a bar chart to compare the number of products sold by each employee.),"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, 
       SUM([Order Details].Quantity) AS TotalProductsSold 
FROM employees 
INNER JOIN orders ON employees.EmployeeID = orders.EmployeeID 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID
'''

# Execute the query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Check if result_df is empty
if result_df.empty:
    raise ValueError('The query returned no results')

# Generate a bar chart using plotly express
fig = px.bar(result_df, x='EmployeeID', y='TotalProductsSold', 
             title='Total Number of Products Sold by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalProductsSold': 'Total Products Sold'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the total number of products sold by each employee
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.Quantity) AS TotalProductsSold
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
'''  

# Execute the SQL query and retrieve the data
employee_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of products sold by each employee
fig = px.bar(employee_sales_df,
             x='FirstName + ' ' + LastName',
             y='TotalProductsSold',
             title='Total Products Sold by Each Employee',
             labels={'TotalProductsSold': 'Number of Products Sold', 'Employee': 'Employee'},
             text='TotalProductsSold')

# Show the visualization to the user
show_to_user(fig)",The input code is incorrect because it uses an invalid expression for the 'x' parameter in the plotly bar chart. The expression 'FirstName + ' ' + LastName' should be replaced with a new column in the dataframe for full names or the chart axis should instead use 'EmployeeID' for consistency with the aggregation logic.,"import plotly.express as px

# Define the SQL query according to the business request
sql_query = '''
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalProductsSold 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;'''

# Execute the query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(result_df)

# Create a bar chart using plotly
fig = px.bar(result_df, x='EmployeeID', y='TotalProductsSold', title='Total Products Sold by Each Employee', labels={'TotalProductsSold': 'Total Products Sold', 'EmployeeID': 'Employee ID'})

# Show the created plotly figure to the user
show_to_user(fig)","The input code correctly implements the same logic as the reference code to achieve the requested business analytic task. Both codes calculate the total number of products sold by each employee using a SQL query, and generate a bar chart using Plotly to visualize the results. The differences in the code, such as table aliases, do not affect the correctness of the outcome.",Finetuned
List customers who have not placed any orders in the last year.,"import pandas as pd
import plotly.express as px

# SQL query to list customers who have not placed any orders in the last year
sql_query = '''
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderID IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the dataframe is not empty before displaying to the user
if not result_df.empty:
    show_to_user(result_df)
else:
    print('No customers found who have not placed any orders in the last year.')","import pandas as pd

# Define the SQL query to find customers who have not placed any orders in the last year
sql_query = '''
SELECT c.CustomerID, c.CompanyName, c.ContactName
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY c.CustomerID, c.CompanyName, c.ContactName;
'''

# Execute the SQL query and get the results in a DataFrame
customers_without_orders = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(customers_without_orders)","The input code incorrectly uses 'GROUP BY' which is unnecessary since we are not aggregating data. There is also an inconsistency in how rows with no orders are filtered. The reference code checks if 'OrderID' is NULL to identify customers with no orders, while the input code checks 'OrderDate'. The reference code's approach is correct, as a NULL 'OrderID' more accurately captures customers with no orders.","import pandas as pd
from datetime import datetime, timedelta

# Define the SQL query
sql_query = '''
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderDate IS NULL OR o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR);
'''

# Execute the SQL query
customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_df)","The input Python code has a logical error in the WHERE clause of the SQL query. It uses 'o.OrderDate IS NULL', which is incorrect because NULL values would not appear in a LEFT JOIN. The correct condition should be 'o.OrderID IS NULL', as in the reference code, to identify customers with no recent orders.",None
Identify products with a unit price greater than the average unit price across all products. (Include a comparison of prices in a bar chart or similar visualization.),"import pandas as pd
import plotly.express as px

# Define the SQL query to get products with unit prices greater than the average unit price
sql_query = '''
SELECT p.ProductID, p.ProductName, p.UnitPrice 
FROM products p 
WHERE p.UnitPrice > (SELECT AVG(UnitPrice) FROM products);
'''

# Execute the SQL query
products_above_average_price = execute_sql_query(sql_query)

# Define the SQL query to get the average unit price for all products
avg_price_query = 'SELECT AVG(UnitPrice) as AvgPrice FROM products;'

# Execute the SQL query to get the average unit price
avg_price_df = execute_sql_query(avg_price_query)
avg_price = avg_price_df['AvgPrice'][0]

# Create a comparison bar chart
fig = px.bar(products_above_average_price, x='ProductName', y='UnitPrice', 
             title='Products with Unit Price Greater than the Average',
             labels={'UnitPrice': 'Unit Price'}, 
             text='UnitPrice')

# Add a line for the average price
fig.add_hline(y=avg_price, line_dash='dash', line_color='red', annotation_text='Average Price', annotation_position='bottom right')

# Display the bar chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Step 1: Retrieve products and calculate the average unit price
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice
FROM products
""""""
products_df = execute_sql_query(sql_query)

# Calculate average unit price
average_unit_price = products_df['UnitPrice'].mean()

# Step 2: Identify products with a unit price greater than the average
above_average_products = products_df[products_df['UnitPrice'] > average_unit_price]

# Step 3: Visualize the results with a bar chart
fig = px.bar(
    above_average_products,
    x='ProductName',
    y='UnitPrice',
    title='Products with Unit Price Greater than Average',
    labels={'UnitPrice': 'Unit Price', 'ProductName': 'Product Name'}
)

# Step 4: Show the visualization to the user
show_to_user(fig)",The input code does not add a line for the average price in the bar chart as the reference implementation does.,"import pandas as pd
import plotly.express as px

# Define the SQL queries
avg_unit_price_query = 'SELECT AVG(UnitPrice) AS AvgUnitPrice FROM products;'
products_above_avg_price_query = 'SELECT ProductName, UnitPrice FROM products WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM products);'

# Execute the queries
avg_unit_price_df = execute_sql_query(avg_unit_price_query)
products_above_avg_price_df = execute_sql_query(products_above_avg_price_query)

# Extract the average unit price
avg_unit_price = avg_unit_price_df.loc[0, 'AvgUnitPrice']
print(f'Average Unit Price: {avg_unit_price}')

# Display the products above average unit price
print(products_above_avg_price_df)

# Create the bar chart visualization
fig = px.bar(products_above_avg_price_df, x='ProductName', y='UnitPrice', title='Products with Unit Price Greater Than Average', text='UnitPrice')

# Show the bar chart to the user
show_to_user(fig)
","The evaluated code does not add a horizontal line to indicate the average unit price on the bar chart visualization, which is present in the reference implementation.",None
What is the most frequently ordered product in 2023? (Include a bar chart to show the frequency of orders for each product in 2023.),"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, products.ProductName, COUNT([Order Details].OrderID) AS order_count 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE YEAR([Order Details].OrderDate) = 2023 
GROUP BY products.ProductID, products.ProductName 
ORDER BY order_count DESC
'''

# Execute the SQL query to retrieve data
product_orders_df = execute_sql_query(sql_query)

# Generate the bar chart for order frequencies for each product in 2023
fig = px.bar(product_orders_df, x='ProductName', y='order_count', title='Frequency of Orders for Each Product in 2023')

# Display the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Query to get the product frequency for the year 2023
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_quantity DESC;
'''  

# Execute the SQL query and get the data
product_frequency_df = execute_sql_query(sql_query)

# Get the most frequently ordered product
most_frequent_product = product_frequency_df.iloc[0]
print(f'Most Frequently Ordered Product in 2023: {most_frequent_product.ProductName} (Quantity: {most_frequent_product.total_quantity})')

# Create a bar chart to show the frequency of orders for each product
fig = px.bar(product_frequency_df, x='ProductName', y='total_quantity', title='Frequency of Products Ordered in 2023', labels={'total_quantity': 'Total Quantity Ordered', 'ProductName': 'Product Name'})

# Show the plot to the user
show_to_user(fig)",The input code calculates the total quantity ordered per product instead of the count of orders per product.,"To find the most frequently ordered product in 2023 and generate a bar chart showing the frequency of orders for each product in 2023, you can use the following Python code.

### Step 1: Fetching the data
The SQL query is already given:
```sql
SELECT ProductName, COUNT(*) AS OrderFrequency
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(OrderDate) = 2023
GROUP BY ProductName
```

### Step 2: Analyzing the data
We'll use the `max()` function to find the most frequently ordered product and the rest of the data will be displayed using a bar chart.

### Step 3: Visualizing the data
Here's the complete code snippet to execute and visualize the data.

```python
import pandas as pd
import plotly.express as px

# SQL Query to get the frequent orders
sql_query = '''
SELECT ProductName, COUNT(*) AS OrderFrequency
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(OrderDate) = 2023
GROUP BY ProductName
ORDER BY OrderFrequency DESC;
'''

# Execute the SQL query to get the data
order_freq_df = execute_sql_query(sql_query)

# Display the dataframe to find the most frequently ordered product
display_df = order_freq_df.copy()  # Copy to avoid modifying the original

# Display the most frequently ordered product
most_frequent_product = order_freq_df.iloc[0]
print(f""The most frequently ordered product in 2023 is {most_frequent_product['ProductName']} with {most_frequent_product['OrderFrequency']} orders."")

# Generate a bar chart for the frequency of orders for each product in 2023
fig = px.bar(order_freq_df, x='ProductName', y='OrderFrequency', title='Order Frequency per Product in 2023')

# Show the bar chart to the user
show_to_user(fig)

# Optionally, show the order frequency dataframe as well
show_to_user(display_df)
```

### Explanation of Key Steps:
1. **Data Extraction**: Executes the SQL query to retrieve relevant order frequency data.
2. **Finding Most Frequent Product**: Identifies and prints out the product with the highest order frequency in 2023.
3. **Data Visualization**: Creates a bar chart to visualize the order frequency of all products for the year 2023.
4. **Display Results**: Uses the `show_to_user()` function to display both the bar chart and the data, ensuring the user has full context.","The input code correctly fulfills the business analytic request by executing a SQL query to identify the most frequently ordered product in 2023 and generates a bar chart to visualize the frequency of orders for each product. The structure and logic of the SQL query effectively match the reference implementation, ensuring the correct data is retrieved. The visualization and data display functions are appropriately utilized, making the overall implementation functionally equivalent to the reference code.",Finetuned
What are the names and IDs of all products that are currently out of stock?,"import pandas as pd

# SQL query to get the names and IDs of all products that are currently out of stock
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;'

# Execute the SQL query and get the result as a pandas dataframe
# Note: Assuming `execute_sql_query` is a provided utility function as mentioned

df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(df)","sql_query = """"""
SELECT ProductID, ProductName
FROM products
WHERE UnitsInStock = 0
""""""
data = execute_sql_query(sql_query)
show_to_user(data)","The input Python code correctly retrieves the names and IDs of all products that are currently out of stock by executing the appropriate SQL query. It then displays the result using the 'show_to_user' function, aligning with the business analytic request and achieving the same outcome as the reference implementation.","import pandas as pd

# Define the SQL query to get products that are out of stock
sql_query = 'SELECT ProductID, ProductName FROM products WHERE UnitsInStock = 0;'

# Execute the SQL query using the provided function
out_of_stock_products = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(out_of_stock_products)",The input code successfully retrieves the names and IDs of all products that are currently out of stock using the provided utility functions. It matches the business analytic request and achieves the same outcome as the reference implementation.,Base
How many products were low on stock (below reorder level) in August 2023? (Include a visualization to show the number of low-stock products over time.),"import pandas as pd
import plotly.express as px

# SQL query to retrieve low-stock products in August 2023
sql_query = '''SELECT products.ProductID, products.RecordDate
               FROM products
               WHERE products.UnitsInStock < products.ReorderLevel
               AND MONTH(products.RecordDate) = 8
               AND YEAR(products.RecordDate) = 2023''' 

# Execute the SQL query
low_stock_df = execute_sql_query(sql_query)

# Convert RecordDate to datetime for better manipulation
low_stock_df['RecordDate'] = pd.to_datetime(low_stock_df['RecordDate'])

# Extract date components for more structured analysis
low_stock_df['Date'] = low_stock_df['RecordDate'].dt.date

# Group by date to get count of low-stock products for each day
low_stock_count = low_stock_df.groupby('Date').size().reset_index(name='LowStockCount')

# Create a line plot to visualize the number of low-stock products over time
fig = px.line(low_stock_count, x='Date', y='LowStockCount', title='Low-Stock Products in August 2023', labels={'LowStockCount': 'Number of Low-Stock Products'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the query to find low stock products for August 2023
sql_query = '''
SELECT COUNT(*) AS low_stock_count
FROM products
WHERE UnitsInStock < ReorderLevel
AND ProductID IN (
    SELECT DISTINCT ProductID 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE orders.OrderDate BETWEEN '2023-08-01' AND '2023-08-31'
)
'''  

# Execute the SQL query and retrieve the results
low_stock_products = execute_sql_query(sql_query)

# Display the count of low-stock products
show_to_user(low_stock_products)

# Define query to get low stock product counts over time
time_query = '''
SELECT DATE(orders.OrderDate) AS order_date, COUNT(*) AS low_stock_count 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.UnitsInStock < products.ReorderLevel
GROUP BY DATE(orders.OrderDate)
ORDER BY DATE(orders.OrderDate);
'''

# Execute the time series SQL query
low_stock_time_series = execute_sql_query(time_query)

# Create a line plot to visualize the number of low-stock products over time
fig = px.line(low_stock_time_series, x='order_date', y='low_stock_count', title='Low Stock Products Over Time', labels={'order_date':'Date', 'low_stock_count':'Low Stock Count'})

# Show the visualization to the user
show_to_user(fig)","The input code uses a different logic to identify low-stock products by looking at 'Order Details' and 'orders', which is not equivalent to filtering by 'RecordDate' in August 2023, as in the reference implementation. Therefore, the logic does not correctly answer the business request.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to retrieve the necessary data
sql_query = '''
SELECT COUNT(*) AS low_stock_products,
       MONTH(orders.OrderDate) AS order_month,
       YEAR(orders.OrderDate) AS order_year
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.UnitsInStock < products.ReorderLevel
      AND orders.OrderDate >= '2023-08-01'
      AND orders.OrderDate < '2023-09-01'
GROUP BY order_month, order_year
'''

# Step 2: Execute the SQL query
low_stock_data = execute_sql_query(sql_query)

# Step 3: Visualizing the result for August 2023
fig = px.line(low_stock_data, x='order_month', y='low_stock_products', title='Number of Low-Stock Products in August 2023')

# Step 4: Display the visualization to the user
show_to_user(fig)","The evaluated code counts low-stock products based on order dates, not product record dates. It inaccurately uses order details, contradicting the reference requirement to use product stock and reorder levels.",None
What is the total number of products available in the inventory?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT COUNT(*) AS total_products FROM products;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Extract the total number of products from the resulting dataframe
if not result_df.empty:
    total_products = result_df.loc[0, 'total_products']
else:
    total_products = 0

# Convert the result into a DataFrame for better presentation
output_df = pd.DataFrame({'Total Products': [total_products]})

# Display the result using the show_to_user utility function
show_to_user(output_df)
","import pandas as pd

# SQL query to count the total number of products in the inventory
sql_query = ""SELECT COUNT(*) AS TotalProducts FROM products WHERE Discontinued = 0""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The input code only counts products that are not discontinued. This might not match the reference implementation if discontinued products exist in the dataset.,"python
import pandas as pd

# Define the SQL query
sql_query = 'SELECT SUM(UnitsInStock) AS TotalUnitsInStock FROM products;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if the result is not empty and retrieve the total units in stock
if not result_df.empty:
    total_units_in_stock = result_df.loc[0, 'TotalUnitsInStock']
    result_df = pd.DataFrame({'TotalUnitsInStock': [total_units_in_stock]})

# Display the result
show_to_user(result_df)",The input code calculates the total units in stock rather than counting the total number of products. It should use COUNT(*) to find the number of products.,None
Which shipping company has the highest on-time delivery rate? (Include a visualization comparing on-time delivery rates among shipping companies.),"# Import required libraries
import plotly.express as px

# Define the SQL query
top_shipping_query = '''
SELECT ShipVia, 
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipVia 
ORDER BY OnTimeDeliveryRate DESC;''' 

# Execute the SQL query and get the result in a pandas dataframe
df = execute_sql_query(top_shipping_query)

# Generate a bar plot to visualize on-time delivery rates among shipping companies
fig = px.bar(df, x='ShipVia', y='OnTimeDeliveryRate', title='On-Time Delivery Rates by Shipping Company', labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-Time Delivery Rate'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate the on-time delivery rates per shipping company
sql_query = '''
SELECT ShipVia, 
       COUNT(OrderID) AS TotalOrders, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeDeliveries,
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID)) * 100.0 AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipVia
ORDER BY OnTimeDeliveryRate DESC;
'''  

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Show the results to the user in a tabular format
show_to_user(results_df)

# Create a visualization comparing on-time delivery rates among shipping companies
fig = px.bar(
    results_df,
    x='ShipVia',
    y='OnTimeDeliveryRate',
    title='On-Time Delivery Rates by Shipping Company',
    labels={'ShipVia': 'Shipping Company', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'},
    color='OnTimeDeliveryRate'
)

# Show the plot to the user
show_to_user(fig)","The input code effectively calculates and visualizes the on-time delivery rates among shipping companies. It includes all necessary components to determine which company has the highest rate, similar to the reference implementation, even though it includes additional details like TotalOrders and OnTimeDeliveries.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT shippers.CompanyName,
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
ORDER BY on_time_delivery_rate DESC
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Visualization: bar chart for on-time delivery rates
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate', labels={'on_time_delivery_rate': 'On-Time Delivery Rate', 'CompanyName': 'Shipping Company' }, title='On-Time Delivery Rates by Shipping Company')

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly calculates the on-time delivery rate by joining 'orders' and 'shippers' tables and grouping by 'CompanyName', matching the intended logic of the reference implementation which groups by 'ShipVia'. The visualization accurately uses a bar chart to display results, fulfilling the business analytic request.",Base
What are the top 5 products in terms of total units sold? (Include a bar chart to show the top 5 products based on total units sold.),"
import plotly.express as px

# SQL query to get the top 5 products in terms of total units sold
sql_query = '''
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalUnitsSold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5;
'''

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to show the top 5 products based on total units sold
fig = px.bar(df, x='ProductName', y='TotalUnitsSold', title='Top 5 Products by Total Units Sold', labels={'ProductName': 'Product Name', 'TotalUnitsSold': 'Total Units Sold'})

# Display the plotly figure to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to get the total units sold for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5
'''

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(results_df, x='ProductName', y='TotalUnitsSold', title='Top 5 Products by Total Units Sold')

# Show the results to the user
show_to_user(fig)","The input code correctly executes a SQL query to retrieve the top 5 products based on total units sold. It then uses Plotly to create a bar chart displaying these products, matching the business analytic request effectively. The steps mirror the reference implementation's logic, with variations in variable names and structure, which are acceptable.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductID, SUM(od.Quantity) AS TotalUnitsSold 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID 
ORDER BY TotalUnitsSold DESC 
LIMIT 5;
""""""

# Execute the query to get the data
products_df = execute_sql_query(sql_query)

# Ensure we have the columns in the dataframe
products_df.columns = ['ProductID', 'TotalUnitsSold']

# Create a bar chart using plotly
fig = px.bar(products_df, x='ProductID', y='TotalUnitsSold', title='Top 5 Products by Total Units Sold')

# Show the bar chart to the user
show_to_user(fig)","The input code does not include the 'ProductName' column in the SQL query, which is required to effectively display the top 5 products in terms of units sold as intended in the business analytic request.",Base
What is the monthly average shipping cost?,"import pandas as pd
import plotly.express as px

# SQL query to get the monthly average shipping cost
df = execute_sql_query(""SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AvgShippingCost FROM orders GROUP BY Month;"")

# Display the dataframe to the user
show_to_user(df)

# Ensure the 'Month' column is treated as a datetime object for proper plotting
df['Month'] = pd.to_datetime(df['Month'], format='%Y-%m')

df = df.sort_values('Month')  # Sort dataframe by 'Month' to ensure plot is in chronological order

# Create a line plot using Plotly to visualize the monthly average shipping cost
fig = px.line(df, x='Month', y='AvgShippingCost', title='Monthly Average Shipping Cost', labels={'Month': 'Month', 'AvgShippingCost': 'Average Shipping Cost'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd

# SQL query to calculate monthly average shipping cost
sql_query = """"""
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(Freight) AS Average_Shipping_Cost
FROM
    orders
GROUP BY
    Month
""""""

# Execute the SQL query and retrieve data
monthly_avg_shipping_cost = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(monthly_avg_shipping_cost)","The input code calculates and displays the monthly average shipping cost similar to the reference implementation, but it lacks the time conversion and sorting needed for proper chronological analysis and visualization. It also does not create a plot for visualization, which is part of the request.","import pandas as pd
import plotly.express as px


def fetch_monthly_avg_shipping_cost():
    # SQL query to get monthly average shipping cost
    sql_query = """"""
    SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Freight) AS AVG_Freight
    FROM orders
    GROUP BY Month
    ORDER BY Month;
    """"""

    # Execute the SQL query and retrieve the data
    monthly_avg_shipping_cost_df = execute_sql_query(sql_query)

    # Check if the dataframe is not empty before plotting
    if not monthly_avg_shipping_cost_df.empty:
        # Plotting the data using plotly
        fig = px.line(monthly_avg_shipping_cost_df, x='Month', y='AVG_Freight', title='Monthly Average Shipping Cost', labels={'Month': 'Month', 'AVG_Freight': 'Average Shipping Cost'})

        # Show the plot to the user
        show_to_user(fig)
    else:
        print(""No data available to display."")

# Execute the function
fetch_monthly_avg_shipping_cost()","The evaluated code correctly calculates the monthly average shipping cost using an SQL query. It groups the data by month, calculates the average freight, and sorts the results by month. Both the reference and input codes fetch the data, check for emptiness, and plot it using Plotly before displaying it with 'show_to_user'. Therefore, it successfully addresses the business analytic request.",Finetuned
Which employee has the highest sales in Q1 2023?,"import pandas as pd
import plotly.express as px

# SQL query string based on the given specification
sql_query = '''
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY employees.EmployeeID
ORDER BY employee_sales DESC
LIMIT 1;
'''

# Execute the SQL query and fetch the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","# SQL query to find the employee with the highest sales in Q1 2023
sql_query = '''
SELECT employees.EmployeeID, employees.FirstName, employees.LastName,  
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales  
FROM [Order Details]  
JOIN orders ON [Order Details].OrderID = orders.OrderID  
JOIN employees ON orders.EmployeeID = employees.EmployeeID  
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'  
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName  
ORDER BY total_sales DESC  
LIMIT 1
'''  

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)  

# Displaying the result to the user
show_to_user(result_df)","The input code retrieves the employee with the highest sales in Q1 2023, accurately reflecting the business analytic request. It includes additional employee details (FirstName, LastName), but this does not impact the correctness of identifying the top seller. The query logic is consistent with the reference implementation.","import pandas as pd

# Define the executed SQL query
sql_query = '''
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN employees e ON o.EmployeeID = e.EmployeeID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 1
'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user using the provided utility function
show_to_user(result_df)","The input code fulfills the business requirement by executing an equivalent SQL query as the reference implementation. Both queries select the employee with the highest sales in Q1 2023, using the same logic and SQL functions for calculations. The column names differ slightly, but they do not affect the outcome.",Base
What is the total revenue generated from each product sold in 2022? (Include data visualization for better illustration),"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID
'''

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total revenue per product
fig = px.bar(df, x='ProductID', y='total_revenue', title='Total Revenue per Product in 2022', labels={'ProductID': 'Product ID', 'total_revenue': 'Total Revenue'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total revenue generated from each product sold in 2022
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE YEAR(orders.OrderDate) = 2022 
GROUP BY products.ProductID, products.ProductName
""""""

# Execute the SQL query and get the results
revenue_data = execute_sql_query(sql_query)

# Data visualization using Plotly
fig = px.bar(revenue_data, x='ProductName', y='total_revenue',
             title='Total Revenue Generated from Each Product Sold in 2022',
             labels={'total_revenue': 'Total Revenue', 'ProductName': 'Product'})

# Show the result to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by calculating the total revenue generated from each product sold in 2022. It executes the SQL query which considers 'OrderDate' in the year 2022. It also correctly visualizes the data with Plotly, creating a bar chart to represent 'total_revenue' per 'ProductName'. Although it includes the 'ProductName' in the grouping and visualization, it achieves the same outcome as the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT p.ProductID, SUM(od.Quantity * od.UnitPrice) AS ProductRevenue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY p.ProductID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Generate the data visualization
fig = px.bar(result_df, x='ProductID', y='ProductRevenue', title='Total Revenue from Each Product Sold in 2022')

# Display the result to the user
show_to_user(fig)
","The evaluated code doesn't apply discounts to the revenue calculation, which is present in the reference code. This can lead to an overestimation of total revenue.",Base
What is the most ordered product in terms of quantity?,"import pandas as pd

# SQL query to find the most ordered product in terms of quantity
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalQuantityOrdered DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if the result dataframe is not empty
if not result_df.empty:
    # Display the result to the user
    show_to_user(result_df)
else:
    print(""No data found."")
","import pandas as pd

# SQL query to get the total quantity ordered for each product
sql_query = '''
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantityOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantityOrdered DESC
LIMIT 1;
'''

# Execute the SQL query and get the result as a DataFrame
most_ordered_product_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(most_ordered_product_df)","The input code correctly calculates the most ordered product by executing a SQL query that sums the quantities of each product and orders the results in descending order, limiting to one result. This matches the reference implementation's logic, effectively answering the business analytic request.","import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to retrieve the data
sql_query = '''SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID ORDER BY TotalQuantity DESC LIMIT 1;'''
result_df = execute_sql_query(sql_query)

# Step 2: Display the result to the user
show_to_user(result_df)

# Step 3: Optional - Visualizing the result using plotly
fig = px.bar(result_df, x='ProductID', y='TotalQuantity', title='Most Ordered Product', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})
show_to_user(fig)","The evaluated code returns the ProductID and TotalQuantity, but it does not include the ProductName, which is necessary to fully answer the business analytic request. The reference code joins Order Details with Products to get the ProductName.",Base
How many products have less than 10 units in stock?,"import pandas as pd

# SQL query to find products with less than 10 units in stock
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < 10;""

# Execute the query using the provided utility function
df = execute_sql_query(sql_query)

# Count the number of products with less than 10 units in stock
num_products = df.shape[0]

# Display the count
show_to_user(pd.DataFrame({'Number of Products with < 10 units': [num_products]}))","import pandas as pd

# SQL query to find the number of products with less than 10 units in stock
sql_query = """"""
SELECT COUNT(*) AS ProductsBelowThreshold
FROM products
WHERE UnitsInStock < 10
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly counts the number of products with less than 10 units in stock and displays it using the available utilities. Although it uses a different method by directly counting in the SQL query, it effectively addresses the business analytic request.","import pandas as pd

# Define the SQL query to count products with less than 10 units in stock
sql_query = 'SELECT COUNT(*) AS LowStockProducts FROM products WHERE UnitsInStock < 10;'

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input Python code correctly counts the number of products with less than 10 units in stock using an SQL query with COUNT(*) and displays the result, aligning with the business analytic request and the outcome of the reference implementation.",Base
List the top 5 products with the highest total sales revenue. (Include a bar chart to visualize the comparisons),"import pandas as pd
import plotly.express as px

# SQL query to get the top 5 products with the highest total sales revenue
sql_query = '''
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID, products.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 products by total sales revenue
fig = px.bar(sales_data, x='ProductName', y='TotalSales', 
             title='Top 5 Products by Total Sales Revenue', 
             labels={'ProductName': 'Product Name', 'TotalSales': 'Total Sales Revenue'}, 
             text='TotalSales')

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalRevenue DESC
LIMIT 5
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualizing the top 5 products with highest sales revenue
fig = px.bar(result_df, x='ProductName', y='TotalRevenue', title='Top 5 Products by Total Sales Revenue',
              labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

# Show the results to the user
show_to_user(fig)","The input code retrieves and visualizes the top 5 products with the highest total sales revenue correctly, similar to the reference code. Both codes execute an SQL query to compute total sales revenue and create a bar chart using Plotly to visualize the results. The minor differences in variable names and formatting do not affect the outcome.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales of the top 5 products
fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Top 5 Products by Total Sales Revenue')

# Show the plot to the user
show_to_user(fig)
","The input code does not account for discounts when calculating the total sales revenue, unlike the reference code which includes discounts in the calculation. This results in potentially different outcomes for the top 5 products.",Base
Which products have the highest and lowest inventory turnover ratio? (Include data visualization for comparison),"import pandas as pd
import plotly.express as px

def get_inventory_turnover_ratio():
    # SQL query to get the inventory turnover ratio for each product
    sql_query = '''
    SELECT p.ProductName, 
           SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    GROUP BY p.ProductName 
    ORDER BY InventoryTurnoverRatio DESC
    LIMIT 1;
    '''
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Include an SQL query to get the product with the lowest inventory turnover ratio
    sql_query_low = '''
    SELECT p.ProductName, 
           SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    GROUP BY p.ProductName 
    ORDER BY InventoryTurnoverRatio ASC
    LIMIT 1;
    '''
    
    # Execute the low turnover SQL query
    df_low = execute_sql_query(sql_query_low)
    
    # Merge highest and lowest turnover ratios into a new DataFrame for visualization
    comparison_df = pd.DataFrame({
        ""ProductName"": [df.iloc[0]['ProductName'], df_low.iloc[0]['ProductName']],
        ""InventoryTurnoverRatio"": [df.iloc[0]['InventoryTurnoverRatio'], df_low.iloc[0]['InventoryTurnoverRatio']]
    })
    
    # Create bar plot visualization for comparison
    fig = px.bar(comparison_df, x='ProductName', y='InventoryTurnoverRatio', 
                 title='Highest and Lowest Inventory Turnover Ratio', 
                 labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})
    
    # Show the visualization to the user
    show_to_user(fig)

# Call the function to execute the analysis and visualization
get_inventory_turnover_ratio()","import pandas as pd
import plotly.express as px

# SQL query to get the Sales and Inventory data
sql_query = '''
SELECT p.ProductID, p.ProductName,
       SUM(od.Quantity) AS TotalSold,
       AVG(p.UnitsInStock) AS AvgInventory,
       SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
''' 

# Execute the SQL query
product_data = execute_sql_query(sql_query)

# Calculate Inventory Turnover Ratio
product_data['InventoryTurnoverRatio'] = product_data['TotalRevenue'] / product_data['AvgInventory']

# Identify products with highest and lowest inventory turnover ratio
highest_turnover = product_data.loc[product_data['InventoryTurnoverRatio'].idxmax()]
lowest_turnover = product_data.loc[product_data['InventoryTurnoverRatio'].idxmin()]

# Prepare data for visualization
comparison_data = product_data[['ProductID', 'ProductName', 'InventoryTurnoverRatio']]

# Create a bar chart for inventory turnover ratio
fig = px.bar(comparison_data, x='ProductName', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio of Products')

# Show the visual representation to the user
show_to_user(fig)

# Display the highest and lowest inventory turnover products
result = pd.DataFrame({
    'Type': ['Highest Turnover', 'Lowest Turnover'],
    'ProductID': [highest_turnover.ProductID, lowest_turnover.ProductID],
    'ProductName': [highest_turnover.ProductName, lowest_turnover.ProductName],
    'Inventory Turnover Ratio': [highest_turnover.InventoryTurnoverRatio, lowest_turnover.InventoryTurnoverRatio]
})

show_to_user(result)","The input code correctly calculates and visualizes the inventory turnover ratio for all products, and identifies the products with the highest and lowest ratios. It achieves the same outcome as the reference implementation, even though the approach differs, fulfilling the business analytic request.","To achieve the goal of identifying products with the highest and lowest inventory turnover ratio and visualizing the data, we can follow these steps:

1. **Import necessary libraries**: Ensure we have all required libraries for data manipulation and visualization.
2. **Retrieve Data**: Execute the SQL query to get inventory turnover ratios for all products.
3. **Data Manipulation**: Extract the products with the highest and lowest turnover ratios.
4. **Data Visualization**: Create a visualization for comparison.

Here's the complete code:

```python
# Step 1: Import necessary libraries
import pandas as pd
import plotly.express as px

# Step 2: Execute the SQL query to retrieve data
sql_query = '''
SELECT p.ProductName, 
       (SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)) AS InventoryTurnoverRatio 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
'''

df = execute_sql_query(sql_query)

# Step 3: Extract the highest and lowest turnover ratios
highest_turnover = df.loc[df['InventoryTurnoverRatio'].idxmax()]
lowest_turnover = df.loc[df['InventoryTurnoverRatio'].idxmin()]

# Combine highest and lowest into a single DataFrame for easy visualization
comparison_df = pd.DataFrame({
    ""ProductName"": [highest_turnover['ProductName'], lowest_turnover['ProductName']],
    ""InventoryTurnoverRatio"": [highest_turnover['InventoryTurnoverRatio'], lowest_turnover['InventoryTurnoverRatio']]
})

# Step 4: Create a data visualization
fig = px.bar(comparison_df, x='ProductName', y='InventoryTurnoverRatio', 
             title=""Highest and Lowest Inventory Turnover Ratio"", 
             labels={'ProductName': 'Product Name', 'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

# Show the visualization to the user
show_to_user(fig)
```

### Summary of the Code:
- We retrieve the inventory turnover ratios using the given SQL query.
- We identify the products with the highest and lowest turnover ratios, then combine these into a new DataFrame.
- We use Plotly to create a bar chart to visually compare these two products' turnover ratios.
- Finally, we display the visualization using the `show_to_user()` function. 

### Additional Tips:
- Ensure that the execute_sql_query function is properly set up to run the SQL query.
- Validate if the returned DataFrame not empty and if indices used for extraction are within bounds.
- The visualization approach can be modified as needed to fit specific styles or requirements.","The input code effectively retrieves data for all products, calculates inventory turnover ratios, identifies the products with the highest and lowest ratios, and visualizes these using a bar chart. It matches the reference implementation in terms of functional outcomes.",Base
Identify employees with the highest and lowest order counts. (Include a bar chart for better comparison),"import pandas as pd
import plotly.express as px

# Define the SQL query
detail_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1 
UNION 
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount ASC 
LIMIT 1;'''

# Execute the query to get the data
data_df = execute_sql_query(detail_query)

# Create the bar chart using plotly
fig = px.bar(data_df, 
            x='EmployeeID', 
            y='OrderCount', 
            text='OrderCount', 
            title='Employees with Highest and Lowest Order Counts', 
            labels={'EmployeeID':'Employee ID', 'OrderCount':'Order Count'}, 
            hover_data=['FirstName', 'LastName'])

# Show the bar chart to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to count orders by employee
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
""""""

# Execute the SQL query
order_counts_df = execute_sql_query(sql_query)

# Identify employees with the highest and lowest order counts
highest_order_count = order_counts_df.loc[order_counts_df['OrderCount'].idxmax()]
lowest_order_count = order_counts_df.loc[order_counts_df['OrderCount'].idxmin()]

# Prepare data for visualization
comparison_df = pd.DataFrame([
    [highest_order_count['EmployeeName'], highest_order_count['OrderCount']],
    [lowest_order_count['EmployeeName'], lowest_order_count['OrderCount']]
], columns=['Employee', 'Order Count'])

# Create a bar chart for comparison
fig = px.bar(comparison_df, x='Employee', y='Order Count', title='Highest and Lowest Order Counts by Employee')

# Show results to the user
show_to_user(fig)","The input code correctly identifies employees with the highest and lowest order counts and produces a bar chart using Plotly, similar to the reference implementation. It successfully uses functions to execute SQL queries and display the bar chart with employee names and order counts, achieving the same analytical goal.","import pandas as pd
import plotly.express as px

# SQL query to get the employees with the highest and lowest order counts
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC;
'''

# Execute the SQL query and retrieve the data into a pandas dataframe
df = execute_sql_query(sql_query)

# Identify the employee with the highest order count
max_order_employee = df.loc[df['OrderCount'].idxmax()]

# Identify the employee with the lowest order count
min_order_employee = df.loc[df['OrderCount'].idxmin()]

# Correcting the bar chart to show only the max and min order count employees
min_val = min_order_employee['OrderCount']
max_val = max_order_employee['OrderCount']
if max_val == min_val:
    # In this case, there's a tie or no different to show
    raise ValueError(""No distinct highest and lowest order counts found. Please check the data."")

# Creating a new dataframe for the top two
top_two_df = pd.DataFrame({
    'EmployeeID': [max_order_employee['EmployeeID'], min_order_employee['EmployeeID']],
    'OrderCount': [max_order_employee['OrderCount'], min_order_employee['OrderCount']]
})

# Create a bar chart using plotly
fig = px.bar(top_two_df, x='EmployeeID', y='OrderCount', title='Employees with Highest and Lowest Order Counts')

# Show the result to the user
show_to_user(fig)

# Also showing the data to user if needed
show_to_user(df)","The input code doesn't join the 'employees' and 'orders' tables to include employee names, unlike the reference implementation. This means it doesn't fully meet the business analytic request of identifying specific employees with highest and lowest order counts along with their first and last names.",Base
Which employee handled the most orders?,"import pandas as pd

# Define the SQL query
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC 
LIMIT 1;
'''

# Execute the SQL query and retrieve the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","sql_query = '''
SELECT EmployeeID, COUNT(*) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1;
'''

most_orders_employee = execute_sql_query(sql_query)
show_to_user(most_orders_employee)",The input code correctly answers the business analytic request by identifying the employee who handled the most orders. It matches the reference implementation in logic and achieves the same outcome. Differences in variable naming and the use of count aggregation do not affect correctness.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
INNER JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC
'''  # Correcting the SQL query to see all employees with order counts.

# Execute the SQL query to retrieve the data
order_data = execute_sql_query(sql_query)

# Find the employee who handled the most orders
max_orders_employee = order_data.iloc[0]
employee_id = max_orders_employee['EmployeeID']
order_count = max_orders_employee['OrderCount']

# Display the most orders handled
show_to_user(pd.DataFrame({'EmployeeID': [employee_id], 'OrderCount': [order_count]}))

# Optional: Visualize the data for all employees
fig = px.bar(order_data, x='EmployeeID', y='OrderCount', title='Orders Handled by Employees', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})
show_to_user(fig)","The input code executes an SQL query to count orders per employee, sorts the results, and displays the top employee with the most orders, fulfilling the business request. Although it does more by visualizing the entire result, it correctly identifies the employee with the most orders, matching the reference implementation's outcome.",Base
Calculate the average lead time for each supplier in delivered products. (Include data visualization for more detailed insights),"import pandas as pd
import plotly.express as px

# SQL Query to calculate the average lead time for each supplier in delivered products.
sql_query = '''
SELECT suppliers.SupplierID, CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, CompanyName;
'''

# Execute the SQL query using the provided function, which returns a pandas dataframe.
supplier_lead_time_df = execute_sql_query(sql_query)

# Ensure the dataframe columns are correctly typed
dtype_corrected_supplier_lead_time_df = supplier_lead_time_df.copy()
dtype_corrected_supplier_lead_time_df['AverageLeadTime'] = dtype_corrected_supplier_lead_time_df['AverageLeadTime'].astype(float)

# Display the dataframe to the user using the provided function.
show_to_user(dtype_corrected_supplier_lead_time_df)

# Create a bar chart to visualize the average lead time for each supplier.
fig = px.bar(dtype_corrected_supplier_lead_time_df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier', labels={'CompanyName': 'Supplier', 'AverageLeadTime': 'Average Lead Time (days)'} )

# Show the plot to the user using the provided function.
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average lead time for each supplier
sql_query = '''
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT od.ProductID FROM [Order Details] od WHERE od.OrderID = o.OrderID)
WHERE o.ShippedDate IS NOT NULL
GROUP BY s.SupplierID, s.CompanyName
ORDER BY AverageLeadTime;
'''  

# Execute the SQL query
lead_time_df = execute_sql_query(sql_query)

# Visualization of average lead time per supplier
fig = px.bar(lead_time_df, x='CompanyName', y='AverageLeadTime',
             title='Average Lead Time for Each Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier Company'})

# Show the results to the user
show_to_user(fig)","The input code calculates the average lead time for each supplier similarly to the reference code by executing a SQL query and visualizing the results with a bar chart. Although there is a slight difference in how `Order Details` are joined, it still effectively groups by supplier and calculates the average lead time, achieving the same outcome.","
import plotly.express as px

# Step 1: Define the SQL query to get the average lead time for each supplier
sql_query = '''
SELECT products.SupplierID, AVG(DATEDIFF(day, orders.OrderDate, orders.ShippedDate)) AS AverageLeadTime 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID
'''

# Step 2: Execute the SQL query
results_df = execute_sql_query(sql_query)

# Step 3: Data Visualization using Plotly
fig = px.bar(results_df, x='SupplierID', y='AverageLeadTime', title='Average Lead Time per Supplier', labels={'SupplierID': 'Supplier ID', 'AverageLeadTime': 'Average Lead Time (days)'})

# Step 4: Display the plot
show_to_user(fig)
","The evaluated code correctly calculates the average lead time per supplier but omits the supplier's company name in the SQL query and result. The reference code includes the supplier's company name, which is crucial for identification beyond SupplierID alone.",Base
What is the average discount given in orders for the year 2023?,"import pandas as pd

# SQL query to get the average discount for orders in the year 2023
sql_query = (""SELECT AVG([Order Details].Discount) AS avg_discount ""
             ""FROM [Order Details] ""
             ""JOIN orders ON [Order Details].OrderID = orders.OrderID ""
             ""WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'"")

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the average discount value from the dataframe
avg_discount = result_df['avg_discount'][0]

# Prepare a dataframe to display to the user
output_df = pd.DataFrame({'Average Discount': [avg_discount]})

# Display the result to the user
show_to_user(output_df)","import pandas as pd

# SQL query to calculate the average discount given in orders for the year 2023
sql_query = """"""
SELECT AVG([Order Details].Discount) AS average_discount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and fetch the result into a pandas dataframe
average_discount_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_discount_df)","The input code correctly computes the average discount for orders in 2023. It uses the same SQL query logic to calculate the average discount, and both implementations fetch and display the result using the utility functions. The output column name difference does not affect the correctness.","import pandas as pd

# Define the SQL query
discount_query = '''
SELECT AVG([Order Details].Discount) AS avg_discount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE YEAR(orders.OrderDate) = 2023
'''

# Execute the SQL query
discount_df = execute_sql_query(discount_query)

# Extract the average discount from the dataframe
avg_discount = discount_df.loc[0, 'avg_discount']

# Convert the single value to a dataframe to match the expected input type for show_to_user
display_df = pd.DataFrame({'Average Discount for 2023': [avg_discount]})

# Display the result
show_to_user(display_df)","The input code correctly calculates the average discount for orders in 2023 by joining the 'orders' and '[Order Details]' tables and filtering by the year. It uses 'YEAR(orders.OrderDate) = 2023' to achieve the same filter condition as the reference code's 'WHERE orders.OrderDate BETWEEN' statement. Both implementations select the average discount and display the result, effectively answering the business analytic request.",Base
What is the average order fulfillment time by month? (Include a line chart for monthly trends),"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgOrderFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query to get the data
orders_data = execute_sql_query(sql_query)

# Make sure the 'Month' column is treated as a datetime object for correct plotting
orders_data['Month'] = pd.to_datetime(orders_data['Month'], format='%Y-%m')

# Create a line chart using plotly express
fig = px.line(orders_data, x='Month', y='AvgOrderFulfillmentTime', title='Average Order Fulfillment Time by Month')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average order fulfillment time by month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month,
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY month
ORDER BY month;
""""""

# Execute the SQL query
fulfillment_data = execute_sql_query(sql_query)

# Create the line chart for average order fulfillment time by month
fig = px.line(fulfillment_data, x='month', y='avg_fulfillment_time',
              title='Average Order Fulfillment Time by Month',
              labels={'month': 'Month', 'avg_fulfillment_time': 'Avg Fulfillment Time (Days)'} )

# Show the data and visualization to the user
show_to_user(fig)","The input Python code successfully calculates the average order fulfillment time by month and generates a line chart, matching the business analytic request. Both the input and reference code achieve the same outcome, with minor differences such as column names. The input code additionally filters out rows where 'ShippedDate' is NULL, ensuring more accurate results.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM orders 
GROUP BY DATE_FORMAT(orders.OrderDate, '%Y-%m')
""""""

# Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# Ensure that the 'month' column is treated as a datetime type
orders_df['month'] = pd.to_datetime(orders_df['month'], format='%Y-%m')

# Sort the dataframe by 'month'
orders_df.sort_values('month', inplace=True)

# Create a line chart for the average order fulfillment time by month
fig = px.line(orders_df, x='month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time by Month', 
              labels={'month': 'Month', 'avg_fulfillment_time': 'Average Fulfillment Time (days)'})

# Display the line chart to the user
show_to_user(fig)","The input code correctly calculates the average order fulfillment time by month and generates a line chart similar to the reference implementation. It handles the SQL query execution, processes the data into a DataFrame, converts the 'month' column to datetime, sorts by 'month', and generates the line chart using Plotly Express. The operations in the input code achieve the same outcome as the reference code, addressing the business analytic request as required.",Base
What is the total revenue generated by each employee? (Include a bar chart to visualize the revenue distribution),"import plotly.express as px

# SQL query to calculate total revenue by each employee
sql_query = '''
SELECT EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY EmployeeID;
'''

# Execute the SQL query
revenue_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue distribution
fig = px.bar(revenue_df, x='EmployeeID', y='TotalRevenue', title='Total Revenue by Employee', labels={'EmployeeID': 'Employee ID', 'TotalRevenue': 'Total Revenue'})

# Display the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue generated by each employee
sql_query = '''
SELECT o.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders AS o
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY o.EmployeeID
'''

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Visualize the revenue distribution
fig = px.bar(revenue_data, x='EmployeeID', y='TotalRevenue', title='Total Revenue Generated by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalRevenue': 'Total Revenue'})

# Show visualization to user
show_to_user(fig)","The input Python code correctly calculates the total revenue generated by each employee using a SQL query. It then visualizes the revenue distribution with a bar chart using Plotly, matching the intended outcome of the business analytic request and reference implementation, despite minor differences in style and naming.","import plotly.express as px

# SQL query string
sql_query = '''
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Ensure the SQL result is loaded into the dataframe correctly
result_df.columns = ['EmployeeID', 'TotalSales']

# Create a bar chart to visualize the revenue distribution
fig = px.bar(result_df, x='EmployeeID', y='TotalSales', title='Total Revenue Generated by Each Employee', labels={'TotalSales': 'Total Sales ($)', 'EmployeeID': 'Employee ID'})

# Display the bar chart to the user
show_to_user(fig)","The input Python code correctly executes an SQL query to calculate the total revenue generated by each employee, similar to the reference code. It performs the same joins and sum operation to compute revenue, although it retrieves data from 'employees' instead of directly from 'orders'. The result is plotted using a bar chart with plotly, which fulfills the visualization requirement. The slight variation in column naming ('TotalSales' vs 'TotalRevenue') does not affect the correctness since the business requirement is addressed effectively.",Base
Find the total freight cost incurred in the year 2023.,"import pandas as pd

# Define the SQL query to find the total freight cost for the year 2023
sql_query = ""SELECT SUM(Freight) AS TotalFreightCost2023 FROM orders WHERE YEAR(OrderDate) = 2023;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total freight cost value from the result
TotalFreightCost2023 = result_df['TotalFreightCost2023'].iloc[0]

# Display the total freight cost to the user
show_to_user(pd.DataFrame({'TotalFreightCost2023': [TotalFreightCost2023]}))","import pandas as pd

# SQL query to get the total freight cost for the year 2023
sql_query = """"""
SELECT SUM(Freight) AS TotalFreightCost
FROM orders
WHERE YEAR(OrderDate) = 2023
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The evaluated code correctly executes the SQL query to find the total freight for the year 2023. It does not rename the column but captures the necessary sum, which is equivalent to the reference implementation. The key requirement—retrieving the total freight for 2023—is satisfied, and the result is displayed using the provided utility function.","import pandas as pd
import plotly.express as px

# 1. Define the SQL query
sql_query = """"""
SELECT SUM(orders.Freight) AS total_freight_cost 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31';
""""""

# 2. Execute the SQL query
df = execute_sql_query(sql_query)

# 3. Since the result will only contain one value, extract that value
total_freight_cost = df.iloc[0]['total_freight_cost']

# 4. Create a DataFrame for display purposes
display_df = pd.DataFrame({'total_freight_cost': [total_freight_cost]})

# 5. Display the result to the user
show_to_user(display_df)","The input Python code correctly calculates the total freight cost for the year 2023. It uses a SQL query with an appropriate condition for the date range, executes the query, extracts the result, and then displays it, thus fulfilling the business analytic request.",Base
Identify which month has the highest number of orders historically. (Include a bar chart for monthly comparisons),"import pandas as pd
import plotly.express as px

# SQL query to identify monthly order counts
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m') 
ORDER BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query to get the monthly order data
df = execute_sql_query(sql_query)

# Determine the month with the highest number of orders
highest_order_month = df.loc[df['OrderCount'].idxmax()]

# Display the month with the highest order count
show_to_user(pd.DataFrame([highest_order_month]))

# Generate a bar chart for monthly comparisons
fig = px.bar(df, x='Month', y='OrderCount', title='Monthly Order Counts', labels={'Month': 'Month', 'OrderCount': 'Order Count'})

# Show bar chart to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve orders data grouped by month
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY Month
ORDER BY Month
'''

# Execute the SQL query and get the result into a dataframe
orders_df = execute_sql_query(sql_query)

# Identify the month with the highest number of orders
max_orders_month = orders_df.loc[orders_df['NumberOfOrders'].idxmax()]

# Create a bar chart for monthly comparisons
fig = px.bar(orders_df, x='Month', y='NumberOfOrders',
             title='Monthly Orders Comparison',
             labels={'Month': 'Month', 'NumberOfOrders': 'Number of Orders'})

# Display the results
show_to_user(fig)

# Print the month with the highest number of orders
print(f'The month with the highest number of orders is: {max_orders_month[",The input code is missing the statement to display or return the month with the highest number of orders. The print statement is incomplete and should output the result.,"# Import necessary libraries
import plotly.express as px
import pandas as pd

# SQL query to fetch month with the highest number of orders historically
sql_query = '''
SELECT MONTH(OrderDate) AS Month, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY MONTH(OrderDate) 
ORDER BY OrderCount DESC;
'''

# Execute the SQL query and retrieve the data

order_data = execute_sql_query(sql_query)

# Visualize the result with a bar chart
fig = px.bar(order_data, x='Month', y='OrderCount', title='Monthly Orders Comparison')

# Show the result to the user
show_to_user(fig)","The input code groups by the numeric month value (1-12), not by year-month, which can aggregate data incorrectly across multiple years. This approach can misrepresent the actual month with the highest order count. The reference implementation correctly groups data by year-month and finds the peak month accordingly.",None
Calculate the average number of products per order.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG(od.Quantity) AS AverageProductsPerOrder FROM [Order Details] od;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to retrieve the necessary data
sql_query = '''
SELECT o.OrderID, COUNT(od.ProductID) AS ProductCount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.OrderID
'''

# Execute the SQL query and get the data as a DataFrame
order_data = execute_sql_query(sql_query)

# Calculate the average number of products per order
average_products_per_order = order_data['ProductCount'].mean()

# Create a DataFrame to display the result
result_df = pd.DataFrame({'Average Products per Order': [average_products_per_order]})

# Display the result to the user
show_to_user(result_df)","The input code calculates the average number of products per order correctly. Both the input and reference implementations achieve the same outcome of determining the average products per order, albeit through different query approaches and calculations.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT AVG(Quantity) AS AverageProductPerOrder FROM [Order Details];'

# Execute the SQL query to retrieve the result
result_df = execute_sql_query(sql_query)

# Extract the average product per order value
average_product_per_order = result_df['AverageProductPerOrder'].iloc[0]

# Prepare the output dataframe
output_df = pd.DataFrame({'AverageProductPerOrder': [average_product_per_order]})

# Display the result to the user
show_to_user(output_df)","The input code correctly calculates the average number of products per order. It executes an SQL query to find the average quantity from the 'Order Details', extracts the result, and displays it using the provided utility functions. The difference in column name ('AverageProductPerOrder' vs. 'AverageProductsPerOrder') does not impact the correctness of the result.",Base
Which product has the highest total sales in 2022?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID
ORDER BY total_sales DESC
LIMIT 1
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","import pandas as pd

# SQL query to retrieve total sales by product for the year 2022
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID
ORDER BY total_sales DESC
LIMIT 1
""""""

# Execute the SQL query and get the results in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code successfully retrieves the product with the highest total sales for 2022. It implements the same SQL logic as the reference code and uses the correct utility functions to execute the query and display the result. Differences in style, such as variable naming, do not affect the correctness of the solution.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = 2022
GROUP BY od.ProductID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Clean the result to ensure it's a single row
if result_df.empty:
    raise ValueError('No data found for the year 2022')

# Display the result to the user
show_to_user(result_df)
","The input code correctly calculates the total sales for each product in 2022 and orders them to find the highest one, similarly to the reference implementation. Both codes ensure that the data is grouped and limited to the necessary date range. The SQL queries achieve the same outcome despite slight differences in syntax.",Base
How many orders were placed in each quarter of 2022? (Include a bar chart for quarterly comparisons),"import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT QUARTER(orders.OrderDate) AS order_quarter, COUNT(orders.OrderID) AS total_orders
FROM orders
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY order_quarter
'''

# Step 2: Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart for quarterly comparisons
fig = px.bar(orders_df, x='order_quarter', y='total_orders', title='Orders Placed per Quarter in 2022', labels={'order_quarter': 'Quarter', 'total_orders': 'Total Orders'})

# Step 4: Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to count orders placed in each quarter of 2022
sql_query = '''
SELECT 
    QUARTER(OrderDate) AS quarter,
    COUNT(OrderID) AS order_count
FROM 
    orders
WHERE 
    OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY 
    QUARTER(OrderDate)
ORDER BY 
    quarter
'''  

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# Create a bar chart for quarterly comparisons
fig = px.bar(data, x='quarter', y='order_count', 
             title='Orders Count in Each Quarter of 2022', 
             labels={'quarter': 'Quarter', 'order_count': 'Number of Orders'})

# Show the bar chart to the user
show_to_user(fig)",The input code achieves the same outcome as the reference code. It executes a SQL query to count the number of orders in each quarter of 2022 and creates a bar chart using Plotly to compare quarterly order counts. The differences in variable names ('order_quarter' vs 'quarter' and 'total_orders' vs 'order_count') do not affect the correctness of the solution. Both implementations effectively visualize the number of orders per quarter for 2022 using Plotly and the same SQL execution mechanism.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the number of orders per quarter for the year 2022
sql_query = '''
SELECT 
    CASE 
        WHEN MONTH(OrderDate) BETWEEN 1 AND 3 THEN 'Q1' 
        WHEN MONTH(OrderDate) BETWEEN 4 AND 6 THEN 'Q2' 
        WHEN MONTH(OrderDate) BETWEEN 7 AND 9 THEN 'Q3' 
        WHEN MONTH(OrderDate) BETWEEN 10 AND 12 THEN 'Q4' 
    END AS Quarter, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = 2022 
GROUP BY 
    Quarter;'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Creating bar chart for quarterly comparisons
fig = px.bar(orders_df, x='Quarter', y='OrderCount', title='Orders Placed in Each Quarter of 2022', labels={'OrderCount': 'Number of Orders', 'Quarter': 'Quarter of 2022'})

# Displaying the bar chart to the user
show_to_user(fig)
","The input code correctly queries the number of orders placed in each quarter of 2022, using an equivalent SQL query to determine the quarter. It successfully groups the data by quarter and uses Plotly to generate a bar chart, fulfilling the business analytic request and matching the reference implementation's outcome.",Base
How many unique customers placed orders in the last quarter?,"import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS unique_customers
FROM orders 
WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE());
""""""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_result)","import pandas as pd

# Define the start and end dates for the last quarter
from datetime import datetime, timedelta  

end_date = datetime.now() - timedelta(days=datetime.now().day)  # Last day of the previous month
start_date = end_date - timedelta(days=90)  # 90 days back from end date

# SQL query to fetch unique customers who placed orders in the last quarter
sql_query = f""""""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""

# Execute the SQL query and get the result as a DataFrame
unique_customers_df = execute_sql_query(sql_query)

# Count unique customers
unique_customer_count = unique_customers_df.shape[0]

# Display the result to the user
result_df = pd.DataFrame({'Unique Customer Count': [unique_customer_count]})
show_to_user(result_df)","The input code calculates the start and end dates incorrectly for the last quarter, as it assumes a quarter is always 90 days. This may not accurately reflect calendar quarters. The reference code uses SQL date functions to correctly identify the last 3 months.","import pandas as pd

# SQL query to find the number of unique customers who placed orders in the last quarter
date_range_query = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS UniqueCustomers
FROM orders
WHERE orders.OrderDate >= CURDATE() - INTERVAL 3 MONTH;
""""""

# Execute the SQL query
result_df = execute_sql_query(date_range_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly counts the unique customers who placed orders in the last 3 months, which aligns with the business request and reference implementation.",Finetuned
What are the top three products that generate the most sales revenue? (Include a bar chart for better visualization),"import plotly.express as px
import pandas as pd

# SQL query to fetch the top three products that generate the most sales revenue
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Safety check to ensure the DataFrame is not empty before plotting
if not result_df.empty:
    # Create a bar chart for better visualization
    fig = px.bar(result_df, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue')
    
    # Display the result to the user
    show_to_user(fig)
else:
    show_to_user(""No data found."")","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales revenue per product
sql_query = '''
SELECT [Order Details].ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY [Order Details].ProductID
ORDER BY TotalRevenue DESC
LIMIT 3;
''' 

# Execute the SQL query and store the result in a DataFrame
top_products = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(top_products, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue', labels={'ProductID': 'Product ID', 'TotalRevenue': 'Total Revenue'})

# Display the result to the user
show_to_user(fig)",The input code correctly retrieves the top three products generating the most sales revenue by executing an appropriate SQL query. It correctly uses the same calculation as the reference implementation for revenue. It also creates a bar chart using Plotly and displays it using the utility function. The join with the 'orders' table does not alter the outcome relevant to the request.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT TOP 3 p.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
INNER JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID
ORDER BY TotalRevenue DESC;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart with plotly
fig = px.bar(result_df, x='ProductID', y='TotalRevenue', title='Top 3 Products by Sales Revenue', labels={'ProductID': 'Product ID', 'TotalRevenue': 'Total Revenue'})

# Show the bar chart to the user
show_to_user(fig)","The input Python code successfully addresses the business analytic request by executing a SQL query that calculates the top three products with the highest sales revenue. It then creates a bar chart using Plotly for visualization. The key logic and steps align with the reference implementation, despite minor differences in SQL syntax (using INNER JOIN versus direct selection). The outcome achieved is consistent with the expected results.",Base
What are the names of products that have been discontinued?,"import pandas as pd

# Define the SQL query to retrieve names of discontinued products
sql_query = 'SELECT ProductName FROM products WHERE Discontinued = 1;'

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(products_df)","import pandas as pd

# SQL query to fetch names of products that have been discontinued
sql_query = """"""
SELECT ProductName
FROM products
WHERE Discontinued = 1
""""""

# Execute the SQL query and get the data as a DataFrame
discontinued_products_df = execute_sql_query(sql_query)

# Show the resulting DataFrame to the user
show_to_user(discontinued_products_df)","The input code correctly executes a SQL query to retrieve the names of discontinued products from the 'products' table. It uses the 'execute_sql_query' function to obtain the data as a DataFrame and then displays it using 'show_to_user', matching the logic of the reference implementation.","import pandas as pd

# SQL query to get the names of products that have been discontinued
sql_query = 'SELECT ProductName FROM products WHERE Discontinued = 1;'

# Execute the query and retrieve the data
products_df = execute_sql_query(sql_query)

# Display the list of discontinued products to the user
show_to_user(products_df)","The input code correctly executes the same SQL query to find names of discontinued products and displays the result using the given utility functions, matching the reference implementation in functionality.",Base
Which supplier has supplied the most quantity of products? Please include a bar chart to visualize the quantities supplied by each supplier.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SupplierID, SUM(UnitsOnOrder) AS TotalQuantitySupplied 
FROM products 
GROUP BY SupplierID 
ORDER BY TotalQuantitySupplied DESC
""""""

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities supplied by each supplier
fig = px.bar(df, x='SupplierID', y='TotalQuantitySupplied', title='Quantity Supplied by Each Supplier', labels={'SupplierID': 'Supplier ID', 'TotalQuantitySupplied': 'Total Quantity Supplied'})

# Display the result to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Step 1: Retrieve total quantity supplied by each supplier
sql_query = '''
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalQuantity DESC
'''  

# Execute the SQL query
supplier_quantity_df = execute_sql_query(sql_query)

# Step 2: Identify the supplier with the maximum quantity
max_supplier = supplier_quantity_df.iloc[0]
max_supplier_id = max_supplier['SupplierID']
max_quantity = max_supplier['TotalQuantity']

# Step 3: Visualization of quantities supplied by all suppliers
fig = px.bar(supplier_quantity_df, x='SupplierID', y='TotalQuantity', 
             title='Total Quantity Supplied by Each Supplier', 
             labels={'SupplierID': 'Supplier ID', 'TotalQuantity': 'Total Quantity Supplied'})

# Show the result to the user
show_to_user(fig)

# Display the supplier with the most quantity supplied
max_supplier_info = pd.DataFrame({'SupplierID': [max_supplier_id], 'TotalQuantity': [max_quantity]})
show_to_user(max_supplier_info)","The input code fulfills the business analytic request by calculating the total quantity supplied by each supplier and creating a bar chart for visualization. It also identifies the supplier with the maximum quantity. Although it joins with a different table than the reference code, it effectively answers the question and achieves the same outcome.","import plotly.express as px
import pandas as pd

# Execute the query to retrieve the total quantity of products supplied by each supplier
sql_query = '''
SELECT suppliers.SupplierID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID 
ORDER BY TotalQuantity DESC 
'''

# Get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Ensure the dataframe is sorted to display the supplier with the most quantity supplied at the top
df_sorted = df.sort_values(by='TotalQuantity', ascending=False)

# Create the bar chart using plotly
fig = px.bar(df_sorted, x='SupplierID', y='TotalQuantity', title='Quantities Supplied by Each Supplier', labels={'SupplierID': 'Supplier ID', 'TotalQuantity': 'Total Quantity Supplied'})

# Display the bar chart to the user
show_to_user(fig)

# Find the supplier with the most quantity supplied
top_supplier = df_sorted.iloc[0]

top_supplier_id = top_supplier['SupplierID']
top_supplier_quantity = top_supplier['TotalQuantity']

# Display the top supplier info to the user in a dataframe format
top_supplier_df = pd.DataFrame({'SupplierID': [top_supplier_id], 'TotalQuantity': [top_supplier_quantity]})
show_to_user(top_supplier_df)
","The input code correctly retrieves and visualizes the total quantities supplied by each supplier, similar to the reference code. Additionally, it identifies the top supplier, which is an extra step that fulfills the analytic request more precisely.",Base
Determine the average discount given by each employee. Please include a bar chart to illustrate the average discounts given by each employee.,"import pandas as pd
import plotly.express as px

# SQL query to determine the average discount given by each employee
sql_query = '''
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;'''

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using plotly to illustrate the average discounts given by each employee
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', title='Average Discount Given by Each Employee', labels={'EmployeeID': 'Employee ID', 'AvgDiscount': 'Average Discount'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to get the discounts per employee
sql_query = '''
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, EmployeeName
'''  

# Execute the SQL query
average_discounts_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discounts
fig = px.bar(
    average_discounts_df,
    x='EmployeeName',
    y='AverageDiscount',
    title='Average Discount Given by Each Employee',
    labels={'AverageDiscount': 'Average Discount', 'EmployeeName': 'Employee'}
)

# Show the result to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by calculating the average discount per employee. It includes a bar chart to illustrate the average discounts given. The use of additional employee name information is an enhancement, not a deviation from the request.","import pandas as pd
import plotly.express as px

# SQL query to get the average discount given by each employee
sql_query = '''
SELECT employees.EmployeeID, AVG([Order Details].Discount) AS AverageDiscount
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID;
'''

# Execute the query and retrieve the data
employee_discounts_df = execute_sql_query(sql_query)

# Ensure the dataframe has the necessary columns
if 'EmployeeID' in employee_discounts_df.columns and 'AverageDiscount' in employee_discounts_df.columns:
    # Create a bar chart to illustrate the average discounts given by each employee
    fig = px.bar(employee_discounts_df, x='EmployeeID', y='AverageDiscount', 
                 title='Average Discounts Given by Each Employee',
                 labels={'EmployeeID': 'Employee ID', 'AverageDiscount': 'Average Discount'})
    # Show the result to the user
    show_to_user(fig)
else:
    print(""Dataframe does not contain the required columns."")","The input code achieves the same outcome as the reference implementation. It correctly calculates the average discount given by each employee using a SQL query and creates a bar chart using Plotly, matching the business analytic request. The column names in the SQL query differ slightly but do not affect the core functionality or output.",Base
Which month had the highest number of orders placed? Please include a line chart to visualize the number of orders per month.,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the number of orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m') 
""""""

# Execute the SQL query to get the data into a pandas dataframe
orders_per_month_df = execute_sql_query(sql_query)

# Find the month with the highest number of orders placed
max_orders_month_df = orders_per_month_df.sort_values('OrderCount', ascending=False).head(1)

# Create a line chart to visualize the number of orders per month
fig = px.line(orders_per_month_df, x='Month', y='OrderCount', title='Number of Orders Per Month')

# Display the data analysis and visualization result to the user
show_to_user(max_orders_month_df)
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Retrieve order data from the database
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY Month
ORDER BY TotalOrders DESC
""""""
df_orders = execute_sql_query(sql_query)

# Step 2: Identify the month with the highest number of orders
highest_orders_month = df_orders.iloc[0]

# Step 3: Create the line chart to visualize the total number of orders per month
fig = px.line(df_orders, x='Month', y='TotalOrders', title='Total Number of Orders per Month')
show_to_user(fig)

# Display the month with the highest orders
show_to_user(highest_orders_month)","The input code successfully retrieves the number of orders per month, identifies the month with the highest orders, and creates a line chart for visualization. It achieves the same outcome as the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the number of orders per month
sql_query = ""SELECT YEAR(OrderDate) AS Year, MONTH(OrderDate) AS Month, COUNT(*) AS OrderCount FROM orders GROUP BY YEAR(OrderDate), MONTH(OrderDate);""

# Execute the SQL query using the provided utility function and get the result into a DataFrame
orders_per_month_df = execute_sql_query(sql_query)

# Create a 'YearMonth' column for better plotting
orders_per_month_df['YearMonth'] = orders_per_month_df['Year'].astype(str) + '-' + orders_per_month_df['Month'].astype(str)

# Create the line chart using Plotly
fig = px.line(orders_per_month_df.sort_values(by=['Year', 'Month']), x='YearMonth', y='OrderCount', title='Number of Orders per Month')

# Display the line chart to the user using the provided utility function
show_to_user(fig)

# To show which month had the highest number of orders, we need to calculate the exact month
max_order_month_query = ""SELECT YEAR(OrderDate) AS Year, MONTH(OrderDate) AS Month, COUNT(*) AS OrderCount FROM orders GROUP BY YEAR(OrderDate), MONTH(OrderDate) ORDER BY OrderCount DESC LIMIT 1;""
max_order_month_df = execute_sql_query(max_order_month_query)

# Display the month with the highest number of orders to the user
show_to_user(max_order_month_df)","The input code correctly identifies the month with the highest number of orders and creates a line chart to visualize the number of orders per month, achieving the outcome as described in the business analytic request. The different approach used, such as adding a 'YearMonth' column and executing two separate queries, still effectively answers the question.",Base
Retrieve the contact information for all suppliers located in a specific region.,"import pandas as pd
import plotly.express as px

# Define the specified region for the query
specified_region = 'YourRegionHere'

# SQL query to retrieve supplier contact information in the specified region
sql_query = f""""""
SELECT SupplierID, CompanyName, ContactName, Phone, City, Region 
FROM suppliers 
WHERE Region = '{specified_region}'
""""""

# Execute the SQL query and retrieve the data in a pandas dataframe
supplier_data = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(supplier_data)","region = 'SpecificRegion'  # Specify the desired region

# SQL query to retrieve contact information for all suppliers in the specified region
sql_query = f""""""
SELECT SupplierID, CompanyName, ContactName, ContactTitle, Address, City, Region, PostalCode, Country, Phone, Fax, HomePage 
FROM suppliers 
WHERE Region = '{region}'
""""""  

# Execute the SQL query to get the results in a DataFrame
supplier_data = execute_sql_query(sql_query)  

# Show the retrieved supplier contact information to the user
show_to_user(supplier_data)  
","The input code fulfills the business analytic request by querying supplier information for a specific region. Although the columns retrieved are more comprehensive, the essential contact information is included, and the approach aligns with the reference implementation's objective.","import pandas as pd

# Define the query string for retrieving contact information for suppliers in a specific region
# For demonstration, we’ll use 'USA' as the region. This should be replaced with actual parameters.

region = 'USA'
sql_query = f""""""
SELECT S.SupplierID, S.CompanyName, S.ContactName, S.ContactTitle, S.Address, S.City, S.Region, S.PostalCode, S.Country 
FROM suppliers S 
WHERE S.Region = '{region}';
""""""

# Execute the query using the provided function
suppliers_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(suppliers_df)","The input code successfully retrieves supplier contact information for suppliers in a specific region, as specified in the business request. It constructs an SQL query filtering by the 'Region', executes the query, and displays the resulting dataframe. Though it retrieves additional fields, the code effectively addresses the business analytic request, achieving the same outcome as the reference implementation.",Base
Calculate the discount amount for each order in January 2023.,"import pandas as pd
import plotly.express as px

# SQL Query to calculate discount amount for each order in January 2023
sql_query = '''
SELECT o.OrderID, SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY o.OrderID;
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_df)","import pandas as pd

# SQL query to retrieve orders and their discounts for January 2023
sql_query = """"""
SELECT o.OrderID, od.UnitPrice, od.Quantity, od.Discount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate < '2023-02-01'
""""""

# Execute SQL query to get the data
orders_data = execute_sql_query(sql_query)

# Calculate the discount amount for each order
orders_data['DiscountAmount'] = orders_data['UnitPrice'] * orders_data['Quantity'] * orders_data['Discount']

# Group by OrderID to sum the discount amount for each order
result = orders_data.groupby('OrderID')['DiscountAmount'].sum().reset_index()

# Show the result to the user
show_to_user(result)","The input code correctly calculates the discount amount for each order in January 2023. It retrieves the necessary data, computes the discount amount for each item line, and then sums up the discount amounts for each order. This approach achieves the same outcome as the reference implementation despite differences in code organization.","import pandas as pd
import plotly.express as px

# SQL query to get the order discount amounts for January 2023
sql_query = '''
SELECT o.OrderID, SUM(od.UnitPrice * od.Quantity * od.Discount) AS DiscountAmount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY o.OrderID;
'''

# Execute the SQL query and fetch the result
# The result will be a pandas DataFrame
order_discounts_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(order_discounts_df)

# Optional: Visualize the discount amounts using Plotly
fig = px.bar(order_discounts_df, x='OrderID', y='DiscountAmount', title='Discount Amount for Each Order in January 2023')

# Show the plotly figure to the user
show_to_user(fig)","The input Python code accurately executes the SQL query to calculate the discount amount for each order in January 2023. The query structure and logic match the reference implementation. Additionally, the input code includes a plotly visualization of the results, which is an optional but valid extension. The use of 'execute_sql_query' and 'show_to_user' follows the constraints.",Base
What are the total sales by month? Please include a line chart to illustrate the total sales per month.,"import pandas as pd
import plotly.express as px

# SQL query to fetch total sales by month
sql_query = '''
SELECT YEAR(o.OrderDate) AS Year, 
       MONTH(o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
INNER JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
GROUP BY YEAR(o.OrderDate), MONTH(o.OrderDate) 
ORDER BY Year, Month;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate a 'Year-Month' column
df['Year-Month'] = df['Year'].astype(str) + '-' + df['Month'].astype(str)

# Create a line chart using plotly
fig = px.line(df, x='Year-Month', y='TotalSales', title='Total Sales by Month', labels={'Year-Month': 'Year-Month', 'TotalSales': 'Total Sales'})

# Show the figure to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales by month
sql_query = '''
SELECT
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM
    orders
JOIN
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY
    month
ORDER BY
    month;
'''

# Execute the query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(sales_data, x='month', y='total_sales', title='Total Sales by Month', labels={'total_sales': 'Total Sales', 'month': 'Month'})

# Show the result to the user
show_to_user(fig)","The input code successfully calculates the total sales by month and generates a line chart using Plotly. It addresses the business analytic request by providing the total sales per month and visualizing it in a line chart, which matches the desired outcome of the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales by month
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
INNER JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Month;
""""""

# Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Process the 'Month' column to ensure correct datetime formatting for better plotting
sales_data['Month'] = pd.to_datetime(sales_data['Month'], format='%Y-%m')

# Create a line chart to illustrate the total sales per month
fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales by Month', labels={'Month': 'Month', 'TotalSales': 'Total Sales'})

# Show the chart to the user
show_to_user(fig)","The input code correctly calculates total sales by month using a SQL query and formats the 'Month' column for plotting. It creates a line chart with plotly, fulfilling the requirement to visualize total sales per month. Although it uses a date format function instead of separate year and month fields, the outcome aligns with the analytic request and reference.",Base
Which category has the highest number of products? Please include a bar chart to visualize the number of products in each category.,"import pandas as pd
import plotly.express as px

# SQL query to get the count of products per category
corrected_sql = ""SELECT CategoryID, COUNT(ProductID) AS NumberOfProducts FROM products GROUP BY CategoryID;""

# Execute the SQL query to get the data
df_products = execute_sql_query(corrected_sql)

# Find the category with the highest number of products
category_with_max_products = df_products.loc[df_products['NumberOfProducts'].idxmax()]

# Plot the bar chart for the number of products in each category
fig = px.bar(df_products, x='CategoryID', y='NumberOfProducts', title='Number of Products in Each Category')

# Show the results
data_to_show = pd.DataFrame({'CategoryID_with_Max_Products': [category_with_max_products['CategoryID']], 'NumberOfProducts': [category_with_max_products['NumberOfProducts']]})

show_to_user(data_to_show)
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the count of products per category
sql_query = '''
SELECT c.CategoryID, COUNT(p.ProductID) as ProductCount
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID
ORDER BY ProductCount DESC;
'''

# Execute the SQL query
category_product_counts = execute_sql_query(sql_query)

# Find the category with the highest number of products
highest_category = category_product_counts.iloc[0]

# Prepare data for visualization
bar_chart_data = category_product_counts.sort_values(by='ProductCount')

# Create a bar chart
fig = px.bar(bar_chart_data, x='CategoryID', y='ProductCount',
             title='Number of Products in Each Category',
             labels={'CategoryID': 'Category ID', 'ProductCount': 'Number of Products'},
             text='ProductCount')

# Show the visualization to user
show_to_user(fig)","The input code correctly generates a bar chart but fails to explicitly show the category with the highest number of products as a dataframe, unlike the reference implementation.","import plotly.express as px

# Define the SQL query to get the category with the highest number of products
sql_query = 'SELECT CategoryID, COUNT(*) as ProductCount FROM products GROUP BY CategoryID ORDER BY ProductCount DESC;'

# Execute the SQL query and retrieve the data
product_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of products in each category
fig = px.bar(product_data, x='CategoryID', y='ProductCount', title='Number of Products per Category', labels={'CategoryID': 'Category ID', 'ProductCount': 'Number of Products'})

# Display the resultant bar chart to the user
show_to_user(fig)",The input code does not identify and show the category with the highest number of products as specified in the business analytic request. It only displays the bar chart.,None
Which products received the highest total discount? Please include a bar chart to visualize the total discounts received by each product.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Discount) AS TotalDiscount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY TotalDiscount DESC;
'''

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Create the bar chart
fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Total Discounts Received by Each Product', labels={'ProductName': 'Product Name', 'TotalDiscount': 'Total Discount'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total discount per product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalDiscount DESC;
''' 

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Creating a bar chart to visualize total discounts received by each product
fig = px.bar(result_df, x='ProductName', y='TotalDiscount', title='Total Discounts Received by Each Product')

# Show the results to the user
show_to_user(fig)","The input code multiplies the Discount by Quantity, whereas the reference code sums only the Discount. This causes a discrepancy in calculating the TotalDiscount per product. The bar chart logic is correct, but the calculations differ from the reference implementation.","import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT ProductID, SUM(Quantity * UnitPrice * Discount) AS TotalDiscount 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalDiscount DESC;
'''

# Fetch data
df = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(df, x='ProductID', y='TotalDiscount', title='Total Discounts Received by Each Product',
             labels={'ProductID': 'Product ID', 'TotalDiscount': 'Total Discount'})

# Show bar chart to user
show_to_user(fig)","The input code calculates discounts based on ProductID without joining the Products table. It doesn't map ProductID to ProductName, which is necessary for clarity. The SQL query also incorrectly calculates the discount by multiplying Quantity, UnitPrice, and Discount directly, rather than using SUM(Discount). Therefore, it may not match the reference implementation's outcome.",None
Which regions have the highest average order value? Please include a bar chart to visualize the average order value by region.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipRegion, AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ShipRegion 
ORDER BY AverageOrderValue DESC
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(result_df, x='ShipRegion', y='AverageOrderValue',
             title='Average Order Value by Region', labels={'ShipRegion': 'Region', 'AverageOrderValue': 'Average Order Value'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales and count of orders by region
sql_query = '''
SELECT 
    o.ShipRegion, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales, 
    COUNT(DISTINCT o.OrderID) AS OrderCount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.ShipRegion
'''

# Execute the SQL query
region_data = execute_sql_query(sql_query)

# Calculate Average Order Value (AOV) by region
region_data['AverageOrderValue'] = region_data['TotalSales'] / region_data['OrderCount']

# Create a bar chart for the average order value by region
fig = px.bar(region_data, x='ShipRegion', y='AverageOrderValue', 
             title='Average Order Value by Region', 
             labels={'AverageOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})

# Show the plot to user
show_to_user(fig)","The evaluated code correctly calculates the average order value by region by dividing the total sales by the count of orders for each region. It also visualizes these results using a bar chart, which aligns with the business analytic request and achieves the same outcome as the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipRegion, AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS avg_order_value 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipRegion 
ORDER BY avg_order_value DESC;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Sort the DataFrame by avg_order_value in descending order (if not already sorted)
result_df = result_df.sort_values(by='avg_order_value', ascending=False)

# Create a bar chart using plotly
fig = px.bar(result_df, x='ShipRegion', y='avg_order_value', 
             title='Average Order Value by Region', 
             labels={'ShipRegion': 'Region', 'avg_order_value': 'Average Order Value'},
             height=400)

# Display the result
show_to_user(fig)
","The input code effectively executes the same SQL query as the reference code to calculate the average order value by region. It uses a similar plotly bar chart to visualize the results. The variable names and order of some operations differ, but functionality and outcomes remain consistent with the business request.",Base
Identify the top 3 customers by revenue in the last quarter. Please include a bar chart to visualize the revenues of the top 3 customers.,"import pandas as pd
import plotly.express as px

# Define the SQL query to get top 3 customers by revenue in the last quarter
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as Revenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate > DATE_SUB(NOW(), INTERVAL 3 MONTH) 
GROUP BY customers.CustomerID 
ORDER BY Revenue DESC 
LIMIT 3;'''

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Validate if the result_df is not empty and contains expected columns
if not result_df.empty and 'CustomerID' in result_df.columns and 'Revenue' in result_df.columns:
    # Create a bar chart to visualize the revenues of the top 3 customers
    fig = px.bar(result_df, x='CustomerID', y='Revenue', title='Top 3 Customers by Revenue in the Last Quarter', labels={'CustomerID': 'Customer ID', 'Revenue': 'Revenue'})

    # Display the bar chart to the user
    show_to_user(fig)
else:
    print('No data to display or missing expected columns.')","import pandas as pd
import plotly.express as px

# Define the SQL query to get total revenue for each customer in the last quarter
sql_query = '''
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '1 quarter'
AND o.OrderDate < DATE_TRUNC('quarter', CURRENT_DATE)
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalRevenue DESC
LIMIT 3; 
'''

# Execute the SQL query and retrieve the data
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly Express
fig = px.bar(top_customers_df, x='CompanyName', y='TotalRevenue', 
             title='Top 3 Customers by Revenue in Last Quarter',
             labels={'TotalRevenue': 'Revenue', 'CompanyName': 'Customer Name'})

# Show the figure to the user
show_to_user(fig)","The input code correctly identifies the top 3 customers by revenue in the last quarter using a SQL query. The code includes a bar chart visualization using Plotly Express, displaying the companies' names and their corresponding revenues. While the SQL query's date filtering differs slightly from the reference code, it still effectively captures the desired time frame. Overall, the input code meets the business request by producing the correct data output and visualization.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) 
GROUP BY customers.CustomerID 
ORDER BY TotalRevenue DESC 
LIMIT 3
'''

# Step 2: Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart
fig = px.bar(result_df, x='CustomerID', y='TotalRevenue', title='Top 3 Customers by Revenue in the Last Quarter', labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue'})

# Step 4: Display the bar chart
show_to_user(fig)","The evaluated code correctly retrieves the top 3 customers by revenue in the last quarter and generates a bar chart for visualization. The SQL logic matches the reference code, and the display function is used as expected.",Base
What percentage of orders were delivered before the required date in 2022? Please include a pie chart to illustrate the percentage of orders delivered before the required date.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM(CASE WHEN YEAR(OrderDate) = 2022 AND ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(OrderID) AS BeforeRequiredDateRate 
FROM orders 
WHERE YEAR(OrderDate) = 2022
'''

# Execute the query using the provided utility function
orders_df = execute_sql_query(sql_query)

# Calculate the percentage
before_required_date_rate = orders_df['BeforeRequiredDateRate'].iloc[0] * 100

# Create a dataframe for the pie chart
pie_chart_df = pd.DataFrame({
    'Status': ['Before Required Date', 'After Required Date'],
    'Values': [before_required_date_rate, 100 - before_required_date_rate]
})

# Generate the pie chart using plotly
fig = px.pie(pie_chart_df, values='Values', names='Status', title='Percentage of Orders Delivered Before Required Date in 2022')

# Show the pie chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve relevant data for 2022
sql_query = """"""
SELECT 
    COUNT(OrderID) AS TotalOrders, 
    COUNT(CASE WHEN ShippedDate < RequiredDate THEN 1 END) AS EarlyDeliveries 
FROM orders 
WHERE YEAR(OrderDate) = 2022;
""""""

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Calculate the percentages
if order_data['TotalOrders'][0] > 0:
    early_delivery_percentage = (order_data['EarlyDeliveries'][0] / order_data['TotalOrders'][0]) * 100
    late_delivery_percentage = 100 - early_delivery_percentage
else:
    early_delivery_percentage = 0
    late_delivery_percentage = 0

# Prepare data for the pie chart
labels = ['Delivered Early', 'Delivered Late']
values = [early_delivery_percentage, late_delivery_percentage]

# Create a pie chart
fig = px.pie(values=values, names=labels, title='Order Delivery Status in 2022')

# Show the result to the user
show_to_user(fig)","The input code calculates the percentage of orders delivered before the required date in 2022 by counting early deliveries and total orders, then generates a pie chart to illustrate these percentages. This approach achieves the same outcome as the reference code, addressing the business analytic request correctly.","import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31') AS OnTimeDeliveryRate 
FROM orders 
WHERE orders.ShippedDate <= orders.RequiredDate AND orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' '''

# Execute the SQL query to get the OnTimeDeliveryRate
on_time_delivery_df = execute_sql_query(sql_query)

# Extract the on_time_delivery_rate
on_time_delivery_rate = on_time_delivery_df.at[0, 'OnTimeDeliveryRate']

# Calculate the non-delivery rate
non_delivery_rate = 100 - on_time_delivery_rate

# Data for the pie chart
data = {
    'Delivery Status': ['On Time', 'Late'],
    'Percentage': [on_time_delivery_rate, non_delivery_rate]
}

# Create a DataFrame for the pie chart
pie_df = pd.DataFrame(data)

# Create a pie chart using plotly
fig = px.pie(pie_df, names='Delivery Status', values='Percentage', title='Order Delivery Performance in 2022')

# Show the pie chart to the user
show_to_user(fig)","The given input code successfully calculates the percentage of orders delivered on time for the year 2022 and visualizes it using a pie chart. Although there is a difference in the SQL query formulation compared to the reference implementation, both codes achieve the correct calculation and produce a pie chart visualization of the delivery performance. The main difference lies in the label naming and slight variation in SQL syntax, but they effectively answer the business analytic request.",Base
Which supplier has the shortest average lead time in April 2023? Please include a bar chart to visualize the average lead times of suppliers.,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time 
  FROM orders 
  JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
  JOIN products ON [Order Details].ProductID = products.ProductID 
 WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
 GROUP BY products.SupplierID 
 ORDER BY supplier_lead_time ASC 
 LIMIT 1
'''

# Execute the query
result_df = execute_sql_query(sql_query)

# Display the supplier with the shortest average lead time
show_to_user(result_df)

# Bar chart for average lead times of all suppliers
sql_query_all_suppliers = '''
SELECT products.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time 
  FROM orders 
  JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
  JOIN products ON [Order Details].ProductID = products.ProductID 
 WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
 GROUP BY products.SupplierID 
 ORDER BY supplier_lead_time ASC
'''

# Execute the query for all suppliers
all_suppliers_df = execute_sql_query(sql_query_all_suppliers)

# Create bar chart using plotly
fig = px.bar(all_suppliers_df, x='SupplierID', y='supplier_lead_time', title='Average Lead Time of Suppliers in April 2023', labels={'supplier_lead_time':'Average Lead Time (Days)'})

# Show the bar chart
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to get average lead times for each supplier in April 2023.
sql_query = """"""
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time
FROM orders
JOIN products ON orders.ProductID = products.ProductID
WHERE orders.OrderDate >= '2023-04-01' AND orders.OrderDate < '2023-05-01'
GROUP BY products.SupplierID
""""""

# Execute the query and load the results into a DataFrame.
lead_time_df = execute_sql_query(sql_query)

# Find the supplier with the shortest average lead time.
shortest_lead_time_supplier = lead_time_df.loc[lead_time_df['avg_lead_time'].idxmin()]

# Print out the supplier ID and its average lead time.
print(f""Supplier ID with shortest average lead time: {shortest_lead_time_supplier['SupplierID']}, Lead Time: {shortest_lead_time_supplier['avg_lead_time']} days"")

# Visualize the average lead times of all suppliers.
fig = px.bar(lead_time_df, x='SupplierID', y='avg_lead_time', title='Average Lead Time of Suppliers in April 2023',
             labels={'SupplierID': 'Supplier ID', 'avg_lead_time': 'Average Lead Time (days)'})

# Show the plot to the user.
show_to_user(fig)","The input code incorrectly joins 'orders' with 'products' directly on 'ProductID', missing a join with 'Order Details'. This could lead to incorrect results as 'ProductID' is not directly in 'orders'. The reference code includes 'Order Details' for accuracy.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY suppliers.CompanyName 
ORDER BY avg_lead_time ASC 
LIMIT 1
'''

# Execute the SQL query to get the shortest average lead time for April 2023
result_df = execute_sql_query(sql_query)
shortest_lead_time_supplier = result_df.iloc[0]

# Display the result to the user
show_to_user(shortest_lead_time_supplier)

# Now create the SQL query to get all average lead times for visualization
visualization_sql_query = '''
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-04-30' 
GROUP BY suppliers.CompanyName 
ORDER BY avg_lead_time ASC
'''

# Execute the SQL query to get all average lead times for the suppliers
visualization_df = execute_sql_query(visualization_sql_query)

# Create a bar chart to visualize the average lead times of suppliers
fig = px.bar(visualization_df, x='CompanyName', y='avg_lead_time', 
             title='Average Lead Times of Suppliers (April 2023)', 
             labels={'CompanyName': 'Supplier', 'avg_lead_time': 'Average Lead Time (Days)'})

# Display the bar chart to the user
show_to_user(fig)
","The evaluated code correctly calculates the shortest average lead time for suppliers in April 2023 and visualizes the data in a bar chart. It retrieves supplier names instead of IDs, but fulfills the analytic request, achieving the same outcomes as the reference.",Finetuned
Who are the employees reporting to each manager?,"import pandas as pd
import plotly.express as px

# SQL query to get employees reporting to each manager
sql_query = '''
SELECT m.EmployeeID AS ManagerID, m.LastName AS ManagerLastName, m.FirstName AS ManagerFirstName,
       e.EmployeeID AS EmployeeID, e.LastName AS EmployeeLastName, e.FirstName AS EmployeeFirstName
FROM employees e
JOIN employees m ON e.ReportsTo = m.EmployeeID;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Data analysis - Group the dataframe by ManagerID, ManagerLastName, and ManagerFirstName
# Keep track of the employees reporting to each manager
grouped_df = df.groupby(['ManagerID', 'ManagerLastName', 'ManagerFirstName']).apply(lambda x: x[['EmployeeID', 'EmployeeLastName', 'EmployeeFirstName']].to_dict('records')).reset_index()
grouped_df.columns = ['ManagerID', 'ManagerLastName', 'ManagerFirstName', 'EmployeesReporting']

# Display the result to the user
show_to_user(grouped_df)
","sql_query = '''
SELECT 
    m.FirstName AS ManagerFirstName,
    m.LastName AS ManagerLastName,
    e.FirstName AS EmployeeFirstName,
    e.LastName AS EmployeeLastName
FROM 
    employees e
JOIN 
    employees m ON e.ReportsTo = m.EmployeeID
ORDER BY 
    m.LastName, m.FirstName, e.LastName, e.FirstName;
'''  

# Execute the SQL query and get the results in a DataFrame.
employee_manager_df = execute_sql_query(sql_query)

# Show the results to the user.
show_to_user(employee_manager_df)",The input code provides a list of employees and their managers but does not group them by manager. This does not match the intended request or the reference output format.,"import pandas as pd
import plotly.express as px

def get_employees_reporting_to_managers():
    # SQL query to retrieve employees reporting to each manager
    df = execute_sql_query('SELECT e1.* FROM employees e1 JOIN employees e2 ON e1.ManagerID = e2.EmployeeID;')

    # Grouping employees under their managers
    if not df.empty:
        df_grouped = df.groupby('ManagerID').agg(list).reset_index()
        df_grouped.columns = ['ManagerID', 'Employees']

        # Create a visual representation of the managers and their reporting employees
        fig = px.bar(df_grouped, x='ManagerID', y=[df_grouped['Employees'][i] for i in range(len(df_grouped))])
        fig.update_layout(title='Employees Reporting to Each Manager', xaxis_title='Manager ID')

        # Show the visualization to user
        show_to_user(fig)
        
    else:
        show_to_user(pd.DataFrame({'message': ['No data available']}))

# Execute the function to get and show the data
get_employees_reporting_to_managers()","The input code incorrectly uses 'ManagerID' which is not defined in the SQL query or database schema. Additionally, it aggregates all employee columns under each manager without separating employee details. It also incorrectly attempts to plot a bar graph without proper x and y values, which does not address the business analytic request correctly.",None
Find the average discount applied to orders in January 2023. Please include a bar chart to visualize the average discounts applied.,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the average discount
sql_query = ""SELECT AVG(od.Discount) AS AvgDiscount FROM orders o JOIN [Order Details] od ON o.OrderID = od.OrderID WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31';""

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Extract the average discount from the result
avg_discount = result_df['AvgDiscount'][0]

# Create a dataframe for visualization
viz_df = pd.DataFrame({'Month': ['January 2023'], 'AvgDiscount': [avg_discount]})

# Create a bar chart using plotly
fig = px.bar(viz_df, x='Month', y='AvgDiscount', title='Average Discount Applied to Orders in January 2023', labels={'AvgDiscount': 'Average Discount'})

# Display the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve discounts applied to orders in January 2023
sql_query = """"""
SELECT AVG([Order Details].Discount) AS AverageDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= '2023-01-01' AND orders.OrderDate < '2023-02-01'
""""""

# Execute the SQL query to get the average discount
average_discount_df = execute_sql_query(sql_query)

# Check the result
average_discount = average_discount_df['AverageDiscount'].iloc[0]

# Prepare data for visualization
visualization_data = pd.DataFrame({'Month': ['January 2023'], 'Average Discount': [average_discount]})

# Create a bar chart using Plotly
fig = px.bar(visualization_data, x='Month', y='Average Discount', title='Average Discount Applied to Orders in January 2023')

# Display the results to the user
show_to_user(fig)","The input code correctly calculates the average discount for January 2023 using a SQL query and visualizes the result with a Plotly bar chart. Both the SQL query and the visualization steps are aligned with the reference implementation, achieving the same outcome.","import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT AVG([Order Details].Discount) AS AvgDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Extract the average discount value
avg_discount = result_df['AvgDiscount'].iloc[0]

# Create a DataFrame to hold the data for visualization
visual_df = pd.DataFrame({'Month': ['January 2023'], 'AvgDiscount': [avg_discount]})

# Create a bar chart using Plotly
fig = px.bar(visual_df, x='Month', y='AvgDiscount', title='Average Discount Applied to Orders in January 2023')

# Show the bar chart to the user
show_to_user(fig)","The input code successfully computes the average discount for orders in January 2023 using a SQL query and creates a bar chart using Plotly to visualize the result. It performs all necessary steps like the reference implementation, addressing the business analytic request effectively.",Base
Calculate the total sales for employees located in a specific region.,"import pandas as pd
import plotly.express as px

# SQL query to calculate total sales for employees located in a specific region
sql_query = '''
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE e.Region = 'specific region' 
GROUP BY e.EmployeeID;'''

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Check the resulting dataframe
print(sales_data.head())

# Plot the total sales for employees located in the specific region
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Total Sales by Employee in Specific Region')

# Display the plot to the user
show_to_user(fig)","import pandas as pd

# Define the region for which we want to calculate total sales
specific_region = 'YourRegion'  # Replace with the desired region

# SQL query to get total sales for employees in the specific region
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = '{specific_region}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code successfully calculates the total sales for employees located in a specified region using a SQL query that matches the logic of the reference implementation. Although it includes additional employee details such as FirstName and LastName, this does not affect the correctness of the task, which is calculating total sales by EmployeeID. The outcome aligns with the business request and reference code objective.","import pandas as pd
import plotly.express as px

# Define the specific region for which we want to calculate total sales
specific_region = 'YourRegion'  # replace with actual region

# SQL query to calculate total sales for employees located in a specific region
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Region, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = '{specific_region}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName, e.Region;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(sales_data)

# Optional: Visualization using plotly
fig = px.bar(sales_data, x='FirstName', y='TotalSales', title=f'Total Sales by Employee in {specific_region}', labels={'TotalSales': 'Total Sales', 'FirstName': 'Employee First Name'})
show_to_user(fig)",The input code fulfills the business analytic request by executing an SQL query that calculates total sales for employees in a specified region. It includes additional information about the employees (FirstName and LastName) and utilizes a parameterized region. The added employee details and visualization do not affect the correctness concerning the request.,Base
What are the names of all suppliers who are located in Germany?,"import pandas as pd

# Define the SQL query to find suppliers in Germany
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""

# Execute the SQL query and get the results in a Pandas DataFrame
# Assuming execute_sql_query is previously defined function

df_suppliers = execute_sql_query(sql_query)

# Display the retrieved data to the user
show_to_user(df_suppliers[['CompanyName']])","import pandas as pd

# SQL query to fetch names of suppliers located in Germany
sql_query = """"""
SELECT CompanyName 
FROM suppliers 
WHERE Country = 'Germany';
""""""

# Execute the SQL query
result = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result)",The input code successfully executes the SQL query to retrieve names of suppliers located in Germany and displays the result using provided utility functions. The outcome matches the business analytic request and reference implementation.,"import pandas as pd

# SQL query to fetch names of all suppliers located in Germany
sql_query = ""SELECT CompanyName FROM suppliers WHERE Country = 'Germany';""

# Execute the SQL query
suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(suppliers_df)",The input code correctly implements the business logic by executing the same SQL query as the reference code to fetch supplier names from Germany. It then displays the data using the utility function 'show_to_user'. The absence of column selection like in the reference code does not affect the correctness since 'show_to_user' can directly handle the dataframe.,Base
What was the average order value in June 2023?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '2023-06';
'''

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Ensure the result is presented to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to calculate the average order value for June 2023
sql_query = """"""
SELECT AVG(Total_Value) AS Average_Order_Value 
FROM (
    SELECT  
        o.OrderID,  
        SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Total_Value  
    FROM orders o  
    JOIN [Order Details] od ON o.OrderID = od.OrderID  
    WHERE o.OrderDate >= '2023-06-01' AND o.OrderDate < '2023-07-01'  
    GROUP BY o.OrderID
) AS Order_Totals;
""""""  

# Execute the SQL query to get the average order value
average_order_value_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(average_order_value_df)",The input code correctly calculates the average order value for June 2023 by aggregating orders per order ID and then calculating the average of these totals. This approach matches the intent of the reference implementation.,"To calculate the average order value for June 2023, we need to follow these steps:

1. Retrieve all orders from June 2023 using the `OrderDate` field in the `orders` table.
2. Join the `orders` table with the `[Order Details]` table to get the corresponding order details.
3. Calculate the total sales for each order by summing the product of `UnitPrice` and `Quantity` multiplied by `(1 - Discount)`.
4. Calculate the average order value by dividing the total sales by the number of orders.

Here's the Python code to execute these steps:

```python
import pandas as pd
import plotly.express as px

# The SQL query to get the total sales and number of orders in June 2023
sql_query = '''
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales, 
    COUNT( DISTINCT o.OrderID) AS OrderCount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
'''

# Execute the SQL query and get the results as a pandas dataframe
df = execute_sql_query(sql_query)

# Calculate the average order value
df['AverageOrderValue'] = df['TotalSales'] / df['OrderCount']

# Display the result to the user
show_to_user(df[['AverageOrderValue']])
```

### Explanation:

1. **SQL Query**: The SQL query retrieves the total sales and order count for June 2023.
2. **Data Processing**: The calculate average order value is performed by dividing total sales by the order count.
3. **Output**: The result is shown to the user with only the average order value displayed.","Both the reference and input code calculate the average order value for June 2023 correctly by using the same aggregation logic. Although they differ in presentation, both achieve the intended outcome.",Base
Calculate the average freight cost for each customer. Please include a bar chart to visualize the average freight costs for each customer.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT CustomerID, AVG(Freight) AS AvgFreight FROM orders GROUP BY CustomerID;""

# Execute the SQL query and get the results
customer_freight_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average freight costs for each customer
fig = px.bar(customer_freight_df, x='CustomerID', y='AvgFreight', title='Average Freight Cost per Customer')

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Step 1: Execute SQL query to get the average freight costs for each customer
sql_query = '''
SELECT CustomerID, AVG(Freight) AS AverageFreight
FROM orders
GROUP BY CustomerID
'''  
df_avg_freight = execute_sql_query(sql_query)

# Step 2: Create a bar chart to visualize the average freight costs for each customer
fig = px.bar(df_avg_freight, x='CustomerID', y='AverageFreight', 
             title='Average Freight Cost per Customer',
             labels={'AverageFreight': 'Average Freight Cost', 'CustomerID': 'Customer ID'})

# Step 3: Show the bar chart to the user
show_to_user(fig)","The input code calculates the average freight cost per customer and generates a bar chart using Plotly, just like the reference code. It achieves the same outcome by using a similar SQL query and visualization method, despite differences in column naming.","# Import necessary libraries
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT CustomerID, AVG(Freight) AS AverageFreightCost FROM orders GROUP BY CustomerID;'

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Generate the bar chart using plotly
fig = px.bar(result_df, x='CustomerID', y='AverageFreightCost', title='Average Freight Cost per Customer')

# Display the bar chart
show_to_user(fig)","The evaluated code correctly calculates the average freight cost per customer and generates a bar chart using Plotly, similar to the reference implementation. Differences in column names ('AverageFreightCost' vs 'AvgFreight') do not impact the correctness.",Base
How many orders were placed on weekends in the last three months? Please include a bar chart to visualize the number of orders placed on each weekend.,"import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define SQL query to get weekend orders in the last three months
sql_query = '''
SELECT OrderDate, COUNT(OrderID) AS WeekendOrders 
FROM orders 
WHERE DAYOFWEEK(OrderDate) IN (1, 7) 
AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
GROUP BY OrderDate
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Convert OrderDate to datetime
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])

# Create a column for the weekend day (Saturday/Sunday)
orders_df['Weekend'] = orders_df['OrderDate'].dt.strftime('%A')

# Aggregate total orders by weekend day
weekend_orders_df = orders_df.groupby('Weekend')['WeekendOrders'].sum().reset_index()

# Create a bar chart to visualize the number of orders placed on each weekend day
fig = px.bar(weekend_orders_df, x='Weekend', y='WeekendOrders', title='Number of Orders Placed on Weekends in the Last Three Months')

# Show the bar chart to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the start date as three months ago
three_months_ago = (datetime.now() - timedelta(days=90)).date()

# SQL query to retrieve orders placed on weekends in the last three months
sql_query = f""""""
SELECT DATE(OrderDate) AS OrderDate, COUNT(*) AS OrderCount
FROM orders
WHERE OrderDate >= '{three_months_ago}'
AND DAYOFWEEK(OrderDate) IN (1, 7)
GROUP BY DATE(OrderDate)
ORDER BY OrderDate;
""""""

# Execute the SQL query and get the results in a dataframe
orders_df = execute_sql_query(sql_query)

# Display the number of weekend orders
weekend_order_count = orders_df['OrderCount'].sum()
print(f'Total weekend orders in the last three months: {weekend_order_count}')

# Create a bar chart for the number of orders placed on each weekend
fig = px.bar(orders_df, x='OrderDate', y='OrderCount', title='Weekend Orders in the Last Three Months', labels={'OrderDate': 'Weekend Date', 'OrderCount': 'Number of Orders'})

# Show the figure to the user
show_to_user(fig)","The input code correctly retrieves the total number of orders placed on weekends in the last three months using a similar SQL query, and displays a bar chart with weekend order counts. Despite minor differences in approach, the essential functionality is preserved and matches the reference implementation.","import pandas as pd
import plotly.express as px

def get_weekend_order_data():
    # SQL query to get the count of weekend orders in the last three months
    query = """"""
    SELECT COUNT(*) AS weekend_orders_count 
    FROM orders 
    WHERE DATEPART(dw, OrderDate) IN (1, 7) 
    AND OrderDate > DATEADD(MONTH, -3, GETDATE())
    """"""
    
    # Execute the SQL query to retrieve the data
    weekend_orders_df = execute_sql_query(query)

    # Extract the count value from the dataframe
    count_of_weekend_orders = weekend_orders_df.iloc[0, 0]

    # Generate dummy data for visualization purposes
    # As the original query does not provide the breakdown per weekend,
    # we simulate it for illustrative purposes. In a real scenario,
    # you'd query for data points per weekend accordingly.
    weekends = [i for i in range(1, 13)]  # Simulated weekends
    number_of_orders = [count_of_weekend_orders // len(weekends) for _ in weekends]
    weekend_data = pd.DataFrame({'Weekend': weekends, 'Orders': number_of_orders})

    # Create a bar chart to visualize the number of orders placed on each weekend
    fig = px.bar(weekend_data, x='Weekend', y='Orders', title='Number of Orders Placed on Each Weekend in the Last Three Months')
    
    # Display the bar chart
    show_to_user(fig)

# Execute the function to retrieve and display the data
get_weekend_order_data()","The input code does not correctly retrieve and visualize the number of orders placed on each weekend in the last three months. It aggregates total weekend orders without breaking down the orders per weekend, resulting in a simulated chart that doesn't reflect the real data.",Base
What is the total sales revenue generated in the year 2023?,"import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales revenue in 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales revenue from the result
if not result_df.empty:
    total_sales = result_df.iloc[0]['total_sales']
else:
    total_sales = 0

# Create a DataFrame for visualization
sales_df = pd.DataFrame({'Year': ['2023'], 'Total Sales': [total_sales]})

# Create a bar plot using plotly express
fig = px.bar(sales_df, x='Year', y='Total Sales', title='Total Sales Revenue for 2023', labels={'Total Sales': 'Revenue ($)'})

# Display the result to the user
show_to_user(fig)","import pandas as pd

# Define SQL query to calculate total sales revenue for the year 2023
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'""""""

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)",The input Python code retrieves the total sales revenue for 2023 but does not create a visualization using Plotly as required by the reference implementation.,"import pandas as pd

# Construct the SQL query to calculate total sales revenue for the year 2023
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = 2023;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales value from the result dataframe
if not result_df.empty:
    total_sales = result_df['total_sales'][0]
else:
    total_sales = 0

# Convert the result to a DataFrame
output_df = pd.DataFrame({'year': [2023], 'total_sales': [total_sales]})

# Display the result to the user
show_to_user(output_df)","The input code successfully calculates the total sales revenue for the year 2023 by executing a SQL query that aggregates the sales data for that year. It uses the same calculation logic as the reference implementation, and correctly handles the result extraction and display. The minor differences, such as using a different method to filter the date (YEAR function), do not affect the correctness of the outcome.",Finetuned
How many products have been ordered but not yet shipped?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT orders.OrderID FROM orders WHERE orders.ShippedDate IS NULL;'

# Execute the SQL query to get the dataframe using the provided utility function
orders_df = execute_sql_query(sql_query)

# Calculate the number of products that have been ordered but not yet shipped
num_products_not_shipped = len(orders_df)

# Create a dataframe to display the result
result_df = pd.DataFrame({'Number of products not shipped': [num_products_not_shipped]})

# Use the provided utility function to display the result
show_to_user(result_df)","sql_query = """"""
SELECT COUNT(*) AS ProductsOrderedNotShipped
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.ShippedDate IS NULL
""""""

# Execute the SQL query and retrieve the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)",The input code counts the 'Order Details' records instead of orders. It should retrieve distinct 'OrderID's from 'orders' where 'ShippedDate' is NULL to match the business request and reference implementation.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM(od.Quantity) AS UnshippedQuantity 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.ShippedDate IS NULL;
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Extract the unshipped quantity from the resulting dataframe
unshipped_quantity = result_df.iloc[0, 0]

# Convert unshipped quantity to a DataFrame for display
unshipped_df = pd.DataFrame({'UnshippedQuantity': [unshipped_quantity]})

# Display the result to the user
show_to_user(unshipped_df)
","The input code successfully addresses the business request by calculating the quantity of products that have been ordered but not yet shipped. It utilizes a SQL query to sum quantities of unshipped orders, while the reference code counts order IDs that have not been shipped. Both effectively answer the request, although they differ in approach.",Finetuned
Which products are low in stock and need reordering?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;""

# Execute the SQL query and get the result in a pandas dataframe
products_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(products_df)","import pandas as pd

# SQL query to find products low in stock and need reordering
def get_low_stock_products():
    sql_query = '''
    SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
    FROM products
    WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0
    '''
    return execute_sql_query(sql_query)

# Execute the query and get low stock products
data = get_low_stock_products()

# Display the result to the user
show_to_user(data)","The input code correctly identifies products that are low in stock and need reordering by querying for products where UnitsInStock is less than or equal to ReorderLevel and are not discontinued. It then displays the results, fulfilling the business analytic request similarly to the reference code.","import pandas as pd

# Define SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query to retrieve data
products_df = execute_sql_query(sql_query)

# Display the products that are low in stock and need reordering
show_to_user(products_df)","The input code does not check if the products are discontinued. It only considers 'UnitsInStock < ReorderLevel', missing the 'Discontinued = 0' condition present in the reference implementation.",Base
How many orders were shipped but not yet delivered by the required date?,"# Import necessary libraries
import pandas as pd

# Define the SQL query as given in the business request
sql_query = 'SELECT COUNT(*) FROM orders WHERE ShippedDate > RequiredDate;'

# Execute the SQL query using the provided utility function
orders_df = execute_sql_query(sql_query)

# The result from the query will be a dataframe with one column containing the count
orders_not_delivered_on_time_count = orders_df.iloc[0, 0]

# Convert the result into a pandas dataframe to display
result_df = pd.DataFrame({'Orders Not Delivered On Time': [orders_not_delivered_on_time_count]})

# Display the result using the provided utility function
show_to_user(result_df)","import pandas as pd

# Define the SQL query to count orders that were shipped but not yet delivered by the required date
sql_query = '''
SELECT COUNT(OrderID) AS UndeliveredOrders
FROM orders
WHERE ShippedDate IS NOT NULL AND ShippedDate > RequiredDate
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly counts orders that were shipped but not delivered by the RequiredDate, similar to the reference code. Both consider orders where ShippedDate is greater than RequiredDate.","import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query.
sql_query = 'SELECT COUNT(*) AS LateDeliveries FROM orders WHERE ShippedDate > RequiredDate;'

# Step 2: Execute the SQL query to retrieve data.
result_df = execute_sql_query(sql_query)

# Step 3: Display the data retrieved.
show_to_user(result_df)

# Step 4 (Optional): If you want to visualize the data, for example, a bar chart.
fig = px.bar(result_df, x=result_df.index, y='LateDeliveries', title='Number of Late Deliveries')
show_to_user(fig)
","The evaluated code successfully counts the orders shipped later than the required date and uses the same SQL logic as the reference implementation. It retrieves and displays the result correctly using the provided functions, matching the business analytic request.",Base
Determine the average number of products per order.,"import pandas as pd

# SQL query to determine the average number of products per order
sql_query = '''
SELECT AVG(ProductCount) AS AverageProductsPerOrder 
FROM (SELECT OrderID, COUNT(ProductID) AS ProductCount 
      FROM [Order Details] 
      GROUP BY OrderID) AS ProductCounts;'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if the result dataframe is empty to avoid IndexError
if not result_df.empty:
    # Extract the average number of products per order from the result
    average_products_per_order = result_df['AverageProductsPerOrder'][0]
else:
    average_products_per_order = None

# Prepare the result to show the user
result_to_show = pd.DataFrame({
    'AverageProductsPerOrder': [average_products_per_order]
})

# Show the result to the user
show_to_user(result_to_show)","import pandas as pd

# SQL query to get the total number of products per order
sql_query = '''
SELECT o.OrderID, COUNT(od.ProductID) AS ProductCount 
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.OrderID
'''  

# Execute the query and get the results in a DataFrame
order_details = execute_sql_query(sql_query)

# Calculate the average number of products per order
average_products_per_order = order_details['ProductCount'].mean()

# Prepare the result for display
result_df = pd.DataFrame({'Average Products per Order': [average_products_per_order]})

# Show the result to the user
show_to_user(result_df)","The input code accurately calculates the average number of products per order by first retrieving the product count per order via a SQL query and then computing the mean of these counts using pandas, which aligns with the reference implementation.","import pandas as pd
import plotly.express as px

# Function to determine the average number of products per order
def get_average_products_per_order():
    # Execute the SQL query to get the average number of products per order
    sql_query = 'SELECT AVG(Quantity) AS AverageProductCount FROM [Order Details]'
    result_df = execute_sql_query(sql_query)

    # Display the result to the user
    show_to_user(result_df)
    
# Call the function to perform the analysis
get_average_products_per_order()","The input code calculates the average quantity per order detail rather than the average number of distinct products per order. The reference code groups by OrderID and counts distinct ProductIDs, which is not achieved in the input code.",Base
Which suppliers provide products that are currently discontinued?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 1;
'''

# Execute the SQL query
suppliers_with_discontinued_products = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(suppliers_with_discontinued_products)

# Additional visualization (Optional)
fig = px.bar(suppliers_with_discontinued_products, x='CompanyName', y='SupplierID', 
             title='Suppliers Providing Discontinued Products', 
             labels={'CompanyName': 'Supplier Company', 'SupplierID': 'Supplier ID'})

# Show the bar plot to the user
show_to_user(fig)","sql_query = """"""
SELECT Suppliers.SupplierID, Suppliers.SupplierName 
FROM Suppliers 
JOIN products ON Suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 1;
""""""

# Execute the SQL query and retrieve results.
result_df = execute_sql_query(sql_query)

# Display the result to the user.
show_to_user(result_df)","The evaluated code does not use DISTINCT in the SQL query, which could lead to duplicate entries in the result if the same supplier provides multiple discontinued products.","import pandas as pd

# Define the SQL query
sql_query = '''
SELECT s.CompanyName 
FROM suppliers s 
INNER JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.Discontinued = 1;
'''

# Execute the SQL query using the given utility function
suppliers_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(suppliers_df)","The input code correctly identifies suppliers of currently discontinued products by executing an SQL query that joins the suppliers and products tables and filters for discontinued products. Although it does not include the SupplierID in its output like the reference, it effectively answers the business request.",Finetuned
What are the most commonly ordered product quantities?,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS MostCommonQuantities 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID 
ORDER BY MostCommonQuantities DESC;
'''

# Execute the SQL query and retrieve the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result dataframe to the user
show_to_user(df)

# Create and display a bar chart visualization
fig = px.bar(df, x='ProductID', y='MostCommonQuantities', title='Most Commonly Ordered Product Quantities', labels={'ProductID': 'Product ID', 'MostCommonQuantities': 'Total Quantity Ordered'})
show_to_user(fig)","import pandas as pd

# SQL query to get the most commonly ordered product quantities
sql_query = '''
SELECT Quantity, COUNT(*) as Frequency
FROM [Order Details]
GROUP BY Quantity
ORDER BY Frequency DESC
'''

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user using the provided utility function
show_to_user(result_df)","The input code calculates and ranks frequencies of each specific order quantity from the 'Order Details' table, not the total quantities per product as requested. The reference implementation calculates the total quantities ordered per product.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to retrieve common product quantities
sql_query = '''
SELECT [Order Details].OrderID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY [Order Details].OrderID 
ORDER BY TotalQuantity DESC;
'''

# Step 2: Execute the SQL query
order_quantities_df = execute_sql_query(sql_query)

# Step 3: Display the retrieved data to the user
show_to_user(order_quantities_df)

# Step 4: Create a bar chart to visualize the most commonly ordered product quantities
fig = px.bar(order_quantities_df, x='OrderID', y='TotalQuantity', 
             title='Most Commonly Ordered Product Quantities', 
             labels={'OrderID': 'Order ID', 'TotalQuantity': 'Total Quantity'})

# Step 5: Display the bar chart
show_to_user(fig)
","The input code aggregates quantities by OrderID, not ProductID. The business request requires aggregation by ProductID to find the most commonly ordered product quantities, similar to the reference implementation.",None
Find the most expensive product by unit price.,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT ProductName FROM products ORDER BY UnitPrice DESC LIMIT 1;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","import pandas as pd

# Step 1: Define the SQL query to find the most expensive product by unit price.
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice
FROM products
WHERE Discontinued = 0
ORDER BY UnitPrice DESC
LIMIT 1
""""""

# Step 2: Execute the SQL query to get the most expensive product.
most_expensive_product = execute_sql_query(sql_query)

# Step 3: Show the result to the user.
show_to_user(most_expensive_product)","The input code adds an additional condition by excluding discontinued products, whereas the reference code does not include this condition. This could lead to a different result if the most expensive product is discontinued.","import pandas as pd
import plotly.express as px

# Define the SQL query to find the most expensive product by unit price
sql_query = 'SELECT MAX(UnitPrice) AS MostExpensiveProduct FROM products;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optionally, visualize the most expensive product with a bar chart
fig = px.bar(result_df, x=result_df.index, y='MostExpensiveProduct', title='Most Expensive Product by Unit Price')

# Show the plot to the user
show_to_user(fig)","The input code calculates the maximum UnitPrice, not the product name with the highest UnitPrice. The reference code retrieves the ProductName ordered by UnitPrice descending and limits the result to one. The input code does not meet the business requirement to find the most expensive product name.",None
Find the top 5 highest priced products.,"import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductName, UnitPrice FROM products ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query and get the resulting dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
graph = px.bar(result_df, x='ProductName', y='UnitPrice', title='Top 5 Highest Priced Products', labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price'})
show_to_user(graph)","import pandas as pd

# SQL query to find the top 5 highest priced products
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
ORDER BY UnitPrice DESC
LIMIT 5;
""""""

# Execute the SQL query
highest_priced_products = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(highest_priced_products)",The input code correctly executes the SQL query to find the top 5 highest priced products and uses the `show_to_user` function to display the result. It successfully addresses the business analytic request even without the visualization in the reference code.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT p.ProductName FROM products p ORDER BY p.UnitPrice DESC LIMIT 5;'

# Execute the query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code retrieves only the ProductName and not the UnitPrice, which is necessary for identifying the top 5 highest priced products.",Base
List customers with their respective regions and count of orders placed.,"
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT customers.CustomerID, customers.Region, COUNT(orders.OrderID) AS total_orders 
FROM customers 
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID 
GROUP BY customers.CustomerID, customers.Region;'''

# Execute the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Display the results to the user as a table
show_to_user(data)

# Optionally, create a visualization using plotly
# Example: Bar chart showing count of orders per region
fig = px.bar(data, x='CustomerID', y='total_orders', color='Region', title='Count of Orders per Customer by Region')

# Show the plotly figure to the user
show_to_user(fig)
","import pandas as pd

# SQL query to get customer information along with count of orders per customer
sql_query = '''
SELECT c.CustomerID, c.CompanyName, c.Region, COUNT(o.OrderID) AS OrderCount
FROM customers AS c
LEFT JOIN orders AS o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName, c.Region
ORDER BY c.CompanyName;
'''

# Execute the SQL query and get the results in a DataFrame
df_customers_orders = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df_customers_orders)","The input code correctly retrieves the list of customers along with their regions and the count of orders placed using a SQL query. While the input code includes an additional 'CompanyName' column which the reference implementation does not, it still effectively answers the business analytic request by providing the required data. Both codes group by 'CustomerID' and 'Region' and count the orders, which is the core requirement.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT customers.CustomerID, customers.Region, COUNT(orders.OrderID) AS Total_Orders
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID, customers.Region;
'''

# Execute the SQL query and get the result
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optional: Visualize the data using a bar chart for better insight
fig = px.bar(result_df, x='CustomerID', y='Total_Orders', color='Region', title='Total Orders by Customer and Region', labels={'Total_Orders': 'Number of Orders', 'CustomerID': 'Customer ID'})
show_to_user(fig)
","The input code uses an inner join instead of a left join. This will exclude customers who have not placed any orders, which is not intended according to the business analytic request seen in the reference code.",Base
Find the top 5 cities with the highest number of orders and visualize the distribution of orders.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 5;
'''

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Generate the bar chart using Plotly
fig = px.bar(orders_df, x='ShipCity', y='OrderCount', title='Top 5 Cities with the Highest Number of Orders', labels={'ShipCity': 'City', 'OrderCount': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the top 5 cities with the highest number of orders
sql_query = '''
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 5
'''  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Visualizing the distribution of orders by city
fig = px.bar(result_df, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders',
             labels={'ShipCity': 'City', 'OrderCount': 'Number of Orders'},
             color='OrderCount')

# Show the plot to the user
show_to_user(fig)","The input Python code achieves the same outcome as the reference implementation by executing a similar SQL query to retrieve the top 5 cities with the highest number of orders and visualizing the result using a bar chart with Plotly. While it also displays the results as a DataFrame before visualization, the core functionality remains consistent with the request.","import pandas as pd
import plotly.express as px

# SQL query to fetch top 5 cities with the highest number of orders
sql_query = '''SELECT ShipCity, COUNT(*) AS NumberOfOrders FROM orders GROUP BY ShipCity ORDER BY NumberOfOrders DESC LIMIT 5;'''

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Visualize the distribution of orders
fig = px.bar(order_data, x='ShipCity', y='NumberOfOrders', title='Top 5 Cities with Highest Number of Orders')

# Display the visualization to the user
show_to_user(fig)","The input code correctly executes the SQL query to fetch the top 5 cities with the highest number of orders. It then uses Plotly to visualize this data as a bar chart. Both the reference and input codes produce the desired analysis, despite minor differences in column naming.",Base
What is the total quantity of each product sold and visualize the quantities for comparison?,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID;""

# Execute the SQL query to get the data
product_sales_df = execute_sql_query(sql_query)

# Create a bar plot for product quantities visualization
fig = px.bar(product_sales_df, x='ProductID', y='TotalQuantity', title='Total Quantity of Each Product Sold', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve total quantity sold for each product
sql_query = '''
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantitySold
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantitySold DESC;
'''  

# Execute SQL query and load data into a pandas DataFrame
total_quantity_sold_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total quantity sold for each product
fig = px.bar(total_quantity_sold_df, x='ProductID', y='TotalQuantitySold',
             title='Total Quantity Sold for Each Product',
             labels={'ProductID': 'Product ID', 'TotalQuantitySold': 'Total Quantity Sold'},
             color='TotalQuantitySold')

# Show the visualization to the user
show_to_user(fig)","The input code correctly sums the quantities sold for each product and visualizes them using a bar chart, effectively addressing the business analytic request. The additional JOIN operation in the SQL query does not impact the output as it retains the necessary data for visualization. The plot is enhanced by ordering the bars and including a color gradient, which improves visual clarity.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS total_quantity 
FROM [Order Details] 
INNER JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID;
'''

# Step 2: Execute the SQL query to get the result into a pandas dataframe
result_df = execute_sql_query(sql_query)

# Step 3: Visualize the total quantity of each product sold
fig = px.bar(result_df, x='ProductID', y='total_quantity', title='Total Quantity Sold per Product')

# Step 4: Display the visualization result
show_to_user(fig)","The input code calculates the total quantity sold for each product and visualizes it using a bar plot, which matches the business analytic request and achieves the same outcome as the reference implementation. The use of an INNER JOIN with the products table does not impact the result and still fulfills the requirement.",Base
Find the total sales and the number of orders for each customer in March 2023 and visualize the sales distribution.,"import pandas as pd
import plotly.express as px

# SQL query to get the total sales and the number of orders for each customer in March 2023
sql_query = '''
SELECT O.CustomerID, SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales, COUNT(O.OrderID) AS OrderCount 
FROM orders O 
JOIN [Order Details] OD 
ON O.OrderID = OD.OrderID 
WHERE DATE_FORMAT(O.OrderDate, '%Y-%m') = '2023-03' 
GROUP BY O.CustomerID;'''

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Plotting the sales distribution using plotly express
fig = px.histogram(df, x='TotalSales', title='Sales Distribution for March 2023', labels={'TotalSales': 'Total Sales'})

# Display the visualization to the user
show_to_user(fig)

# Display the dataframe for debugging purposes
df_display = df
show_to_user(df_display)","import pandas as pd
import plotly.express as px

# SQL query to get total sales and the number of orders for each customer in March 2023
sql_query = '''
SELECT 
    o.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
    COUNT(DISTINCT o.OrderID) AS NumberOfOrders
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '2023-03-01' AND o.OrderDate < '2023-04-01'
GROUP BY 
    o.CustomerID
'''

# Execute SQL query and get the results
results = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(results)

# Visualization of sales distribution
fig = px.histogram(results, x='TotalSales', title='Sales Distribution for March 2023',
                   labels={'TotalSales': 'Total Sales', 'CustomerID': 'Customer ID'},
                   nbins=30)
show_to_user(fig)",The input code effectively addresses the business analytic request by calculating the total sales and number of orders per customer for March 2023. It uses a different SQL date filter but achieves the same result as the reference. The visualization of sales distribution is correctly implemented using Plotly.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = '''
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as total_sales, 
       COUNT(orders.OrderID) as order_count 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY customers.CustomerID
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualize the sales distribution
fig = px.histogram(result_df, x='total_sales', nbins=30, title='Sales Distribution for Each Customer in March 2023', labels={'total_sales': 'Total Sales ($)'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the total sales and number of orders for each customer in March 2023, using SQL to fetch data from the database. It also visualizes the sales distribution with Plotly. The approach matches the reference implementation's logic and intent, despite minor differences in writing the SQL query.",Base
"How many units have been sold for each product, grouped by supplier and create a visualization for the data?","import plotly.express as px

# SQL query to retrieve data
sql_query = '''
SELECT s.SupplierName, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierName, p.ProductName;'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create visualization using Plotly
fig = px.bar(result_df, x='SupplierName', y='TotalQuantitySold', color='ProductName', title='Total Units Sold per Product Grouped by Supplier')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the required data
sql_query = '''
SELECT p.ProductName, p.SupplierID, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName, p.SupplierID
'''

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Visualizing the data using Plotly
fig = px.bar(sales_data, x='ProductName', y='TotalUnitsSold', color='SupplierID',
             title='Total Units Sold by Product and Supplier',
             labels={'TotalUnitsSold':'Units Sold', 'ProductName':'Product Name', 'SupplierID':'Supplier ID'})

# Show the visualization to the user
show_to_user(fig)","The input code is missing the SupplierName in the SQL query, which is required to group by supplier effectively. It uses SupplierID for the grouping but doesn't retrieve the names, which makes the output less informative compared to the reference implementation.","# Import necessary libraries
import plotly.express as px
import pandas as pd

# SQL query to retrieve the necessary data
sql_query = '''
SELECT products.SupplierID, SUM([Order Details].Quantity) AS TotalQuantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.SupplierID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not result_df.empty:
    # Create a bar chart using plotly
    fig = px.bar(result_df, x='SupplierID', y='TotalQuantity', title='Total Units Sold for Each Product Grouped by Supplier', labels={'TotalQuantity': 'Total Quantity Sold', 'SupplierID': 'Supplier ID'})
    
    # Display the result
    show_to_user(fig)
else:
    print('No data retrieved from the query.')","The input code does not group by SupplierName and ProductName as in the reference. It only groups by SupplierID without considering products, leading to incorrect results.",None
Calculate the percentage of orders shipped within 5 days of the order date.,"import pandas as pd
import plotly.express as px

def calculate_percentage_within_5_days():
    # SQL queries
    within_5_days_query = """"""
    SELECT COUNT(OrderID) * 100.0 / (SELECT COUNT(OrderID) FROM orders) AS PercentageWithin5Days 
    FROM orders 
    WHERE DATEDIFF(ShippedDate, OrderDate) <= 5
    """"""
    
    # Execute the SQL query
    within_5_days_df = execute_sql_query(within_5_days_query)
    
    # Extract the result from the dataframe
    percentage_within_5_days = within_5_days_df['PercentageWithin5Days'].iloc[0]
    
    # Prepare the result in a dataframe
    result_df = pd.DataFrame({
        'PercentageWithin5Days': [percentage_within_5_days]
    })
    
    # Display the result to the user
    show_to_user(result_df)
    
if __name__ == ""__main__"":
    calculate_percentage_within_5_days()","import pandas as pd

# SQL query to calculate orders shipped within 5 days of the order date
sql_query = '''
SELECT COUNT(OrderID) AS total_orders,
       COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) <= 5 THEN 1 END) AS shipped_within_5_days
FROM orders
'''  

# Execute the SQL query and retrieve data
result_df = execute_sql_query(sql_query)

# Calculate the percentage of orders shipped within 5 days
if result_df['total_orders'][0] > 0:
    percentage_shipped_within_5_days = (result_df['shipped_within_5_days'][0] / result_df['total_orders'][0]) * 100
else:
    percentage_shipped_within_5_days = 0

# Create a DataFrame to display the result
percentage_df = pd.DataFrame({'Percentage Shipped Within 5 Days (%)': [percentage_shipped_within_5_days]})

# Show the result to the user
show_to_user(percentage_df)","The evaluated code correctly calculates the percentage of orders shipped within 5 days by using a SQL query to retrieve the total number of orders and the number of orders shipped within 5 days, then calculates the percentage based on these values. The result is then displayed using a DataFrame, similar to the reference implementation's approach, fulfilling the business analytic request.","import pandas as pd

# SQL to get total number of orders
sql_total_orders = 'SELECT COUNT(*) AS TotalOrders FROM orders;'

# SQL to get number of orders shipped within 5 days
sql_within_5_days = 'SELECT COUNT(*) AS OrdersWithin5Days FROM orders WHERE DATEDIFF(ShippedDate, OrderDate) <= 5;'

# Execute SQL Queries
total_orders_df = execute_sql_query(sql_total_orders)
orders_within_5_days_df = execute_sql_query(sql_within_5_days)

# Ensure to get the values from the DataFrames
total_orders = total_orders_df.at[0, 'TotalOrders']
orders_within_5_days = orders_within_5_days_df.at[0, 'OrdersWithin5Days']

# Calculate the percentage
if total_orders > 0:
    percentage_within_5_days = (orders_within_5_days / total_orders) * 100
else:
    percentage_within_5_days = 0.0

# Create a DataFrame to display the result
result_df = pd.DataFrame({'PercentageWithin5Days': [percentage_within_5_days]})

# Show the result to the user
show_to_user(result_df)","The provided code correctly calculates the percentage of orders shipped within 5 days of the order date. It effectively achieves the same outcome as the reference implementation by executing SQL queries to get the total number of orders and those shipped within 5 days, then computes the percentage, and displays the result using the given utility functions.",Base
What is the total quantity ordered across all products by month and visualize the monthly trends?,"import pandas as pd
import plotly.express as px

# SQL query to retrieve data
sql_query = '''
SELECT MONTH(OrderDate) AS OrderMonth, YEAR(OrderDate) AS OrderYear, SUM(Quantity) AS TotalQuantityOrdered 
FROM [Order Details] 
GROUP BY MONTH(OrderDate), YEAR(OrderDate);
'''

# Execute SQL query and get the results in a pandas dataframe
data = execute_sql_query(sql_query)

# Convert columns to appropriate types
data['OrderMonth'] = data['OrderMonth'].astype(int)
data['OrderYear'] = data['OrderYear'].astype(int)
data['TotalQuantityOrdered'] = data['TotalQuantityOrdered'].astype(int)

# Create a 'Year-Month' column for easier sorting and plotting
data['YearMonth'] = pd.to_datetime(data['OrderYear'].astype(str) + '-' + data['OrderMonth'].astype(str) + '-01')

# Sort data by 'YearMonth'
data = data.sort_values(by='YearMonth')

# Plot the monthly trends using plotly
fig = px.line(data, x='YearMonth', y='TotalQuantityOrdered', title='Total Quantity Ordered by Month', labels={
    'YearMonth': 'Month',
    'TotalQuantityOrdered': 'Total Quantity Ordered'
})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total quantity ordered across all products by month
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN Orders o ON od.OrderID = o.OrderID
GROUP BY Month
ORDER BY Month;
''' 

# Execute SQL query and retrieve data
monthly_orders = execute_sql_query(sql_query)

# Visualize monthly trends
fig = px.line(monthly_orders, x='Month', y='TotalQuantity', title='Monthly Total Quantity Ordered', labels={'Month': 'Month', 'TotalQuantity': 'Total Quantity Ordered'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the total quantity ordered by month and visualizes the monthly trends using Plotly. It retrieves necessary data, computes the required metrics, and successfully generates a visualization similar to the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_FORMAT(O.OrderDate, '%Y-%m') AS Month, SUM(OD.Quantity) AS TotalQuantityOrdered 
FROM [Order Details] OD 
JOIN orders O ON OD.OrderID = O.OrderID 
GROUP BY Month 
ORDER BY Month;
'''

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Ensure Month column is treated as a string to retain correct chronological order
df['Month'] = df['Month'].astype(str)

# Sort the dataframe by Month
df = df.sort_values(by='Month')

# Visualize the monthly trends using Plotly
fig = px.line(df, x='Month', y='TotalQuantityOrdered', title='Total Quantity Ordered by Month')

# Display the visualization to the user
show_to_user(fig)","The input code effectively groups the total quantity ordered by month and visualizes the trends. It achieves the same outcome as the reference implementation by querying the database using a SQL query, and then using Plotly to create a line graph of the results. The key difference is that the input code aggregates by a formatted date string and orders it correctly as a string, whereas the reference code separately aggregates by month and year and then combines them. Both approaches meet the business requirement of visualizing total quantities by month.",Base
Which product has generated the highest revenue?,"import pandas as pd
import plotly.express as px

# Define the SQL Query
sql_query = '''SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS Revenue 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY Revenue DESC;'''

# Execute the SQL Query
result_df = execute_sql_query(sql_query)

# Display the product with the highest revenue
if not result_df.empty:
    highest_revenue_product = result_df.iloc[0]
    show_to_user(highest_revenue_product)

# Transform the result_df to a more readable format if needed
result_df['ProductID'] = result_df['ProductID'].astype(str)

# Create a bar plot for visualization
fig = px.bar(result_df, x='ProductID', y='Revenue', title='Revenue by Product', 
             labels={'ProductID': 'Product ID', 'Revenue': 'Revenue'},
             text_auto=True)

# Show to user
show_to_user(fig)

# Print the product with the highest revenue
print(highest_revenue_product)","import pandas as pd

# SQL query to calculate total sales by product
sql_query = '''
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalRevenue DESC
LIMIT 1
''' 

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code correctly calculates the product with the highest revenue by executing a SQL query that selects the ProductID and total revenue for each product, orders the results by revenue in descending order, and limits the output to the top result. This aligns with the business analytic request to identify the product generating the highest revenue and achieves the same outcome as the reference implementation, despite some differences such as not displaying a visualization.","import pandas as pd
import plotly.express as px

# SQL query to find the product that generates the highest revenue
sql_query = '''
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 1;
'''

# Execute the SQL query and get the result as a pandas dataframe
def get_highest_revenue_product():
    df = execute_sql_query(sql_query)
    return df

# Function to perform the business analysis and get the result
result_df = get_highest_revenue_product()

# Display the result to the user
show_to_user(result_df)","The input code correctly identifies the product with the highest revenue by executing an SQL query that joins the products and order details tables, calculates total revenue, and orders the results by revenue in descending order. It then limits the result to the top product, displaying it using the show_to_user function. This aligns with the business request and achieves the same outcome as the reference implementation, despite the variations in approach.",Base
Calculate the average order value for each customer.,"import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue 
FROM customers c 
INNER JOIN orders o ON c.CustomerID = o.CustomerID 
INNER JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query to retrieve data

df = execute_sql_query(sql_query)

# The SQL query already calculates average order value per customer

# Display the result to the user
show_to_user(df)","import pandas as pd

# SQL query to calculate the total order value and the number of orders for each customer
sql_query = '''
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue, 
       COUNT(o.OrderID) AS OrderCount
FROM customers AS c
JOIN orders AS o ON c.CustomerID = o.CustomerID
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID
''' 

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Calculate average order value for each customer
order_data['AverageOrderValue'] = order_data['TotalOrderValue'] / order_data['OrderCount']

# Keep only relevant columns for display
average_order_value = order_data[['CustomerID', 'AverageOrderValue']]

# Show the result to the user
show_to_user(average_order_value)","The input code successfully calculates the average order value for each customer. It sums the total order value and the count of orders per customer, then divides the total by the number of orders to get the average. Although the implementation differs from the reference, it achieves the same analytical goal.","import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = '''
SELECT orders.CustomerID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS AvgOrderValue 
FROM orders 
JOIN [Order Details] 
  ON orders.OrderID = [Order Details].OrderID 
GROUP BY orders.CustomerID;
'''

# Step 2: Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Display the result
show_to_user(df)

# Optional: Visualize the average order value for each customer
fig = px.bar(df, x='CustomerID', y='AvgOrderValue', 
             title='Average Order Value for Each Customer', 
             labels={'CustomerID': 'Customer ID', 'AvgOrderValue': 'Average Order Value'})
show_to_user(fig)","Both the reference and input implementations correctly calculate the average order value for each customer using SQL queries and display the results. The difference in the input code includes a visualization step using Plotly, which does not affect the correctness of the computation.",Base
What is the average lead time for orders delivered by each supplier and visualize the lead times?,"import pandas as pd
import plotly.express as px

# SQL query to get average lead time for orders delivered by each supplier
sql_query = '''
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID
'''

# Execute the SQL query and retrieve data as a pandas dataframe
df = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(df, x='SupplierID', y='avg_lead_time', title='Average Lead Time for Orders Delivered by Each Supplier', labels={'SupplierID': 'Supplier ID', 'avg_lead_time': 'Average Lead Time (Days)'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get supplier lead time
sql_query = '''
SELECT products.SupplierID, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS supplier_lead_time
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.SupplierID
'''  

# Execute the SQL query to get the data
lead_time_data = execute_sql_query(sql_query)

# Visualization of the lead times
fig = px.bar(lead_time_data, x='SupplierID', y='supplier_lead_time', 
             title='Average Lead Time for Orders Delivered by Each Supplier', 
             labels={'supplier_lead_time': 'Average Lead Time (Days)', 'SupplierID': 'Supplier ID'})

# Show the result to the user
show_to_user(fig)","The input code computes the average lead time for orders delivered by each supplier and creates a bar chart visualization. Despite minor differences, such as column naming ('supplier_lead_time' vs. 'avg_lead_time'), the input code achieves the same outcome as the reference implementation.","
import pandas as pd
import plotly.express as px

# SQL query to get the average lead time for orders delivered by each supplier
sql_query = '''
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID = o.ProductID
GROUP BY s.CompanyName;'''

# Execute the SQL query to get the data
supplier_lead_times = execute_sql_query(sql_query)

# Generate the visualization
fig = px.bar(supplier_lead_times, x='CompanyName', y='AverageLeadTime', title='Average Lead Time for Orders by Each Supplier', labels={'CompanyName':'Supplier', 'AverageLeadTime':'Average Lead Time (in days)'})

# Display the result to the user
show_to_user(fig)
","The input code is incorrect as it joins the orders to products on ProductID directly, missing the [Order Details] table. This may lead to inaccurate lead time calculation due to missing connections between orders and products.",Base
Which suppliers provide products that are currently out of stock?,"import pandas as pd

# Define SQL query to retrieve the required data
sql_query = """"""
SELECT s.SupplierName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.UnitsInStock = 0;
""""""

# Execute the SQL query and retrieve data into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(df)","import pandas as pd

# SQL query to retrieve suppliers providing products that are currently out of stock
sql_query = '''
SELECT DISTINCT p.SupplierID
FROM products p
WHERE p.UnitsInStock = 0
'''

# Execute the SQL query and get the data
out_of_stock_suppliers = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(out_of_stock_suppliers)",The evaluated code retrieves 'SupplierID' instead of 'SupplierName' and lacks a join with the 'suppliers' table to get the names. It doesn't directly address the request to identify suppliers by name.,"import pandas as pd

# Step 1: Define the SQL query based on business requirements
sql_query = '''
SELECT suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.UnitsInStock = 0
'''

# Step 2: Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Step 3: Display the results to the user
show_to_user(result_df)","The input code correctly identifies suppliers providing products that are out of stock by querying the 'suppliers' and 'products' tables. It matches the logic of the reference implementation in using an SQL JOIN to find suppliers associated with products having zero units in stock. Although 'SupplierName' and 'CompanyName' column names differ, this does not affect the correctness relative to the business analytic request.",Finetuned
How many units on order are there for each product?,"import pandas as pd
import plotly.express as px

# SQL query to get the product names and units on order
sql_query = 'SELECT p.ProductName, p.UnitsOnOrder FROM products p'

# Execute SQL query
products_df = execute_sql_query(sql_query)

# Check the retrieved DataFrame
print(products_df.head())

# Visualize the data using Plotly
fig = px.bar(products_df, x='ProductName', y='UnitsOnOrder', title='Units on Order for Each Product', labels={'ProductName': 'Product Name', 'UnitsOnOrder': 'Units on Order'})

# Display the chart to the user
show_to_user(fig)","import pandas as pd

# SQL query to retrieve units on order for each product.
sql_query = """"""
SELECT ProductID, SUM(UnitsOnOrder) AS TotalUnitsOnOrder
FROM products
GROUP BY ProductID
""""""

# Execute the SQL query using the provided function.
units_on_order_df = execute_sql_query(sql_query)

# Show the result to the user.
show_to_user(units_on_order_df)","The input code groups the data by 'ProductID' and sums up 'UnitsOnOrder', potentially misrepresenting the data if 'ProductID' is not unique. The reference code retrieves 'ProductName' and 'UnitsOnOrder' directly from the 'products' table without aggregation. The tasks performed by the two implementations are not equivalent.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, UnitsOnOrder FROM products""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display basic information about the data
print(""Data Overview:"")
print(products_df.info())

# Display first few rows of the dataframe
print(""First few rows of the data:"")
print(products_df.head())

# Visualize the data using plotly
fig = px.bar(products_df, x='ProductID', y='UnitsOnOrder', 
             title='Units on Order for Each Product', 
             labels={'ProductID':'Product ID', 'UnitsOnOrder':'Units On Order'})

# Display the plot to the user
show_to_user(fig)","The input code uses 'ProductID' instead of 'ProductName', which does not fulfill the business request to show units on order for each product by name.",None
How many units of each product are currently in stock?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductID, ProductName, UnitsInStock FROM products;'

# Execute the SQL query using the provided utility function
products_df = execute_sql_query(sql_query)

# Display the data to the user using the provided utility function
show_to_user(products_df)

# For visualization, create a bar chart for the UnitsInStock of each ProductName
fig = px.bar(products_df, x='ProductName', y='UnitsInStock', title='Units In Stock per Product', labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units In Stock'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd

# SQL query to retrieve the count of units in stock for each product
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query and get the DataFrame
inventory_df = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(inventory_df)","The evaluated code includes a WHERE clause filtering out discontinued products, which is not present in the reference implementation. This could result in different output by excluding some products from the count.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT ProductID, UnitsInStock FROM products;'

# Execute the SQL query to retrieve data
product_stock_df = execute_sql_query(sql_query)

# Validate data retrieval
if product_stock_df.empty:
    print('No data retrieved from the database.')
else:
    # Display the data to the user
    show_to_user(product_stock_df)

    # Optionally, create a bar chart for better visualization
    fig = px.bar(product_stock_df, x='ProductID', y='UnitsInStock', title='Current Stock of Each Product', labels={'ProductID':'Product ID', 'UnitsInStock':'Units In Stock'})
    # Show the bar chart to the user
    show_to_user(fig)","The input code retrieves 'ProductID' and 'UnitsInStock' but not 'ProductName', which might be essential for identifying products in stock effectively. The reference implementation retrieves 'ProductName' for better clarity in analysis and visualization.",None
Which product has the highest unit price but lowest sales quantity?,"import pandas as pd

# Step 1: Query for product with the highest unit price
query_highest_price = '''
SELECT products.ProductID, products.ProductName, products.UnitPrice
FROM products
WHERE products.UnitPrice = (
    SELECT MAX(products.UnitPrice) 
    FROM products
)'''

# Execute the query and get the result
highest_price_product = execute_sql_query(query_highest_price)

# Extract ProductID, ProductName, and UnitPrice of the highest priced product
highest_price_product_id = highest_price_product.iloc[0]['ProductID']
highest_price_product_name = highest_price_product.iloc[0]['ProductName']
highest_price_product_unit_price = highest_price_product.iloc[0]['UnitPrice']

# Step 2: Check if the highest priced product has any sales quantities
query_check_sales = f'''
SELECT [Order Details].ProductID, SUM([Order Details].Quantity) as TotalQuantity
FROM [Order Details]
WHERE [Order Details].ProductID = {highest_price_product_id}
GROUP BY [Order Details].ProductID
'''

# Execute the query and get the result
sales_quantities = execute_sql_query(query_check_sales)

# Step 3: If the product has no sales quantities, create the result dataframe
if sales_quantities.empty or sales_quantities.iloc[0]['TotalQuantity'] == 0:
    result_df = pd.DataFrame({'ProductID': [highest_price_product_id],
                              'ProductName': [highest_price_product_name],
                              'UnitPrice': [highest_price_product_unit_price],
                              'TotalQuantity': [0]})
else:
    # The product has some sales quantity, hence doesn't meet the condition of zero sales quantity
    result_df = pd.DataFrame(columns=['ProductID', 'ProductName', 'UnitPrice', 'TotalQuantity'])

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to retrieve unit price and sales quantity
sql_query = '''
SELECT products.ProductID, products.UnitPrice, SUM([Order Details].Quantity) AS SalesQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID, products.UnitPrice
'''

# Execute the SQL query and store the result in a DataFrame
product_data = execute_sql_query(sql_query)

# Find the product with the highest unit price but lowest sales quantity
# Sort the DataFrame by UnitPrice descending and SalesQuantity ascending
result = product_data.sort_values(by=['UnitPrice', 'SalesQuantity'], ascending=[False, True])

# Get the product with the highest unit price and lowest sales quantity
highest_price_lowest_sales = result.iloc[0]

# Display the result to the user
show_to_user(highest_price_lowest_sales)","The input code retrieves the product with the highest price and lowest sales quantity but does not correctly handle the requirement of zero sales. It assumes a non-zero smallest quantity is acceptable, diverging from the reference implementation that checks for zero sales.","import pandas as pd
import plotly.express as px

# Step 1: Retrieve data from the database
sql_query = '''
SELECT p.ProductID, p.ProductName, MAX(p.UnitPrice) as HighestUnitPrice, 
       MIN(od.Quantity) as LowestSalesQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY HighestUnitPrice DESC, LowestSalesQuantity ASC;
'''

result_df = execute_sql_query(sql_query)

# Step 2: Display the DataFrame to the user
show_to_user(result_df)","The code retrieves products with the highest unit price and lowest sales quantity for each product, not necessarily a product with the highest unit price and zero sales quantity. It does not check if the highest-priced product specifically has zero sales.",None
Which product had the highest sales in terms of quantity in March 2023?,"import pandas as pd

# Define the SQL query to find the product with the highest sales in terms of quantity in March 2023
sql_query = '''
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductName
ORDER BY total_quantity DESC
LIMIT 1
'''

# Execute the SQL query and retrieve the results
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to find the product with the highest quantity sold in March 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_quantity DESC
LIMIT 1
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly executes a SQL query to find the product with the highest sales quantity in March 2023, similar to the reference code. The inclusion of ProductID in the SELECT and GROUP BY clauses does not affect the correctness as it does not change the result of the query. The primary goal of identifying the product with the highest sales is achieved.","import pandas as pd
import plotly.express as px

# The SQL query to find the product with the highest sales in terms of quantity for March 2023
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) as total_quantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY products.ProductID 
ORDER BY total_quantity DESC 
LIMIT 1;
'''

# Execute the SQL query and get the result in a pandas dataframe
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)
","The input code retrieves ProductID instead of ProductName, which does not directly address the business request. The output is not in the correct format for identifying the product by name.",Base
What is the total sales generated by each employee for the past year? Please include a data visualization to illustrate the results.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and retrieve the data
employee_sales_df = execute_sql_query(sql_query)

# Data visualization using plotly
fig = px.bar(employee_sales_df, x='EmployeeID', y='TotalSales', 
            hover_data=['FirstName', 'LastName'], 
            labels={'TotalSales':'Total Sales'}, 
            title='Total Sales Generated by Each Employee for the Past Year')

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to get total sales per employee for the past year
year_start = pd.to_datetime('today') - pd.DateOffset(years=1)
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '{year_start.strftime('%Y-%m-%d')}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

# Execute the SQL query and retrieve data in a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(data, x='FirstName', y='TotalSales',
             title='Total Sales Generated by Each Employee in the Past Year',
             labels={'FirstName': 'Employee Name', 'TotalSales': 'Total Sales ($)'} )

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the total sales generated by each employee over the past year and creates a bar chart to illustrate the results. It matches the reference implementation's logic and produces the expected outcome, despite minor differences in variable naming and grouping columns.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS YearlySales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN Employees e ON o.EmployeeID = e.EmployeeID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY e.EmployeeID;
''' 

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Concatenate first and last names to create a full name column
sales_data['FullName'] = sales_data['FirstName'] + ' ' + sales_data['LastName']

# Create the bar chart visualization using plotly
fig = px.bar(sales_data, x='FullName', y='YearlySales', title='Total Sales Generated by Each Employee in the Past Year', labels={'FullName': 'Employee', 'YearlySales': 'Total Sales'})

# Show the plot
show_to_user(fig)","The input code correctly calculates total sales generated by each employee for the past year and visualizes it using a bar chart. The variable names and SQL structure match the reference implementation, with slight differences in presentation that don't affect correctness.",Base
Find the average number of days between order placement and order shipping by customer.,"
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageDaysToShip 
FROM orders 
GROUP BY CustomerID;
'''

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(result_df)

# Optionally, create a bar chart visualization
fig = px.bar(result_df, x='CustomerID', y='AverageDaysToShip', title='Average Days to Ship per Customer')

# Display the plotly figure
show_to_user(fig)  
","import pandas as pd

# SQL query to calculate the average number of days between order placement and order shipping by customer
sql_query = '''
SELECT CustomerID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgDaysBetween
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY CustomerID
'''

# Execute the SQL query and get the results in a pandas dataframe
results_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(results_df)","The evaluated code correctly calculates the average number of days between order placement and order shipping by customer. It addresses the business analytic request by using a SQL query similar to the reference code. The main difference is the naming of the output column ('AvgDaysBetween' vs. 'AverageDaysToShip'), which doesn't affect the correctness of the result. Both codes ensure only non-null 'ShippedDate' values are considered, and display the results to the user.","import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = '''
SELECT customers.CustomerID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_days_between_order_and_shipping 
FROM orders 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optional: visualize the result using a bar chart
fig = px.bar(result_df, x='CustomerID', y='avg_days_between_order_and_shipping', title='Average Days Between Order Placement and Shipping by Customer')
show_to_user(fig)","The input code correctly calculates the average number of days between order placement and shipping by customer. It achieves this through a SQL query that calculates the difference in days between 'ShippedDate' and 'OrderDate', grouped by 'CustomerID'. The input code joins the 'customers' table, but this does not affect the correctness as it still aggregates by 'CustomerID' correctly. The result is visualized similar to the reference implementation. The functions 'execute_sql_query' and 'show_to_user' are used as specified.",Base
What is the total sales revenue generated by each product category in the last year? Please include a data visualization to illustrate the results.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales revenue by product category for the last year
sql_query = '''
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY ProductID;
'''

# Execute the SQL query using the provided utility function
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales revenue by product category
fig = px.bar(sales_data,
             x='ProductID',
             y='TotalSales',
             title='Total Sales Revenue by Product Category in the Last Year',
             labels={'ProductID': 'Product Category', 'TotalSales': 'Total Sales Revenue'}
            )

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve total sales by product category in the last year
sql_query = """"""
SELECT p.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
WHERE o.OrderDate >= DATEADD(year, -1, GETDATE())
GROUP BY p.CategoryID
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart visualization of total sales by product category
fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Total Sales Revenue by Product Category (Last Year)', labels={'CategoryID': 'Product Category', 'TotalSales': 'Total Sales Revenue'})

# Display the visualization to the user
show_to_user(fig)","The input code uses 'CategoryID' instead of 'ProductID', which aligns with the business request for product categories. The reference code uses 'ProductID'. The input code correctly fetches and visualizes sales data by product category as intended, thus satisfying the business analytic request.","# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE())-1 
GROUP BY categories.CategoryName;
'''

# Execute the SQL query and get the result
data = execute_sql_query(sql_query)

# Ensure the data is sorted for better visualization
data = data.sort_values(by='TotalSales', ascending=False)

# Create a bar chart to visualize the total sales revenue by product category
fig = px.bar(data, x='CategoryName', y='TotalSales', 
             title='Total Sales Revenue by Product Category in the Last Year', 
             labels={'CategoryName': 'Product Category', 'TotalSales': 'Total Sales Revenue ($)'})

# Show the result to the user
show_to_user(fig)","The input code correctly calculates the total sales revenue by product category for the last year. It properly joins the necessary tables including categories to get the category name, uses a SQL query with appropriate date filtering, and sorts the data for better visualization. The visualization is done using a bar chart with Plotly and displayed using the show_to_user function. Despite minor differences in implementation, it fulfills the business analytic request effectively.",Finetuned
Identify suppliers that have not supplied any products in the last year.,"import pandas as pd
import plotly.express as px


def identify_suppliers_no_recent_products():
    # SQL query to identify suppliers that have not supplied any products in the last year
    sql_query = '''
    SELECT suppliers.CompanyName 
    FROM suppliers 
    LEFT JOIN (
        SELECT products.SupplierID, COUNT(*) AS ProductCount 
        FROM products 
        JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
        JOIN orders ON [Order Details].OrderID = orders.OrderID 
        WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
        GROUP BY products.SupplierID
    ) AS recent_products 
    ON suppliers.SupplierID = recent_products.SupplierID 
    WHERE recent_products.ProductCount IS NULL;
    '''
    
    # Execute the SQL query
    result_df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(result_df)
    
    # Optional visualization
    try:
        if not result_df.empty:  # Check if the dataframe is not empty
            fig = px.bar(result_df, x='CompanyName', title='Suppliers with No Products Supplied in the Last Year')
            show_to_user(fig)
    except Exception as e:
        print(f""An error occurred while plotting: {e}"")

# Call the function to execute the code
identify_suppliers_no_recent_products()","import pandas as pd
from datetime import datetime, timedelta

# Calculate the date one year ago from today
date_one_year_ago = datetime.now() - timedelta(days=365)
# Format the date to match the database format (YYYY-MM-DD)
date_one_year_ago_str = date_one_year_ago.strftime('%Y-%m-%d')

# SQL query to find suppliers that have not supplied any products in the last year
sql_query = f""""""
SELECT s.SupplierID, s.CompanyName
FROM suppliers s
LEFT JOIN products p ON s.SupplierID = p.SupplierID
LEFT JOIN orders o ON p.ProductID = o.OrderID
WHERE o.OrderDate < '{date_one_year_ago_str}' OR o.OrderDate IS NULL
GROUP BY s.SupplierID, s.CompanyName
""""""  

# Execute the SQL query and store the result in a DataFrame
suppliers_without_orders_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(suppliers_without_orders_df)","The evaluated code does not correctly implement the business logic. The query checks for orders older than one year rather than looking for suppliers with no orders in the last year. The condition should exclude suppliers who have supplied products within the last year, not just those with older orders.","import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT suppliers.CompanyName FROM suppliers 
LEFT JOIN products ON suppliers.SupplierID = products.SupplierID 
LEFT JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderID IS NULL 
OR [Order Details].OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR);
'''

# Execute the SQL query and retrieve the data
suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(suppliers_df)","The input code incorrectly identifies suppliers that have never supplied products, rather than those who haven't supplied in the last year. It misses joining with orders and filtering by recent orders compared to the reference implementation.",None
Which products have stock levels below their reorder level?,"import pandas as pd
import plotly.express as px

# Define the SQL query to find products with stock levels below their reorder level
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query and retrieve the data into a pandas dataframe
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)","sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0;
''' 

# Execute the SQL query to get products with stock levels below their reorder level
result_df = execute_sql_query(sql_query) 

# Display the result to the user
show_to_user(result_df)","The input code correctly retrieves products with stock levels below the reorder level, while also considering whether the products are not discontinued. This addresses the business analytic request and achieves the same outcome as the reference implementation, with an additional filter for discontinued products which may be an intended enhancement.","import pandas as pd

def get_stock_below_reorder_level():
    # SQL query to find products with stock levels below their reorder level
    sql_query = ""SELECT ProductID FROM products WHERE UnitsInStock < ReorderLevel;""
    
    # Execute the SQL query using the provided utility function
    df = execute_sql_query(sql_query)
    
    # Display the result using the provided utility function
    show_to_user(df)

# Execute the function
get_stock_below_reorder_level()
","The input code queries only the 'ProductID' instead of both 'ProductID' and 'ProductName', which does not fully match the business analytic request as per the reference implementation.",Base
How many units of each product are currently on order?,"import pandas as pd
import plotly.express as px

# SQL Query
sql_query = 'SELECT ProductName, UnitsOnOrder FROM products;'

# Execute SQL query
products_df = execute_sql_query(sql_query)

# Display dataframe to user
show_to_user(products_df)

# Optional: Visualization (e.g., bar chart)
fig = px.bar(products_df, x='ProductName', y='UnitsOnOrder', title='Units on Order for Each Product')
show_to_user(fig)","import pandas as pd

# SQL query to retrieve units on order for each product
sql_query = '''
SELECT p.ProductName, p.UnitsOnOrder
FROM products AS p
WHERE p.Discontinued = 0;
'''  # Assuming we only want the active products

# Execute the SQL query
units_on_order_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(units_on_order_df)","The input code filters out discontinued products, which is not part of the business analytic request nor the reference implementation. The request asks for units on order for all products, not just active ones.","import pandas as pd
import plotly.express as px

def get_products_on_order():
    # Define SQL query to get ProductName and UnitsOnOrder
    sql_query = 'SELECT p.ProductName, p.UnitsOnOrder FROM products p;'
    
    # Execute the SQL query
    products_on_order_df = execute_sql_query(sql_query)
    
    # Display the DataFrame to the user
    show_to_user(products_on_order_df)
    
    # Optional: If you want to visualize the data using a plot
    fig = px.bar(products_on_order_df, x='ProductName', y='UnitsOnOrder', title='Units of Each Product Currently on Order')
    show_to_user(fig)

# Call the function to execute
get_products_on_order()",The input code correctly executes the SQL query to retrieve 'ProductName' and 'UnitsOnOrder' from the 'products' table. It displays the result using the show_to_user function and optionally visualizes the data with a bar chart. This matches the business analytic request and achieves the same outcome as the reference implementation.,Finetuned
What is the monthly sales trend for each product over the last year? Please use a data visualization to illustrate the trend.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM') AS Month, 
       SUM([Order Details].Quantity) AS MonthlySales 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderDate >= DATEADD(year, -1, GETDATE()) 
GROUP BY products.ProductID, FORMAT([Order Details].OrderDate, 'yyyy-MM');
'''

# Execute the SQL query and retrieve the data as a pandas dataframe
df = execute_sql_query(sql_query)

# Sort the dataframe by Month for better line plot trends
df.sort_values(by='Month', inplace=True)

# Create a line plot for monthly sales trend for each product
fig = px.line(df, x='Month', y='MonthlySales', color='ProductID', title='Monthly Sales Trend for Each Product')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL Query to get monthly sales data for each product over the last year
sql_query = '''
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
    SUM(od.Quantity) AS TotalSales
FROM  
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    p.ProductID, Month
ORDER BY 
    Month, p.ProductID;
'''

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Check if data is retrieved
display(sales_data)

# Create a line plot to show the monthly sales trend for each product
fig = px.line(sales_data, x='Month', y='TotalSales', color='ProductName', title='Monthly Sales Trend for Each Product')

# Display the plot to the user
show_to_user(fig)","The input code correctly retrieves the monthly sales trend for each product over the last year and visualizes it using Plotly. The use of DATE_FORMAT and the SQL query structure are appropriate for achieving the intended outcome, which matches the reference implementation.","import pandas as pd
import plotly.express as px

# SQL Query to execute
sql_query = '''
SELECT p.ProductName, DATE_FORMAT(o.OrderDate, '%Y-%m') as OrderMonth, SUM(od.Quantity) as TotalSold 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY p.ProductName, OrderMonth 
ORDER BY OrderMonth ASC;
'''

# Execute the SQL query and get the result in a dataframe
sales_data = execute_sql_query(sql_query)

# Create the plotly line chart
fig = px.line(sales_data, x='OrderMonth', y='TotalSold', color='ProductName', 
              title='Monthly Sales Trend for Each Product Over the Last Year', 
              labels={'OrderMonth': 'Month', 'TotalSold': 'Total Quantity Sold', 'ProductName': 'Product'})

# Display the plotly figure to the user
show_to_user(fig)","The input Python code correctly queries and visualizes the monthly sales trend for each product over the last year, similar to the reference implementation. Both implementations execute SQL queries to retrieve sales data and use Plotly to create line plots, satisfying the business analytic request.",Base
Find the average discount provided per order.,"import pandas as pd
import plotly.express as px

# SQL query to find the average discount provided per order.
sql_query = 'SELECT AVG([Order Details].Discount) AS AvgDiscount FROM [Order Details];'

# Execute the SQL query
df = execute_sql_query(sql_query)

# Since we are interested in the average discount, we need to extract that specific value
avg_discount = df['AvgDiscount'][0]

# Create a dataframe to hold the result
result_df = pd.DataFrame({'Metric': ['Average Discount'], 'Value': [avg_discount]})

# Display the results to the user
show_to_user(result_df)
","import pandas as pd

# SQL query to find the average discount per order
discount_query = """"""
SELECT AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID
""""""

# Execute the SQL query and store the result in a DataFrame
discount_df = execute_sql_query(discount_query)

# Calculate the average discount from the retrieved data
average_discount = discount_df['AverageDiscount'].mean()

# Prepare the result to show to the user
result_df = pd.DataFrame({'AverageDiscount': [average_discount]})

# Show the result to the user
show_to_user(result_df)","The input code calculates the average discount per order using GROUP BY OrderID and then averages these. This differs from the reference, which calculates the overall average discount across all order details without grouping by OrderID.","import pandas as pd

# Define the SQL query to find the average discount provided per order
sql_query = 'SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];'

# Execute the SQL query and retrieve the results
result_df = execute_sql_query(sql_query)

# Extract the average discount value from the resulting dataframe
average_discount = result_df['AverageDiscount'].iloc[0]

# Prepare a dataframe to display the average discount
average_discount_df = pd.DataFrame({'Average Discount': [average_discount]})

# Display the results to the user
show_to_user(average_discount_df)","The input Python code correctly computes the average discount per order using an SQL query, retrieves the result, and displays it. The logic aligns with the business request and the reference implementation, differing only in variable naming and output formatting, which are acceptable differences.",Finetuned
What is the average quantity per unit for products supplied by each supplier?,"import pandas as pd
import plotly.express as px

# SQL query to get the average quantity per unit for products supplied by each supplier
sql_query = '''
SELECT s.SupplierID, s.SupplierName, AVG(CAST(p.QuantityPerUnit AS DECIMAL)) AS AverageQuantityPerUnit
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.SupplierName;
'''

# Execute the SQL query and retrieve the data as a pandas dataframe

df = execute_sql_query(sql_query)

# Ensure the column names are adjusted for Plotly, removing any potential leading/trailing spaces
if 'SupplierID' in df.columns and 'SupplierName' in df.columns and 'AverageQuantityPerUnit' in df.columns:
    df = df[['SupplierID', 'SupplierName', 'AverageQuantityPerUnit']]

# Show the data to the user
show_to_user(df)

# Optional: Create a visual representation using plotly
fig = px.bar(df, x='SupplierName', y='AverageQuantityPerUnit', title='Average Quantity Per Unit by Supplier', labels={'SupplierName': 'Supplier Name', 'AverageQuantityPerUnit': 'Average Quantity Per Unit'})

# Show the plotly figure to the user
show_to_user(fig)
","import pandas as pd

# SQL query to calculate average Quantity per Unit for each supplier
sql_query = '''
SELECT p.SupplierID, 
       AVG(CAST(SUBSTRING_INDEX(p.QuantityPerUnit, ' ', 1) AS UNSIGNED)) AS AverageQuantityPerUnit
FROM products p
GROUP BY p.SupplierID
'''  

# Execute the SQL query and retrieve the data
supplier_avg_quantity = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(supplier_avg_quantity)","The input code calculates the average quantity per unit from the 'QuantityPerUnit' directly from the 'products' table without joining it with the 'suppliers' table, whereas the reference code uses a join to associate each product with its supplier. The input code could lead to inaccurate results if the 'SupplierID' is not unique to each supplier. Additionally, it does not retrieve or display 'SupplierName', which is part of the analytic request.","import pandas as pd
import plotly.express as px

# SQL query to get average quantity per unit for products supplied by each supplier.
sql_query = '''
SELECT suppliers.SupplierID, suppliers.CompanyName, 
       AVG(CAST (SUBSTRING_INDEX(products.QuantityPerUnit, ' ', 1) AS SIGNED)) AS AverageQuantityPerUnit 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.SupplierID, suppliers.CompanyName;
'''

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Show the retrieved data to the user
show_to_user(supplier_data)

# Optionally, visualize the average quantity per unit for each supplier using a bar chart
fig = px.bar(supplier_data, x='CompanyName', y='AverageQuantityPerUnit', 
             title='Average Quantity Per Unit for Each Supplier', 
             labels={'CompanyName':'Supplier', 'AverageQuantityPerUnit':'Average Quantity Per Unit'})

show_to_user(fig)","The input code correctly calculates the average quantity per unit for products supplied by each supplier, similar to the reference implementation. It uses a SQL query that joins the 'suppliers' and 'products' tables, grouping by supplier, and computes the average of quantities parsed from a string. The code displays the results using a bar chart, aligning with the business analytic request.",Finetuned
What is the average shipping cost per order for the current year?,"import pandas as pd
import plotly.express as px
from datetime import datetime

def get_average_shipping_cost_current_year():
    current_year = datetime.now().year  # Get the current year
    sql_query = f""""""
        SELECT AVG(orders.Freight) AS shipping_cost_per_order 
        FROM orders 
        WHERE YEAR(orders.OrderDate) = {current_year}
    """"""
    # Execute the SQL query
    result_df = execute_sql_query(sql_query)
    # Display the result to the user
    show_to_user(result_df)

get_average_shipping_cost_current_year()","import pandas as pd

# SQL query to get the average shipping cost per order for the current year
sql_query = """"""
SELECT AVG(orders.Freight) AS average_shipping_cost_per_order 
FROM orders 
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE())
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly calculates the average shipping cost per order for the current year using a SQL query that matches the logic of the reference implementation. It uses the function 'execute_sql_query' to run the query and 'show_to_user' to display the result, satisfying the business analytic request.","import pandas as pd
import plotly.express as px

# SQL query to get the average shipping cost per order for the current year
sql_query = """"""
SELECT AVG(Freight) AS AverageShippingCost
FROM orders
WHERE DATE_FORMAT(OrderDate, '%Y') = DATE_FORMAT(CURDATE(), '%Y');
""""""

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Extract the average shipping cost from the result
average_shipping_cost = result_df['AverageShippingCost'][0]
average_shipping_df = pd.DataFrame({'AverageShippingCost': [average_shipping_cost]})

# Display the average shipping cost to the user
show_to_user(average_shipping_df)","The input code correctly calculates the average shipping cost per order for the current year, similar to the reference implementation. It uses a SQL query to filter orders by the current year and calculates the average 'Freight'. The result is displayed to the user, meeting the business analytic request.",Base
Identify the top 3 regions by total sales revenue. Please include a data visualization to illustrate the results.,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to retrieve top 3 regions by total sales revenue
sql_query = '''
SELECT 
    customers.Region, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSalesRevenue 
FROM 
    customers 
INNER JOIN 
    orders 
ON 
    customers.CustomerID = orders.CustomerID 
INNER JOIN 
    [Order Details] 
ON 
    orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.Region 
ORDER BY 
    TotalSalesRevenue DESC 
LIMIT 3;
'''

# Execute the SQL query and retrieve the data
regions_sales_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty and has the expected columns
if not regions_sales_df.empty and 'Region' in regions_sales_df.columns and 'TotalSalesRevenue' in regions_sales_df.columns:
    # Creating a bar chart using plotly
    fig = px.bar(regions_sales_df, x='Region', y='TotalSalesRevenue', title='Top 3 Regions by Total Sales Revenue')
    # Display the figure
    show_to_user(fig)
else:
    print('The query did not return the expected data structure.')","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue by region
sql_query = '''
SELECT c.Region, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
ORDER BY TotalRevenue DESC
LIMIT 3
'''  

# Execute the SQL query to retrieve the data
results_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 3 regions by total sales revenue
fig = px.bar(results_df, x='Region', y='TotalRevenue', title='Top 3 Regions by Total Sales Revenue',
             labels={'TotalRevenue': 'Total Revenue', 'Region': 'Region'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the top 3 regions by total sales revenue using a SQL query and visualizes the results with a Plotly bar chart. The approach and outcome align with the reference implementation, satisfying the business analytic request.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT o.ShipRegion, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.ShipRegion 
ORDER BY TotalSales DESC 
LIMIT 3;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualization
fig = px.bar(result_df, x='ShipRegion', y='TotalSales', 
             title='Top 3 Regions by Total Sales Revenue', 
             labels={'ShipRegion': 'Region', 'TotalSales': 'Total Sales Revenue'})

# Show the result to the user
show_to_user(fig)","The evaluated code uses 'ShipRegion' instead of 'Region', which may not correspond to the same column as in the reference code. Differences in the join conditions or missing tables could affect the result, making the outputs inconsistent.",Base
How many orders were placed each month? Please include a data visualization to illustrate the trend.,"
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS TotalOrders FROM orders GROUP BY OrderMonth;
""""""

# Execute SQL Query and get the result as pandas dataframe
# Assuming execute_sql_query is defined and returns a pandas dataframe
try:
    df = execute_sql_query(sql_query)
except Exception as e:
    show_to_user(f'Error executing SQL query: {e}')

# Ensure the dataframe is not empty
if df.empty:
    show_to_user('The query returned no results.')
else:
    # Data visualization using plotly
    try:
        fig = px.line(df, x='OrderMonth', y='TotalOrders', title='Total Orders Placed Each Month', labels={'OrderMonth':'Month', 'TotalOrders':'Total Orders'})

        # Display the data visualization
        show_to_user(fig)
    except Exception as e:
        show_to_user(f'Error creating visualization: {e}')
","import pandas as pd
import plotly.express as px

# SQL query to count orders placed each month
sql_query = '''
SELECT DATE_TRUNC('month', OrderDate) AS month,
       COUNT(OrderID) AS order_count
FROM orders
GROUP BY month
ORDER BY month;
'''

# Execute the SQL query to retrieve data
monthly_orders_df = execute_sql_query(sql_query)

# Create a line plot to visualize the trend of orders placed each month
fig = px.line(monthly_orders_df, x='month', y='order_count',
              title='Number of Orders Placed Each Month',
              labels={'month': 'Month', 'order_count': 'Number of Orders'}))

# Show the data visualization to the user
show_to_user(fig)","The input code correctly executes a SQL query to count orders placed each month using DATE_TRUNC, similar to the reference code's DATE_FORMAT. It then creates a Plotly line plot to visualize the trend, fulfilling the business request. Column names differ, but the logic and outcome align with the reference.","import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, COUNT(*) AS order_count 
FROM orders 
GROUP BY month;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Ensure month column is treated as datetime
orders_df['month'] = pd.to_datetime(orders_df['month'], format='%Y-%m')

# Sort data by month
orders_df = orders_df.sort_values('month')

# Data visualization
fig = px.line(orders_df, x='month', y='order_count', title='Monthly Order Count', labels={'month': 'Month', 'order_count': 'Order Count'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly counts the number of orders each month using SQL, processes the data with pandas, and visualizes it using plotly, similar to the reference implementation. Column names and visualization labels differ but fulfill the business request.",Base
Which product has the highest cumulative discount in terms of dollar value?,"import pandas as pd
import plotly.express as px

# SQL query to get the product with the highest cumulative discount
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Discount * od.UnitPrice * od.Quantity) AS TotalDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalDiscount DESC
LIMIT 1;
'''

# Execute the query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Check if dataframe is not empty
if not df.empty:
    # Display the result to the user
    show_to_user(df)

    # Optionally, create a bar chart visualization
    fig = px.bar(df, x='ProductName', y='TotalDiscount', title='Product with Highest Cumulative Discount', labels={'TotalDiscount':'Total Discount ($)', 'ProductName':'Product Name'})
    show_to_user(fig)
else:
    show_to_user('No data available for the given query.')
","import pandas as pd

# Step 1: Retrieve data from the Order Details
sql_query = '''
SELECT ProductID, SUM(Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY ProductID
'''  
discount_data = execute_sql_query(sql_query)

# Step 2: Retrieve product names for the discounted products
sql_query_products = '''
SELECT ProductID, ProductName
FROM products
'''  
products_data = execute_sql_query(sql_query_products)

# Step 3: Merge total discounts with product names
merged_data = pd.merge(discount_data, products_data, on='ProductID')

# Step 4: Identify the product with the highest cumulative discount
highest_discount_product = merged_data.loc[merged_data['TotalDiscount'].idxmax()]

# Step 5: Prepare the result for display
result = pd.DataFrame([highest_discount_product])
show_to_user(result)","The evaluated code only aggregates discounts without considering unit price and quantity, which leads to an incorrect cumulative discount calculation.","import pandas as pd
import plotly.express as px

# Execute the SQL query to get the cumulative discounts
df = execute_sql_query(""""""
SELECT ProductID, SUM((UnitPrice * Quantity * Discount)) AS CumulativeDiscount
FROM [Order Details]
GROUP BY ProductID
ORDER BY CumulativeDiscount DESC
LIMIT 1;
"""""")

# Display the result to the user
show_to_user(df)","The input code does not retrieve the product name, only the ProductID and cumulative discount, whereas the reference code includes the ProductName in the output. Additionally, the input code does not provide a bar chart visualization or handle the scenario where no data is found.",None
How many different suppliers are there?,"import pandas as pd

# Define the SQL query to count distinct suppliers
sql_query = ""SELECT COUNT(DISTINCT SupplierID) AS SupplierCount FROM products;""

# Execute the SQL query and retrieve the result as a pandas dataframe
# It is assumed that the function execute_sql_query(sql_query) is available in the environment
# which connects to the database and executes the SQL query

df = execute_sql_query(sql_query)

# Extract the count of different suppliers from the dataframe
supplier_count = df['SupplierCount'].iloc[0]

# Format the result as a dataframe for display
result_df = pd.DataFrame({'Total Different Suppliers': [supplier_count]})

# Display the result to the user
# It is assumed that the function show_to_user(data) is available in the environment
# that takes a pandas dataframe or plotly figure and displays it to the user

show_to_user(result_df)","import pandas as pd

# SQL query to count distinct suppliers
sql_query = """"""
SELECT COUNT(DISTINCT SupplierID) AS distinct_supplier_count
FROM products;
""""""

# Execute the SQL query and retrieve the results
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code effectively counts the distinct suppliers using a SQL query. The query retrieves the count, and the result is displayed to the user. This achieves the same outcome as the reference implementation—the number of distinct suppliers is determined correctly and displayed, satisfying the business analytic request.","
import pandas as pd

# SQL Query to count the distinct suppliers
sql_query = 'SELECT COUNT(DISTINCT SupplierID) AS UniqueSuppliers FROM products;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the count of unique suppliers
unique_suppliers_count = result_df['UniqueSuppliers'].iloc[0]

# Display the result to the user
show_to_user(pd.DataFrame({'UniqueSuppliers': [unique_suppliers_count]}))
","The input Python code correctly executes a SQL query to count distinct suppliers. It retrieves the result using 'execute_sql_query' and extracts the count from the dataframe. The result is then displayed using 'show_to_user'. Even though the output column name differs ('UniqueSuppliers' vs 'SupplierCount'), it effectively answers the business request by counting the distinct suppliers, matching the reference implementation's outcome.",Base
What is the correlation between freight cost and fulfillment time? Please include a data visualization to illustrate the correlation.,"import plotly.express as px
import pandas as pd

# Execute the SQL query to retrieve the data
df = execute_sql_query(""SELECT Freight, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders;"")

# Calculate the correlation between Freight and FulfillmentTime
correlation = df['Freight'].corr(df['FulfillmentTime'])

# Print the correlation value
print(f'Correlation between Freight cost and Fulfillment time: {correlation}')

# Create a scatter plot to visualize the correlation
fig = px.scatter(df, x='Freight', y='FulfillmentTime', title='Correlation between Freight cost and Fulfillment time', labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (days)'})

# Show the plot to user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to fetch Freight cost and Fulfillment time
sql_query = '''
SELECT 
    Freight, 
    DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL 
''' 

# Execute the SQL query and store the results in a DataFrame
results_df = execute_sql_query(sql_query)

# Calculate correlation between Freight and FulfillmentTime
correlation = results_df['Freight'].corr(results_df['FulfillmentTime'])

# Create a scatter plot to visualize the correlation
fig = px.scatter(results_df, x='Freight', y='FulfillmentTime',
                 title='Correlation between Freight Cost and Fulfillment Time',
                 labels={'Freight': 'Freight Cost', 'FulfillmentTime': 'Fulfillment Time (days)'}
                )

# Show the correlation result to the user
show_to_user(fig)","The input code successfully addresses the business analytic request by calculating the correlation between freight cost and fulfillment time. It uses a SQL query to fetch the necessary data, calculates the correlation, and creates a scatter plot to visualize the relationship. The output effectively achieves the same outcome as the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to get the required data
def get_correlation_data():
    return execute_sql_query(""SELECT Freight, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders;"")

# Fetch data
data = get_correlation_data()

# Ensure column names match the query results
freight_col, fulfillment_col = 'Freight', 'FulfillmentTime'
if freight_col not in data.columns or fulfillment_col not in data.columns:
    raise ValueError(""Column names do not match expected names: 'Freight' and 'FulfillmentTime'"")

# Calculate correlation
correlation = data[freight_col].corr(data[fulfillment_col])
print(f'Correlation between Freight and FulfillmentTime: {correlation}')

# Data visualization
fig = px.scatter(data, x=freight_col, y=fulfillment_col, trendline='ols', 
                 title=f'Correlation between Freight and Fulfillment Time: {correlation:.2f}',
                 labels={freight_col: 'Freight Cost', fulfillment_col: 'Fulfillment Time'})

# Show plot
show_to_user(fig)","The input code correctly fulfills the business request by calculating the correlation between freight cost and fulfillment time, and it includes a data visualization using a scatter plot with a trendline. The approach and result match the reference implementation's outcome.",Base
Which employee made the highest sales on a specific date?,"import pandas as pd
import plotly.express as px

# Define the specific date for the analysis
target_date = 'YYYY-MM-DD'

# SQL query to find the employee with the highest sales on the specific date
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate = '{target_date}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the specific date we want to analyze
specific_date = '2023-10-01'  # Change this to your desired date

# SQL query to find the employee with the highest sales on the specified date
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate = '{specific_date}' 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the data
highest_sales_employee = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(highest_sales_employee)","The input code does not include employees' first and last names in the GROUP BY clause, unlike the reference implementation.","import pandas as pd
import plotly.express as px

# Define the specific date for which we want to find the employee with the highest sales
specific_date = ""2023-09-30""  # Replace this with the desired date

# Step 1: Write the SQL query
sql_query = f""""""
SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate = '{specific_date}' 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 1
""""""

# Step 2: Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Step 3: Display the result to the user
show_to_user(result_df)","The input code does not retrieve the employee's first and last names, only the EmployeeID, unlike the reference code, which retrieves both names alongside the TotalSales. This difference may impact the analysis if additional employee identification is required.",None
What is the average unit price of products in each category?,"import pandas as pd
import plotly.express as px

# Define the SQL query to get the average unit price of products in each category
sql_query = 'SELECT CategoryID, AVG(UnitPrice) AS AveragePrice FROM products GROUP BY CategoryID;'

# Execute the SQL query and get the result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user in tabular form
show_to_user(df)

# Create a plotly bar chart visualization for the average unit price by category
fig = px.bar(df, x='CategoryID', y='AveragePrice', title='Average Unit Price by Category', labels={'CategoryID':'Category ID', 'AveragePrice':'Average Unit Price'})

# Display the plotly bar chart
show_to_user(fig)","import pandas as pd

# Define the SQL query to calculate the average unit price of products in each category
sql_query = '''
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
WHERE p.Discontinued = 0
GROUP BY p.CategoryID
'''

# Execute the SQL query and retrieve the data into a DataFrame
average_unit_price_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(average_unit_price_df)","The input code adds a condition `WHERE p.Discontinued = 0` which is not present in the reference implementation. This means it only considers products that are not discontinued, potentially leading to different results.","import pandas as pd
import plotly.express as px

# SQL query to get the average unit price for each category
sql_query = 'SELECT CategoryID, AVG(UnitPrice) AS AveragePrice FROM products GROUP BY CategoryID;'

# Execute the SQL query and get the result as a pandas dataframe
result_df = execute_sql_query(sql_query)

# Ensure that the result_df has the correct column names
result_df.columns = ['CategoryID', 'AveragePrice']

# Display the result to the user
show_to_user(result_df)

# Visualization of average price per category
fig = px.bar(result_df, x='CategoryID', y='AveragePrice', title='Average Unit Price by Category', labels={'CategoryID': 'Category ID', 'AveragePrice': 'Average Unit Price'})
show_to_user(fig)","The input Python code correctly replicates the reference implementation's logic. It retrieves the average unit price of products for each category from the database using a SQL query, assigns appropriate column names, and displays both the data table and a Plotly bar chart. Both scripts fulfill the business analytic request.",Finetuned
Which product had the highest sales revenue in 2022? Please include a data visualization to illustrate the sales revenue of top products.,"import plotly.express as px

# SQL query to get the product with the highest sales revenue in 2022
sql_query = '''
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID 
ORDER BY product_sales DESC LIMIT 1
'''

# Execute the SQL query to retrieve data
sales_data = execute_sql_query(sql_query)

# Extract the ProductID with highest sales
highest_sales_product_id = sales_data['ProductID'].iloc[0]

# Additional query to get the sales data for visualization
sales_query = '''
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID 
ORDER BY product_sales DESC
'''

# Execute the additional query to get sales data for visualization
sales_data_for_viz = execute_sql_query(sales_query)

# Generate the bar plot for sales revenue of top products
fig = px.bar(sales_data_for_viz, x='ProductID', y='product_sales', title='Sales Revenue of Top Products in 2022')

# Show the plot to the user
show_to_user(fig)

# Print the product with the highest sales revenue
show_to_user(f'Product with the highest sales revenue in 2022: {highest_sales_product_id}')","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue for each product in 2022
sql_query = '''
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY products.ProductID, products.ProductName 
ORDER BY total_sales DESC
'''  

# Execute the SQL query and retrieve the data
product_sales = execute_sql_query(sql_query)

# Identify the product with the highest sales revenue
highest_sales_product = product_sales.iloc[0]

# Show the result to the user
show_to_user(highest_sales_product)

# Data visualization for sales revenue of top products
fig = px.bar(product_sales.head(10), x='ProductName', y='total_sales', 
             title='Top 10 Products by Sales Revenue in 2022', 
             labels={'total_sales': 'Total Sales Revenue', 'ProductName': 'Product Name'})

# Display the plot
show_to_user(fig)","The input code correctly addresses the business analytic request by identifying the product with the highest sales revenue in 2022 and visualizing the sales revenue of the top products. It successfully executes the SQL query to obtain the necessary data, identifies the highest sales product, and generates a bar chart for the top 10 products using Plotly. The outcome aligns with the reference implementation.","import plotly.express as px

# SQL Query to get the highest sales revenue product in 2022
sql_query = '''
SELECT 
    products.ProductID,
    products.ProductName,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS sales_revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY sales_revenue DESC
'''  # Removed LIMIT 1 to get all data for visualization

# Execute SQL Query and retrieve data
sales_data = execute_sql_query(sql_query)

# Display the product with highest sales revenue
highest_sales_product = sales_data.iloc[0]
print(f""Product with highest sales revenue in 2022: {highest_sales_product['ProductName']} ({highest_sales_product['sales_revenue']})"")

# Data visualization for the top products
fig = px.bar(sales_data, x='ProductName', y='sales_revenue', title='Sales Revenue of Top Products in 2022', labels={'sales_revenue': 'Sales Revenue', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly addresses the business analytic request by identifying the product with the highest sales revenue in 2022 and providing a data visualization. It uses a similar SQL query to the reference code, albeit without the LIMIT 1 to facilitate visualization. The code effectively determines and displays the top product and generates a corresponding bar plot, meeting the requirements.",Base
How many orders have been placed by each customer? Please include a data visualization to show the distribution of orders per customer.,"import pandas as pd
import plotly.express as px

# SQL query to get the count of orders placed by each customer
sql_query = 'SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY CustomerID'

# Execute the query and retrieve the data into a pandas dataframe
df_orders = execute_sql_query(sql_query)

# Data visualization using plotly
fig = px.histogram(df_orders, x='OrderCount', nbins=20, title='Distribution of Orders per Customer', labels={'OrderCount':'Number of Orders'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to count the number of orders placed by each customer
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
'''  

# Execute the SQL query
order_counts_df = execute_sql_query(sql_query)

# Display the dataframe to the user
show_to_user(order_counts_df)

# Data visualization: Plotting the distribution of orders per customer
fig = px.bar(order_counts_df, x='CustomerID', y='OrderCount', title='Distribution of Orders per Customer',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'},
             color='OrderCount',
             text='OrderCount')
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig.update_layout(xaxis_title='Customer ID', yaxis_title='Number of Orders')

# Show the plot to the user
show_to_user(fig)","The input code correctly fulfills the business analytic request by accurately counting the number of orders per customer and visualizing the distribution using a bar chart. This aligns with the reference implementation, which uses a histogram, and both achieve the same outcome.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT CustomerID, COUNT(*) AS OrderCount FROM orders GROUP BY CustomerID;'

# Execute the SQL query and retrieve the data
customer_orders_df = execute_sql_query(sql_query)

# Check if the dataframe columns are as expected
if 'CustomerID' not in customer_orders_df.columns or 'OrderCount' not in customer_orders_df.columns:
    raise ValueError(""Unexpected dataframe structure"")

# Create a bar plot to show the distribution of orders per customer
fig = px.bar(customer_orders_df, x='CustomerID', y='OrderCount', title='Order Count per Customer', labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'})

# Show the plot to the user
show_to_user(fig)","The input Python code correctly calculates the number of orders placed by each customer using a SQL query and visualizes the data. The main difference from the reference implementation is the use of a bar chart instead of a histogram, which is still valid as it shows the distribution of orders per customer, thereby addressing the business analytic request effectively.",Base
Which employee generated the most sales in Q4 2023? Please include a data visualization to compare sales generated by all employees.,"import plotly.express as px

# Define the SQL query
sql_query = '''SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 1'''

# Execute the SQL query and get the result as a pandas dataframe
sales_df = execute_sql_query(sql_query)

# Get the top employee who generated the most sales
top_employee_id = sales_df.iloc[0]['EmployeeID']

# Modify the SQL query to get sales data for all employees
all_sales_query = '''SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID
ORDER BY total_sales DESC''' 

# Execute the SQL query and get the result as a pandas dataframe
all_sales_df = execute_sql_query(all_sales_query)

# Create a bar chart to visualize the sales generated by all employees
fig = px.bar(all_sales_df, x='EmployeeID', y='total_sales', title='Total Sales by Employee in Q4 2023', labels={'total_sales': 'Total Sales ($)', 'EmployeeID': 'Employee ID'}, text='total_sales')

# Update layout to enhance visualization
fig.update_layout(xaxis=dict(tickmode='linear'))

# Display the result to the user
show_to_user(fig)

# Also show the top employee ID and their total sales
show_to_user(sales_df)","import pandas as pd
import plotly.express as px

# SQL query to get employee sales for Q4 2023
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
""""""

# Execute SQL query and retrieve data
employee_sales_df = execute_sql_query(sql_query)

# Identify the employee with the most sales
top_employee = employee_sales_df.loc[employee_sales_df['employee_sales'].idxmax()]

# Display the top employee
print(f'The employee with the most sales in Q4 2023 is: {top_employee.FirstName} {top_employee.LastName} with sales of ${top_employee.employee_sales:.2f}.')

# Plot the sales comparison for all employees
fig = px.bar(employee_sales_df, x='FirstName', y='employee_sales',
             title='Employee Sales in Q4 2023',
             labels={'FirstName': 'Employee', 'employee_sales': 'Total Sales ($)'})

# Show the plot to the user
show_to_user(fig)","The input code successfully identifies the employee with the most sales in Q4 2023 and visualizes the sales of all employees using a bar chart. Although it includes additional details like employee names, it fulfills the business request and achieves the same outcome as the reference implementation.","import plotly.express as px


def main():
    # SQL query to find the employee who generated the most sales in Q4 2023
    sql_query = '''
    SELECT employees.EmployeeID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    JOIN employees ON orders.EmployeeID = employees.EmployeeID 
    WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
    GROUP BY employees.EmployeeID 
    ORDER BY employee_sales DESC 
    LIMIT 1''' 

    # Execute SQL query
    top_sales_employee = execute_sql_query(sql_query)

    # Get all employee sales for Q4 2023
    all_sales_query = '''
    SELECT employees.EmployeeID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    JOIN employees ON orders.EmployeeID = employees.EmployeeID 
    WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31' 
    GROUP BY employees.EmployeeID 
    ORDER BY employee_sales DESC''' 

    # Execute SQL query to get all employee sales
    all_sales_data = execute_sql_query(all_sales_query)

    # Visualize the data
    fig = px.bar(all_sales_data, x='EmployeeID', y='employee_sales', title='Q4 2023 Sales by Employee', labels={'EmployeeID':'Employee ID', 'employee_sales':'Sales ($)'})

    # Show the plot to the user
    show_to_user(fig)

    # Display the top sales employee info
    print(f'Top Sales Employee in Q4 2023: {top_sales_employee.iloc[0][""EmployeeID""]}, Sales: {top_sales_employee.iloc[0][""employee_sales""]}')

if __name__ == ""__main__"":
    main()","The input Python code effectively implements the business analytic request by querying the database to determine the employee with the most sales in Q4 2023. The code also retrieves sales data for all employees during this period and visualizes it using a bar chart, which meets the requirement of comparing sales for all employees. The output and logic are consistent with the reference implementation, even though the naming of some variables (e.g., 'employee_sales' vs 'total_sales') is slightly different. Overall, the code addresses the request correctly and effectively.",Base
"What is the maximum, minimum, and average salary of the employees?","import pandas as pd
import plotly.express as px

# SQL query
sql_query = ""SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees;""

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(result_df)

# Additionally, we can visualize the data using plotly
# Convert the result to a long format for better visualization in plotly
result_long_df = result_df.melt(var_name='Statistic', value_name='Salary')
fig = px.bar(result_long_df, x='Statistic', y='Salary', title='Salary Statistics', labels={'Statistic': 'Statistic', 'Salary': 'Salary'})
show_to_user(fig)","import pandas as pd

# SQL query to retrieve salary data from employees table
sql_query = ""SELECT Salary FROM employees""

# Execute the SQL query using the provided utility function
salary_data = execute_sql_query(sql_query)

# Calculate maximum, minimum, and average salary
max_salary = salary_data['Salary'].max()
min_salary = salary_data['Salary'].min()
avg_salary = salary_data['Salary'].mean()

# Create a result dataframe to display the results
result_df = pd.DataFrame({
    'Metric': ['Maximum Salary', 'Minimum Salary', 'Average Salary'],
    'Value': [max_salary, min_salary, avg_salary]
})

# Display the result to the user using the provided function
show_to_user(result_df)","The input code correctly calculates the maximum, minimum, and average salary, achieving the same outcome as the reference implementation. While the method of calculating the metrics differs (SQL vs. Python), the results are equivalent.","import pandas as pd
import plotly.express as px

# Execute the SQL query to get the max, min, and avg salary
sql_query = 'SELECT MAX(Salary) AS MaxSalary, MIN(Salary) AS MinSalary, AVG(Salary) AS AvgSalary FROM employees;'
salary_df = execute_sql_query(sql_query)

# Display the result of the SQL query to the user
show_to_user(salary_df)
","The input code does not include the visualization part that the reference implementation has using Plotly, which is also considered part of the business request. The statistical data is fetched and displayed correctly, but the Plotly visualization is missing.",Base
What is the average discount given per order in the last week?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT AVG([Order Details].Discount) AS Average_Discount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 WEEK);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to calculate the average discount per order in the last week
sql_query = '''
SELECT AVG([Order Details].Discount) AS AverageDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= NOW() - INTERVAL '7 DAYS'
'''  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input Python code successfully calculates the average discount per order in the last week. The use of NOW() - INTERVAL '7 DAYS' is equivalent to DATE_SUB(CURDATE(), INTERVAL 1 WEEK) used in the reference code. The logic and outcome are the same.","import pandas as pd

# Define the SQL query
sql_query = '''
SELECT AVG([Order Details].Discount) AS AverageDiscount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= DATEADD(day, -7, CURRENT_DATE);
'''

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Extract the average discount from the result
if not result_df.empty:
    avg_discount = result_df.iloc[0]['AverageDiscount']
else:
    avg_discount = 0

# Convert the average discount to a DataFrame for display
avg_discount_df = pd.DataFrame({'AverageDiscount': [avg_discount]})

# Display the result to the user
show_to_user(avg_discount_df)","The evaluated code calculates the average discount per order in the last week, which matches the business analytic request and achieves the same outcome as the reference implementation. Although there are slight differences in syntax (using DATEADD instead of DATE_SUB), the logic and result are correct.",Base
What is the average order value for the year 2022?,"import pandas as pd
import plotly.express as px

# SQL query to calculate average order value for the year 2022
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate the Average Order Value for the year 2022
sql_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
""""""

# Execute the SQL query
average_order_value_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_order_value_df)",The input code correctly calculates the average order value for 2022 by executing the same SQL query used in the reference implementation and displaying the result with 'show_to_user'. The implementation successfully addresses the business analytic request.,"import pandas as pd
import plotly.express as px

# SQL query to get the average order value for the year 2022
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result
display_df = result_df[['avg_order_value']]
show_to_user(display_df)","The input code correctly executes the SQL query to calculate the average order value for the year 2022, matching the reference implementation and fulfilling the business analytic request. The extraction of 'avg_order_value' from the result dataframe is consistent with the intended output.",Base
How many orders were placed by each customer in the last quarter of 2022? Please include a data visualization to show the orders per customer.,"import pandas as pd
import plotly.express as px

# SQL query to get order count per customer for Q4 2022
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate BETWEEN '2022-10-01' AND '2022-12-31' 
GROUP BY CustomerID
""""""

# Execute SQL query and retrieve the result as a pandas dataframe
order_counts_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the orders per customer
fig = px.bar(order_counts_df, x='CustomerID', y='OrderCount', title='Orders per Customer in Q4 2022')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve the number of orders placed by each customer in the last quarter of 2022
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= '2022-10-01' AND OrderDate <= '2022-12-31'
GROUP BY CustomerID
ORDER BY OrderCount DESC;
'''  

# Execute the SQL query and retrieve the data
order_counts = execute_sql_query(sql_query)

# Visualize the order counts per customer using Plotly
fig = px.bar(order_counts, x='CustomerID', y='OrderCount', title='Number of Orders per Customer in Q4 2022',
             labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Show the visualization to the user
show_to_user(fig)",The input code correctly executes a SQL query to count the number of orders per customer for the last quarter of 2022 and then uses Plotly to create a bar chart for visualization. It effectively addresses the business analytic request and matches the outcome of the reference implementation. Differences such as the ordering of the results do not affect the correctness in terms of meeting the requirements.,"import pandas as pd
import plotly.express as px

# SQL query to get the order count for each customer in the last quarter of 2022
sql_query = '''
SELECT customers.CustomerID, COUNT(orders.OrderID) AS total_orders
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
WHERE orders.OrderDate BETWEEN '2022-10-01' AND '2022-12-31'
GROUP BY customers.CustomerID
'''

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Generate a bar plot using plotly
fig = px.bar(order_data, x='CustomerID', y='total_orders', title='Total Orders per Customer in Q4 2022', labels={'CustomerID':'Customer ID', 'total_orders':'Total Orders'})

# Show the plot to the user
show_to_user(fig)","The input code correctly calculates the number of orders placed by each customer in the last quarter of 2022 and visualizes it using a bar plot. The SQL query effectively gathers the needed order counts, and the visualization displays orders per customer as required by the business analytic request. The solution aligns with the reference implementation's logic and outcome.",Base
What is the total quantity of products ordered in each month of the current year? Please include a data visualization to show the quantity ordered per month.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(od.Quantity) AS TotalQuantityOrdered 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY Month;
'''

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Create the data visualization
fig = px.bar(df, x='Month', y='TotalQuantityOrdered', title='Total Quantity of Products Ordered Per Month', labels={'Month': 'Month', 'TotalQuantityOrdered': 'Total Quantity Ordered'})
fig.update_xaxes(type='category')  # Ensure the x-axis is treated as a category

# Show the data visualization to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# Query to get total quantity of products ordered per month for current year
sql_query = '''
SELECT YEAR(o.OrderDate) AS Year,
       MONTH(o.OrderDate) AS Month,
       SUM(od.Quantity) AS TotalQuantity
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = YEAR(CURDATE())
GROUP BY YEAR(o.OrderDate), MONTH(o.OrderDate)
ORDER BY Month;
'''  

# Execute SQL query
monthly_data = execute_sql_query(sql_query)

# Create a line plot to visualize the total quantity ordered per month
fig = px.line(monthly_data, x='Month', y='TotalQuantity', title='Total Quantity of Products Ordered per Month',
              labels={'TotalQuantity': 'Total Quantity Ordered', 'Month': 'Month'},
              line_shape='linear')

# Show the plot to user
show_to_user(fig)","The input code correctly calculates the total quantity of products ordered per month for the current year and generates a visualization. Both the reference and input implementations use SQL to aggregate data and visualization using Plotly. The reference implementation uses a bar chart, whereas the input uses a line chart, but both accurately represent the requested data.","import pandas as pd
import plotly.express as px

# SQL query to get total quantity of products ordered in each month of the current year
sql_query = '''
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].Quantity) AS TotalQuantity
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE())
GROUP BY Month;
'''

# Execute the SQL query using the provided utility function
orders_df = execute_sql_query(sql_query)

# Convert Month column to datetime for proper plotting
orders_df['Month'] = pd.to_datetime(orders_df['Month']).dt.to_period('M').dt.to_timestamp()

# Create a plotly bar chart
fig = px.bar(orders_df, x='Month', y='TotalQuantity', title='Total Quantity of Products Ordered Per Month This Year', labels={'TotalQuantity':'Total Quantity', 'Month':'Month'})
fig.update_layout(xaxis_title='Month', yaxis_title='Total Quantity')

# Display the visualization to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by executing an SQL query to calculate the total quantity of products ordered for each month of the current year. It matches the logic of the reference implementation and produces a plotly bar chart to visualize the data. Differences in the code do not affect the outcome, making it functionally equivalent to the reference implementation.",Base
How many orders included products with more than a 10% discount?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT COUNT(DISTINCT od.OrderID) as NumberOfOrders FROM [Order Details] od WHERE od.Discount > 0.10""

# Execute the SQL query
orders_with_discount_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(orders_with_discount_df)","import pandas as pd

# SQL query to count the number of orders with products having more than 10% discount
sql_query = '''
SELECT COUNT(DISTINCT od.OrderID) AS OrderCount
FROM [Order Details] od
WHERE od.Discount > 0.10
'''

# Execute the SQL query and retrieve data
order_count_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(order_count_df)","The input code correctly executes a SQL query to count distinct orders with more than a 10% discount, identical to the reference implementation, fulfilling the business analytic request.","import pandas as pd

# Execute the SQL query
sql_query = ""SELECT COUNT(DISTINCT OrderID) AS NumberOfOrders FROM [Order Details] WHERE Discount > 0.1;""
result_df = execute_sql_query(sql_query)

# Extract the count from the DataFrame
number_of_orders = result_df['NumberOfOrders'].iloc[0]

# Prepare the result for display
result_display_df = pd.DataFrame({'Measure': ['Number of Orders With > 10% Discount'], 'Count': [number_of_orders]})

# Show the result to the user
show_to_user(result_display_df)",The input code correctly executes the same SQL query as the reference code and accurately displays the count of distinct orders with more than a 10% discount. The additional steps to reformat the display do not alter the correct result and purpose.,Base
What is the inventory turnover ratio for the past month?,"import pandas as pd
import plotly.express as px

# SQL query to fetch inventory turnover ratio for the past month
sql_query = '''
SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 MONTH');
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate Inventory Turnover Ratio for the past month
sql_query = '''
SELECT 
    SUM(od.Quantity * od.UnitPrice) AS COGS, 
    AVG(p.UnitsInStock) AS Avg_Inventory
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    od.OrderID IN (
        SELECT OrderID FROM Orders WHERE OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month') 
        AND OrderDate < DATE_TRUNC('month', CURRENT_DATE)
    )
'''  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate Inventory Turnover Ratio
if not result_df.empty:
    inventory_turnover_ratio = result_df['COGS'].iloc[0] / result_df['Avg_Inventory'].iloc[0] if result_df['Avg_Inventory'].iloc[0] != 0 else 0
else:
    inventory_turnover_ratio = None

# Show the result to the user
show_to_user(pd.DataFrame({'Inventory Turnover Ratio': [inventory_turnover_ratio]}))","The input code calculates COGS and Avg_Inventory but the query logic to get orders from the past month is different. The reference uses EXTRACT(MONTH) matching, while the input uses DATE_TRUNC for precise past month filtering. This difference can lead to different results if the datasets include more than one year. Therefore, the input code might not achieve the same outcome as the reference implementation.","To calculate the inventory turnover ratio for the past month, we can use the formula:

\[
\text{Inventory Turnover Ratio} = \frac{\text{Cost of Goods Sold}}{\text{Average Inventory}}
\]

Here's the step-by-step breakdown and the corresponding Python code using the provided utility function `sql_query` and `show_to_user`:

1. Query the past month's Cost of Goods Sold (COGS).
2. Query the average inventory for the past month.
3. Calculate the Inventory Turnover Ratio using the retrieved values.

```python
import pandas as pd

# Step 1: Query for Cost of Goods Sold (COGS) for the past month
cogs_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS COGS 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) AND CURRENT_DATE;
""""""

# Executing the COGS query
cogs_df = sql_query(cogs_query)
if not cogs_df.empty:
    cogs_value = cogs_df.iloc[0]['COGS']
else:
    cogs_value = 0

# Step 2: Query for Average Inventory for the past month
avg_inventory_query = """"""
SELECT AVG(Quantity) AS AvgInventory 
FROM products p 
WHERE p.ProductID IN (
    SELECT DISTINCT od.ProductID 
    FROM [Order Details] od 
    JOIN orders o ON od.OrderID = o.OrderID 
    WHERE o.OrderDate BETWEEN DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) AND CURRENT_DATE
);
""""""

# Executing the Avg Inventory query
avg_inventory_df = sql_query(avg_inventory_query)
if not avg_inventory_df.empty:
    avg_inventory_value = avg_inventory_df.iloc[0]['AvgInventory']
else:
    avg_inventory_value = 1  # to avoid division by zero

# Step 3: Calculating Inventory Turnover Ratio
inventory_turnover_ratio = cogs_value / avg_inventory_value

# Prepare the results for visualization
results_df = pd.DataFrame({""Metric"": [""Inventory Turnover Ratio""], ""Value"": [inventory_turnover_ratio]})

# Displaying the results to the user
show_to_user(results_df)
```

### Explanation of the Code:
1. **Querying COGS**: We retrieve the COGS for orders placed in the last month using appropriate SQL joins.
2. **Querying Average Inventory**: We retrieve the average inventory of products that were sold in the last month.
3. **Calculating Inventory Turnover**: We calculate the inventory turnover by dividing the COGS by the average inventory.
4. **Displaying Results**: Finally, we format the results into a DataFrame and display it to the user.

### Notes:
- Default safeguard for the average inventory is set to 1 to prevent division by zero errors (though logically this should not happen).
- The SQL queries are simple aggregate queries, and assuming the COGS will not return null, we directly calculate using the first row's value.
- Constructed DataFrame for clarity in presentation.","The input code uses different methods to calculate COGS and Average Inventory compared to the reference implementation. The input code calculates COGS with discounts considered and uses the quantity for an average, while the reference code uses the sum of Quantity times UnitPrice without considering the discount, and average stock. These differences affect the outcome.",None
Find the top 3 cities with the most orders placed. Please include a data visualization to show the number of orders per city.,"import plotly.express as px
import pandas as pd

# SQL query to find top 3 cities with the most orders
sql_query = 'SELECT ShipCity, COUNT(*) AS total_orders FROM orders GROUP BY ShipCity ORDER BY total_orders DESC LIMIT 3;'

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Ensure the column names are correct in the dataframe
order_data.columns = ['ShipCity', 'total_orders']

# Data visualization
fig = px.bar(order_data, x='ShipCity', y='total_orders', title='Top 3 Cities with Most Orders', labels={'ShipCity': 'City', 'total_orders': 'Total Orders'})

# Show the data and visualization to the user
show_to_user(fig)

# Display the data in tabular form
show_to_user(order_data)","import pandas as pd
import plotly.express as px

# SQL query to find the top 3 cities with the most orders placed
sql_query = """"""
SELECT customers.City, COUNT(orders.OrderID) AS NumberOfOrders
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.City
ORDER BY NumberOfOrders DESC
LIMIT 3
""""""

# Execute the query and retrieve the data
top_cities_df = execute_sql_query(sql_query)

# Display the top cities data to the user
top_cities_df

# Visualization using Plotly
total_orders = top_cities_df['NumberOfOrders']
top_cities = top_cities_df['City']

fig = px.bar(top_cities_df, x='City', y='NumberOfOrders',
             title='Top 3 Cities with Most Orders Placed',
             labels={'NumberOfOrders': 'Number of Orders', 'City': 'City'},
             color='NumberOfOrders')

# Show visualization to user
show_to_user(fig)","The input code correctly executes a query to find the top 3 cities with the most orders by joining the customers and orders tables. It groups and orders the results properly. It then visualizes the results using Plotly, creating a bar chart. The solution addresses the business request and mimics the functionality of the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 3;
'''

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Data visualization
fig = px.bar(orders_df, x='ShipCity', y='OrderCount', 
             title='Top 3 Cities with the Most Orders Placed',
             labels={'ShipCity':'City', 'OrderCount':'Number of Orders'})

# Display the result to the user
show_to_user(fig)",The input code correctly implements the business analytic request by finding and visualizing the top 3 cities with the most orders. It uses a similar SQL query and generates the same visualization using Plotly. The column name difference is minor and does not affect the correctness.,Base
What is the average shipping cost per order for orders shipped to 'Canada'?,"import pandas as pd

# Define the SQL query
sql_query = ""SELECT AVG(Freight) AS AverageShippingCost FROM orders WHERE ShipCountry = 'Canada';""

# Execute the SQL query to fetch the data
result_df = execute_sql_query(sql_query)

# Ensure the data is a single value dataframe
if not result_df.empty and 'AverageShippingCost' in result_df.columns:
    avg_shipping_cost = result_df['AverageShippingCost'][0]
    print(f""Average Shipping Cost for orders shipped to Canada: {avg_shipping_cost}"")
    # Display the result to the user as a dataframe
    show_to_user(pd.DataFrame({'AverageShippingCost': [avg_shipping_cost]}))
else:
    print(""No data found"")","import pandas as pd

# SQL query to calculate the average shipping cost per order for orders shipped to Canada
sql_query = """"""
SELECT AVG(Freight) as average_shipping_cost
FROM orders
WHERE ShipCountry = 'Canada'
""""""

# Execute the SQL query and retrieve the data
average_shipping_cost_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_shipping_cost_df)",The evaluated code correctly calculates the average shipping cost for orders shipped to Canada using a SQL query and displays the result to the user with 'show_to_user'. It aligns with the business request and achieves the same outcome as the reference implementation.,"import pandas as pd

# Define the SQL query
db_query = """"""
SELECT AVG(Freight) AS AverageShippingCost
FROM orders
WHERE ShipCountry = 'Canada';
""""""

# Execute the query to get the result as a pandas dataframe
df = execute_sql_query(db_query)

# Display the result to the user
show_to_user(df)","The provided code correctly executes the SQL query to calculate the average shipping cost for orders shipped to Canada, stores it in a DataFrame, and displays the result using the show_to_user function. The steps align with the business analytic request and reference implementation, despite slight differences in column handling.",Base
What is the retention rate of customers comparing the first half of 2023 to the previous year?,"import plotly.express as px
import pandas as pd

# Query to fetch unique customers count in the first half of 2023
query_2023 = '''SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_2023 
FROM orders o 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-06-30' '''

# Query to fetch unique customers count before 2023
query_previous = '''SELECT COUNT(DISTINCT o.CustomerID) AS customer_count_previous 
FROM orders o 
WHERE o.OrderDate < '2023-01-01' '''

# Execute the queries
result_2023 = execute_sql_query(query_2023)
result_previous = execute_sql_query(query_previous)

# Extract counts from the results
customer_count_2023 = result_2023['customer_count_2023'].iloc[0]
customer_count_previous = result_previous['customer_count_previous'].iloc[0]

# Calculate the customer retention rate
if customer_count_previous != 0:  # To avoid division by zero
    customer_retention_rate = customer_count_2023 / customer_count_previous
else:
    customer_retention_rate = 0

# Prepare a DataFrame for visualization
retention_data = pd.DataFrame({
    'Period': ['Before 2023', 'First Half of 2023'],
    'Customer Count': [customer_count_previous, customer_count_2023]
})

# Create a bar plot using plotly
fig = px.bar(retention_data, x='Period', y='Customer Count', title=f'Customer Retention Rate: {customer_retention_rate:.2f}', text='Customer Count')

# Show the plot to the user
show_to_user(fig)","import pandas as pd

# Define date ranges for the two periods
first_half_2023_start = '2023-01-01'
first_half_2023_end = '2023-06-30'
previous_year_end = '2022-12-31'
previous_year_start = '2022-01-01'

# SQL query to get the count of returning customers in first half of 2023
retaining_customers_query = f""""""
SELECT COUNT(DISTINCT orders.CustomerID) AS returning_customers
FROM orders
WHERE orders.OrderDate BETWEEN '{first_half_2023_start}' AND '{first_half_2023_end}'
AND orders.CustomerID IN (
    SELECT CustomerID
    FROM orders
    WHERE OrderDate < '{first_half_2023_start}'
)
""""""

# SQL query to get the count of total customers in the first half of 2023
total_customers_query = f""""""
SELECT COUNT(DISTINCT orders.CustomerID) AS total_customers
FROM orders
WHERE orders.OrderDate BETWEEN '{first_half_2023_start}' AND '{first_half_2023_end}'
""""""

# Execute the queries
returning_customers_df = execute_sql_query(retaining_customers_query)
total_customers_df = execute_sql_query(total_customers_query)

# Calculate the retention rate
returning_customers = returning_customers_df['returning_customers'].iloc[0]
total_customers = total_customers_df['total_customers'].iloc[0]
retention_rate = (returning_customers / total_customers) * 100 if total_customers > 0 else 0

# Prepare the result
result = pd.DataFrame({'Retention Rate (%)': [retention_rate]})

# Show the result to the user
show_to_user(result)","The input code calculates a retention rate as the percentage of returning customers out of total customers for the first half of 2023, which is a different metric from the reference code. The reference implementation measures retention as the ratio of unique customers in the first half of 2023 to those before 2023.","import pandas as pd
from plotly import express as px

# Define SQL queries for the first half of 2023 and the previous year
query_2023 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS customer_count 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-06-30'
""""""

query_previous_year = """"""
SELECT COUNT(DISTINCT orders.CustomerID) AS customer_count 
FROM orders 
WHERE orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

# Execute SQL queries and get the results
try:
    customer_count_2023_df = execute_sql_query(query_2023)
    customer_count_previous_year_df = execute_sql_query(query_previous_year)
except Exception as e:
    show_to_user(f""Error executing SQL query: {str(e)}"")
    raise

# Extract the customer counts
try:
    customer_count_2023 = customer_count_2023_df['customer_count'].iloc[0]
    customer_count_previous_year = customer_count_previous_year_df['customer_count'].iloc[0]
except Exception as e:
    show_to_user(f""Error extracting customer counts: {str(e)}"")
    raise

# Calculate the retention rate
if customer_count_previous_year == 0:
    show_to_user(""Cannot calculate retention rate because previous year customer count is zero."")
    retention_rate = 0
else:
    retention_rate = customer_count_2023 / customer_count_previous_year

# Prepare the dataframe for visualization
retention_rate_df = pd.DataFrame({'Period': ['First Half of 2023'], 'Retention Rate': [retention_rate]})

# Create a simple bar chart
fig = px.bar(retention_rate_df, x='Period', y='Retention Rate', title='Customer Retention Rate Comparison')

# Show the bar chart to the user
show_to_user(fig)
","The input code uses the previous year (2022) instead of all previous periods before 2023 to calculate retention, which deviates from the reference implementation's intent of comparing to all previous customers.",None
How many distinct products have been ordered?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(DISTINCT ProductID) AS DistinctProducts FROM [Order Details]'

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(result_df)","import pandas as pd

# SQL query to count distinct products ordered
sql_query = """"""
SELECT COUNT(DISTINCT ProductID) AS distinct_products_count
FROM [Order Details]
""""""

# Execute the SQL query using the provided utility function
distinct_products_count_df = execute_sql_query(sql_query)

# Show the result to the user using the provided utility function
show_to_user(distinct_products_count_df)","The input code correctly executes an SQL query that counts the distinct products ordered, matching the business analytic request. The outcome will be the same as the reference implementation since both use COUNT(DISTINCT ProductID). Differences in variable names and alias do not affect correctness.","import pandas as pd

# Construct the SQL query
sql_query = 'SELECT COUNT(DISTINCT ProductID) as DistinctProductCount FROM [Order Details];'

# Execute the SQL query using the provided function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The code successfully constructs and executes a SQL query to count the distinct 'ProductID' in the '[Order Details]' table, similar to the reference implementation. The difference in alias name does not affect the correctness.",Base
How many orders were placed each month by each customer? Please include a data visualization to show monthly orders per customer.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT c.CustomerID, DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth, COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID, OrderMonth;'''

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Generate the plot
fig = px.bar(orders_data, x='OrderMonth', y='OrderCount', color='CustomerID', 
             labels={'OrderMonth':'Order Month', 'OrderCount':'Number of Orders', 'CustomerID':'Customer ID'},
             title='Monthly Orders per Customer')

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the count of orders placed by each customer per month
sql_query = '''
SELECT
    c.CustomerID,
    c.CompanyName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
    COUNT(o.OrderID) AS OrderCount
FROM
    customers c
JOIN
    orders o ON c.CustomerID = o.CustomerID
GROUP BY
    c.CustomerID, OrderMonth
ORDER BY
    c.CustomerID, OrderMonth
'''

# Execute the SQL query and retrieve the data
monthly_orders = execute_sql_query(sql_query)

# Visualizing the monthly orders per customer using Plotly
fig = px.line(monthly_orders,
              x='OrderMonth',
              y='OrderCount',
              color='CompanyName',
              title='Monthly Orders per Customer',
              labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)","The input code successfully retrieves the number of orders per customer per month, and visualizes the data using a line chart with the customer's company name as a color differentiator. The choice to use a line chart instead of a bar chart is acceptable as it effectively displays the same information specified by the business request. The core functionality and outcome remain consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve the required data
sql_query = """"""
SELECT DATE_FORMAT(O.OrderDate, '%Y-%m') AS order_month, O.CustomerID, COUNT(*) AS order_count 
FROM orders O 
GROUP BY order_month, O.CustomerID;
""""""

# Execute the query to get the dataframe
orders_df = execute_sql_query(sql_query)

# Ensure 'order_month' is treated as a string for proper plotting
orders_df['order_month'] = orders_df['order_month'].astype(str)

# Create a plotly line chart to visualize monthly orders per customer
fig = px.line(orders_df, x='order_month', y='order_count', color='CustomerID', title='Monthly Orders per Customer')

# Display the figure to the user
show_to_user(fig)
```","The input code incorrectly groups by 'order_month' before 'CustomerID', which may lead to a different outcome. It also visualizes with a line chart instead of a bar chart. Both deviations could result in discrepancies from the reference implementation output.",Base
What is the hire date of the oldest employee?,"import pandas as pd
import plotly.express as px

# SQL Query to find the hire date of the oldest employee
sql_query = 'SELECT e.FirstName, e.LastName, e.HireDate FROM employees e ORDER BY e.HireDate ASC LIMIT 1'

# Execute the SQL query using the provided utility function
employee_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(employee_df)","sql_query = ""SELECT HireDate FROM employees WHERE BirthDate = (SELECT MIN(BirthDate) FROM employees)"" 
oldest_employee_hire_date = execute_sql_query(sql_query) 
show_to_user(oldest_employee_hire_date)","The input code evaluates the hire date of the employee with the earliest birth date, not the earliest hire date as requested by the business analytics request. The query should order by HireDate, not BirthDate.","
import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query to find the hire date of the oldest employee
sql_query = ""SELECT HireDate FROM employees ORDER BY HireDate ASC LIMIT 1;""

# Step 2: Execute the SQL query using the provided utility function
employees_df = execute_sql_query(sql_query)

# Step 3: Extract the hire date
hire_date_of_oldest_employee = employees_df.iloc[0]['HireDate']

# Step 4: Convert the hire date to a DataFrame for display
result_df = pd.DataFrame({'Oldest Employee Hire Date': [hire_date_of_oldest_employee]})

# Step 5: Display the result to the user
show_to_user(result_df)
","The provided code correctly retrieves the hire date of the oldest employee using an SQL query that orders by HireDate in ascending order and limits the results to one. It extracts this date, formats it into a DataFrame, and displays the result, effectively addressing the business analytic request and matching the outcome of the reference implementation.",Finetuned
How many order details entries have a discount greater than 10%?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(*) AS order_details_count FROM [Order Details] WHERE Discount > 0.1;'

# Execute the SQL query to get the data
order_details_df = execute_sql_query(sql_query)

# Display the count to the user
show_to_user(order_details_df)","import pandas as pd

# Define the SQL query to count order details with a discount greater than 10%
sql_query = """"""
SELECT COUNT(*) AS discount_count
FROM [Order Details]
WHERE Discount > 0.10
""""""

# Execute the SQL query and get the result
discount_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(discount_data)","The input code correctly counts the number of order details with a discount greater than 10%, matching the logic of the reference implementation. Both codes use an SQL query with the condition 'Discount > 0.1' and display the result.","import pandas as pd

# Define the SQL query to count order details with a discount greater than 10%
sql_query = 'SELECT COUNT(*) AS high_discount_orders FROM [Order Details] WHERE Discount > 0.10;'

# Execute the SQL query and retrieve result as a pandas dataframe
df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(df)","The input code correctly implements the business analytic request by counting entries in '[Order Details]' where 'Discount' is greater than 10%. It matches the intended logic of the reference code, even though column names differ.",Base
Which supplier has the highest average lead time?,"import pandas as pd
import plotly.express as px

# SQL query to find the supplier with the highest average lead time
sql_query = '''
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY s.CompanyName 
ORDER BY AverageLeadTime DESC 
LIMIT 1;
'''

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Check if there is a result returned and visualize the data
if not results_df.empty:
    fig = px.bar(results_df, x='CompanyName', y='AverageLeadTime', title='Supplier with the Highest Average Lead Time')
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Error': ['No results returned by the query']}))","import pandas as pd

# SQL query to calculate the average lead time for each supplier
sql_query = '''
SELECT 
    s.SupplierID, 
    s.CompanyName,
    AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    orders o ON p.ProductID = o.ProductID
GROUP BY 
    s.SupplierID, s.CompanyName
ORDER BY 
    AverageLeadTime DESC
LIMIT 1;
'''

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
dash.show_to_user(result_df)","The input code incorrectly joins 'orders' directly to 'products' instead of going through 'Order Details'. This leads to incorrect calculation of average lead times as it does not correctly account for the relationship through order details. The calculated lead time will differ from the reference, and thus, the code does not meet the business request.","import pandas as pd
import plotly.express as px

def get_highest_avg_lead_time():
    # SQL query to find the supplier with the highest average lead time.
    sql_query = '''
    SELECT s.CompanyName, 
           AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime 
    FROM suppliers s 
    JOIN products p ON s.SupplierID = p.SupplierID 
    JOIN orders o ON p.ProductID = o.ProductID 
    GROUP BY s.CompanyName 
    ORDER BY AvgLeadTime DESC 
    LIMIT 1;
    '''
    
    # Execute the SQL query.
    df = execute_sql_query(sql_query)
    
    # Display result to the user.
    show_to_user(df)

# Call the function to perform the desired operation
get_highest_avg_lead_time()
","The input code does not properly follow the query logic to compute the average lead time. It errors in the JOIN structure, missing [Order Details] to accurately calculate lead times based on specific orders.",None
Identify employees whose orders had the highest average discount applied. Please include a data visualization to compare the average discounts by employees.,"import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY AvgDiscount DESC;
'''

# Execute the SQL query and fetch the dataframe
employee_discounts_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discounts by employees
fig = px.bar(employee_discounts_df, x='EmployeeID', y='AvgDiscount', title='Average Discounts by Employees', labels={'EmployeeID': 'Employee ID', 'AvgDiscount': 'Average Discount'})

# Show the result to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate the average discount applied by each employee
sql_query = '''
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    AVG(od.Discount) AS AverageDiscount 
FROM 
    employees e 
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName 
ORDER BY 
    AverageDiscount DESC;
'''  

# Execute the SQL query and store results in a DataFrame
average_discount_df = execute_sql_query(sql_query)

# Display the DataFrame to the user
show_to_user(average_discount_df)

# Visualization of average discounts by employees
fig = px.bar(average_discount_df, 
             x='FirstName', 
             y='AverageDiscount', 
             color='LastName', 
             title='Average Discounts by Employee', 
             labels={'AverageDiscount': 'Average Discount', 'FirstName': 'Employee First Name'})

# Show the figure to the user
show_to_user(fig)","The input code correctly identifies employees whose orders had the highest average discount by executing a SQL query to fetch employee ID, first name, last name, and average discount. It groups by employee details and orders them based on average discount. The data visualization uses a bar chart to display average discounts by employee, with color differentiation by last name, effectively comparing different employees, fulfilling the business analytic request.","import pandas as pd
import plotly.express as px

# SQL Query to get the employee with the highest average discount
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.Discount) AS AvgDiscount
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY AvgDiscount DESC
LIMIT 1;'''

# Execute the SQL query to retrieve data
employee_with_highest_discount = execute_sql_query(sql_query)

# Then we'll retrieve all average discounts by employee for visualization
sql_query_all = '''
SELECT e.EmployeeID, AVG(od.Discount) AS AvgDiscount
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;'''

# Execute the SQL query to retrieve data for visualization
all_employees_discount = execute_sql_query(sql_query_all)

# Create a visualization using plotly
fig = px.bar(all_employees_discount, x='EmployeeID', y='AvgDiscount', title='Average Discounts by Employees', labels={'AvgDiscount': 'Average Discount', 'EmployeeID': 'Employee ID'})

# Display the data visualization to the user
show_to_user(fig)

# Display the employee with highest average discount to user
show_to_user(employee_with_highest_discount)","The input code does not match the business analytic request. While it correctly calculates the employee with the highest average discount and visualizes all employees' average discounts, it doesn't provide a direct comparison of all employees' average discounts in one visualization as intended.",Base
What is the average unit price of products within each category?,"import pandas as pd
import plotly.express as px

def get_average_unit_price_per_category():
    sql_query = 'SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice FROM products GROUP BY CategoryID;'
    df = execute_sql_query(sql_query)
    show_to_user(df)
    
    # Optional: visualize the data
    fig = px.bar(df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price per Category')
    show_to_user(fig)
    
get_average_unit_price_per_category()","import pandas as pd

# SQL query to calculate the average unit price of products within each category
sql_query = '''
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
'''

# Execute the SQL query and retrieve the data
average_unit_price_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(average_unit_price_df)","The input code correctly calculates the average unit price of products within each category using a SQL query and displays the result. It achieves the same outcome as the reference implementation, even though it omits the optional visualization step.","import plotly.express as px

# SQL query to fetch the average unit price per category
sql_query = ""SELECT CategoryID, AVG(UnitPrice) AS AverageUnitPrice FROM products GROUP BY CategoryID;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Optionally, visualize the result using Plotly
fig = px.bar(result_df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Category', labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})

# Show the visualization to the user
show_to_user(fig)

# Display the dataframe to the user
show_to_user(result_df)","The input code correctly executes the same SQL query as the reference code to compute the average unit price per category and displays both the dataframe and an optional Plotly visualization to the user, effectively addressing the business request.",Base
List the employees who have never made a sale.,"import pandas as pd
import plotly.express as px

# SQL query to list employees who have never made a sale
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.OrderID IS NULL
'''

# Execute the SQL query using the utility function
employees_never_made_sale_df = execute_sql_query(sql_query)

# Show the resulting dataframe to the user
show_to_user(employees_never_made_sale_df)","sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderID IS NULL
""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)","The input Python code effectively replicates the business requirement and matches the reference implementation. It correctly constructs an SQL query to list employees who have never made a sale by performing a LEFT JOIN between 'employees' and 'orders' tables and checking for NULL OrderID values. The result is shown to the user using the utility function 'show_to_user', fulfilling the task requirements.","import pandas as pd
import plotly.express as px

# Query to get the list of employees who have never made a sale
query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName 
FROM employees 
LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.OrderID IS NULL;
""""""

# Execute the query
employees_never_made_sale = execute_sql_query(query)

# Display the result
show_to_user(employees_never_made_sale)","The input Python code effectively addresses the business analytic request. It uses a SQL query to perform a LEFT JOIN between the 'employees' and 'orders' tables and filters where 'OrderID' is NULL to list employees who have never made a sale. This matches the logic of the reference implementation, ensuring the same outcome.",Base
How many orders were shipped but not yet delivered?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT OrderID FROM orders WHERE ShippedDate IS NOT NULL AND RequiredDate IS NULL;'

# Execute the SQL query to retrieve the data
orders_df = execute_sql_query(sql_query)

# Analyze the data: Count the number of orders shipped but not yet delivered
shipped_not_delivered_count = orders_df.shape[0]

# Prepare the results for display
results_df = pd.DataFrame({'Shipped But Not Delivered Orders': [shipped_not_delivered_count]})

# Display the results to the user
show_to_user(results_df)
","sql_query = '''
SELECT COUNT(*) AS OrdersNotDelivered
FROM orders
WHERE ShippedDate IS NOT NULL AND (DeliveredDate IS NULL OR DeliveredDate > CURRENT_DATE)
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly calculates the number of orders shipped but not yet delivered based on the conditions provided (ShippedDate is not null and DeliveredDate is null or in the future). The logic aligns with the business request and achieves the same outcome as the reference implementation, which counts orders with a non-null ShippedDate and a null RequiredDate.","import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(*) AS pending_deliveries FROM orders o WHERE o.ShippedDate IS NOT NULL AND o.DeliverDate IS NULL;'

# Execute the SQL query to retrieve data
data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(data)","Both codes correctly count the number of orders shipped but not yet delivered. The input code uses COUNT(*) in the SQL query to achieve this, while the reference code retrieves rows and counts them in Python. The logic aligns with the business analytic request.",Base
Which orders have the highest discounts applied?,"import pandas as pd
import plotly.express as px

# SQL Query to retrieve the highest discounts on orders
sql_query = '''
SELECT orders.OrderID, MAX([Order Details].Discount) AS MaxDiscount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY orders.OrderID 
ORDER BY MaxDiscount DESC 
LIMIT 1;
'''

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Display the result using the provided utility function
show_to_user(result_df)","sql_query = """"""
SELECT o.OrderID, SUM(od.Discount) AS TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderID
ORDER BY TotalDiscount DESC
LIMIT 10;
""""""

# Execute the SQL query and retrieve the results
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)","The input code sums the discounts per order and retrieves the top 10 orders by total discount, while the reference query finds the single highest discount per order and returns the order with the maximum discount. The input code does not match the business analytic request or the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT * FROM [Order Details] ORDER BY Discount DESC LIMIT 5;""

# Execute the SQL query to retrieve data
order_details_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(order_details_df)

# Optionally, visualize the data if you want to create a plot
fig = px.bar(order_details_df, 
             x='OrderID', 
             y='Discount', 
             title='Top 5 Orders with Highest Discounts', 
             labels={'OrderID': 'Order ID', 'Discount': 'Discount Value'})

# Show the visualization
show_to_user(fig)","The input code retrieves the top 5 highest discounts without grouping by OrderID. The original request is to find orders with the highest discounts applied (i.e., the maximum discount per order), not just the top 5 discount entries. The input code also lacks the necessary grouping and sorting by maximum discount per order as done in the reference implementation.",None
What is the average time taken to ship an order?,"import pandas as pd
import plotly.express as px

# The given SQL query to get the average shipping time
sql_query = 'SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) as AverageShippingTime FROM orders;'

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Visualize the result in a bar chart using plotly
# Since result_df will only contain one row with one column, we need to create a dict to display correctly
fig = px.bar(x=['AverageShippingTime'], y=[result_df.iloc[0]['AverageShippingTime']], labels={'x':'Metric', 'y':'Time in Days'}, title='Average Shipping Time for Orders')

# Display the result to the user
show_to_user(fig)","import pandas as pd

# SQL query to calculate average time taken to ship an order
sql_query = '''
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime
FROM orders
WHERE ShippedDate IS NOT NULL
'''  

# Execute the SQL query and store the result in a dataframe
shipping_data = execute_sql_query(sql_query)

# Show the result to user
show_to_user(shipping_data)","The input Python code correctly calculates the average time taken to ship an order using a SQL query similar to the reference implementation. It retrieves data using the execute_sql_query function and displays it with show_to_user. Although it does not use plotly for visualization, this is acceptable since the primary request is to provide the average shipping time, which it successfully does.","import pandas as pd

# SQL query to get average shipping time
sql_query = 'SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime FROM orders;'

# Execute the SQL query using the provided utility function
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The evaluated code correctly computes the average shipping time using the provided SQL query and displays the result using the show_to_user function. Although it does not use plotly for visualization, it meets the requirement to output the computed average time.",Base
List the top 5 products by sales for Q2 2023 with a visualization of their respective sales figures.,"import plotly.express as px
import pandas as pd

# Utility function to execute SQL query
sql_query = '''
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY products.ProductID
ORDER BY total_sales DESC
LIMIT 5
'''

top_products_df = execute_sql_query(sql_query)

# Check if top_products_df is not empty
if not top_products_df.empty:
    # Create a bar plot for the top 5 products by sales
    fig = px.bar(top_products_df, x='ProductID', y='total_sales', 
                 title='Top 5 Products by Sales for Q2 2023', 
                 labels={'ProductID':'Product ID', 'total_sales':'Total Sales ($)'})

    # Show the visualization to the user
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Message': ['No data available for Q2 2023']}))","import pandas as pd
import plotly.express as px

# Define the SQL query to get the top 5 products by sales for Q2 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 5
""""""

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Create a bar chart to visualize sales figures
fig = px.bar(results_df, x='ProductName', y='total_sales', title='Top 5 Products by Sales for Q2 2023',
             labels={'total_sales': 'Sales Amount', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by listing the top 5 products by sales for Q2 2023 and visualizing their sales figures. It executes a similar SQL query as the reference code, includes 'ProductName' for enhanced visualization, creates a bar chart using Plotly, and displays the figure using 'show_to_user'. The methodology and outcome align with the reference implementation.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity * [Order Details].UnitPrice) AS total_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 5
""""""

# Execute the SQL query and retrieve data
df = execute_sql_query(sql_query)

# Correctly rename the columns in the dataframe
df.columns = ['ProductID', 'ProductName', 'Total Sales']

# Create a bar chart
fig = px.bar(df, x='ProductName', y='Total Sales',
             title='Top 5 Products by Sales for Q2 2023',
             labels={'ProductName': 'Product Name', 'Total Sales': 'Total Sales ($)'})

# Display the figure to the user
show_to_user(fig)","The input code does not account for discounts applied to orders, leading to an inaccurate calculation of total sales. The reference implementation multiplies the unit price, quantity, and (1 - discount) to account for discounts.",Base
Which products from each supplier have not been discontinued?,"import pandas as pd
import plotly.express as px

# SQL query to fetch products from each supplier that have not been discontinued
sql_query = '''
SELECT suppliers.CompanyName, products.ProductName 
FROM suppliers 
INNER JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.Discontinued = 0;
'''

# Execute SQL query
df = execute_sql_query(sql_query)

# Displaying the result directly to the user with show_to_user
def show_to_user(df):
    print(df)
show_to_user(df)
","import pandas as pd

# SQL query to select products from each supplier that have not been discontinued
sql_query = '''
SELECT s.SupplierID, s.CompanyName, p.ProductID, p.ProductName
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.Discontinued = 0
'''  

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly retrieves the non-discontinued products for each supplier using the SQL query, and it displays the results using the utility function. Although there are additional columns (SupplierID, ProductID) in the input code, it still answers the business request effectively.","import pandas as pd
import plotly.express as px

# SQL Query to get products that have not been discontinued grouped by each supplier.
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, p.ProductName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.Discontinued = 0
""""""

# Execute the SQL query to retrieve data
suppliers_products_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(suppliers_products_df)

# Optionally, create a visualization
fig = px.bar(suppliers_products_df, x='SupplierID', y='ProductName', title='Products from Each Supplier Not Discontinued')
show_to_user(fig)",The input code correctly retrieves products from each supplier that have not been discontinued by executing a similar SQL query to the reference code. It also adds a visualization step that does not conflict with the business request.,Base
What is the total number of orders where the quantity ordered exceeded 50 units in 2023?,import pandas as pd\n\n# Define the SQL query\nsql_query = '''\nSELECT COUNT(orders.OrderID) AS large_orders \nFROM [Order Details] \nJOIN orders ON [Order Details].OrderID = orders.OrderID \nWHERE [Order Details].Quantity > 50 \nAND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'\n'''\n\n# Execute the SQL query and get the result in a pandas dataframe\ndf = execute_sql_query(sql_query)\n\n# Extract the count of large orders from the dataframe\nlarge_orders = df['large_orders'][0] if not df.empty else 0\n\n# Display the result to the user\nshow_to_user(pd.DataFrame({'large_orders': [large_orders]})),"sql_query = """"""
SELECT COUNT(*) AS total_orders 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Quantity > 50 
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'""""""

result_df = execute_sql_query(sql_query)
show_to_user(result_df)","The input code correctly counts the total number of orders where the quantity ordered exceeded 50 units in 2023. It uses a SQL query that mirrors the reference implementation, and the function execute_sql_query is used to retrieve the result, which is then displayed using show_to_user.","import pandas as pd
from datetime import datetime

# Step 1: Define the SQL query
sql_query = '''
SELECT COUNT(*) AS HighQuantityOrders 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE od.Quantity > 50 
AND DATE_FORMAT(o.OrderDate, '%Y') = '2023'
'''

# Step 2: Execute the SQL query and get the result as a pandas dataframe
df_result = execute_sql_query(sql_query)

# Step 3: Display the result to the user
show_to_user(df_result)
","The input code correctly counts the number of orders with quantities exceeding 50 units in 2023. It achieves this by selecting orders where quantity is greater than 50 and using a date filter for the year 2023. The result is then displayed to the user, aligning with the business request and the reference implementation.",Base
What is the average quantity of products ordered per order?,"import pandas as pd
import plotly.express as px

# SQL Query to get the average quantity of products ordered per order
sql_query = ""SELECT AVG([Order Details].Quantity) AS AverageQuantity FROM [Order Details]""

# Execute the SQL Query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to get the total quantity of products ordered and total number of orders
sql_query = '''
SELECT COUNT(DISTINCT o.OrderID) AS TotalOrders, SUM(od.Quantity) AS TotalQuantity
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate average quantity per order
average_quantity_per_order = result_df['TotalQuantity'].iloc[0] / result_df['TotalOrders'].iloc[0]

# Create a DataFrame to display the result
average_quantity_df = pd.DataFrame({'Average Quantity per Order': [average_quantity_per_order]})

# Show the result to the user
show_to_user(average_quantity_df)","The input code correctly calculates the average quantity of products ordered per order. It retrieves the total quantity and the total number of distinct orders, computes the average, and presents the result. This achieves the same outcome as the reference implementation, where the average was directly calculated using AVG in SQL.","import pandas as pd
import plotly.express as px

# Define the SQL query to calculate the average quantity of products ordered per order.
sql_query = 'SELECT AVG(Quantity) AS AverageQuantity FROM [Order Details];'

# Execute the SQL query.
order_details_df = execute_sql_query(sql_query)

# Extract the average quantity from the dataframe
average_quantity = order_details_df['AverageQuantity'].iloc[0]

# Create a DataFrame to format the output nicely
result_df = pd.DataFrame({'Average Quantity': [average_quantity]})

# Display the result to the user
show_to_user(result_df)","The input code correctly calculates the average quantity of products ordered per order using the provided SQL query. It then extracts the result into a pandas DataFrame and displays it using the show_to_user function, which aligns with the business analytic request.",Base
What is the performance of each product based on sales quantities in Q1 2023 with a visualization comparing sales quantities?,"import pandas as pd
import plotly.express as px

# SQL query based on the business requirements
sql_query = '''
SELECT products.ProductID, SUM([Order Details].Quantity) AS product_performance
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY products.ProductID
'''

# Executing the SQL query
df = execute_sql_query(sql_query)

# Generating the bar plot for product performance
fig = px.bar(df, x='ProductID', y='product_performance', title='Product Performance in Q1 2023', labels={'ProductID': 'Product ID', 'product_performance': 'Sales Quantity'})

# Displaying the visualization
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get product performance based on sales quantities in Q1 2023
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS sales_quantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY products.ProductID, products.ProductName
""""""

# Execute the SQL query
product_performance_df = execute_sql_query(sql_query)

# Visualize the sales quantities
fig = px.bar(product_performance_df, x='ProductName', y='sales_quantity',
             title='Product Performance Based on Sales Quantities in Q1 2023',
             labels={'sales_quantity': 'Sales Quantity', 'ProductName': 'Product Name'})

# Show the result to the user
show_to_user(fig)","The evaluated code addresses the business analytic request successfully. It calculates sales quantities for products in Q1 2023 and visualizes them using a bar plot, effectively answering the request and achieving the same outcome as the reference implementation, despite including product names in the visualization.","import plotly.express as px

# SQL query to retrieve product performance data
sql_query = '''
  SELECT p.ProductName, SUM(od.Quantity) AS total_quantity_sold 
  FROM products p 
  JOIN [Order Details] od 
  ON p.ProductID = od.ProductID 
  JOIN orders o 
  ON od.OrderID = o.OrderID 
  WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
  GROUP BY p.ProductName''' 

# Execute the SQL query
product_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize sales quantities of each product
fig = px.bar(product_sales_df, x='ProductName', y='total_quantity_sold', title='Product Sales Performance Q1 2023', labels={'ProductName': 'Product', 'total_quantity_sold': 'Total Quantity Sold'})

# Display the result to the user
show_to_user(fig)",The input code successfully retrieves and visualizes product performance in Q1 2023 based on sales quantities. It uses the same date range and joins the necessary tables to calculate the total quantity sold for each product. The visualization effectively communicates product performance as requested.,Base
Find the top 5 customers by the number of orders placed with a visualization of the number of orders per customer.,"import plotly.express as px
import pandas as pd

# SQL Query to get the top 5 customers by the number of orders placed
sql_query = '''
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the result_df has the correct columns
result_df.columns = ['CustomerID', 'OrderCount']

# Visualize the number of orders per customer
fig = px.bar(result_df, x='CustomerID', y='OrderCount', 
             title='Top 5 Customers by Number of Orders', 
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per customer
sql_query = '''
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderCount DESC
LIMIT 5
''' 

# Execute SQL query to get data
customer_orders = execute_sql_query(sql_query)

# Visualize the number of orders per customer using Plotly
fig = px.bar(customer_orders, x='CompanyName', y='OrderCount', title='Top 5 Customers by Number of Orders',
             labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer Name'},
             color='OrderCount')

# Show the visualization to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by executing a SQL query that retrieves the top 5 customers with the most orders and visualizing the results. It includes both CustomerID and CompanyName, which provides additional customer details compared to the reference. The visualization uses Plotly for a bar chart, achieving the same outcome as the reference code.","import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT c.CustomerID, COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
'''

# Execute the query to retrieve data
customers_orders_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(customers_orders_df, x='CustomerID', y='OrderCount',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'},
             title='Top 5 Customers by Number of Orders')

# Display the visualization
show_to_user(fig)",The input code correctly implements the business request. It retrieves the top 5 customers by order count using a SQL query and visualizes the results using a bar chart with plotly. It achieves the same outcome as the reference implementation.,Base
What is the average shipping time for orders shipped to a specific country in the current month?,"import pandas as pd
import plotly.express as px
from datetime import datetime

# Get the current date
current_date = datetime.now()

# Format the current date to match YYYY-MM for SQL query
current_month = current_date.strftime('%Y-%m')

# Define the specific country to filter orders by
specified_country = 'specified_country'

# SQL query to get the average shipping time for orders shipped to the specified country in the current month
sql_query = f""""""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime
FROM orders
WHERE DATE_FORMAT(OrderDate, '%Y-%m') = '{current_month}'
AND ShipCountry = '{specified_country}'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Specify the country you want to analyze
country = 'Your_Specific_Country'

# SQL query to calculate average shipping time for the specified country in current month
sql_query = f""""""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime 
FROM orders 
WHERE ShipCountry = '{country}' 
AND MONTH(OrderDate) = MONTH(CURRENT_DATE()) 
AND YEAR(OrderDate) = YEAR(CURRENT_DATE())
""""""

# Execute the SQL query
shipping_time_data = execute_sql_query(sql_query)

# Show the data to the user
show_to_user(shipping_time_data)","The input code correctly addresses the business analytic request. It calculates the average shipping time for orders shipped to a specified country in the current month using a similar SQL query logic as the reference implementation. The differences are non-substantive, mainly in the method of extracting the current year and month, which are equivalent.","import pandas as pd
import datetime as dt

# Step 1: Write the SQL query
sql_query = """"""
SELECT AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgShippingTime
FROM orders
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE)
  AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE)
  AND orders.ShipCountry = 'specific_country';
""""""

# Step 2: Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Step 3: Display the result using the provided utility function
show_to_user(result_df)","The input code correctly calculates the average shipping time for orders to a specific country within the current month, akin to the reference implementation. It uses SQL functions to filter by year and month based on the current date, matching the logic in the reference code.",Base
Which customers have purchased more than 5 different products?,"import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT customers.CustomerID, customers.CompanyName 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID, customers.CompanyName 
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
'''

# Execute the SQL query and fetch the results into a pandas dataframe
df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(df)

# Optionally, visualize the data using plotly
fig = px.bar(df, x='CustomerID', y='CompanyName', title='Customers with more than 5 different products purchased')
show_to_user(fig)
","import pandas as pd

# Query to select customers who have purchased more than 5 different products
sql_query = '''
SELECT orders.CustomerID, COUNT(DISTINCT [Order Details].ProductID) AS product_count
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.CustomerID
HAVING COUNT(DISTINCT [Order Details].ProductID) > 5
'''  

# Execute the SQL query and retrieve the data
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code correctly identifies customers who have purchased more than 5 different products by counting distinct ProductIDs per CustomerID and filtering customers with a count greater than 5. Although it doesn't display the CompanyName, it fulfills the analytic request similar to the reference implementation.","import pandas as pd
import plotly.express as px

# SQL Query to fetch the required data
grouped_sql_query = """"""
SELECT c.CustomerID, COUNT(DISTINCT o.ProductID) AS ProductCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID 
HAVING COUNT(DISTINCT o.ProductID) > 5;
""""""

# Execute the SQL query
grouped_df = execute_sql_query(grouped_sql_query)

# Display the dataframe to the user
show_to_user(grouped_df)

# Optionally, visualize the data using plotly
fig = px.bar(grouped_df, x='CustomerID', y='ProductCount', title='Customers with Purchases of More than 5 Different Products', labels={'CustomerID': 'Customer ID', 'ProductCount': 'Product Count'})

# Show the plot to the user
show_to_user(fig)",The input code does not perform the correct query. It lacks the join with the 'Order Details' table necessary to count distinct product purchases. The reference code includes this join to accurately count product IDs per order.,Base
Which region has the highest on-time delivery rate with a visualization comparing on-time delivery rates across regions?,"import pandas as pd
import plotly.express as px

# SQL query to retrieve the region with the highest on-time delivery rate
sql_query = '''
SELECT ShipRegion, 
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS on_time_rate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY on_time_rate DESC LIMIT 1;'''

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Extract the region with the highest on-time delivery rate
highest_on_time_region = result_df.iloc[0]

# Output the region with the highest on-time delivery rate
show_to_user(highest_on_time_region)

# SQL query to retrieve all on-time delivery rates across regions for visualization
sql_query_all = '''
SELECT ShipRegion, 
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS on_time_rate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY on_time_rate DESC;'''

# Execute SQL query to get the full data
all_regions_df = execute_sql_query(sql_query_all)

# Convert the on_time_rate to numeric in case it's not already
all_regions_df['on_time_rate'] = pd.to_numeric(all_regions_df['on_time_rate'])

# Create a bar chart to visualize on-time delivery rates across regions
fig = px.bar(all_regions_df, x='ShipRegion', y='on_time_rate', title='On-Time Delivery Rates by Region')

# Show the bar chart
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rate per region
sql_query = '''
SELECT ShipRegion,
       COUNT(OrderID) AS TotalOrders,
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM orders
GROUP BY ShipRegion
'''  

# Execute the SQL query and get the data
region_delivery_data = execute_sql_query(sql_query)

# Calculate on-time delivery rate for each region
region_delivery_data['OnTimeDeliveryRate'] = region_delivery_data['OnTimeDeliveries'] / region_delivery_data['TotalOrders']

# Find the region with the highest on-time delivery rate
highest_region = region_delivery_data.loc[region_delivery_data['OnTimeDeliveryRate'].idxmax()]

# Create a bar chart comparing on-time delivery rates across regions
fig = px.bar(region_delivery_data, 
             x='ShipRegion', 
             y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rates Across Regions', 
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate', 'ShipRegion': 'Region'})

# Show the visualization to the user
show_to_user(fig)

# Return the region with the highest on-time delivery rate
greatest_region = highest_region['ShipRegion'], highest_region['OnTimeDeliveryRate']
greatest_region","The input code successfully calculates the on-time delivery rate for each region and identifies the region with the highest rate. It then visualizes the on-time delivery rates across regions using a bar chart. This achieves the same outcome as the reference implementation, despite differences in SQL query structure and processing steps.","
import pandas as pd
import plotly.express as px

# SQL query to fetch on-time delivery rates per region
sql_query = """"""
SELECT ShipRegion, COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID) AS on_time_delivery_rate
FROM orders
GROUP BY ShipRegion
ORDER BY on_time_delivery_rate DESC
""""""

# Execute the SQL query to get the data
on_time_delivery_df = execute_sql_query(sql_query)

# Find region with the highest on-time delivery rate
highest_on_time_delivery_region = on_time_delivery_df.iloc[0]

# Display the region with the highest on-time delivery rate
display_data = pd.DataFrame([highest_on_time_delivery_region])
show_to_user(display_data)

# Create a visualization of on-time delivery rates across regions
fig = px.bar(on_time_delivery_df, x='ShipRegion', y='on_time_delivery_rate',
             title='On-Time Delivery Rates Across Regions',
             labels={'on_time_delivery_rate': 'On-Time Delivery Rate (%)'})

# Show the plot to the user
show_to_user(fig)
",The input code correctly calculates the on-time delivery rate for each region and identifies the region with the highest rate. It also visualizes the on-time delivery rates across regions using a bar chart in a manner consistent with the reference implementation.,Base
How many orders were placed in the current year?,"import pandas as pd
import datetime as dt

# Get the current year
current_year = dt.datetime.now().year

# SQL query to count the total orders in the current year
sql_query = f""SELECT COUNT(*) AS TotalOrders FROM orders WHERE YEAR(OrderDate) = {current_year};""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to count the number of orders placed in the current year
sql_query = """"""
SELECT COUNT(OrderID) AS OrdersCount
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE())
""""""

# Execute the SQL query and retrieve the data
orders_count_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(orders_count_df)","The input code successfully counts the number of orders placed in the current year using a SQL query similar to the reference implementation. Both implementations achieve the same outcome, even though the SQL syntax slightly differs.","import pandas as pd
import plotly.express as px

# Define the SQL query to count the number of orders in the current year
current_year_query = """"""
SELECT COUNT(*) AS orders_placed
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURRENT_TIMESTAMP)
""""""

# Execute the SQL query
result_df = execute_sql_query(current_year_query)

# Extract the count from the result
orders_placed = result_df['orders_placed'].iloc[0]

# Prepare the DataFrame for display
summary_df = pd.DataFrame({'Year': [pd.Timestamp.now().year], 'Orders Placed': [orders_placed]})

# Display the result to the user using the show_to_user function
show_to_user(summary_df)","The evaluated code correctly executes an SQL query to count the number of orders in the current year, extracts the count, and presents the data in a DataFrame. It displays the result using the 'show_to_user' function, effectively fulfilling the business request in a manner similar to the reference implementation.",Base
Calculate the total discount given on all orders in the last month.,"import pandas as pd

# SQL query to calculate the total discount on all orders in the last month
sql_query = '''
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS TotalDiscount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATE_ADD(CURDATE(), INTERVAL -1 MONTH);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to get the total discount of orders from the last month
sql_query = """"""
SELECT SUM([Order Details].Discount * [Order Details].Quantity) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate >= ADD_MONTHS(CURRENT_DATE, -1) 
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The evaluated code uses the function ADD_MONTHS instead of DATE_ADD, and CURRENT_DATE instead of CURDATE. Both these function selections might lead to differences in execution depending on SQL dialects. It's crucial to ensure these function calls are compatible with the database being used.","import pandas as pd
import plotly.express as px

# SQL query to calculate the total discount given on all orders in the last month
sql_query = '''
SELECT SUM(Quantity * UnitPrice * (Discount / 100)) AS TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH);
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Note: df will have one row with a single column 'TotalDiscount'

# Show the result to user
show_to_user(df)","The input code divides the Discount by 100, assuming it's a percentage, but it should be used directly as a decimal according to the reference code.",None
Which products have a stock level below their reorder level?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to find products with stock level below their reorder level
sql_query = '''
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
'''

# Execute the SQL query and retrieve data
products_below_reorder_level = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(products_below_reorder_level)","The input code correctly identifies products with a stock level below their reorder level by using an SQL query with the condition 'UnitsInStock < ReorderLevel'. Although it includes additional columns and a condition to exclude discontinued products (Discontinued = 0), it fulfills the business request. Differences in column selection do not affect the correctness regarding the requested output.","import pandas as pd
import plotly.express as px

# Define the SQL query to find products with stock level below reorder level
sql_query = 'SELECT ProductID FROM products WHERE UnitsInStock < ReorderLevel;'

# Execute the SQL query
low_stock_products_df = execute_sql_query(sql_query)

# Display the results to the user
for index, row in low_stock_products_df.iterrows():
    product_id = row['ProductID']
    if index == len(low_stock_products_df) - 1:
        print(f""ProductID with low stock (last entry): {product_id}"")
    else:
        print(f""ProductID with low stock: {product_id}"")","The input code retrieves 'ProductID' instead of 'ProductName', which does not match the business request and reference code that specifies the product names.",Base
Which month had the highest number of orders placed with a visualization showing the number of orders per month?,"# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY Month 
ORDER BY NumberOfOrders DESC;
""""""

# Execute SQL query
orders_data = execute_sql_query(sql_query)

# Find the month with the highest number of orders
max_orders_month = orders_data.iloc[0]

# Visualization
fig = px.bar(orders_data, x='Month', y='NumberOfOrders', title='Number of Orders per Month')

# Show results to user
show_to_user(fig)

# Also show the month with the highest number of orders
show_to_user(pd.DataFrame([max_orders_month]))","import pandas as pd
import plotly.express as px

# SQL query to count the number of orders per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query and retrieve the data
orders_per_month = execute_sql_query(sql_query)

# Identify the month with the highest number of orders
max_orders_month = orders_per_month.loc[orders_per_month['NumberOfOrders'].idxmax()]

# Create a line chart to visualize the number of orders per month
fig = px.line(orders_per_month, x='Month', y='NumberOfOrders', title='Number of Orders per Month')

# Show the visualization and the month with the highest orders
show_to_user(fig)
print(f'The month with the highest number of orders is: {max_orders_month.Month} with {max_orders_month.NumberOfOrders} orders.')","The input code uses a line chart instead of a bar chart, and it sorts the months chronologically rather than by the number of orders. This may not highlight the month with the highest orders as clearly as the reference implementation.","import plotly.express as px

# SQL query to find the month with the highest number of orders
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(*) AS NumberOfOrders
FROM orders
GROUP BY Month
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query
monthly_orders_df = execute_sql_query(sql_query)

# Sort the dataframe by Month for appropriate visualization
monthly_orders_df['Month'] = pd.to_datetime(monthly_orders_df['Month'])
monthly_orders_df = monthly_orders_df.sort_values('Month')

# Visualization: Number of orders per month
fig = px.line(monthly_orders_df, x='Month', y='NumberOfOrders', title='Number of Orders per Month', labels={'NumberOfOrders': 'Number of Orders', 'Month': 'Month'})
fig.update_layout(xaxis_title='Month', yaxis_title='Number of Orders')

# Show the result to the user
show_to_user(fig)

# Display the month with the highest number of orders
highest_order_month = monthly_orders_df.iloc[0]
show_to_user(monthly_orders_df)
show_to_user(highest_order_month)",The input code does not correctly identify and display the month with the highest number of orders. It sorts the months chronologically for visualization but then selects the first month for display instead of the month with the highest orders.,None
Determine the employee with the largest average order size with a visualization comparing the average order sizes.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderSize 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY AvgOrderSize DESC 
LIMIT 1;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Determine the employee with the largest average order size
employee_id_with_max_avg_order_size = result_df.iloc[0]['EmployeeID']
avg_order_size = result_df.iloc[0]['AvgOrderSize']

# Additional query to get all employees' average order sizes for comparison
comparison_query = '''
SELECT employees.EmployeeID, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AvgOrderSize 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY AvgOrderSize DESC;
'''

# Execute the comparison query
comparison_df = execute_sql_query(comparison_query)

# Create a bar plot for visualization
fig = px.bar(comparison_df, x='EmployeeID', y='AvgOrderSize', 
             title='Comparison of Average Order Sizes by Employee', 
             labels={'EmployeeID':'Employee ID', 'AvgOrderSize':'Average Order Size'})

# Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get total sales per employee
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""  

# Execute the SQL query and create a DataFrame
employee_sales_df = execute_sql_query(sql_query)

# Calculate average order size for each employee
# Assuming total orders = count of orders made by each employee
order_count_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
""""""

order_count_df = execute_sql_query(order_count_query)

# Merge dataframes to get average order size
average_order_size_df = employee_sales_df.merge(order_count_df, on='EmployeeID')
average_order_size_df['AverageOrderSize'] = average_order_size_df['TotalSales'] / average_order_size_df['OrderCount']

# Find employee with the largest average order size
largest_average_order_employee = average_order_size_df.loc[average_order_size_df['AverageOrderSize'].idxmax()]

# Visualization
fig = px.bar(average_order_size_df, x='FirstName + ' ' + LastName', y='AverageOrderSize',
             title='Average Order Size per Employee')
show_to_user(fig)\n

# Output the employee with largest average order size
print(largest_average_order_employee)","The input code calculates the total sales per employee and divides it by the count of orders per employee to find the average order size. It uses the sum of UnitPrice, Quantity, and Discount for each employee, but divides it by the count of orders, which assumes only one order per transaction. This approach could lead to incorrect average calculations if an employee has orders with multiple products. The reference code correctly calculates the average order size using the actual order details joined by the order ID. Thus, the input code does not replicate the reference implementation accurately.","
import plotly.express as px

# SQL query to determine the employee with the largest average order size
sql_query = '''
SELECT EmployeeID, AVG(Quantity * UnitPrice) AS AvgOrderSize
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY EmployeeID
ORDER BY AvgOrderSize DESC
LIMIT 1;'''  # Limit added to retrieve only the top employee

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Plotting the average order sizes for all employees, not just the top one
sql_query_all = '''
SELECT EmployeeID, AVG(Quantity * UnitPrice) AS AvgOrderSize
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY EmployeeID;'''  # This retrieves data for all employees

# Execute the SQL query to get data for all employees
result_all_df = execute_sql_query(sql_query_all)

# Creating a bar chart to compare the average order sizes
fig = px.bar(result_all_df, x='EmployeeID', y='AvgOrderSize', 
             title='Comparison of Average Order Sizes by Employee', 
             labels={'EmployeeID': 'Employee ID', 'AvgOrderSize': 'Average Order Size'})

# Display the plot
show_to_user(fig)

# Output the employee with the largest average order size data
show_to_user(result_df)
","The input code does not include the discount factor in calculating the average order size, unlike the reference implementation. It also does not limit the grouping by employee, missing the join with the employees table.",None
How many distinct customers placed orders each month with a visualization showing the number of distinct customers per month?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT DATE_TRUNC('month', o.OrderDate) AS Month, 
COUNT(DISTINCT o.CustomerID) AS UniqueCustomers 
FROM orders o 
GROUP BY Month;
'''

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Ensure the 'Month' column is in datetime format
orders_df['Month'] = pd.to_datetime(orders_df['Month'])

# Sort the dataframe by the 'Month' column
orders_df = orders_df.sort_values(by='Month')

# Create a line plot showing the number of distinct customers per month
fig = px.line(orders_df, x='Month', y='UniqueCustomers', title='Distinct Customers Per Month', labels={'Month': 'Month', 'UniqueCustomers': 'Number of Distinct Customers'})

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get distinct customers per month
sql_query = '''
SELECT
    DATE_TRUNC('month', o.OrderDate) AS Month,
    COUNT(DISTINCT o.CustomerID) AS DistinctCustomers
FROM
    orders o
GROUP BY
    Month
ORDER BY
    Month;
'''  

# Execute SQL query and load results into a DataFrame
customer_data = execute_sql_query(sql_query)

# Create a line plot for distinct customers per month
fig = px.line(customer_data, x='Month', y='DistinctCustomers', 
              title='Number of Distinct Customers Per Month',
              labels={'Month': 'Month', 'DistinctCustomers': 'Distinct Customers'})

# Show the visualization to the user
show_to_user(fig)","The input Python code correctly fulfills the business analytic request by querying distinct customers per month, creating a plot with Plotly, and displaying it. It matches the logic and outcome of the reference implementation, despite the column name difference.","To solve the request, we will follow these steps:

1. Write a SQL query to retrieve the number of distinct customers who placed orders each month.
2. Execute the SQL query using the provided utility function.
3. Visualize the data using `plotly`.

Here's the complete Python code to accomplish this:

```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = ""SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(DISTINCT CustomerID) AS DistinctCustomers FROM orders GROUP BY Month;""

# Step 2: Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Step 3: Create a plot using plotly
fig = px.line(order_data, x='Month', y='DistinctCustomers', title='Number of Distinct Customers Per Month', labels={'Month': 'Month', 'DistinctCustomers': 'Number of Distinct Customers'})

# Optionally, Sort the data by Month for better visualization
order_data['Month'] = pd.to_datetime(order_data['Month'])
order_data_sorted = order_data.sort_values('Month')

# Step 4: Show the result to the user
show_to_user(fig)
```","The input code correctly retrieves and visualizes the number of distinct customers per month. It uses a SQL query to group the data by month and counts distinct customers, similar to the reference code. The visualization with Plotly is achieved using a line plot. Despite using a slightly different SQL method (DATE_FORMAT instead of DATE_TRUNC), both codes effectively address the business requirement.",Base
What are the average discounts applied per order?,"import pandas as pd
import plotly.express as px

# SQL query to retrieve average discounts per order
sql_query = '''
SELECT OrderID, AVG(Discount) AS AverageDiscount 
FROM [Order Details] 
GROUP BY OrderID;
'''

# Execute the SQL query and get the result in a pandas dataframe
order_discounts_df = execute_sql_query(sql_query)

# Display the average discounts per order to user
show_to_user(order_discounts_df)

# Optional: Additional visualization using plotly
fig = px.bar(order_discounts_df, x='OrderID', y='AverageDiscount', title='Average Discounts per Order')
show_to_user(fig)","import pandas as pd

# SQL query to get average discounts applied per order
sql_query = '''
SELECT OrderID, AVG(Discount) as AverageDiscount
FROM [Order Details]
GROUP BY OrderID
'''

# Execute the SQL query and get the results
average_discounts_df = execute_sql_query(sql_query)

# Show the results to the user
show_to_user(average_discounts_df)","The input Python code successfully addresses the business analytic request to calculate the average discounts applied per order, achieving the same outcome as the reference implementation. Both codes execute a similar SQL query to retrieve average discounts per order and then display the results using the show_to_user function. The input code accomplishes the task without optional visualization, which is acceptable as it is not a requirement.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT AVG(Discount) AS AvgDiscount FROM [Order Details];'

# Execute the SQL query and get the result as a pandas dataframe
try:
    df = execute_sql_query(sql_query)
except Exception as e:
    print(f'Error executing SQL query: {e}')
    df = pd.DataFrame()

# Display the average discount to the user
show_to_user(df)

# For visualization, use plotly to create a simple bar chart for average discount
fig = px.bar(df, x=df.index, y='AvgDiscount', title='Average Discount per Order')
show_to_user(fig)","The input code calculates the overall average discount, not the average discount per order as requested. It should group by OrderID to meet the requirement.",Base
What is the average order fulfillment time for orders made in February 2023? Please include a visualization to compare the daily fulfillment times.,"import pandas as pd
import plotly.express as px

# SQL Query to calculate the average order fulfillment time for February 2023
sql_query_avg_fulfillment = (
    'SELECT AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgFulfillmentTime '
    'FROM orders o '
    'WHERE MONTH(o.OrderDate) = 2 AND YEAR(o.OrderDate) = 2023;'
)

# SQL Query to get daily fulfillment times for February 2023
sql_query_daily_fulfillment = (
    'SELECT DATEDIFF(o.ShippedDate, o.OrderDate) AS FulfillmentTime, '
    'DATE(o.OrderDate) AS OrderDate '
    'FROM orders o '
    'WHERE MONTH(o.OrderDate) = 2 AND YEAR(o.OrderDate) = 2023;'
)

# Execute the queries
avg_fulfillment_df = execute_sql_query(sql_query_avg_fulfillment)
daily_fulfillment_df = execute_sql_query(sql_query_daily_fulfillment)

# Extract the average fulfillment time
average_fulfillment_time = avg_fulfillment_df[""AvgFulfillmentTime""][0]

# Print the average fulfillment time
print('Average Order Fulfillment Time for February 2023: ', average_fulfillment_time)

# Create a visualization to compare the daily fulfillment times
fig = px.line(daily_fulfillment_df, 
              x='OrderDate', 
              y='FulfillmentTime', 
              title='Daily Fulfillment Times for February 2023',
              labels={
                  'OrderDate': 'Order Date',
                  'FulfillmentTime': 'Fulfillment Time (days)'
              })

# Display the plot
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to retrieve order fulfillment times for February 2023
sql_query = """"""
SELECT
    DATE(OrderDate) AS OrderDate,
    DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM
    orders
WHERE
    OrderDate BETWEEN '2023-02-01' AND '2023-02-28' AND
    ShippedDate IS NOT NULL
""""""

# Execute the query and get the data into a DataFrame
fulfillment_data = execute_sql_query(sql_query)

# Calculate average fulfillment time
average_fulfillment_time = fulfillment_data['FulfillmentTime'].mean()

# Print or save the average fulfillment time for later reference
print(f""Average Order Fulfillment Time for February 2023: {average_fulfillment_time:.2f} days"")

# Prepare the daily fulfillment times for visualization
daily_fulfillment_times = (fulfillment_data.groupby('OrderDate')['FulfillmentTime'].mean().reset_index())

# Create a line plot for daily fulfillment times
fig = px.line(daily_fulfillment_times, x='OrderDate', y='FulfillmentTime', title='Daily Average Order Fulfillment Time for February 2023')

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the average order fulfillment time for February 2023 and generates a line plot to visualize daily fulfillment times. Although the implementation details differ slightly from the reference code, the outcome remains the same, fulfilling the business analytic request.","import pandas as pd
import plotly.express as px

# Step 1: SQL Query to Fetch Data
query = """"""
SELECT DATE(orders.OrderDate) AS order_date, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS daily_fulfillment_time 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-02-01' AND '2023-02-28' 
GROUP BY order_date
""""""

# Step 2: Execute the SQL Query and Fetch the Results
order_data = execute_sql_query(query)

# Step 3: Calculate the Overall Average Fulfillment Time
avg_fulfillment_time_narrowed = order_data['daily_fulfillment_time'].mean()

# Extracting the average fulfillment time for February 2023 and ensuring it's well formatted
avg_fulfillment_time_broad = f""Average Order Fulfillment Time for February 2023 is {avg_fulfillment_time_narrowed} days""

# Display the broad fulfillment time
show_to_user(avg_fulfillment_time_broad)

# Step 4: Visualize the Daily Fulfillment Times
fig = px.line(order_data, x='order_date', y='daily_fulfillment_time', title='Daily Order Fulfillment Time in February 2023', labels={'order_date': 'Order Date', 'daily_fulfillment_time': 'Daily Fulfillment Time (days)'})

# Step 5: Display the Visualization
show_to_user(fig)",The input code correctly calculates the average order fulfillment time for February 2023 by grouping daily average fulfillment times and then computing the overall average. It also visualizes daily fulfillment times using Plotly. Both match the business request and outcomes of the reference code.,Base
Get a list of employees and the number of orders they have handled.,"import pandas as pd
import plotly.express as px

# SQL query to retrieve the required data
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;'''

# Execute the SQL query and get the results in a dataframe
employee_orders_df = execute_sql_query(sql_query)

# Display the results to the user
display_data = employee_orders_df[['EmployeeID', 'FirstName', 'LastName', 'OrderCount']]
show_to_user(display_data)

# Optionally create a bar plot to visualize the number of orders handled by each employee
fig = px.bar(employee_orders_df, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Each Employee', labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'})
show_to_user(fig)","import pandas as pd

# SQL query to get the count of orders handled by each employee
sql_query = '''
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY NumberOfOrders DESC;
'''  

# Execute the SQL query and store the result in a DataFrame
employee_orders_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(employee_orders_df)","The input code correctly executes a SQL query to retrieve the count of orders each employee has handled, using a LEFT JOIN instead of an INNER JOIN. It shows the same data as the reference code with an additional step of ordering the result, which does not affect the correctness per the business request. Both implementations obtain employees and their respective order counts.","import pandas as pd
import plotly.express as px

# Define the SQL query to execute
def get_employee_order_count():
    sql_query = 'SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount FROM employees e JOIN orders o ON e.EmployeeID = o.EmployeeID GROUP BY e.EmployeeID, e.FirstName, e.LastName;'
    
    # Execute the SQL query and get the result into a pandas dataframe
    df = execute_sql_query(sql_query)
    
    # Display the result to the user
    show_to_user(df)
    
    # Additionally, we can visualize the data using a bar chart
    fig = px.bar(df, x='FirstName', y='OrderCount', title='Number of Orders Handled by Employees', labels={'FirstName': 'Employee First Name', 'OrderCount': 'Order Count'})
    show_to_user(fig)
    
# Call the function to get the result and visualize
get_employee_order_count()","The input Python code effectively addresses the business analytic request by retrieving employees and their respective order counts. It follows the same SQL logic as the reference implementation, and it provides a visualization. Although the bar chart uses 'FirstName' on the x-axis instead of 'EmployeeID', this does not affect the correctness, as it still presents the order count for each employee.",Base
What is the inventory turnover ratio for the product 'Chai' in May 2023? Please provide a visualization to show the trend of inventory turnover ratios over time.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.ProductName = 'Chai' AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
'''

# Execute the SQL query to get the data
inventory_turnover_data = execute_sql_query(sql_query)

# Display the inventory turnover ratio for May 2023
show_to_user(inventory_turnover_data)

# Define a query to get the inventory turnover ratios over time for visualization
sql_query_trend = '''
SELECT DATEPART(month, orders.OrderDate) AS month, DATEPART(year, orders.OrderDate) AS year,
SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE products.ProductName = 'Chai'
GROUP BY DATEPART(year, orders.OrderDate), DATEPART(month, orders.OrderDate)
ORDER BY year, month
'''

# Execute the SQL query to get the trend data
timeline_turnover_data = execute_sql_query(sql_query_trend)

# Convert to datetime for better visualization
timeline_turnover_data['date'] = pd.to_datetime(timeline_turnover_data[['year', 'month']].assign(day=1))

# Create a line plot for the trend of inventory turnover ratios
fig = px.line(timeline_turnover_data, x='date', y='inventory_turnover_ratio', title='Trend of Inventory Turnover Ratios for Chai', labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio', 'date': 'Date'})

# Display the trend visualization
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to get inventory turnover ratio for 'Chai' in May 2023
sql_query_may = """"""
SELECT
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM
    [Order Details]
JOIN
    products ON [Order Details].ProductID = products.ProductID
JOIN
    orders ON [Order Details].OrderID = orders.OrderID
WHERE
    orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31' 
    AND products.ProductName = 'Chai'
GROUP BY
    month
""""""

# Execute the SQL query
inventory_turnover_may = execute_sql_query(sql_query_may)

# SQL query to track the trend of inventory turnover ratios over time
sql_query_trend = """"""
SELECT
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM
    [Order Details]
JOIN
    products ON [Order Details].ProductID = products.ProductID
JOIN
    orders ON [Order Details].OrderID = orders.OrderID
GROUP BY
    month
ORDER BY
    month
""""""

# Execute the SQL query for trend
inventory_turnover_trend = execute_sql_query(sql_query_trend)

# Visualization of inventory turnover ratio trend over time
fig = px.line(inventory_turnover_trend, x='month', y='inventory_turnover_ratio',
              title='Inventory Turnover Ratio Trend Over Time',
              labels={'month': 'Month', 'inventory_turnover_ratio': 'Inventory Turnover Ratio'})

# Show trend visualization
show_to_user(fig)

# Show May 2023 inventory turnover ratio to the user
show_to_user(inventory_turnover_may)","The input code correctly calculates the inventory turnover ratio for 'Chai' in May 2023 and visualizes the trend over time, matching the outcome of the reference implementation despite differences in formatting, such as using DATE_FORMAT instead of DATEPART.","import plotly.express as px
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
WITH monthly_sales AS (
    SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
           SUM([Order Details].Quantity * [Order Details].UnitPrice) AS total_sales 
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    JOIN products ON [Order Details].ProductID = products.ProductID
    WHERE products.ProductName = 'Chai' 
      AND orders.OrderDate BETWEEN '2023-05-01' AND '2023-05-31'
    GROUP BY month
), average_inventory AS (
    SELECT products.ProductName,
           AVG(products.UnitsInStock) AS avg_inventory
    FROM products
    WHERE products.ProductName = 'Chai'
    GROUP BY products.ProductName
)
SELECT monthly_sales.month, 
       monthly_sales.total_sales / average_inventory.avg_inventory AS inventory_turnover_ratio
FROM monthly_sales, average_inventory
ORDER BY monthly_sales.month
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the date format is treated properly as a datetime type
result_df['month'] = pd.to_datetime(result_df['month'])

# Create a plotly figure
fig = px.line(result_df, x='month', y='inventory_turnover_ratio', title='Inventory Turnover Ratio for Chai in May 2023', markers=True)

# Show the data to the user
show_to_user(fig)

# Also, show the raw data for debugging purpose (this line can be optionally removed if not needed)
show_to_user(result_df)
","The evaluated code correctly calculates the inventory turnover ratio for 'Chai' in May 2023 by dividing total sales by average inventory, similar to the reference implementation. It provides a visualization chart using Plotly, which matches the requirement to show the trend of inventory turnover ratios over time. The approach may differ slightly from the reference, but functions effectively meet the business analytic request.",Base
Which shipping method has the shortest average order fulfillment time? Please provide a visualization to compare the fulfillment times across all shipping methods.,"import pandas as pd
import plotly.express as px

# SQL query to get average fulfillment times by shipping method
sql_query = '''
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AverageFulfillmentTime ASC;
'''

# Execute the SQL query and get the results in a pandas dataframe
df = execute_sql_query(sql_query)

# Find the shipping method with the shortest average fulfillment time
shortest_fulfillment_method = df.iloc[0]
print(shortest_fulfillment_method)

# Create the visualization with plotly
fig = px.bar(df, x='ShipVia', y='AverageFulfillmentTime', title='Average Fulfillment Time by Shipping Method')

# Show visualization to user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to calculate average order fulfillment time by shipping method
sql_query = '''
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipVia
'''  

# Execute the SQL query and retrieve the data
fulfillment_data = execute_sql_query(sql_query)

# Identify the shipping method with the shortest average fulfillment time
shortest_fulfillment = fulfillment_data.loc[fulfillment_data['AvgFulfillmentTime'].idxmin()]
print(f'Shipping Method with the Shortest Average Order Fulfillment Time: {shortest_fulfillment[""ShipVia""]}, Time: {shortest_fulfillment[""AvgFulfillmentTime""]}')

# Visualization of average fulfillment times across shipping methods
fig = px.bar(fulfillment_data, x='ShipVia', y='AvgFulfillmentTime',
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Show the visualization to the user
show_to_user(fig)","The input code successfully computes the average order fulfillment time by shipping method, identifies the method with the shortest time, and creates a visualization similar to the reference implementation. The code correctly uses SQL, processes data with pandas, and visualizes with Plotly, fulfilling the business analytical request.","import plotly.express as px
import pandas as pd

# SQL Query to get the average fulfillment time by shipping method
sql_query = '''
SELECT ship_via, AVG(DATEDIFF(day, order_date, shipped_date)) AS avg_fulfillment_time
FROM orders
GROUP BY ship_via
ORDER BY avg_fulfillment_time ASC;
'''

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Find the shipping method with the shortest average order fulfillment time
shortest_avg_fulfillment = data.iloc[0]

# Display the shipping method with the shortest average fulfillment time
show_to_user(shortest_avg_fulfillment)

# Plot the average order fulfillment time for each shipping method
fig = px.bar(data, x='ship_via', y='avg_fulfillment_time', title='Average Order Fulfillment Time by Shipping Method', labels={'ship_via':'Shipping Method', 'avg_fulfillment_time':'Average Fulfillment Time (Days)'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly fulfills the business requirement of identifying the shipping method with the shortest average fulfillment time and visualizing it. The SQL query is equivalent, though it uses a different date difference function syntax. Both codes use plotly to create a bar chart and correctly display it.",Base
What is the number of products sold with discounts?,"import pandas as pd

# Define the SQL query
sql_query = 'SELECT COUNT(DISTINCT ProductID) AS ProductsWithDiscount FROM [Order Details] WHERE Discount > 0;'

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# Define the SQL query to get the number of products sold with discounts
sql_query = '''
SELECT SUM([Order Details].Quantity) AS TotalQuantity
FROM [Order Details]
WHERE [Order Details].Discount > 0
'''  

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","The input code calculates the total quantity of products sold with discounts, not the number of distinct products.","import pandas as pd

# Define the SQL query to count the number of products sold with discounts
sql_query = 'SELECT SUM(od.Quantity) AS TotalUnitsSoldWithDiscount FROM [Order Details] od WHERE od.Discount > 0;'

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Get the sum value from the first row of the DataFrame
if not result_df.empty and 'TotalUnitsSoldWithDiscount' in result_df.columns:
    TotalUnitsSoldWithDiscount = result_df['TotalUnitsSoldWithDiscount'].iloc[0]
else:
    TotalUnitsSoldWithDiscount = 0

# Prepare the result for display
result_to_display = pd.DataFrame({'TotalUnitsSoldWithDiscount': [TotalUnitsSoldWithDiscount]})

# Display the result to the user
show_to_user(result_to_display)","The input code calculates the total number of units sold with a discount, while the reference implementation counts distinct products with a discount. The business request is for the number of products, not the total units sold.",None
What is the average order fulfillment time per employee? Provide a visualization to compare the fulfillment times of different employees.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = 'SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime FROM orders GROUP BY EmployeeID;'

# Execute the SQL query and retrieve the data
employee_fulfillment_data = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(employee_fulfillment_data, x='EmployeeID', y='AverageFulfillmentTime', title='Average Order Fulfillment Time per Employee', labels={'EmployeeID': 'Employee ID', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get order fulfillment times by employee
sql_query = '''
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS Avg_Fulfillment_Time
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY EmployeeID
ORDER BY EmployeeID
'''

# Execute the SQL query
fulfillment_times_df = execute_sql_query(sql_query)

# Visualization: Bar chart comparing average fulfillment times per employee
fig = px.bar(fulfillment_times_df, x='EmployeeID', y='Avg_Fulfillment_Time',
             title='Average Order Fulfillment Time per Employee',
             labels={'Avg_Fulfillment_Time': 'Average Fulfillment Time (Days)', 'EmployeeID': 'Employee ID'})

# Show the visualization to the user
show_to_user(fig)","The input code correctly calculates the average order fulfillment time per employee and generates a Plotly bar chart for visualization. It includes a condition to exclude records with null 'ShippedDate', which is a logical enhancement, ensuring accuracy. The outcome matches the reference implementation's purpose, fulfilling the business analytic request.","
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL Query
sql_query = '''
SELECT e.EmployeeID, AVG(DATEDIFF(day, o.OrderDate, o.ShippedDate)) AS AvgFulfillmentTime 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID;
'''

# Step 2: Execute the SQL Query
employee_fulfillment_times = execute_sql_query(sql_query)

# Step 3: Visualize the Data
fig = px.bar(employee_fulfillment_times, x='EmployeeID', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time per Employee', 
             labels={'EmployeeID':'Employee ID', 'AvgFulfillmentTime':'Average Fulfillment Time (days)'})

# Step 4: Display the Data
show_to_user(fig)
","The input code effectively answers the business analytic request. It calculates the average order fulfillment time per employee by joining the 'employees' and 'orders' tables and computes the average using a similar SQL query as the reference implementation. The visualization is correctly created using Plotly to compare fulfillment times among employees, and matches the reference implementation's logic, even with differences in SQL query syntax.",Base
What is the average number of units ordered per order?,"import pandas as pd
import plotly.express as px

# SQL query to get the average number of units ordered per order
sql_query = 'SELECT AVG(Quantity) AS AvgQuantityPerOrder FROM [Order Details];'

# Execute the SQL query to retrieve data
result_df = execute_sql_query(sql_query)

# Extract the average quantity value
avg_quantity = result_df['AvgQuantityPerOrder'][0]

# Create a dataframe for visualization
viz_df = pd.DataFrame({'Metric': ['AvgQuantityPerOrder'], 'Value': [avg_quantity]})

# Create a bar chart for visualization
fig = px.bar(viz_df, x='Metric', y='Value', title='Average Number of Units Ordered per Order')

# Show the visualized result to the user
show_to_user(fig)","import pandas as pd

# SQL query to get the total number of units ordered and the total number of orders
sql_query = '''
SELECT COUNT(DISTINCT OrderID) AS TotalOrders,
       SUM(Quantity) AS TotalUnitsOrdered
FROM [Order Details]
'''  

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Calculate the average number of units ordered per order
average_units_per_order = order_data['TotalUnitsOrdered'].values[0] / order_data['TotalOrders'].values[0]

# Prepare a dataframe to show results
result_df = pd.DataFrame({'Average Units per Order': [average_units_per_order]})

# Show the result to the user
show_to_user(result_df)","The input code correctly calculates the average number of units ordered per order using a different method from the reference implementation. It retrieves the total number of unique orders and the sum of quantities, then computes the average, which matches the intent of the business analytic request.","import pandas as pd

# SQL query to get the average number of units ordered per order
sql_query = 'SELECT AVG(Quantity) AS AverageUnits FROM [Order Details];'

# Execute the SQL query to retrieve the data
result_df = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(result_df)",The input code correctly retrieves the average number of units ordered per order and displays it using the available utility functions. It achieves the same outcome as the reference implementation.,Base
Determine the total revenue generated from orders shipped to Germany.,"import pandas as pd
import plotly.express as px

# SQL query to determine total revenue from orders shipped to Germany
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.ShipCountry = 'Germany';
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)","import pandas as pd

# SQL query to calculate total revenue generated from orders shipped to Germany
sql_query = """"""
SELECT
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM
    orders
JOIN
    [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN
    customers ON orders.CustomerID = customers.CustomerID
WHERE
    orders.ShipCountry = 'Germany'
""""""

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(revenue_data)",The input code correctly calculates revenue from orders shipped to Germany. The inclusion of an additional JOIN with the customers table does not affect the result because it doesn't impact the SUM calculation or filtering condition for 'ShipCountry = Germany'.,"import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to get the total revenue from orders shipped to Germany
sql_query = '''
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_revenue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.ShipCountry = 'Germany'
'''

# Step 2: Execute the SQL query
revenue_df = execute_sql_query(sql_query)

# Step 3: Display the result to the user
show_to_user(revenue_df)",The input code correctly executes a SQL query to calculate the total revenue from orders shipped to Germany using the same logic as the reference implementation. The SQL syntax and the method of execution and display are consistent with the requirements.,Base
Determine the freights cost totals for each month in 2023. Please include a month-by-month visualization of freight costs.,"import pandas as pd
import plotly.express as px

# SQL query to get the freight cost totals for each month in 2023
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Freight) AS TotalFreight
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY Month;
'''

# Execute the SQL query and retrieve the data
freight_data = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as a datetime object
freight_data['Month'] = pd.to_datetime(freight_data['Month'] + '-01')

# Sort data by the 'Month' column
freight_data = freight_data.sort_values(by='Month')

# Create a month-by-month visualization using Plotly
fig = px.line(freight_data, x='Month', y='TotalFreight', title='Freight Cost Totals for Each Month in 2023', labels={'Month': 'Month', 'TotalFreight': 'Total Freight Cost'})

# Display the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the total freight cost for each month in 2023
sql_query = '''
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM(Freight) AS TotalFreight 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = 2023 
GROUP BY 
    Month 
ORDER BY 
    Month;
'''

# Execute the SQL query and get the results in a DataFrame
results_df = execute_sql_query(sql_query)

# Visualize the month-by-month total freight costs
fig = px.line(results_df, x='Month', y='TotalFreight', title='Total Freight Costs in 2023', labels={'TotalFreight': 'Total Freight Cost', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)",The input code successfully queries the freight costs for each month in 2023 and visualizes them using Plotly. It achieves the same outcome as the reference implementation by ordering the data by month directly in the SQL query.,"import pandas as pd
import plotly.express as px

# SQL query to determine the total freight costs for each month in 2023
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, SUM(Freight) AS TotalFreightCost
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query to retrieve the data
orders_data = execute_sql_query(sql_query)

# Check if the returned dataframe is empty
if orders_data.empty:
    print(""No data available for the year 2023."")
else:
    # Create a bar chart to visualize the total freight costs per month
    fig = px.bar(orders_data, x='OrderMonth', y='TotalFreightCost',
                 title='Total Freight Costs per Month in 2023',
                 labels={'OrderMonth': 'Month', 'TotalFreightCost': 'Total Freight Cost'},
                 text='TotalFreightCost')
    fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
    fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
    
    # Display the visualization to the user
    show_to_user(fig)
",The input code successfully performs the task of fetching freight cost totals for each month in 2023 and visualizes them. It uses a bar chart instead of a line chart but effectively addresses the business request and matches the reference implementation's outcome.,Base
Which categories have an average unit price above $20?,"import pandas as pd
import plotly.express as px

# SQL query to get the categories with average unit price above $20
sql_query = '''
SELECT CategoryName
FROM categories c
JOIN products p ON c.CategoryID = p.CategoryID
GROUP BY c.CategoryName
HAVING AVG(p.UnitPrice) > 20;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user using the utility function
show_to_user(result_df)

# Optional: Visualize the result using a bar plot
fig = px.bar(result_df, x='CategoryName', title='Categories with Average Unit Price Above $20', y='avg_price')
show_to_user(fig)","import pandas as pd

# SQL query to retrieve categories with average unit price above $20
sql_query = '''
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
HAVING AVG(p.UnitPrice) > 20
'''  

# Execute the SQL query to get the data
result_df = execute_sql_query(sql_query)

# Show the resulting dataframe to the user
show_to_user(result_df)","The evaluated code retrieves categories based only on CategoryID without joining with the categories table to get the CategoryName. Thus, it doesn't fully meet the business request of listing categories with average unit prices above $20 by their names.","import pandas as pd
import plotly.express as px

# Query to retrieve categories with average unit price above $20
sql_query = '''
SELECT c.CategoryID, c.CategoryName 
FROM categories c 
JOIN products p ON c.CategoryID = p.CategoryID 
GROUP BY c.CategoryID, c.CategoryName 
HAVING AVG(p.UnitPrice) > 20;
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(result_df)

# Optional: Visualization (e.g., bar chart)
fig = px.bar(result_df, x='CategoryName', title='Categories with Average Unit Price Above $20', labels={'CategoryName':'Category Name'})
show_to_user(fig)","The input code successfully retrieves categories with an average unit price above $20. Although it includes 'CategoryID' in the SELECT statement, it doesn't affect the correctness related to the business analytic request. The code achieves the same outcome as the reference implementation.",Finetuned
Who are the suppliers for orders placed in the first quarter of this year?,"import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the needed data
sql_query = """"""
SELECT DISTINCT s.CompanyName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query using the provided utility function
suppliers_df = execute_sql_query(sql_query)

# Display the data to the user using the provided utility function
show_to_user(suppliers_df)","import pandas as pd

# Define the SQL query to retrieve suppliers for orders placed in the first quarter of the current year
sql_query = '''
SELECT DISTINCT s.SupplierID, s.CompanyName, s.ContactName, s.ContactTitle, s.Address,
                s.City, s.Region, s.PostalCode, s.Country, s.Phone
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID = o.OrderID
WHERE o.OrderDate >= '2023-01-01' AND o.OrderDate <= '2023-03-31'
'''

# Execute the SQL query and retrieve the data as a pandas dataframe
supplier_data = execute_sql_query(sql_query)

# Display the results to the user
show_to_user(supplier_data)","The input code incorrectly joins 'products' with 'orders' on 'ProductID' and 'OrderID', instead of joining 'Order Details' with 'orders'. This leads to incorrect results. The reference code uses the correct joins and conditions.","import pandas as pd

# Define the SQL query
sql_query = '''
SELECT DISTINCT suppliers.SupplierID, suppliers.CompanyName 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
'''

# Execute the SQL query to get the data
unique_suppliers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(unique_suppliers_df)","The input code correctly retrieves distinct suppliers for orders placed in the first quarter of 2023. It includes `SupplierID` along with `CompanyName`, which is an additional detail compared to the reference but does not affect correctness. It uses a JOIN to link suppliers with the respective orders within the specified date range, which matches the business analytic request and the outcome of the reference implementation.",Finetuned
What is the total sales quantity for each product? Please provide a visualization showing the sales quantity per product.,"import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query
sql_query = 'SELECT ProductID, SUM(Quantity) AS TotalSales FROM [Order Details] GROUP BY ProductID;'

# Step 2: Execute the SQL query to retrieve the data
sales_data = execute_sql_query(sql_query)

# Step 3: Create a visualization of the total sales quantity per product
fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Total Sales Quantity per Product', labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales Quantity'})

# Step 4: Display the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales quantity for each product
sql_query = '''
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSalesQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
'''  

# Execute SQL query and retrieve data
sales_data = execute_sql_query(sql_query)

# Create visualization
fig = px.bar(sales_data, x='ProductName', y='TotalSalesQuantity',
             title='Total Sales Quantity per Product',
             labels={'TotalSalesQuantity': 'Sales Quantity', 'ProductName': 'Product Name'})

# Display the result to user
show_to_user(fig)","The input code retrieves the total sales quantity for each product and creates a bar chart for this data, similar to the reference code. It includes product names in the data, providing additional context, but still achieves the same outcome: visualizing sales quantity per product.","import plotly.express as px

# Function to execute the SQL query
sql_query = 'SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM [Order Details] GROUP BY ProductID;'
data = execute_sql_query(sql_query)

# Create a bar chart for the sales quantity per product
fig = px.bar(data, x='ProductID', y='TotalQuantity', title='Total Sales Quantity per Product', labels={'TotalQuantity': 'Total Quantity', 'ProductID': 'Product ID'})

# Show the visualization to the user
show_to_user(fig)",The input Python code correctly implements the business analytic request by executing an SQL query to retrieve the total sales quantity for each product and visualizes it using a Plotly bar chart. The differences in column naming ('TotalSales' vs 'TotalQuantity') do not affect the correctness as the data is accurately represented.,Base
Which city has the highest number of orders? Please visualize the number of orders per city.,"import pandas as pd
import plotly.express as px

# Execute the SQL query
sql_query = '''
SELECT ShipCity, COUNT(OrderID) as NumberOfOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC;
'''

df = execute_sql_query(sql_query)

# Extract the city with the highest number of orders
city_with_highest_orders = df.iloc[0]['ShipCity']

# Extract the number of orders for the city with the highest number of orders
number_of_orders_highest_city = df.iloc[0]['NumberOfOrders']

# Visualize the number of orders per city
fig = px.bar(df, x='ShipCity', y='NumberOfOrders', title='Number of Orders per City')

# Show the results to the user
show_to_user(fig)

# Also show the city with the highest number of orders
highest_orders_df = pd.DataFrame({'City': [city_with_highest_orders], 'NumberOfOrders': [number_of_orders_highest_city]})
show_to_user(highest_orders_df)","import pandas as pd
import plotly.express as px

# SQL query to get the count of orders per city
sql_query = '''
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
'''

# Execute the SQL query
orders_per_city = execute_sql_query(sql_query)

# Get the city with the highest number of orders
highest_order_city = orders_per_city.iloc[0]
print(f""City with the highest number of orders: {highest_order_city['ShipCity']} - Orders: {highest_order_city['OrderCount']}"")

# Create a bar plot for the number of orders per city
fig = px.bar(orders_per_city, x='ShipCity', y='OrderCount', title='Number of Orders per City', labels={'OrderCount': 'Number of Orders', 'ShipCity': 'City'})

# Show the plot to the user
show_to_user(fig)","The input code correctly executes a SQL query to retrieve the count of orders per city, orders them in descending order, and identifies the city with the highest number of orders. It then visualizes the number of orders per city using a bar plot with Plotly. Although variable names differ, the outcome aligns with the business analytic request.","import pandas as pd
import plotly.express as px

# Execute the SQL query to get the number of orders per city
sql_query = 'SELECT ShipCity, COUNT(*) AS order_count FROM orders GROUP BY ShipCity ORDER BY order_count DESC;'
order_data = execute_sql_query(sql_query)

# DataFrame containing number of orders per city
display_data = order_data

# Visualize the number of orders per city
fig = px.bar(display_data, x='ShipCity', y='order_count', title='Number of Orders per City', labels={'ShipCity': 'City', 'order_count': 'Order Count'})

# Show the plot to the user
show_to_user(fig)

# Find the city with the highest number of orders
highest_order_city = display_data.iloc[0]
show_to_user(highest_order_city)","The input code successfully executes a SQL query to retrieve the number of orders per city and visualizes this data using a bar chart. It also correctly identifies the city with the highest number of orders and displays it, fulfilling the business analytic request.",Base
What is the average order fulfillment time for each shipping method? Provide a visualization to compare the fulfillment times of different shipping methods.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query to retrieve data
orders_df = execute_sql_query(sql_query)

# Check the retrieved dataframe
print(orders_df.head())

# Ensure column names are consistent
orders_df.columns = ['ShipVia', 'AverageFulfillmentTime']

# Create a bar chart to compare the fulfillment times of different shipping methods
fig = px.bar(orders_df, x='ShipVia', y='AverageFulfillmentTime', title='Average Order Fulfillment Time by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Show the plot to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to calculate average order fulfillment time for each shipping method
sql_query = '''
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS Avg_Fulfillment_Time
FROM orders
GROUP BY ShipVia
'''

# Execute the SQL query
fulfillment_data = execute_sql_query(sql_query)

# Create a plotly bar chart to visualize the average order fulfillment time by shipping method
fig = px.bar(fulfillment_data, x='ShipVia', y='Avg_Fulfillment_Time',
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'Avg_Fulfillment_Time': 'Average Fulfillment Time (Days)'}
            )

# Show the result to the user
show_to_user(fig)","The input code uses DATEDIFF with the argument order reversed compared to the reference implementation. This would result in negative fulfillment times if OrderDate is before ShippedDate. The correct order for DATEDIFF is (day, OrderDate, ShippedDate).","import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query and get the data
data = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(data, x='ShipVia', y='AverageFulfillmentTime', 
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AverageFulfillmentTime': 'Average Fulfillment Time (days)'}
            )

# Display the visualization
show_to_user(fig)
","The input code uses DATEDIFF with parameters reversed compared to the reference implementation, potentially leading to negative fulfillment times. Ensure the correct order of parameters in DATEDIFF.",None
Which customers have placed orders in the last month?,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT CustomerID FROM orders WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);""

# Execute the SQL query to get the data
customers_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(customers_df)","from datetime import datetime, timedelta

# Calculate the date one month ago from today
one_month_ago = datetime.now() - timedelta(days=30)
formatted_date = one_month_ago.strftime('%Y-%m-%d')

# SQL query to fetch customers who placed orders in the last month
sql_query = f""""""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE OrderDate >= '{formatted_date}'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(result_df)","The input code retrieves CustomerIDs for orders placed in the last month by calculating the date one month ago from today, which aligns with the business request. Although it uses a slightly different SQL query format than the reference implementation, the outcome is the same. It also appropriately uses the given utility functions.","import pandas as pd
import plotly.express as px

# Define the SQL query based on the business request
sql_query = """"""
SELECT c.CustomerID, c.CompanyName 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
""""""

# Execute the SQL query and get the result as a pandas dataframe
customers_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(customers_df)","The input code retrieves customers who placed orders in the last month by joining customers and orders tables based on CustomerID, ensuring the retrieval of required customer IDs. The output meets the business analytic request, as it includes CustomerID filtering by recent order dates, similar to the reference implementation.",Base
List customers who have placed orders within the last 30 days.,"import pandas as pd
import plotly.express as px

# SQL query to get orders from the last 30 days
sql_query = 'SELECT * FROM orders WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY);'

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the resulting dataframe to the user
show_to_user(orders_df)","import pandas as pd
from datetime import datetime, timedelta

# Calculate the date 30 days ago from today
thirty_days_ago = (datetime.now() - timedelta(days=30)).date()

# SQL query to get customers who placed orders in the last 30 days
sql_query = f""""""
SELECT DISTINCT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Address, 
                c.City, c.Region, c.PostalCode, c.Country, c.Phone, c.Fax 
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderDate >= '{thirty_days_ago}'
""""""

# Execute the SQL query
customer_orders_recent = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(customer_orders_recent)","The input code correctly filters customers who placed orders within the last 30 days. It joins the 'customers' and 'orders' tables, using the 'OrderDate' column to filter recent orders. This achieves the same outcome as the reference code, which selects orders from the last 30 days, albeit focusing only on customers. Despite structural differences, the business request is effectively fulfilled.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''SELECT DISTINCT CustomerID FROM orders WHERE DATEDIFF(CURDATE(), OrderDate) <= 30;'''

# Execute the SQL query to get the data
customer_df = execute_sql_query(sql_query)

# Check if the result is empty
if customer_df.empty:
    print(""No customers have placed orders within the last 30 days."")
else:
    # Show the result to user
    show_to_user(customer_df)","The input code correctly lists customers who have placed orders within the last 30 days by selecting distinct CustomerIDs where OrderDate is within the last 30 days. This aligns with the business request, even though the output format slightly differs from the reference implementation, which lists all orders instead of distinct customers.",Base
What are the names and unit prices of all products?,"import pandas as pd
import plotly.express as px

# SQL query to fetch the names and unit prices of all products
sql_query = 'SELECT ProductName, UnitPrice FROM products;'

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the result to the user
show_to_user(products_df)","import pandas as pd

# SQL query to retrieve product names and unit prices
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
""""""

# Execute the SQL query
product_data = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(product_data)","The input code correctly executes a SQL query to fetch product names and unit prices, and displays the results using the appropriate utility functions as required by the business analytic request.","
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = 'SELECT ProductName, UnitPrice FROM products;'

# Execute the SQL query to get the data
products_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(products_df)
","The input code performs the requested task accurately, matching the reference implementation by fetching names and unit prices of all products and displaying them using the provided utility functions.",Base
Find the monthly sales performance for each product. Include a visualization to show the monthly sales trends for each product.,"import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate) AS Month, 
SUM(od.Quantity) AS MonthlySales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY p.ProductID, p.ProductName, EXTRACT(MONTH FROM o.OrderDate);
'''

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Ensure 'Month' is treated as a categorical type for proper sorting and plotting
sales_data['Month'] = sales_data['Month'].astype(int)

# Create a line plot for monthly sales trends for each product
fig = px.line(sales_data, x='Month', y='MonthlySales', color='ProductName', title='Monthly Sales Trends for Each Product', 
              labels={'Month': 'Month', 'MonthlySales': 'Monthly Sales', 'ProductName': 'Product Name'}, 
              category_orders={'Month': list(range(1, 13))})

# Show the plot to the user
show_to_user(fig)
","import pandas as pd
import plotly.express as px

# SQL query to retrieve monthly sales performance for each product
sql_query = """"""
SELECT
    DATE_TRUNC('month', OD.OrderDate) AS Month,
    P.ProductName,
    SUM(OD.Quantity) AS TotalSales,
    SUM(OD.Quantity * OD.UnitPrice * (1 - OD.Discount)) AS Revenue
FROM
    [Order Details] OD
JOIN
    products P ON OD.ProductID = P.ProductID
GROUP BY
    Month, P.ProductName
ORDER BY
    Month, P.ProductName
""""""

# Execute the SQL query to get the data
monthly_sales_df = execute_sql_query(sql_query)

# Visualize the monthly sales trends for each product
fig = px.line(monthly_sales_df,
              x='Month',
              y='Revenue',
              color='ProductName',
              title='Monthly Sales Trends for Each Product',
              labels={'Revenue': 'Total Revenue', 'Month': 'Month'})

# Display the result to user
show_to_user(fig)","The input code calculates and visualizes revenue, while the reference code analyzes monthly sales in terms of quantity. Although both codes involve monthly performance trends, the input code focuses on a different metric--revenue instead of sales quantity as in the reference implementation.","To address the user request effectively, we will implement the following steps in our Python code:

1. Execute the SQL query to retrieve the monthly sales performance for each product.
2. Transform the retrieved data into a suitable format for visualization.
3. Generate a plot to show the monthly sales trends for each product.
4. Display the visualization result to the user.

Let's dive into the Python code implementation.

```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query
data = execute_sql_query(""""""
SELECT products.ProductName, EXTRACT(MONTH FROM orders.OrderDate) AS order_month, 
SUM([Order Details].Quantity) AS total_quantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY products.ProductName, order_month;
"""""")

# Step 2: Transform the data
# Ensure order_month is treated as a categorical variable to preserve order in plots
data['order_month'] = data['order_month'].astype(str).astype('category')
data['order_month'].cat.set_categories([str(i) for i in range(1, 13)], ordered=True)

# Step 3: Generate the plot
fig = px.line(data, x='order_month', y='total_quantity', color='ProductName', title='Monthly Sales Trends for Each Product', labels={'order_month': 'Month', 'total_quantity': 'Total Quantity Sold'})

# Step 4: Display the visualization result
show_to_user(fig)
```

### Explanation

1. **Executing the SQL Query**: We use the `execute_sql_query` function to retrieve the desired data. The SQL query groups the data monthly and by product name.

2. **Data Transformation**: After retrieving the data, we adjust the `order_month` to ensure it is recognized as a categorical type. This guarantees that when plotting, the months are displayed in the correct order.

3. **Creating the Visualization**: We leverage `plotly.express` to generate a line plot. The x-axis represents the months, while the y-axis represents the total quantity sold per product.

4. **Displaying the Result**: Finally, we utilize `show_to_user` to display the resulting plot to the user.

### Running the Code
Ensure the Python environment has the necessary packages (`pandas`, `plotly`) before executing the provided script.","The input code correctly implements the business analytic request by executing a SQL query to retrieve monthly sales data for each product, transforming this data for plotting, and generating a line plot using Plotly to show monthly sales trends. This achieves the same outcome as the reference implementation.",Finetuned
What is the total sales revenue generated last month?,"import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue generated last month
sql_query = '''
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Total_Sales_Revenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
'''

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the total sales revenue from the result
total_sales_revenue = result_df['Total_Sales_Revenue'][0]

# Prepare the data for displaying
result_to_display = pd.DataFrame({'Total_Sales_Revenue': [total_sales_revenue]})

# Show the result to the user
show_to_user(result_to_display)","import pandas as pd

# SQL query to calculate total sales revenue for last month
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' 
AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE)
""""""

# Execute the SQL query
total_sales_df = execute_sql_query(sql_query)

# Show the result to the user
show_to_user(total_sales_df)","The input code correctly calculates the total sales revenue for the last month using SQL. It applies the same logic as the reference code by joining orders and order details, applying discounts, and filtering for the previous month. The display method may differ slightly, but the essential outcome matches the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue generated last month
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATEADD(month, -1, GETDATE())
""""""

# Execute the SQL query and get the result
result_df = execute_sql_query(sql_query)

# Extract the total sales value
total_sales = result_df['TotalSales'].iloc[0]

# Convert the total sales value to a DataFrame for display
result_to_display = pd.DataFrame({'TotalSales': [total_sales]})

# Display the result to the user
show_to_user(result_to_display)
","The input code uses GETDATE() and DATEADD to determine the last month, which is incorrect. The 'DateAdd' comparison needs adjustment to filter for the last month correctly. Additionally, it should consider the entire last month (e.g., using a more precise range) rather than starting from one month prior to the current date.",Base
Which employees have handled the most orders? Please visualize the results to highlight the top performers.,"import pandas as pd
import plotly.express as px

# SQL query to get employees who handled the most orders
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS OrdersHandled 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrdersHandled DESC;
'''

# Execute the SQL query and get the results in a pandas dataframe
df = execute_sql_query(sql_query)

# Validate the structure of the dataframe
df.columns = ['EmployeeID', 'OrdersHandled']

# Create a bar chart to visualize the top performers
fig = px.bar(df, x='EmployeeID', y='OrdersHandled', title='Top Employees by Orders Handled',
             labels={'EmployeeID':'Employee ID', 'OrdersHandled':'Orders Handled'},
             color='OrdersHandled',
             color_continuous_scale=px.colors.sequential.Plasma)

# Show the visualization to the user
show_to_user(fig)","import pandas as pd
import plotly.express as px

# SQL query to get the counts of orders handled by each employee
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) as OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
'''  

# Execute the SQL query
employee_orders_df = execute_sql_query(sql_query)

# Visualize the results to highlight the top performers
fig = px.bar(employee_orders_df,
             x='EmployeeID', 
             y='OrderCount', 
             title='Top Employees by Number of Orders',
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'},
             color='OrderCount', 
             color_continuous_scale=px.colors.sequential.Viridis)

# Show the visualization to the user
show_to_user(fig)","The input code correctly addresses the business analytic request by executing a SQL query that counts the number of orders handled by each employee, ordering by the count in descending order. It then uses Plotly to visualize the top performers in a bar chart format. While the color scale is different from the reference, both codes achieve the same outcome and effectively visualize the top-performing employees.","import pandas as pd
import plotly.express as px

# SQL query to get employees who handled the most orders
sql_query = """"""
SELECT e.EmployeeID, COUNT(e.EmployeeID) AS OrderCount 
FROM employees e 
INNER JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get the results in a dataframe
results_df = execute_sql_query(sql_query)

# Create a bar chart using plotly
fig = px.bar(results_df, x='EmployeeID', y='OrderCount', 
             title='Employee Order Handling Performance', 
             labels={'EmployeeID':'Employee ID', 'OrderCount':'Number of Orders'})

# Highlighting top performers by changing bar color
fig.update_traces(marker_color='indigo')

# Show the plot to the user
show_to_user(fig)","The input code effectively addresses the business analytic request by identifying employees with the most orders. It uses a SQL query akin to the reference implementation to retrieve counts of orders handled by employees, uses Plotly to create a bar chart, and utilizes util functions correctly for execution and displaying the results. Although the SQL joins the employees and orders tables, it achieves the same outcome as grouping by EmployeeID in the orders table since it counts the number of orders per employee.",Base
