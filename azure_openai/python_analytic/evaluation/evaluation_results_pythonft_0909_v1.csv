Business Analytic Request,Ground Truth Code,Generated Code by Base Model,Base Model Explanation,Generated Code by Finetuned Model,Finetuned Model Explanation,Model that got it right
"What is the average discount applied to orders each month, and can you display this information with a line or bar chart?","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       AVG(`[Order Details]`.Discount) AS avg_discount 
FROM `[Order Details]` 
JOIN orders ON `[Order Details]`.OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY month
""""""

# Execute the SQL query and get the result as a DataFrame
data = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(
    data, 
    x='month', 
    y='avg_discount', 
    title='Average Discount Applied to Orders Each Month in 2023',
    labels={'avg_discount': 'Average Discount', 'month': 'Month'},
    markers=True
)

# Display the figure to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
       AVG([Order Details].Discount) AS average_discount
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY month
ORDER BY month
""""""
data = execute_sql_query(sql_query)

fig = px.line(data, x='month', y='average_discount', title='Average Discount Applied to Orders Each Month')
show_to_user(fig)
```","The input code does not filter the orders to only include those from the year 2023, unlike the reference implementation. This means it will not accurately reflect the average discount for that specific year. Additionally, the input code calculates the average discount but does not specify this restriction.","```python
import pandas as pd
import plotly.express as px

def execute_business_analysis():
    # Define the SQL query
    sql_query = """"""
    SELECT 
        EXTRACT(YEAR FROM orders.OrderDate) AS order_year,
        EXTRACT(MONTH FROM orders.OrderDate) AS order_month,
        AVG([Order Details].Discount) AS average_discount
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    GROUP BY order_year, order_month;
    """"""
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Check if the retrieved DataFrame has the expected columns
    if not {'order_year', 'order_month', 'average_discount'}.issubset(df.columns):
        raise ValueError(""SQL query did not return the expected columns."")

    # Ensure 'order_month' is treated as an integer
    df['order_month'] = df['order_month'].astype(int)

    # Add a new column for 'Month' in yyyy-mm format
    df['Month'] = df['order_year'].astype(str) + '-' + df['order_month'].astype(str).str.zfill(2)

    # Create a line chart using Plotly
    fig = px.line(
        df, 
        x='Month', 
        y='average_discount', 
        title='Average Discount Applied to Orders Each Month',
        labels={'average_discount': 'Average Discount', 'Month': 'Month'},
        markers=True
    )
    
    # Display the chart
    show_to_user(fig)

# Call the function to perform the analysis
execute_business_analysis()
```","The input Python code does not filter the data to include only the year 2023, which is a key requirement in the business request and reference implementation. Although the implemented logic for querying and charting is similar, the lack of year filtering makes the result potentially incorrect for the specified requirement.",None
"Which city had the highest number of orders placed, and can you provide a bar chart to visualize the number of orders per city?","
```python
import pandas as pd
import plotly.express as px

# Function that executes a given SQL query and returns the result as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation, replace with actual database connection logic
    data = {
        'ShipCity': ['CityA', 'CityB', 'CityC'],
        'OrderCount': [150, 200, 120]
    }
    return pd.DataFrame(data)

# Function that would display data or visualization results to the user
def show_to_user(data):
    # Mock implementation
    print(data)

# SQL query to get the order count per city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount FROM orders GROUP BY ShipCity
""""""

# Execute the query
df_orders = execute_sql_query(sql_query)

# Determine the city with the highest number of orders
city_with_most_orders = df_orders.loc[df_orders['OrderCount'].idxmax()]

# Output the city with the highest number of orders
show_to_user(pd.DataFrame([city_with_most_orders]))

# Create a bar chart for the order counts per city
fig = px.bar(df_orders, x='ShipCity', y='OrderCount', title='Number of Orders per City')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 1
""""""
highest_city_df = execute_sql_query(sql_query)

city = highest_city_df['ShipCity'].values[0]

sql_query_all = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
""""""
orders_per_city_df = execute_sql_query(sql_query_all)

fig = px.bar(orders_per_city_df, x='ShipCity', y='OrderCount', title='Number of Orders per City')
show_to_user(fig)
```","Both the reference and input code correctly identify the city with the highest number of orders and produce a bar chart to visualize the number of orders per city. The input code uses an additional step with an SQL query to immediately find the city with the highest order count, which is a valid approach. The logic adheres to the requirement and aligns with the reference code's intent, even though the specific method for finding the city is different.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC;
""""""

# Function to execute the SQL query and return the results in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation of the function to execute the SQL query
    # This should be connected to the actual database logic
    # For demonstration, returning a sample DataFrame
    data = {
        ""ShipCity"": [""New York"", ""Los Angeles"", ""Chicago""],
        ""NumberOfOrders"": [150, 120, 100]
    }
    return pd.DataFrame(data)

# Execute the query
df_orders_per_city = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_orders_per_city, x='ShipCity', y='NumberOfOrders', 
             title='Number of Orders per City', 
             labels={'ShipCity': 'City', 'NumberOfOrders': 'Number of Orders'})

# Function to display the visualization to the user
def show_to_user(data):
    # This function displays data or a visualization
    # Assuming a logical implementation is available
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code doesn't determine the city with the highest number of orders before creating the bar chart. The reference code identifies the city with the maximum orders using `idxmax` and shows it separately. The SQL query in the input code sorts the data by orders, but this doesn't fulfill the exact request to explicitly identify or output the city with the most orders before generating the chart.",Base
Who are the top 5 employees in terms of total sales revenue? Include a bar chart to compare their sales performance.,"```python
import plotly.express as px
import pandas as pd

# SQL query to fetch the top 5 employees based on total sales
sql_query = """"""
    SELECT e.EmployeeID, 
           SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
    FROM employees e 
    JOIN orders o ON e.EmployeeID = o.EmployeeID 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    GROUP BY e.EmployeeID 
    ORDER BY TotalSales DESC 
    LIMIT 5;
""""""

# Execute query and get results as a DataFrame
top_employees_sales = execute_sql_query(sql_query)

# Creating a bar chart to compare sales performance
fig = px.bar(top_employees_sales, x='EmployeeID', y='TotalSales', 
             title='Top 5 Employees by Total Sales Revenue',
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales Revenue'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
ORDER BY 
    TotalSales DESC
LIMIT 5;
""""""

top_employees = execute_sql_query(sql_query)

fig = px.bar(top_employees, 
              x=top_employees['FirstName'] + ' ' + top_employees['LastName'], 
              y='TotalSales', 
              title='Top 5 Employees by Total Sales Revenue',
              labels={'x': 'Employee', 'TotalSales': 'Total Sales Revenue'})

show_to_user(fig)
```",The input code correctly retrieves the top 5 employees by total sales revenue and generates a bar chart for comparison. It includes additional columns for FirstName and LastName to display full names which do not alter the logic but enhances readability. The logic of the data retrieval and chart generation aligns with the reference code.,"```python
import plotly.express as px
import pandas as pd

# Execute the SQL query to get the top 5 employees by sales revenue
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Function to execute SQL query (assumed implemented)
def execute_sql_query(sql_query: str):
    # Placeholder for function implementation
    pass

# Fetch the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='TotalRevenue', 
             title='Top 5 Employees by Total Sales Revenue',
             labels={'EmployeeID': 'Employee ID', 'TotalRevenue': 'Total Revenue'})

# Function to display the result
def show_to_user(data):
    # Placeholder for function to display the result
    pass

# Show the bar chart to user
show_to_user(fig)
```","The input Python code fulfills the business analytics request by selecting the top 5 employees in terms of total sales revenue from a database and creating a bar chart to compare their sales performance. It adheres to the same logic as the reference implementation. The differences in naming the alias for total sales revenue (`TotalRevenue` vs. `TotalSales`) and their uses are consistent with the intent. Both the input and reference codes use a SQL query to compute total sales and a Plotly bar chart for visualization. The function placeholders for executing the query and displaying the result are present in both, making the input code correct.",both
Which suppliers have products with zero stock available? Please include a bar chart to display the count of zero-stock products per supplier.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch suppliers with zero-stock products
sql_query = """"""
SELECT s.SupplierID, s.CompanyName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.UnitsInStock = 0;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Count zero-stock products per supplier
zero_stock_count = df.groupby('CompanyName').size().reset_index(name='ZeroStockCount')

# Create a bar chart
fig = px.bar(zero_stock_count, x='CompanyName', y='ZeroStockCount', 
             title='Zero Stock Products per Supplier',
             labels={'ZeroStockCount': 'Count of Zero-Stock Products', 'CompanyName': 'Supplier'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(p.ProductID) AS ZeroStockCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.UnitsInStock = 0
GROUP BY s.SupplierID, s.CompanyName
""""""

zero_stock_suppliers = execute_sql_query(sql_query)

fig = px.bar(zero_stock_suppliers, x='CompanyName', y='ZeroStockCount', title='Count of Zero-Stock Products per Supplier')
show_to_user(fig)
```","The input code correctly identifies suppliers with zero-stock products and visualizes the count per supplier using a bar chart. It executes a SQL query similar to the reference by joining suppliers and products and filtering for zero-stock items. It aggregates the count of such products per supplier within the SQL query, a slight but equivalent variation on the logic. The bar chart is constructed and displayed correctly, fulfilling the business analytics request.","```python
import plotly.express as px
import pandas as pd

# SQL query to find products with zero stock
sql_query = """"""
SELECT s.SupplierID, COUNT(p.ProductID) AS ZeroStockProducts
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitsInStock = 0
GROUP BY s.SupplierID;
""""""

# Execute the SQL query using the utility function
zero_stock_df = execute_sql_query(sql_query)

# Create a bar chart to display the count of zero-stock products per supplier
fig = px.bar(zero_stock_df, x='SupplierID', y='ZeroStockProducts',
             title='Count of Zero-Stock Products per Supplier',
             labels={'SupplierID': 'Supplier ID', 'ZeroStockProducts': 'Zero Stock Products'})

# Show the plot to the user
show_to_user(fig)
```","The input code does not align with the reference implementation. The primary issue is that the reference code retrieves and displays supplier names, while the input code uses `SupplierID`. Additionally, the input code performs the aggregation (COUNT of zero-stock products) in the SQL query, whereas the reference code performs this operation in Python using `groupby`. Although the input code does count zero-stock products correctly, it does not meet the requirement of displaying supplier names, which is a key part of the business analytics request.",Base
"What is the total number of sales per city, and can you provide a bar chart to visualize the comparisons?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total number of sales per city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS TotalSales 
FROM orders 
GROUP BY ShipCity;
""""""

# Execute the SQL query and store the result in a DataFrame
df_sales_per_city = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales per city
fig = px.bar(df_sales_per_city, x='ShipCity', y='TotalSales', 
             title='Total Sales per City', 
             labels={'ShipCity': 'City', 'TotalSales': 'Total Sales'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.City, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.City
""""""

sales_per_city = execute_sql_query(sql_query)

fig = px.bar(sales_per_city, x='City', y='TotalSales', title='Total Sales per City')
show_to_user(fig)
```","The provided code calculates total sales revenue per city based on employee locations and line item details, which differs from the reference implementation's calculation of the total number of sales (count of orders) per city based solely on order information. Additionally, it uses a different SQL query structure and joins multiple tables, which does not adhere to the reference logic.","
import plotly.express as px

# Define the query to get total sales per city
query = """"""
SELECT 
    customers.City, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.City;
""""""

# Execute the SQL query
df_sales_per_city = execute_sql_query(query)

# Create a bar chart using Plotly
fig = px.bar(df_sales_per_city, x='City', y='TotalSales', title='Total Sales per City',
             labels={'TotalSales': 'Total Sales', 'City': 'City'}, 
             template='plotly');

# Display the figure to the user
show_to_user(fig)
","The input code calculates total sales revenue per city, not the count of orders as requested. The reference code counts order IDs to find the number of sales per city. Additionally, different tables and fields are used between the codes.",None
"Which customers have received the largest discounts, and can we visualize this data to better understand the distribution and patterns?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT c.CustomerID, MAX(od.Discount) AS MaxDiscount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID
ORDER BY MaxDiscount DESC;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
discount_data = execute_sql_query(sql_query)

# Visualize the distribution and patterns of discounts using a bar chart
fig = px.bar(
    discount_data,
    x='CustomerID',
    y='MaxDiscount',
    title='Maximum Discounts Received by Customers',
    labels={'CustomerID': 'Customer ID', 'MaxDiscount': 'Maximum Discount'},
    template='plotly_dark',
)

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve customers with the largest discounts
sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    SUM(od.Discount) AS TotalDiscount
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    TotalDiscount DESC
LIMIT 10
""""""

# Execute the SQL query and get the DataFrame
discount_data = execute_sql_query(sql_query)

# Visualization of the total discounts received by customers
fig = px.bar(discount_data, x='CompanyName', y='TotalDiscount',
             title='Top 10 Customers with Largest Discounts',
             labels={'CompanyName': 'Customer', 'TotalDiscount': 'Total Discount'},
             color='TotalDiscount')

show_to_user(fig)
```","The provided input code calculates TotalDiscount per customer, while the reference code calculates MaxDiscount per customer. These are different metrics, leading to different interpretations. Additionally, the input code limits results to the top 10 customers, whereas the reference code does not specify a limit.","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           [Order Details].Discount) AS Discount 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY Discount DESC
""""""

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function for the purpose
    # In a real scenario, this would execute the SQL and return a DataFrame
    pass

# Execute the SQL query to get data
discounts_df = execute_sql_query(sql_query)

# Ensure data was fetched successfully
if discounts_df is not None and not discounts_df.empty:
    # Visualize data using Plotly
    fig = px.histogram(discounts_df, x='Discount', 
                       title='Distribution of Discounts Among Customers',
                       labels={'Discount': 'Total Discount'},
                       nbins=20)
    
    # Show the histogram to the user
    show_to_user(fig)  # Assuming show_to_user is defined to display figures

```","The input code calculates the total discount received by each customer, while the reference code identifies the maximum discount received by any customer. They are answering different questions. Additionally, the input code visualizes a histogram of discounts rather than a bar chart of maximum discounts per customer.",None
"Which customers have placed more than ten orders, and can you provide a bar chart to visualize the number of orders per customer?","
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is expected to be pre-defined and available for use
    pass

def show_to_user(data):
    # This function is expected to be pre-defined and available for use
    pass

# Define the SQL query to get customers with more than ten orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10;
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Generate a bar chart showing the number of orders per customer
fig = px.bar(order_data, x='CustomerID', y='OrderCount',
             title='Number of Orders Per Customer',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) AS OrderCount
FROM orders o
GROUP BY o.CustomerID
HAVING COUNT(o.OrderID) > 10
""""""

customers_with_many_orders = execute_sql_query(sql_query)

fig = px.bar(customers_with_many_orders, x='CustomerID', y='OrderCount', 
              title='Number of Orders per Customer (More than 10 Orders)', 
              labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The input code is correct as it follows the same logic as the reference implementation. Both codes define an identical SQL query to select CustomerIDs with more than ten orders and count the number of orders. The query results are then used to create a bar chart using Plotly Express, which is displayed using the same utility function. The minor differences, such as aliasing the orders table and slight variations in chart title, do not affect the correctness of the code with respect to the business analytics requirement.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY CustomerID 
HAVING COUNT(OrderID) > 10;
""""""

# Execute the SQL query using the utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function mocks the execution and returns sample data
    # In practice, replace this with the actual database connection and SQL execution
    return pd.DataFrame({
        'CustomerID': [1, 2, 3],
        'NumberOfOrders': [15, 12, 20]
    })

df_orders_over_ten = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per customer
fig = px.bar(df_orders_over_ten, x='CustomerID', y='NumberOfOrders',
             title='Number of Orders per Customer',
             labels={'NumberOfOrders': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Display the bar chart using the utility function
def show_to_user(data):
    # This function mocks the display logic
    print(""Mock display function called"")
    if isinstance(data, pd.DataFrame):
        print(""Displaying dataframe:"")
        print(data)
    else:
        print(""Displaying visualization:"")
        data.show()

show_to_user(fig)
```","The provided code correctly executes an SQL query to retrieve customers with more than ten orders, similarly to the reference implementation. It uses Plotly Express to create a bar chart visualizing the number of orders per customer. The logic, data flow, and final output are consistent with the reference implementation, including the use of the utility functions `execute_sql_query` and `show_to_user`.",both
"What is the customer lifetime value of each customer, and how can it be visualized to highlight patterns across different segments?","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate customer lifetime value
sql_query = """"""
SELECT 
    customers.CustomerID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
GROUP BY 
    customers.CustomerID
""""""

# Execute the SQL query and get the result as a DataFrame
customer_ltv_df = execute_sql_query(sql_query)

# Sort the DataFrame by customer_lifetime_value for better visualization
customer_ltv_df.sort_values(by='customer_lifetime_value', ascending=False, inplace=True)

# Visualize the customer lifetime value across different segments
fig = px.bar(
    customer_ltv_df, 
    x='CustomerID', 
    y='customer_lifetime_value',
    title='Customer Lifetime Value by Customer ID',
    labels={'customer_lifetime_value': 'Lifetime Value', 'CustomerID': 'Customer ID'},
    template='plotly_dark'
)

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value,
       customerDemographics.CustomerDesc
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
JOIN customerCustomerDemo ON customers.CustomerID = customerCustomerDemo.CustomerID 
JOIN customerDemographics ON customerCustomerDemo.CustomerTypeID = customerDemographics.CustomerTypeID 
GROUP BY customers.CustomerID, customerDemographics.CustomerDesc
""""""

customer_lifetime_value_df = execute_sql_query(sql_query)

fig = px.bar(customer_lifetime_value_df, 
             x='CustomerID', 
             y='customer_lifetime_value', 
             color='CustomerDesc', 
             title='Customer Lifetime Value by Customer Segments')
show_to_user(fig)
```","The input code introduces additional segmentation by customer demographics, which deviates from the reference task that only calculates and visualizes LTV by Customer ID. The input code groups data by both CustomerID and CustomerDesc, adding complexity that may highlight patterns across customer segments but does not align with the simplicity of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Utility functions placeholder
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This would contain logic to execute the SQL query 
    # and return the results as a pandas DataFrame.
    pass

def show_to_user(data):
    # Logic to display data or visualization to the user.
    pass

# SQL Query to calculate Customer Lifetime Value
sql_query = """"""
SELECT 
    customers.CustomerID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.CustomerID;
""""""

# Execute SQL and retrieve data
customer_lifetime_df = execute_sql_query(sql_query)

# Visualize Customer Lifetime Value
fig = px.histogram(customer_lifetime_df, 
                   x='customer_lifetime_value', 
                   nbins=50, 
                   title=""Distribution of Customer Lifetime Value"",
                   labels={'customer_lifetime_value': 'Customer Lifetime Value'})

# Show visualization
show_to_user(fig)
```","The provided code calculates customer lifetime value correctly using a SQL query, but the visualization approach differs from the reference implementation. The reference uses a bar chart to show customer lifetime value per customer, while the input code uses a histogram to depict the distribution of customer lifetime values. This does not align with the reference's requirement to highlight patterns across different segments per customer.",None
"What is the average number of products ordered per order, and could you provide a histogram to visualize the distribution of products ordered per order?","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user functions are already defined as per the environment constraints.

# SQL query to get OrderID and OrderQuantity (number of products per order)
sql_query = """"""
SELECT OrderID, COUNT(ProductID) AS OrderQuantity 
FROM [Order Details] 
GROUP BY OrderID
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Calculate the average number of products ordered per order
avg_products_per_order = order_data['OrderQuantity'].mean()

# Display the average number to the user
show_to_user(pd.DataFrame({'AvgProductsPerOrder': [avg_products_per_order]}))

# Generate a histogram to visualize the distribution of products ordered per order
fig = px.histogram(order_data, x='OrderQuantity', nbins=20, title='Distribution of Products Ordered Per Order')

# Show the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.OrderID,
    SUM(od.Quantity) AS TotalProductsOrdered
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.OrderID
""""""

order_details_df = execute_sql_query(sql_query)

average_products = order_details_df['TotalProductsOrdered'].mean()

histogram_fig = px.histogram(order_details_df, x='TotalProductsOrdered', title='Distribution of Products Ordered per Order')
show_to_user(histogram_fig)

average_products
```","The input code calculates the sum of quantities per order instead of counting distinct products per order. It uses SUM(od.Quantity) while the reference uses COUNT(ProductID). The aggregation logic differs, making the average potentially inaccurate compared to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are pre-defined

# Step 1: SQL query to get all product quantities in orders
sql_query = ""SELECT products_on_orders.Quantity FROM products_on_orders""
product_data_df = execute_sql_query(sql_query)

# Step 2: Calculate the average quantity of products ordered per order
average_quantity_per_order = product_data_df['Quantity'].mean()

# Display the average
# Using a DataFrame to facilitate display as a tabular result
average_df = pd.DataFrame({'AverageQuantityPerOrder': [average_quantity_per_order]})
show_to_user(average_df)

# Step 3: Create a histogram to visualize the distribution
fig = px.histogram(product_data_df, x='Quantity', title='Distribution of Products Ordered per Order')

# Step 4: Display the histogram
show_to_user(fig)
```","The input code does not correctly adhere to the business request as interpreted from the reference implementation. The reference code calculates the number of products per order by grouping data by OrderID and counting ProductID. However, the input code directly queries product quantities without grouping by order, which does not meet the original request.",None
Identify the top 5 products with the highest sales revenue and create a bar chart to visualize the comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to select top 5 products by sales revenue
sql_query = """"""
SELECT [Order Details].ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS product_sales 
FROM [Order Details] 
GROUP BY [Order Details].ProductID 
ORDER BY product_sales DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top products by sales revenue
fig = px.bar(
    top_products_df, 
    x='ProductID', 
    y='product_sales', 
    title='Top 5 Products by Sales Revenue',
    labels={'product_sales': 'Sales Revenue', 'ProductID': 'Product ID'},
    text_auto=True
)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS SalesRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY SalesRevenue DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='SalesRevenue', title='Top 5 Products by Sales Revenue')
show_to_user(fig)
```","The input code is correct as it adheres to the same logic as the reference implementation. Both scripts execute an SQL query to select the top 5 products with the highest sales revenue, ordering them by the calculated sales revenue from the product of UnitPrice, Quantity, and the discount factor, grouped by ProductID. The input code uses an alias 'od' for 'Order Details' in the SQL query, which is just a syntactic difference. Both codes utilize Plotly to create a bar chart for visualization. The key logic and functionality are maintained in the input code.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the product sales data
sql_query = """"""
SELECT p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS SalesRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY SalesRevenue DESC
LIMIT 5;
""""""

# Utility function to execute SQL query
product_sales_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to see the top 5 products by sales revenue
fig = px.bar(product_sales_df, x='ProductName', y='SalesRevenue',
             title='Top 5 Products by Sales Revenue',
             labels={'ProductName': 'Product Name', 'SalesRevenue': 'Sales Revenue'},
             text='SalesRevenue')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by selecting the top 5 products by sales revenue, similarly to the reference implementation. It uses a JOIN to get the product name instead of the product ID, which is a reasonable addition, and both SQL queries calculate the sales revenue in the same way. The bar chart creation and display are also consistent with the requirements.",both
"How many orders were not shipped at all, and can you provide a visualization of this data?","```python
import plotly.express as px
import pandas as pd

# SQL query to count orders not shipped
sql_query = ""SELECT COUNT(*) AS NotShippedOrders FROM orders WHERE ShippedDate IS NULL""

# Execute the SQL query
df_orders_not_shipped = execute_sql_query(sql_query)

# Visualize the data using Plotly
fig = px.bar(df_orders_not_shipped, 
             x=df_orders_not_shipped.index, 
             y='NotShippedOrders', 
             title='Orders Not Shipped',
             labels={'NotShippedOrders': 'Number of Orders'},
             text='NotShippedOrders')

# Update layout for better aesthetics
fig.update_traces(textposition='outside')
fig.update_layout(yaxis_title='Number of Orders', xaxis_title='')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT COUNT(OrderID) AS Not_Shipped_Orders
FROM orders
WHERE ShippedDate IS NULL
""""""

not_shipped_orders_df = execute_sql_query(sql_query)

fig = px.bar(not_shipped_orders_df, x='Not_Shipped_Orders', title='Number of Orders Not Shipped')
show_to_user(fig)
```","The input code does not include a text label on the bars, which is part of the reference implementation. It also doesn't update the layout for better aesthetics, such as setting text positions to be outside the bars, or defining axis titles.","```python
import plotly.express as px

# SQL query to find the number of orders not shipped
sql_query = ""SELECT COUNT(OrderID) AS UnshippedOrders FROM orders WHERE ShippedDate IS NULL;""

# Execute the query and get the result as a DataFrame
orders_df = execute_sql_query(sql_query)

# Generate a bar chart for unshipped orders
fig = px.bar(x=['Unshipped Orders'], y=orders_df['UnshippedOrders'], labels={'y': 'Count', 'x': 'Order Status'}, title='Number of Orders Not Shipped')

# Display the visualization to the user
show_to_user(fig)
```","The code accurately answers the business analytics request by querying the number of orders not shipped using an appropriate SQL query. It uses a similar logic as the reference code by executing a SQL query to count orders where 'ShippedDate' is null and visualizes this count using a bar chart from Plotly. While the variable names and the chart details differ slightly (e.g., x-axis label), the essential logic and outcome are consistent with the reference implementation.",Finetuned
"Identify orders that were shipped late and the shipping method used, and create a chart to show the frequency of late shipments by shipping method.","```python
import pandas as pd
import plotly.express as px

# Assuming the utility functions are defined elsewhere:

# SQL query to identify late shipments
sql_query = ""SELECT OrderID, ShipVia FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query and get the result as a pandas DataFrame
late_shipments_df = execute_sql_query(sql_query)

# Count the frequency of late shipments by shipping method
late_shipments_count = late_shipments_df['ShipVia'].value_counts().reset_index()
late_shipments_count.columns = ['ShippingMethod', 'Frequency']

# Create a bar chart to show the frequency of late shipments by shipping method
fig = px.bar(
    late_shipments_count,
    x='ShippingMethod',
    y='Frequency',
    title='Frequency of Late Shipments by Shipping Method',
    labels={'Frequency': 'Number of Late Shipments', 'ShippingMethod': 'Shipping Method'}
)

# Display the chart using the predefined utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS LateShipmentCount
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY ShipVia
""""""

late_shipments = execute_sql_query(sql_query)

fig = px.bar(late_shipments, x='ShipVia', y='LateShipmentCount', 
             title='Frequency of Late Shipments by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'LateShipmentCount': 'Number of Late Shipments'})

show_to_user(fig)
```","The input code meets the business analytics request by identifying late shipments and counting them by shipping method. The SQL query correctly groups by 'ShipVia' and counts the late shipments, which is equivalent to the 'value_counts()' approach in the reference code. The chart creation uses the same data structure to visualize the frequency of late shipments by shipping method. The logic and outcome align with the reference implementation, ensuring correctness.","import pandas as pd
import plotly.express as px

# Assuming the function execute_sql_query is available in the environment
def identify_late_shipments_and_visualize():
    # SQL query to identify late shipments and their shipping methods
    sql_query = """"""
    SELECT OrderID, ShipperName 
    FROM orders 
    JOIN shippers ON orders.ShipVia = shippers.ShipperID 
    WHERE ShippedDate > RequiredDate;
    """"""

    # Execute the query to get a DataFrame
    late_shipments_df = execute_sql_query(sql_query)

    # Count frequency of late shipments by shipping method
    late_shipments_count = late_shipments_df['ShipperName'].value_counts().reset_index()
    late_shipments_count.columns = ['Shipping Method', 'Frequency']

    # Create a bar chart using Plotly
    fig = px.bar(late_shipments_count, x='Shipping Method', y='Frequency', 
                 title='Frequency of Late Shipments by Shipping Method',
                 labels={'Frequency': 'Number of Late Shipments'})

    # Display the chart to the user
    show_to_user(fig)

# Run the function
identify_late_shipments_and_visualize()
","The input code correctly identifies late shipments using a SQL query. It joins the 'orders' table with the 'shippers' table to retrieve the shipping method name, whereas the reference code uses only the shipping method ID. It counts the frequency of late shipments by 'ShipperName' instead of 'ShipVia', which is a logical choice for a more descriptive output. The chart creation logic and its display are also consistent in purpose with the reference implementation. Thus, the input code adheres to the business request and logic of the reference code.",both
"Which product category generates the most revenue, and can this be visualized with a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to identify which product category generates the most revenue
sql_query = """"""
SELECT p.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue 
FROM [Order Details] od 
JOIN Products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
ORDER BY Revenue DESC;
""""""

# Execute the query and get the resulting DataFrame
result_df = execute_sql_query(sql_query)

# Determine the category with the maximum revenue
max_revenue_category = result_df.iloc[0]

# Display the category generating the most revenue
show_to_user(pd.DataFrame([max_revenue_category]))

# Create a bar chart for revenue by product category and display it
fig = px.bar(result_df, x='CategoryID', y='Revenue', title='Revenue by Product Category')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
GROUP BY 
    p.CategoryName
ORDER BY 
    Revenue DESC
LIMIT 1;
""""""

revenue_data = execute_sql_query(sql_query)
category = revenue_data['CategoryName'].values[0]
revenue = revenue_data['Revenue'].values[0]

bar_chart_data = pd.DataFrame({
    'Category': [category],
    'Revenue': [revenue]
})

fig = px.bar(bar_chart_data, x='Category', y='Revenue', title='Top Product Category by Revenue')
show_to_user(fig)
```","The input code limits the SQL query to only the top category by adding 'LIMIT 1'. Consequently, it does not generate a complete dataset for all categories, which is necessary for creating an accurate bar chart comparing all categories by revenue as specified in the Business Analytics Request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch revenue for each product category
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([order details].UnitPrice * [order details].Quantity * 
           (1 - [order details].Discount)) AS total_revenue 
FROM [order details] 
JOIN products ON [order details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName 
ORDER BY total_revenue DESC 
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df_revenue = execute_sql_query(sql_query)

# Visualize the total revenue for each category using a bar chart
fig = px.bar(df_revenue, 
             x='CategoryName', 
             y='total_revenue', 
             title='Total Revenue by Product Category', 
             labels={'CategoryName': 'Product Category', 'total_revenue': 'Total Revenue'},
             template='plotly_dark')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly calculates the total revenue per product category using a SQL query, similar to the reference implementation. It joins the necessary tables and aggregates revenue by category. Although it uses 'CategoryName' instead of 'CategoryID', this change is valid and helpful for visualization. Furthermore, it generates a bar chart displaying total revenue by product category, fulfilling the visualization requirement of the task. The essentials of the requested analysis and visualization logic are maintained.",Finetuned
"Which suppliers have delivered discontinued products, and can you visualize the findings using a bar chart to highlight the number of discontinued products delivered by each supplier?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to identify suppliers that delivered discontinued products
sql_query = """"""
SELECT suppliers.CompanyName, COUNT(products.ProductID) as DiscontinuedProductCount
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
WHERE products.Discontinued = 1
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query and retrieve the results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of discontinued products per supplier
fig = px.bar(
    df,
    x='CompanyName',
    y='DiscontinuedProductCount',
    title='Number of Discontinued Products Delivered by Each Supplier',
    labels={'CompanyName': 'Supplier', 'DiscontinuedProductCount': 'Discontinued Products Delivered'},
    template='plotly_dark'
)

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(p.ProductID) AS DiscontinuedCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.Discontinued = 1
GROUP BY s.SupplierID, s.CompanyName
""""""
data = execute_sql_query(sql_query)

fig = px.bar(data, x='CompanyName', y='DiscontinuedCount', title='Discontinued Products Delivered by Suppliers', 
             labels={'CompanyName': 'Supplier', 'DiscontinuedCount': 'Number of Discontinued Products'})
show_to_user(fig)
```","The input Python code does not join with the 'Order Details' table. This could mean that it counts discontinued products that may not have been delivered. The reference implementation counts only the discontinued products that were actually delivered, as indicated by the presence of corresponding entries in the 'Order Details' table. This is crucial to accurately answering the business question about deliveries.","```python
import plotly.express as px
import pandas as pd

# SQL query to find suppliers with discontinued products
sql_query = """"""
SELECT s.SupplierID, s.CompanyName 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.Discontinued = 1;
""""""

# Execute the SQL query and store the result in a DataFrame
df_suppliers = execute_sql_query(sql_query)

# Count the number of discontinued products by each supplier
discontinued_counts = df_suppliers['CompanyName'].value_counts().reset_index(name='ProductCount')
discontinued_counts.columns = ['CompanyName', 'ProductCount']

# Create a bar chart to visualize the number of discontinued products delivered by each supplier
fig = px.bar(discontinued_counts, x='CompanyName', y='ProductCount', 
             title='Number of Discontinued Products by Supplier',
             labels={'ProductCount': 'Number of Discontinued Products', 'CompanyName': 'Supplier'})

# Display the bar chart
show_to_user(fig)
```","The input Python code is incorrect. It doesn't account for counting orders of discontinued products. The reference implementation joins 'Order Details' table to ensure only delivered products are considered, while the input code only checks if products are discontinued without verifying delivery.",None
"What is the revenue generated from each product, and can it be visualized in a bar chart to compare the revenues effectively?","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch product revenue details
sql_query = '''
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS Revenue 
FROM 
    products p 
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY 
    p.ProductID, p.ProductName;
'''

# Execute the SQL query
revenue_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the revenue for each product
fig = px.bar(revenue_df, x='ProductName', y='Revenue', title='Revenue by Product', labels={'Revenue': 'Revenue ($)', 'ProductName': 'Product Name'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS Revenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='Revenue', 
             title='Revenue Generated from Each Product', 
             labels={'Revenue': 'Total Revenue', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code calculates revenue differently by including a discount factor 'od.Discount'. The request did not specify including discounts, and this is a deviation from the reference logic.","```python
import pandas as pd
import plotly.express as px

# Assume this is a utility function provided in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is supposed to execute the given SQL and return a DataFrame
    pass

def show_to_user(data):
    # This function displays the data or visualizations to the user
    pass

# SQL Query to get revenue per product
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) as Revenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute SQL query and get data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='Revenue', title='Revenue by Product')

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly fetches the revenue for each product using an SQL query, groups by ProductName, and calculates the revenue in the same manner as the reference implementation. It uses Plotly to create a bar chart for visualization, aligning with the business analytics request. The only notable difference is the omission of the ProductID in the SQL query of the input code, which is not essential for generating the required revenue comparison chart.",Finetuned
"How many products are currently being discontinued, and can you provide a bar chart to visualize the number of discontinued products by category?","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the count of discontinued products by category
sql_query = """"""
SELECT CategoryName, COUNT(*) as DiscontinuedCount
FROM products
JOIN categories ON products.CategoryID = categories.CategoryID
WHERE Discontinued = 1
GROUP BY CategoryName
""""""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(discontinued_products_df, x='CategoryName', y='DiscontinuedCount',
             title='Number of Discontinued Products by Category',
             labels={'DiscontinuedCount': 'Number of Discontinued Products', 'CategoryName': 'Category'})

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CategoryID, COUNT(*) AS DiscontinuedCount
FROM products
WHERE Discontinued = 1
GROUP BY CategoryID
""""""

discontinued_products = execute_sql_query(sql_query)

total_discontinued = discontinued_products['DiscontinuedCount'].sum()

fig = px.bar(discontinued_products, x='CategoryID', y='DiscontinuedCount', title='Number of Discontinued Products by Category')
show_to_user(fig)

total_discontinued
```","The input code does not join the products table with the categories table to get the category names. It only groups by CategoryID and not by CategoryName. Additionally, it does not provide the number of discontinued products by category name as requested, and it sums up all discontinued products instead of displaying them by category.","
import pandas as pd
import plotly.express as px

# Utility function to execute SQL and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Implement the actual logic 
    # to execute the SQL query and return a pandas DataFrame
    pass

# Utility function to display data or a figure
def show_to_user(data):
    # Placeholder function: Implement the actual logic 
    # to display the data or figure to the user
    pass

# SQL query to get the number of discontinued products by category
sql_query = ""SELECT Category, COUNT(*) as Discontinued_Products FROM products WHERE Discontinued = 1 GROUP BY Category;""

# Execute the SQL query and get the result in a DataFrame
discontinued_products_df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the number of discontinued products by category
fig = px.bar(discontinued_products_df, x='Category', y='Discontinued_Products', 
             title='Discontinued Products by Category',
             labels={'Category': 'Product Category', 'Discontinued_Products': 'Number of Discontinued Products'})

# Show the bar chart to the user
show_to_user(fig)
","The input code implementation is incorrect because the SQL query is different from the reference. The input code uses 'Category' instead of 'CategoryName' and does not include the JOIN with the 'categories' table, which is crucial to get the correct category names. This could lead to incorrect results if 'Category' is not a valid field in the 'products' table. Therefore, the logic deviates from the reference implementation.",None
"What is the average shipping cost per order for each shipper, and can you provide a bar chart to visualize the comparison?","```python
import plotly.express as px
import pandas as pd

# SQL query provided
sql_query = """"""
SELECT shippers.CompanyName, AVG(orders.Freight) AS avg_shipping_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

# Execute the SQL query to get the DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average shipping cost per shipper
fig = px.bar(df,
             x='CompanyName',
             y='avg_shipping_cost',
             title='Average Shipping Cost per Order for Each Shipper',
             labels={'avg_shipping_cost': 'Average Shipping Cost', 'CompanyName': 'Shipper'},
             text='avg_shipping_cost'
            )

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName AS shipper_name, AVG(orders.Freight) AS average_shipping_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

shipping_costs_df = execute_sql_query(sql_query)

fig = px.bar(shipping_costs_df, x='shipper_name', y='average_shipping_cost', 
             title='Average Shipping Cost per Order by Shipper', 
             labels={'average_shipping_cost': 'Average Shipping Cost', 'shipper_name': 'Shipper'})

show_to_user(fig)
```","The provided Python code correctly implements the business analytics request. Both the reference and input code execute a similar SQL query to calculate the average shipping cost per order for each shipper by joining the 'orders' and 'shippers' tables and grouping by 'CompanyName'. The input code then uses Plotly Express to create a bar chart with appropriate titles and labels, just like the reference. The small differences, such as variable names and slight changes in wording for labels and titles, do not affect the correctness or logic alignment between the two implementations.","```python
import plotly.express as px

# SQL query
sql_query = """"""
SELECT shippers.CompanyName, AVG(orders.Freight) AS AverageFreightCost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='AverageFreightCost', 
             title='Average Shipping Cost per Order by Shipper',
             labels={'CompanyName': 'Shipper', 'AverageFreightCost': 'Average Freight Cost ($)'})

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly calculates the average shipping cost per order for each shipper using a SQL query and plots a bar chart to visualize it. The logic closely matches the reference implementation: it joins the orders and shippers tables, groups by the company name, calculates the average freight, and uses Plotly Express to create a bar chart. Differences in variable names and minor label changes do not impact the correctness of the code.",both
"Which category has the longest list of discontinued products, and can you provide a bar chart to visualize the results?","```python
import plotly.express as px
import pandas as pd

# SQL Query to find the category with the longest list of discontinued products
sql_query = """"""
SELECT c.CategoryID, c.CategoryName, COUNT(p.ProductID) AS DiscontinuedCount
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
WHERE p.Discontinued = 1
GROUP BY c.CategoryID
ORDER BY DiscontinuedCount DESC;
""""""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Find the category with the maximum count of discontinued products
max_discontinued_category_df = discontinued_products_df.nlargest(1, 'DiscontinuedCount')

# Create a bar chart to visualize the results
fig = px.bar(discontinued_products_df, x='CategoryName', y='DiscontinuedCount',
             title='Number of Discontinued Products by Category',
             labels={'DiscontinuedCount': 'Number of Discontinued Products', 'CategoryName': 'Category'},
             color='DiscontinuedCount')

# Show the result
show_to_user(fig)
show_to_user(max_discontinued_category_df[['CategoryName', 'DiscontinuedCount']])
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, COUNT(*) AS DiscontinuedCount
FROM products p
WHERE p.Discontinued = 1
GROUP BY p.CategoryID
ORDER BY DiscontinuedCount DESC
LIMIT 10
""""""

discontinued_products = execute_sql_query(sql_query)

fig = px.bar(discontinued_products, x='CategoryID', y='DiscontinuedCount', 
             title='Count of Discontinued Products by Category',
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Discontinued Products Count'})

show_to_user(fig)
```","The input code does not meet the business analytics request as it does not identify which category has the longest list of discontinued products, nor does it display the top category. Additionally, it only selects the top 10 categories and does not retrieve category names, which are necessary to fulfill the request. The input code also does not align with the reference logic of showing the maximum category and displaying its name.","Sure! To tackle this request, we'll proceed with the following steps:

1. Run the SQL query to fetch the data.
2. Visualize the results using a bar chart.

Here’s how we’ll do it in Python:

```python
import pandas as pd
import plotly.express as px

# SQL query to find the number of discontinued products per category
sql_query = """"""
SELECT products.CategoryID, COUNT(*) AS DiscontinuedCount 
FROM products 
WHERE products.Discontinued = 1 
GROUP BY products.CategoryID 
ORDER BY DiscontinuedCount DESC
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the categories with the most discontinued products
fig = px.bar(df, x='CategoryID', y='DiscontinuedCount', 
             title='Number of Discontinued Products by Category',
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Number of Discontinued Products'})

# Display the bar chart to the user
show_to_user(fig)
```

### Explanation:

- The SQL query retrieves categories with the count of discontinued products, sorted by the count in descending order.
- After executing the query using `execute_sql_query`, the result is stored in a DataFrame.
- We utilize `plotly.express` to create a bar chart (ensuring that the x-axis represents category IDs and the y-axis represents the count of discontinued products).
- Finally, the bar chart is displayed using the `show_to_user` function.","The input code does not join the products and categories tables to retrieve the CategoryName, which limits the analysis to CategoryID only. Additionally, it does not identify the category with the longest list of discontinued products or present it explicitly. The reference implementation joins these tables and provides both CategoryName and the detailed category with the most discontinued products, which the input lacks.",None
"What is the average unit price of all products, and can you provide a bar chart to visualize the distribution of unit prices across different product categories?","```python
import plotly.express as px
import pandas as pd

# SQL query to get the average unit price
sql_query_avg_price = ""SELECT AVG(UnitPrice) AS AverageUnitPrice FROM products""
# SQL query to get all unit prices for each product category
sql_query_prices_by_category = """"""
SELECT ProductCategory, UnitPrice 
FROM products
""""""

# Execute SQL queries
average_price_df = execute_sql_query(sql_query_avg_price)
prices_by_category_df = execute_sql_query(sql_query_prices_by_category)

# Calculate the average unit price from the query result
average_unit_price = average_price_df['AverageUnitPrice'].iloc[0]

# Display the average unit price to the user
show_to_user(pd.DataFrame({'Average Unit Price': [average_unit_price]}))

# Create a bar chart to visualize the distribution of unit prices across product categories
fig = px.bar(prices_by_category_df, 
             x='ProductCategory', 
             y='UnitPrice', 
             title='Distribution of Unit Prices Across Product Categories',
             labels={'UnitPrice': 'Unit Price', 'ProductCategory': 'Product Category'},
             barmode='group')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID, 
    AVG(p.UnitPrice) AS AverageUnitPrice
FROM 
    products p
GROUP BY 
    p.CategoryID
""""""

average_unit_price_df = execute_sql_query(sql_query)

average_unit_price = average_unit_price_df['AverageUnitPrice'].mean()

fig = px.bar(average_unit_price_df, 
             x='CategoryID', 
             y='AverageUnitPrice',
             title='Average Unit Price by Product Category',
             labels={'CategoryID': 'Product Category', 'AverageUnitPrice': 'Average Unit Price'})

show_to_user(fig)

average_unit_price
```","The input code calculates the average unit price per category and visualizes it, while the reference calculates the global average unit price and visualizes individual prices by category. These two approaches provide different insights and do not adhere to the same analytic rationale.","```python
import pandas as pd
import plotly.express as px

# Placeholder function definition for execute_sql_query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation that runs the SQL and returns a DataFrame
    pass

# Placeholder function definition for show_to_user
def show_to_user(data):
    # Placeholder for actual implementation to display data
    pass

# Execute the SQL query to get the average unit price of all products
average_price_query = ""SELECT AVG(UnitPrice) AS AvgUnitPrice FROM products;""
average_price_df = execute_sql_query(average_price_query)

# Display the average unit price
show_to_user(average_price_df)

# Query to get unit prices across different product categories
# Assuming 'ProductCategory' is a valid column in the 'products' table
unit_prices_query = """"""
SELECT ProductCategory, UnitPrice
FROM products;
""""""
unit_prices_df = execute_sql_query(unit_prices_query)

# Create a bar chart to visualize the distribution of unit prices across different product categories
fig = px.bar(unit_prices_df, x='ProductCategory', y='UnitPrice', title='Distribution of Unit Prices by Product Category')

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the requirements by executing SQL queries to obtain the average unit price and the unit prices by product category. The calculated average unit price is displayed using the placeholder 'show_to_user' function. It also uses Plotly to create a bar chart for the distribution of unit prices across product categories, which is consistent with the reference implementation. The logical steps and functionality closely match the reference code.",Finetuned
"Which customers have placed orders with the highest discounts, and can you provide a bar chart to visualize the top customer discount recipients?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch customer discounts
sql_query = """"""
SELECT o.CustomerID, MAX(od.Discount) AS MaxDiscount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.CustomerID 
ORDER BY MaxDiscount DESC;
""""""

# Execute the SQL query
customer_discounts_df = execute_sql_query(sql_query)

# Filter the top customer discount recipients (e.g., top 10)
top_customers_df = customer_discounts_df.head(10)

# Create a bar chart using Plotly
fig = px.bar(
    top_customers_df, 
    x='CustomerID', 
    y='MaxDiscount', 
    title='Top Customer Discount Recipients',
    labels={'CustomerID': 'Customer ID', 'MaxDiscount': 'Maximum Discount'}
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.CustomerID, SUM(od.Discount) as TotalDiscount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID
ORDER BY TotalDiscount DESC
LIMIT 10
""""""

top_customers_discounts = execute_sql_query(sql_query)

fig = px.bar(top_customers_discounts, x='CustomerID', y='TotalDiscount', 
             title='Top Customers with Highest Discounts', 
             labels={'CustomerID': 'Customer ID', 'TotalDiscount': 'Total Discount'})
show_to_user(fig)
```","The input code uses `SUM(od.Discount)` to calculate `TotalDiscount` for each customer, which is different from the reference code that uses `MAX(od.Discount)` to find the highest single discount per customer. Therefore, the input code does not adhere to the same logic as the reference implementation.","
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are predefined utilities

# SQL query to get customers with the highest discounts
sql_query = """"""
SELECT 
    customers.CustomerID, 
    AVG([Order Details].Discount) AS AverageDiscount 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.CustomerID 
ORDER BY 
    AverageDiscount DESC;
""""""

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    discount_data, 
    x='CustomerID', 
    y='AverageDiscount', 
    title='Top Customers by Average Discount',
    labels={'CustomerID': 'Customer ID', 'AverageDiscount': 'Average Discount'}
)

# Display the bar chart
show_to_user(fig)
","The input code calculates the 'AverageDiscount' for each customer instead of the 'MaxDiscount' as in the reference code. The business request is to identify customers with the highest discounts, which aligns with using 'MAX' rather than 'AVG'. The input code also does not limit the number of top customers returned, whereas the reference code fetches the top 10.",None
"Which products have sales exceeding $5000, and can you provide a bar chart to visualize these products and their sales figures?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductName, SUM([Order Details].Quantity * [Order Details].UnitPrice) as TotalSales
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY ProductName 
HAVING SUM([Order Details].Quantity * [Order Details].UnitPrice) > 5000;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalSales', title='Products with Sales Exceeding $5000')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
HAVING SUM(od.Quantity * od.UnitPrice) > 5000
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Products with Sales Exceeding $5000')
show_to_user(fig)
```","The input code correctly implements the business analytics request. It calculates total sales per product and filters for products with sales exceeding $5000, similar to the reference implementation. Both codes group by ProductName, compute total sales, and use Plotly to visualize the results.","
```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
HAVING TotalSales > 5000;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize products with sales over $5000
fig = px.bar(df, x='ProductName', y='TotalSales', title='Products with Sales Over $5000')

# Show the visualization to the user
show_to_user(fig)
```","The input code achieves the same objective as the reference code by selecting products with sales exceeding $5000. Both implementations create a bar chart using Plotly to visualize the products and their sales figures. The logic, including the SQL query, aligns with that of the reference, considering the discount in the input code which doesn't alter the fundamental requirement of identifying products with total sales over $5000.",both
Calculate the total discount given on products sold in the last month and visualize the data with a bar chart showing discounts across different product categories.,"```python
import pandas as pd
import plotly.express as px

# Execute SQL query to get the discounts data
sql_query = '''
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS TotalDiscount, 
    products.CategoryID
FROM 
    [Order Details]
JOIN 
    products ON [Order Details].ProductID = products.ProductID
WHERE 
    OrderID IN (SELECT OrderID FROM orders WHERE OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 MONTH) AND CURDATE())
GROUP BY 
    products.CategoryID;
'''

def execute_sql_query(sql_query: str):
    # Dummy implementation: Replace it with actual logic to execute the SQL query and return a DataFrame.
    # In a real environment, this would utilize a database connection to fetch data.
    return pd.DataFrame({
        'CategoryID': [1, 2, 3],
        'TotalDiscount': [500, 300, 200]
    })

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Fetch data using the provided execute_sql_query function
discount_data = execute_sql_query(sql_query)

# Visualize the data using Plotly
fig = px.bar(discount_data, x='CategoryID', y='TotalDiscount', 
             title='Total Discount by Product Category in the Last Month',
             labels={'CategoryID': 'Product Category', 'TotalDiscount': 'Total Discount'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Get the first and last date of the last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to calculate total discount per product category for the last month
sql_query = f""""""
SELECT 
    p.CategoryID,
    SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    od.OrderID IN (
        SELECT OrderID FROM orders 
        WHERE OrderDate >= '{first_day_last_month}' 
        AND OrderDate <= '{last_day_last_month}'
    )
GROUP BY 
    p.CategoryID
""""""

# Execute the query and load the data into a DataFrame
discount_data = execute_sql_query(sql_query)

# Visualize the data with a bar chart
fig = px.bar(discount_data, x='CategoryID', y='TotalDiscount',
             title='Total Discounts Across Product Categories in Last Month',
             labels={'CategoryID': 'Product Category', 'TotalDiscount': 'Total Discount'})
show_to_user(fig)
```","The input Python code correctly defines the SQL query to calculate the total discount per product category for the last month, similar to the reference implementation. The logic to determine the date range for the last month is accurate. Both implementations group data by product category and sum the discounts. The visualization with Plotly is consistent in both, displaying a bar chart of total discounts by product category. The differences in SQL syntax detail do not affect the overall logic or correctness of the task request.","```python
import pandas as pd
import plotly.express as px

# Define the utility function for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Replace this with actual database connection and query execution
    pass

# Define the utility function for showing outputs to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch total discount by product category for the last month
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
WHERE [Order Details].OrderID IN (
    SELECT OrderID FROM orders 
    WHERE MONTH(OrderDate) = MONTH(CURDATE() - INTERVAL 1 MONTH)
    AND YEAR(OrderDate) = YEAR(CURDATE() - INTERVAL 1 MONTH)
)
GROUP BY categories.CategoryName;
""""""

# Execute the SQL query and store the result in a DataFrame
df_discounts = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_discounts, x='CategoryName', y='TotalDiscount', title='Total Discount by Product Category for Last Month')

# Show the bar chart to the user
show_to_user(fig)
```","The input code differs from the reference code in the SQL query logic. The input code uses MONTH() and YEAR() functions to filter last month's data, which could fail at year change, while the reference code uses DATE_SUB() and CURDATE() for true month comparison. Additionally, the input code joins with categories to fetch CategoryName, while the reference uses CategoryID. This difference could affect categorization and data accuracy, particularly if the mapping between CategoryID and CategoryName isn't one-to-one or if CategoryID is essential for analysis.",Base
"Which company name appears most frequently in the customer database, and can you provide a bar chart to visualize the frequency distribution?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CompanyName, COUNT(*) AS Frequency 
FROM customers 
GROUP BY CompanyName 
ORDER BY Frequency DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='Frequency', title='Frequency Distribution of Company Names')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CompanyName, COUNT(*) AS Frequency
FROM customers
GROUP BY CompanyName
ORDER BY Frequency DESC
LIMIT 10
""""""
data = execute_sql_query(sql_query)

fig = px.bar(data, x='CompanyName', y='Frequency', title='Company Name Frequency Distribution')
show_to_user(fig)
```","The provided code includes a LIMIT 10 clause in the SQL query, which restricts the results to only the top 10 companies by frequency. This makes the frequency distribution incomplete compared to the reference implementation, which returns all companies sorted by frequency. Therefore, the code does not fully adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to find the frequency of each company
sql_query = """"""
SELECT CompanyName, COUNT(CompanyName) AS Frequency 
FROM customers 
GROUP BY CompanyName 
ORDER BY Frequency DESC;
""""""

# Execute the SQL query
company_frequency_df = execute_sql_query(sql_query)

# Generate the bar chart for frequency distribution
fig = px.bar(company_frequency_df, x='CompanyName', y='Frequency',
             title='Frequency Distribution of Company Names',
             labels={'CompanyName': 'Company Name', 'Frequency': 'Frequency'},
             text='Frequency')

# Customize the chart for better visualization
fig.update_traces(textposition='outside')
fig.update_layout(bargap=0.2)

# Display the chart
show_to_user(fig)
```","The input code fulfills the business analytics request by executing an SQL query to calculate the frequency of each company name in the 'customers' table and then visualizes it using a Plotly bar chart. It follows the same logical steps as the reference implementation: executing a similar SQL query, grouping by 'CompanyName', ordering by frequency, and creating a bar chart to visualize the frequency distribution. The additional plotting enhancements in the input code do not affect the correctness of the result.",Finetuned
"What are the top 5 cities by number of shipments, and can you provide a bar chart to visualize the results?","```python
import plotly.express as px

# SQL query to get the top 5 cities by number of shipments
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS Shipments 
FROM orders 
GROUP BY ShipCity 
ORDER BY Shipments DESC 
LIMIT 5
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 5 cities by shipments
fig = px.bar(df, x='ShipCity', y='Shipments', title='Top 5 Cities by Number of Shipments')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipCity
ORDER BY ShipmentCount DESC
LIMIT 5
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='ShipCity', y='ShipmentCount', title='Top 5 Cities by Number of Shipments')
show_to_user(fig)
```",The input Python code correctly follows the logic of the reference implementation. It executes a SQL query to retrieve the top 5 cities by number of shipments and uses Plotly to create and display a bar chart. The differences in variable names ('Shipments' vs 'ShipmentCount') do not affect the core logic or the outcome.,"```python
import pandas as pd
import plotly.express as px

# Given the SQL query
sql_query = """"""
SELECT o.ShipCity, COUNT(*) AS ShipmentCount
FROM orders o
GROUP BY o.ShipCity
ORDER BY ShipmentCount DESC
LIMIT 5;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_cities_df, x='ShipCity', y='ShipmentCount',
             title='Top 5 Cities by Number of Shipments',
             labels={'ShipCity': 'City', 'ShipmentCount': 'Number of Shipments'})

# Display the bar chart to the user
show_to_user(fig)
```",Both the reference and input implementations follow the same logic: they execute a SQL query to fetch the top 5 cities by the number of shipments and use Plotly to create a bar chart. The differences in column naming ('Shipments' vs 'ShipmentCount') and label attributes don't affect the correctness in terms of logic and output.,both
What is the stock-to-sale ratio for each product? Include a bar chart to visualize the ratios across different products.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are already defined in the environment

# SQL query to get the stock-to-sale ratio for each product
sql_query = """"""
SELECT ProductName, UnitsInStock * 1.0 / SUM([Order Details].Quantity) AS StockToSaleRatio 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY ProductName;
""""""

# Execute SQL query and load the result into a DataFrame
df = execute_sql_query(sql_query)

# Check if DataFrame is not empty
if not df.empty:
    # Generate a bar chart to visualize the stock-to-sale ratio for each product
    fig = px.bar(df, x='ProductName', y='StockToSaleRatio', 
                 title='Stock-to-Sale Ratio by Product', 
                 labels={'StockToSaleRatio': 'Stock-to-Sale Ratio', 'ProductName': 'Product Name'})
    # Show the bar chart to the user
    show_to_user(fig)
else:
    print(""No data available to display"")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity) AS TotalSales, 
       p.UnitsInStock
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

product_data = execute_sql_query(sql_query)

product_data['StockToSaleRatio'] = product_data['UnitsInStock'] / product_data['TotalSales'].replace(0, pd.NA)
fig = px.bar(product_data, x='ProductName', y='StockToSaleRatio', 
              title='Stock-to-Sale Ratio for Each Product', 
              labels={'StockToSaleRatio': 'Stock-to-Sale Ratio', 
                      'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code uses a LEFT JOIN, which includes products without sales, unlike the INNER JOIN in the reference which only includes products with sales. This results in a division by zero situation handled by replacing zeros with pd.NA, which is not addressed in the reference. Furthermore, the reference code calculates the StockToSaleRatio directly in the SQL query, while the input code calculates it in Python, leading to potential differences in handling missing or zero sales data.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT P.ProductID, 
       (P.UnitsInStock / P.UnitsOnOrder) AS StockToSaleRatio 
FROM products P;
""""""

# Execute the SQL query
data_frame = execute_sql_query(sql_query)

# Generate a bar chart for the stock-to-sale ratio
bar_chart = px.bar(data_frame, 
                   x='ProductID', 
                   y='StockToSaleRatio', 
                   title='Stock to Sale Ratio for Each Product')

# Display the bar chart using the utility function
show_to_user(bar_chart)
```","The input code calculates the stock-to-sale ratio using 'UnitsInStock / UnitsOnOrder', which is incorrect according to the request. The reference code calculates the ratio as 'UnitsInStock / SUM(Order Details.Quantity)', considering sales from order details. Moreover, the input code does not join the 'products' table with 'Order Details' to include sales information needed for the correct ratio calculation.",None
Identify products with the highest discount offered historically and create a visualization to compare these discounts.,"```python
import plotly.express as px
import pandas as pd

# Utility function substitutes
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function: Replace with actual database query execution
    data = {
        'ProductID': [1, 2, 3],
        'MaxDiscount': [0.30, 0.25, 0.15]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock function: Replace with actual display logic
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query as per the request
sql_query = """"""
SELECT ProductID, MAX(Discount) AS MaxDiscount
FROM [Order Details]
GROUP BY ProductID
ORDER BY MaxDiscount DESC
""""""

# Execute the query and get results as a DataFrame
discounts_df = execute_sql_query(sql_query)

# Create a bar chart comparing the discounts
fig = px.bar(discounts_df, x='ProductID', y='MaxDiscount', 
             title='Highest Discounts Offered by Product',
             labels={'ProductID': 'Product ID', 'MaxDiscount': 'Maximum Discount'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Discount) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalDiscount DESC
LIMIT 10;
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductName', y='TotalDiscount', 
             title='Top 10 Products with Highest Historical Discounts',
             labels={'TotalDiscount': 'Total Discount', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input Python code calculates 'TotalDiscount' by summing all discounts for each product, whereas the reference implementation finds the 'MaxDiscount' by selecting the maximum discount a product has ever offered. Consequently, the input code does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Sample utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would interface with the database to execute the query.
    # Here, it is a placeholder.
    pass

# Sample utility function to display data or visualization to the user
def show_to_user(data):
    # This function would handle displaying a DataFrame or Plotly figure.
    # Here, it is a placeholder.
    pass

# SQL query to find products with the highest historical discounts
sql_query = """"""
SELECT p.ProductName, AVG(od.Discount) AS HistoricalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY HistoricalDiscount DESC;
""""""

# Execute the query and get the result into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the discounts
fig = px.bar(df, x='ProductName', y='HistoricalDiscount',
             title='Products with Highest Historical Discounts',
             labels={'HistoricalDiscount': 'Average Discount', 'ProductName': 'Product Name'})

# Display the figure
show_to_user(fig)
```","The input code calculates the average discount per product (`AVG(od.Discount)`), whereas the reference code calculates the maximum discount (`MAX(Discount)`) historically given to each product. This results in different metrics being used; thus, the logic differs. Additionally, the input code includes a join with the `products` table to retrieve `ProductName`, while the reference code directly uses `ProductID` from `[Order Details]`.",None
"Evaluate the impact of hiring date on the sales performance, and provide a data visualization to illustrate the relationship.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT employees.EmployeeID, 
       YEAR(employees.HireDate) AS HireYear, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, 
         YEAR(employees.HireDate)
""""""

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Code to connect to database and execute query
    # For example purposes, return an empty DataFrame
    return pd.DataFrame()

# Fetch data using the provided query
data = execute_sql_query(sql_query)

# Data analysis - Evaluate TotalSales by HireYear
if not data.empty:
    sales_by_hire_year = data.groupby('HireYear')['TotalSales'].sum().reset_index()

    # Visualization using Plotly
    fig = px.line(sales_by_hire_year, x='HireYear', y='TotalSales', 
                  title='Impact of Hiring Year on Sales Performance',
                  labels={'HireYear': 'Year of Hiring', 'TotalSales': 'Total Sales'})

    # Display the visualization
    show_to_user(fig)
else:
    print(""No data available to display"");
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.HireDate, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.HireDate
ORDER BY e.HireDate;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='HireDate', y='TotalSales', title='Impact of Hiring Date on Sales Performance')
show_to_user(fig)
```","The input code aggregates sales by hiring date for each specific date, while the reference code groups sales by the hiring year. This means the reference implementation evaluates the yearly impact of hiring on sales, whereas the input code provides daily granularity, leading to different analysis outcomes and possibly a more complex visualization. To match the reference logic, the input code should extract the year from the HireDate and group by that year instead.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get the data
sql_query = """"""
SELECT  
    employees.HireDate, 
    employees.EmployeeID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS SalesPerformance
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    employees.HireDate, employees.EmployeeID
""""""

# Function to execute the SQL query and fetch the results
def execute_sql_query(sql_query: str):
    # Implement your database connection and fetching logic here
    # For now, assume it returns a DataFrame.
    # Placeholder: return pd.DataFrame(data) after executing the query
    pass

# Execute the SQL query
data = execute_sql_query(sql_query)

# Data processing: Aggregate data by HireDate for overall SalesPerformance
aggregated_data = data.groupby('HireDate', as_index=False)['SalesPerformance'].sum()

# Create a line chart to visualize the relationship between HireDate and SalesPerformance
fig = px.line(aggregated_data, x='HireDate', y='SalesPerformance', title='Impact of Hire Date on Sales Performance',
              labels={'HireDate': 'Hire Date', 'SalesPerformance': 'Sales Performance'})

# Show the visualization to the user
show_to_user(fig)
```",The input code aggregates sales performance by the precise 'HireDate' instead of the 'HireYear' as in the reference. This could result in a different aggregation level and visualization output. The correct approach should match the logic of aggregating sales by the year of hiring as seen in the reference code.,None
Determine the average unit price of products supplied by each supplier and visualize the results with a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL queries and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to connect to the database,
    # execute the SQL query, and return the result as a DataFrame.
    pass

# Utility function to display data or visualization
def show_to_user(data):
    # This function should be implemented to either print a DataFrame
    # or display a Plotly figure.
    pass

# SQL query to get the average unit price of products by supplier
sql_query = """"""
SELECT s.SupplierID, AVG(p.UnitPrice) AS AvgUnitPrice
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID;
""""""

# Execute the SQL query to get data into a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='SupplierID', y='AvgUnitPrice',
             title='Average Unit Price by Supplier',
             labels={'SupplierID': 'Supplier ID', 'AvgUnitPrice': 'Average Unit Price'})

# Show the resulting bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(p.UnitPrice) AS AverageUnitPrice
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
""""""

average_unit_price_df = execute_sql_query(sql_query)

fig = px.bar(average_unit_price_df, x='CompanyName', y='AverageUnitPrice', 
             title='Average Unit Price of Products Supplied by Each Supplier',
             labels={'CompanyName': 'Supplier', 'AverageUnitPrice': 'Average Unit Price'})
show_to_user(fig)
```","The input code delivers the same business analytics result as the reference implementation. The SQL query structure is similar, calculating the average unit price of products by supplier. The reference uses 'SupplierID', while the input code uses 'CompanyName', which is acceptable as both identify the supplier. The data visualization aspect is consistent, using Plotly to create a bar chart with appropriate labels and titles. Thus, the code adheres to the specified business request and logic.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.SupplierID, AVG(products.UnitPrice) AS AverageUnitPrice 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.SupplierID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AverageUnitPrice', title='Average Unit Price by Supplier')

# Display the figure to the user
show_to_user(fig)
```","The input code correctly implements the requested business analytics task. It calculates the average unit price of products supplied by each supplier using an SQL query that matches the logic of the reference code. The resulting data is then visualized with a bar chart using Plotly, following the same steps as the reference implementation.",both
Identify the top 5 suppliers by total sales revenue generated and provide a bar chart visualization to compare their sales revenue.,"```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Here we assume the connection and execution of the query
    # This is a stub and should be replaced with the actual implementation
    pass

# Function to display data or visualization
def show_to_user(data):
    # Here we assume the display of data or visualization
    # This is a stub and should be replaced with the actual implementation
    pass

# SQL query to get the top 5 suppliers by total sales
sql_query = """"""
SELECT suppliers.SupplierID, CompanyName, 
SUM([Order Details].UnitPrice * Quantity * (1 - Discount)) AS TotalSales 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, CompanyName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the data as a DataFrame
top_suppliers_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    top_suppliers_df,
    x='CompanyName',
    y='TotalSales',
    title='Top 5 Suppliers by Total Sales Revenue',
    labels={'TotalSales': 'Total Sales Revenue', 'CompanyName': 'Supplier'},
    text_auto=True
)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalSales DESC
LIMIT 5
""""""

top_suppliers_df = execute_sql_query(sql_query)

fig = px.bar(top_suppliers_df, x='CompanyName', y='TotalSales', 
             title='Top 5 Suppliers by Total Sales Revenue',
             labels={'TotalSales': 'Total Sales Revenue', 'CompanyName': 'Supplier Company'})
show_to_user(fig)
```","The input code correctly follows the business analytics request and logic of the reference implementation. It executes a SQL query to select the top 5 suppliers by total sales revenue, calculates 'TotalSales' using the same formula, and uses similar SQL JOINs to relate tables. The bar chart is generated using Plotly with equivalent parameters for axis labels and title, fulfilling the visualization requirement. The differences in variable naming and minor label variations do not affect the overall correctness.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the top 5 suppliers by total sales revenue
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to represent SQL execution
    # This should be implemented to connect to a database and return a result DataFrame
    pass

# Fetch the results
df = execute_sql_query(sql_query)

# Generate a bar chart to compare the top 5 suppliers by total sales revenue
fig = px.bar(df, x='CompanyName', y='TotalRevenue', 
             title='Top 5 Suppliers by Total Sales Revenue',
             labels={'CompanyName': 'Company Name', 'TotalRevenue': 'Total Revenue ($)'})

# Display the bar chart
def show_to_user(data):
    # Placeholder function to represent display to user
    # This should be used to present pandas DataFrame or Plotly figure
    pass

show_to_user(fig)
```","The provided code correctly implements the business logic to identify the top 5 suppliers by total sales revenue and provides a bar chart visualization. It follows the same logic as the reference implementation by computing the total sales from the 'Order Details' table, grouping by 'CompanyName' and ordering by 'TotalRevenue'. Both implementations correctly use Plotly for visualization and assume the SQL execution and display functions are implemented elsewhere.",both
How many orders were shipped via each shipping company? Include a bar chart to visualize the comparison.,"```python
import plotly.express as px
import pandas as pd


def execute_sql_query(sql_query: str):
    # This function is a placeholder. In practice, it would execute the SQL query 
    # and return a pandas DataFrame with the results.
    data = {
        'CompanyName': ['Shipper A', 'Shipper B', 'Shipper C'],
        'order_count': [100, 150, 75]
    }
    return pd.DataFrame(data)


def show_to_user(data):
    # This function is a placeholder. In practice, it would display the data 
    # or visualization to the user.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query
sql_query = """"""
SELECT shippers.CompanyName, COUNT(orders.OrderID) AS order_count 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='order_count', title='Orders Shipped via Each Shipping Company', labels={'order_count':'Order Count', 'CompanyName':'Shipping Company'})

# Show visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, COUNT(orders.OrderID) AS order_count
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

order_data = execute_sql_query(sql_query)

fig = px.bar(order_data, x='CompanyName', y='order_count', title='Orders Shipped via Each Shipping Company')
show_to_user(fig)
```","The provided code correctly executes the SQL query to count the number of orders shipped via each shipping company. It uses the same logic and structure as the reference code to join the 'orders' and 'shippers' tables, groups the results by 'CompanyName', and then creates a bar chart using Plotly for visualization. The minor differences, such as variable names, do not impact the correctness of the logic or outcome.","```python
import plotly.express as px

# SQL query to fetch the data
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount FROM orders GROUP BY ShipVia;
""""""

# Execute the SQL query using the provided utility function
data_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders shipped via each shipping company
fig = px.bar(data_df, x='ShipVia', y='OrderCount', title='Number of Orders by Shipping Company')

# Display the figure using the provided utility function
show_to_user(fig)
```","The input code uses 'ShipVia' without joining the 'shippers' table, so it lacks 'CompanyName' for proper labeling. Unlike the reference code, the input doesn't group by 'CompanyName', making it incomplete for the task. Additionally, it implies use of 'execute_sql_query' to return 'CompanyName', which isn't currently reflected in the input SQL or DataFrame structure.",Base
Identify the top 5 products with the highest sales performance based on quantity sold and present the results in a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductID, SUM(od.Quantity) AS TotalQuantitySold
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID
ORDER BY TotalQuantitySold DESC
LIMIT 5;
""""""

# Execute the SQL query and get the results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Here you should implement the actual database query execution
    # For this example, let's assume this function returns a DataFrame
    pass

# Plotly figure display utility
def show_to_user(data):
    # This function should already know how to display the data
    # For Plotly figures, assume it uses something like `figure.show()`
    pass

# Get the top 5 products by sales performance
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalQuantitySold', title='Top 5 Products by Quantity Sold')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 5;
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalQuantity', title='Top 5 Products by Quantity Sold')
show_to_user(fig)
```","The input code correctly follows the same logic as the reference implementation. It retrieves the top 5 products with the highest quantity sold. Although it includes ProductName in the query, which provides more context, this does not affect the correctness of the solution. The ordering, grouping, and plotting logic remain consistent with the reference implementation's objective to visualize the top 5 products by sales quantity.","```python
import pandas as pd
import plotly.express as px

# SQL query as provided
query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalQuantity DESC 
LIMIT 5;
""""""

# Utility function mocks
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would connect to a database and return the result as a DataFrame
    pass

def show_to_user(data):
    # This function would display the given data to the user
    pass

# Execute the SQL query to get the data
df = execute_sql_query(query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Top 5 Products by Quantity Sold')

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code is functionally equivalent to the reference implementation. Both queries select the ProductID and the total quantity sold, ordering by quantity with a limit of 5. The SQL structure and logic are the same. The data visualization and display parts also match the reference, using Plotly to create the bar chart and assuming a show function. The code fulfills the business analytics request effectively.",both
Determine the most common discount rates used and visualize the distribution with a histogram.,"
import plotly.express as px

# SQL query to get discount distribution
sql_query = """"""
SELECT Discount, COUNT(*) AS Count 
FROM [Order Details] 
GROUP BY Discount 
ORDER BY Discount;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
discount_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the discount distribution
fig = px.bar(discount_df, x='Discount', y='Count', title='Distribution of Discount Rates')

# Display the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Discount
FROM [Order Details]
WHERE Discount IS NOT NULL
""""""
discount_data = execute_sql_query(sql_query)

fig = px.histogram(discount_data, x='Discount', nbins=30, title='Distribution of Discount Rates')
show_to_user(fig)
```","The provided code correctly addresses the business analytics request by determining the distribution of discount rates and visualizing them. Although it uses a histogram instead of a bar chart, the visualization still effectively represents the distribution. Both implementations involve executing a SQL query to retrieve discount data and plotting the distribution, meeting the intent of the request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the frequency of each discount rate
sql_query = """"""
SELECT Discount, COUNT(*) AS DiscountFrequency 
FROM [Order Details] 
GROUP BY Discount 
ORDER BY DiscountFrequency DESC;
""""""

# Execute the SQL query to get the data
discount_data = execute_sql_query(sql_query)

# Create a histogram to visualize the distribution of discount rates
fig = px.histogram(discount_data, 
                   x='Discount', 
                   weights='DiscountFrequency',
                   title='Distribution of Discount Rates',
                   labels={'Discount': 'Discount Rate', 'DiscountFrequency': 'Frequency'})

# Display the histogram to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request by determining the most common discount rates and visualizing their distribution. While the input code uses a histogram and the reference code uses a bar chart, both visualizations effectively represent the frequency of discount rates. The SQL queries in both implementations group and count the discounts similarly, ensuring the same data is visualized. The input code's use of 'weights' in a histogram achieves the same outcome as the bar chart in the reference code, providing a correct visualization of discount distribution.",both
"Which shipping company has the highest average delay in delivery, and can you provide a bar chart to visualize the average delays by company?","```python
import plotly.express as px
import pandas as pd

# SQL query to retrieve average delay by shipping company
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, RequiredDate)) AS AverageDelay
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY ShipVia
ORDER BY AverageDelay DESC;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average delays by company
fig = px.bar(df, x='ShipVia', y='AverageDelay', title='Average Delivery Delay by Shipping Company')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, 
       AVG(DATEDIFF(ShippedDate, RequiredDate)) AS AverageDelay
FROM orders
GROUP BY ShipVia
ORDER BY AverageDelay DESC
""""""
average_delays_df = execute_sql_query(sql_query)

highest_delay_shipper = average_delays_df.iloc[0]

fig = px.bar(average_delays_df, 
             x='ShipVia', 
             y='AverageDelay', 
             title='Average Delay by Shipping Company', 
             labels={'ShipVia': 'Shipping Company', 'AverageDelay': 'Average Delay (Days)'})

show_to_user(fig)
```",The input code does not match the reference logic exactly. The missing clause 'WHERE ShippedDate > RequiredDate' in the SQL query allows orders that don't exceed the required delivery date to be included in the average delay computation. This results in incorrect computation of average delays.,"```python
import pandas as pd
import plotly.express as px

# Execute SQL query to fetch average delays by shipping company
sql_query = """"""
SELECT shippers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.RequiredDate)) AS AvgDelay 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY AvgDelay DESC
""""""
# Execute the SQL query and get the results in a DataFrame
df_delays = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize average delays by company
fig = px.bar(df_delays, x='CompanyName', y='AvgDelay',
             title='Average Delivery Delays by Shipping Company',
             labels={'CompanyName': 'Shipping Company', 'AvgDelay': 'Average Delay (days)'},
             template='plotly')

# Show the bar chart to the user
show_to_user(fig)
```","Both implementations accurately fulfill the business analytics request to determine the shipping company with the highest average delay. The input code fetches the same average delays but includes an additional JOIN to get the company name instead of using ShipVia as the identifier. The bar chart visualization faithfully represents the average delays, aligning with the business request objectives.",Finetuned
"Which products have been discontinued but still have stock available, and can we visualize this data with a bar chart to compare the remaining stock levels for each product?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Example code: Replace with actual database query execution code
    import sqlite3
    conn = sqlite3.connect(""your_database.db"")
    df = pd.read_sql_query(sql_query, conn)
    conn.close()
    return df

# Function to display data analysis or visualization results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Main execution
sql_query = '''
SELECT ProductName, UnitsInStock
FROM products
WHERE Discontinued = 1
AND UnitsInStock > 0;
'''

# Retrieve data using the provided SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the remaining stock levels for discontinued products
fig = px.bar(df, x='ProductName', y='UnitsInStock', title='Remaining Stock of Discontinued Products')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
WHERE Discontinued = 1 AND UnitsInStock > 0
""""""

discontinued_products = execute_sql_query(sql_query)

fig = px.bar(discontinued_products, x='ProductName', y='UnitsInStock', 
             title='Discontinued Products with Available Stock',
             labels={'UnitsInStock': 'Remaining Stock', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request. It retrieves products that are discontinued but still have stock using a SQL query. The data is then visualized with a bar chart, showing each product's name and the remaining stock levels, similar to what the reference implementation does. It includes enhancements like additional labels but follows the same logic.","import plotly.express as px
import pandas as pd

# Assume execute_sql_query and show_to_user are predefined functions.

# SQL query to get discontinued products with remaining stock
sql_query = '''
SELECT ProductName, UnitsInStock FROM products WHERE Discontinued = 1 AND UnitsInStock > 0;
'''

# Execute the query and get DataFrame
discontinued_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    discontinued_products_df,
    x='ProductName',
    y='UnitsInStock',
    title='Discontinued Products with Remaining Stock',
    labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units In Stock'},
)

# Show the chart to the user
show_to_user(fig)
","The input Python code correctly implements the business analytics request by querying discontinued products with remaining stock and visualizing the data with a bar chart. The logic is consistent with the reference implementation, as it uses a similar SQL query and visualization approach using Plotly, maintaining the intended functionality and output.",both
Calculate the total freight cost for all orders shipped to the USA and visualize the cost distribution by state.,"
```python
import pandas as pd
import plotly.express as px

def calculate_freight_cost_distribution():
    # SQL query to get freight cost by state for orders shipped to the USA
    sql_query = """"""
    SELECT ShipState, SUM(Freight) AS TotalFreightCost
    FROM orders
    WHERE ShipCountry = 'USA'
    GROUP BY ShipState;
    """"""
    
    # Execute the SQL query
    freight_data = execute_sql_query(sql_query)
    
    # Visualize the freight cost distribution by state using Plotly
    fig = px.bar(freight_data, x='ShipState', y='TotalFreightCost', 
                 title='Freight Cost Distribution by State in the USA',
                 labels={'TotalFreightCost': 'Total Freight Cost', 'ShipState': 'State'})
    
    # Display the visualization
    show_to_user(fig)

# Execute the function
calculate_freight_cost_distribution()
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, SUM(Freight) AS TotalFreight
FROM orders
WHERE ShipCountry = 'USA'
GROUP BY ShipRegion
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipRegion', y='TotalFreight', title='Total Freight Cost Distribution by State in the USA')
show_to_user(fig)
```","Both implementations aim to calculate the sum of freight costs for orders shipped to the USA, grouped by the state or equivalent region. The input code uses 'ShipRegion' instead of 'ShipState' but still captures the essence of grouping by location within the USA. The visualization logic is consistent, using Plotly to display a bar chart. Therefore, the input code adheres to the same logic as the reference and fulfills the business request.","```python
import pandas as pd
import plotly.express as px

# SQL query for fetching total freight cost and state information for US orders
sql_query = """"""
SELECT 
    ShipState, 
    SUM(Freight) AS TotalFreightCost 
FROM orders 
WHERE ShipCountry = 'USA'
GROUP BY ShipState;
""""""

# Execute the SQL query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of freight cost by state
fig = px.bar(orders_df, x='ShipState', y='TotalFreightCost',
             title='Freight Cost Distribution by State in the USA',
             labels={'ShipState': 'State', 'TotalFreightCost': 'Total Freight Cost'},
             text='TotalFreightCost')

# Display the plot to the user
show_to_user(fig)
```","The input code performs the requested task of calculating the total freight cost for orders shipped to the USA and visualizing the distribution by state. It uses a SQL query to aggregate the freight costs by state, just like the reference code. The resultant data is visualized using a Plotly bar chart. The slight differences in variable naming and additional 'text' parameter for labeling in the chart do not affect the correctness. Thus, the input code adheres to the logic and requirements similar to the reference implementation.",both
"Which product has the highest number of units on order, and can this be visualized in a bar chart?","```python
import pandas as pd
import plotly.express as px

# Assume the utility function execute_sql_query is provided and returns a DataFrame
# Also assume show_to_user is provided for display

# SQL query to get the product with the highest number of units on order
sql_query = """"""
SELECT p.ProductID, p.UnitsOnOrder 
FROM products p 
ORDER BY p.UnitsOnOrder DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(df, x='ProductID', y='UnitsOnOrder', title='Product with Highest Units on Order')

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitsOnOrder
FROM products p
ORDER BY p.UnitsOnOrder DESC
LIMIT 1;
""""""

result_df = execute_sql_query(sql_query)
fig = px.bar(result_df, x='ProductName', y='UnitsOnOrder', title='Product with Highest Units on Order')
show_to_user(fig)
```","The input code correctly answers the question by selecting the product with the highest units on order and visualizes it in a bar chart. It aligns with the logic of the reference implementation, despite including the ProductName in the query and using it in the visualization, which enhances the chart's readability.","```python
import plotly.express as px
import pandas as pd

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution
    pass

def show_to_user(data):
    # Placeholder for displaying data
    pass

# SQL query defined
sql_query = """"""
SELECT ProductName, UnitsOnOrder 
FROM products 
ORDER BY UnitsOnOrder DESC 
FETCH FIRST ROW ONLY;
""""""

# Execute the SQL query to get the data
product_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(product_data, x='ProductName', y='UnitsOnOrder', 
             title='Product with Highest Units on Order')

# Display the bar chart
show_to_user(fig)
```","The input code correctly answers the business analytics request, which is to find the product with the highest number of units on order and visualize it in a bar chart. While the reference code selects the 'ProductID', the input code uses 'ProductName' instead, but both achieve the same logical outcome of identifying the product with the most units on order. Additionally, the SQL syntax differences (using 'LIMIT 1' vs 'FETCH FIRST ROW ONLY') are equivalent in context. Both codes utilize Plotly to create and display a bar chart.",both
"Which shipping method is used the most, and can you provide a bar chart to visualize the frequency of each method?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to get the frequency of each shipping method
sql_query = """"""
SELECT ShipVia, COUNT(*) AS UsageCount
FROM orders
GROUP BY ShipVia
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the frequency of each shipping method
fig = px.bar(df, x='ShipVia', y='UsageCount', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'UsageCount': 'Usage Count'})

# Display the bar chart using the required utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC;
""""""

shipping_methods_df = execute_sql_query(sql_query)

fig = px.bar(shipping_methods_df, x='ShipVia', y='Frequency', title='Shipping Method Frequency',
             labels={'ShipVia': 'Shipping Method', 'Frequency': 'Number of Orders'})

show_to_user(fig)
```","The input code correctly answers the business analytics request. It queries the frequency of each shipping method and displays a bar chart. The SQL query selects and counts the shipping methods, similar to the reference implementation. Both codes group by 'ShipVia' and use Plotly Express to create and display a bar chart. The order in the SQL query (order by descending) does not affect the correctness of the output or the logic.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the usage frequency of each shipping method
sql_query = """"""
SELECT ShipVia, COUNT(ShipVia) AS UsageCount 
FROM orders 
GROUP BY ShipVia 
ORDER BY UsageCount DESC;
""""""

# Execute the SQL query and get the results as a pandas DataFrame
shipping_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the frequency of each shipping method
fig = px.bar(shipping_data, x='ShipVia', y='UsageCount', 
             title='Frequency of Shipping Methods',
             labels={'ShipVia': 'Shipping Method', 'UsageCount': 'Frequency'},
             text='UsageCount')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly answers the business analytics request by determining the frequency of each shipping method and displaying it as a bar chart. It uses a similar SQL query to the reference code, grouping by 'ShipVia' and counting the occurrences. The use of ORDER BY in the SQL query doesn't affect correctness for the task requested. The Plotly implementation and function call to display the chart are also in line with the requirements and the reference code.",both
"Which products have the highest quantities on order, and can we visualize this using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductName, UnitsOnOrder 
FROM products 
ORDER BY UnitsOnOrder DESC;
""""""

# Execute the SQL query and get the data into a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(products_df, x='ProductName', y='UnitsOnOrder', 
             title='Products with Highest Quantities on Order',
             labels={'ProductName': 'Product Name', 'UnitsOnOrder': 'Units on Order'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch products with the highest quantities on order
sql_query = """"""
SELECT ProductID, ProductName, UnitsOnOrder
FROM products
WHERE Discontinued = 0
ORDER BY UnitsOnOrder DESC
LIMIT 10;
""""""

# Execute the SQL query
product_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities on order
fig = px.bar(product_data, x='ProductName', y='UnitsOnOrder', 
             title='Top 10 Products by Quantity on Order', 
             labels={'UnitsOnOrder': 'Quantity on Order', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)
```","The input code filters out discontinued products and limits the results to the top 10, which deviates from the reference code. The reference code includes all products and doesn't limit the result set.","```python
import plotly.express as px

# SQL query to fetch products with the highest quantities on order
sql_query = ""SELECT ProductName, UnitsOnOrder FROM products ORDER BY UnitsOnOrder DESC;""

# Execute the SQL query and get the result as a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top products by UnitsOnOrder
fig = px.bar(products_df, x='ProductName', y='UnitsOnOrder', 
             title='Products with Highest Quantities on Order',
             labels={'ProductName': 'Product Name', 'UnitsOnOrder': 'Units on Order'},
             text='UnitsOnOrder')

# Display the bar chart
show_to_user(fig)
```","The input code appropriately addresses the business analytics request by querying the products with the highest quantities on order, similar to the reference implementation. Both use the same SQL query and Pandas DataFrame method to obtain the data. The visualization is created using Plotly in both cases, and the resulting bar chart displays products by UnitsOnOrder. A minor difference is the inclusion of the 'text' attribute in the input code, which adds UnitsOnOrder values as text annotations on the bars; this does not change the correctness of the visualization.",Finetuned
"Which products have the highest sales quantity this month, and can you provide a bar chart to visualize this data?","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch products with the highest sales quantity for the current month
sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE DATE_FORMAT(OrderDate, '%Y-%m') = DATE_FORMAT(CURDATE(), '%Y-%m') 
GROUP BY products.ProductID, products.ProductName 
ORDER BY TotalQuantity DESC;
""""""

# Function to execute SQL query and get data as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation of this function is assumed to be available
    pass

# Function to display data or visualization
def show_to_user(data):
    # Implementation of this function is assumed to be available
    pass

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top-selling products
fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Top Selling Products This Month')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the highest sales quantity this month
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE MONTH(CURRENT_DATE) = MONTH(od.OrderID) AND YEAR(CURRENT_DATE) = YEAR(od.OrderID)
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 10;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the data
fig = px.bar(sales_data, x='ProductName', y='TotalQuantity', title='Top Products by Sales Quantity This Month', labels={'TotalQuantity': 'Sales Quantity', 'ProductName': 'Product Name'})

# Show the data visualization to the user
show_to_user(fig)
```","The provided code correctly implements the required task. It retrieves the products with the highest sales quantity for the current month using a SQL query. Both the provided and reference implementations filter data based on the current month and year, group by product, sum the quantities, and order the results by total quantity in descending order. The provided code also includes a limit of 10 results, which adds a constraint not found in the reference but is not conflicting with retrieving 'highest sales quantity'. The data visualization part using Plotly to create a bar chart is equivalent to the reference, thus making the provided code logically correct and aligned with the business request.","```python
import plotly.express as px

# SQL query to fetch the product sales data for the current month
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE) 
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY products.ProductName 
ORDER BY total_quantity DESC;
""""""

# Execute the SQL query and fetch the data
product_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the product sales data
fig = px.bar(
    product_sales_df, 
    x='ProductName', 
    y='total_quantity',
    title='Top Selling Products This Month',
    labels={'total_quantity': 'Total Quantity Sold'},
    template='plotly'
)

# Display the bar chart
show_to_user(fig)
```",The input code and reference code both correctly execute an SQL query to fetch product sales data and create a bar chart using Plotly to visualize the top-selling products for the current month. The logic used to determine the current month and to sum the sales quantities is equivalent in both codes. Differences in SQL execution and Plotly styling do not affect the core logic consistency.,both
"What is the product-wise breakdown of Total Sales for this year, and can you provide a visual representation such as a bar chart to enhance understanding?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the product-wise breakdown of total sales for this year
sql_query = """"""
SELECT od.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS ProductSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY od.ProductID 
ORDER BY ProductSales DESC;
""""""

# Execute the SQL query and return a pandas DataFrame
df_sales = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_sales, x='ProductID', y='ProductSales', 
             title='Product-wise Breakdown of Total Sales for This Year',
             labels={'ProductID': 'Product ID', 'ProductSales': 'Total Sales'},
             template='plotly_dark')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY 
    od.ProductID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Product-wise Breakdown of Total Sales for This Year')
show_to_user(fig)
```","The input code correctly implements the business request as it uses an SQL query to calculate the product-wise breakdown of total sales for the current year using the same logical structure as the reference code. Both codes execute a similar SQL query and present the results using a Plotly bar chart. The difference in variable names (TotalSales vs. ProductSales) does not affect the correctness. The sorting by total sales in the reference code is not explicitly required in the task description, so its absence in the input does not affect the correctness.","import plotly.express as px
import pandas as pd

# Define a utility function to execute the SQL query and return results as a DataFrame.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function body - to be replaced with actual SQL execution logic.
    pass

# Define a utility function to display the data or visualization results.
def show_to_user(data):
    # Simulated function body - to be replaced with actual display logic.
    pass

# Define the SQL query based on business request.
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY products.ProductName;
""""""

# Execute the SQL query using the utility function to get sales data.
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the product-wise breakdown of Total Sales.
fig = px.bar(
    sales_data,
    x='ProductName',
    y='TotalSales',
    title='Product-wise Breakdown of Total Sales for 2023',
    labels={'ProductName': 'Product Name', 'TotalSales': 'Total Sales'},
    template='plotly'
)

# Display the bar chart using the utility function.
show_to_user(fig)
","The input code calculates 'Total Sales' without considering discounts, whereas the reference code includes a discount in the calculation. Additionally, the input code filters orders by an explicit date range, while the reference code uses the current year dynamically. These differences affect the correctness of the analysis as per the specified request.",Base
Which region has the highest number of orders? Can you provide a bar chart to visualize the comparison across regions?,"```python
import pandas as pd
import plotly.express as px

# SQL query to obtain order counts by region
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipRegion
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query using the utility function to get the DataFrame
df_regions = execute_sql_query(sql_query)

# Visualize the data using a bar chart in Plotly
fig = px.bar(df_regions, x='ShipRegion', y='OrderCount', 
             title='Number of Orders by Region',
             labels={'OrderCount': 'Order Count', 'ShipRegion': 'Region'})

# Display the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OrderCount DESC;
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ShipRegion', y='OrderCount', title='Number of Orders by Region', labels={'OrderCount': 'Number of Orders', 'ShipRegion': 'Region'})
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It uses the same SQL query to count orders by region, orders the results in descending order of the count, and stores the result in a DataFrame. The Plotly bar chart is created with the correct labels and title, similar to the reference code. The functions to execute the SQL and display the plot are assumed to perform the same operations as in the reference code.","```python
import plotly.express as px

# Define the SQL query to get order counts by region
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get the results as a DataFrame
order_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(order_data, x='ShipRegion', y='OrderCount',
             title='Number of Orders by Region',
             labels={'ShipRegion': 'Region', 'OrderCount': 'Number of Orders'})

# Show the bar chart to the user
show_to_user(fig)
```",The input code achieves the same functionality as the reference code: it executes an SQL query to count orders by region and then creates a bar chart using Plotly to visualize the results. Both the query and the visualization logic are consistent with the reference. Differences in label wording ('Number of Orders' vs. 'Order Count') do not affect the correctness regarding the task goal.,both
List the suppliers with products that are consistently ordered and provide a bar chart showing the frequency of orders for each supplier.,"```python
import pandas as pd
import plotly.express as px

# Define SQL query to get suppliers with consistently ordered products
sql_query = """"""
SELECT suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.CompanyName 
HAVING COUNT(DISTINCT [Order Details].OrderID) > 1;
""""""

# Function to execute SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate database query execution
    # Replace with actual database connection and query execution logic
    # Example: return pd.read_sql(sql_query, connection)
    pass  # This should be implemented with actual SQL execution code

# Retrieve data using the utility function
suppliers_df = execute_sql_query(sql_query)

# Check if the resulting DataFrame is empty
if suppliers_df.empty:
    print(""No suppliers found with consistently ordered products."")
else:
    # Since we already have distinct orders per company, count the suppliers directly
    supplier_order_counts = suppliers_df['CompanyName'].value_counts().reset_index()
    supplier_order_counts.columns = ['CompanyName', 'OrderFrequency']

    # Create a bar chart using Plotly
    fig = px.bar(supplier_order_counts, x='CompanyName', y='OrderFrequency',
                 title='Frequency of Orders for Each Supplier',
                 labels={'OrderFrequency': 'Order Frequency', 'CompanyName': 'Supplier'})

    # Display the plot using the show_to_user function
    show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(o.OrderID) AS OrderFrequency
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
HAVING COUNT(o.OrderID) > 0
ORDER BY OrderFrequency DESC;
""""""

supplier_orders_df = execute_sql_query(sql_query)

fig = px.bar(supplier_orders_df, x='CompanyName', y='OrderFrequency', title='Frequency of Orders for Each Supplier')
show_to_user(fig)
```","The input code does not correctly interpret the business request. The HAVING clause in the input ensures inclusion of suppliers with any orders (> 0), while the request specifies 'consistently ordered products,' which should be defined by ordering frequency (e.g., more than one order as in the reference). Additionally, the input sorts by order frequency, which is a change in logic from the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the count of distinct products for each supplier
sql_query = """"""
SELECT suppliers.CompanyName, COUNT(DISTINCT [Order Details].ProductID) AS product_count 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Filter suppliers with a consistent product count (assuming we interpret 'consistently' as all suppliers)
consistent_suppliers = df[df['product_count'] > 0]

# Display the DataFrame with filtered suppliers
show_to_user(consistent_suppliers)

# Create a bar chart to visualize the frequency of orders for each supplier
fig = px.bar(consistent_suppliers, x='CompanyName', y='product_count', 
             title='Frequency of Orders per Supplier',
             labels={
                 'CompanyName': 'Supplier',
                 'product_count': 'Unique Product Count'
             })

# Show the bar chart
show_to_user(fig)
```","The input code does not adhere to the business analytics request or the logic of the reference implementation. The reference code queries suppliers whose products are ordered consistently by counting distinct order IDs, implying repeated orders. The input code counts distinct product IDs per supplier instead, which doesn't address consistency in terms of order frequency. Additionally, the input code assumes consistency with a product count greater than zero, which does not align with the logic of identifying consistently ordered products across multiple orders.",None
Identify the products that are provided by multiple suppliers and represent the results using a bar chart to show the number of suppliers per product.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to identify products provided by multiple suppliers
sql_query = """"""
SELECT P.ProductName, COUNT(DISTINCT P.SupplierID) AS SupplierCount
FROM products P
JOIN (SELECT ProductID FROM products GROUP BY ProductID HAVING COUNT(DISTINCT SupplierID) > 1) AS MultiSupplier
ON P.ProductID = MultiSupplier.ProductID
GROUP BY P.ProductName;
""""""

# Execute the SQL query and get results as a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Generate a bar chart to show the number of suppliers per product
fig = px.bar(products_df, x='ProductName', y='SupplierCount', 
             title='Number of Suppliers per Product', 
             labels={'ProductName': 'Product Name', 'SupplierCount': 'Number of Suppliers'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, COUNT(DISTINCT p.SupplierID) AS SupplierCount
FROM products p
GROUP BY p.ProductID, p.ProductName
HAVING COUNT(DISTINCT p.SupplierID) > 1
""""""

products_suppliers = execute_sql_query(sql_query)

fig = px.bar(products_suppliers, x='ProductName', y='SupplierCount', title='Number of Suppliers per Product')
show_to_user(fig)
```","Both the reference and the input Python code correctly identify products that have more than one distinct supplier. The SQL query in both cases selects products and counts distinct suppliers, only including products with multiple suppliers. The difference in the SQL is mainly in the approach but not in functionality, and both produce similar results. They then visualize this information in a bar chart displaying the number of suppliers per product.","```python
import plotly.express as px

# Given function to execute SQL query
def execute_sql_query(sql_query: str):
    # Placeholder function to simulate SQL query execution
    # In actual implementation, this would connect to a database and return a dataframe
    import pandas as pd
    data = {'ProductID': [1, 2, 3], 'SupplierCount': [2, 3, 4]}
    return pd.DataFrame(data)

# Given function to display results
def show_to_user(data):
    if isinstance(data, dict):
        for key, df in data.items():
            print(f""{key}:"")
            print(df)
    else:
        print(data)

# SQL query to get the products with the SupplierCount > 1
sql_query = """"""
SELECT ProductID, COUNT(DISTINCT SupplierID) AS SupplierCount 
FROM products 
GROUP BY ProductID 
HAVING COUNT(DISTINCT SupplierID) > 1;
""""""

# Execute the query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='SupplierCount', 
             title='Number of Suppliers per Product',
             labels={'ProductID': 'Product ID', 'SupplierCount': 'Number of Suppliers'})

# Show the plot using the utility function
show_to_user(fig)
```","The input code and reference implementation both aim to identify products provided by multiple suppliers and visualize this using a bar chart. While the input code differs slightly in implementation, it correctly follows the logic of aggregating ProductIDs with multiple suppliers and displays the SupplierCount as a bar chart. The specific use of column names ('ProductID' vs. 'ProductName') is consistent with provided data, fulfilling the business request.",both
"What are the average sales per order for each employee, and can you provide a bar chart to visualize the results?","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT E.EmployeeID, 
AVG(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS AverageSalesPerOrder 
FROM employees E 
JOIN orders O ON E.EmployeeID = O.EmployeeID 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
GROUP BY E.EmployeeID;
""""""

# Execute the SQL query and obtain the result as a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average sales per order for each employee
fig = px.bar(data, x='EmployeeID', y='AverageSalesPerOrder', 
             title='Average Sales Per Order by Employee', 
             labels={'EmployeeID': 'Employee ID', 'AverageSalesPerOrder': 'Average Sales Per Order'})

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
    COUNT(o.OrderID) AS OrderCount,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / NULLIF(COUNT(o.OrderID), 0) AS AverageSalesPerOrder
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='FirstName' + ' ' + 'LastName', y='AverageSalesPerOrder', 
             labels={'FirstName': 'Employee', 'AverageSalesPerOrder': 'Average Sales per Order'},
             title='Average Sales per Order for Each Employee')
show_to_user(fig)
```","The input code calculates the average sales per order for each employee, similar to the reference code. Although it includes additional details like employee first and last names, the essential logic of calculating 'AverageSalesPerOrder' and visualizing it with a bar chart is consistent with the reference implementation. The division by 'NULLIF(COUNT(o.OrderID), 0)' ensures no division by zero, which is appropriate. The visualization effectively displays 'Average Sales per Order', fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT e.EmployeeID, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AvgSalesPerOrder
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # This function should connect to the database, execute the query, and return the DataFrame
    pass

# Fetch the data
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='EmployeeID', y='AvgSalesPerOrder', 
             title='Average Sales per Order by Employee',
             labels={'AvgSalesPerOrder': 'Average Sales per Order', 'EmployeeID': 'Employee ID'})

# Display the bar chart
def show_to_user(data):
    # Placeholder for logic to display data to user
    # If data is a Plotly figure, it will be plotted
    pass

show_to_user(fig)
```","The input Python code correctly executes the same SQL query as the reference code, aggregating average sales per order for each employee. It utilizes the same logic by joining the employees, orders, and order details tables and calculates the average sales based on the unit price, quantity, and discount. The column alias differs slightly ('AvgSalesPerOrder' vs 'AverageSalesPerOrder'), but logically they represent the same calculation. Both implementations also use Plotly to generate a bar chart visualizing the results, and any placeholder functions for database connectivity and display do not affect the logical correctness of the code.",both
Determine the total number of customers who have never placed an order and create a visualization showing the proportion of customers who have never ordered versus those who have.,"
```python
import pandas as pd
import plotly.express as px

# SQL queries
customer_query = ""SELECT COUNT(CustomerID) AS NeverOrdered FROM customers WHERE CustomerID NOT IN (SELECT DISTINCT CustomerID FROM orders);""
total_customers_query = ""SELECT COUNT(CustomerID) AS TotalCustomers FROM customers;""

# Utility function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to execute the provided SQL query and return the result as a pandas DataFrame
    pass

# Utility function to display data
def show_to_user(data):
    # This function should be implemented to display a pandas DataFrame or a Plotly figure
    pass

# Execute queries to get the required data
never_ordered_df = execute_sql_query(customer_query)
total_customers_df = execute_sql_query(total_customers_query)

# Extract the values from the dataframes
never_ordered_count = never_ordered_df['NeverOrdered'].iloc[0]
total_customers_count = total_customers_df['TotalCustomers'].iloc[0]

# Calculate the number of customers who have placed an order
ordered_count = total_customers_count - never_ordered_count

# Create a DataFrame for visualization
data = pd.DataFrame({
    'Category': ['Never Ordered', 'Ordered'],
    'Count': [never_ordered_count, ordered_count]
})

# Create a pie chart to show the proportion of customers
fig = px.pie(data, names='Category', values='Count', title='Proportion of Customers: Never Ordered vs Ordered')

# Display the visualization
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    COUNT(DISTINCT c.CustomerID) AS NeverOrdered
FROM
    customers c
LEFT JOIN
    orders o ON c.CustomerID = o.CustomerID
WHERE
    o.OrderID IS NULL
""""""

never_ordered_df = execute_sql_query(sql_query)
never_ordered_count = never_ordered_df['NeverOrdered'].iloc[0]

sql_query = """"""
SELECT
    COUNT(DISTINCT CustomerID) AS TotalCustomers
FROM
    customers
""""""

total_customers_df = execute_sql_query(sql_query)
total_customers_count = total_customers_df['TotalCustomers'].iloc[0]

ordered_count = total_customers_count - never_ordered_count

data = {
    'Status': ['Never Ordered', 'Ordered'],
    'Count': [never_ordered_count, ordered_count]
}

status_df = pd.DataFrame(data)

fig = px.pie(status_df, values='Count', names='Status', title='Proportion of Customers Who Have Never Ordered vs. Those Who Have')
show_to_user(fig)
```","The evaluated code correctly implements the required business logic. It calculates the number of customers who have never placed an order by performing a LEFT JOIN between the customers and orders tables and counting where OrderID is NULL. This approach is logically equivalent to the reference code's use of a subquery with NOT IN. The total number of customers is then obtained, and the number of customers who have ordered is computed by subtraction. Finally, both codes use Plotly to create a pie chart representing the proportions, adhering to the specified request.","```python
import pandas as pd
import plotly.express as px

# Replace with the actual execute_sql_query function as defined in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the actual SQL query execution
    # In practice, this would connect to the database and fetch results
    data = {
        'CustomerID': [1, 2, 3, 4, 5],
        'HasPlacedOrder': [1, 1, 0, 1, 0]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Display the result based on whether data is a DataFrame or a Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query
sql_query = ""SELECT CustomerID FROM customers WHERE CustomerID NOT IN (SELECT CustomerID FROM orders);""
# Adjusted DataFrame to include query assumption
customers_df = execute_sql_query(sql_query)

# Determine number of customers who have never placed an order
new_customers_count = customers_df.shape[0]

# Assuming another query retrieves total number of unique customers
total_customers = 5  # As per the example data, adjust as per actual data

# Calculate the number of customers who have placed orders
customers_had_orders_count = total_customers - new_customers_count

# Create a DataFrame for visualization
proportion_df = pd.DataFrame({
    'OrderStatus': ['Never Ordered', 'Ordered'],
    'Count': [new_customers_count, customers_had_orders_count]
})

# Create a pie chart to visualize the proportion
fig = px.pie(proportion_df, names='OrderStatus', values='Count', title='Customer Order Status Proportion')

# Display the figure using the show_to_user function
show_to_user(fig)
```","The input code does not correctly implement the specified business analytics request. While it generates a pie chart, the data source used in 'execute_sql_query' is not aligned with the SQL queries from the reference code. The input calculates 'new_customers_count' from a DataFrame that does not originate from an actual SQL query output that considers distinct customer orders. Instead, it utilizes a static DataFrame with hypothetical 'HasPlacedOrder' data, which deviates significantly from the requirement to query the database to identify never-ordered customers. Consequently, the logic behind identifying the 'Never Ordered' count is flawed, making the final result incorrect.",Base
"How many orders include a discount greater than 20%? Additionally, provide a bar chart of order counts segmented by discount ranges.","```python
import pandas as pd
import plotly.express as px

# SQL query to count orders with a discount greater than 20%
sql_query_high_discount_orders = '''
SELECT COUNT(DISTINCT [Order Details].OrderID) AS HighDiscountOrders
FROM [Order Details]
WHERE [Order Details].Discount > 0.2;
'''

# Execute SQL query to find the number of high discount orders
high_discount_orders_df = execute_sql_query(sql_query_high_discount_orders)

# Display the number of high discount orders
show_to_user(high_discount_orders_df)

# SQL query to get all order details with discounts
sql_query_all_discounts = '''
SELECT [Order Details].OrderID, [Order Details].Discount
FROM [Order Details];
'''

# Execute SQL query to get discount details for all orders
all_discounts_df = execute_sql_query(sql_query_all_discounts)

# Create discount ranges for analysis
bins = [-0.01, 0, 0.1, 0.2, 0.3, 0.4, 1]
labels = ['0%', '0-10%', '10-20%', '20-30%', '30-40%', '40%+']
all_discounts_df['DiscountRange'] = pd.cut(all_discounts_df['Discount'], bins=bins, labels=labels)

# Count the number of orders in each discount range
discount_range_counts = all_discounts_df['DiscountRange'].value_counts().sort_index().reset_index()
discount_range_counts.columns = ['DiscountRange', 'OrderCount']

# Create a bar chart for the order counts by discount range
fig = px.bar(discount_range_counts, x='DiscountRange', y='OrderCount',
             title='Order Counts by Discount Range', 
             labels={'OrderCount':'Order Count', 'DiscountRange':'Discount Range'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    COUNT(*) AS OrdersWithDiscountGreaterThan20
FROM
    [Order Details]
WHERE
    Discount > 0.20
""""""

result = execute_sql_query(sql_query)
count_discount_greater_than_20 = result['OrdersWithDiscountGreaterThan20'].iloc[0]

sql_query_discount_ranges = """"""
SELECT
    CASE 
        WHEN Discount = 0 THEN '0%'
        WHEN Discount > 0 AND Discount <= 0.05 THEN '0% - 5%'
        WHEN Discount > 0.05 AND Discount <= 0.10 THEN '5% - 10%'
        WHEN Discount > 0.10 AND Discount <= 0.15 THEN '10% - 15%'
        WHEN Discount > 0.15 AND Discount <= 0.20 THEN '15% - 20%'
        WHEN Discount > 0.20 AND Discount <= 0.25 THEN '20% - 25%'
        WHEN Discount > 0.25 AND Discount <= 0.30 THEN '25% - 30%'
        ELSE '> 30%'
    END AS DiscountRange,
    COUNT(*) AS OrderCount
FROM
    [Order Details]
GROUP BY
    DiscountRange
ORDER BY
    DiscountRange
""""""

discount_ranges = execute_sql_query(sql_query_discount_ranges)
fig = px.bar(discount_ranges, x='DiscountRange', y='OrderCount', title='Order Counts by Discount Ranges')
show_to_user(fig)

count_discount_greater_than_20
```","The input code uses a different discount segmentation logic than the reference. The input code has ranges such as '0% - 5%' and '> 30%', which are missing from the reference. Additionally, the input calculates the count directly with COUNT(*), which could lead to different results from COUNT(DISTINCT OrderID) if there are duplicate entries. The grouping and conditions in the input are not equivalent to the reference.","```python
import pandas as pd
import plotly.express as px

# Constants
SQL_QUERY = ""SELECT DISTINCT OrderID FROM [Order Details] WHERE Discount > 0.2;""

# Utility Functions
def execute_sql_query(sql_query: str):
    # Mock function to execute an SQL query
    # In practice, this would connect to the database and return the results
    if sql_query == SQL_QUERY:
        return pd.DataFrame({'OrderID': [1, 2, 3]})

def show_to_user(data):
    # Mock function to display data
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# Step 1: Execute the given SQL query
discount_orders_df = execute_sql_query(SQL_QUERY)

# Count the orders with discount > 20%
num_discount_orders = discount_orders_df['OrderID'].nunique()

# Display the result
show_to_user(pd.DataFrame({'Orders with >20% Discount': [num_discount_orders]}))

# Mock larger dataset for segmentation analysis
orders_df = pd.DataFrame({
    'OrderID': [1, 2, 3, 4, 5],
    'Discount': [0.05, 0.25, 0.15, 0.30, 0.10]
})

# Segment by discount ranges
discount_bins = [0, 0.1, 0.2, 0.3, 1]
discount_labels = ['0-10%', '10-20%', '20-30%', '>30%']
orders_df['Discount Range'] = pd.cut(orders_df['Discount'], bins=discount_bins, labels=discount_labels, right=False)

# Count orders in each discount range
discount_range_counts = orders_df['Discount Range'].value_counts().reset_index()
discount_range_counts.columns = ['Discount Range', 'Order Count']

# Create bar chart
fig = px.bar(discount_range_counts, x='Discount Range', y='Order Count', title='Order Counts by Discount Range')

# Show the bar chart
show_to_user(fig)
```","The input code does not fully match the reference implementation. The SQL query in the reference counts distinct OrderIDs directly, while the input code retrieves distinct OrderIDs and calculates the count in Python, which matches the intent but lacks connecting it with database execution realism. Furthermore, the discount range segmentation differs; the input excludes zero discounts and uses open intervals for the bins, impacting the range grouping compared to the reference implementation, which includes zero and higher ranges. These deviations result in different potential outcomes for both order count and chart presentation.",None
"Which products have less than 10 units in stock and need reordering, and can you provide a bar chart to display these products?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to get products with less than 10 units in stock and need reordering
sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
WHERE UnitsInStock < 10 AND UnitsInStock <= ReorderLevel;
""""""

# Execute the SQL query and get the result in a pandas DataFrame
products_to_reorder = execute_sql_query(sql_query)

# Create a bar chart to display the products and their stock levels
fig = px.bar(
    products_to_reorder,
    x='ProductName',
    y='UnitsInStock',
    title='Products Needing Reordering',
    labels={'UnitsInStock': 'Units in Stock'}
)

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products 
WHERE UnitsInStock < 10 AND Discontinued = 0
""""""

products_to_reorder = execute_sql_query(sql_query)

fig = px.bar(products_to_reorder, x='ProductName', y='UnitsInStock', 
              title='Products Needing Reorder (Less than 10 Units in Stock)',
              labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'})

show_to_user(fig)
```",The provided code does not correctly implement the business analytics request as specified by the reference implementation. The query in the input code checks for `Discontinued = 0` instead of the `ReorderLevel` condition required by the reference code. This means the logic differs as the input code may include products that should not be reordered based solely on stock levels.,"```python
import pandas as pd
import plotly.express as px

# SQL query to identify products with less than 10 units in stock that need reordering
sql_query = """"""
SELECT ProductID, ProductName FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0;
""""""

# Execute the SQL query and return the result as a DataFrame
products_needing_reorder = execute_sql_query(sql_query)

# Create a bar chart to display the products
fig = px.bar(
    products_needing_reorder, 
    x='ProductName', 
    y='ProductID', 
    title=""Products Needing Reorder:"",
    labels={'ProductName': 'Product Name', 'ProductID': 'Product ID'}
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code and reference code use different criteria for selecting products. The reference code checks for 'UnitsInStock < 10 AND UnitsInStock <= ReorderLevel', while the input code uses 'UnitsInStock < ReorderLevel AND Discontinued = 0'. Also, the chart uses a different y-axis ('ProductID' instead of 'UnitsInStock'), which does not represent stock levels.",None
"What is the average shipping cost per order in 2023, and can this be illustrated with a bar chart showing monthly averages?","```python
import pandas as pd
import plotly.express as px

# The SQL query to get the average shipping cost per month in 2023
sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS order_month,
    AVG(orders.Freight) AS avg_shipping_cost_per_order
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY order_month
ORDER BY order_month
""""""

# Use the utility function to execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the monthly average shipping costs
fig = px.bar(
    df, 
    x='order_month', 
    y='avg_shipping_cost_per_order',
    title='Average Shipping Cost per Order by Month in 2023',
    labels={'order_month': 'Month', 'avg_shipping_cost_per_order': 'Average Shipping Cost ($)'}
)

# Display the resulting bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, AVG(Freight) AS avg_shipping_cost
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY month
ORDER BY month;
""""""

monthly_avg_shipping_cost = execute_sql_query(sql_query)

fig = px.bar(monthly_avg_shipping_cost, x='month', y='avg_shipping_cost', 
             labels={'avg_shipping_cost': 'Average Shipping Cost', 'month': 'Month'},
             title='Average Shipping Cost per Order in 2023')
show_to_user(fig)
```","Both implementations achieve the same objective of calculating the average shipping cost per order for each month in 2023. Despite slight differences in SQL syntax, like `DATE_TRUNC` vs. `DATE_FORMAT`, and the table aliasing differences, the core logic is preserved. Both use grouping by month and calculate the average of `Freight`. The visualization part is also equivalent, using Plotly to create a bar chart with appropriate labels and titles.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch monthly average shipping costs for 2023
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM orders.OrderDate) AS month,
    AVG(orders.ShippedCost) AS avg_shipping_cost 
FROM 
    orders 
WHERE 
    EXTRACT(YEAR FROM orders.OrderDate) = 2023 
GROUP BY 
    EXTRACT(MONTH FROM orders.OrderDate) 
ORDER BY 
    month;
""""""

# Execute the SQL query to get the data
monthly_avg_shipping_cost_df = execute_sql_query(sql_query)

# Display the DataFrame for review
show_to_user(monthly_avg_shipping_cost_df)

# Create a bar chart to illustrate monthly average shipping costs
fig = px.bar(
    monthly_avg_shipping_cost_df, 
    x='month', 
    y='avg_shipping_cost', 
    title='Average Shipping Cost Per Order in 2023',
    labels={'month': 'Month', 'avg_shipping_cost': 'Average Shipping Cost'}
)

# Display the bar chart
show_to_user(fig)
```","The input code is incorrect because it uses 'orders.ShippedCost' instead of 'orders.Freight' as in the reference code. This difference implies that the input code might calculate shipping costs using the wrong column. The extraction of the month using EXTRACT is logical but differs slightly by not using DATE_TRUNC and instead groups by the extracted month, which may also affect date grouping precision if time factors are considered (though it answers the same question if the year is fixed). These differences, particularly the column name, affect the adherence to the logic of the reference implementation.",Base
"Find any correlation between the employees' hire date and their performance in sales, and include a scatter plot to visualize the relationship.","```python
import pandas as pd
import plotly.express as px
from scipy.stats import pearsonr

# Mock implementation of execute_sql_query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # In actual implementation, this would execute the query against the database.
    pass

# Mock implementation of show_to_user
def show_to_user(data):
    # In actual implementation, this would display the data or visualization.
    pass

# SQL Query as provided
sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.HireDate, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.HireDate 
ORDER BY TotalSales DESC
""""""

# Execute the SQL query and get the data
employees_sales_data = execute_sql_query(sql_query)

# Convert HireDate to datetime format
employees_sales_data['HireDate'] = pd.to_datetime(employees_sales_data['HireDate'])

# Calculate the correlation
correlation, _ = pearsonr(
    employees_sales_data['HireDate'].map(pd.Timestamp.toordinal), 
    employees_sales_data['TotalSales']
)

# Print the correlation
print(f'Correlation between HireDate and TotalSales: {correlation}')

# Create scatter plot
fig = px.scatter(
    employees_sales_data, 
    x='HireDate', 
    y='TotalSales', 
    title='Correlation between HireDate and Total Sales',
    labels={'HireDate': 'Hire Date', 'TotalSales': 'Total Sales'}
)

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.HireDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.HireDate
""""""

data = execute_sql_query(sql_query)

data['HireDate'] = pd.to_datetime(data['HireDate']).dt.date
fig = px.scatter(data, x='HireDate', y='TotalSales', title='Correlation between Hire Date and Total Sales',
                 labels={'HireDate': 'Hire Date', 'TotalSales': 'Total Sales'})

show_to_user(fig)
```","The input code does not calculate the correlation coefficient between 'HireDate' and 'TotalSales', which is a crucial part of the business analytics request. The reference implementation uses `pearsonr` to calculate this value, which is missing in the input code.","```python
import pandas as pd
import plotly.express as px

# Utility Function: Simulated for purpose of this environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would actually connect to a database and execute the provided query
    # For this context, it's assumed to return a valid DataFrame
    pass

def show_to_user(data):
    # Placeholder function to display data or visualization
    pass

# Business Application Logic
sql_query = """"""
SELECT e.EmployeeID, 
       (YEAR(CURDATE()) - YEAR(e.HireDate)) AS YearsWithCompany, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Load the data using the utility function
df = execute_sql_query(sql_query)

# Check for any correlation
if df['YearsWithCompany'].isnull().any() or df['TotalSales'].isnull().any():
    raise ValueError(""Data contains missing values which may affect correlation calculation."")

correlation = df['YearsWithCompany'].corr(df['TotalSales'])

# Visualize the relationship using a scatter plot
fig = px.scatter(df, x='YearsWithCompany', y='TotalSales', 
                 title=f'Scatter Plot of Hire Duration vs Total Sales (Correlation: {correlation:.2f})',
                 labels={'YearsWithCompany': 'Years with Company', 'TotalSales': 'Total Sales'})

# Display the scatter plot
show_to_user(fig)
```","The input code computes 'YearsWithCompany' instead of working directly with 'HireDate' as in the reference code. This transformation changes the essence of the correlation check. Additionally, it calculates a Pearson correlation using pandas directly, which differs from the ordinal date conversion and scipy usage in the reference code, leading to potentially different correlation results. Thus, it does not apply the same logic as the reference.",None
Calculate the average unit price of all products per supplier and visualize the results with a bar chart.,"```python
import plotly.express as px
import pandas as pd

# Assuming the function execute_sql_query is pre-defined and existing in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function. In practice, this should execute the provided SQL query.
    pass

def show_to_user(data):
    # This is a placeholder function. In practice, this should display a DataFrame or a Plotly graph.
    pass

# SQL query to get the average unit price of all products per supplier
sql_query = """"""
SELECT s.CompanyName, AVG(p.UnitPrice) AS AvgUnitPrice 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.CompanyName;
""""""

# Execute the SQL query and get the result into a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='AvgUnitPrice', title='Average Unit Price per Supplier', labels={'CompanyName':'Supplier', 'AvgUnitPrice':'Average Unit Price'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(p.UnitPrice) AS AverageUnitPrice
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
""""""

average_unit_price_df = execute_sql_query(sql_query)

fig = px.bar(average_unit_price_df, x='CompanyName', y='AverageUnitPrice', 
             title='Average Unit Price of Products per Supplier',
             labels={'AverageUnitPrice': 'Average Unit Price', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly executes a SQL query to calculate the average unit price of all products per supplier, similar to the reference code. It uses the same logic by selecting and aggregating data from the same tables, grouping by supplier company name. The resulting data is then visualized using Plotly with a bar chart, which matches the reference implementation. Minor differences in column naming conventions do not affect correctness.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = ""SELECT SupplierID, AVG(UnitPrice) AS AvgUnitPrice FROM products GROUP BY SupplierID;""

# Execute SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for average unit prices per supplier
fig = px.bar(df, x='SupplierID', y='AvgUnitPrice', title='Average Unit Price per Supplier')

# Show the visualization to the user
show_to_user(fig)
```","The input code calculates the average unit price per SupplierID instead of per CompanyName, which does not match the reference implementation. The reference code uses a JOIN to ensure it includes CompanyName in the results, while the input code does not join the suppliers and products tables.",Base
Find the correlation between employee hire date and total sales and visualize the results using a scatter plot.,"```python
import pandas as pd
import plotly.express as px
from scipy.stats import pearsonr

# Placeholder for the execute_sql_query function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the provided SQL query and return the result as a pandas DataFrame
    pass

# Placeholder for the show_to_user function
def show_to_user(data):
    # This function should handle displaying the data, either as a DataFrame or Plotly figure
    pass

# The SQL query as specified in the input
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales, 
       YEAR(CURDATE()) - YEAR(e.HireDate) AS YearsSinceHire 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the data in a DataFrame
df = execute_sql_query(sql_query)

# Calculate the correlation between YearsSinceHire and TotalSales
correlation, _ = pearsonr(df['YearsSinceHire'], df['TotalSales'])

# Print the correlation coefficient
print(f""Correlation between Years Since Hire and Total Sales: {correlation}"")

# Create a scatter plot to visualize the relationship
fig = px.scatter(df, x='YearsSinceHire', y='TotalSales', 
                 title='Correlation Between Years Since Hire and Total Sales',
                 labels={'YearsSinceHire': 'Years Since Hire', 'TotalSales': 'Total Sales'})

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get hire dates and total sales
sql_query = """"""
SELECT e.HireDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.HireDate
""""""
data = execute_sql_query(sql_query)

# Calculate correlation
correlation = data['HireDate'].astype('int64').corr(data['TotalSales'])

# Scatter plot
fig = px.scatter(data, x='HireDate', y='TotalSales', title='Correlation between Hire Date and Total Sales')
show_to_user(fig)

correlation
```","The input code differs fundamentally from the reference code in its approach to determining the correlation. The input uses 'HireDate' directly rather than calculating 'YearsSinceHire'. This results in incorrect correlation measurement. Additionally, the input lacks the use of the Pearson correlation function, which is more appropriate for this calculation.","```python
import pandas as pd
import plotly.express as px


def execute_sql_query(sql_query: str):
    # Placeholder implementation for example purposes
    data = {
        'EmployeeID': [1, 2, 3],
        'Correlation': [0.5, -0.3, 0.8]
    }
    return pd.DataFrame(data)


def show_to_user(data):
    # Placeholder implementation for example purposes
    if isinstance(data, pd.DataFrame):
        print(data)
    elif hasattr(data, 'show'):
        data.show()


# Step 1: Execute the SQL query to get the correlation results
sql_query = """"""
SELECT employees.EmployeeID, 
       CORR(DATEDIFF(CURRENT_DATE, employees.HireDate), 
            user_sales.TotalSales) AS Correlation 
FROM employees 
JOIN (
    SELECT employee_id, SUM(orders.Total) AS TotalSales 
    FROM orders 
    JOIN employees ON orders.EmployeeID = employees.EmployeeID 
    GROUP BY employee_id
) AS user_sales 
ON employees.EmployeeID = user_sales.employee_id 
GROUP BY employees.EmployeeID;
""""""

correlation_df = execute_sql_query(sql_query)

# Step 2: Visualize using a scatter plot
fig = px.scatter(correlation_df, x='EmployeeID', y='Correlation', 
                 title=""Correlation between Employee Hire Date and Total Sales"",
                 labels={'Correlation': 'Correlation Coefficient'})

# Step 3: Present the visualization to the user
show_to_user(fig)
```","The input code does not correctly implement the business analytics request. Firstly, the SQL query structure is incorrect; it attempts to calculate correlation directly in the SQL using a non-standard function 'CORR', which is not supported in SQL standards like the implementation intended with 'pearsonr' in Python. Secondly, the input code attempts to visualize correlation coefficients against Employee IDs, which deviates from the requirement of visualizing the direct scatter plot of 'Years Since Hire' vs 'Total Sales'. The reference implementation correctly calculates the correlation in Python and creates the appropriate scatter plot, which the input code does not do.",None
"What percentage of orders were delivered on time this month, and can you provide a pie chart to visualize the on-time versus late deliveries?","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the percentage of on-time deliveries
sql_query = """"""
SELECT 
    COUNT(OrderID) FILTER (WHERE ShippedDate <= RequiredDate) * 100.0 / COUNT(OrderID) AS on_time_percentage, 
    COUNT(OrderID) FILTER (WHERE ShippedDate > RequiredDate) * 100.0 / COUNT(OrderID) AS late_percentage
FROM orders 
WHERE OrderDate >= DATE_TRUNC('month', CURRENT_DATE);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the results
on_time_percentage = result_df['on_time_percentage'].iloc[0]
late_percentage = result_df['late_percentage'].iloc[0]

# Create a DataFrame for visualization
visualization_df = pd.DataFrame({
    'Delivery Status': ['On-Time', 'Late'],
    'Percentage': [on_time_percentage, late_percentage]
})

# Create a pie chart using Plotly
fig = px.pie(visualization_df, names='Delivery Status', values='Percentage', 
             title='On-Time vs Late Deliveries for This Month')

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Get the current month
current_month = datetime.now().strftime(""%Y-%m"")

# SQL query to retrieve orders for the current month
sql_query = f""""""
SELECT 
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM 
    orders
WHERE 
    DATE_FORMAT(OrderDate, '%Y-%m') = '{current_month}'
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate the percentage of on-time deliveries
total_orders = result_df['TotalOrders'].iloc[0]
on_time_deliveries = result_df['OnTimeDeliveries'].iloc[0]
on_time_percentage = (on_time_deliveries / total_orders) * 100 if total_orders > 0 else 0

# Prepare data for pie chart
labels = ['On-Time', 'Late']
values = [on_time_deliveries, total_orders - on_time_deliveries]

# Create a pie chart
fig = px.pie(names=labels, values=values, title=f'On-Time Delivery Percentage: {on_time_percentage:.2f}%', 
             color_discrete_sequence=['green', 'red'])

# Show the results
show_to_user(fig)
```","The provided Python code correctly implements the business analytics request by calculating the percentage of orders delivered on time for the current month. The logic aligns with the reference implementation, using a SQL query to retrieve the necessary data and calculate the 'On-Time' delivery percentage. Although different methods are used (e.g., CASE WHEN versus FILTER), they achieve equivalent results. Both codes create and display a pie chart visualizing on-time versus late deliveries, fulfilling the requirement.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # The actual SQL execution code is presumed to be in place
    # Here we just simulate returning a DataFrame
    return pd.read_sql(sql_query, your_database_connection)

# Function to display data to the user
def show_to_user(data):
    if isinstance(data, (pd.DataFrame, px.Figure)):
        # Display logic for pandas DataFrame or Plotly figure
        pass

# SQL query to get on-time delivery details
sql_query = """"""
SELECT COUNT(CASE WHEN orders.OrderDate <= orders.ShippedDate THEN order_id END) as OnTimeCount, 
       COUNT(CASE WHEN orders.OrderDate > orders.ShippedDate THEN order_id END) as LateCount 
FROM orders 
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE) 
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE);
""""""

# Execute SQL query
delivery_data_df = execute_sql_query(sql_query)

# Calculate total orders delivered this month
total_orders = delivery_data_df['OnTimeCount'][0] + delivery_data_df['LateCount'][0]

# Create a DataFrame for percentage calculation
percentage_df = pd.DataFrame({
    'Status': ['On Time', 'Late'],
    'Percentage': [
        (delivery_data_df['OnTimeCount'][0] / total_orders) * 100,
        (delivery_data_df['LateCount'][0] / total_orders) * 100
    ]
})

# Create a pie chart with Plotly
fig = px.pie(percentage_df, names='Status', values='Percentage', title='Order Delivery on Time This Month')

# Show the pie chart
show_to_user(fig)
```",The input code incorrectly checks the condition for on-time and late delivery by comparing `OrderDate` with `ShippedDate`. This should be a comparison between `ShippedDate` and `RequiredDate` as per the reference implementation. The logic differs from the reference that checks if `ShippedDate` is less than or equal to `RequiredDate` for on-time deliveries.,Base
"Which suppliers are located in 'USA' and how many products do they supply? Additionally, can you provide a bar chart to visualize the number of products supplied by each supplier?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve necessary data
sql_query = """"""
SELECT CompanyName, COUNT(ProductID) as ProductCount 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE Country = 'USA' 
GROUP BY CompanyName;
""""""

# Execute the SQL query to get data
suppliers_data = execute_sql_query(sql_query)

# Check if data retrieval was successful
if not suppliers_data.empty:
    # Generate bar chart visualization
    fig = px.bar(suppliers_data, 
                 x='CompanyName', 
                 y='ProductCount', 
                 title='Number of Products Supplied by USA Suppliers',
                 labels={'CompanyName': 'Supplier', 'ProductCount': 'Number of Products'})

    # Display the visualization
    show_to_user(fig)
else:
    # Display a message if no data is obtained
    show_to_user(pd.DataFrame({'Message': ['No suppliers found in USA with associated products']}))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE s.Country = 'USA'
GROUP BY s.CompanyName
""""""
suppliers_data = execute_sql_query(sql_query)

fig = px.bar(suppliers_data, x='CompanyName', y='ProductCount', title='Number of Products Supplied by Each Supplier in the USA')
show_to_user(fig)
```","The input code does not handle the case where `suppliers_data` might be empty, which can lead to an error when attempting to create a bar chart with no data. The reference code handles this with a check and provides a message if no data is found.","```python
import pandas as pd
import plotly.express as px

# Assuming we have the function execute_sql_query available from the utility module
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for the purpose of this example
    # Replace with the actual implementation
    pass

def show_to_user(data):
    # Mock implementation for the purpose of this example
    # Replace with the actual implementation
    pass

# SQL query based on the request
sql_query = """"""
SELECT suppliers.CompanyName, COUNT(products.ProductID) AS ProductCount
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
WHERE suppliers.Country = 'USA'
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of products supplied by each supplier
fig = px.bar(df, x='CompanyName', y='ProductCount', title='Number of Products Supplied by Each Supplier in USA')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the required functionality according to the business analytics request and the reference implementation. It uses SQL to retrieve suppliers located in the USA and counts the products they supply, groups by the supplier name, and utilizes Plotly Express to create a bar chart. Differences in variable names like 'df' instead of 'suppliers_data' do not affect the logic or outcome. Moreover, both implementations handle chart generation and output display similarly, meaning the input code is functionally equivalent to the reference code.",Finetuned
"Which employee has the most orders shipped on time, and can this be visualized in a bar chart showing each employee and their respective on-time orders?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # This is a placeholder for the actual implementation that connects to a database.
    # Here we assume it returns a pandas DataFrame for the given SQL query.
    pass

def show_to_user(data):
    # This function will display the data or visualization to the user.
    pass

# SQL query to find all employees and their on-time orders
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OnTimeOrders
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE orders.ShippedDate <= orders.RequiredDate
GROUP BY employees.EmployeeID
ORDER BY OnTimeOrders DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the data using Plotly
fig = px.bar(df, x='EmployeeID', y='OnTimeOrders', title='On-Time Orders by Employee', 
             labels={'EmployeeID': 'Employee ID', 'OnTimeOrders': 'On-Time Orders'})

# Show the figure using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    COUNT(o.OrderID) AS OnTimeOrders
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
WHERE 
    o.ShippedDate <= o.RequiredDate
GROUP BY 
    e.EmployeeID
ORDER BY 
    OnTimeOrders DESC
""""""

employee_on_time_orders = execute_sql_query(sql_query)

top_employee = employee_on_time_orders.iloc[0]

fig = px.bar(employee_on_time_orders, 
              x='EmployeeName', 
              y='OnTimeOrders', 
              title='On-Time Orders Shipped by Each Employee',
              labels={'OnTimeOrders': 'Number of On-Time Orders'},
              color='OnTimeOrders')

show_to_user(fig)
```","The input Python code correctly answers the business analytics request and follows the same logic as the reference implementation. It executes the SQL query to find employees and their on-time orders, joining the employees and orders tables, and using a condition on ShippedDate and RequiredDate. The query groups employees by EmployeeID and orders the result by the number of on-time orders. The code then visualizes the data using Plotly's bar chart, similar to the reference code. The addition of 'EmployeeName' does not affect the correctness for the given task, as it aids in visualization.","```python
import pandas as pd
import plotly.express as px

# Business Analytic Request Function
def main():
    # Define the SQL query to get the on-time shipped orders for each employee
    sql_query = """"""
    SELECT 
        employees.EmployeeID, 
        COUNT(orders.OrderID) AS OnTimeOrders 
    FROM 
        employees 
        JOIN orders ON employees.EmployeeID = orders.EmployeeID 
    WHERE 
        orders.ShippedDate <= orders.RequiredDate 
    GROUP BY 
        employees.EmployeeID 
    ORDER BY 
        OnTimeOrders DESC;
    """"""

    # Execute the SQL query and get the result as a DataFrame
    df = execute_sql_query(sql_query)

    # Visualize the on-time orders using a bar chart
    fig = px.bar(df, x='EmployeeID', y='OnTimeOrders', 
                 title='On-Time Orders by Employee',
                 labels={'OnTimeOrders': 'On-Time Orders', 'EmployeeID': 'Employee ID'},
                 text='OnTimeOrders')

    # Show the bar chart to the user
    show_to_user(fig)

# Execute the main function to run the analysis and visualization
main()
```","The input Python code executes the same SQL query as the reference code to calculate the number of on-time shipped orders for each employee. It then visualizes the results using a bar chart with Plotly, similarly ordering and labeling the chart. Although the chart includes 'text' to display the order numbers on the bars, this is a minor addition and doesn't affect the correctness regarding the business request. Overall, the input code adheres to the same logic as the reference implementation.",both
Which are the top 5 products by sales revenue? Include a bar chart for better visualization.,"```python
import plotly.express as px

# SQL query to retrieve top 5 products by sales revenue
sql_query = """"""
SELECT [Order Details].ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS ProductSales 
FROM [Order Details] 
GROUP BY [Order Details].ProductID 
ORDER BY ProductSales DESC 
LIMIT 5;
""""""

# Function to execute SQL query and get results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly for better visualization
fig = px.bar(df, x='ProductID', y='ProductSales', title='Top 5 Products by Sales Revenue')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalRevenue DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='TotalRevenue', title='Top 5 Products by Sales Revenue')
show_to_user(fig)
```","Both implementations retrieve the top 5 products by sales revenue, calculated using the formula 'UnitPrice * Quantity * (1 - Discount)', and visualize the results using a bar chart in Plotly. The evaluated code joins with the 'orders' table, which does not impact the overall logic of summing the revenue grouped by ProductID. The slight variations between the two SQL queries do not affect the correctness as they produce the same outcome.","```python
import plotly.express as px
import pandas as pd

# Assume the utility function execute_sql_query is already implemented

# Define the SQL query to get the top 5 products by sales revenue
sql_query = """"""
SELECT P.ProductID, P.ProductName, SUM(OD.Quantity * OD.UnitPrice) AS SalesRevenue
FROM products P
JOIN [Order Details] OD ON P.ProductID = OD.ProductID
GROUP BY P.ProductID, P.ProductName
ORDER BY SalesRevenue DESC
LIMIT 5;
""""""

# Execute SQL query using the utility function
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly for better visualization
fig = px.bar(
    top_products_df,
    x='ProductName',
    y='SalesRevenue',
    title='Top 5 Products by Sales Revenue',
    labels={'ProductName': 'Product Name', 'SalesRevenue': 'Sales Revenue'},
    text='SalesRevenue'
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code does not include the discount calculation present in the reference implementation. The sales revenue in the input is calculated using only Quantity and UnitPrice, but it should also account for any discounts applied, which is essential for accurate sales revenue. To match the reference logic, the code should include discount consideration in the calculation.",Base
Calculate the average fulfillment time for shipped orders and visualize the results using a histogram.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to calculate average fulfillment time
sql_query = """"""
SELECT DATEDIFF(orders.ShippedDate, orders.OrderDate) AS fulfillment_time 
FROM orders 
WHERE orders.ShippedDate IS NOT NULL
""""""

# Function to execute SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Hypothetical implementation
    # Replace this with actual database execution logic
    pass

# Function to show results to the user
def show_to_user(data):
    # Hypothetical implementation
    # Replace this with actual display logic
    pass

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the mean fulfillment time
avg_fulfillment_time = df['fulfillment_time'].mean()
print(f""The average fulfillment time for shipped orders is {avg_fulfillment_time} days."")

# Visualize the results using a histogram
fig = px.histogram(df, x='fulfillment_time', title='Distribution of Fulfillment Times')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS average_fulfillment_time FROM orders WHERE ShippedDate IS NOT NULL""
fulfillment_data = execute_sql_query(sql_query)

fig = px.histogram(fulfillment_data, x=""average_fulfillment_time"", title=""Average Fulfillment Time Histogram"")
show_to_user(fig)
```","The input code calculates the average fulfillment time directly in the SQL query, returning a single average value, not individual fulfillment times. The histogram attempts to plot a single average value, which is not meaningful. In contrast, the reference code calculates individual fulfillment times first, then computes the average separately, and plots a histogram of those individual times.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Function implementation that connects to the database and retrieves the data
    pass

# Function to display data or visualization results
def show_to_user(data):
    # Function implementation that displays the data or plot
    pass

# SQL Query to calculate average fulfillment time
sql_query = '''
SELECT DATEDIFF(shipped_date, order_date) AS fulfillment_time 
FROM orders 
WHERE orders.shipped_date IS NOT NULL;
'''

# Execute the SQL query to get the fulfillment times
fulfillment_times_df = execute_sql_query(sql_query)

# Calculate average fulfillment time
avg_fulfillment_time = fulfillment_times_df['fulfillment_time'].mean()
print(f""Average Fulfillment Time: {avg_fulfillment_time} days"")

# Visualize fulfillment times using a histogram
fig = px.histogram(
    fulfillment_times_df, 
    x='fulfillment_time', 
    title='Histogram of Fulfillment Times',
    labels={'fulfillment_time': 'Fulfillment Time (days)'},
    nbins=20
)

# Show the histogram to the user
show_to_user(fig)
```","The input code correctly calculates the average fulfillment time for shipped orders and visualizes the results using a histogram, adhering to the same logic as the reference implementation. Both implementations use a SQL statement to calculate the date difference (fulfillment time) for orders with non-null shipped dates, compute the average fulfillment time using pandas, and display a histogram using Plotly.",Finetuned
"What was the most common order month for new customers, and can you provide a bar chart to illustrate the distribution of order months?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the order month and count of new customers
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM o.OrderDate) AS OrderMonth, 
    COUNT(o.CustomerID) AS NewCustomerCount 
FROM 
    orders o 
JOIN 
    customers c ON o.CustomerID = c.CustomerID 
WHERE 
    o.OrderDate = c.RegisterDate 
GROUP BY 
    OrderMonth 
ORDER BY 
    NewCustomerCount DESC
""""""

# Execute the SQL query and store the result in a DataFrame
order_month_data = execute_sql_query(sql_query)

# Get the most common order month (already ordered by count desc)
most_common_order_month = order_month_data.iloc[0]['OrderMonth']

# Create a bar chart using Plotly
fig = px.bar(order_month_data, x='OrderMonth', y='NewCustomerCount', 
             title='Distribution of Order Months for New Customers',
             labels={'OrderMonth': 'Order Month', 'NewCustomerCount': 'Number of New Customers'})

# Show the bar chart to the user
show_to_user(fig)

# Optionally, show the most common order month
most_common_result = pd.DataFrame({
    'MostCommonOrderMonth': [most_common_order_month],
    'NewCustomerCount': [order_month_data.iloc[0]['NewCustomerCount']]
})

# Show the result to the user
show_to_user(most_common_result)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the order months for new customers
sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth
FROM 
    orders o
JOIN 
    customers c ON o.CustomerID = c.CustomerID
WHERE 
    c.CustomerID NOT IN (SELECT DISTINCT CustomerID FROM orders WHERE OrderDate < o.OrderDate)
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Count the frequency of each order month
order_month_counts = data['OrderMonth'].value_counts().reset_index()
order_month_counts.columns = ['OrderMonth', 'Count']

# Identify the most common order month
most_common_month = order_month_counts.loc[order_month_counts['Count'].idxmax()]

# Create a bar chart
fig = px.bar(order_month_counts, x='OrderMonth', y='Count', title='Distribution of Order Months for New Customers')
show_to_user(fig)

most_common_month
```","The input Python code does not correctly implement the business analytics request. The primary issue lies in the SQL query logic. The reference code extracts orders made on the same day as the customer registration, indicating a 'new customer' as one who places an order on their registration date. The input code tries to determine a new customer by ensuring there are no prior orders for a customer before the current order's date, which may include new customers but based on different criteria. Thus, the logic for identifying 'new customers' differs between the reference and the input code, rendering the input implementation incorrect for the task as specified.","```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve order months for new customers
sql_query = """"""
SELECT EXTRACT(MONTH FROM orders.OrderDate) AS order_month, COUNT(*) AS order_count
FROM orders
JOIN customers ON orders.CustomerID = customers.CustomerID 
WHERE DATEDIFF(orders.OrderDate, customers.RegistrationDate) < 30
GROUP BY order_month
ORDER BY order_month;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the distribution of order months
fig = px.bar(df, x='order_month', y='order_count',
             title='Distribution of Order Months for New Customers',
             labels={'order_month': 'Order Month', 'order_count': 'Number of Orders'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code differs from the reference code in identifying new customers. The reference code assumes new customers are those where the order date matches the registration date exactly. However, the input code considers orders made within 30 days of registration, which does not adhere to the same logic as the reference implementation. Therefore, the input code is not correct with respect to fulfilling the specified business request.",None
"What is the customer lifetime value for customers in the USA, and can it be visualized using a distribution chart to show the variance in values?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    customers.CustomerID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    customers ON orders.CustomerID = customers.CustomerID 
WHERE 
    customers.Country = 'USA' 
GROUP BY 
    customers.CustomerID
""""""

# Execute the SQL query to get the data
customer_lifetime_df = execute_sql_query(sql_query)

# Visualize the customer lifetime value using a distribution chart
fig = px.histogram(customer_lifetime_df, x='customer_lifetime_value', nbins=30, 
                   title='Customer Lifetime Value Distribution in USA', 
                   labels={'customer_lifetime_value': 'Customer Lifetime Value'})

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN customers ON orders.CustomerID = customers.CustomerID
WHERE customers.Country = 'USA'
GROUP BY customers.CustomerID
""""""

lifetime_value_df = execute_sql_query(sql_query)

fig = px.histogram(lifetime_value_df, 
                   x='customer_lifetime_value', 
                   title='Customer Lifetime Value Distribution for USA Customers',
                   labels={'customer_lifetime_value': 'Customer Lifetime Value'})

show_to_user(fig)
```","Both the reference and input implementations perform the same logical steps to calculate the customer lifetime value for customers in the USA. They execute a SQL query to aggregate purchase values by customer, filter on the USA, and visualize the distribution of the lifetime values with a histogram. The differences in variable names and minor labeling do not affect the correctness of the code according to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are pre-defined utility functions.
def calculate_and_visualize_clv():
    # SQL query to fetch the required data
    sql_query = """"""
    SELECT
        customers.CustomerID,
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value
    FROM
        [Order Details]
    JOIN
        orders ON [Order Details].OrderID = orders.OrderID
    JOIN
        customers ON orders.CustomerID = customers.CustomerID
    WHERE
        customers.Country = 'USA'
    GROUP BY
        customers.CustomerID
    """"""

    # Execute the SQL query and get the data
    data = execute_sql_query(sql_query)

    # Visualize the customer lifetime value using a distribution chart
    fig = px.histogram(
        data,
        x='customer_lifetime_value',
        nbins=30,
        title='Distribution of Customer Lifetime Value for Customers in the USA',
        labels={'customer_lifetime_value': 'Customer Lifetime Value'},
        template='plotly'
    )

    # Display the figure to the user
    show_to_user(fig)

# Execute the function
calculate_and_visualize_clv()
```","The input code meets the business analytics request and adheres to the same logic as the reference implementation. Both codes execute the same SQL query to retrieve the customer lifetime value for customers in the USA, and both use Plotly Express to create a histogram to visualize the distribution of these values. The differences in the function name and additional parameters like 'template' do not impact the correctness or the implementation logic.",both
"Which product has the highest total sales revenue, and can this be illustrated using a bar chart to compare revenue across all products?","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a mock function. Replace with actual implementation.
    # For demonstration purposes, let's assume it returns a DataFrame.
    pass

# Utility function to display data or visualization
def show_to_user(data):
    # This is a mock function to demonstrate the output.
    # It should display the data or visualization.
    pass

# SQL query to fetch total sales revenue by product
sql_query = '''
SELECT 
    ProductName, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalRevenue 
FROM 
    products 
JOIN 
    [Order Details] 
ON 
    products.ProductID = [Order Details].ProductID 
GROUP BY 
    ProductName 
ORDER BY 
    TotalRevenue DESC;
'''

# Execute the SQL query and fetch the results into a DataFrame
df_sales_revenue = execute_sql_query(sql_query)

# Visualize the total sales revenue across all products using a bar chart
fig = px.bar(df_sales_revenue, x='ProductName', y='TotalRevenue', title='Total Sales Revenue by Product')

# Display the bar chart
show_to_user(fig)

# Additionally, find the product with the highest total sales revenue
highest_selling_product = df_sales_revenue.iloc[0]

# Display the product with the highest total sales revenue
show_to_user(pd.DataFrame([highest_selling_product]))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    TotalRevenue DESC
""""""

revenue_data = execute_sql_query(sql_query)

highest_revenue_product = revenue_data.iloc[0]
fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', title='Total Sales Revenue per Product', labels={'TotalRevenue': 'Revenue', 'ProductName': 'Product'})
show_to_user(fig)
```","The input code calculates `TotalRevenue` using `SUM(od.Quantity * od.UnitPrice * (1 - od.Discount))`, which accounts for discounts. This logic differs from the reference code, which calculates `TotalRevenue` without considering discounts using `SUM([Order Details].Quantity * [Order Details].UnitPrice)`. Thus, the input code does not follow the same logic as the reference code. Also, the input code does not explicitly display the product with the highest total sales revenue, which is shown in the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str):
    # This is a placeholder function that simulates query execution.
    # In production, this connects to the database and returns data as a DataFrame.
    # Example DataFrame is returned here for demonstration purposes.
    data = {'ProductName': ['Product A', 'Product B', 'Product C'],
            'TotalRevenue': [3000, 4500, 2500]}
    return pd.DataFrame(data)

# SQL query to get the total revenue for each product
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalRevenue DESC
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Find the product with the highest total sales revenue
highest_revenue_product = df.iloc[0]

# Display the highest revenue product details
show_to_user(highest_revenue_product)

# Create a bar chart for revenue comparison across all products
fig = px.bar(df, x='ProductName', y='TotalRevenue',
             title='Total Revenue by Product',
             labels={'ProductName': 'Product', 'TotalRevenue': 'Total Revenue'})

# Display the bar chart
show_to_user(fig)
```","The evaluated input code includes an additional calculation by factoring in discounts (`(1 - od.Discount)`) that is not present in the reference implementation. This affects the total revenue calculation and consequently contradicts the logic of the reference code. Consequently, the highest revenue product identified might differ, and therefore the logic does not strictly adhere to the reference implementation.",None
What percentage of orders have a shipping address in the 'California' region? Visualize the percentage with a pie chart.,"```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL query
def execute_sql_query(sql_query: str):
    # Placeholder for actual SQL execution which returns a pandas DataFrame
    # This function is assumed to be already implemented
    pass

# Utility function to show data or graphs to the user
def show_to_user(data):
    # Placeholder to display data or graphs
    # This function is assumed to be already implemented
    pass

# SQL query to find the percentage of orders shipped to the California region
sql_query = '''
SELECT (COUNT(OrderID) FILTER (WHERE ShipRegion = 'California') * 100.0 / COUNT(OrderID)) AS PercentageInCalifornia 
FROM orders;
'''

# Execute the SQL query and get the result in a pandas DataFrame
percentage_df = execute_sql_query(sql_query)

# Extract the percentage for visualization
percentage_in_california = percentage_df['PercentageInCalifornia'].iloc[0]

# Create a pie chart with Plotly
fig = px.pie(
    names=['California', 'Other Regions'],
    values=[percentage_in_california, 100 - percentage_in_california],
    title='Percentage of Orders in the California Region'
)

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(*) AS total_orders,
    SUM(CASE WHEN ShipRegion = 'California' THEN 1 ELSE 0 END) AS california_orders
FROM 
    orders
""""""

orders_df = execute_sql_query(sql_query)

total_orders = orders_df['total_orders'][0]
california_orders = orders_df['california_orders'][0]
california_percentage = (california_orders / total_orders) * 100

labels = ['California', 'Other']
values = [california_percentage, 100 - california_percentage]

fig = px.pie(values=values, names=labels, title='Percentage of Orders with Shipping Address in California')
show_to_user(fig)
```","The input code correctly calculates the percentage of orders with a shipping address in the 'California' region using a SQL query. It counts total orders and orders specifically shipped to California, computes the required percentage, and then visualizes it with a pie chart using Plotly. This logic is consistent with the reference implementation, even though the SQL query structure differs slightly. Both implementations achieve the same result and present the data using a pie chart.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are already defined

# Define the SQL query to find percentage of orders with shipping address in California
sql_query = """"""
SELECT 
    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders)) AS california_percentage 
FROM 
    orders 
WHERE 
    ShippingRegion = 'California';
""""""

# Execute the SQL query and get the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Calculate percentage of orders not in California
percent_not_california = 100 - result_df['california_percentage'][0]

# Create a DataFrame for visualization
visualization_df = pd.DataFrame({
    'Region': ['California', 'Other'],
    'Percentage': [result_df['california_percentage'][0], percent_not_california]
})

# Create a pie chart using Plotly
fig = px.pie(visualization_df, names='Region', values='Percentage', 
             title='Percentage of Orders Shipped to California')

# Display the pie chart
show_to_user(fig)
```","The input code correctly calculates the percentage of orders with shipping addresses in California using a SQL query. It selects the count of such orders and divides it by the total number of orders to get the percentage. The result is visualized with a pie chart in Plotly. Both implementations adhere to the intended logic of calculating and visualizing the percentage, albeit with slight variations in SQL syntax and DataFrame handling.",both
Which suppliers provide products that have been ordered more than 100 times? Include a chart showing the frequency of orders per supplier.,"
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SupplierID, COUNT(od.ProductID) as OrderFrequency
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY SupplierID 
HAVING COUNT(od.ProductID) > 100;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
suppliers_df = execute_sql_query(sql_query)

# Create a bar chart of order frequency per supplier
fig = px.bar(suppliers_df, x='SupplierID', y='OrderFrequency', title='Order Frequency Per Supplier')

# Display the figure
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, COUNT(od.Quantity) AS OrderCount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.SupplierID
HAVING COUNT(od.Quantity) > 100
""""""

supplier_orders_df = execute_sql_query(sql_query)

order_frequency_plot = px.bar(supplier_orders_df, 
                               x='SupplierID', 
                               y='OrderCount', 
                               title='Frequency of Orders per Supplier',
                               labels={'SupplierID': 'Supplier ID', 'OrderCount': 'Number of Orders'})

show_to_user(order_frequency_plot)
```","The provided input code achieves the same objective as the reference code. Both queries count the number of times products supplied by each SupplierID are ordered and filter for those with a count greater than 100. They use the same join between the 'Order Details' and 'products' tables. The input code counts 'od.Quantity' while the reference counts 'od.ProductID', but since both reside within the same joined query context and focus on SupplierID, the approach effectively aligns with the intended analytics request. Additionally, both implementations use Plotly to visualize the results with similar bar charts.","```python
import pandas as pd
import plotly.express as px

# Given SQL query to extract suppliers with products ordered more than 100 times
sql_query = """"""
SELECT SupplierID 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY SupplierID 
HAVING SUM(Quantity) > 100;
""""""

# Execute the SQL query using the utility function to get suppliers
suppliers_df = execute_sql_query(sql_query)

# Count frequency of orders per supplier
order_frequency = suppliers_df['SupplierID'].value_counts().reset_index()
order_frequency.columns = ['SupplierID', 'Frequency']

# Create a bar chart to visualize the frequency of orders per supplier
fig = px.bar(order_frequency, x='SupplierID', y='Frequency', 
             title='Frequency of Orders per Supplier',
             labels={'Frequency': 'Number of Orders'},
             template='plotly')

# Display the figure
show_to_user(fig)
```","The input Python code is incorrect because it uses `SUM(Quantity) > 100` instead of `COUNT(od.ProductID) > 100` as in the reference. This means the input code checks for total quantity ordered rather than the number of orders. Additionally, it counts the frequency of the SupplierID after retrieving the query results, whereas the reference directly provides order frequency in the SQL query. These differences result in a different logic than requested.",Base
Which shipping method had the highest number of delays in the last quarter? Include a bar chart to visualize the number of delays per shipping method.,"```python
import plotly.express as px
import pandas as pd

# SQL Query to fetch delays per shipping method for the last quarter
sql_query = """"""
SELECT ShipVia, COUNT(*) AS Delays 
FROM orders 
WHERE ShippedDate > RequiredDate 
AND TO_CHAR(OrderDate, 'YYYY-Q') = TO_CHAR(DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months', 'YYYY-Q') 
GROUP BY ShipVia 
ORDER BY Delays DESC;
""""""

# Execute the query and get the result as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Function implementation for executing SQL and returning DataFrame
    pass

# Execute the SQL query
delays_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the delays per shipping method
fig = px.bar(delays_df, x='ShipVia', y='Delays', title='Number of Delays per Shipping Method in the Last Quarter')

# Show the visualization
def show_to_user(data):
    # Function implementation to display data or figure
    pass

show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Get the last quarter date range
last_quarter_start = pd.to_datetime(pd.to_datetime('today').replace(day=1) - pd.offsets.DateOffset(months=3)).replace(day=1).date()
last_quarter_end = pd.to_datetime(pd.to_datetime('today').replace(day=1) - pd.offsets.DateOffset(days=1)).date()

# SQL query to retrieve the number of delays per shipping method
sql_query = f""""""
SELECT ShipVia, COUNT(OrderID) AS DelayCount
FROM orders
WHERE ShippedDate > RequiredDate AND OrderDate BETWEEN '{last_quarter_start}' AND '{last_quarter_end}'
GROUP BY ShipVia
ORDER BY DelayCount DESC
""""""

# Execute the query
delays_df = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(delays_df, x='ShipVia', y='DelayCount', title='Number of Delays per Shipping Method Last Quarter',
             labels={'ShipVia': 'Shipping Method', 'DelayCount': 'Number of Delays'})

# Show the result
show_to_user(fig)
```","The input code effectively accomplishes the request by calculating the number of shipping delays for orders placed in the last quarter and visualizing the result with a bar chart, similar to the reference implementation. Although the method of calculating the last quarter's date range differs, it still achieves the same outcome. Additionally, both codes organize query results by delays and plot them, conforming to the requirements.","```python
import plotly.express as px
import pandas as pd

# SQL query to retrieve shipping methods with the highest delays in the last quarter
sql_query = """"""
    SELECT ShipVia, COUNT(*) AS delayed_shipments 
    FROM orders 
    WHERE ShippedDate > '2023-07-01' AND ShippedDate < '2023-10-01' 
    AND ShippedDate > RequiredDate 
    GROUP BY ShipVia 
    ORDER BY delayed_shipments DESC;
""""""

# Execute the SQL query to get the data
delays_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(delays_df, x='ShipVia', y='delayed_shipments', 
             title='Number of Delays per Shipping Method in Last Quarter',
             labels={'ShipVia': 'Shipping Method', 'delayed_shipments': 'Number of Delays'},
             text_auto=True)

# Display the visualization to the user
show_to_user(fig)
```","The input code does not dynamically determine the last quarter based on the current date like the reference code. Instead, it uses static dates ('2023-07-01' to '2023-10-01'), which would only be correct if those dates are indeed the last quarter from the current date. The reference code ensures flexibility by calculating the last quarter dynamically. This discrepancy affects the accuracy of identifying the correct data for analysis.",Base
"Analyze the impact of employee birth month on sales performance, and provide a visualization to highlight any trends or patterns.","```python
import pandas as pd
import plotly.express as px

# Provided utility function that simulates executing an SQL query and returns a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated SQL query execution
    # This would normally contain the logic to connect to a database and execute sql_query
    pass

# Provided utility function to display the result
def show_to_user(data):
    # Simulated function for displaying data or a plotly figure
    pass

# SQL query to execute
sql_query = """"""
SELECT e.EmployeeID, 
       MONTH(e.BirthDate) AS BirthMonth, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, MONTH(e.BirthDate);
""""""

# Execute the SQL query and get the data as a DataFrame
employee_sales_df = execute_sql_query(sql_query)

# Group by BirthMonth to get the total sales by month
monthly_sales_df = employee_sales_df.groupby('BirthMonth')['TotalSales'].sum().reset_index()

# Create a plotly bar chart to visualize sales by birth month
fig = px.bar(monthly_sales_df, x='BirthMonth', y='TotalSales', title='Total Sales by Employee Birth Month')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    MONTH(e.BirthDate) AS BirthMonth,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, MONTH(e.BirthDate)
""""""

data = execute_sql_query(sql_query)

sales_by_birth_month = data.groupby('BirthMonth').agg({'TotalSales': 'sum'}).reset_index()

fig = px.bar(sales_by_birth_month, x='BirthMonth', y='TotalSales', 
             title='Total Sales by Employee Birth Month',
             labels={'BirthMonth': 'Birth Month', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It executes an identical SQL query to fetch employee sales data by birth month, performs grouping and aggregation to calculate total sales by birth month, and uses Plotly to create a bar chart for visualization. The key elements, such as grouping, aggregation, and visualization, match the reference implementation. Thus, the input code satisfies the business analytics request as specified.","```python
import pandas as pd
import plotly.express as px

def analyze_employee_birth_month_on_sales():
    # SQL query provided
    sql_query = """"""
    SELECT TO_CHAR(E.BirthDate, 'MM') AS BirthMonth, 
           SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS MonthlySales 
    FROM employees E 
    JOIN orders O ON E.EmployeeID = O.EmployeeID 
    JOIN ""Order Details"" OD ON O.OrderID = OD.OrderID 
    GROUP BY TO_CHAR(E.BirthDate, 'MM');
    """"""
    
    # Execute the SQL query and load data into a DataFrame
    sales_data = execute_sql_query(sql_query)
    
    # Ensure 'BirthMonth' is treated as a categorical variable
    sales_data['BirthMonth'] = sales_data['BirthMonth'].astype(int)
    sales_data.sort_values(by='BirthMonth', inplace=True)
    
    # Visualization using Plotly
    fig = px.bar(sales_data, x='BirthMonth', y='MonthlySales', 
                 labels={'BirthMonth': 'Birth Month', 'MonthlySales': 'Sales'},
                 title='Impact of Employee Birth Month on Sales Performance')
    
    # Display the visualization to the user
    show_to_user(fig)

# Function call to execute the analysis and visualization
analyze_employee_birth_month_on_sales()
```","The input code correctly implements the business analytics request and adheres to the same logic as the reference code. It retrieves total sales grouped by the employee's birth month, executes an SQL query to retrieve necessary data, and visualizes the sales data using a Plotly bar chart. While there are differences in syntax, such as using `TO_CHAR` instead of `MONTH`, and slight naming differences like 'MonthlySales' instead of 'TotalSales', the core logic remains consistent. Both implementations compute sales performance based on the birth month and visualize the results in a bar chart.",both
"What is the total freight cost for each shipping country, and could you provide a bar chart to visualize the costs by country?","import pandas as pd
import plotly.express as px

# Sample SQL query
sql_query = """"""
SELECT orders.ShipCountry, SUM(orders.Freight) AS TotalFreight 
FROM orders 
GROUP BY orders.ShipCountry
""""""

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ShipCountry', y='TotalFreight', 
             title='Total Freight Cost by Shipping Country')

# Display the bar chart
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipCountry
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Shipping Country')
show_to_user(fig)
```","The input Python code accomplishes the same task as the reference implementation. Both codes execute an SQL query to calculate the total freight cost for each shipping country and create a bar chart using Plotly to visualize the results. The SQL query and the chart creation logic are identical, fulfilling the business analytics request.","```python
import plotly.express as px

# Execute the SQL query to get the total freight cost per shipping country
sql_query = '''
SELECT ShipCountry, SUM(Freight) AS TotalFreight FROM orders GROUP BY ShipCountry;
'''
data_frame = execute_sql_query(sql_query)

# Create a bar chart to visualize the total freight costs by country
fig = px.bar(data_frame, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Shipping Country')

# Display the bar chart to the user
show_to_user(fig)
```","The provided Python code correctly implements the business analytics request. It executes a SQL query that retrieves the total freight cost per shipping country and then uses Plotly to create a bar chart visualizing these costs. The logic and outcome align with the reference implementation, despite minor differences in code structure and formatting.",both
"What was the average order value each month, and can we visualize this data in a line chart to identify trends or patterns over time?","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for the sake of example
    # In real usage, this function connects to a database and executes the given SQL query
    pass

def show_to_user(data):
    # Dummy implementation for the sake of example
    # In real usage, this function would display data to the user
    pass

# SQL query provided
sql_query = """"""
SELECT DATE_TRUNC('month', orders.OrderDate) AS Month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AverageOrderValue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY DATE_TRUNC('month', orders.OrderDate);
""""""

# Execute SQL query to get the DataFrame
df = execute_sql_query(sql_query)

# Generate line chart to identify trends or patterns over time
fig = px.line(df, x='Month', y='AverageOrderValue', title='Average Order Value Per Month')

# Display the line chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS average_order_value
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    DATE_TRUNC('month', o.OrderDate)
ORDER BY 
    month;
""""""

average_order_value_df = execute_sql_query(sql_query)

fig = px.line(average_order_value_df, x='month', y='average_order_value', title='Average Order Value by Month')
show_to_user(fig)
```","The input code correctly executes an SQL query to calculate the average order value by month, similar to the reference code. It uses DATE_TRUNC to aggregate the data monthly and calculates the average order value using the SUM and COUNT functions. It also generates a line chart using Plotly Express to visualize the data over time. Both implementations apply the same logic: extracting the month and computing the average order value, ensuring correctness.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS Month, 
    AVG(SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))) AS AverageOrderValue 
FROM 
    orders o 
JOIN 
    [Order Details] ON o.OrderID = [Order Details].OrderID 
GROUP BY 
    DATE_TRUNC('month', o.OrderDate);
""""""

# Execute the SQL query and retrieve the data in a DataFrame
df = execute_sql_query(sql_query)

# Convert the 'Month' column to datetime for proper plotting
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart using Plotly to show the average order value over time
fig = px.line(df, x='Month', y='AverageOrderValue', title='Average Order Value Per Month', labels={'AverageOrderValue': 'Average Order Value ($)', 'Month': 'Month'})

# Display the figure to the user
show_to_user(fig)
```","The input code applies AVG on an aggregate function (SUM), which leads to incorrect SQL syntax and logic. The reference uses SUM divided by COUNT(DISTINCT orders.OrderID) to calculate the average per order, which is correct. The query in the input would produce incorrect results if it were executable.",Base
What is the average shipping cost per order for each shipping method? Please include a bar chart to compare the average costs across different shipping methods.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL query to get average shipping costs per shipping method
sql_query = """"""
SELECT ShipVia, AVG(Freight) AS AvgShippingCost FROM orders GROUP BY ShipVia;
""""""

# Execute the SQL query and return the result as a pandas DataFrame
shipping_cost_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize average shipping costs per shipping method
fig = px.bar(shipping_cost_df, x='ShipVia', y='AvgShippingCost', 
             title='Average Shipping Cost per Order by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AvgShippingCost': 'Average Shipping Cost'},
             text='AvgShippingCost')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(Freight) AS Average_Shipping_Cost
FROM orders
GROUP BY ShipVia
""""""
df = execute_sql_query(sql_query)

fig = px.bar(df, x='ShipVia', y='Average_Shipping_Cost', 
             title='Average Shipping Cost per Order by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'Average_Shipping_Cost': 'Average Shipping Cost'})
show_to_user(fig)
```","The input code correctly implements the business analytics request by executing an SQL query to compute the average shipping cost per order for each shipping method. It uses a similar SQL query format as the reference code, grouping by 'ShipVia' and calculating 'AVG(Freight)'. The variable naming differs slightly with 'Average_Shipping_Cost' instead of 'AvgShippingCost', which does not affect the correctness. Both codes use Plotly Express to plot a bar chart comparing average costs and provide a similar visualization. The use of 'show_to_user' in both indicates equivalent results rendering. Hence, the input code adheres to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average shipping cost per order for each shipping method
sql_query = """"""
SELECT shippers.CompanyName, AVG(orders.Freight) AS avg_freight 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to compare the average costs across different shipping methods
fig = px.bar(df, x='CompanyName', y='avg_freight', 
             title='Average Shipping Cost per Order by Shipping Method',
             labels={'CompanyName': 'Shipping Method', 'avg_freight': 'Average Cost ($)'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code achieves the same business objective as the reference code. Both calculate the average shipping cost per order for each shipping method and present the results in a bar chart. The input code uses an additional join to get the `CompanyName` instead of the `ShipVia` ID, which adds clarity to the labels without affecting the correctness. The core logic and final output, a bar chart comparing the average costs across different methods, align with the reference implementation.",both
Identify the top 5 customers by order count and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str):
    # Placeholder function to simulate database query execution
    # In practice, this would interface with a database
    return pd.DataFrame({
        'CustomerID': [1, 2, 3, 4, 5],
        'OrderCount': [150, 140, 135, 130, 125]
    })

def show_to_user(data):
    # Placeholder function to simulate showing data to the user
    # This function should display a DataFrame or a Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to fetch top 5 customers by order count
sql_query = """"""
SELECT CustomerID, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""

# Fetching the data
customer_data = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(customer_data, x='CustomerID', y='OrderCount',
             title='Top 5 Customers by Order Count',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'})

# Show the bar chart visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CustomerID', y='OrderCount', title='Top 5 Customers by Order Count')
show_to_user(fig)
```","The input code correctly performs the task of identifying the top 5 customers by order count and visualizes the results using a bar chart. The SQL query in both the reference and input code orders by order count in descending order, groups by CustomerID, and limits the results to the top 5 customers. The visualization logic using Plotly is also consistent between the two codes, as both create and display a bar chart with appropriate titles and labels. Thus, the input code adheres to the logic and objective of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Business Analysis and Visualization
def analyze_top_customers():
    # SQL query to retrieve top 5 customers by order count
    sql_query = """"""
    SELECT CustomerID, COUNT(OrderID) AS OrderCount 
    FROM orders 
    GROUP BY CustomerID 
    ORDER BY OrderCount DESC 
    LIMIT 5;
    """"""
    
    # Execute the SQL query and get results in a DataFrame
    top_customers_df = execute_sql_query(sql_query)
    
    # Create a bar chart using Plotly
    fig = px.bar(top_customers_df, x='CustomerID', y='OrderCount', 
                 title='Top 5 Customers by Order Count', 
                 labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'},
                 text='OrderCount')
    
    # Display the bar chart
    show_to_user(fig)

# Run the analysis
analyze_top_customers()
```",The input Python code correctly fulfills the business analytics request. Both the reference and input code execute a similar SQL query to fetch the top 5 customers by order count and visualize the results using a bar chart. Minor differences such as column aliasing and the inclusion of the 'text' parameter in Plotly do not diverge from the initial logic or desired output.,both
"What is the average time taken from order placement to shipment for each employee, and can it be visualized with a bar chart to compare their performance?","```python
import pandas as pd
import plotly.express as px

# Placeholder function for executing SQL queries
def execute_sql_query(sql_query: str):
    # Implementation to execute SQL and return a DataFrame
    pass

# Placeholder function for displaying results
def show_to_user(data):
    # Implementation to show data or figures
    pass

# SQL query to get average shipping time for each employee
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageShippingTime 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query and load the result into a DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart to compare average shipping time across employees
fig = px.bar(df, x='EmployeeID', y='AverageShippingTime',
             title='Average Shipping Time per Employee',
             labels={'EmployeeID': 'Employee ID', 'AverageShippingTime': 'Average Shipping Time (days)'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average time from order placement to shipment for each employee
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgShipmentTime
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate IS NOT NULL
GROUP BY e.EmployeeID
""""""

# Execute the SQL query
avg_shipment_time_df = execute_sql_query(sql_query)

# Visualize the average shipment time with a bar chart
fig = px.bar(avg_shipment_time_df, 
              x='FirstName', 
              y='AvgShipmentTime', 
              title='Average Time from Order Placement to Shipment per Employee',
              labels={'AvgShipmentTime': 'Average Shipment Time (Days)', 'FirstName': 'Employee First Name'},
              color='AvgShipmentTime')

show_to_user(fig)
```","The input Python code correctly computes the average time from order placement to shipment for each employee. The logic of using an SQL query to compute the average difference between 'ShippedDate' and 'OrderDate' for each employee matches the reference implementation. Additionally, the input code includes a non-null check for 'ShippedDate', which is a valid addition to ensure data integrity. Both implementations visualize the results using a bar chart with Plotly Express, fulfilling the request for a comparative performance bar chart. The main difference is in the inclusion of employee first names in the visualization, which is an acceptable enhancement for better understanding.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration purposes
    # This would actually execute the SQL query and return a DataFrame
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query for retrieving average time from order placement to shipment for each employee
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageShipTime 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if df is empty after SQL execution
if df.empty:
    print(""No data to display"")
else:
    # Visualize the result with a bar chart to compare employee performance
    fig = px.bar(df, x='EmployeeID', y='AverageShipTime', 
                 title='Average Time from Order to Shipment per Employee', 
                 labels={'AverageShipTime': 'Average Shipment Time (Days)'})
    
    # Show the visualization to the user
    show_to_user(fig)
```","The provided Python code aligns with the reference implementation's logic. Both codes execute a SQL query to calculate the average shipping time by employee and visualize the data with a bar chart using Plotly. Differences, such as variable names ('AverageShippingTime' vs. 'AverageShipTime') and additional error handling for empty data in the input code, do not affect the core functionality.",both
"Which suppliers deliver products to the most diverse set of countries, and can this be visualized using a bar chart to compare the range of countries per supplier?","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to connect to your database and return results as a DataFrame
    pass

# Utility function to display results to the user
def show_to_user(data):
    # Assuming data is a Plotly figure or DataFrame; implementation may vary based on data nature
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query provided by the request
sql_query = """"""
SELECT s.SupplierID, COUNT(DISTINCT o.ShipCountry) AS CountryCount 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY s.SupplierID 
ORDER BY CountryCount DESC;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Visualization: Bar chart showing the number of countries per supplier
fig = px.bar(df, x='SupplierID', y='CountryCount', title='Number of Countries per Supplier', labels={'CountryCount': 'Number of Countries'})

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(DISTINCT o.ShipCountry) AS CountryCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY CountryCount DESC
""""""

suppliers_country_diversity = execute_sql_query(sql_query)

fig = px.bar(suppliers_country_diversity, x='CompanyName', y='CountryCount',
             title='Diversity of Countries Served by Suppliers',
             labels={'CompanyName': 'Supplier', 'CountryCount': 'Number of Countries'},
             color='CountryCount')
show_to_user(fig)
```","The input code is correct as it adheres to the same business logic as the reference implementation. Both codes determine which suppliers deliver to the most diverse set of countries. The input code includes an additional column, 'CompanyName', for clarity. The SQL query components remain consistent, and it correctly counts distinct 'ShipCountry' entries by 'SupplierID'. The visualization is slightly enhanced by adding color discrimination based on 'CountryCount', but this does not alter the fundamental logic or outcome. Thus, it effectively answers the business request.","
import pandas as pd
import plotly.express as px

# Assuming the presence of a function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing the SQL query
    # The actual implementation would interface with the database
    raise NotImplementedError(""This should be implemented to execute SQL queries"")

def show_to_user(data):
    # Placeholder for displaying data or graphical output
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query
sql_query = """"""
SELECT s.CompanyName, COUNT(DISTINCT o.ShipCountry) AS UniqueCountries 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON o.OrderID = od.OrderID 
GROUP BY s.CompanyName 
ORDER BY UniqueCountries DESC;
""""""

# Execute SQL query and get the results as a DataFrame
supplier_country_df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(supplier_country_df, 
             x='CompanyName', 
             y='UniqueCountries', 
             title='Number of Unique Countries Supplied by Each Supplier',
             labels={'CompanyName': 'Supplier', 'UniqueCountries': 'Unique Countries'},
             template='plotly')

# Show the bar chart
show_to_user(fig)
","The input code correctly implements the business analytics request. It evaluates which suppliers deliver to the most diverse set of countries and visualizes the data using a bar chart. The SQL query accurately counts the number of unique countries each supplier delivers to, and this is similar to the reference implementation. The main difference is that the input code uses 'CompanyName' instead of 'SupplierID' for labeling, but logically they represent the suppliers and do not affect the correctness of the analysis. The visualization and display steps follow the correct logic, matching the intent of the reference implementation.",both
"Which city has the highest number of supplier contacts, and can this information be represented in a bar chart for better clarity?","```python
import pandas as pd
import plotly.express as px

def get_city_with_highest_supplier_contacts():
    # Define the SQL query
    sql_query = """"""
    SELECT City, COUNT(ContactName) AS ContactCount
    FROM suppliers
    GROUP BY City
    ORDER BY ContactCount DESC
    """"""
    
    # Execute the SQL query and get the result in a pandas DataFrame
    df = execute_sql_query(sql_query)
    
    # Create a bar chart using Plotly
    fig = px.bar(df, x='City', y='ContactCount', title='Supplier Contacts by City')
    
    # Display the chart to the user
    show_to_user(fig)

    # Return the city with the highest number of supplier contacts
    return df.iloc[0]['City']

# Run the function to get the result
get_city_with_highest_supplier_contacts()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT City, COUNT(ContactName) AS SupplierContactCount
FROM suppliers
GROUP BY City
ORDER BY SupplierContactCount DESC
LIMIT 1;
""""""

top_city = execute_sql_query(sql_query)

bar_chart = px.bar(top_city, x='City', y='SupplierContactCount', title='City with Highest Supplier Contacts')
show_to_user(bar_chart)
```","The input code only retrieves the city with the highest supplier contacts using an SQL query with LIMIT 1, which doesn't align with the entire requirement to display a bar chart of all cities and their contact counts. The reference code obtains a list of all cities and their counts for the bar chart and then identifies the city with the highest count, which allows for proper comparison and visualization.","```python
import pandas as pd
import plotly.express as px

# Placeholder for actual SQL query execution
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is supposed to execute the given SQL query
    # and return the results as a pandas DataFrame.
    pass  # Implement database connection logic as needed

# Placeholder for actual display function
def show_to_user(data):
    # This function is supposed to take a pandas DataFrame or Plotly figure
    # and display it.
    pass  # Implement display logic for data visualization as needed

# SQL Query to identify the city with the highest number of supplier contacts
sql_query = """"""
SELECT City, COUNT(*) AS SupplierCount 
FROM suppliers 
GROUP BY City 
ORDER BY SupplierCount DESC;
""""""

# Execute the SQL query and retrieve results
supplier_data = execute_sql_query(sql_query)

# Display the DataFrame for initial analysis
show_to_user(supplier_data)

# Create a bar chart using Plotly for better clarity
fig = px.bar(supplier_data, x='City', y='SupplierCount', 
             title='Number of Supplier Contacts per City')

# Show the bar chart to the user
show_to_user(fig)
```","The input code provided does not return the city with the highest number of supplier contacts, as it only displays the data and chart without returning the specific city name. The reference implementation returns the city with the highest number of contacts as part of the function. Additionally, the reference implementation uses 'ContactName' in the SQL query, whereas the input implementation uses '*', which may lead to different counts depending on the database schema.",None
"How many products have a stock higher than their reorder level, and can this be visualized using a bar chart to show the number of products across different categories?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of products with stock higher than reorder level
sql_query_count = """"""
SELECT COUNT(*) as product_count 
FROM products 
WHERE UnitsInStock > ReorderLevel;
""""""

# SQL query to get the number of products across different categories
sql_query_category = """"""
SELECT CategoryID, COUNT(*) as num_products 
FROM products 
WHERE UnitsInStock > ReorderLevel 
GROUP BY CategoryID;
""""""

# Execute the SQL query to get counts
product_count_df = execute_sql_query(sql_query_category)

# Visualize the data using Plotly
fig = px.bar(product_count_df, x='CategoryID', y='num_products', title='Number of Products with Stock Higher than Reorder Level by Category')

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, COUNT(*) AS ProductCount
FROM products p
WHERE p.UnitsInStock > p.ReorderLevel
GROUP BY p.CategoryID
""""""

product_data = execute_sql_query(sql_query)

fig = px.bar(product_data, x='CategoryID', y='ProductCount', 
             title='Number of Products with Stock Higher than Reorder Level',
             labels={'CategoryID': 'Category ID', 'ProductCount': 'Number of Products'})

show_to_user(fig)
```","Both the reference and input code implementations are designed to count the number of products with stock higher than their reorder level, grouped by categories. The SQL queries in both methods are correctly formulated to achieve this. The bar chart visualization in the input code effectively matches the logic for categorizing and counting products, providing the same insights as the reference implementation.","```python
import plotly.express as px

# SQL query to get products with stock higher than reorder level for each category
sql_query = """"""
SELECT 
    CategoryName AS Category, 
    COUNT(ProductID) AS Count 
FROM 
    products 
JOIN 
    categories ON products.CategoryID = categories.CategoryID
WHERE 
    UnitsInStock > ReorderLevel 
GROUP BY 
    CategoryName;
""""""

# Execute the SQL query using the provided utility function
# This returns a Pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of products across different categories
fig = px.bar(df, x='Category', y='Count', title='Products with Stock Higher than Reorder Level by Category')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference code. It queries the products with stock higher than their reorder level, grouped by category. The code then visualizes the results using a bar chart. The difference is in detail: the input code joins with the 'categories' table and groups by 'CategoryName' instead of 'CategoryID'. However, this satisfies the business requirement of visualizing the number of products across different categories and adheres to the same logical evaluation as the reference implementation.",both
"How many orders has each employee processed, and can you provide a bar chart to visualize the results?","```python
import pandas as pd
import plotly.express as px

# Use a utility function to execute the SQL query and store the results in a DataFrame
def execute_sql_query(sql_query: str):
    # Simulating the SQL execution for example purposes
    # Normally this would connect to your database and run the sql_query
    data = {
        'EmployeeID': [1, 2, 3],
        'OrderCount': [15, 25, 18]
    }
    return pd.DataFrame(data)

# SQL query to fetch the number of orders processed by each employee
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID;
""""""

# Execute the query to get a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize order counts per employee
fig = px.bar(orders_df, x='EmployeeID', y='OrderCount', 
             title='Number of Orders Processed by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OrderCount DESC
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='FirstName', y='OrderCount', 
             title='Number of Orders Processed by Each Employee',
             labels={'FirstName': 'Employee', 'OrderCount': 'Number of Orders'},
             text='OrderCount')

show_to_user(fig)
```","The input Python code groups by additional fields (FirstName, LastName), which may cause the order count to be different if there are multiple employees with the same ID but different names, leading to discrepancies compared to the reference implementation. Additionally, the bar chart uses `FirstName` instead of `EmployeeID`, potentially obscuring the results if employees share the same first name. The order of results is also modified with an ORDER BY clause, which was not present in the reference.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the orders processed by each employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID
""""""

# Execute the SQL query and retrieve the result as a DataFrame
df_orders = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of orders processed by each employee
fig = px.bar(df_orders, x='EmployeeID', y='OrderCount', title='Number of Orders Processed by Each Employee')

# Display the visualization to the user
show_to_user(fig)
```","The input code assumes that the 'orders' table alone contains the complete set of employees, which may exclude employees without orders. The reference code uses a LEFT JOIN on the 'employees' table to include all employees, ensuring that even those with zero orders are counted. Therefore, the input code may not accurately reflect the requested data for all employees, as required by the business analytics request.",None
Discover products sold in quantities exceeding 1000 units per month and visualize the results with a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) as TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
HAVING SUM(od.Quantity) > 1000;
""""""

# Execute the SQL query to get the results in a DataFrame
product_data = execute_sql_query(sql_query)

# Create a bar chart to visualize products sold in quantities exceeding 1000 units
fig = px.bar(product_data, x='ProductName', y='TotalQuantity', title='Products Sold in Quantities Exceeding 1000 Units')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity) AS TotalQuantity
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
HAVING 
    SUM(od.Quantity) > 1000
ORDER BY 
    TotalQuantity DESC
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ProductName', y='TotalQuantity', title='Products Sold Over 1000 Units per Month', labels={'TotalQuantity': 'Units Sold', 'ProductName': 'Product Name'})
show_to_user(fig)
```",The provided code correctly answers the business analytics request and follows the same logic as the reference implementation. Both codes execute a SQL query to fetch products with total quantities exceeding 1000 units and visualize the data with a bar chart. The difference in the order of columns in the SELECT clause and the inclusion of ORDER BY does not affect the correctness of the logic or the output.,"
```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, EXTRACT(MONTH FROM OrderDate) AS Month, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY ProductID, EXTRACT(MONTH FROM OrderDate) 
HAVING SUM(Quantity) > 1000;
""""""

# Execute the SQL query and get the data as a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    data,
    x='ProductID',
    y='TotalQuantity',
    color='Month',
    title='Products Sold in Quantities Exceeding 1000 Units per Month',
    labels={'TotalQuantity': 'Total Quantity', 'ProductID': 'Product ID'}
)

# Display the bar chart
show_to_user(fig)
```","The input code evaluates products sold in quantities exceeding 1000 per month by grouping by 'ProductID' and month, but the reference code groups by 'ProductName' for overall sales, not by month. Additionally, the reference implementation uses 'ProductName' for the visualization, while the input uses 'ProductID'.",Base
"Which country had the highest average order value last year, and provide a bar chart to visualize the comparison among top countries?","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch average order value by country
sql_query = """"""
SELECT Country, AVG(TotalOrderValue) AS AverageOrderValue
FROM (
    SELECT orders.CustomerID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalOrderValue, 
           customers.Country
    FROM orders
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
    JOIN customers ON orders.CustomerID = customers.CustomerID
    WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
    GROUP BY orders.OrderID, customers.Country
) AS CountryOrderAverages
GROUP BY Country
ORDER BY AverageOrderValue DESC
""""""

# Fetch data using utility function
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average order value by country
fig = px.bar(data, x='Country', y='AverageOrderValue', 
             title='Average Order Value by Country in 2022',
             labels={'AverageOrderValue': 'Average Order Value'},
             text='AverageOrderValue')

# Enhance readability
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')

# Display the figure
show_to_user(fig)

# Identifying the country with the highest average order value for additional clarity
top_country = data.loc[0, 'Country']
top_value = data.loc[0, 'AverageOrderValue']

# Create a DataFrame for the highest country result
top_country_df = pd.DataFrame({'Country': [top_country], 'AverageOrderValue': [top_value]})

# Display top country data
show_to_user(top_country_df)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the average order value by country for last year
sql_query = """"""
SELECT 
    c.Country,
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY 
    c.Country
ORDER BY 
    AverageOrderValue DESC
LIMIT 10;
""""""

# Execute the SQL query
average_order_values = execute_sql_query(sql_query)

# Create a bar chart for the average order values by country
fig = px.bar(average_order_values, 
             x='Country', 
             y='AverageOrderValue', 
             title='Average Order Value by Country (2022)', 
             labels={'AverageOrderValue': 'Average Order Value', 'Country': 'Country'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code calculates the average order value directly from `[Order Details]` without first summing the total order value per order. It differs from the reference implementation, where the total order value is computed per order, then averaged by the country. The SQL logic differs significantly, potentially leading to different results. Also, the input code selects only the top 10 countries, whereas the reference does not limit the output.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query):
    # Placeholder function: actual implementation will fetch data from database
    # For demonstration, it assumes a function returning a DataFrame
    pass

def show_to_user(data):
    # Placeholder function: actual implementation will display output
    pass

# SQL query to fetch the highest average order value per country for last year
sql_query = """"""
SELECT 
    ShipCountry, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    YEAR(o.OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY 
    ShipCountry 
ORDER BY 
    AvgOrderValue DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
average_order_values_df = execute_sql_query(sql_query)

# Select the top countries for visualization (optional: specify how many top countries)
top_n_countries = 10  # Change this number as needed
if not average_order_values_df.empty:
    # Handle the case where there are fewer than top_n_countries in the DataFrame
    if len(average_order_values_df) < top_n_countries:
        top_n_countries = len(average_order_values_df)
    # Create a bar chart with Plotly
    fig = px.bar(
        average_order_values_df.head(top_n_countries), 
        x='ShipCountry', 
        y='AvgOrderValue', 
        title='Top Countries by Average Order Value (Last Year)',
        labels={'AvgOrderValue': 'Average Order Value', 'ShipCountry': 'Country'},
        template='plotly'
    )
    # Display the bar chart
    show_to_user(fig)
else:
    print(""No data available for the specified period."")
```","The input code uses 'ShipCountry' instead of 'Country', and calculates average order value as 'SUM(...) / COUNT(DISTINCT o.OrderID)', instead of using an inner query grouped by orders and then averaging these per country. Additionally, it assumes current date logic for the last year which may not align with a simple calendar year check as in the reference code. These differences in logic make the results possibly inconsistent with the business request, despite both aiming to create a similar visualization.",None
"What is the total sales revenue for each product, and can we visualize the revenue distribution using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query is a predefined function as per the environment constraints.
sql_query = """"""
SELECT 
    P.ProductName, 
    SUM(OD.Quantity * OD.UnitPrice) AS TotalRevenue 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY P.ProductName;
""""""

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue distribution
fig = px.bar(
    sales_data, 
    x='ProductName', 
    y='TotalRevenue', 
    title='Total Sales Revenue for Each Product', 
    labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'}
)

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', 
              title='Total Sales Revenue by Product', 
              labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code computes TotalRevenue using Quantity, UnitPrice, and Discount, whereas the reference does not account for discounts. This deviation affects the total revenue calculations, leading to different results. The reference implementation aligns with the business request more accurately, whereas the input introduces additional logic absent in the request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch total sales revenue for each product
sql_query = """"""
SELECT products.ProductID, ProductName, SUM(UnitPrice * Quantity) AS Revenue
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductID, ProductName
""""""

# Execute the SQL query and get the result as a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Visualize the revenue distribution using a bar chart
fig = px.bar(sales_data, x='ProductName', y='Revenue', title='Total Sales Revenue by Product')

# Display the bar chart to the user
show_to_user(fig)
```","Both implementations correctly execute an SQL query to calculate the total sales revenue for each product using a join between order details and products. The SQL logic to sum up the revenue (UnitPrice * Quantity) is consistent in both versions. The group by clause appropriately groups by product names. Additionally, both implementations create a bar chart using Plotly to visualize this revenue distribution and display the chart to the user. Although the input code uses ProductID in the group by clause, it doesn't affect the correctness of the revenue aggregation by product name.",Finetuned
Which city has the highest number of unique customers? Include a bar chart to compare the number of unique customers across different cities.,"import plotly.express as px
import pandas as pd

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution
    # In practice, this would connect to a database and return a DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    # Would show a DataFrame or Plotly figure
    pass

# SQL query to get the unique customers count per city
sql_query = """"""
SELECT City, COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM customers
GROUP BY City
ORDER BY UniqueCustomers DESC;
""""""

# Execute the SQL query to get the DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart to compare the number of unique customers across cities
fig = px.bar(df, x='City', y='UniqueCustomers', title='Unique Customers per City')

# Show the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT City, COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM customers
GROUP BY City
ORDER BY UniqueCustomers DESC
""""""
customer_data = execute_sql_query(sql_query)

highest_city = customer_data.iloc[0]
highest_city_name = highest_city['City']
highest_city_count = highest_city['UniqueCustomers']

fig = px.bar(customer_data, x='City', y='UniqueCustomers', title='Number of Unique Customers by City')
show_to_user(fig)

highest_city_name, highest_city_count
```","The input Python code correctly executes the SQL query to retrieve the count of unique customers per city, orders the data by this count, generates a bar chart using Plotly to visualize the number of unique customers by city, and identifies the city with the highest count of unique customers. The logic matches the reference implementation, fulfilling the business analytics request.","import pandas as pd
import plotly.express as px

# SQL query to get the number of unique customers by city
sql_query = """"""
SELECT 
    City, 
    COUNT(DISTINCT CustomerID) AS UniqueCustomers 
FROM 
    customers 
GROUP BY 
    City 
ORDER BY 
    UniqueCustomers DESC;
""""""

# Execute the SQL query
customer_data = execute_sql_query(sql_query)

# Create a bar chart to compare the number of unique customers across cities
fig = px.bar(
    customer_data, 
    x='City', 
    y='UniqueCustomers', 
    title='Number of Unique Customers by City',
    labels={'UniqueCustomers': 'Number of Unique Customers'}
)

# Display the bar chart
show_to_user(fig)
","The input Python code correctly implements the requested business analytics task. It uses the same SQL query to retrieve the number of unique customers by city, executes the query to get the data, and generates a bar chart using Plotly to visualize the data. The logic and outcome are consistent with the reference implementation, even though there are minor differences in naming conventions and plot labeling.",both
"How many distinct products are ordered in each country, and can you provide a bar chart to visualize this data?","
import plotly.express as px

# SQL Query
sql_query = '''
SELECT Country, COUNT(DISTINCT [Order Details].ProductID) AS DistinctProducts 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY Country;
'''

# Execute the SQL query to get the data into a pandas DataFrame
distinct_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    distinct_products_df, 
    x='Country', 
    y='DistinctProducts', 
    title='Number of Distinct Products Ordered per Country',
    labels={'DistinctProducts': 'Number of Distinct Products'}
)

# Display the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Country, COUNT(DISTINCT od.ProductID) AS DistinctProducts
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Country
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='Country', y='DistinctProducts', title='Distinct Products Ordered per Country', labels={'DistinctProducts': 'Number of Distinct Products', 'Country': 'Country'})
show_to_user(fig)
```","The input Python code correctly matches the business analytics request and adheres to the same logic as the reference implementation. Both implementations execute a similar SQL query to count distinct products ordered in each country by joining tables for customers, orders, and order details. The input code also generates a bar chart using Plotly, equivalent to the reference implementation. The differences in table aliasing and minor code syntax do not affect the correctness of the logic or output.","```python
import pandas as pd
import plotly.express as px

# SQL query to get distinct products ordered in each country
sql_query = '''
SELECT orders.ShipCountry, COUNT(DISTINCT [Order Details].ProductID) AS DistinctProducts
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.ShipCountry
'''

# Function to execute the SQL query and get the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for execution logic
    pass

# Execute the SQL query and get the DataFrame
data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize distinct products per country
fig = px.bar(data_df, x='ShipCountry', y='DistinctProducts', 
             title='Distinct Products Ordered by Country', 
             labels={'ShipCountry': 'Country', 'DistinctProducts': 'Distinct Products'})

# Display the chart to the user
def show_to_user(data):
    # Placeholder for display logic (could be a function call, etc.)
    pass

show_to_user(fig)
```","The input Python code groups by 'ShipCountry' instead of 'Country'. The reference implementation joins the 'customers' table to ensure the country is accurate, using 'Country', which may differ from 'ShipCountry'. This discrepancy means the logic isn't identical between the two implementations, potentially affecting the data aggregation.",Base
Identify employees who have never handled an order in a specific region and present the findings using a bar chart for better clarity.,"```python
import pandas as pd
import plotly.express as px

# Preset utility function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution; use a database connection in practice.
    pass

# Preset utility function to display results to the user
def show_to_user(data):
    # Placeholder for actual display mechanism.
    pass

# SQL Query to find employees who have never handled an order in a specific region
sql_query = """"""
SELECT employees.EmployeeID 
FROM employees 
WHERE NOT EXISTS (
    SELECT 1 
    FROM orders 
    WHERE orders.EmployeeID = employees.EmployeeID 
    AND orders.ShipRegion = 'SpecificRegion'
)
""""""

# Execute the SQL query and get the result as a DataFrame
employees_df = execute_sql_query(sql_query)

# Employee count is unnecessary as it's a unique list of EmployeeIDs
employee_count = employees_df['EmployeeID'].value_counts().reset_index()
employee_count.columns = ['EmployeeID', 'Count']

# Create a bar chart to visualize the findings
fig = px.bar(employee_count, x='EmployeeID', y='Count', title='Employees Not Handling Orders in Specific Region')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

region = 'SpecificRegion'  # Replace with the specific region you want to filter

# SQL query to get employees who have handled orders in the specified region
sql_query_handled_orders = f""""""
SELECT DISTINCT e.EmployeeID, e.FirstName, e.LastName
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShipRegion = '{region}'
""""""

handled_orders_df = execute_sql_query(sql_query_handled_orders)

# SQL query to get all employees
sql_query_all_employees = ""SELECT EmployeeID, FirstName, LastName FROM employees""
all_employees_df = execute_sql_query(sql_query_all_employees)

# Identify employees who have never handled an order in the specified region
never_handled_orders_df = all_employees_df[~all_employees_df['EmployeeID'].isin(handled_orders_df['EmployeeID'])]

# Count the number of employees who have never handled an order in the specified region
employee_counts = never_handled_orders_df.groupby(['FirstName', 'LastName']).size().reset_index(name='Count')

# Create a bar chart
fig = px.bar(employee_counts, x='FirstName', y='Count', title='Employees Who Never Handled Orders in Region',
             labels={'FirstName': 'Employee First Name', 'Count': 'Count of Employees'})

show_to_user(fig)
```","The input code uses the wrong level of aggregation for the bar chart. It groups by first and last names, rather than listing just EmployeeID with a count of 1. Also, grouping by first and last name could potentially combine different employees with the same name, which doesn't align with the reference code that keeps track of unique EmployeeIDs only. Additionally, the bar chart in the reference implementation uses EmployeeID as the x-axis, while the input code uses 'FirstName'.","```python
import pandas as pd
import plotly.express as px

# SQL query to get employees who have never handled an order in the 'specific' region
sql_query = """"""
SELECT EmployeeID, EmployeeName 
FROM employees 
WHERE EmployeeID NOT IN (
    SELECT DISTINCT EmployeeID 
    FROM orders 
    WHERE ShipRegion = 'specific'
);
""""""

# Execute the SQL query and fetch the data
df_employees_never_handled = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df_employees_never_handled, 
    x='EmployeeName', 
    y='EmployeeID', 
    title='Employees Never Handling Orders in the ""specific"" Region',
    labels={'EmployeeID': 'Employee ID', 'EmployeeName': 'Employee Name'}
)

# Show the bar chart
show_to_user(fig)
```","The input Python code selects 'EmployeeName' and visualizes it against 'EmployeeID', which does not match the reference logic. The reference code counts the number of times each 'EmployeeID' appears (which is unnecessary for a unique list) and plots a bar chart, whereas the input code uses 'EmployeeName' directly, implying a different visualization intent. The difference in SQL logic also affects consistency, as 'specific' in the input code differs from 'SpecificRegion' in the reference.",None
"What is the average fulfillment time for orders shipped in the last month, and can this be visualized using a histogram to show the distribution of fulfillment times?","```python
import pandas as pd
import plotly.express as px
from datetime import datetimerom dateutil.relativedelta import relativedelta

# SQL query to calculate average fulfillment time
sql_query_avg_fulfillment = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE ShippedDate BETWEEN DATEADD(MONTH, -1, CURRENT_DATE) AND CURRENT_DATE
""""""

# Execute the SQL query to get the average fulfillment time
avg_fulfillment_df = execute_sql_query(sql_query_avg_fulfillment)

# SQL query to get all fulfillment times for orders shipped last month
sql_query_fulfillment_times = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE ShippedDate BETWEEN DATEADD(MONTH, -1, CURRENT_DATE) AND CURRENT_DATE
""""""

# Execute the SQL query to get fulfillment times for histogram
fulfillment_times_df = execute_sql_query(sql_query_fulfillment_times)

# Visualize the distribution of fulfillment times using a histogram
fig = px.histogram(fulfillment_times_df, x='FulfillmentTime',
                   title='Distribution of Fulfillment Times for Last Month',
                   labels={'FulfillmentTime': 'Fulfillment Time (Days)'},
                   nbins=20)

# Show the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last month
end_date = datetime.now().date()
start_date = end_date - timedelta(days=30)

# SQL query to get the fulfillment times for orders shipped in the last month
sql_query = f""""""
SELECT DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE ShippedDate BETWEEN '{start_date}' AND '{end_date}'
""""""

# Execute the SQL query
fulfillment_data = execute_sql_query(sql_query)

# Calculate average fulfillment time
average_fulfillment_time = fulfillment_data['FulfillmentTime'].mean()

# Create a histogram for the distribution of fulfillment times
fig = px.histogram(fulfillment_data, x='FulfillmentTime', title='Distribution of Fulfillment Times', 
                   labels={'FulfillmentTime': 'Fulfillment Time (Days)'})

# Show the average fulfillment time and the histogram to the user
show_to_user(pd.DataFrame({'Average Fulfillment Time': [average_fulfillment_time]}))
show_to_user(fig)
```","The input Python code calculates dates using a `30-day` period, which may not accurately represent the previous month, especially for months not containing 30 days. The reference implementation uses `DATEADD(MONTH, -1, CURRENT_DATE)` which adjusts for the exact previous month, thus maintaining accuracy across different month lengths. Other aspects such as calculating averages, retrieving data, and visualization are consistent between both implementations.","```python
import pandas as pd
import plotly.express as px

# Function to calculate average fulfillment time and visualize the distribution
def analyze_fulfillment_time():
    # Fetching orders from the last month
    sql_query = """"""
    SELECT OrderID, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
    FROM orders
    WHERE YEAR(ShippedDate) = YEAR(CURRENT_DATE - INTERVAL '1 month')
    AND MONTH(ShippedDate) = MONTH(CURRENT_DATE - INTERVAL '1 month');
    """"""
    
    # Execute the SQL query and return the data as a pandas DataFrame
    df_orders = execute_sql_query(sql_query)
    
    # Calculate the average fulfillment time
    avg_fulfillment_time = df_orders['FulfillmentTime'].mean()
    
    # Print the average fulfillment time
    print(f""Average Fulfillment Time for last month: {avg_fulfillment_time:.2f} days"")
    
    # Visualize the distribution of fulfillment times using a histogram
    fig = px.histogram(df_orders, x='FulfillmentTime', title='Distribution of Fulfillment Times (last month)')
    
    # Display the histogram
    show_to_user(fig)

# Call the function to perform the analysis
analyze_fulfillment_time()
```","The input code uses a different method to filter orders shipped in the last month using `YEAR` and `MONTH` functions after subtracting one month from the current date. This may not align with the behavior of accounting for the whole last calendar month as in the reference code using `DATEADD(MONTH, -1, CURRENT_DATE)` and checking `BETWEEN`. Additionally, the input code does not return the calculated average; it just prints it. Both approaches should return results and visualization consistently.",None
"Which suppliers provide the most products by quantity, and how can we visualize this data to better understand the distribution?","```python
import plotly.express as px
import pandas as pd

# SQL query to get supplier data
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity) AS TotalQuantity 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID 
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Visualize the distribution of products provided by each supplier
fig = px.bar(
    supplier_data,
    x='SupplierID',
    y='TotalQuantity',
    title='Products Distribution by Supplier',
    labels={'SupplierID': 'Supplier ID', 'TotalQuantity': 'Total Quantity'},
    template='plotly'
)

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
ORDER BY TotalQuantity DESC
""""""

supplier_data = execute_sql_query(sql_query)

fig = px.bar(supplier_data, x='SupplierID', y='TotalQuantity', title='Total Products Supplied by Supplier')
show_to_user(fig)
```","The input code and the reference code both query the total quantity of products supplied by each supplier by joining products and order details tables. Although the input code does not explicitly join the suppliers table, assuming there is a direct one-to-one relationship between products and suppliers, the input code effectively achieves the same result. The visualization element is also consistent with the business request, using a bar chart to show the distribution of products by supplier. Thus, the input code adheres to the logic and fulfills the business analytics request.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the required data
sql_query = """"""
SELECT 
    suppliers.CompanyName, 
    SUM(products.UnitsInStock + products.UnitsOnOrder) AS TotalUnits 
FROM 
    suppliers 
JOIN 
    products 
ON 
    suppliers.SupplierID = products.SupplierID 
GROUP BY 
    suppliers.CompanyName 
ORDER BY 
    TotalUnits DESC;
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of products by quantity per supplier
fig = px.bar(
    df, 
    x='CompanyName', 
    y='TotalUnits', 
    title='Suppliers Providing the Most Products by Quantity',
    labels={'CompanyName': 'Supplier', 'TotalUnits': 'Total Units'},
    text='TotalUnits'
)

# Update layout for better readability
fig.update_traces(textposition='outside')
fig.update_layout(xaxis_title='Supplier', yaxis_title='Total Units', xaxis_tickangle=-45)

# Display the figure
show_to_user(fig)
```","The input code does not align with the reference implementation. The core logic differs: the input code sums 'UnitsInStock + UnitsOnOrder' for products to calculate 'TotalUnits', whereas the reference code sums 'Quantity' from 'Order Details'. Additionally, the input code groups by 'CompanyName', not 'SupplierID'. Thus, the data and logic are different, making the input code incorrect for this request.",Base
"What is the sales trend over the last 6 months for each employee, and can you provide a line chart to visualize the trends?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch sales data
sql_query = """"""
SELECT e.EmployeeID, 
       e.FirstName, 
       e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales, 
       EXTRACT(MONTH FROM o.OrderDate) as SalesMonth 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATEADD(MONTH, -6, CURRENT_DATE) 
GROUP BY e.EmployeeID, SalesMonth 
ORDER BY e.EmployeeID, SalesMonth;
""""""

# Execute SQL query and store the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Ensure data types are correct
sales_data['SalesMonth'] = sales_data['SalesMonth'].astype(int)
sales_data['TotalSales'] = sales_data['TotalSales'].astype(float)

# Create a line chart to visualize sales trends
fig = px.line(
    sales_data, 
    x='SalesMonth', 
    y='TotalSales', 
    color='EmployeeID',
    labels={'SalesMonth': 'Month', 'TotalSales': 'Total Sales'},
    title='Sales Trend Over the Last 6 Months by Employee',
    line_group='EmployeeID',
    hover_name='FirstName'
)

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve sales data for the last 6 months grouped by employee
sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
GROUP BY 
    e.EmployeeID, Month
ORDER BY 
    e.EmployeeID, Month
""""""

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Create a line chart to visualize sales trends
fig = px.line(sales_data, x='Month', y='TotalSales', color='EmployeeName',
              title='Sales Trend Over the Last 6 Months by Employee',
              labels={'TotalSales': 'Total Sales', 'Month': 'Month'},
              markers=True)

# Show the chart to the user
show_to_user(fig)
```","The provided code calculates the sales trend over the last 6 months for each employee and visualizes it with a line chart. The logic aligns with the reference implementation. Both codes: 1) fetch employee sales data over the past 6 months using SQL, 2) group the data by employee and month, 3) calculate total sales, and 4) utilize Plotly for line chart visualization. Minor differences such as column naming and date formatting are implementation variations that do not affect correctness.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
       EXTRACT(YEAR FROM orders.OrderDate) AS Year, 
       EXTRACT(MONTH FROM orders.OrderDate) AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate >= DATEADD(MONTH, -6, CURRENT_DATE) 
GROUP BY employees.EmployeeID, Year, Month 
ORDER BY employees.EmployeeID, Year, Month
""""""

# Fetch the data
sales_data = execute_sql_query(sql_query)

# Create a 'Date' column for easier plotting
sales_data['Date'] = pd.to_datetime(sales_data[['Year', 'Month']].assign(DAY=1))

# Create a line chart for sales trends
fig = px.line(
    sales_data,
    x='Date',
    y='TotalSales',
    color='EmployeeName',
    labels={'TotalSales': 'Total Sales', 'Date': 'Date'},
    title='Sales Trend Over the Last 6 Months by Employee'
)

# Display the line chart
show_to_user(fig)
```",The input code implements the same logic as the reference code. Both codes execute a SQL query to fetch sales data for each employee over the last six months and then visualize this data in a line chart. The main differences are in the SQL query aggregation detail (by year and month in input code vs. by month in reference code) and the use of a concatenated name for employees as the color label in the input code. These differences do not affect the correctness as they still adhere to the requested business analytics and provide the required line chart visualization.,both
"What is the average discount given on orders, and can you provide a visualization to illustrate the distribution of these discounts?","```python
import plotly.express as px
import pandas as pd

# SQL query to get the average discount on orders
sql_query_avg_discount = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute SQL query to get the average discount
avg_discount_df = execute_sql_query(sql_query_avg_discount)

# Display the average discount to the user
show_to_user(avg_discount_df)

# SQL query to get all discounts for visualization
sql_query_discounts = ""SELECT Discount FROM [Order Details];""

# Execute SQL query to get all discounts
discounts_df = execute_sql_query(sql_query_discounts)

# Generate a histogram to visualize the distribution of discounts
fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts')

# Display the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT AVG(Discount) AS AverageDiscount, Discount
FROM [Order Details]
GROUP BY Discount
""""""
discount_data = execute_sql_query(sql_query)

average_discount = discount_data['AverageDiscount'].mean()

fig = px.histogram(discount_data, x='Discount', title='Distribution of Discounts', 
                   labels={'Discount': 'Discount Percentage'}, nbins=30)
show_to_user(fig)

average_discount
```","The input code produces an incorrect result for the average discount because it calculates the mean of 'AverageDiscount' from a grouped DataFrame, while the reference calculates the overall average from the database. The histogram visualization is correct, but the method to compute the average discount is not aligned with the reference logic, leading to potentially inaccurate values.","```python
import pandas as pd
import plotly.express as px

# Placeholder for the actual SQL execute function
def execute_sql_query(sql_query: str):
    # This function executes the SQL query and returns a pandas DataFrame.
    # Implementation will depend on the actual database connection and query execution logic
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, go.Figure):
        data.show()

# SQL query to get the average discount
sql_query = ""SELECT Order_Details.Discount FROM Order_Details""

# Execute SQL query and get the results
discount_df = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = discount_df['Discount'].mean()

# Show the average discount to the user
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))

# Create a histogram to show the distribution of discounts
fig = px.histogram(discount_df, x='Discount', title='Distribution of Discounts on Orders')

# Show the histogram to the user
show_to_user(fig)
```
","The provided code correctly calculates the average discount and visualizes the discount distribution in a similar manner as the reference code. Both pieces of code execute a query to fetch discounts, compute the average, and display it. Likewise, both create a histogram using Plotly to show the distribution. Although the SQL query syntax slightly differs, the logical operations remain consistent with the requested task and reference implementation.",Finetuned
"Which product has the most units on order, and can we visualize this data with a bar chart for comparison?","```python
import plotly.express as px
import pandas as pd

# SQL query to get all products ordered by units on order
data_query = """"""
SELECT products.ProductID, products.ProductName, products.UnitsOnOrder
FROM products
ORDER BY products.UnitsOnOrder DESC
""""""

# Execute the SQL query using the utility function
result_df = execute_sql_query(data_query)

# Visualize the data with a bar chart
fig = px.bar(
    result_df, 
    x='ProductName', 
    y='UnitsOnOrder', 
    title='Products with Units on Order',
    labels={'UnitsOnOrder': 'Units on Order', 'ProductName': 'Product Name'}
)

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY total_quantity DESC 
LIMIT 1
""""""

top_product_df = execute_sql_query(sql_query)

sql_query_comparison = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY total_quantity DESC
""""""

comparison_df = execute_sql_query(sql_query_comparison)

fig = px.bar(comparison_df, x='ProductName', y='total_quantity', title='Product Units on Order Comparison', labels={'total_quantity':'Units on Order', 'ProductName':'Product'})
show_to_user(fig)
```","The provided code evaluates the 'Order Details' table and sums quantities to calculate the total product quantity, while the reference code uses 'UnitsOnOrder' from the 'products' table. These are different calculations and might not represent the same business metric. Consequently, the visualization and data derived do not align with the specific business analytics request to identify and compare 'Units on Order'.","```python
import pandas as pd
import plotly.express as px


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function to mimic the behavior of executing the SQL query.
    # In actual implementation, this would interact with a database and return a DataFrame.
    pass

def show_to_user(data):
    # This function is a placeholder to simulate displaying the data or visualization.
    # In practice, this would handle the output or visualization in the actual environment.
    pass

# SQL query to find the product with the most units on order
sql_query = """"""
    SELECT p.ProductName, p.UnitsOnOrder
    FROM products p
    ORDER BY p.UnitsOnOrder DESC
""""""

# Execute the SQL query and get a pandas DataFrame
df = execute_sql_query(sql_query)

# Visualization: Create a bar chart for comparison of units on order
fig = px.bar(df, x='ProductName', y='UnitsOnOrder', title='Products with Most Units on Order')

# Show the bar chart to the user
show_to_user(fig)
```","The input code adheres to the specified business analytics request and mirrors the logic of the reference code. Both implementations execute a similar SQL query to retrieve product names and units on order, sorted in descending order by units on order. They utilize Plotly Express to generate a bar chart for visualization and employ placeholder functions to simulate SQL execution and display. While variable names and slight details differ, the core logic and output adhere to the request and reference implementation.",Finetuned
Are there any suppliers with discontinued products only? Please include a visualization to show the list of such suppliers for clearer understanding.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find suppliers with only discontinued products
sql = """"""
SELECT suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.SupplierID 
HAVING COUNT(products.ProductID) = COUNT(CASE WHEN products.Discontinued = 1 THEN 1 END);
""""""

# Execute the SQL query and store the result in a DataFrame
df_suppliers_with_discontinued_products = execute_sql_query(sql)

# Visualization to show the suppliers with only discontinued products
fig = px.bar(
    df_suppliers_with_discontinued_products,
    x='CompanyName',
    title='Suppliers with Only Discontinued Products',
    labels={'CompanyName': 'Supplier Company Name'},
    text='CompanyName'
)

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find suppliers with only discontinued products
sql_query = """"""
SELECT s.SupplierID, s.CompanyName
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.CompanyName
HAVING SUM(CASE WHEN p.Discontinued = 0 THEN 1 ELSE 0 END) = 0
""""""

# Execute the SQL query
suppliers_with_discontinued_only = execute_sql_query(sql_query)

# Visualize the result
fig = px.bar(suppliers_with_discontinued_only, 
             x='CompanyName', 
             y='SupplierID', 
             title='Suppliers with Discontinued Products Only',
             labels={'SupplierID': 'Supplier ID'},
             text='SupplierID')

show_to_user(fig)
```","The provided input code correctly identifies suppliers with only discontinued products by using SQL logic equivalent to the reference code. The HAVING clause ensures suppliers are selected only if the sum of non-discontinued products is zero, which is equivalent logic to counting only discontinued products. The visualization uses a bar plot similar to the reference, effectively displaying the suppliers' names. The code adheres to the specification of identifying and displaying suppliers with only discontinued products.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DISTINCT SupplierID FROM products 
GROUP BY SupplierID 
HAVING SUM(CASE WHEN Discontinued = 0 THEN 1 ELSE 0 END) = 0;
""""""

# Execute the query to get the data
discontinued_suppliers = execute_sql_query(sql_query)

# Create a visualization
fig = px.bar(discontinued_suppliers, x='SupplierID', title='Suppliers with Only Discontinued Products')

# Display the visualization to the user
show_to_user(fig)
```","The input code uses `SupplierID` directly without linking to `CompanyName` from the `suppliers` table, unlike the reference implementation. It also shows Supplier IDs instead of more descriptive Company Names, which does not clearly communicate the same information or adhere to the business requirement for clarity. Additionally, the query logic is slightly different by using SUM logic to check for non-discontinued products as opposed to directly counting as in the reference, though this logic difference achieves similar filtering. However, the visualization clarity and alignment with the specified business request are insufficient.",Base
What is the percentage of orders that were shipped late? Include a bar chart comparing on-time versus late shipments.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    COUNT(*) FILTER (WHERE ShippedDate > RequiredDate) AS LateShipments,
    COUNT(*) AS TotalShipments
FROM orders;
""""""

# Execute SQL query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Calculate the percentage of late shipments
late_shipment_percentage = (orders_df['LateShipments'][0] / orders_df['TotalShipments'][0]) * 100

# Create a DataFrame for visualization
shipment_data = pd.DataFrame({
    'Category': ['On-Time', 'Late'],
    'Count': [orders_df['TotalShipments'][0] - orders_df['LateShipments'][0], orders_df['LateShipments'][0]]
})

# Generate a bar chart using Plotly
fig = px.bar(
    shipment_data, 
    x='Category', 
    y='Count', 
    title=f'Shipment Delivery Status (Late Percentage: {late_shipment_percentage:.2f}%)',
    labels={'Count': 'Number of Shipments'},
    color='Category'
)

# Show the visualization to the user
show_to_user(fig)
```","```python
sql_query = """"""
SELECT 
    COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) AS Late,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTime
FROM 
    orders
""""""

order_status = execute_sql_query(sql_query)

late_orders = order_status['Late'].iloc[0]
on_time_orders = order_status['OnTime'].iloc[0]

total_orders = late_orders + on_time_orders
percentage_late = (late_orders / total_orders) * 100

import plotly.express as px
import pandas as pd

status_data = pd.DataFrame({
    'Status': ['On Time', 'Late'],
    'Count': [on_time_orders, late_orders]
})

fig = px.bar(status_data, x='Status', y='Count', title='Comparison of On-Time vs Late Shipments')
show_to_user(fig)
```","The input code correctly calculates the percentage of late shipments. It retrieves the required data using a SQL query and calculates the percentage of late shipments from the total. It then creates a bar chart comparing on-time and late shipments, adhering to the same logic as the reference code. Differences in syntax do not affect the correctness of the logic.","```python
import plotly.express as px
import pandas as pd

# Utility Functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to the database, execute the SQL query, and return the results
    # as a pandas DataFrame. Stub implemented for demonstration.
    if ""ShippedLateRatio"" in sql_query:
        return pd.DataFrame({
            'ShippedLateRatio': [0.15],
            'OnTimeCount': [850],
            'LateCount': [150]
        })

def show_to_user(data):
    # This function should display the data/pandas DataFrame or plot the figure if it's a Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query to get the on-time and late order counts
query = """"""
SELECT 
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeCount,
    SUM(CASE WHEN ShippedDate > RequiredDate THEN 1 ELSE 0 END) AS LateCount
FROM orders;
""""""

df = execute_sql_query(query)

# Calculate the percentages
total_orders = df['OnTimeCount'].iloc[0] + df['LateCount'].iloc[0]
percent_on_time = (df['OnTimeCount'].iloc[0] / total_orders) * 100
percent_late = (df['LateCount'].iloc[0] / total_orders) * 100

# Create a bar chart comparing on-time vs late shipments
bar_chart_data = pd.DataFrame({
    'Category': ['On-Time', 'Late'],
    'Percentage': [percent_on_time, percent_late]
})

fig = px.bar(bar_chart_data, x='Category', y='Percentage', title='On-Time vs Late Shipments')

# Show the results
show_to_user(fig)
```","The input code effectively computes the percentage of orders that were shipped late, as required by the business analytics request. Although the method of computation differs from the reference implementation, it achieves the correct result: calculating percentages from counts of on-time and late shipments. Both codes use a SQL query to extract shipment data, and both generate a bar chart comparing on-time versus late shipments. Hence, the input code adheres to the same logic as the reference implementation.",both
Find the average shipping time for orders handled by each employee and visualize the results with a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Utility Functions
def execute_sql_query(sql_query: str):
    # Implementation for executing SQL and returning DataFrame
    # This is a placeholder for demonstration purposes
    pass

def show_to_user(data):
    # Implementation for displaying data
    # This is a placeholder for demonstration purposes
    pass

# SQL Query
sql_query = """"""
SELECT e.EmployeeID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgShippingTime
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate IS NOT NULL
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='AvgShippingTime',
             title='Average Shipping Time by Employee',
             labels={'EmployeeID': 'Employee ID', 'AvgShippingTime': 'Average Shipping Time (Days)'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       e.FirstName, 
       e.LastName, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgShippingTime
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate IS NOT NULL
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

average_shipping_time_df = execute_sql_query(sql_query)

fig = px.bar(average_shipping_time_df, 
             x='FirstName' + ' ' + 'LastName', 
             y='AvgShippingTime', 
             title='Average Shipping Time per Employee',
             labels={'EmployeeID': 'Employee ID', 'AvgShippingTime': 'Average Shipping Time (Days)'})

show_to_user(fig)
```","The input code groups by both first and last names, while the reference code only groups by EmployeeID. This may lead to inconsistencies if multiple employees have the same name. Additionally, the x-axis of the bar chart uses a non-existent column 'FirstName' + ' ' + 'LastName', which would cause an error.","```python
import plotly.express as px
import pandas as pd

# Assuming the execute_sql_query function is defined in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function executes SQL query and returns the result as a DataFrame
    # To be implemented
    pass

def show_to_user(data):
    # This function displays data or figures
    # To be implemented
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the average shipping time for each employee
sql_query = """"""
SELECT e.EmployeeID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageShippingTime 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the result as a Pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average shipping time
fig = px.bar(df, x='EmployeeID', y='AverageShippingTime', 
             title='Average Shipping Time by Employee',
             labels={'AverageShippingTime': 'Avg Shipping Time (Days)'})

# Display the figure to the user
show_to_user(fig)
```","The input code does not include a check for non-null 'ShippedDate', which is present in the reference implementation. This could lead to incorrect average calculations if there are orders with null 'ShippedDate'.",None
"  
""Which orders have a discount greater than 20%, who manages them, and what is the distribution of these discounts visualized in a chart?","
import pandas as pd
import plotly.express as px

# SQL query from the request
sql_query = """"""
SELECT o.OrderID, e.FirstName, e.LastName, od.Discount
FROM orders o
JOIN employees e ON o.EmployeeID = e.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0.2;
""""""

# Execute the SQL query and retrieve the results as a DataFrame
orders_df = execute_sql_query(sql_query)

# Display the DataFrame results to the user
show_to_user(orders_df)

# Generate a histogram to visualize the distribution of discounts
fig = px.histogram(orders_df, x='Discount', title='Distribution of Discounts Greater than 20%')

# Display the histogram figure to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.OrderID, e.EmployeeID, e.FirstName, e.LastName, d.Discount
FROM orders o
JOIN employees e ON o.EmployeeID = e.EmployeeID
JOIN [Order Details] d ON o.OrderID = d.OrderID
WHERE d.Discount > 0.2
""""""

result_df = execute_sql_query(sql_query)

discount_distribution = result_df['Discount'].value_counts().reset_index()
discount_distribution.columns = ['Discount', 'Count']

fig = px.histogram(discount_distribution, x='Discount', y='Count', 
                   title='Distribution of Discounts Greater than 20%',
                   labels={'Discount': 'Discount (%)', 'Count': 'Number of Orders'})

show_to_user(fig)
```","The input code differs from the reference implementation in how it visualizes the discount distribution. Instead of directly creating a histogram from the 'Discount' column, it calculates value counts, resulting in a different distribution visualization and meaning. Thus, it does not adhere to the same logic as the reference.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch orders with more than 20% discount, their managers, and the discount details
sql_query = """"""
SELECT OrderID, managers.UserID AS ManagerID, Discount
FROM mddx.orders 
JOIN mddx.order_details ON orders.OrderID = order_details.OrderID
JOIN managers ON orders.UserID = managers.UserID
WHERE order_details.Discount > 0.20;
""""""

# Execute SQL query
result_df = execute_sql_query(sql_query)

# Visualize the distribution of discounts using a histogram
if not result_df.empty:
    fig = px.histogram(result_df, x=""Discount"", nbins=10, title=""Distribution of Discounts > 20%"")
    show_to_user(fig)
else:
    show_to_user(""No orders with discounts greater than 20% found."")
```","The input code retrieves data using different database details and column names compared to the reference code. Specifically, it uses 'managers' and 'UserID' instead of 'employees' and 'EmployeeID'. Additionally, while both pieces of code generate histograms for discounts greater than 20%, the reference code uses employee names in its SQL query and output, whereas the input code uses 'ManagerID'. As a result, the retrieved data and visualization would differ, indicating a deviation in implementation logic.",None
"Which city received the most shipments, and provide a bar chart to compare shipment counts across the top cities?","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get shipment counts per city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS Shipments 
FROM orders 
GROUP BY ShipCity 
ORDER BY Shipments DESC;
""""""

# Execute the query and get the result as a DataFrame
shipments_df = execute_sql_query(sql_query)

# Determine the city with the most shipments
top_city_df = shipments_df.head(1)

# Create a bar chart to compare shipment counts across top cities
fig = px.bar(shipments_df, x='ShipCity', y='Shipments', 
             title='Shipment Counts by City',
             labels={'ShipCity': 'City', 'Shipments': 'Number of Shipments'})

# Display the city with the most shipments
show_to_user(top_city_df)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipCity
ORDER BY ShipmentCount DESC
LIMIT 10
""""""

top_cities_df = execute_sql_query(sql_query)

most_shipments_city = top_cities_df.iloc[0]['ShipCity']
fig = px.bar(top_cities_df, x='ShipCity', y='ShipmentCount', 
             title='Shipment Counts Across Top Cities',
             labels={'ShipCity': 'City', 'ShipmentCount': 'Number of Shipments'})

show_to_user(fig)

most_shipments_city
```","The reference code finds the city with the most shipments from all cities, while the input code limits the query to the top 10 cities. This limitation could lead to inaccuracies if the city with the most shipments doesn't fall within these 10 cities. Additionally, the input code does not display the city with the most shipments separately, unlike the reference code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get shipment counts by city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY ShipmentCount DESC
""""""

# Execute the SQL query to retrieve data
df_shipments = execute_sql_query(sql_query)

# Create a bar chart to show shipment counts across the top cities
fig = px.bar(df_shipments, x='ShipCity', y='ShipmentCount', 
             title='Top Cities by Shipment Count', 
             labels={'ShipCity': 'City', 'ShipmentCount': 'Number of Shipments'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code does not identify and display the city with the most shipments separately, which is a requirement based on the business analytics request and the steps followed by the reference code. The reference code specifically extracts the top city using 'head(1)' and displays it, which the input code fails to do.",None
"What is the total number of different products sold to date? Additionally, provide a bar chart showing the count of products sold across different categories.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the total number of unique products sold
sql_query_unique_products = ""SELECT COUNT(DISTINCT ProductID) AS UniqueProductsSold FROM [Order Details];""
unique_products_df = execute_sql_query(sql_query_unique_products)

# Display the total number of unique products sold
show_to_user(unique_products_df)

# Execute the SQL query to get the count of products sold across different categories
sql_query_products_by_category = """"""
SELECT Category, COUNT(ProductID) AS ProductsSold 
FROM [Order Details] 
JOIN Products ON [Order Details].ProductID = Products.ProductID 
JOIN Categories ON Products.CategoryID = Categories.CategoryID
GROUP BY Category;
""""""
products_by_category_df = execute_sql_query(sql_query_products_by_category)

# Create a bar chart using Plotly
fig = px.bar(products_by_category_df, x='Category', y='ProductsSold', 
             title='Products Sold Across Different Categories')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total number of different products sold and count by category
sql_query = """"""
SELECT p.CategoryID, COUNT(DISTINCT od.ProductID) AS ProductsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID;
""""""

# Execute the SQL query
category_sales = execute_sql_query(sql_query)

# Calculate total number of different products sold
total_products_sold = category_sales['ProductsSold'].sum()

# Create a bar chart for counting products sold across different categories
fig = px.bar(category_sales, 
             x='CategoryID', 
             y='ProductsSold', 
             title='Count of Products Sold Across Different Categories',
             labels={'CategoryID': 'Category ID', 'ProductsSold': 'Number of Products Sold'})

# Show the result to the user
show_to_user(fig)

# Show total products sold
print(""Total number of different products sold to date:"", total_products_sold)
```","The input code does not correctly compute the total number of different products sold as it sums the count of unique products per category, leading to potential duplication if products span multiple categories. Also, it uses CategoryID instead of Category for the x-axis, which is not aligned with the reference implementation's goal of providing a more detailed category breakdown.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total number of different products sold
sql_query_total_products = """"""
SELECT COUNT(DISTINCT ProductID) AS TotalProducts 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID;
""""""

# SQL query to get the count of products sold across different categories
sql_query_category_count = """"""
SELECT Category, COUNT(DISTINCT ProductID) AS ProductCount 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY Category
ORDER BY ProductCount DESC;
""""""

# Execute the SQL query to get the total number of different products
total_products_df = execute_sql_query(sql_query_total_products)

# Display the total number of different products sold
show_to_user(total_products_df)

# Execute the SQL query to get the count of products sold across categories
category_count_df = execute_sql_query(sql_query_category_count)

# Create a bar chart showing the count of products sold across different categories
fig = px.bar(category_count_df, x='Category', y='ProductCount', title='Products Sold Across Categories', labels={'ProductCount': 'Number of Products Sold'})
fig.update_layout(bargap=0.2)

# Display the bar chart
show_to_user(fig)
```","The input code does not correctly align with the reference implementation. The input code counts the distinct number of ProductIDs per category instead of the total occurrences of ProductIDs. Additionally, it joins the Products table before filtering by category, missing the necessary join with the Categories table to correctly attribute category names. The reference code calculates the total number of all occurrences of ProductIDs from the Order Details table joined with categories. Thus, the logic differs.",None
Which month had the highest total sales revenue this year? Please include a bar chart to visualize the total sales for each month.,"```python
import pandas as pd
import plotly.express as px

# Placeholder for the SQL execution utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Logic to connect to the database and execute the SQL query
    # and return the result as a pandas DataFrame
    pass

# Placeholder for the function to display results to the user
def show_to_user(data):
    # Logic to display pandas DataFrame or Plotly figure
    pass

# SQL query for fetching total sales per month for the current year
sql_query = """"""
SELECT DATE_TRUNC('month', o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query to get the DataFrame
sales_data = execute_sql_query(sql_query)

# Plotting total sales per month
fig = px.bar(sales_data, x='Month', y='TotalSales', title='Total Sales per Month')

# Display the visualization
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by month for the current year
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(OrderDate) = YEAR(CURDATE())
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query and fetch the results
sales_data = execute_sql_query(sql_query)

# Find the month with the highest total sales
highest_sales_month = sales_data.loc[sales_data['TotalSales'].idxmax()]

# Create a bar chart
fig = px.bar(sales_data, x='Month', y='TotalSales', title='Total Sales by Month', labels={'TotalSales':'Total Sales Revenue'})
fig.add_annotation(
    x=highest_sales_month['Month'],
    y=highest_sales_month['TotalSales'],
    text='Highest Sales',
    arrowhead=2,
    ax=0,
    ay=-40,
    showarrow=True,
    font=dict(color='red')
)

# Show the user the results
show_to_user(fig)
```","The input Python code is correct. It follows the logic of the reference implementation by executing a similar SQL query to fetch total sales by month for the current year, and visualizes the data using a bar chart. The use of `DATE_FORMAT` and `YEAR` functions instead of `DATE_TRUNC` and `EXTRACT` aligns with possible differences in SQL dialects. Moreover, the input code adds an annotation to highlight the month with the highest sales, which is an enhancement but does not deviate from the original request.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholder
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation, should execute the SQL and return a DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualizations
    pass

# SQL query to get monthly sales data
sql_query = '''
SELECT YEAR(orders.OrderDate) AS Year, 
       MONTH(orders.OrderDate) AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
INNER JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY YEAR(orders.OrderDate), MONTH(orders.OrderDate) 
ORDER BY Month ASC
'''

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Visualize the total sales for each month using a bar chart
fig = px.bar(monthly_sales_df, x='Month', y='TotalSales', 
             title='Total Sales Revenue per Month',
             labels={'TotalSales': 'Total Sales ($)', 'Month': 'Month'},
             text='TotalSales')

# Display the figure
show_to_user(fig)
```","The evaluated code correctly answers the business question. Both the reference and evaluated codes execute a SQL query to extract sales totals per month for the current year, join the same tables, and use equivalent logic for the sum calculation. The visualization is a bar chart in both cases, displaying total sales per month. Differences in SQL functions (e.g., DATE_TRUNC vs. YEAR/MONTH) are due to syntax variations but do not affect the logic, making the evaluated code correct.",both
Identify the top 5 customers with the highest spending and present the results in a bar chart.,"```python
# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve top 5 customers with the highest spending
sql_query = """"""
SELECT o.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpent 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.CustomerID 
ORDER BY TotalSpent DESC 
LIMIT 5
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart for the top 5 customers
fig = px.bar(df, x='CustomerID', y='TotalSpent', title='Top 5 Customers by Spending')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSpending
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID
ORDER BY TotalSpending DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CustomerID', y='TotalSpending', title='Top 5 Customers by Spending')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It retrieves the top 5 customers by total spending using an SQL query, which is similar to the reference implementation. The column aliases differ slightly ('TotalSpending' vs. 'TotalSpent'), but this does not affect the logic or outcome. Additionally, the bar chart creation and display steps match those of the reference implementation, making the overall approach consistent and correct.","```python
import plotly.express as px

# SQL query to fetch the top 5 customers with the highest spending
sql_query = """"""
SELECT C.CustomerID, 
       SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSpending 
FROM customers C 
JOIN orders O ON C.CustomerID = O.CustomerID 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
GROUP BY C.CustomerID 
ORDER BY TotalSpending DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the data as a DataFrame
df_top_customers = execute_sql_query(sql_query)

# Create a bar chart using the DataFrame
fig = px.bar(df_top_customers, x='CustomerID', y='TotalSpending', 
             title='Top 5 Customers by Spending',
             labels={'CustomerID': 'Customer ID', 'TotalSpending': 'Total Spending'},
             template='plotly')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by identifying the top 5 customers with the highest spending. It also matches the logic of the reference implementation. Both implementations perform an SQL query to calculate the total spending per customer using 'SUM' on the product of 'UnitPrice', 'Quantity', and 'Discount' across the joined 'orders' and 'Order Details' tables. They then select the top 5 customers by ordering the results in descending order of spending. Finally, both codes use Plotly Express to create a bar chart displaying the top customers by spending. While there are slight differences in the SQL syntax and bar chart details like labels and template, these do not affect the logic or the correctness of the task execution.",both
"Which city receives the most shipments, and can this be represented in a bar chart for easier comparison?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(*) AS Shipments
FROM orders
GROUP BY ShipCity
ORDER BY Shipments DESC;
""""""

# Execute the SQL query and retrieve the results in a DataFrame
df_shipments = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of shipments per city
fig = px.bar(df_shipments, x='ShipCity', y='Shipments', 
             title='Number of Shipments by City',
             labels={'ShipCity': 'City', 'Shipments': 'Number of Shipments'})

# Display the visualization result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipCity
ORDER BY ShipmentCount DESC
LIMIT 1;
""""""

top_city_df = execute_sql_query(sql_query)

city_name = top_city_df['ShipCity'].values[0]
shipment_count = top_city_df['ShipmentCount'].values[0]

shipment_data = pd.DataFrame({'City': [city_name], 'Shipments': [shipment_count]})

fig = px.bar(shipment_data, x='City', y='Shipments', title='City with Most Shipments', labels={'Shipments': 'Number of Shipments', 'City': 'City'})
show_to_user(fig)
```","The input code retrieves and visualizes only the city with the most shipments, ignoring other cities. The reference code retrieves all cities and their shipment counts, allowing for a bar chart comparison of all cities. Therefore, the input code does not fully comply with the business analytics request of comparing multiple cities.","```python
import plotly.express as px

# SQL query to get the city with the maximum shipments
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS Shipments 
FROM orders 
GROUP BY ShipCity 
ORDER BY Shipments DESC 
LIMIT 1;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not df.empty:
    # Create a bar chart using Plotly
    fig = px.bar(df, x='ShipCity', y='Shipments', title='Shipments per City')

    # Show the bar chart to the user
    show_to_user(fig)
else:
    show_to_user(""No shipments data available."")
```","The input code only retrieves the city with the maximum shipments due to the LIMIT 1 clause, which results in a single bar chart, not a full comparison across all cities. The reference code provides a complete list of shipments by city for comprehensive comparison.",None
How many products have never been ordered? Include a bar chart to show the count of these products by category.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find products never ordered
sql_query = """"""
SELECT products.ProductID, products.ProductName, categories.CategoryName
FROM products
LEFT JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
WHERE [Order Details].ProductID IS NULL;
""""""

# Execute the SQL query
df_unordered_products = execute_sql_query(sql_query)

# Count unordered products by category
category_counts = df_unordered_products['CategoryName'].value_counts().reset_index()
category_counts.columns = ['Category', 'Count']

# Create a bar chart using Plotly
fig = px.bar(category_counts, x='Category', y='Count', title='Number of Unordered Products by Category')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get products that have never been ordered
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.CategoryID
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL
""""""
never_ordered_products = execute_sql_query(sql_query)

# Count of these products by category
count_by_category = never_ordered_products['CategoryID'].value_counts().reset_index()
count_by_category.columns = ['CategoryID', 'Count']

# Bar chart visualization
fig = px.bar(count_by_category, x='CategoryID', y='Count', title='Count of Products Never Ordered by Category')
show_to_user(fig)
```","The input code does not completely match the logic of the reference implementation. The reference code includes a join with the categories table to retrieve the CategoryName, whereas the input code only retrieves CategoryID. Therefore, the bar chart in the input code labels the categories by CategoryID instead of CategoryName, which may not appropriately answer the business analytics request.","
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation, replace with actual database connection and execution
    pass

# Function to display data analysis or visualization results
def show_to_user(data):
    # Placeholder implementation, replace with actual display logic
    pass

# SQL query to find products that have never been ordered
sql_query_unordered_products = """"""
SELECT p.ProductID, p.Category 
FROM products p 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.OrderID IS NULL;
""""""

# Execute SQL query to get unordered products
unordered_products_df = execute_sql_query(sql_query_unordered_products)

# Count of unordered products by category
category_count_df = unordered_products_df.groupby('Category').size().reset_index(name='Count')

# Generate a bar chart using Plotly
fig = px.bar(category_count_df, x='Category', y='Count', title='Count of Unordered Products by Category')

# Display the bar chart
show_to_user(fig)
","The input code fails to join the categories table to obtain category names accurately. It uses a field 'Category' which doesn't exist directly in the reference context. The reference code directly joins the categories table to retrieve 'CategoryName', ensuring correct counting by category names, whereas the input code assumes a 'Category' field in the products table. This results in potential inaccuracy in categorizing unordered products.",None
Determine the total number of products that are overstocked and create a bar chart to display the categories of these overstocked products.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch overstocked product data with categories
sql_query = """"""
SELECT CategoryName, COUNT(*) AS OverstockedCount
FROM products
INNER JOIN categories ON products.CategoryID = categories.CategoryID
WHERE UnitsInStock > (ReorderLevel + UnitsOnOrder)
GROUP BY CategoryName;
""""""

# Execute the SQL query to get the data
overstocked_df = execute_sql_query(sql_query)

# Create a bar chart to display the categories of overstocked products
fig = px.bar(overstocked_df, x='CategoryName', y='OverstockedCount',
             title='Overstocked Products by Category',
             labels={'CategoryName': 'Product Category', 'OverstockedCount': 'Number of Overstocked Products'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, COUNT(*) AS OverstockedCount
FROM products p
WHERE p.UnitsInStock > p.ReorderLevel AND p.Discontinued = 0
GROUP BY p.CategoryID
""""""

overstocked_products = execute_sql_query(sql_query)

total_overstocked = overstocked_products['OverstockedCount'].sum()

fig = px.bar(overstocked_products, x='CategoryID', y='OverstockedCount', title='Overstocked Products by Category')
show_to_user(fig)
```","The input code does not align with the specified business analytics request and reference implementation in key ways: 1. It uses 'CategoryID' instead of 'CategoryName', which affects the bar chart's x-axis depiction of categories. 2. It does not cater to joining the 'categories' table for meaningful category names. 3. It overlooks the condition 'UnitsOnOrder' in determining overstocked products, making it inconsistent with the method used for comparison in the reference code.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT CategoryID, ProductName
FROM products
WHERE UnitsInStock > ReorderLevel;
""""""

# Execute the SQL query and store the result in a DataFrame
overstocked_products_df = execute_sql_query(sql_query)

# Count the number of products in each category
overstocked_count_by_category = overstocked_products_df['CategoryID'].value_counts().reset_index()
overstocked_count_by_category.columns = ['CategoryID', 'Count']

# Create a bar chart to display the number of overstocked products by category
fig = px.bar(overstocked_count_by_category, 
             x='CategoryID', 
             y='Count', 
             title='Number of Overstocked Products by Category',
             labels={'CategoryID': 'Category ID', 'Count': 'Number of Products'})

# Show the bar chart to the user
show_to_user(fig)
```","The provided code is incorrect because it does not meet the business analytics request. The reference implementation checks if products are overstocked by comparing 'UnitsInStock' to the sum of 'ReorderLevel' and 'UnitsOnOrder'. It also joins categories to determine the count per category. The evaluated code merely checks if 'UnitsInStock' is greater than 'ReorderLevel', and does not join with categories to calculate the count correctly. Additionally, it uses 'CategoryID' instead of 'CategoryName', which doesn't fulfill the request to display categories of the overstocked products.",None
Calculate the total sales for each product and provide a bar chart to visualize the results.,"
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales
FROM [Order Details]
GROUP BY ProductID;
""""""

# Execute the SQL query and retrieve the results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales for each product
fig = px.bar(df, x='ProductID', y='TotalSales', title='Total Sales for Each Product', labels={'TotalSales': 'Total Sales', 'ProductID': 'Product ID'})

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.bar(total_sales_df, x='ProductID', y='TotalSales', title='Total Sales for Each Product')
show_to_user(fig)
```","The input Python code calculates total sales per product similar to the reference implementation by joining tables on 'OrderID'. Although the SQL query in the input code includes an additional join with the 'orders' table, this does not affect the final aggregation of 'TotalSales' per 'ProductID'. The calculation and visualization logic align with the business analytics request, fulfilling the requirement correctly.","```python
import pandas as pd
import plotly.express as px

# SQL Query to calculate total sales for each product
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity) AS TotalSales 
FROM products 
INNER JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalSales', title='Total Sales by Product', labels={'TotalSales': 'Total Sales', 'ProductID': 'Product ID'})

# Display the bar chart
show_to_user(fig)
```","The input code does not include the discount factor in the calculation of TotalSales, which is present in the reference implementation. This omission results in a different calculation and potentially incorrect totals compared to what is specified in the request and reference code.",Base
Analyze the correlation between unit price and units ordered for the products and include a scatter plot to visualize the relationship.,"```python
import pandas as pd
import plotly.express as px

# SQL query to analyze correlation
sql_query = """"""
SELECT 
    p.ProductName, 
    p.UnitPrice, 
    od.Quantity 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Calculate the correlation between UnitPrice and Quantity for each product
grouped_df = df.groupby('ProductName').apply(lambda g: g['UnitPrice'].corr(g['Quantity'])).reset_index(name='PriceQuantityCorrelation')

# Visualize the correlation for each product using a scatter plot
fig = px.scatter(
    grouped_df, 
    x='ProductName', 
    y='PriceQuantityCorrelation',
    title='Correlation between Unit Price and Units Ordered by Product',
    labels={'PriceQuantityCorrelation': 'Correlation'},
    template='plotly'
)

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.UnitPrice,
    od.Quantity 
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
""""""

data = execute_sql_query(sql_query)

correlation = data.corr().iloc[0, 1]

fig = px.scatter(data, x='UnitPrice', y='Quantity', title=f'Scatter Plot of Unit Price vs Quantity Ordered\nCorrelation: {correlation:.2f}')
show_to_user(fig)
```","The input code does not match the logic of the reference implementation. It calculates a global correlation across all products, not per product as required. The visual also plots all unit prices against quantities ordered, rather than visualizing product-specific correlations.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductName, UnitPrice, SUM(Quantity) AS TotalUnitsOrdered 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY ProductName, UnitPrice;
""""""

# Execute the SQL query and retrieve the data
products_data = execute_sql_query(sql_query)

# Calculate the correlation between UnitPrice and TotalUnitsOrdered
correlation = products_data[['UnitPrice', 'TotalUnitsOrdered']].corr().iloc[0, 1]

# Print correlation to the user
show_to_user(pd.DataFrame({'Correlation': [correlation]}))

# Create a scatter plot to visualize the relationship
fig = px.scatter(
    products_data,
    x='UnitPrice',
    y='TotalUnitsOrdered',
    title='Scatter Plot of Unit Price vs. Units Ordered',
    labels={
        'UnitPrice': 'Unit Price',
        'TotalUnitsOrdered': 'Total Units Ordered'
    }
)

# Display the scatter plot to the user
show_to_user(fig)
```","The input code calculates the correlation between 'UnitPrice' and the aggregated 'TotalUnitsOrdered' across all products rather than each product individually. The reference code computes and visualizes the correlation by grouping each product. Also, the scatter plot in the input is based on UnitPrice and TotalUnitsOrdered rather than showing the correlation for each product.",None
"Which suppliers have shipped orders on time this year, and can this be visualized using a timeline or bar chart for clarity?","```python
import pandas as pd
import plotly.express as px

# The SQL query to fetch the relevant supplier data
sql_query = """"""
SELECT DISTINCT suppliers.CompanyName 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.ShippedDate) = YEAR(CURRENT_DATE) 
AND orders.RequiredDate >= orders.ShippedDate;
""""""

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Visualize the data using a bar chart for clarity
fig = px.bar(supplier_data, 
             x='CompanyName', 
             title='Suppliers Who Shipped Orders On Time This Year',
             labels={'CompanyName': 'Supplier'})

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the current year
current_year = pd.Timestamp.now().year

# SQL query to retrieve on-time shipments and supplier information for the current year
sql_query = f""""""
SELECT s.SupplierID, s.CompanyName, 
       COUNT(o.OrderID) AS OnTimeShipments
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID = o.OrderID
WHERE YEAR(o.ShippedDate) = {current_year} 
AND o.ShippedDate <= o.RequiredDate
GROUP BY s.SupplierID, s.CompanyName
""""""

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(results_df, x='CompanyName', y='OnTimeShipments', 
             title='On-Time Shipments by Supplier in {current_year}', 
             labels={'OnTimeShipments': 'Number of On-Time Shipments', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code has an error in the SQL JOIN clause where it matches `products.ProductID` to `orders.OrderID`, instead of using `[Order Details].ProductID` and `[Order Details].OrderID` as in the reference code. This affects the correctness of the data relationship, resulting in potentially inaccurate results. Additionally, the input code aggregates data to count on-time shipments, which is a deviation from the reference code logic which lists distinct company names without aggregates.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to fetch suppliers who have shipped orders on time this year
query = """"""
SELECT s.CompanyName, COUNT(o.OrderID) AS OnTimeOrders 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
AND o.ShippedDate <= o.RequiredDate 
GROUP BY s.SupplierID, s.CompanyName
""""""

# Retrieve the data using the utility function
suppliers_data = execute_sql_query(query)

# Check if data is retrieved
if suppliers_data.empty:
    show_to_user(pd.DataFrame({'Message': ['No on-time deliveries found for this year.']}))
else:
    # Create a bar chart to visualize the number of on-time orders per supplier
    fig = px.bar(
        suppliers_data,
        x='CompanyName',
        y='OnTimeOrders',
        title='On-time Orders by Supplier (This Year)',
        labels={'CompanyName': 'Supplier', 'OnTimeOrders': 'Number of On-time Orders'}
    )

    # Display the visualization
    show_to_user(fig)
```","The input code correctly fulfills the business request by identifying suppliers who have shipped orders on time this year and visualizing the results using a bar chart. The primary condition for 'on-time' is met by ensuring the shipped date is on or before the required date. Although the reference code uses 'ShippedDate' for the year comparison and the input code uses 'OrderDate', both still accurately segment by the current year and thus meet the underlying business logic and requirements. The bar chart visualization meets the request for clarity, and the overall process aligns with the analytical goal and logic of the reference implementation.",Finetuned
"What is the average order fulfillment time for each employee, and can it be represented in a bar chart for better comparison?","
```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function which should be implemented to connect to the database,
    # execute the query and return the result as a DataFrame
    pass

# Utility function to display data analysis or visualization results
def show_to_user(data):
    # Placeholder function which should be implemented to handle display logic
    pass

# Define the SQL query
sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY EmployeeID;
""""""

# Execute the query and capture the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for average order fulfillment time for each employee
if not df.empty:
    fig = px.bar(df, x='EmployeeID', y='AverageFulfillmentTime',
                 title='Average Order Fulfillment Time per Employee',
                 labels={'AverageFulfillmentTime': 'Avg Fulfillment Time (days)', 'EmployeeID': 'Employee ID'})

    # Display the bar chart to the user
    show_to_user(fig)
else:
    print(""No data available to display."")
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY EmployeeID
""""""

fulfillment_time_df = execute_sql_query(sql_query)

fig = px.bar(fulfillment_time_df, x='EmployeeID', y='AvgFulfillmentTime',
             title='Average Order Fulfillment Time per Employee',
             labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'EmployeeID': 'Employee ID'})
show_to_user(fig)
```","The input code correctly executes the specified business analytics request. It calculates the average order fulfillment time for each employee using the same SQL query logic as the reference implementation. Both codes use Plotly Express to create a bar chart for visualization and invoke a function to display it to the user. The names of the average fulfillment time column are slightly different ('AvgFulfillmentTime' vs 'AverageFulfillmentTime'), but this does not affect the correctness of the logic or functionality.","```python
import pandas as pd
import plotly.express as px

# Define utility functions (mock implementations for context)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would execute the SQL and return a DataFrame.
    # Simulated output for demonstration purposes.
    data = {'EmployeeID': [1, 2], 'AvgFulfillmentTime': [3.5, 4.2]}
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the average order fulfillment time per employee
sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY EmployeeID;
""""""

# Execute the SQL query and get the result into a DataFrame
order_fulfillment_df = execute_sql_query(sql_query)

# Create a bar chart to compare the average fulfillment times
fig = px.bar(order_fulfillment_df, x='EmployeeID', y='AvgFulfillmentTime',
             title='Average Order Fulfillment Time by Employee',
             labels={'AvgFulfillmentTime': 'Avg Fulfillment Time (Days)'},
             text='AvgFulfillmentTime')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It executes a similar SQL query to compute the average fulfillment time for each employee and stores the result in a DataFrame. A bar chart is then created using Plotly to visualize this data, matching the requirements of the reference implementation. The function names and minor details differ, but the logic and outcome are consistent with the reference implementation.",both
Find out the monthly average units in stock for each product and create a line chart to visualize the trends over time.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT 
    p.ProductName, 
    EXTRACT(YEAR FROM o.OrderDate) AS Year, 
    EXTRACT(MONTH FROM o.OrderDate) AS Month, 
    AVG(p.UnitsInStock) AS AverageMonthlyStock 
FROM 
    products p 
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID 
JOIN 
    orders o ON od.OrderID = o.OrderID 
GROUP BY 
    p.ProductName, Year, Month;
""""""

# Fetching the data using the provided utility function
df = execute_sql_query(sql_query)

# Creating a line chart for average monthly stock per product
fig = px.line(
    df, 
    x='Month', 
    y='AverageMonthlyStock', 
    color='ProductName', 
    line_group='Year',
    title='Monthly Average Units in Stock for Each Product',
    labels={'AverageMonthlyStock': 'Average Units in Stock'}
)

# Displaying the resulting figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(CURRENT_DATE, '%Y-%m') AS Month,
    ProductID,
    AVG(UnitsInStock) AS AverageUnitsInStock
FROM 
    products
GROUP BY 
    Month, ProductID
ORDER BY 
    Month, ProductID;
""""""

average_units_df = execute_sql_query(sql_query)

fig = px.line(average_units_df, x='Month', y='AverageUnitsInStock', color='ProductID', 
              title='Monthly Average Units in Stock for Each Product', 
              labels={'AverageUnitsInStock': 'Average Units in Stock', 'Month': 'Month'})

show_to_user(fig)
```","The input code calculates the average units in stock across all current products for each month using a constant date format (CURRENT_DATE), which does not correspond to historical order data. The reference code queries historical monthly data using order dates and calculates averages based on actual order activity, which is needed for accurate trend analysis. Additionally, the input code does not consider different years, only current data, and does not aggregate by product name, but rather by ProductID.","```python
import pandas as pd
import plotly.express as px

# Define the business logic in a function
def monthly_average_units_in_stock():
    # SQL query given
    sql_query = """"""
    SELECT p.ProductID, DATE_TRUNC('month', o.OrderDate) AS Month, AVG(p.UnitsInStock) AS AvgUnitsInStock 
    FROM products p 
    LEFT JOIN orders o ON p.ProductID = o.ProductID 
    GROUP BY p.ProductID, DATE_TRUNC('month', o.OrderDate);
    """"""

    # Execute the SQL query using the utility function
    df = execute_sql_query(sql_query)

    # Ensure that 'Month' is treated as a date
    df['Month'] = pd.to_datetime(df['Month'])

    # Create a line chart using Plotly to visualize the trends
    fig = px.line(
        df,
        x='Month',
        y='AvgUnitsInStock',
        color='ProductID',
        title='Monthly Average Units in Stock for Each Product',
        labels={'AvgUnitsInStock': 'Average Units in Stock', 'Month': 'Month'}
    )

    # Display the line chart using the utility function
    show_to_user(fig)

# Call the function to execute the process
monthly_average_units_in_stock()
```","The input code calculates average units in stock monthly based on ProductID without considering the OrderID's role in aggregating data through Order Details, which is important for ensuring correct product association when calculating stock levels over orders. The reference code joins Order Details and uses EXTRACT to compute averages precisely for each ProductName by filtering orders per month. The input does not match the grouping logic of the reference code, which provides clarity and accuracy in retrieving monthly stock levels.",None
"How many late shipments were there each month, and can you provide a line chart to visualize the monthly trends?","```python
import pandas as pd
import plotly.express as px

# SQL query to get late shipments per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
       COUNT(OrderID) AS LateShipments 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY OrderMonth;
""""""

# Execute the SQL query and get the DataFrame
late_shipments_df = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly late shipments trends
fig = px.line(late_shipments_df, x='OrderMonth', y='LateShipments', 
              title='Monthly Late Shipments Trends',
              labels={'OrderMonth': 'Order Month', 'LateShipments': 'Number of Late Shipments'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS LateShipments
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

late_shipments_df = execute_sql_query(sql_query)

fig = px.line(late_shipments_df, x='Month', y='LateShipments', title='Monthly Late Shipments')
show_to_user(fig)
```","Both the input code and the reference code execute a similar SQL query to count late shipments per month based on the condition 'ShippedDate > RequiredDate.' They then generate a line chart using Plotly Express to visualize these monthly trends. Differences in variable names (e.g., 'Month' vs. 'OrderMonth') and chart titles are cosmetic and do not affect the correctness, as the logic and goal of the analysis remain unchanged.","```python
import plotly.express as px
import pandas as pd

# SQL query provided
sql_query = """"""
SELECT 
    DATE_FORMAT(RequiredDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS LateShipments 
FROM 
    orders 
WHERE 
    ShippedDate > RequiredDate 
GROUP BY 
    DATE_FORMAT(RequiredDate, '%Y-%m');
""""""

# Execute the SQL query and fetch the data into a DataFrame
late_shipments_df = execute_sql_query(sql_query)

# Creating a line chart using Plotly to visualize late shipments per month
fig = px.line(
    late_shipments_df, 
    x='Month', 
    y='LateShipments', 
    title='Monthly Late Shipments',
    labels={'LateShipments': 'Late Shipments', 'Month': 'Month'}
)

# Display the line chart to the user
show_to_user(fig)
```","The provided Python code correctly calculates the number of late shipments per month by grouping on the month derived from RequiredDate, which corresponds to the logic in the reference code. Similarly, it creates a line chart using Plotly to visualize the late shipments trend as required. The use of DATE_FORMAT function to extract the month is consistent with the intention of the query in both implementations. The difference in column naming for the month does not affect correctness as the logic remains the same.",both
"What's the average discount applied to product orders, and can a bar chart be provided to show the distribution of discounts by product category?","```python
import pandas as pd
import plotly.express as px

# Execute SQL query to get the average discount
sql_query_avg_discount = ""SELECT AVG(Discount) FROM [Order Details];""
avg_discount_df = execute_sql_query(sql_query_avg_discount)

# Display the average discount result
show_to_user(avg_discount_df)

# Execute SQL query to get discount data by product category
sql_query_discount_by_category = """"""
SELECT ProductCategory, AVG(Discount) AS Discount
FROM [Order Details]
JOIN Products ON [Order Details].ProductID = Products.ProductID
GROUP BY ProductCategory;
""""""
discount_by_category_df = execute_sql_query(sql_query_discount_by_category)

# Create a bar chart to show the distribution of discounts by product category
fig = px.bar(discount_by_category_df, x='ProductCategory', y='Discount', 
             title='Discount Distribution by Product Category', 
             labels={'Discount': 'Average Discount (%)'},
             height=400)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL Query to get average discount and discounts by product category
sql_query = """"""
SELECT 
    p.CategoryID,
    AVG(od.Discount) AS AverageDiscount
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
GROUP BY 
    p.CategoryID
""""""

# Execute the SQL query
discounts_df = execute_sql_query(sql_query)

# Calculate the average discount across all products
average_discount = discounts_df['AverageDiscount'].mean()

# Create a bar chart for distribution of discounts by product category
fig = px.bar(discounts_df, 
             x='CategoryID', 
             y='AverageDiscount', 
             title='Average Discount by Product Category',
             labels={'CategoryID': 'Product Category', 'AverageDiscount': 'Average Discount'},
             color='AverageDiscount')

# Show results
show_to_user(discounts_df)
show_to_user(fig)

average_discount
```","The input code and reference code differ in their SQL queries and logic for calculating the average discount. The input code calculates the average discount directly from the discounts by category, which is incorrect. It should separately calculate the overall average discount first, not as the mean of category averages. Also, the reference code uses 'ProductCategory' while the input code uses 'CategoryID', this might be fine if 'CategoryID' is meant to represent the category—it's a minor difference assuming they refer to the same thing. However, the logic for calculating average discount doesn't match due to the grouping difference.","```python
import pandas as pd
import plotly.express as px

# Assume the execute_sql_query and show_to_user functions are available from the provided environment

# SQL query to calculate the average discount
sql_avg_discount = ""SELECT AVG([Order Details].Discount) AS AverageDiscount FROM [Order Details];""

# Execute the SQL query to get the average discount
avg_discount_df = execute_sql_query(sql_avg_discount)

# Show the average discount to the user
show_to_user(avg_discount_df)

# SQL query to obtain discount and product category data
sql_discounts_by_category = """"""
SELECT [Order Details].Discount, Products.Category
FROM [Order Details]
JOIN Products ON [Order Details].ProductID = Products.ProductID;
""""""

# Execute the SQL query to get discounts by product category
discounts_by_category_df = execute_sql_query(sql_discounts_by_category)

# Create a bar chart to show the distribution of discounts by product category
fig = px.bar(discounts_by_category_df, x='Category', y='Discount', 
             title='Distribution of Discounts by Product Category',
             labels={'Discount': 'Discount Amount', 'Category': 'Product Category'}, 
             barmode='group')

# Show the bar chart to the user
show_to_user(fig)
```","The input code calculates individual discounts by category rather than the average discount per category. It uses 'Discount' instead of 'AVG(Discount)' in the SQL query to group by average discounts. The reference implementation calculates the average discount per product category, which affects the bar chart output.",None
"What is the total freight cost by region over the last year, and can this be visualized in a bar chart?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
    SELECT ShipRegion, SUM(Freight) AS TotalFreight 
    FROM orders 
    WHERE OrderDate >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '1 year' 
    GROUP BY ShipRegion;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total freight cost by region
fig = px.bar(df, x='ShipRegion', y='TotalFreight', title='Total Freight Cost by Region Over the Last Year')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

last_year = datetime.now() - timedelta(days=365)
last_year_str = last_year.strftime('%Y-%m-%d')

sql_query = f""""""
SELECT 
    ShipRegion, 
    SUM(Freight) AS TotalFreight 
FROM 
    orders 
WHERE 
    OrderDate >= '{last_year_str}' 
GROUP BY 
    ShipRegion
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipRegion', y='TotalFreight', title='Total Freight Cost by Region (Last Year)')
show_to_user(fig)
```","The input code correctly calculates the total freight cost by region over the last year. The approach to determine the last year's date is slightly different but effective: it subtracts 365 days from the current date instead of using DATE_TRUNC. The logic for executing the SQL query and generating the bar chart is consistent with the reference implementation, fulfilling the business analytics request.","
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    ShipRegion, 
    SUM(Freight) AS TotalFreightCost 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = YEAR(CURRENT_DATE) - 1 
GROUP BY 
    ShipRegion;
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # The implementation of this function is assumed to be provided elsewhere in the environment
    pass

# Fetch the data using the utility function
df = execute_sql_query(sql_query)

# Visualize the total freight cost by region in a bar chart
fig = px.bar(df, x='ShipRegion', y='TotalFreightCost',
             title='Total Freight Cost by Region for Last Year',
             labels={'TotalFreightCost': 'Total Freight Cost'},
             text='TotalFreightCost')

# Show the visualization to the user
def show_to_user(data):
    # The implementation of this function is assumed to be provided elsewhere in the environment
    pass

show_to_user(fig)
","The input code uses 'YEAR(OrderDate) = YEAR(CURRENT_DATE) - 1' to filter the data for the last year, while the reference code uses 'OrderDate >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '1 year''. The input code checks for orders from the previous calendar year, whereas the reference code checks for the last 365 days from the current date. Thus, the logic to determine the last year is different, potentially leading to different results.",Base
"What is the most common shipping method, and can you provide a chart to visualize the distribution of shipping methods?","```python
import plotly.express as px
import pandas as pd

# Given utility function stubs for environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    pass

def show_to_user(data):
    pass

# SQL query to count the number of orders for each shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY ShipVia 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the query and retrieve the data
df_shipping_methods = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of shipping methods
fig = px.bar(df_shipping_methods, x='ShipVia', y='NumberOfOrders', 
             title='Distribution of Shipping Methods',
             labels={'ShipVia': 'Shipping Method', 'NumberOfOrders': 'Number of Orders'})

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS Count
FROM orders
GROUP BY ShipVia
ORDER BY Count DESC
""""""

shipping_methods = execute_sql_query(sql_query)

most_common_shipping_method = shipping_methods.iloc[0]

fig = px.bar(shipping_methods, x='ShipVia', y='Count', title='Distribution of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'Count': 'Number of Orders'})
show_to_user(fig)

most_common_shipping_method
```","The input code correctly follows the logic of the reference implementation. It executes a SQL query to count the number of orders for each shipping method, orders the results by count in descending order, and visualizes the data using a bar chart with Plotly Express. The most common shipping method is also retrieved, matching the requested analysis. The differences in column naming and retrieval operations do not affect the correctness of the solution.","```python
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT ShipVia, COUNT(*) AS OrderCount FROM orders 
GROUP BY ShipVia ORDER BY OrderCount DESC;
""""""

# Execute the SQL query
shipping_data = execute_sql_query(sql_query)

# Create a bar chart to show the distribution of shipping methods
fig = px.bar(shipping_data, x='ShipVia', y='OrderCount', 
             title='Distribution of Shipping Methods', 
             labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'})

# Show the chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request by executing an SQL query to count orders grouped by shipping method, orders them by descending count, and uses Plotly to create a bar chart for visualization. The logic matches the reference implementation effectively, even though the SQL `COUNT` alias is different ('OrderCount' instead of 'NumberOfOrders'). The key functionalities—query execution, grouping, ordering, and visualization—are consistent with the reference.",both
List the orders that were fulfilled late and provide a bar chart showing the number of late orders per month.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch late orders
sql_query = ""SELECT OrderID, ShippedDate FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query to get the data
late_orders_df = execute_sql_query(sql_query)

# Ensure that 'ShippedDate' is in datetime format
late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])

# Add 'Month' column to the DataFrame for counting late orders per month
late_orders_df['Month'] = late_orders_df['ShippedDate'].dt.to_period('M')

# Count late orders per month
late_orders_count = late_orders_df.groupby('Month').size().reset_index(name='LateOrders')

# Create a bar chart to show the number of late orders per month
fig = px.bar(late_orders_count, x='Month', y='LateOrders', title='Number of Late Orders Per Month')

# Display the bar chart
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month,
    COUNT(OrderID) AS LateOrders
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

late_orders_df = execute_sql_query(sql_query)

fig = px.bar(late_orders_df, x='Month', y='LateOrders', title='Number of Late Orders per Month')
show_to_user(fig)
```","The provided input code correctly retrieves the count of late orders per month and generates a bar chart. It fetches late orders by comparing 'ShippedDate' with 'RequiredDate', then groups the results by month using SQL's DATE_TRUNC function. This approach aligns with the reference logic, which performs similar operations in Python. Both codes generate a bar chart of late orders per month, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to get late orders
sql_query = """"""
SELECT OrderID, ShippedDate, RequiredDate
FROM orders
WHERE ShippedDate > RequiredDate;
""""""
late_orders_df = execute_sql_query(sql_query)

# Step 2: Convert ShippedDate to datetime to extract month and year
late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])
late_orders_df['MonthYear'] = late_orders_df['ShippedDate'].dt.to_period('M')

# Step 3: Count late orders per month
late_orders_per_month = late_orders_df.groupby('MonthYear').size().reset_index(name='LateOrdersCount')

# Step 4: Create a bar chart using Plotly
fig = px.bar(late_orders_per_month, x='MonthYear', y='LateOrdersCount',
             title='Number of Late Orders Per Month',
             labels={'MonthYear': 'Month & Year', 'LateOrdersCount': 'Late Orders'})

# Step 5: Display the bar chart to the user
show_to_user(fig)
```","The input code adheres to the business analytics request by listing late orders and creating a bar chart of late orders per month. It uses the correct logic of querying orders where ShippedDate is later than RequiredDate, converts ShippedDate to a datetime format to extract monthly periods, and groups them to count the number of late orders per month. Then, it uses Plotly to create a bar chart, which matches the logic of the reference implementation. The variable names differ slightly, but the logic and output remain consistent with the request and reference code.",both
What percentage of orders were delivered on time in the last quarter? Include a pie chart to visualize the distribution of on-time vs late deliveries.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    SUM(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 ELSE 0 END) AS on_time,
    COUNT(orders.OrderID) AS total_orders
FROM orders
WHERE QUARTER(orders.OrderDate) = (QUARTER(CURDATE()) - 1) 
AND YEAR(orders.OrderDate) = YEAR(CURDATE())
""""""

# Execute SQL query and load results into a DataFrame
df = execute_sql_query(sql_query)

# Calculate on-time delivery rate
if df['total_orders'].iloc[0] > 0:  # Check to avoid division by zero
    df['on_time_delivery_rate'] = df['on_time'] / df['total_orders']
else:
    df['on_time_delivery_rate'] = 0

# Prepare data for visualization
data = {
    ""Status"": [""On-Time"", ""Late""],
    ""Count"": [df['on_time'].iloc[0], df['total_orders'].iloc[0] - df['on_time'].iloc[0]]
}
visual_df = pd.DataFrame(data)

# Create a pie chart using Plotly
fig = px.pie(visual_df, names='Status', values='Count', title='On-Time vs Late Deliveries')

# Show the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve order data for the last quarter
sql_query = """"""
SELECT 
    COUNT(OrderID) AS total_orders, 
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS on_time_deliveries 
FROM 
    orders 
WHERE 
    OrderDate >= DATEADD(QUARTER, -1, GETDATE())
""""""

# Execute the SQL query and retrieve the results
df = execute_sql_query(sql_query)

# Calculate the percentage of on-time deliveries
total_orders = df['total_orders'].values[0]
on_time_deliveries = df['on_time_deliveries'].values[0]
on_time_percentage = (on_time_deliveries / total_orders) * 100 if total_orders > 0 else 0

# Prepare data for pie chart visualization
data = {
    ""Delivery Status"": [""On-time"", ""Late""],
    ""Count"": [on_time_deliveries, total_orders - on_time_deliveries]
}
pie_df = pd.DataFrame(data)

# Create a pie chart
fig = px.pie(pie_df, names='Delivery Status', values='Count', title='On-time vs Late Deliveries in the Last Quarter', hole=0.3)

# Show the percentage to user
show_to_user(fig)

on_time_percentage
```","The input Python code uses DATEADD(QUARTER, -1, GETDATE()) to calculate the last quarter, which does not correctly limit the query to the last quarter as implemented in the reference code. Additionally, the reference code explicitly specifies that the last quarter is determined using QUARTER(orders.OrderDate) = (QUARTER(CURDATE()) - 1) and YEAR(orders.OrderDate) = YEAR(CURDATE()), which ensures it only considers the last quarter of the current year. The reference code also calculates the on-time delivery rate as a fraction, while the input code calculates it as a percentage. These discrepancies might lead to incorrect results compared to the reference implementation.","
```python
import pandas as pd
import plotly.express as px


def calculate_on_time_delivery_rate():
    # SQL query to fetch the required data
    sql_query = """"""
    SELECT 
        COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 100.0 / COUNT(*) AS OnTimeDeliveryRate,
        COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) AS OnTimeCount, 
        COUNT(*) - COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) AS LateCount
    FROM orders 
    WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 3 MONTH) AND CURDATE();
    """"""

    # Execute the SQL query
    query_result = execute_sql_query(sql_query)

    # Calculate the on-time delivery percentage
    on_time_count = query_result['OnTimeCount'][0]
    total_orders = on_time_count + query_result['LateCount'][0]
    if total_orders > 0:
        on_time_delivery_percentage = (on_time_count / total_orders) * 100
    else:
        on_time_delivery_percentage = 0

    # Creating the data for the pie chart
    pie_data = pd.DataFrame({
        'Status': ['On Time', 'Late'],
        'Count': [on_time_count, query_result['LateCount'][0]]
    })

    # Creating the pie chart
    fig = px.pie(
        pie_data,
        names='Status',
        values='Count',
        title='On-Time vs Late Deliveries',
        hole=0.3  # create a donut chart
    )

    # Display the pie chart
    show_to_user(fig)


# Call the function to execute the flow
calculate_on_time_delivery_rate()
```
","The input code incorrectly calculates the quarter using a date range instead of the QUARTER function, potentially leading to inaccurate results for the last quarter. The logic for determining which orders fall within the last quarter is flawed compared to the reference implementation.",None
"What is the total freight cost incurred in each country, and can you provide a comparison using a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to extract the data
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY ShipCountry;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Country')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipCountry
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Country')
show_to_user(fig)
```","The input Python code correctly follows the business analytics request and adheres to the same logic as the reference implementation. Both snippets execute a SQL query to GROUP BY ShipCountry and calculate SUM of Freight, then create a bar chart using Plotly to visualize the total freight cost by country. All necessary steps, including query execution and visualization, are present and functional.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total freight cost by country
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreightCost
FROM orders
GROUP BY ShipCountry
""""""

# Execute the SQL query and get the results in a pandas DataFrame
freight_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total freight cost by country
fig = px.bar(freight_data, x='ShipCountry', y='TotalFreightCost', 
             title='Total Freight Cost by Country', 
             labels={'TotalFreightCost': 'Total Freight Cost', 'ShipCountry': 'Country'})

# Display the bar chart to the user
show_to_user(fig)
```",The input Python code correctly implements the business analytics request by calculating the total freight cost incurred in each country using a SQL query. The only difference compared to the reference implementation is a slight variation in naming ('TotalFreightCost' vs 'TotalFreight') and the addition of labels in the plot. Both differences do not affect the logic or outcome of the task. The resulting bar chart and total freight values remain the same.,both
"What is the total number of unique products ordered? Additionally, can you provide a bar chart showing the count of unique products ordered over time?","```python
import pandas as pd
import plotly.express as px

# Define SQL queries
query_total_unique_products = ""SELECT COUNT(DISTINCT ProductID) as TotalUniqueProducts FROM [Order Details];""
query_unique_products_over_time = """"""
SELECT OrderDate, COUNT(DISTINCT ProductID) as UniqueProducts
FROM [Order Details] od
JOIN Orders o ON od.OrderID = o.OrderID
GROUP BY OrderDate
ORDER BY OrderDate;
""""""

# Execute SQL queries
total_unique_products_df = execute_sql_query(query_total_unique_products)
unique_products_over_time_df = execute_sql_query(query_unique_products_over_time)

# Show the total unique products
show_to_user(total_unique_products_df)

# Create bar chart for unique products over time
fig = px.bar(unique_products_over_time_df, x='OrderDate', y='UniqueProducts', title='Unique Products Ordered Over Time')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.OrderDate, 
    od.ProductID 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.OrderDate, od.ProductID
""""""

df = execute_sql_query(sql_query)

unique_products_count = df['ProductID'].nunique()
time_grouped = df.groupby('OrderDate').agg(unique_products=('ProductID', 'nunique')).reset_index()

fig = px.bar(time_grouped, x='OrderDate', y='unique_products', title='Count of Unique Products Ordered Over Time')
show_to_user(fig)

unique_products_count
```","The input code does not compute the total number of unique products correctly because it incorrectly uses the `nunique()` method on the entire DataFrame instead of directly executing a COUNT DISTINCT SQL query on the ProductID field. The result variable `unique_products_count` should represent the total unique products across the dataset, but it doesn’t. While the visualization logic aligns with the reference by showing a bar chart of unique products over time, the fundamental SQL query needed to calculate the total number of unique products is missing.","
import pandas as pd
import plotly.express as px

# Define a function to execute the SQL query and return the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mocked execution, replace with actual SQL execution code
    # For example, using SQLAlchemy for SQL execution
    pass

# Define a function to display data or visualization to the user
def show_to_user(data):
    # Mocked display function, replace with actual implementation
    pass

# SQL query to get the total number of unique products ordered
sql_query_unique_products = """"""
SELECT COUNT(DISTINCT [Order Details].ProductID) AS UniqueProductsOrdered 
FROM [Order Details];
""""""

# Execute the SQL query to get the total number of unique products
df_unique_products = execute_sql_query(sql_query_unique_products)

# Display the result
show_to_user(df_unique_products)

# SQL query to get the count of unique products ordered over time
sql_query_products_over_time = """"""
SELECT 
    DATE_TRUNC('month', ""Orders"".OrderDate) AS OrderMonth, 
    COUNT(DISTINCT [Order Details].ProductID) AS UniqueProductsOrdered 
FROM [Order Details] 
JOIN ""Orders"" ON [Order Details].OrderID = ""Orders"".OrderID 
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query to get the data for the bar chart
df_products_over_time = execute_sql_query(sql_query_products_over_time)

# Create a bar chart using Plotly
fig = px.bar(df_products_over_time, x='OrderMonth', y='UniqueProductsOrdered', 
             title='Unique Products Ordered Over Time',
             labels={'OrderMonth': 'Order Month', 'UniqueProductsOrdered': 'Unique Products Ordered'})

# Display the bar chart to the user
show_to_user(fig)
","The input Python code correctly addresses the business analytics request by calculating the total number of unique products ordered and creating a bar chart showing the count of unique products over time. Although the SQL syntax uses different nuances (such as `DATE_TRUNC` for monthly aggregation), the logic aligns with the reference implementation's intentions. Both implementations retrieve the same information and display it using Plotly, fulfilling the task requirements.",Finetuned
"What is the distribution of orders shipped per region each month, and how can a monthly trend line chart visualize these distributions?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT DATE_TRUNC('month', ShippedDate) AS Month, ShipRegion, COUNT(OrderID) AS OrdersShipped 
FROM orders 
GROUP BY Month, ShipRegion;
""""""

# Function to execute SQL query and get data as pandas DataFrame
data = execute_sql_query(sql_query)

# Ensure 'Month' is a datetime type for proper sorting
data['Month'] = pd.to_datetime(data['Month'])

# Create a line chart to visualize the distribution of orders shipped per region each month
fig = px.line(
    data, 
    x=""Month"", 
    y=""OrdersShipped"", 
    color=""ShipRegion"",
    title=""Monthly Distribution of Orders Shipped per Region"",
    labels={""OrdersShipped"": ""Number of Orders Shipped"", ""Month"": ""Month""}
)

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    DATE_TRUNC('month', ShippedDate) AS month,
    ShipRegion,
    COUNT(OrderID) AS orders_shipped
FROM
    orders
WHERE
    ShippedDate IS NOT NULL
GROUP BY
    month, ShipRegion
ORDER BY
    month, ShipRegion;
""""""

orders_distribution = execute_sql_query(sql_query)

fig = px.line(orders_distribution, x='month', y='orders_shipped', color='ShipRegion', 
              title='Monthly Distribution of Orders Shipped per Region')
show_to_user(fig)
```","The input code follows the same logic as the reference implementation. It retrieves the monthly number of orders shipped per region using a SQL query, converts the 'month' field to a datetime type implicitly through the query for sorting, and creates a line chart displaying the distribution. The slight differences in variable names and checks for non-null shipped dates do not affect the correctness regarding the request.","```python
import pandas as pd
import plotly.express as px

def plot_monthly_shipped_orders():
    # Define the SQL query
    sql_query = """"""
    SELECT 
        EXTRACT(YEAR FROM ShippedDate) AS Year, 
        EXTRACT(MONTH FROM ShippedDate) AS Month, 
        ShipRegion, 
        COUNT(*) AS OrderCount 
    FROM 
        orders 
    GROUP BY 
        Year, Month, ShipRegion 
    ORDER BY 
        Year, Month, ShipRegion;
    """"""
    
    # Execute the SQL query and get the result as a DataFrame
    df = execute_sql_query(sql_query)
    
    # Convert 'Year' and 'Month' to a datetime period for accurate plotting
    df['Date'] = pd.to_datetime(df[['Year', 'Month']].assign(DAY=1))
    
    # Create a trend line chart using Plotly
    fig = px.line(
        df, 
        x='Date', 
        y='OrderCount', 
        color='ShipRegion',
        title='Monthly Distribution of Shipped Orders per Region',
        labels={'OrderCount':'Number of Orders', 'Date':'Date'}
    )
    
    # Display the visualization
    show_to_user(fig)

# Run the function to perform the analysis and display the trend line chart
plot_monthly_shipped_orders()
```","Both implementations aim to visualize the monthly distribution of orders shipped per region. The reference code groups by truncated month and ShipRegion, counting orders directly. The input code calculates year and month separately but combines them into a datetime object for plotting. Both methods achieve the same end result because they group by month and region, counting orders per group. The line chart visualization with Plotly is consistent across both implementations, using the month and order count, colored by region.",both
"How many orders were placed each month, and can you provide a line graph to visualize the trends over time?","```python
import plotly.express as px
import pandas as pd

# Execute SQL query to get the data
sql_query = """"""
SELECT COUNT(OrderID) AS OrderCount, 
       EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month 
FROM orders 
GROUP BY Year, Month;
""""""
order_data = execute_sql_query(sql_query)

# Create a new column for Year-Month
order_data['YearMonth'] = pd.to_datetime(order_data['Year'].astype(str) + '-' + order_data['Month'].astype(str), format='%Y-%m')

# Sort the data by YearMonth
order_data.sort_values('YearMonth', inplace=True)

# Create a line graph using Plotly
fig = px.line(order_data, x='YearMonth', y='OrderCount', title='Monthly Order Counts Over Time', labels={'OrderCount': 'Number of Orders', 'YearMonth': 'Year-Month'})

# Show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count orders by month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY OrderMonth
ORDER BY OrderMonth
""""""

# Execute the SQL query
monthly_orders_df = execute_sql_query(sql_query)

# Create a line graph to visualize the trends over time
fig = px.line(monthly_orders_df, x='OrderMonth', y='OrderCount', title='Number of Orders Placed Each Month', labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","Both the input and reference code aim to count the number of orders placed each month and visualize them with a line graph. The main difference is the approach: the input code uses SQL's DATE_FORMAT to directly format the date into 'Year-Month', while the reference code does it post-query in Python. Both methods result in the same outcome of organizing orders by month. Additionally, the input code incorporates sorting within SQL, matching the logic of sorting in the reference code using Pandas. Therefore, the input code correctly adheres to the business request using the same logic as the reference.","```python
import plotly.express as px
import pandas as pd

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation for executing SQL and returning a DataFrame
    pass

# Function to show data or visualizations to the user
def show_to_user(data):
    # Placeholder implementation for displaying data
    pass

# SQL query to fetch order data per month
sql_query = """"""
SELECT TO_CHAR(OrderDate, 'YYYY-MM') AS Month, COUNT(*) AS NumberOfOrders 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query and fetch results into a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(
    orders_df,
    x='Month',
    y='NumberOfOrders',
    title='Number of Orders Placed Each Month',
    labels={'NumberOfOrders': 'Number of Orders', 'Month': 'Month'}
)

# Display the line graph
show_to_user(fig)
```","The input code achieves the same objective as the reference implementation. Both codes execute a SQL query to obtain the order counts for each month. The input code uses 'TO_CHAR(OrderDate, 'YYYY-MM')' to group data by year and month, which is equivalent to extracting year and month in separate steps and then combining them, as done in the reference code. The visualization step in both codes employs Plotly to generate a line graph of monthly order counts. Given that the input code generates the correct monthly order count data and appropriately visualizes it, it is considered correct.",both
What is the on-time delivery rate for each shipping method? Please include a bar chart to visualize the comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get on-time delivery rate by shipping method
sql_query = """"""
SELECT ShipVia, 
ROUND(100.0 * SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) / COUNT(OrderID), 2) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipVia', y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rate by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'},
             text='OnTimeDeliveryRate')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipVia,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    ShipVia
""""""

result_df = execute_sql_query(sql_query)

result_df['OnTimeRate'] = result_df['OnTimeDeliveries'] / result_df['TotalOrders'] * 100

fig = px.bar(result_df, x='ShipVia', y='OnTimeRate', 
              title='On-Time Delivery Rate by Shipping Method',
              labels={'ShipVia': 'Shipping Method', 'OnTimeRate': 'On-Time Delivery Rate (%)'})

show_to_user(fig)
```","The input Python code calculates the on-time delivery rate in a logically equivalent manner to the reference implementation. It calculates the total orders and on-time deliveries per shipping method and then computes the on-time delivery rate. This aligns with the logic in the reference code, which performs a similar computation using a SQL query. The visualization created (bar chart) also matches the requirement of the business analytics request, similar to the reference code.","```python
import plotly.express as px
import pandas as pd

# Assuming the SQL query function is available in the environment 
sql_query = """"""
    SELECT ShipVia, 
           COUNT(CASE WHEN ShippedDate <= RequiredDate THEN OrderID END) * 100.0 / COUNT(OrderID) AS OnTimeDeliveryRate 
    FROM orders 
    GROUP BY ShipVia;
""""""

# Execute the SQL query and store the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize on-time delivery rate by shipping method
fig = px.bar(
    df, 
    x='ShipVia', 
    y='OnTimeDeliveryRate', 
    title='On-Time Delivery Rate by Shipping Method',
    labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'ShipVia': 'Shipping Method'},
    text='OnTimeDeliveryRate'
)

# Display the bar chart using the provided utility function
show_to_user(fig)
```","The input Python code evaluates the on-time delivery rate per shipping method similarly to the reference implementation. Both SQL queries calculate the rate by checking if the 'ShippedDate' is less than or equal to the 'RequiredDate'. They then divide the count of on-time orders by the total number of orders and multiply by 100 to express it as a percentage. The visualization part is identical, using Plotly to create a bar chart. Thus, the input code correctly implements the logic outlined in the business analytics request.",both
Which category of products has generated the most revenue? Please include a bar chart to visualize the revenue by product category.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the revenue by product category
sql_query = """"""
SELECT CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY CategoryID
ORDER BY TotalRevenue DESC;
""""""
# Assume execute_sql_query is a predefined function that returns a DataFrame
revenue_data = execute_sql_query(sql_query)

# Visualize the revenue by category using a bar chart
fig = px.bar(revenue_data, x='CategoryID', y='TotalRevenue', 
             title='Revenue by Product Category',
             labels={'CategoryID': 'Product Category', 'TotalRevenue': 'Total Revenue'})

# Display the bar chart using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS Revenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY Revenue DESC
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='CategoryID', y='Revenue', title='Revenue by Product Category', labels={'CategoryID': 'Product Category', 'Revenue': 'Total Revenue'})
show_to_user(fig)
```","The input code calculates revenue by considering discounts ('od.Discount'), whereas the reference code does not factor in discounts. This means the logic for calculating revenue is different. Therefore, the input code is not following the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

def analyze_revenue_by_category():
    # SQL query to execute
    sql_query = '''
    SELECT CategoryID, 
           SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
    FROM products p 
    JOIN ""Order Details"" od ON p.ProductID = od.ProductID 
    GROUP BY CategoryID 
    ORDER BY TotalRevenue DESC;
    '''
    
    # Execute the SQL query to get results into a DataFrame
    df = execute_sql_query(sql_query)
    
    # Create a bar chart using Plotly to visualize revenue by category
    fig = px.bar(df, x='CategoryID', y='TotalRevenue', title='Revenue by Product Category', labels={'CategoryID': 'Product Category', 'TotalRevenue': 'Total Revenue'})
    
    # Display the bar chart
    show_to_user(fig)

# Execute the function
analyze_revenue_by_category()
```","The input Python code applies a discount in the revenue calculation, which is not present in the reference implementation. The reference code calculates revenue using only the UnitPrice and Quantity, not accounting for any Discount. Thus, the logic is different.",None
"What are the total sales for each product over the last year, and can you provide a bar chart to visualize these sales?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity * 
           (1 - [Order Details].Discount) * 
           [Order Details].UnitPrice) AS TotalSales 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName;
""""""

# Execute the SQL query and get a DataFrame
df_sales = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_sales, x='ProductName', y='TotalSales', title='Total Sales by Product Over the Last Year')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last year
end_date = datetime.now()
start_date = end_date - timedelta(days=365)

# SQL query to get total sales for each product over the last year
sql_query = f""""""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID FROM [Orders] 
    WHERE OrderDate >= '{start_date.strftime('%Y-%m-%d')}' 
    AND OrderDate <= '{end_date.strftime('%Y-%m-%d')}'
)
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart for the total sales
fig = px.bar(sales_data, x='ProductName', y='TotalSales', 
             title='Total Sales for Each Product Over the Last Year',
             labels={'TotalSales': 'Total Sales ($)', 'ProductName': 'Product Name'},
             text='TotalSales')

# Show the plot to the user
show_to_user(fig)
```","The input code correctly computes the total sales for each product over the last year by using a similar SQL query logic. It calculates sales using the quantity, unit price, and discount from order details, filters orders based on the date range for the last year, and groups by product. The resultant DataFrame is then used to create a bar chart using Plotly. The code produces the intended results and aligns with the reference implementation despite additional functionalities like ordering results by sales and adding labels to the chart.","```python
import pandas as pd
import plotly.express as px

# Business Analytic Request: Total sales for each product over the last year
# SQL query provided
sql_query = """"""
SELECT P.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS ProductSales 
FROM [Order Details] 
JOIN products P ON [Order Details].ProductID = P.ProductID 
JOIN orders O ON [Order Details].OrderID = O.OrderID 
WHERE O.OrderDate BETWEEN '2022-10-01' AND '2023-10-01' 
GROUP BY P.ProductName
""""""

# Define a function to execute SQL query and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function: Replace with actual DB execution code
    pass

# Define a function to show results to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame) or isinstance(data, px.Figure):
        # Simulated function: Replace with actual show logic if required
        pass

# Execute the SQL query to get sales data
sales_data = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(sales_data, x='ProductName', y='ProductSales', 
             title='Total Sales for Each Product Over the Last Year',
             labels={'ProductName': 'Product Name', 'ProductSales': 'Total Sales'},
             template='plotly')

# Show the resulting bar chart
show_to_user(fig)
```","The input code correctly implements the business analytics request. It calculates total sales for each product by summing the quantity multiplied by the unit price, adjusted for the discount, similar to the reference implementation. The input code also filters orders based on the specified date range, which aligns with the 'last year' requirement. Finally, it presents the total sales in a bar chart using Plotly, fulfilling the visualization request.",both
"Which orders had the highest freight costs, and can you provide a visualization ranking these orders by freight cost?","```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query and get the data as a DataFrame
sql_query = ""SELECT o.OrderID, o.Freight FROM orders o ORDER BY o.Freight DESC;""
orders_df = execute_sql_query(sql_query)

# Step 2: Visualize the orders ranked by freight cost using Plotly
fig = px.bar(orders_df, x='OrderID', y='Freight', title='Orders Ranked by Freight Cost',
             labels={'Freight': 'Freight Cost', 'OrderID': 'Order ID'},
             template='plotly')

# Step 3: Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, Freight
FROM orders
ORDER BY Freight DESC
LIMIT 10;
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='OrderID', y='Freight', title='Top 10 Orders by Freight Cost', labels={'Freight': 'Freight Cost', 'OrderID': 'Order ID'})
show_to_user(fig)
```","The input code limits the visualization to the top 10 orders by freight cost using 'LIMIT 10', which is not present in the reference implementation. The business request is to rank orders by freight cost without a specified limit.","Certainly! We can execute the SQL query provided using the `execute_sql_query` utility function and then use the `show_to_user` function to visualize the results. Here’s an example Python code that accomplishes this:

```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get order information with printable freight costs
sql_query = """"""
    SELECT OrderID, Freight AS Cost 
    FROM orders 
    ORDER BY Freight DESC 
    LIMIT 10;
""""""

# Retrieve the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 10 orders by freight cost
fig = px.bar(df, x='OrderID', y='Cost', title='Top 10 Orders by Freight Cost',
             labels={'OrderID': 'Order ID', 'Cost': 'Freight Cost USD'},
             text='Cost')

# Update layout for better visualization
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')

# Display the visualization to the user
show_to_user(fig)
```

This code retrieves the top 10 orders with the highest freight costs and visualizes them using a Plotly bar chart, making it easier for the user to understand which orders are incurring the most freight costs.","The input code limits the results to the top 10 orders by freight cost, while the reference code ranks all orders by freight cost without limitation. This changes the scope of the task and therefore doesn't fully adhere to the reference implementation's logic.",None
"Which employee made the highest sales in July 2023, and can you provide a bar chart to display the sales figures for all employees?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a mock function. In a real scenario, it would execute the provided SQL on a database.
    # For example, using a connection with pandas read_sql_query method:
    # return pd.read_sql_query(sql_query, connection)
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        # Handle DataFrame display logic if necessary
        print(data)
    elif isinstance(data, (px.Figure)):
        data.show()

# SQL to retrieve all employees' sales in July 2023
all_sales_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-07-01' AND '2023-07-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC
""""""

# Execute the query to get sales data for all employees
sales_df = execute_sql_query(all_sales_query)

# Check if the query returned any results
if sales_df is not None and not sales_df.empty:
    # Determine the employee with the highest sales
    top_employee = sales_df.iloc[0]

    # Print out the employee with the highest sales
    print(f""Employee {top_employee['EmployeeID']} made the highest sales in July 2023 with total sales of {top_employee['total_sales']}."")

    # Create a bar chart to display the sales figures for all employees
    fig = px.bar(sales_df, x='EmployeeID', y='total_sales', title='Sales by Employee for July 2023')

    # Show the plot
    show_to_user(fig)
else:
    print(""No sales data available for July 2023."")
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get employee sales in July 2023
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-07-01' AND '2023-07-31'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY employee_sales DESC
""""""

# Execute SQL query
employee_sales_df = execute_sql_query(sql_query)

# Get the employee with the highest sales
top_employee = employee_sales_df.iloc[0]

# SQL query to get all employees sales for July 2023
sql_query_all = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-07-01' AND '2023-07-31'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
""""""

# Execute SQL query
all_employee_sales_df = execute_sql_query(sql_query_all)

# Create bar chart
fig = px.bar(all_employee_sales_df, x='FirstName', y='employee_sales', 
             title='Employee Sales in July 2023', 
             labels={'FirstName': 'Employee Name', 'employee_sales': 'Sales Amount'})

# Show to user
show_to_user(fig)

top_employee
```","The input code correctly follows the logic of the reference implementation and meets the business request. It executes a SQL query to obtain sales data for employees in July 2023, identifies the employee with the highest sales, and creates a bar chart to display sales for all employees. The use of additional employee details (first name and last name) does not affect the correctness of the operation, as it provides more context in the visualization. Both versions effectively achieve the task's objectives.","
```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function. The actual implementation will be provided separately.
    pass

def show_to_user(data):
    # This is a placeholder function. The actual implementation will be provided separately.
    pass

# SQL query to fetch total sales by employee for July 2023
sql_query = """"""
SELECT employees.EmployeeID, 
       FIRST_NAME, LAST_NAME, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS salesperson_sales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE MONTH(orders.OrderDate) = 7 
AND YEAR(orders.OrderDate) = 2023 
GROUP BY employees.EmployeeID, FIRST_NAME, LAST_NAME 
ORDER BY salesperson_sales DESC
""""""

# Execute the query and fetch results into a DataFrame
sales_data = execute_sql_query(sql_query)

# Display the employee with the highest sales
highest_sales_employee = sales_data.head(1)
show_to_user(highest_sales_employee)

# Create a bar chart for all employee sales
fig = px.bar(sales_data, 
             x='EmployeeID', 
             y='salesperson_sales', 
             hover_data=['FIRST_NAME', 'LAST_NAME'],
             title='Sales Figures for Employees - July 2023',
             labels={'salesperson_sales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request. It executes a SQL query to fetch sales data for each employee for July 2023, determines the top salesperson, and generates a bar chart to display the sales figures for all employees. Although the SQL syntax and column selections differ slightly, it achieves the same outcome as the reference code. Both implementations perform grouping, sorting, and aggregation of sales data correctly. Additionally, both implementations display the top-performing employee and a bar chart visualizing the sales data, satisfying the request requirements.",both
"Identify products due for reorder based on their reorder level and current stock, and visualize the potential shortfall with a bar chart.","```python
import plotly.express as px
import pandas as pd

# SQL Query to identify products due for reorder
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel;
""""""

# Execute the SQL query and obtain the result as a DataFrame
reorder_df = execute_sql_query(sql_query)

# Calculate the shortfall for visualization purposes
reorder_df['Shortfall'] = reorder_df['ReorderLevel'] - reorder_df['UnitsInStock']

# Create a bar chart to visualize the potential shortfall
fig = px.bar(
    reorder_df,
    x='ProductName',
    y='Shortfall',
    title='Potential Product Shortfall',
    labels={'Shortfall': 'Units Shortfall', 'ProductName': 'Product Name'}
)

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0;
""""""

products_df = execute_sql_query(sql_query)

products_df['Shortfall'] = products_df['ReorderLevel'] - products_df['UnitsInStock']
products_due_reorder = products_df[products_df['Shortfall'] > 0]

fig = px.bar(products_due_reorder, 
              x='ProductName', 
              y='Shortfall', 
              title='Products Due for Reorder',
              labels={'Shortfall': 'Units Needed to Reorder', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code includes products based on `Discontinued = 0` rather than comparing `UnitsInStock` with `ReorderLevel` directly, leading to inconsistencies with the reference code logic. The reference focuses only on products where `UnitsInStock <= ReorderLevel` to find products due for reorder.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(query: str) -> pd.DataFrame:
    # This function simulates SQL query execution and returns a DataFrame.
    # Actual implementation would involve database connection and query execution.
    # For demonstration, assume it returns a DataFrame as expected.
    return pd.DataFrame({
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'Units': [5, 0, 8]
    })

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# SQL query to identify products due for reorder
sql_query = """"""
SELECT p.ProductName, p.ReorderLevel - p.UnitsInStock AS Units 
FROM products p 
WHERE p.UnitsInStock < p.ReorderLevel;
""""""

# Execute the SQL query and get the result as a DataFrame
df_reorder_products = execute_sql_query(sql_query)

# Visualize the potential shortfall with a bar chart
fig = px.bar(df_reorder_products, x='ProductName', y='Units',
             title='Products Due for Reorder',
             labels={'Units': 'Units Shortfall'})

# Display the resulting DataFrame and bar chart
show_to_user(df_reorder_products)
show_to_user(fig)
```","The input code calculates 'Units' as 'ReorderLevel - UnitsInStock' in the SQL query, and this represents the shortfall correctly. However, it specifies the condition 'p.UnitsInStock < p.ReorderLevel' instead of 'p.UnitsInStock <= p.ReorderLevel', excluding cases where stock is exactly equal to the reorder level. This discrepancy can lead to missing some products in the output compared to the reference implementation.",None
"Which shipping company has the highest average cost per shipment, and can this be illustrated with a bar chart for better comparison?","```python
import plotly.express as px

# SQL Query to fetch average cost per shipment by shipping company
sql_query = """"""
SELECT ShipVia, AVG(Freight) AS AverageCost 
FROM orders 
GROUP BY ShipVia 
ORDER BY AverageCost DESC
""""""

# Execute the SQL query and fetch the data as a pandas DataFrame
shipping_cost_data = execute_sql_query(sql_query)

# Create a bar chart to illustrate the average cost per shipment by shipping company
fig = px.bar(shipping_cost_data, x='ShipVia', y='AverageCost', 
             title='Average Cost per Shipment by Shipping Company', 
             labels={'ShipVia': 'Shipping Company', 'AverageCost': 'Average Cost'},
             text='AverageCost')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(Freight) AS Average_Cost
FROM orders
GROUP BY ShipVia
ORDER BY Average_Cost DESC
LIMIT 1
""""""

highest_avg_cost_df = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT ShipVia, AVG(Freight) AS Average_Cost
FROM orders
GROUP BY ShipVia
""""""

all_avg_cost_df = execute_sql_query(sql_query_all)

fig = px.bar(all_avg_cost_df, x='ShipVia', y='Average_Cost', 
              title='Average Shipping Cost per Shipment by Shipping Company',
              labels={'ShipVia': 'Shipping Company', 'Average_Cost': 'Average Cost (Freight)'})

show_to_user(fig)
```","The input Python code successfully answers the business analytics request. It executes a SQL query to determine which shipping company has the highest average cost per shipment and constructs a separate query to present all companies in a bar chart for comparison. This approach is logically consistent with the reference implementation, which also focuses on fetching average costs and displaying them in a bar chart.","```python
import plotly.express as px

# Define an SQL query to get average shipping costs per company
sql_query = """"""
SELECT shippers.CompanyName, AVG(orders.Freight) AS AverageFreight
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY AverageFreight DESC;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average shipping cost per company
fig = px.bar(df, x='CompanyName', y='AverageFreight', 
             title='Average Shipping Cost per Company',
             labels={'CompanyName': 'Company Name', 'AverageFreight': 'Average Cost'},
             text='AverageFreight')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly calculates the average freight cost per shipment by shipping company and generates a bar chart similar to the reference implementation. Both queries calculate averages by grouping shipments, and the bar chart visualization follows the same logic, showing average costs per company. While the input code includes a JOIN to fetch company names, the core logic remains consistent with the request.",both
"What is the percentage of total sales contributed by each supplier, and can this be visualized using a pie chart or bar graph for clarity?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.SupplierID, 
       (SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
       (SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) 
        FROM [Order Details] 
        JOIN products ON [Order Details].ProductID = products.ProductID)) * 100 
       AS supplier_sales_percentage 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a pie chart for visualization
fig = px.pie(sales_data, values='supplier_sales_percentage', names='SupplierID', 
             title='Percentage of Total Sales by Supplier')

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS supplier_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
GROUP BY suppliers.SupplierID, suppliers.CompanyName
""""""

supplier_sales_df = execute_sql_query(sql_query)

total_sales = supplier_sales_df['supplier_sales'].sum()
supplier_sales_df['percentage_contribution'] = (supplier_sales_df['supplier_sales'] / total_sales) * 100

fig = px.pie(supplier_sales_df, values='percentage_contribution', names='CompanyName', title='Percentage of Total Sales by Supplier')
show_to_user(fig)
```","The input code correctly computes the percentage of total sales contributed by each supplier. It aggregates sales data by multiplying UnitPrice, Quantity, and the discount factor, and then calculates the percentage contribution of each supplier's sales based on the total sales. The results are visualized using a pie chart, which aligns with the reference implementation's logic. Although the input code includes the supplier names for clarity and uses a slightly different SQL and DataFrame manipulation approach, it adheres to the same logical output as the reference code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    s.SupplierID, 
    s.CompanyName, 
    (SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / 
     (SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) 
      FROM [Order Details] od 
      JOIN products p ON od.ProductID = p.ProductID)) * 100 AS SupplierShare 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID, s.CompanyName;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to represent SQL execution
    # Replace with actual implementation
    pass

def show_to_user(data):
    # Placeholder function to represent showing to user
    # Replace with actual implementation
    pass

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize using a pie chart
fig = px.pie(
    df, 
    names='CompanyName', 
    values='SupplierShare', 
    title='Percentage of Total Sales Contributed by Each Supplier'
)

# Display the pie chart
show_to_user(fig)
```","The input code correctly calculates the percentage of total sales contributed by each supplier using the same logic as the reference implementation. It does so by joining the `Order Details`, `products`, and `suppliers` tables, calculating the total sales amount for each supplier, and dividing it by the total sales amount from all suppliers. The result is grouped by SupplierID and CompanyName. The visualization part uses Plotly Express to create a pie chart with the supplier percentage shares as values, similar to the reference code. The inclusion of the 'CompanyName' in the grouping and visualization does not alter the correctness as it enhances the clarity by providing company names instead of IDs.",both
"What is the retention rate for January 2023, and can you provide a line graph to illustrate trends over the preceding six months?","```python
import pandas as pd
import plotly.express as px

# Placeholder function to execute the supplied SQL query and return the resulting DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function needs to be implemented to properly interact with the actual database
    pass

# Placeholder function to display data to the user
def show_to_user(data):
    # This function needs to be implemented to properly display data to the user
    pass

# SQL query to get the retention rates for the past six months including January 2023
sql_query_template = """"""
SELECT
    EXTRACT(YEAR FROM orders.OrderDate) AS Year,
    EXTRACT(MONTH FROM orders.OrderDate) AS Month,
    (COUNT(DISTINCT CASE WHEN orders.OrderDate BETWEEN '{year_month_start}' AND '{year_month_end}' THEN orders.CustomerID END) * 1.0) /
    NULLIF(COUNT(DISTINCT CASE WHEN orders.OrderDate < '{year_month_start}' THEN orders.CustomerID END), 0) AS RetentionRate
FROM orders
GROUP BY Year, Month
ORDER BY Year DESC, Month DESC
LIMIT 6;
""""""

# Generate the required date ranges for the past six months including January 2023
date_ranges = [
    ('2023-01-01', '2023-01-31'),
    ('2022-12-01', '2022-12-31'),
    ('2022-11-01', '2022-11-30'),
    ('2022-10-01', '2022-10-31'),
    ('2022-09-01', '2022-09-30'),
    ('2022-08-01', '2022-08-31')
]

# Create an empty DataFrame to collect retention rates
retention_df = pd.DataFrame()

# Loop over each date range to execute SQL query and collect results
for start_date, end_date in date_ranges:
    formatted_sql_query = sql_query_template.format(year_month_start=start_date, year_month_end=end_date)
    result_df = execute_sql_query(formatted_sql_query)

    # Append result to the main DataFrame
    retention_df = retention_df.append(result_df, ignore_index=True)

# Convert Year and Month to datetime for plotting
retention_df['Date'] = pd.to_datetime(retention_df[['Year', 'Month']].assign(DAY=1))

# Sort DataFrame by Date
retention_df = retention_df.sort_values('Date')

# Plot the retention rate using Plotly
fig = px.line(retention_df, x='Date', y='RetentionRate', title='Customer Retention Rate Over Past Six Months')

# Display the result using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the start and end date for the retention analysis
end_date = '2023-01-31'
start_date = '2022-07-01'

# SQL query to get the number of returning customers for January 2023
retained_customers_query = f""""""
SELECT COUNT(DISTINCT o.CustomerID) AS RetainedCustomers
FROM orders o
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
""""""

# SQL query to get the total number of customers before January 2023
total_customers_query = f""""""
SELECT COUNT(DISTINCT o.CustomerID) AS TotalCustomers
FROM orders o
WHERE o.OrderDate < '2023-01-01'
""""""

# Execute both queries
retained_customers_df = execute_sql_query(retained_customers_query)
total_customers_df = execute_sql_query(total_customers_query)

# Calculate retention rate
retention_rate = (retained_customers_df['RetainedCustomers'].iloc[0] / total_customers_df['TotalCustomers'].iloc[0]) * 100

# SQL query to get monthly retention data for the last six months
monthly_retention_query = f""""""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
       COUNT(DISTINCT o.CustomerID) AS ReturningCustomers
FROM orders o
WHERE o.OrderDate BETWEEN DATE_SUB('2023-01-01', INTERVAL 6 MONTH) AND '2023-01-31'
GROUP BY Month
ORDER BY Month
""""""

# Execute the monthly retention query
monthly_retention_df = execute_sql_query(monthly_retention_query)

# Create the line graph
fig = px.line(monthly_retention_df, x='Month', y='ReturningCustomers', title='Customer Retention Trend Over Last Six Months', labels={'ReturningCustomers': 'Returning Customers'})
show_to_user(fig)

retention_rate
```","The provided code does not accurately compute the retention rate as described in the business request. The reference code calculates retention as the ratio of current month retained customers to previous month customers, while the input code calculates it for January separately and uses a different logic for the line graph.","import pandas as pd
import plotly.express as px

# SQL query for January 2023
query_january_2023 = """"""
SELECT 
    COUNT(DISTINCT o.CustomerID) AS retained_customers 
FROM 
    orders o 
WHERE 
    o.OrderDate BETWEEN '2023-01-01' AND '2023-01-31' 
    AND o.CustomerID IN (
        SELECT CustomerID 
        FROM orders 
        WHERE OrderDate < '2023-01-01'
    )
""""""

# SQL query for retention data over the preceding six months
query_previous_six_months = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS month, 
    COUNT(DISTINCT o.CustomerID) AS retained_customers
FROM 
    orders o 
WHERE 
    o.OrderDate BETWEEN '2022-07-01' AND '2022-12-31'
GROUP BY 
    month
ORDER BY 
    month
""""""

# Execute SQL queries
january_data = execute_sql_query(query_january_2023)
previous_data = execute_sql_query(query_previous_six_months)

# Calculate retention rate
january_retention_rate = january_data.iloc[0]['retained_customers'] / previous_data['retained_customers'].sum()

# Add January data to previous data for visualization
previous_data = previous_data.append({'month': '2023-01-01', 'retained_customers': january_data.iloc[0]['retained_customers']}, ignore_index=True)

# Create a line graph using Plotly
fig = px.line(previous_data, x='month', y='retained_customers', 
              title='Customer Retention Trends Over Past 6 Months', 
              labels={'retained_customers': 'Number of Retained Customers'})

# Display the line graph
show_to_user(fig)

# Display the retention rate for January 2023
show_to_user(pd.DataFrame({'January 2023 Retention Rate': [january_retention_rate]}))","The input code calculates the number of retained customers, but it uses a different logic than the reference code. The reference code calculates the retention rate by dividing the number of distinct customers in a given month by the number of distinct customers from previous months. The input code does not compute retention rates correctly, as it sums retained customers instead of using distinct counts for a rate calculation. Furthermore, it does not align logically with the reference method of calculating retention rates for each month over the past six months and plotting them.",None
"What is the lifetime value of each customer, and can it be visualized through a bar chart to compare values across different customer segments?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the lifetime value of each customer
sql_query = """"""
SELECT customers.CustomerID, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS LifetimeValue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID
""""""

# Execute the SQL query and get the result as a pandas DataFrame
data = execute_sql_query(sql_query)

# Visualize the lifetime value by creating a bar chart
fig = px.bar(data, x='CustomerID', y='LifetimeValue', title='Customer Lifetime Value', labels={'LifetimeValue':'Lifetime Value', 'CustomerID':'Customer ID'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue,
    c.Region
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.Region
""""""

customer_lifetime_value_df = execute_sql_query(sql_query)

fig = px.bar(customer_lifetime_value_df, 
             x='CustomerID', 
             y='LifetimeValue', 
             color='Region', 
             title='Customer Lifetime Value by Segment', 
             labels={'LifetimeValue': 'Lifetime Value', 'CustomerID': 'Customer ID'})

show_to_user(fig)
```","The input code includes an additional field 'Region' in the SQL query and groups by 'CustomerID' and 'Region'. It visualizes the data with a color distinction by 'Region', which is not part of the original business analytics request or reference implementation. The original request and reference implementation focus solely on 'CustomerID' and 'LifetimeValue', without segmenting by 'Region'.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query is a utility function that has been defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation
    return pd.read_csv('data.csv')  # Assume data is in CSV for demonstration

def show_to_user(data):
    # Placeholder function for demonstration
    print(data)

# SQL query to retrieve customer lifetime value data
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS CustomerLifetimeValue, 
       c.Segment 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID, c.Segment;
""""""

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Group data by Segment and aggregate Customer Lifetime Value
grouped_df = df.groupby('Segment', as_index=False).agg({'CustomerLifetimeValue': 'sum'})

# Create a bar chart to visualize Customer Lifetime Value by segment using Plotly
fig = px.bar(grouped_df,
             x='Segment',
             y='CustomerLifetimeValue',
             title='Customer Lifetime Value by Segment',
             labels={'CustomerLifetimeValue': 'Lifetime Value', 'Segment': 'Customer Segment'})

# Display the figure to the user
show_to_user(fig)
```","The input code calculates and visualizes Customer Lifetime Value (CLV) aggregated by 'Segment', which differs from the reference implementation that calculates CLV for each individual customer. The input code, therefore, doesn't fully adhere to the logic specified in the reference task where the focus is on individual customer comparison rather than segment comparison.",None
"Identify suppliers whose lead time is reducing over the last six months, and visualize the trend of lead times for these suppliers.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve suppliers with lead times over the last 6 months
sql_query = """"""
SELECT 
    suppliers.SupplierID, 
    orders.OrderDate, 
    DATEDIFF(orders.ShippedDate, orders.OrderDate) AS LeadTime 
FROM 
    suppliers 
JOIN 
    products ON suppliers.SupplierID = products.SupplierID 
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN CURRENT_DATE - INTERVAL '6 MONTH' AND CURRENT_DATE
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Calculate monthly average lead time for each supplier
data['OrderMonth'] = data['OrderDate'].dt.to_period('M')
monthly_avg_lead_time = data.groupby(['SupplierID', 'OrderMonth']).LeadTime.mean().reset_index()

# Identify suppliers whose lead time is reducing
suppliers_trend = monthly_avg_lead_time.pivot(index='OrderMonth', columns='SupplierID', values='LeadTime')
reducing_suppliers = []
for supplier_id in suppliers_trend.columns:
    trend = suppliers_trend[supplier_id].dropna()
    if trend.is_monotonic_decreasing:
        reducing_suppliers.append(supplier_id)

# Filter data for reducing suppliers and visualize trends
reducing_data = monthly_avg_lead_time[monthly_avg_lead_time['SupplierID'].isin(reducing_suppliers)]

# Plotting the trend of lead times for these suppliers
fig = px.line(reducing_data, x='OrderMonth', y='LeadTime', color='SupplierID', 
              title='Trend of Lead Times for Suppliers with Reducing Lead Time Over the Last 6 Months',
              labels={'OrderMonth': 'Order Month', 'LeadTime': 'Average Lead Time (Days)'})

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the date range for the last six months
end_date = datetime.now()
start_date = end_date - timedelta(days=180)

# SQL query to calculate average lead time per supplier in the last 6 months
sql_query = f""""""
SELECT 
    s.SupplierID,
    s.CompanyName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    orders o ON p.ProductID = o.OrderID
WHERE 
    o.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY 
    s.SupplierID, Month
ORDER BY 
    s.SupplierID, Month
""""""

# Execute the query and get the result
lead_times_df = execute_sql_query(sql_query)

# Pivot the DataFrame to have months as rows and suppliers as columns
lead_times_pivot = lead_times_df.pivot(index='Month', columns='CompanyName', values='AvgLeadTime')

# Filter suppliers whose lead time is reducing over the last 6 months
reducing_suppliers = lead_times_pivot.dropna().loc[
    (lead_times_pivot.diff().iloc[-1] < 0)  # Check if the last entry is lower than the previous
]

# Visualize the trend of lead times for reducing suppliers
fig = px.line(reducing_suppliers, title='Lead Time Trend for Reducing Suppliers', labels={'value': 'Average Lead Time (Days)', 'Month': 'Month'})
show_to_user(fig)
```","The input code does not accurately identify suppliers who have a consistent decreasing trend in lead times. It only checks if the last recorded lead time is lower than the previous one, not if the entire trend is decreasing. Additionally, there is an error in the SQL query where it links the 'ProductID' to the 'OrderID' instead of 'Order Details'. Lastly, the pivot uses 'CompanyName' rather than 'SupplierID', potentially altering the intended identification and visualization.","
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Stub for execution logic
    # Replace with actual database call logic
    pass

def show_to_user(data):
    # Stub for visualization logic
    # Replace with actual display logic
    pass

# SQL Query to identify suppliers with reducing lead times
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS avg_lead_time
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON o.OrderID = od.OrderID 
WHERE MONTH(o.OrderDate) BETWEEN MONTH(CURRENT_DATE - INTERVAL 6 MONTH) AND MONTH(CURRENT_DATE)
GROUP BY s.SupplierID, s.CompanyName
ORDER BY avg_lead_time DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
supplier_lead_times_df = execute_sql_query(sql_query)

# Process the DataFrame to get lead times over the last six months for visualization
lead_time_trend_data = []

for month_offset in range(6):
    month_date = datetime.now() - timedelta(days=30 * month_offset)
    month_str = month_date.strftime('%Y-%m')
    
    monthly_query = f""""""
    SELECT s.SupplierID, s.CompanyName, DATEDIFF(o.ShippedDate, o.OrderDate) AS lead_time
    FROM suppliers s 
    JOIN products p ON s.SupplierID = p.SupplierID 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    JOIN orders o ON o.OrderID = od.OrderID 
    WHERE MONTH(o.OrderDate) = MONTH('{month_str}-01') AND YEAR(o.OrderDate) = YEAR('{month_str}-01')
    """"""
    
    monthly_data = execute_sql_query(monthly_query)
    monthly_avg = monthly_data.groupby(['SupplierID', 'CompanyName'], as_index=False).mean().rename(columns={'lead_time': 'avg_lead_time'})
    monthly_avg['Month'] = month_str
    lead_time_trend_data.append(monthly_avg)

# Concatenate all months' data
lead_time_trend_df = pd.concat(lead_time_trend_data)

# Filter suppliers with a downward trend in average lead time
downward_trend_suppliers = lead_time_trend_df.groupby('SupplierID').apply(lambda x: all(x['avg_lead_time'].diff().dropna() < 0)).reset_index()
downward_suppliers_ids = downward_trend_suppliers[0].tolist()

filtered_suppliers_df = lead_time_trend_df[lead_time_trend_df['SupplierID'].isin(downward_suppliers_ids)]

# Visualization using Plotly
fig = px.line(filtered_suppliers_df, x='Month', y='avg_lead_time', color='CompanyName',
              title='Trend of Lead Times for Suppliers with Reducing Lead Times over Last Six Months')
show_to_user(fig)
","The input code calculates the lead time trends for suppliers over each month within the last six months, but it does not correctly identify suppliers with consistently decreasing lead times. The filtering logic attempts to find suppliers with a decreasing trend using the diff() function incorrectly. It checks if all differences are negative, which does not directly translate to a consistently decreasing trend. Also, there's an issue with the date determination logic in MONTH() which doesn't match SQL standards, and there’s a misunderstanding in the criteria for month selection versus the reference code.",None
"Who are the top 5 employees generating the most sales this year, and can we visualize this data in a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve top 5 employees generating the most sales in 2023
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY sales DESC
LIMIT 5
""""""

# Execute the query
sales_data = execute_sql_query(sql_query)  # This function will return a pandas DataFrame

# Visualize the results in a bar chart
if not sales_data.empty:
    fig = px.bar(sales_data, 
                 x='FirstName', 
                 y='sales', 
                 text='sales',
                 hover_name='LastName',
                 labels={'sales': 'Total Sales'},
                 title='Top 5 Employees Generating Most Sales in 2023')
    fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
    fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
    
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({""message"": [""No sales data available for 2023""]}))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, 
       CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 5
""""""

top_sales_employees = execute_sql_query(sql_query)

fig = px.bar(top_sales_employees, 
             x='EmployeeName', 
             y='total_sales', 
             title='Top 5 Employees Generating the Most Sales in 2023',
             labels={'total_sales':'Total Sales', 'EmployeeName':'Employee'})
show_to_user(fig)
```","The input code effectively executes the same logic as the reference code to determine the top 5 employees generating the most sales in 2023. It aggregates sales data based on employee information, orders by total sales, and limits the result to the top 5, similar to the reference code. The input code uses 'BETWEEN' for date filtering instead of 'YEAR', which is functionally similar. Additionally, it concatenates first and last names for the employee display in the visualization but otherwise constructs a comparable bar chart for visualization.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the top 5 employees by sales
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = Orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC 
LIMIT 5
""""""

# Assuming execute_sql_query function is provided and defined
df_sales = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(df_sales, x='EmployeeID', y='total_sales', title='Top 5 Employees by Sales This Year', labels={'total_sales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Display the visualization
show_to_user(fig)
```","The input code does not include the first and last names of the employees, which are present in the reference implementation. Additionally, the year is extracted using CURDATE() in the input, which should be `2023` as specified in the business analytics request. Lastly, the input code should handle the case when no data is returned by the query, as demonstrated in the reference implementation.",Base
"Which orders have a fulfillment time greater than 30 days, and can you visualize the distribution of fulfillment times?","```python
import plotly.express as px
import pandas as pd

# SQL query to retrieve order IDs with fulfillment times greater than 30 days
sql_query = """"""
SELECT o.OrderID, DATEDIFF(o.ShippedDate, o.OrderDate) AS FulfillmentTime
FROM orders o
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Filter for orders with a fulfillment time greater than 30 days
fulfilled_orders = data[data['FulfillmentTime'] > 30]

# Visualize the distribution of fulfillment times using a histogram
fig = px.histogram(
    data, 
    x='FulfillmentTime', 
    title='Distribution of Fulfillment Times',
    labels={'FulfillmentTime': 'Days'},
    nbins=30
)

# Show the visualization to the user
show_to_user(fig)

# Show the filtered data for orders with a fulfillment time greater than 30 days
show_to_user(fulfilled_orders[['OrderID', 'FulfillmentTime']])
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE DATEDIFF(ShippedDate, OrderDate) > 30
""""""

orders_over_30_days = execute_sql_query(sql_query)
show_to_user(orders_over_30_days)

fig = px.histogram(orders_over_30_days, x='FulfillmentTime', title='Distribution of Fulfillment Times (Over 30 Days)', nbins=30)
show_to_user(fig)
```","The input code filters orders in the SQL query itself to only include those with fulfillment times greater than 30 days. This prevents the visualization from showing the full distribution of all fulfillment times, which is part of the business analytics request. The reference code selects all data first and then filters, allowing the histogram to represent the entire distribution.","```python
import pandas as pd
import plotly.express as px

def get_long_fulfillment_orders_and_visualize():
    # SQL query to get orders with fulfillment time greater than 30 days
    sql_query = """"""
        SELECT OrderID, DATEDIFF(DELIVERYDATE, ORDERDATE) AS FulfillmentTime 
        FROM orders 
        WHERE DATEDIFF(DELIVERYDATE, ORDERDATE) > 30;
    """"""

    # Execute the SQL query and get the result as a pandas DataFrame
    long_fulfillment_orders = execute_sql_query(sql_query)

    # Visualize the distribution of fulfillment times
    fig = px.histogram(
        long_fulfillment_orders,
        x='FulfillmentTime',
        nbins=20,
        title='Distribution of Fulfillment Times (>30 Days)',
        labels={'FulfillmentTime': 'Fulfillment Time (Days)'}
    )

    # Show the histogram to the user
    show_to_user(fig)

# Call the function to execute
get_long_fulfillment_orders_and_visualize()
```","The input code directly queries for orders with a fulfillment time greater than 30 days in the SQL query, unlike the reference implementation which fetches all orders and then filters them. This results in the input code visualizing only fulfillment times greater than 30 days, whereas the reference visualizes all fulfillment times. Additionally, the column names 'DELIVERYDATE' and 'ORDERDATE' in the user code differ from 'ShippedDate' and 'OrderDate' in the reference, which may affect correctness depending on the database schema.",None
Which employee managed the most orders last month? Include a bar chart to visualize the number of orders managed by each employee.,"import pandas as pd
import plotly.express as px

# SQL query to get the order count for each employee for the last month
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE DATE_FORMAT(OrderDate, '%Y-%m') = DATE_FORMAT(CURDATE() - INTERVAL 1 MONTH, '%Y-%m') 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC;
""""""

# Function to execute the SQL query and return a DataFrame
order_counts_df = execute_sql_query(sql_query)

# Bar chart to visualize the number of orders managed by each employee
fig = px.bar(order_counts_df, x='EmployeeID', y='OrderCount',
             title='Orders Managed by Each Employee Last Month',
             labels={'OrderCount': 'Number of Orders', 'EmployeeID': 'Employee ID'})

# Display the visualization
show_to_user(fig)

# Identify the employee who managed the most orders last month
top_employee = order_counts_df.iloc[0]
top_employee_info = pd.DataFrame([top_employee])

# Display the information of the employee who managed the most orders
show_to_user(top_employee_info)","```python
import pandas as pd
import plotly.express as px

last_month = pd.Timestamp.now() - pd.DateOffset(months=1)
start_date = last_month.replace(day=1)
end_date = last_month + pd.DateOffset(day=1) - pd.DateOffset(days=1)

sql_query = f""""""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= '{start_date.date()}' AND OrderDate <= '{end_date.date()}'
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""

employee_orders = execute_sql_query(sql_query)

most_orders_employee = employee_orders.iloc[0]

fig = px.bar(employee_orders, x='EmployeeID', y='OrderCount', 
             title='Number of Orders Managed by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'})
show_to_user(fig)

most_orders_employee
```","The input code accurately reflects the logic and purpose of the reference implementation. It identifies the employee who managed the most orders last month by calculating the correct start and end dates for the previous month. It also generates a bar chart visualizing the number of orders managed by each employee, matching the essential requirements of the business analytics request. Though date handling differs slightly from the reference implementation, it adheres to the intended logic.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders managed by each employee last month
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS num_orders 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) 
AND MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
GROUP BY employees.EmployeeID 
ORDER BY num_orders DESC
""""""

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database execution
    # Replace with actual database code
    mock_data = {
        'EmployeeID': [1, 2, 3],
        'num_orders': [25, 30, 20]
    }
    return pd.DataFrame(mock_data)

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Find the employee with the most orders
top_employee = df_orders.iloc[0] if not df_orders.empty else None

# Display the results to the user
if top_employee is not None:
    show_to_user({'employee': top_employee['EmployeeID'], 'num_orders': top_employee['num_orders']})

# Create a bar chart to visualize the number of orders managed by each employee
fig = px.bar(df_orders, x='EmployeeID', y='num_orders', title='Number of Orders Managed by Each Employee', labels={'num_orders': 'Number of Orders', 'EmployeeID': 'Employee ID'})

# Show the bar chart
show_to_user(fig)
```","The input code correctly identifies the employee who managed the most orders last month and visualizes the data using a bar chart. The SQL query accurately matches employees to their orders for the last month using similar date logic as the reference implementation. The code effectively displays both the employee with the highest order count and the visualization, matching the logic and analysis intent of the reference code.",both
Which products are most frequently ordered with a discount? Please include a bar chart to visualize the frequency of discounted orders by product.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT ProductID, COUNT(OrderID) AS TimesOrdered 
FROM [Order Details] 
WHERE Discount > 0 
GROUP BY ProductID 
ORDER BY TimesOrdered DESC;
""""""

# Get the result as a pandas DataFrame
discounted_orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the frequency of discounted orders by product
fig = px.bar(discounted_orders_df, x='ProductID', y='TimesOrdered', 
             title='Frequency of Discounted Orders by Product',
             labels={'TimesOrdered': 'Number of Discounted Orders', 'ProductID': 'Product ID'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, COUNT(od.OrderID) AS DiscountedOrderCount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount > 0
GROUP BY od.ProductID
ORDER BY DiscountedOrderCount DESC
""""""

discounted_orders_df = execute_sql_query(sql_query)

fig = px.bar(discounted_orders_df, x='ProductID', y='DiscountedOrderCount', 
             title='Frequency of Discounted Orders by Product',
             labels={'DiscountedOrderCount': 'Number of Discounted Orders', 'ProductID': 'Product ID'})

show_to_user(fig)
```","The input code correctly executes the task as per the business analytics request. Both the input and reference implementations aim to determine which products are most frequently ordered with a discount and visualize the results using a bar chart. The SQL query in the input code selects the ProductID and counts the OrderID where Discount is greater than 0, which aligns with the reference implementation logic. While the input code introduces an additional JOIN with the orders table, this does not affect the count and is likely used to confirm data integrity. The visualization and labeling in the bar chart are consistent across both codes.","```python
import pandas as pd
import plotly.express as px

# SQL query from business request
sql_query = """"""
SELECT [Order Details].ProductID, COUNT(*) AS DiscountedOrderCount
FROM [Order Details]
WHERE Discount > 0
GROUP BY [Order Details].ProductID
ORDER BY DiscountedOrderCount DESC;
""""""

# Function to execute the SQL query and get results as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database call; replace with actual implementation
    # return pd.read_sql_query(sql_query, connection)
    pass

# Execute the SQL query
discounted_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the frequency of discounted orders by product
fig = px.bar(
    discounted_orders_df,
    x='ProductID',
    y='DiscountedOrderCount',
    title='Frequency of Discounted Orders by Product',
    labels={'DiscountedOrderCount': 'Frequency', 'ProductID': 'Product ID'}
)

# Display the bar chart using a utility function
show_to_user(fig)
```","The input code produces the same analytical outcome as the reference implementation. Both codes execute a SQL query to select the ProductID and count how often each product is ordered with a discount. They then visualize this data with a bar chart. While there are minor differences in column naming ('DiscountedOrderCount' vs 'TimesOrdered') and the placeholder for the SQL execution in the input, these do not affect the overall logic and output. Therefore, the input code is correct.",both
"What is the most shipped product in terms of quantity, and provide a bar chart to visualize the quantities of the top shipped products?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # Assume this returns a pandas DataFrame with the result of the query
    pass

# Function to display the result to user
def show_to_user(data):
    # Placeholder for displaying the data
    pass

# SQL query to get the quantities of shipped products
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for the top shipped products
fig = px.bar(df.head(10), x='ProductName', y='TotalQuantity', 
             title='Top Shipped Products by Quantity',
             labels={'TotalQuantity':'Quantity', 'ProductName':'Product Name'})

# Use the utility function to show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 10;
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalQuantity', title='Top Shipped Products by Quantity')
show_to_user(fig)
```","The input Python code effectively implements the required logic: it fetches the product names and their total shipped quantities, orders them in descending order, and limits the output to the top 10 products. The SQL query structure correctly performs the required joins and aggregations as in the reference code. Additionally, it creates and displays a bar chart using Plotly with the relevant information. Therefore, the input code adheres to the reference logic and satisfies the business request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the top shipped products
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalQuantity DESC
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities of the top shipped products
fig = px.bar(df.head(10), x='ProductID', y='TotalQuantity', 
             title='Top Shipped Products by Quantity', 
             labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})

# Display the bar chart
show_to_user(fig)
```","The input code calculates total quantities by ProductID, whereas the reference code calculates total quantities by ProductName by joining the 'products' table. The reference query provides a more complete answer by naming the products, not just using IDs. Additionally, without the product names, the visualization using ProductID isn't as informative.",Base
"Which product had the most orders, how many were ordered, and can this be visualized with a bar chart?","```python
import plotly.express as px
import pandas as pd

# SQL Query to get the product with the most orders
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalQuantity DESC 
LIMIT 1;
""""""

# Execute the SQL query and retrieve the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not result_df.empty:
    # Visualize the product with the most orders using a bar chart
    fig = px.bar(result_df, x='ProductID', y='TotalQuantity', 
                 title='Product with the Most Orders')
    # Display the visualization to the user
    show_to_user(fig)
else:
    # If no data is returned, show a message to the user
    empty_df_message = pd.DataFrame({'Message': ['No data available']})
    show_to_user(empty_df_message)
```","```python
sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalOrdered
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalOrdered DESC
LIMIT 1
""""""

most_ordered_product = execute_sql_query(sql_query)

import plotly.express as px

fig = px.bar(most_ordered_product, x='ProductID', y='TotalOrdered', title='Most Ordered Product')
show_to_user(fig)
```","The input code correctly implements the logic specified in the business analytics request. It constructs an SQL query to fetch the ProductID with the highest total quantity ordered. The query logic, including selection, aggregation, and ordering, matches the reference implementation. Furthermore, the input code uses Plotly Express to create a bar chart that visualizes the product with the most orders, adhering to the visualization requirement. The final operations are equivalent to the reference code, fulfilling the task's requirements, even though there are slight differences in the SQL syntax and import structure.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are defined elsewhere

# SQL query to retrieve product with the most orders
sql_query = """"""
SELECT od.ProductID, COUNT(*) AS OrderQuantity 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY OrderQuantity DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Extract the product ID with the most orders and the total order quantity
top_product_id = result_df['ProductID'].iloc[0]
top_order_quantity = result_df['OrderQuantity'].iloc[0]

# Display the result
result_message = f""Product with the most orders: {top_product_id} with a total of {top_order_quantity} orders.""
show_to_user(pd.DataFrame([result_message], columns=[""Result""]))

# Visualize the data with a bar chart
fig = px.bar(result_df, x='ProductID', y='OrderQuantity', title='Top Product by Order Quantity')

# Show the visualization
show_to_user(fig)
```","The input code uses COUNT(*) to find the number of orders instead of SUM(Quantity), which counts order transactions instead of quantities. The reference implementation calculates the total quantity of each product ordered, leading to potentially different results. Therefore, the logic does not match the reference.",Base
Which products have been discontinued? Please include a bar chart to illustrate the number of discontinued products per category.,"```python
import plotly.express as px

# SQL Query to get discontinued products and their categories
sql_query = """"""
    SELECT ProductName, CategoryName
    FROM products
    JOIN categories ON products.CategoryID = categories.CategoryID
    WHERE Discontinued = 1;
""""""

# Execute the query and get results as a DataFrame
discontinued_products_df = execute_sql_query(sql_query)

# Count the number of discontinued products per category
discontinued_count = discontinued_products_df.groupby('CategoryName').size().reset_index(name='counts')

# Create a bar chart to visualize the number of discontinued products per category
fig = px.bar(discontinued_count, x='CategoryName', y='counts', title='Number of Discontinued Products per Category')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, COUNT(*) AS DiscontinuedCount
FROM products p
WHERE p.Discontinued = 1
GROUP BY p.CategoryID
""""""

discontinued_products = execute_sql_query(sql_query)

fig = px.bar(discontinued_products, x='CategoryID', y='DiscontinuedCount', 
             title='Number of Discontinued Products per Category', 
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Number of Discontinued Products'})

show_to_user(fig)
```","The input code does not correctly follow the logic of the reference implementation. The input code groups by CategoryID without joining with the categories table to get the CategoryName. It omits the JOIN operation with the categories table, leading to a missing mapping of CategoryID to CategoryName. Additionally, the bar chart labels should reflect CategoryName rather than CategoryID for clarity and consistency with the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Assume the existence of the utility functions as described in the constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database connection and query execution
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch discontinued products along with their categories
sql_query = """"""
SELECT ProductName, Category
FROM products
WHERE Discontinued = 1;
""""""

# Execute the SQL query and fetch the data into a DataFrame
discontinued_products = execute_sql_query(sql_query)

# Count the number of discontinued products per category
discontinued_count = discontinued_products['Category'].value_counts().reset_index()
discontinued_count.columns = ['Category', 'DiscontinuedCount']

# Create a bar chart using Plotly
fig = px.bar(
    discontinued_count,
    x='Category',
    y='DiscontinuedCount',
    title='Number of Discontinued Products per Category',
    labels={'DiscontinuedCount': 'Number of Discontinued Products'}
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code does not correctly match the business request. It attempts to fetch the discontinued products from a table but joins with categories incorrectly. The SQL query should join 'categories' as in the reference implementation. This affects both fetching and counting discontinued products by category. Additionally, the column names differ ('CategoryName' vs. 'Category'), affecting grouping and plotting steps.",None
Which employee has handled the highest number of orders? Provide a bar chart to visualize the number of orders handled by each employee.,"
import plotly.express as px

# SQL query to get total orders by each employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY TotalOrders DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='TotalOrders', title='Number of Orders Handled by Each Employee')

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='EmployeeID', y='OrderCount', title='Number of Orders Handled by Each Employee')
show_to_user(fig)
```","The provided input code fulfills the business analytics request by using a SQL query to count orders grouped by each EmployeeID, ensuring it correctly identifies which employee has handled the highest number of orders. It constructs a bar chart using Plotly to visualize the data, consistent with the logic of the reference implementation. The minor difference in column alias naming ('OrderCount' vs. 'TotalOrders') does not affect the functionality, making the input code correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the number of orders handled by each employee
sql_query = """"""
SELECT o.EmployeeID, COUNT(o.OrderID) AS NumberOfOrders 
FROM orders o 
GROUP BY o.EmployeeID 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
df_orders = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders handled by each employee
fig = px.bar(df_orders, x='EmployeeID', y='NumberOfOrders', 
             title='Number of Orders Handled by Each Employee', 
             labels={'EmployeeID': 'Employee ID', 'NumberOfOrders': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly implements the business analytics request by counting the number of orders handled by each employee. The SQL query, DataFrame creation, and bar chart visualization are consistent with the reference implementation. Both codes group by EmployeeID, count the orders, and sort the results in descending order. The chart accurately visualizes the number of orders for each employee, matching the intent of the reference code.",both
What is the total freight cost per shipping method this month? Include a bar chart to visualize the comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the total freight cost per shipping method for the current month
sql_query = """"""
SELECT o.ShipVia, SUM(o.Freight) AS TotalFreightCost 
FROM orders o 
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE) 
GROUP BY o.ShipVia;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total freight cost per shipping method
fig = px.bar(df, x='ShipVia', y='TotalFreightCost', title='Total Freight Cost per Shipping Method This Month')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total freight cost per shipping method this month
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
WHERE MONTH(OrderDate) = MONTH(CURRENT_DATE()) 
  AND YEAR(OrderDate) = YEAR(CURRENT_DATE())
GROUP BY ShipVia
""""""

# Execute the SQL query
freight_data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(freight_data, x='ShipVia', y='TotalFreight', 
             title='Total Freight Cost per Shipping Method This Month',
             labels={'ShipVia': 'Shipping Method', 'TotalFreight': 'Total Freight Cost'})

# Show the result to the user
show_to_user(fig)
```","The input code correctly calculates the total freight cost per shipping method for the current month using the same logic as the reference code. Both SQL queries filter orders by the current month and year, although the input uses separate MONTH() and YEAR() functions while the reference uses DATE_TRUNC. The aggregation and grouping are consistent, and both implementations visualize the data with a bar chart using Plotly. The labels differ slightly in the plot, but this does not affect the correctness of the analysis.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT o.ShipVia, SUM(o.Freight) AS TotalFreight
FROM orders o 
WHERE EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE)
AND EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE)
GROUP BY o.ShipVia
""""""

# Fetch the data using the provided utility function
data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data_df, x='ShipVia', y='TotalFreight', title='Total Freight Cost per Shipping Method for the Current Month', labels={'TotalFreight': 'Total Freight Cost', 'ShipVia': 'Shipping Method'})

# Display the figure
show_to_user(fig)
```","The evaluated code correctly calculates the total freight cost per shipping method for the current month. It uses the EXTRACT method to compare the month and year of the OrderDate with the current date, which is equivalent to the DATE_TRUNC approach in the reference. The use of Plotly to create a bar chart is also consistent with the task requirements.",both
"What is the total revenue for each product category, and can you provide a bar chart to visualize the results?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented to execute the SQL query and return a DataFrame
    pass

def show_to_user(data):
    # This function is assumed to be implemented to display data analysis or visualization results
    pass

# SQL query to fetch total revenue for each product category
sql_query = """"""
SELECT p.CategoryID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.CategoryID;
""""""

# Execute the SQL query and store the result in a DataFrame
df_revenue = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_revenue, x='CategoryID', y='TotalRevenue', 
             title='Total Revenue by Product Category', 
             labels={'CategoryID': 'Product Category ID', 'TotalRevenue': 'Total Revenue'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
""""""

revenue_df = execute_sql_query(sql_query)

fig = px.bar(revenue_df, x='ProductID', y='TotalRevenue', title='Total Revenue by Product Category')
show_to_user(fig)
```","The input code is incorrect. The SQL query in the input code retrieves total revenue per ProductID, not per CategoryID. Additionally, it joins with the 'orders' table instead of the 'products' table and does not include the CategoryID, missing the necessary grouping by product category. Therefore, it does not align with the business request or the logic of the reference implementation.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS Revenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total revenue for each product category
fig = px.bar(df, x='CategoryID', y='Revenue', title='Total Revenue by Product Category')

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the business logic by executing an SQL query to calculate total revenue for each product category, similar to the reference implementation. It then visualizes the results using a bar chart, adhering to the request and logic despite minor differences like variable names.",Finetuned
Determine the total quantity of products on order for each supplier and provide a bar chart to illustrate the results.,"import pandas as pd
import plotly.express as px

# Function to execute a SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation to execute the SQL query and return the result as a pandas DataFrame
    pass

# Function to display data analysis or visualization results
def show_to_user(data):
    # Implementation to display the data
    pass

# SQL Query to determine the total quantity of products on order for each supplier
sql_query = """"""
SELECT s.SupplierName, SUM(p.UnitsOnOrder) AS TotalUnitsOnOrder
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
WHERE p.UnitsOnOrder > 0 
GROUP BY s.SupplierName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the results
fig = px.bar(df, x='SupplierName', y='TotalUnitsOnOrder', 
             title='Total Quantity of Products on Order for Each Supplier',
             labels={'TotalUnitsOnOrder': 'Total Units On Order'})

# Display the bar chart to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantityOnOrder
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='SupplierID', y='TotalQuantityOnOrder', 
             title='Total Quantity of Products on Order by Supplier',
             labels={'TotalQuantityOnOrder': 'Total Quantity on Order', 'SupplierID': 'Supplier ID'})

show_to_user(fig)
```","The input code does not adhere to the same logic as the reference implementation. The reference code calculates the total quantity of products on order for each supplier by summing up 'UnitsOnOrder' from the 'products' table and uses the 'SupplierName'. The input code calculates the total quantity using the 'Order Details' table and groups by 'SupplierID', potentially missing the link to supplier names and filtering conditions like 'UnitsOnOrder > 0'.","```python
import plotly.express as px
import pandas as pd

# Execute the SQL query to retrieve the data
sql_query = """"""
SELECT suppliers.CompanyName, SUM(products.UnitsOnOrder) AS Total_Orders
FROM products 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.CompanyName;
""""""
# Placeholder function: Execute the SQL query and get the result as a DataFrame
def execute_sql_query(sql: str) -> pd.DataFrame:
    # Actual implementation should connect to the database and execute the SQL query
    # This implementation returns a sample DataFrame for demonstration purposes
    sample_data = {
        'CompanyName': ['Supplier A', 'Supplier B', 'Supplier C'],
        'Total_Orders': [150, 200, 80]
    }
    return pd.DataFrame(sample_data)

# Retrieve the data from the SQL database into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total orders for each supplier
fig = px.bar(df, x='CompanyName', y='Total_Orders', 
             title='Total Quantity of Products on Order for Each Supplier',
             labels={'CompanyName': 'Supplier', 'Total_Orders': 'Total Orders'})

# Show the result to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

show_to_user(fig)
```","The input code does not apply the condition 'WHERE p.UnitsOnOrder > 0' from the reference code, resulting in the inclusion of suppliers with zero units on order. This deviation causes the logic to differ from the reference implementation.",None
"Which orders had the highest total discount applied, and how can we visualize these discounts effectively?","
```python
import pandas as pd
import plotly.express as px

# SQL query as specified in the request
sql_query = """"""
SELECT OrderID, 
       SUM(Discount * UnitPrice * Quantity) AS TotalDiscount 
FROM [Order Details] 
GROUP BY OrderID 
ORDER BY TotalDiscount DESC;
""""""

# Execute the SQL query
order_discounts_df = execute_sql_query(sql_query)

# Obtain the order with the highest discount
highest_discount_order = order_discounts_df.head(1)

# Use Plotly to visualize the top discount orders
fig = px.bar(order_discounts_df, x='OrderID', y='TotalDiscount',
             title='Total Discounts by Order',
             labels={'TotalDiscount': 'Total Discount', 'OrderID': 'Order ID'})

# Display the top order and the plot
show_to_user(highest_discount_order)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, SUM(Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY OrderID
ORDER BY TotalDiscount DESC
LIMIT 10;
""""""

discounts_df = execute_sql_query(sql_query)

fig = px.bar(discounts_df, x='OrderID', y='TotalDiscount', 
             title='Top 10 Orders with Highest Total Discounts',
             labels={'TotalDiscount': 'Total Discount', 'OrderID': 'Order ID'})

show_to_user(fig)
```","The input code incorrectly calculates 'TotalDiscount' as just the sum of 'Discount', rather than using the sum of 'Discount * UnitPrice * Quantity', which is the correct computation for total discount applied to each order, as shown in the reference implementation. Additionally, the reference code identifies the order with the highest discount, while the input code only shows the top 10 orders without specifying the highest one.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT 
    o.OrderID, 
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM 
    orders o 
JOIN 
    `[Order Details]` od 
ON 
    o.OrderID = od.OrderID 
GROUP BY 
    o.OrderID 
ORDER BY 
    TotalDiscount DESC;
""""""

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution
    # For demonstration, assume it returns a DataFrame
    return pd.DataFrame()  # Replace with actual data fetching logic

# Function to display data
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)  # Placeholder for actual display logic
    elif isinstance(data, px.Figure):
        data.show()  # Ensure Plotly figures display correctly

# Fetch data using the SQL query
orders_df = execute_sql_query(sql_query)

# Visualize the top orders by total discount using Plotly
fig = px.bar(orders_df, x='OrderID', y='TotalDiscount', title='Top Orders by Total Discount')
show_to_user(fig)
```","The evaluated code does not extract and display the order with the highest discount separately before visualizing the data, as done in the reference implementation. Additionally, the evaluated code uses a placeholder for the SQL execution and data display functions, which needs to be replaced by actual working logic. The reference code explicitly shows the top discount order with 'show_to_user(highest_discount_order)', which is missing in the input code. Additionally, there is a slight inconsistency in the table naming conventions in the SQL query. The code should ensure it fetches and displays the highest discount order distinctly.",None
"Which products need to be reordered based on current levels, and can we visualize this with a stock level chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to get products that need reordering
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query and store the result in a DataFrame
products_to_reorder_df = execute_sql_query(sql_query)

# If the DataFrame is not empty, create a visualization
if not products_to_reorder_df.empty:
    # Create a bar chart to visualize which products need reordering
    fig = px.bar(
        products_to_reorder_df, 
        x='ProductName', 
        y='UnitsInStock', 
        title='Products to Reorder Based on Current Stock Levels',
        labels={'UnitsInStock': 'Units in Stock'},
    )
    show_to_user(fig)
else:
    # If no products need reordering, display a message
    show_to_user(pd.DataFrame({'Message': ['No products need reordering']}))
```","```python
import pandas as pd
import plotly.express as px

# Fetch products that need to be reordered
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE Discontinued = 0 AND UnitsInStock <= ReorderLevel
""""""
reorder_df = execute_sql_query(sql_query)

# Visualize stock levels
fig = px.bar(reorder_df, x='ProductName', y='UnitsInStock', 
             title='Products Needing Reorder',
             labels={'UnitsInStock': 'Current Stock Level'},
             text='UnitsInStock')
fig.update_traces(texttemplate='%{text}', textposition='auto')
show_to_user(fig)
```","The input code includes products that are still available for sale (Discontinued = 0), which is not considered in the reference implementation. Additionally, it doesn't handle the scenario where no products need reordering as the reference implementation does by displaying a message instead of attempting to create a plot.","import pandas as pd
import plotly.express as px

# Assuming the existence of utility functions as described in the environment constraints
def execute_sql_query(sql_query: str):
    # Functionality to execute SQL query and return DataFrame
    pass

def show_to_user(data):
    # Functionality to display data to the user
    pass

# SQL query to identify products needing reorder
sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel
""""""

# Execute the SQL query and retrieve data
products_to_reorder = execute_sql_query(sql_query)

# Generate a stock level chart using Plotly
fig = px.bar(
    products_to_reorder,
    x='ProductName',
    y=['UnitsInStock', 'ReorderLevel'],
    title='Stock Levels of Products Needing Reorder',
    labels={'value': 'Units', 'variable': 'Legend'},
    barmode='group'
)

# Display the chart using the utility function
show_to_user(fig)","The input code deviates from the reference implementation in two key ways: 1) It uses 'UnitsInStock < ReorderLevel' instead of 'UnitsInStock <= ReorderLevel', which changes the condition for reordering. 2) The visualization includes both 'UnitsInStock' and 'ReorderLevel', whereas the reference only visualizes 'UnitsInStock'. These differences mean it does not adhere to the same logic as the reference.",None
Which employee handles the most valuable products by unit price? Please include a data visualization showing the comparison of unit prices for each employee.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch employee and unit price
sql_query = """"""
SELECT e.FirstName, e.LastName, od.UnitPrice 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID;
""""""

# Execute the SQL query and obtain a DataFrame
df = execute_sql_query(sql_query)

# Aggregate to find the maximum unit price handled by each employee
employee_unit_price = df.groupby(['FirstName', 'LastName'], as_index=False).max()

# Sort by UnitPrice to find the employee handling the most valuable product
sorted_df = employee_unit_price.sort_values(by='UnitPrice', ascending=False)

# Create a bar plot to visualize unit prices for each employee
fig = px.bar(
    sorted_df,
    x='FirstName',
    y='UnitPrice',
    color='LastName',
    title='Unit Price of Most Valuable Products by Employee',
    labels={'FirstName': 'Employee First Name', 'UnitPrice': 'Unit Price ($)'}
)

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       od.UnitPrice, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, EmployeeName, od.UnitPrice
ORDER BY od.UnitPrice DESC
""""""

employee_unit_price_df = execute_sql_query(sql_query)

most_valuable_employee = employee_unit_price_df.loc[employee_unit_price_df['UnitPrice'].idxmax()]

fig = px.bar(employee_unit_price_df, 
             x='EmployeeName', 
             y='UnitPrice', 
             title='Comparison of Unit Prices by Employee',
             labels={'UnitPrice': 'Unit Price', 'EmployeeName': 'Employee'},
             text='UnitPrice')

show_to_user(fig)

most_valuable_employee
```","The reference code aims to determine which employee handles the most valuable product by finding the maximum unit price for each employee and comparing them. It uses grouping by employee names. The input code groups by employee ID and name, then uses a different aggregation approach involving quantity, which is unnecessary for answering the request. The requested operation is to identify the maximum unit price per employee, not using total quantity, which the input code wrongly calculates. Moreover, it selects the employee with the overall maximum unit price rather than determining the highest unit price per employee for comparison.","
```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT employees.EmployeeID, AVG(products.UnitPrice) AS AverageUnitPrice
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
GROUP BY employees.EmployeeID
ORDER BY AverageUnitPrice DESC
""""""

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Execute the query and return the results as a DataFrame
    # This is a placeholder function. Replace with actual implementation.
    pass

# Function to show the result to the user
def show_to_user(data):
    # Display data or visualization
    # This is a placeholder function. Replace with actual implementation.
    pass

# Fetch data using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize comparison of average unit prices per employee
fig = px.bar(
    df,
    x='EmployeeID',
    y='AverageUnitPrice',
    title='Average Unit Price by Employee',
    labels={'AverageUnitPrice': 'Average Unit Price', 'EmployeeID': 'Employee ID'},
    text='AverageUnitPrice'
)

# Show the figure to the user
show_to_user(fig)
```
","The input code calculates the average unit price handled by each employee instead of finding the maximum unit price associated with each employee as the reference code does. The business request specifies to determine which employee handles the most valuable products by unit price, best achieved using the maximum rather than the average. The data visualization in the input code compares average unit prices rather than the highest unit price per employee.",None
"Which product generated the most revenue this quarter, and can we visualize the revenue for all products to compare their performance?","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch revenue for all products this quarter
sql_query = """"""
SELECT ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS ProductRevenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE QUARTER(o.OrderDate) = QUARTER(CURRENT_DATE) AND YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY ProductID
ORDER BY ProductRevenue DESC;
""""""

# Execute the SQL query and get the result in a DataFrame
product_revenue_df = execute_sql_query(sql_query)

# Determine the product with the highest revenue
highest_revenue_product = product_revenue_df.iloc[0]

# Print the product with the highest revenue
show_to_user(pd.DataFrame([highest_revenue_product]))

# Create a bar chart to visualize the revenue for all products
fig = px.bar(product_revenue_df, x='ProductID', y='ProductRevenue', title='Product Revenue This Quarter')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the current quarter date range
start_date = '2023-07-01'
end_date = '2023-09-30'

# SQL query to calculate revenue for each product this quarter
sql_query = f""""""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY 
    od.ProductID
ORDER BY 
    Revenue DESC
""""""

# Execute the query
revenue_data = execute_sql_query(sql_query)

# Identify the product that generated the most revenue
top_product = revenue_data.iloc[0]

# Output the top product
print(""Product with the most revenue this quarter:"", top_product)

# Visualize the revenue for all products
fig = px.bar(revenue_data, x='ProductID', y='Revenue', title='Revenue by Product This Quarter')
show_to_user(fig)
```","Both implementations correctly calculate the revenue for each product by joining 'Order Details' and 'orders', grouping by ProductID, and ordering by revenue. The input code uses a fixed date range for the current quarter instead of dynamic date functions, which is a valid approach if the dates are accurate. Both codes then identify the top product by revenue and visualize the data using a bar chart, achieving the same outcome.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    pass

# Utility function to display data to the user
def show_to_user(data):
    # Placeholder for actual display logic
    pass

# SQL query to fetch revenue for all products this quarter
sql_query_all_products = """"""
SELECT p.ProductName, SUM(od.Quantity * (od.UnitPrice - od.UnitPrice * od.Discount)) AS ProductRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE DATEPART(QUARTER, od.OrderDate) = DATEPART(QUARTER, GETDATE())
AND DATEPART(YEAR, od.OrderDate) = DATEPART(YEAR, GETDATE())
GROUP BY p.ProductName;
""""""

# Execute the SQL query
product_revenue_df = execute_sql_query(sql_query_all_products)

# Find the product with the most revenue
most_revenue_product_df = product_revenue_df.sort_values(by='ProductRevenue', ascending=False).head(1)

# Display the product generating the most revenue
show_to_user(most_revenue_product_df)

# Visualize all products' revenue
fig = px.bar(product_revenue_df, x='ProductName', y='ProductRevenue', title='Revenue by Product This Quarter')
show_to_user(fig)
```","The provided code correctly implements the business analytics request. Both the input and reference implementations retrieve the same data: total revenue per product for the current quarter. They use similar logic to filter by quarter and year, calculate revenue using unit price, quantity, and discount, and then display the product with the highest revenue. The bar chart visualization to compare product performance is also correctly implemented in both versions. The differences in SQL syntax, sorting, and column names don't affect the overall functional correctness.",both
Which shipping company handled the most orders in USD value in Q2 2023? Include a bar chart to show the USD value handled by each company.,"```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT 
    shippers.CompanyName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_shipping_value 
FROM 
    orders 
JOIN 
    shippers ON orders.ShipVia = shippers.ShipperID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY 
    shippers.CompanyName 
ORDER BY 
    total_shipping_value DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate the bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='total_shipping_value', 
             title='USD Value Handled by Each Shipping Company in Q2 2023',
             labels={'CompanyName': 'Shipping Company', 'total_shipping_value': 'Total Shipping Value (USD)'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the start and end dates for Q2 2023
start_date = '2023-04-01'
end_date = '2023-06-30'

# SQL query to calculate total sales by shipping company in Q2 2023
sql_query = f""""""
SELECT shippers.CompanyName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY shippers.CompanyName
ORDER BY total_sales DESC
""""""

# Execute the SQL query and retrieve the data
df_sales = execute_sql_query(sql_query)

# Get the shipping company with the most orders
top_company = df_sales.iloc[0]

# Create a bar chart to show the USD value handled by each company
fig = px.bar(df_sales, x='CompanyName', y='total_sales', title='Total Sales by Shipping Company in Q2 2023')
show_to_user(fig)

top_company
```","Both the provided code and the reference implementation correctly calculate the total sales by shipping company for Q2 2023 using SQL. The logic for calculating the total value is the same in both codes: they calculate the sum of 'UnitPrice * Quantity * (1 - Discount)' for each company. The provided code retrieves the top company and creates a bar chart with Plotly, which adheres to the requirements specified in the business analytics request. Therefore, the input code is correct.","```python
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT shippers.CompanyName, 
       SUM(orders.Freight) AS company_usd_value 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipViaID 
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY shippers.CompanyName 
ORDER BY company_usd_value DESC
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart for the USD value handled by each shipping company
fig = px.bar(df, x='CompanyName', y='company_usd_value',
             title='USD Value Handled by Each Shipping Company in Q2 2023',
             labels={'company_usd_value': 'USD Value', 'CompanyName': 'Shipping Company'})

# Display the result
show_to_user(fig)
```","The input code calculates the total shipping value using the 'Freight' column from the 'orders' table, which represents a flat shipping fee, rather than the specific order details calculation ('UnitPrice * Quantity * (1 - Discount)') in the reference code. This results in different values and does not adhere to the specified logic for determining the most value handled by each company in Q2 2023.",Base
What is the average age of employees at the time of hire? Please include a histogram to display the distribution of ages at hiring.,"
```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT
    (CAST(JULIANDAY(employees.HireDate) - JULIANDAY(employees.BirthDate)) / 365.25) AS AgeAtHire
FROM employees
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Calculate the average age at hire
average_age_at_hire = df['AgeAtHire'].mean()

# Create a histogram to display distribution of ages at hiring
fig = px.histogram(df, x='AgeAtHire', title='Distribution of Ages at Hiring', nbins=20)
fig.update_layout(xaxis_title='Age at Hire', yaxis_title='Number of Employees')

# Display results
show_to_user(pd.DataFrame({'Average Age at Hire': [average_age_at_hire]}))
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    BirthDate, 
    HireDate, 
    TIMESTAMPDIFF(YEAR, BirthDate, HireDate) AS AgeAtHire
FROM 
    employees
""""""

employee_data = execute_sql_query(sql_query)

average_age = employee_data['AgeAtHire'].mean()
histogram_fig = px.histogram(employee_data, x='AgeAtHire', title='Distribution of Ages at Hiring')

show_to_user(histogram_fig)

average_age
```","The input code uses `TIMESTAMPDIFF(YEAR, BirthDate, HireDate)` to calculate `AgeAtHire`, whereas the reference code calculates the age more accurately by considering the exact difference in days and dividing by 365.25. The `TIMESTAMPDIFF` approach may result in rounding issues for employees whose birthdays are close to the hire date. Additionally, the input code does not display the average age to the user, which is part of what was asked.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the average age at hire
sql_query = """"""
SELECT EXTRACT(YEAR FROM HireDate) - EXTRACT(YEAR FROM BirthDate) AS AgeAtHire FROM Employees;
""""""

# Execute the SQL query to get the DataFrame
df_age = execute_sql_query(sql_query)

# Calculate the average age
average_age_at_hire = df_age['AgeAtHire'].mean()

# Display the average age
show_to_user(pd.DataFrame({'Average Age at Hire': [average_age_at_hire]}))

# Create histogram of ages at hire
fig = px.histogram(df_age, x='AgeAtHire', nbins=20, title='Distribution of Ages at Hiring')

# Show the histogram to the user
show_to_user(fig)
```","The input Python code uses EXTRACT(YEAR FROM HireDate) - EXTRACT(YEAR FROM BirthDate) to calculate age, which may not be precise as it only considers the year part, ignoring the months and days. The reference implementation uses a more accurate method by calculating the difference in days between the HireDate and BirthDate and then dividing by 365.25 to account for leap years. This difference affects the accuracy of the average age calculation.",None
"What is the total number of units sold by each employee, and can this be represented in a bar chart?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalUnits
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get a DataFrame
data_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(data_df, x='EmployeeID', y='TotalUnits', title='Total Units Sold by Each Employee')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.Quantity) AS TotalUnitsSold
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='FirstName', y='TotalUnitsSold', title='Total Units Sold by Each Employee', 
             labels={'FirstName': 'Employee Name', 'TotalUnitsSold': 'Total Units Sold'})

show_to_user(fig)
```","The input code includes 'FirstName' and 'LastName' in the SQL query, which changes the grouping logic from the reference code. It groups by both EmployeeID and names, instead of just EmployeeID, which could affect results (e.g., if there are employees with the same name). The bar chart uses 'FirstName' instead of 'EmployeeID' as the x-axis, which deviates from the reference's requirement of grouping only by EmployeeID. Therefore, it does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assume that the utility functions are predefined in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute SQL queries and return a DataFrame
    pass

def show_to_user(data):
    # Placeholder function to display data or visualization results
    pass

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query to get the data
data_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(data_df, x='EmployeeID', y='TotalUnitsSold', 
             title='Total Units Sold by Each Employee',
             labels={'TotalUnitsSold': 'Total Units Sold', 'EmployeeID': 'Employee ID'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly answers the business analytics request by calculating the total number of units sold by each employee. The SQL query groups sales data by EmployeeID and sums the quantities, similar to the reference code. Additionally, the code generates a bar chart with Plotly to represent the results, which aligns with the requirements and logic of the reference implementation.",Finetuned
What is the total number of units in stock for each product category? Provide a bar chart to illustrate the comparison among categories.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT CategoryID, SUM(UnitsInStock) AS TotalUnitsInStock 
FROM products 
GROUP BY CategoryID;
""""""

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to your database and execute the provided SQL query
    # It then returns the result as a pandas DataFrame
    # This is a mock implementation for demonstration purposes
    data = {
        'CategoryID': [1, 2, 3],
        'TotalUnitsInStock': [150, 200, 300]
    }
    return pd.DataFrame(data)

# Execute the query and get the result
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='TotalUnitsInStock', 
             title='Total Units in Stock for Each Product Category',
             labels={'CategoryID': 'Category ID', 'TotalUnitsInStock': 'Total Units In Stock'})

# Display the bar chart
def show_to_user(data):
    # This function should handle displaying the data or figure to the user
    # Depending on the environment, this might use IPython.display, web server response, etc.
    # Here we'll assume a simple print for demonstration purposes
    data.show()

show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CategoryName, SUM(p.UnitsInStock) AS TotalUnitsInStock
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CategoryName', y='TotalUnitsInStock', title='Total Units in Stock by Product Category')
show_to_user(fig)
```","The provided code follows the same logic as the reference implementation but with enhancements. It retrieves the total units in stock for each product category using a SQL query, joined with the categories to obtain category names instead of IDs. The use of 'CategoryName' instead of 'CategoryID' for labeling in the chart is more user-friendly. The result is correctly displayed using a bar chart showing 'Total Units in Stock by Product Category.' Thus, the code adequately meets the business request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total number of units in stock for each product category.
sql_query = """"""
SELECT CategoryID, SUM(UnitsInStock) AS TotalUnitsInStock 
FROM products 
GROUP BY CategoryID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame.
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total units in stock for each product category.
fig = px.bar(df, x='CategoryID', y='TotalUnitsInStock', 
             labels={'CategoryID': 'Product Category', 'TotalUnitsInStock': 'Total Units In Stock'},
             title='Total Units In Stock by Product Category')

# Show the bar chart to the user.
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It uses the same SQL query to obtain the total number of units in stock for each product category, groups the results by CategoryID, and creates a bar chart using Plotly. The differences in the label names and title formatting do not affect the correctness of the code in terms of fulfilling the business analytics request.",both
What is the total number of products sold to each country? Please include a bar chart to visualize the distribution across countries.,"```python
import pandas as pd
import plotly.express as px

# SQL query provided in the request
sql_query = """"""
SELECT orders.ShipCountry, SUM([Order Details].Quantity) AS TotalProductsSold
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.ShipCountry;
""""""

# Execute the SQL query and store the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total number of products sold to each country
fig = px.bar(df, x='ShipCountry', y='TotalProductsSold', 
             title='Total Number of Products Sold to Each Country',
             labels={'ShipCountry': 'Country', 'TotalProductsSold': 'Total Products Sold'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.ShipCountry, SUM(od.Quantity) AS TotalProductsSold
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.ShipCountry
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ShipCountry', y='TotalProductsSold', title='Total Products Sold to Each Country', labels={'TotalProductsSold': 'Total Products Sold', 'ShipCountry': 'Country'})
show_to_user(fig)
```",The input code correctly answers the business analytics request and follows the same logic as the reference implementation. Both implementations execute an SQL query to aggregate the total number of products sold per country by joining the 'orders' and 'Order Details' tables and use Plotly to create a bar chart with similar configuration. Variations in table alias usage do not affect functionality.,"```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration purposes
    # Normally, this function would connect to the database and execute the query
    data = {
        'Country': ['USA', 'Canada', 'France'],
        'Total Quantity Sold': [250, 150, 100]
    }
    return pd.DataFrame(data)

# SQL query from the business analytic request
sql_query = """"""
SELECT orders.ShipCountry, SUM([Order Details].Quantity) AS Total_Quantity_Sold 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY orders.ShipCountry 
ORDER BY Total_Quantity_Sold DESC;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Country', y='Total Quantity Sold', 
             title='Total Number of Products Sold to Each Country',
             labels={'Total Quantity Sold': 'Total Quantity Sold'})

# Display the bar chart
show_to_user(fig)
```","The input code retrieves the total number of products sold to each country and visualizes it correctly with a bar chart. The SQL query logic and the use of Plotly to create a bar chart are consistent with the reference code. The naming of columns in the resulting DataFrame differs slightly, but this does not impact the correctness of the logic or the output.",both
List the top 5 products by sales revenue and include a bar chart to visualize the results.,"
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS SalesRevenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName 
ORDER BY SalesRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='SalesRevenue', title='Top 5 Products by Sales Revenue')

# Show the chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS SalesRevenue
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    SalesRevenue DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, 
             x='ProductName', 
             y='SalesRevenue', 
             title='Top 5 Products by Sales Revenue', 
             labels={'SalesRevenue': 'Sales Revenue', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code includes a discount factor in the sales revenue calculation (`od.Discount`), whereas the reference code does not. The reference implementation calculates revenue strictly as the product of quantity and unit price. This difference alters the logic and results, hence the input code does not adhere to the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Given SQL Query to Fetch Data
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Revenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName 
ORDER BY Revenue DESC 
LIMIT 5;
""""""

# Utility function to execute SQL query and return the result as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This should contain the actual code to execute the SQL and return a DataFrame
    # Here is a mock implementation for the purpose of this example
    # In reality, this would connect to a database and fetch results
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C', 'Product D', 'Product E'],
        'Revenue': [2000, 1500, 1200, 800, 300]
    }
    return pd.DataFrame(data)

# Fetch the data
df_top_products = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df_top_products, x='ProductName', y='Revenue', title='Top 5 Products by Sales Revenue')

# Show the resulting bar chart
show_to_user(fig)
```","The input code calculates revenue with a discount factor (`Quantity * UnitPrice * (1 - Discount)`), which is different from the reference code (`Quantity * UnitPrice`). This changes the logic of the requested task and can lead to different top 5 products by sales revenue.",None
"What is the total freight cost by shipping method, and can you provide a bar chart to illustrate the findings?","```python
import pandas as pd
import plotly.express as px

# Assuming the utility functions are already defined somewhere in the environment:
# def execute_sql_query(sql_query: str) -> pd.DataFrame
# def show_to_user(data)

# SQL query to fetch the total freight cost by shipping method
sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total freight cost by shipping method
fig = px.bar(df, x='ShipVia', y='TotalFreight', title='Total Freight Cost by Shipping Method', labels={'ShipVia': 'Shipping Method', 'TotalFreight': 'Total Freight Cost'})

# Display the bar chart using show_to_user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipVia
""""""
freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipVia', y='TotalFreight', title='Total Freight Cost by Shipping Method', labels={'ShipVia': 'Shipping Method', 'TotalFreight': 'Total Freight Cost'})
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request by querying the total freight cost by shipping method using a SQL query similar to the reference code. It then visualizes the data with a bar chart using Plotly Express, and displays it using the 'show_to_user' function. The logic matches that of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total freight cost by shipping method
sql_query = ""
SELECT ShipVia, SUM(Freight) AS TotalFreight FROM orders GROUP BY ShipVia;
""

# Execute the SQL query to get the data
freight_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(freight_data, x='ShipVia', y='TotalFreight', title='Total Freight Cost by Shipping Method')

# Show the bar chart to the user
show_to_user(fig)
```","The input code misses converting 'ShipVia' and 'TotalFreight' columns into user-friendly labels in the bar chart. The reference code uses a 'labels' parameter in the `px.bar` function to add 'Shipping Method' and 'Total Freight Cost' labels, enhancing readability, whereas the input code does not.",Base
"What is the total sales value for each product, and can this be represented in a bar chart for better clarity?","```python
import plotly.express as px
import pandas as pd

# Example SQL query execution function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    """"""
    This function executes an SQL query and returns a pandas DataFrame.
    """"""
    # This function is assumed to be provided externally
    pass

# Example function to display results
def show_to_user(data):
    """"""
    This function displays data or figures to the user.
    """"""
    # This function is assumed to be provided externally
    pass

# SQL query provided in the business request
sql_query = """"""
SELECT products.ProductID, ProductName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID, ProductName 
ORDER BY TotalSales DESC;
""""""

# Execute SQL query and get data in a DataFrame
df_sales = execute_sql_query(sql_query)

# Create a bar chart for total sales value for each product
fig = px.bar(df_sales, x='ProductName', y='TotalSales',
             title='Total Sales Value for Each Product',
             labels={'TotalSales': 'Total Sales Value ($)', 'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Total Sales Value for Each Product')
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It constructs the same SQL query to calculate the total sales value for each product and uses the same libraries, functions (execute_sql_query and show_to_user), and parameters to create a bar chart. The selections and grouping in the SQL query are the same, ensuring the calculation of TotalSales is correct, and the bar chart accurately represents the data. Minor structural differences in the SQL query are inconsequential to the outcome.","import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str):
    # Placeholder function to mimic SQL execution
    # In practice, this function would interact with the database.
    sample_data = {
        'ProductID': [1, 2, 3],
        'TotalSalesValue': [2000.00, 1500.00, 500.00]
    }
    return pd.DataFrame(sample_data)

# SQL query to calculate total sales value for each product
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSalesValue 
FROM [Order Details] 
GROUP BY ProductID;
""""""

# Execute the SQL query
df_sales = execute_sql_query(sql_query)

# Visualize the total sales values using a bar chart
fig = px.bar(df_sales, x='ProductID', y='TotalSalesValue', title='Total Sales Value by Product')

# Display the visualization
def show_to_user(data):
    # This is a placeholder for displaying data or a Plotly figure.
    # In practice, this would handle displaying in the relevant user interface.
    pass

show_to_user(fig)
","The input code and reference code both aim to calculate total sales per product and display it as a bar chart. However, the input code omits the join with the 'products' table and thus doesn't include 'ProductName' in the results. This differs from the reference, which orders products by name on the x-axis of the chart. The input uses 'ProductID' for the x-axis. The input SQL query also does not include ordering results by 'TotalSalesValue'. These differences mean the input code does not fully adhere to the specified business analytics request or the reference implementation logic.",Base
"Which employee's orders have the highest average discount applied, and can this be represented using a bar chart for better comparison?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    E.EmployeeID, 
    AVG(OD.Discount) AS AverageDiscount 
FROM 
    employees E 
JOIN 
    orders O ON E.EmployeeID = O.EmployeeID 
JOIN 
    [Order Details] OD ON O.OrderID = OD.OrderID 
GROUP BY 
    E.EmployeeID 
ORDER BY 
    AverageDiscount DESC;
""""""

# Execute SQL query and get results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Plotting the results using Plotly to compare average discounts
fig = px.bar(df, x='EmployeeID', y='AverageDiscount', title='Average Discount per Employee')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY AvgDiscount DESC
LIMIT 1;
""""""

top_employee = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.Discount) AS AvgDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY AvgDiscount DESC;
""""""

all_discount_data = execute_sql_query(sql_query_all)

fig = px.bar(all_discount_data, x='FirstName', y='AvgDiscount', 
             title='Average Discount by Employee', 
             text='AvgDiscount', 
             labels={'FirstName': 'Employee Name', 'AvgDiscount': 'Average Discount'},
             color='AvgDiscount')

show_to_user(fig)
```","The input code correctly fulfills the business analytics request by identifying the employee with the highest average discount and visualizing all employees' average discounts with a bar chart. While the input code provides additional details (FirstName and LastName) and finds the top employee as well, it ultimately executes a query similar to the reference implementation for the bar chart, sorted by average discount without any functional deviation from the reference logic. Both codes leverage SQL join operations to calculate average discounts per employee and use Plotly for visualization.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, AVG([Order Details].Discount) AS AvgDiscount
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID
ORDER BY AvgDiscount DESC
""""""

# Execute the SQL query
employee_discounts_df = execute_sql_query(sql_query)

# Determine the employee with the highest average discount
highest_avg_discount_employee = employee_discounts_df.iloc[0]

# Display the data for the employee with the highest average discount
show_to_user(highest_avg_discount_employee)

# Create a bar chart to compare the average discounts among employees
fig = px.bar(
    employee_discounts_df,
    x='EmployeeID',
    y='AvgDiscount',
    title='Average Discount per Employee',
    labels={'AvgDiscount': 'Average Discount', 'EmployeeID': 'Employee ID'}
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly implements the requested functionality. It executes the SQL query to fetch employee IDs and their average discounts, sorts the results, identifies the employee with the highest average discount, and displays a bar chart to compare average discounts among employees. The logic matches the reference implementation apart from the additional step of displaying the employee with the highest average discount, which complements the intended analysis.",both
Calculate the average discount applied to orders in the last 3 months and display the distribution of discounts using a histogram.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch discount data for orders in the last 3 months
sql_query = """"""
SELECT [Order Details].Discount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
""""""

# Execute the SQL query and get the result in a DataFrame
discount_df = execute_sql_query(sql_query)

# Calculate the average discount
avg_discount = discount_df['Discount'].mean()

# Display the average discount to the user
show_to_user(pd.DataFrame({'Average Discount': [avg_discount]}))

# Create a histogram of the discount distribution
fig = px.histogram(discount_df, x='Discount', title='Discount Distribution in Last 3 Months')

# Display the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

end_date = datetime.now()
start_date = end_date - timedelta(days=90)

sql_query = f""""""
SELECT Discount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""

discount_data = execute_sql_query(sql_query)
average_discount = discount_data['Discount'].mean()

fig = px.histogram(discount_data, x='Discount', title='Distribution of Discounts Applied to Orders in the Last 3 Months')
show_to_user(fig)

average_discount
```","The evaluated code does not display the average discount to the user in the same manner as the reference code does. The reference implementation uses 'show_to_user' to display the average discount, which is missing in the evaluated code. Additionally, the method to compute the date range slightly differs, though it does not affect correctness.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the necessary data
sql_query = """"""
SELECT OD.Discount 
FROM [Order Details] OD 
JOIN orders O ON OD.OrderID = O.OrderID 
WHERE O.OrderDate >= DATEADD(MONTH, -3, CURRENT_DATE);
""""""

# Execute the SQL query and get the data in a DataFrame
order_details_df = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = order_details_df['Discount'].mean()

# Display the average discount
show_to_user(pd.DataFrame({'Average Discount': [average_discount]}))

# Create a histogram of the discount distribution
fig = px.histogram(order_details_df, x='Discount', title='Distribution of Discounts in Last 3 Months')

# Display the histogram
show_to_user(fig)
```","The input Python code correctly implements the required business analytics request. It calculates the average discount applied to orders in the last 3 months and displays the distribution of discounts using a histogram, similar to the reference implementation. The SQL query and logic for computing the average discount and creating the histogram match the intent of the reference code, despite slight differences in SQL syntax for date functions.",Finetuned
"Which supplier has the most units in stock across all their products, and can you provide a bar chart to visualize the total units in stock for each supplier?","import pandas as pd
import plotly.express as px

# SQL query to get total units in stock for each supplier
sql_query = '''
SELECT suppliers.CompanyName, SUM(products.UnitsInStock) as TotalUnitsInStock
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
GROUP BY suppliers.SupplierID;
'''

# Execute SQL query
supplier_units_df = execute_sql_query(sql_query)

# Find the supplier with the most units in stock
top_supplier = supplier_units_df.loc[supplier_units_df['TotalUnitsInStock'].idxmax()]

# Display the top supplier
top_supplier_info = pd.DataFrame([top_supplier])
show_to_user(top_supplier_info)

# Create a bar chart for total units in stock for each supplier
fig = px.bar(supplier_units_df, x='CompanyName', y='TotalUnitsInStock', 
             title='Total Units in Stock by Supplier',
             labels={'TotalUnitsInStock': 'Total Units in Stock', 'CompanyName': 'Supplier'})

# Display the bar chart
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, SUM(p.UnitsInStock) AS TotalUnitsInStock
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID
ORDER BY TotalUnitsInStock DESC
""""""

result = execute_sql_query(sql_query)
top_supplier = result.iloc[0]

fig = px.bar(result, x='CompanyName', y='TotalUnitsInStock', title='Total Units in Stock by Supplier')
show_to_user(fig)
```","The provided code correctly performs the required operations: it computes the total units in stock for each supplier, identifies the supplier with the most units in stock by sorting the results, and generates a bar chart. While the methods to determine the top supplier differ between the reference and provided code, the logic and outcome remain consistent: both identify the top supplier and visualize the data with a bar chart. Furthermore, the order operation in the SQL query ensures the first row contains the supplier with the highest stock.","```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL query execution logic
    # In a real environment, this function would execute the SQL and return the results as a pandas DataFrame
    return pd.DataFrame({
        'SupplierID': [1, 2, 3],
        'TotalUnitsInStock': [300, 150, 500]
    })

# Utility function to show data to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to execute
sql_query = """"""
SELECT s.SupplierID, SUM(p.UnitsInStock) AS TotalUnitsInStock
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY s.SupplierID
ORDER BY TotalUnitsInStock DESC;
""""""

# Execute the SQL query to get the DataFrame
df_suppliers = execute_sql_query(sql_query)

# Sorting the DataFrame to ensure proper display in the bar chart
df_suppliers = df_suppliers.sort_values(by='TotalUnitsInStock', ascending=False)

# Create a bar chart using Plotly
fig = px.bar(df_suppliers, x='SupplierID', y='TotalUnitsInStock', 
             title='Total Units in Stock per Supplier',
             labels={'TotalUnitsInStock': 'Total Units in Stock'},
             text='TotalUnitsInStock')

# Show the bar chart to the user
show_to_user(fig)
```","The input code does not correctly identify the supplier with the most units in stock. It queries 'SupplierID' while the reference code uses 'CompanyName', which is more informative. Additionally, the input code doesn't explicitly find and display the top supplier separately, which is part of the requirement and is present in the reference implementation.",Base
"What is the inventory turnover ratio for February 2023, and can you provide a visual representation of the ratio compared to previous months?","```python
import pandas as pd
import plotly.express as px

# Sample execute_sql_query function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation to connect to database and execute query
    # Simulating the SQL execution here
    return pd.DataFrame({
        'Month': ['2023-01', '2023-02', '2023-03'],
        'InventoryTurnoverRatio': [5.4, 6.1, 5.9]
    })

# Function to display results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query for February 2023
sql_query = """"""
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-02-01' AND '2023-02-28'
""""""

# Execute SQL query
inventory_turnover_data = execute_sql_query(sql_query)

# Assuming the result returned is a single row DataFrame with February's ratio
inventory_turnover_february = inventory_turnover_data['InventoryTurnoverRatio'].iloc[0]

# Simulate data for previous months as sample data is used
# Create DataFrame for plotting
historical_data = pd.DataFrame({
    'Month': ['2023-01', '2023-02', '2023-03'],
    'InventoryTurnoverRatio': [5.4, inventory_turnover_february, 5.9]
})

# Generate plot
fig = px.line(historical_data, x='Month', y='InventoryTurnoverRatio', 
              title='Inventory Turnover Ratio Over Time',
              labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio'},
              markers=True)

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY month
ORDER BY month;
""""""

turnover_data = execute_sql_query(sql_query)

fig = px.line(turnover_data, x='month', y='inventory_turnover_ratio', title='Inventory Turnover Ratio by Month')
show_to_user(fig)
```","The input code calculates the inventory turnover ratio for all months within 2023, not just for February, and it plots all those months. The reference code specifically queries for February 2023 and does not aggregate results across multiple months in a single query. Therefore, it does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query for February 2023 inventory turnover ratio
sql_query_february = """"""
SELECT SUM(od.UnitPrice * od.Quantity) / AVG(dh.UnitsInStock) AS Inventory_Turnover_Ratio 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
JOIN [Order Details] dh ON od.ProductID = dh.ProductID 
WHERE EXTRACT(MONTH FROM o.OrderDate) = 2 
AND EXTRACT(YEAR FROM o.OrderDate) = 2023;
""""""

# Define the SQL query for inventory turnover ratios for previous months
sql_query_previous_months = """"""
SELECT EXTRACT(MONTH FROM o.OrderDate) AS Month, 
       EXTRACT(YEAR FROM o.OrderDate) AS Year, 
       SUM(od.UnitPrice * od.Quantity) / AVG(dh.UnitsInStock) AS Inventory_Turnover_Ratio 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
JOIN [Order Details] dh ON od.ProductID = dh.ProductID 
WHERE EXTRACT(YEAR FROM o.OrderDate) < 2023
GROUP BY EXTRACT(YEAR FROM o.OrderDate), EXTRACT(MONTH FROM o.OrderDate)
ORDER BY Year, Month;
""""""

# Execute the SQL query for February 2023
february_df = execute_sql_query(sql_query_february)
display(february_df)

# Execute the SQL query for previous months
previous_months_df = execute_sql_query(sql_query_previous_months)

# Combine February with previous months for comparison
combined_df = pd.DataFrame({
    'Month-Year': ['Feb-2023'] + [f""{month}-{year}"" for year, month in zip(previous_months_df['Year'], previous_months_df['Month'])],
    'Inventory Turnover Ratio': [february_df.iloc[0]['Inventory_Turnover_Ratio']] + previous_months_df['Inventory_Turnover_Ratio'].tolist()
})

# Create a line plot for the inventory turnover ratio
fig = px.line(combined_df, x='Month-Year', y='Inventory Turnover Ratio', title='Inventory Turnover Ratio Comparison',
              labels={'Inventory Turnover Ratio': 'Turnover Ratio', 'Month-Year': 'Month-Year'})

# Display the plot
show_to_user(fig)
```","The input code uses a slightly different approach compared to the reference implementation. Specifically, it involves different handling of date filtering and calculation logic using SQL queries. The input code combines current and previous data using an approach that deviates from grouping by year and month in the February query. Additionally, the way it's calculating the inventory turnover using JOINs and GROUP BY differs from the reference implementation logic. Therefore, it doesn’t adhere to the same logic as described in the reference implementation.",None
What are the total sales for each product in the current month? Include a bar chart to visualize the sales distribution across products.,"```python
import plotly.express as px
import pandas as pd

# Business Analytic Request
def analyze_product_sales():
    # SQL Query to get total sales for each product in the current month
    sql_query = """"""
    SELECT P.ProductName, SUM(OD.Quantity * OD.UnitPrice) AS TotalSales
    FROM products P
    JOIN [Order Details] OD ON P.ProductID = OD.ProductID
    WHERE DATE_FORMAT(OD.OrderDate, '%Y-%m') = DATE_FORMAT(CURDATE(), '%Y-%m')
    GROUP BY P.ProductName;
    """"""
    
    # Execute the SQL query and fetch results in a pandas DataFrame
    sales_df = execute_sql_query(sql_query)
    
    # Create a bar chart to visualize the sales distribution across products
    fig = px.bar(sales_df, x='ProductName', y='TotalSales', title='Total Sales for Each Product in the Current Month')
    
    # Show the figure to the user
    show_to_user(fig)

# Call the function to perform the analysis
analyze_product_sales()
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_month = datetime.now().strftime('%Y-%m')

sql_query = f""""""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
WHERE 
    DATE_FORMAT(CURDATE(), '%Y-%m') = '{current_month}'
GROUP BY 
    p.ProductName
""""""
sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Total Sales for Each Product in Current Month')
show_to_user(fig)
```","The input code uses 'DATE_FORMAT(CURDATE(), '%Y-%m') = '{current_month}'' which should be comparing 'DATE_FORMAT(OrderDate, '%Y-%m')' with the current month. Additionally, it includes a discount calculation which is not present in the reference code, affecting the resulting TotalSales values.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT P.ProductName, SUM(OD.UnitPrice * OD.Quantity) AS TotalSales
FROM products P
JOIN [Order Details] OD ON P.ProductID = OD.ProductID
JOIN orders O ON OD.OrderID = O.OrderID
WHERE O.OrderDate >= DATE_TRUNC('month', CURRENT_DATE)
AND O.OrderDate < CURRENT_DATE
GROUP BY P.ProductName
""""""

# Execute the SQL query and get the results in a DataFrame
df_sales = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales distribution across products
fig = px.bar(df_sales, x='ProductName', y='TotalSales', title='Total Sales for Each Product in Current Month')

# Display the figure
show_to_user(fig)
```","The input Python code correctly calculates the total sales for each product in the current month. It uses a similar logic as the reference code. Both codes execute a SQL query that joins the 'products', 'Order Details', and 'orders' tables, grouping by 'ProductName' to sum 'UnitPrice * Quantity' for the current month sales. The way of determining the current month is logically consistent, and both codes create a bar chart using plotly express to visualize the sales distribution. The use of `DATE_TRUNC` and comparison with `CURRENT_DATE` in the input code is equivalent to the date handling in the reference code.",Finetuned
"Which products have the highest inventory turnover ratio, and can this be visualized in a bar chart to better understand the comparison?","import pandas as pd
import plotly.express as px

# SQL query to be executed
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / NULLIF(AVG(products.UnitsInStock), 0) AS turnover_ratio 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY turnover_ratio DESC
""""""

# Execute SQL query to get the data
df_turnover = execute_sql_query(sql_query)

# Optional: Display raw data to user for reference
show_to_user(df_turnover)

# Create a bar chart to visualize the inventory turnover ratio
fig = px.bar(df_turnover, x='ProductName', y='turnover_ratio', title='Inventory Turnover Ratio by Product')

# Display the bar chart to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductID, products.ProductName
ORDER BY inventory_turnover_ratio DESC
LIMIT 10
""""""

inventory_turnover_df = execute_sql_query(sql_query)

fig = px.bar(inventory_turnover_df, 
             x='ProductName', 
             y='inventory_turnover_ratio', 
             title='Top 10 Products by Inventory Turnover Ratio',
             labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly calculates the inventory turnover ratio for the products by summing the order details' quantity multiplied by unit price and dividing by the average units in stock, as shown in the reference code. It also includes a limit to the top 10 products, which is an acceptable modification for visualization purposes. The resulting DataFrame is used to create a bar chart displaying the inventory turnover ratios by product name, which satisfies the business request. The use of 'NULLIF' in the reference code to prevent division by zero is not explicitly mirrored in the input code, but it may be managed within the query execution or not relevant to the dataset.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate inventory turnover ratio
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY InventoryTurnoverRatio DESC;
""""""

# Execute SQL query to get inventory turnover data
inventory_turnover_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(inventory_turnover_df,
             x='ProductName',
             y='InventoryTurnoverRatio',
             title='Inventory Turnover Ratio by Product',
             labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It computes the inventory turnover ratio using a similar SQL query to the reference code, ensuring it selects the product names and calculates turnover as the sum of order details divided by the average units in stock. The ordering by the ratio is also consistent. The visualization part uses Plotly to create and display a bar chart with appropriate labels, mirroring the reference logic effectively. Despite slight differences in SQL aliases and label customizations, the core functionality and logic remain aligned with the reference implementation.",both
Which shipping company handled the most deliveries in 2023? Please include a bar chart to visualize the comparative delivery volumes of each company.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT shippers.CompanyName, COUNT(orders.OrderID) AS num_deliveries
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY shippers.CompanyName
ORDER BY num_deliveries DESC
""""""

# Execute the SQL query and get the result in a DataFrame
df_deliveries = execute_sql_query(sql_query)

# Create a bar chart to visualize the comparative delivery volumes
fig = px.bar(df_deliveries, x='CompanyName', y='num_deliveries', 
             title='Deliveries Handled by Each Shipping Company in 2023')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate delivery volumes for each shipping company in 2023
sql_query = """"""
SELECT shippers.CompanyName, COUNT(orders.OrderID) AS delivery_count
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY shippers.CompanyName
ORDER BY delivery_count DESC
""""""

# Execute the SQL query
delivery_data = execute_sql_query(sql_query)

# Identify the shipping company with the most deliveries
top_shipper = delivery_data.iloc[0]

# Create a bar chart to visualize the delivery volumes
fig = px.bar(delivery_data, x='CompanyName', y='delivery_count', 
             title='Delivery Volumes by Shipping Company in 2023',
             labels={'delivery_count': 'Number of Deliveries', 'CompanyName': 'Shipping Company'})

# Show the result to the user
show_to_user(fig)
```","Both the reference and input codes correctly address the business analytics request. They execute an equivalent SQL query to count the number of deliveries per shipping company in 2023. The only difference is the method of specifying the date condition—both are valid and yield the same results. Each code generates a bar chart using Plotly to visualize the comparative delivery volumes of each company, which aligns with the request. Thus, the input code is logically correct according to the specified criteria.","```python
import pandas as pd
import plotly.express as px

# Simulated function to execute SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL query execution
    # This would normally interact with a database to return the query result
    # Here we use simulated data for illustration
    data = {
        'shippers.CompanyName': ['Company A', 'Company B', 'Company C'],
        'num_orders': [150, 200, 180]
    }
    return pd.DataFrame(data)

# Simulated function to show output to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        # Assume data is a Plotly figure
        data.show()

# Define the SQL query
sql_query = """"""
SELECT shippers.CompanyName, COUNT(orders.OrderID) AS num_orders
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY shippers.CompanyName
ORDER BY num_orders DESC;
""""""

# Execute the SQL query and get the results
df_deliveries = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize delivery volumes
fig = px.bar(df_deliveries, x='shippers.CompanyName', y='num_orders',
             title='Delivery Volumes by Shipping Company in 2023',
             labels={'shippers.CompanyName': 'Shipping Company', 'num_orders': 'Number of Deliveries'})

# Show the chart to the user
show_to_user(fig)
```","The input Python code is correct as it achieves the same objective as the reference implementation. Both codes perform a SQL query to count the number of deliveries handled by each shipping company in 2023 and order the results. The main difference is the alias used for the count column ('num_orders' vs. 'num_deliveries') and the way the year filter is applied in SQL query ('YEAR(orders.OrderDate) = 2023' vs. 'BETWEEN'). Both approaches are valid. The bar chart is correctly generated using Plotly to visualize delivery volumes, and the data is displayed to the user.",both
Determine the busiest month for orders and create a bar chart to visualize monthly order volumes.,"```python
import pandas as pd
import plotly.express as px

def busiest_month_for_orders():
    # SQL query to get monthly order data
    sql_query = '''
    SELECT EXTRACT(MONTH FROM OrderDate) AS OrderMonth, COUNT(OrderID) AS MonthlyOrders 
    FROM orders 
    GROUP BY OrderMonth
    ORDER BY OrderMonth;
    '''
    
    # Execute the SQL query
    monthly_orders_df = execute_sql_query(sql_query)
    
    # Create a bar chart for monthly order volumes
    fig = px.bar(monthly_orders_df, x='OrderMonth', y='MonthlyOrders',
                 title='Monthly Order Volumes',
                 labels={'OrderMonth': 'Month', 'MonthlyOrders': 'Number of Orders'})
    
    # Display the chart to user
    show_to_user(fig)

# Call the function
busiest_month_for_orders()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY OrderCount DESC
""""""
monthly_orders = execute_sql_query(sql_query)

fig = px.bar(monthly_orders, x='Month', y='OrderCount', title='Monthly Order Volumes', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})
show_to_user(fig)
```","The input code groups the order counts by year and month using DATE_FORMAT(OrderDate, '%Y-%m'), while the reference implementation extracts only the month using EXTRACT(MONTH FROM OrderDate). The input groups results differently, potentially leading to different outcomes. Additionally, it sorts the results by OrderCount in descending order, which could affect the visualization compared to sorting by Month as in the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query to determine the busiest month for orders.
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY OrderCount DESC;
""""""

# Function to execute SQL query and return the result as a pandas DataFrame.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implement the logic to execute the SQL and return a pandas DataFrame.
    # This is a placeholder for the actual database connection and execution logic.
    pass  # Replace with actual implementation

# Execute the SQL query
monthly_orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the monthly order volumes.
fig = px.bar(monthly_orders_df, x='Month', y='OrderCount', 
             title='Monthly Order Volumes',
             labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})

# Function to display the visualization to the user.
def show_to_user(data):
    if isinstance(data, (pd.DataFrame, px.Figure)):
        data.show()  # Display the data or figure

# Show the bar chart to the user.
show_to_user(fig)
```","The input code orders the results by OrderCount descending, attempting to find the busiest month. However, the reference implementation orders by OrderMonth to simply plot monthly orders in chronological order. The reference logic focuses on chronological grouping, not identifying the busiest month by OrderCount directly.",None
"Which cities do the top three suppliers operate from, and can you provide a map visualization to illustrate their locations?","```python
import plotly.express as px

# Given Utility Function Stubs
def execute_sql_query(sql_query: str):
    # This function is supposed to execute the SQL query and return the results as a pandas DataFrame.
    # Implemented in the system; here as a placeholder
    pass

def show_to_user(data):
    # This function displays data or visualizations; implemented in the system.
    # It can accept either a DataFrame or a Plotly figure.
    pass

# SQL query from the request
sql_query = """"""
SELECT suppliers.City, MAX(suppliers.latitude) as latitude, MAX(suppliers.longitude) as longitude
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.City 
ORDER BY COUNT(DISTINCT products.SupplierID) DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Check if latitude and longitude are present
if 'latitude' not in df or 'longitude' not in df:
    raise ValueError('Latitude and Longitude columns are expected in the DataFrame.')

# Using Plotly for map visualization
fig = px.scatter_mapbox(
    df, 
    lat='latitude',  # Assuming the DataFrame has latitude for plotting
    lon='longitude', # Assuming the DataFrame has longitude for plotting
    text='City', 
    zoom=3, 
    center={""lat"": 0, ""lon"": 0},
    mapbox_style=""open-street-map"",
    title=""Top 3 Supplier Cities""
)

# Display the map to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top three suppliers based on total sales
sql_query = """"""
SELECT s.City, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName, s.City
ORDER BY TotalSales DESC
LIMIT 3
""""""

# Execute the SQL query and obtain the data
top_suppliers_df = execute_sql_query(sql_query)

# Create a map visualization for the top suppliers' locations
fig = px.scatter_geo(top_suppliers_df, 
                     locations=""City"", 
                     title=""Top 3 Suppliers by Sales"",
                     hover_name=""CompanyName"")
show_to_user(fig)
```","The input code calculates the top three suppliers based on total sales, not on the count of distinct products supplied. The grouping is by SupplierID, which includes CompanyName, but the reference code ranks cities by the number of distinct products. Additionally, the input code uses a basic geographic plot without actual latitude and longitude data, which differs from the Plotly scatter_mapbox used in the reference implementation that requires precise coordinates for mapping.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch the data we need
sql_query = """"""
SELECT s.City 
FROM suppliers s 
JOIN (
    SELECT s1.CompanyName 
    FROM suppliers s1 
    JOIN products p ON s1.SupplierID = p.SupplierID 
    GROUP BY s1.CompanyName 
    ORDER BY SUM(p.UnitPrice * p.UnitsInStock) DESC 
    LIMIT 3
) AS top_suppliers 
ON s.CompanyName = top_suppliers.CompanyName;
""""""

# Execute the SQL query and store the result in a DataFrame
top_cities_df = execute_sql_query(sql_query)

# Use Plotly to create a map visualization of the top cities
fig = px.scatter_geo(
    top_cities_df,
    locations=""City"",
    locationmode=""city names"",
    title=""Cities of the Top 3 Suppliers""
)

# Display the map to the user
show_to_user(fig)
```","The input code retrieves cities based on the top three suppliers by total value of products (UnitPrice * UnitsInStock) rather than the number of distinct suppliers in a city. Moreover, the input code uses a different grouping method compared to the reference, which ranks cities using the distinct count of products per supplier. Additionally, the input map visualization does not ensure latitude and longitude, which the reference code requires for accurate plotting on a map.",None
"What is the longest time taken to fulfill an order, and can this be visualized to show fulfillment times across different orders?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the longest fulfillment time along with all fulfillment times
sql_query = """"""
SELECT 
    OrderID,
    DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM 
    orders;
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Find the longest fulfillment time
max_fulfillment_time = df_orders['FulfillmentTime'].max()

# Display the longest fulfillment time to the user
longest_time_df = pd.DataFrame({'LongestFulfillmentTime': [max_fulfillment_time]})
show_to_user(longest_time_df)

# Visualizing fulfillment times across different orders
fig = px.bar(df_orders, x='OrderID', y='FulfillmentTime', title='Fulfillment Times Across Orders')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID,
       DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL
""""""

# Execute the SQL query
fulfillment_data = execute_sql_query(sql_query)

# Calculate the longest fulfillment time
longest_fulfillment_time = fulfillment_data['FulfillmentTime'].max()

# Visualize fulfillment times across different orders
fig = px.bar(fulfillment_data, x='OrderID', y='FulfillmentTime', title='Fulfillment Times Across Orders', labels={'FulfillmentTime': 'Fulfillment Time (Days)', 'OrderID': 'Order ID'})
show_to_user(fig)

longest_fulfillment_time
```","The provided code correctly calculates the longest fulfillment time and visualizes fulfillment times across different orders. It excludes rows with null 'ShippedDate', which is a valid approach assuming undefined dates should not be considered. The logic and output align with the reference implementation, even though the method of displaying the maximum value differs.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the longest fulfillment time
sql_query = """"""
SELECT MIN(ShippedDate - OrderDate) AS MaxFulfillTime 
FROM orders WHERE ShippedDate IS NOT NULL;
""""""

# Execute the SQL query to get the fulfillment times
fulfillment_times_df = execute_sql_query(""SELECT OrderID, ShippedDate, OrderDate FROM orders WHERE ShippedDate IS NOT NULL"")

# Calculate fulfillment times for each order
fulfillment_times_df['FulfillmentTime'] = fulfillment_times_df['ShippedDate'] - fulfillment_times_df['OrderDate']

# Find the maximum fulfillment time
max_fulfillment_time = fulfillment_times_df['FulfillmentTime'].max()

# Prepare data for visualization
viz_df = fulfillment_times_df.sort_values(by='FulfillmentTime', ascending=False)

# Create a bar plot using Plotly
fig = px.bar(viz_df, x='OrderID', y='FulfillmentTime', title='Order Fulfillment Times', labels={'FulfillmentTime':'Fulfillment Time'})

# Display the maximum fulfillment time and the visualization
show_to_user(pd.DataFrame({'MaxFulfillTime': [max_fulfillment_time]})) # Display MaxFulfillTime
show_to_user(fig)  # Display the bar plot
```","The input code correctly derives the longest time taken to fulfill an order by calculating the difference between 'ShippedDate' and 'OrderDate'. It filters out orders with NULL 'ShippedDate' entries, similar to the reference implementation, ensuring only valid fulfilment times are considered. The code computes the maximum fulfillment time, aligns with the request, and uses Plotly to visualize fulfillment times across orders. Although the SQL query for maximum fulfillment in the input code is slightly different, it doesn't affect the main logic since the max is again calculated in Pandas. Overall, the core logic and outcome are consistent with the reference.",both
"What is the total freight cost incurred for orders handled by each employee? Additionally, provide a bar chart to visualize the freight costs per employee.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation for SQL execution
    # In practice, this would connect to a database and execute the query
    return pd.read_sql_query(sql_query, con=your_database_connection)

# Utility function to show data or figures to the user
def show_to_user(data):
    if isinstance(data, (pd.DataFrame, pd.Series)):
        print(data)  # Display DataFrame information
    elif isinstance(data, px.Figure):
        data.show()  # Display Plotly figure

# SQL query to calculate total freight by employee
sql_query = """"""
SELECT e.EmployeeID, SUM(o.Freight) AS TotalFreight
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the result as a DataFrame
df_freight_by_employee = execute_sql_query(sql_query)

# Display the freight costs by employee
show_to_user(df_freight_by_employee)

# Create a bar chart using Plotly to visualize freight costs per employee
fig = px.bar(df_freight_by_employee, x='EmployeeID', y='TotalFreight', 
             title='Total Freight Cost per Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalFreight': 'Total Freight Cost'})
             
# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(o.Freight) AS TotalFreight
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, EmployeeName
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='EmployeeName', y='TotalFreight', 
             title='Total Freight Cost by Employee', 
             labels={'TotalFreight': 'Total Freight Cost', 'EmployeeName': 'Employee'})

show_to_user(fig)
```","The input code correctly calculates the total freight cost per employee by summing the 'Freight' column for each 'EmployeeID' and grouping by 'EmployeeID' and 'EmployeeName', which aligns with the reference's logic. The differences, such as including 'EmployeeName', provide additional information without altering the correctness of the solution. The bar chart is still correctly visualized using the calculated freight data.","```python
import plotly.express as px

# SQL query to fetch total freight cost per employee
sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    SUM(o.Freight) AS TotalFreightCost 
FROM Employees e 
JOIN Orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute the SQL query
data_frame = execute_sql_query(sql_query)

# Create a bar chart to visualize freight costs per employee
fig = px.bar(
    data_frame,
    x=data_frame.index,  # Assuming 'data_frame' is not reset_index so that 'EmployeeID' is set as index
    y='TotalFreightCost',
    text='TotalFreightCost',
    labels={'TotalFreightCost': 'Total Freight Cost ($)', 'index': 'Employee'},
    title='Total Freight Cost per Employee',
    hover_data=['FirstName', 'LastName']
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code includes additional columns 'FirstName' and 'LastName' in the SQL query and groups by these columns as well. This changes the granularity of the data compared to the reference implementation which groups only by 'EmployeeID'. Additionally, the bar chart uses the DataFrame index for the x-axis, which may not match 'EmployeeID' if not set appropriately. Thus, the input code doesn't adhere to the same logic or output as the reference implementation.",Base
"What is the average monthly sales growth for each product, and can you provide a line chart to visualize the growth trends over time?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function to replicate the execution of the SQL query
    # Replace with actual database querying logic
    data = {
        'ProductName': ['Product A', 'Product A', 'Product B', 'Product B'],
        'Year': [2023, 2023, 2023, 2023],
        'Month': [1, 2, 1, 2],
        'AvgSalesGrowth': [0.10, 0.15, 0.05, 0.07]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock function to display data or plot
    # Replace with actual visualization logic
    print(data)

# SQL query provided in the request
sql_query = """"""
SELECT p.ProductName, 
       AVG(CASE WHEN LAG(SUM(od.Quantity), 1) OVER (PARTITION BY p.ProductID ORDER BY EXTRACT(YEAR FROM o.OrderDate), EXTRACT(MONTH FROM o.OrderDate)) = 0 THEN NULL 
           ELSE (SUM(od.Quantity) - LAG(SUM(od.Quantity), 1) OVER (PARTITION BY p.ProductID ORDER BY EXTRACT(YEAR FROM o.OrderDate), EXTRACT(MONTH FROM o.OrderDate))) / LAG(SUM(od.Quantity), 1) OVER (PARTITION BY p.ProductID ORDER BY EXTRACT(YEAR FROM o.OrderDate), EXTRACT(MONTH FROM o.OrderDate)) 
       END) AS AvgSalesGrowth 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY p.ProductID, p.ProductName, EXTRACT(YEAR FROM o.OrderDate), EXTRACT(MONTH FROM o.OrderDate);
""""""

# Execute SQL query to get data
df = execute_sql_query(sql_query)

# Pivot data for better plotting
df_pivot = df.pivot_table(index=['Year', 'Month'], columns='ProductName', values='AvgSalesGrowth', aggfunc='mean').reset_index()

# Plotting the line chart using Plotly
fig = px.line(df_pivot, x='Month', y=df_pivot.columns[2:], title='Average Monthly Sales Growth per Product', labels={'value':'Avg Sales Growth', 'Month':'Month'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve sales data
sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, p.ProductName, Month
ORDER BY 
    Month, p.ProductID
""""""

sales_data = execute_sql_query(sql_query)

# Step 2: Calculate monthly sales growth for each product
sales_data['SalesGrowth'] = sales_data.groupby('ProductID')['TotalSales'].pct_change() * 100

# Step 3: Pivot the data for visualization
pivot_data = sales_data.pivot(index='Month', columns='ProductName', values='SalesGrowth')

# Step 4: Create the line chart
fig = px.line(pivot_data, title='Average Monthly Sales Growth by Product', labels={'value': 'Sales Growth (%)', 'Month': 'Month'})
show_to_user(fig)
```","The input code effectively calculates the average monthly sales growth for each product, similar to the reference code. It retrieves sales data, calculates the percentage change in sales, and creates a line chart to visualize growth trends over time. The logic adheres to the business analytics request, matching the reference code functionality despite differences in implementation details.","
import pandas as pd
import plotly.express as px

# Assuming the utility functions are already defined
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented elsewhere
    pass

def show_to_user(data):
    # This function is assumed to be implemented elsewhere
    pass

# Provided SQL query for retrieving the required data
sql_query = """"""
SELECT 
    MONTH(o.OrderDate) AS month, 
    p.ProductName, 
    ((SUM(od.Quantity) - LAG(SUM(od.Quantity)) OVER (PARTITION BY p.ProductName ORDER BY MONTH(o.OrderDate))) / NULLIF(LAG(SUM(od.Quantity)) OVER (PARTITION BY p.ProductName ORDER BY MONTH(o.OrderDate)), 0)) * 100 AS sales_growth 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY MONTH(o.OrderDate), p.ProductName;
""""""

# Execute the SQL query and get the data as a DataFrame
sales_growth_df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize the sales growth trends over time
fig = px.line(
    sales_growth_df, 
    x='month', 
    y='sales_growth', 
    color='ProductName',
    title='Monthly Sales Growth Trend by Product',
    labels={'month': 'Month', 'sales_growth': 'Sales Growth (%)'}
)

# Show the chart to the user
show_to_user(fig)
","The input code correctly computes the monthly sales growth for each product by calculating the month-over-month percentage change in sales quantity using the LAG function. It then visualizes the data using a line chart in Plotly, with months on the x-axis and sales growth percentages on the y-axis, colored by product name. The approach matches the logic described in the reference implementation, hence, it is considered correct.",both
"How does the sales quantity of each product compare month over month, and can this be represented in a line or bar chart for clarity?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT ProductName, EXTRACT(MONTH FROM OrderDate) AS Month, SUM([Order Details].Quantity) AS MonthlyQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY ProductName, EXTRACT(MONTH FROM OrderDate) 
ORDER BY ProductName, EXTRACT(MONTH FROM OrderDate);
""""""

# Execute the SQL query and get the results in a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Visualize the data using a line plot
fig = px.line(
    sales_data,
    x='Month',
    y='MonthlyQuantity',
    color='ProductName',
    title='Monthly Sales Quantity by Product',
    labels={'MonthlyQuantity': 'Sales Quantity', 'Month': 'Month'}
)

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly sales quantity for each product
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity) AS TotalQuantity
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, p.ProductName, Month
ORDER BY 
    Month, p.ProductID
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a line chart for month-over-month sales comparison
fig = px.line(sales_data, x='Month', y='TotalQuantity', color='ProductName', title='Monthly Sales Quantity Comparison by Product')

# Show the visualization to the user
show_to_user(fig)
```","The provided code generates a line chart comparing monthly sales quantity for each product, which matches the requirements of the business analytics request. It executes the SQL query to aggregate and extract sales data by product and month. The main difference from the reference implementation is the use of DATE_FORMAT to extract the month and year into a single string (e.g., '%Y-%m'). This still captures monthly aggregation correctly. Both codes create a line plot visualizing sales trends per product, fulfilling the request's intent.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT
    ProductID,
    EXTRACT(YEAR FROM OrderDate) AS Year,
    EXTRACT(MONTH FROM OrderDate) AS Month,
    SUM(od.Quantity) AS Quantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY ProductID, EXTRACT(YEAR FROM OrderDate), EXTRACT(MONTH FROM OrderDate)
ORDER BY Year, Month, ProductID;
""""""

# Execute the SQL query using the utility function
sales_data = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize monthly sales per product
fig = px.line(
    sales_data,
    x='Month',
    y='Quantity',
    color='ProductID',
    title='Monthly Sales Quantity by Product',
    labels={'Quantity': 'Sales Quantity', 'Month': 'Month'},
    hover_data={'Year': True, 'ProductID': True}
)

# Display the visualization
show_to_user(fig)
```","The input code does not fully align with the business request or the reference implementation. The input code uses `ProductID` instead of `ProductName` for grouping and coloring the line chart. Additionally, it extracts both YEAR and MONTH while the reference implementation only extracts MONTH, which simplifies the analysis as requested. The input code results in separate trend lines for each year, which is not consistent with the reference's monthly aggregation across all years for each product.",Base
What is the total discount given for each month? Please include a bar chart to visualize the monthly discounts.,"```python
import pandas as pd
import plotly.express as px

# Sample SQL query execution function (mock implementation)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would typically execute the SQL query and return a DataFrame.
    # Here, you would have the database connection and query execution code.
    # For demonstration purposes, we will use a mock DataFrame.
    data = {
        'Month': ['2023-01', '2023-02', '2023-03'],
        'TotalDiscount': [5000.00, 7000.00, 6500.00]
    }
    return pd.DataFrame(data)

# Sample function to display data (mock implementation)
def show_to_user(data):
    # This function would display the data to the user.
    # If it's a DataFrame, it may display a table.
    # If it's a Plotly figure, it will display a graph.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to calculate monthly discounts
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY Month;
""""""

# Execute the query and get the results in a DataFrame
discounts_df = execute_sql_query(sql_query)

# Visualize the total discount per month using a bar chart
fig = px.bar(discounts_df, x='Month', y='TotalDiscount', title='Total Discount Given Per Month', labels={'TotalDiscount': 'Total Discount', 'Month': 'Month'})

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS OrderMonth,
    SUM([Order Details].Discount * [Order Details].UnitPrice * [Order Details].Quantity) AS TotalDiscount
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

monthly_discounts = execute_sql_query(sql_query)

fig = px.bar(monthly_discounts, x='OrderMonth', y='TotalDiscount', 
              title='Total Discounts Given Each Month', 
              labels={'OrderMonth': 'Month', 'TotalDiscount': 'Total Discount'})
show_to_user(fig)
```",The input code correctly calculates the total discount for each month using the specified SQL query structure. It matches the logic of the reference code by joining the 'orders' and '[Order Details]' tables and aggregating discounts based on the month. Both codes use Plotly for visualization and display it using a similar mechanism. The differences in column alias ('OrderMonth' vs 'Month') and ordering clause do not impact the correctness of the logic.,"```python
import pandas as pd
import plotly.express as px

# Provided utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating database execution and returning a DataFrame
    data = {
        'YearMonth': ['2023-01', '2023-02', '2023-03'],
        'TotalDiscount': [1500, 1200, 1800]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Simulates displaying the data to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query for total monthly discounts
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS YearMonth,
       SUM(Order_Details.Discount * Order_Details.Quantity * Order_Details.UnitPrice) AS TotalDiscount
FROM orders
JOIN Order_Details ON orders.OrderID = Order_Details.OrderID
GROUP BY YearMonth;
""""""

# Execute the SQL query
df_discounts = execute_sql_query(sql_query)

# Create a bar chart to visualize monthly discounts
fig = px.bar(df_discounts, x='YearMonth', y='TotalDiscount', 
             title='Monthly Total Discounts', 
             labels={'YearMonth': 'Month', 'TotalDiscount': 'Total Discount'})

# Display the bar chart
show_to_user(fig)
```","The input Python code to evaluate performs the same task as the reference implementation. Both implementations calculate the total discount given for each month by executing a SQL query that aggregates monthly data, and both include functionality to visualize this information using a bar chart. The variable names and mock data values differ, but the logic is equivalent, satisfying the business analytics request.",both
"What is the average discount applied per order this year, and can you provide a visualization to show the distribution of discounts across different orders?","```python
import pandas as pd
import plotly.express as px

# Utility function which would be provided within the environment
def execute_sql_query(sql_query: str):
    # This function is assumed to execute the SQL query and return a DataFrame
    pass

def show_to_user(data):
    # This function is assumed to display the data or visualization
    pass

# SQL Query to calculate the average discount for this year
sql_query = """"""
SELECT [Order Details].Discount, orders.OrderID
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE)
""""""

# Execute the SQL query and fetch data into a DataFrame
orders_df = execute_sql_query(sql_query)

# Calculate the average discount
avg_discount = orders_df['Discount'].mean()

# Print the average discount
avg_discount_df = pd.DataFrame({'Average Discount': [avg_discount]})
show_to_user(avg_discount_df)

# Visualization: Distribution of discounts across different orders
fig = px.histogram(orders_df, x='Discount', title='Distribution of Discounts Across Orders')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    SUM([Order Details].Discount) AS total_discount,
    COUNT(DISTINCT orders.OrderID) AS total_orders
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

discount_data = execute_sql_query(sql_query)
average_discount = discount_data['total_discount'].iloc[0] / discount_data['total_orders'].iloc[0]

discount_distribution_query = """"""
SELECT 
    [Order Details].Discount
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

discount_distribution_data = execute_sql_query(discount_distribution_query)

fig = px.histogram(discount_distribution_data, x='Discount', title='Distribution of Discounts per Order')
show_to_user(fig)

average_discount
```","The input code correctly calculates the average discount per order this year and generates a visualization of the distribution of discounts across different orders. The SQL query accurately calculates the total discount and total number of orders to derive the average. The second query correctly fetches discount data for creating the histogram. Although the method is slightly different from the reference, it adheres to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average discount for this year
sql_query_avg_discount = ""SELECT AVG(Discount) AS AvgDiscount FROM [Order Details] WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE);""

# SQL query to get all discounts per order for this year
sql_query_discounts_per_order = """"""
    SELECT OrderID, AVG(Discount) AS AvgDiscount
    FROM [Order Details]
    WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE)
    GROUP BY OrderID;
""""""

# Execute the query to get average discount
average_discount_df = execute_sql_query(sql_query_avg_discount)

# Execute the query to get discounts per order
discounts_per_order_df = execute_sql_query(sql_query_discounts_per_order)

# Display the average discount
show_to_user(average_discount_df)

# Create a histogram for the distribution of discounts
fig = px.histogram(discounts_per_order_df, x='AvgDiscount',
                   title='Distribution of Discounts Across Orders',
                   labels={'AvgDiscount': 'Average Discount'},
                   nbins=30)

# Show the histogram
show_to_user(fig)
```","The input code incorrectly calculates the average discount across all orders. It computes the average discount per order and then creates a histogram of these per-order averages, whereas the reference calculates the overall average discount across all order details without grouping by OrderID. This results in a discrepancy between the expected average discount computation and the aggregated one in the input code.",Base
"What is the average lead time for each supplier over the past year, and can a bar chart be created to visualize these lead times for better comparison?","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch data
sql_query = """"""
SELECT s.SupplierID, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN orders o ON p.ProductID = o.ProductID 
WHERE o.OrderDate BETWEEN CURDATE() - INTERVAL 1 YEAR AND CURDATE() 
GROUP BY s.SupplierID;
""""""

# Execute the SQL query to get the data into a pandas DataFrame
supplier_lead_times = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(supplier_lead_times, 
             x='SupplierID', 
             y='AverageLeadTime', 
             title='Average Lead Time for Each Supplier Over the Past Year',
             labels={'AverageLeadTime': 'Average Lead Time (days)'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    suppliers.SupplierID, 
    suppliers.CompanyName, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime
FROM 
    suppliers
JOIN 
    products ON suppliers.SupplierID = products.SupplierID
JOIN 
    orders ON products.ProductID = [Order Details].ProductID
WHERE 
    orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    suppliers.SupplierID, 
    suppliers.CompanyName
""""""

lead_time_data = execute_sql_query(sql_query)

fig = px.bar(lead_time_data, x='CompanyName', y='AverageLeadTime', 
             title='Average Lead Time by Supplier (Past Year)', 
             labels={'AverageLeadTime': 'Average Lead Time (days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code differs from the reference in joining on a non-existent table '[Order Details]'. Instead of 'orders.ProductID', the reference code correctly joins 'products.ProductID' with 'orders.ProductID'. The input code's join on '[Order Details].ProductID' is an error that will cause it to fail unless '[Order Details]' is defined elsewhere.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average lead time for each supplier over the past year
sql_query = """"""
SELECT p.SupplierID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= DATEADD(year, -1, CURRENT_DATE)
GROUP BY p.SupplierID;
""""""

# Function to get data using the utility function
def get_average_lead_time():
    # Execute the query
    df = execute_sql_query(sql_query)
    return df

# Function to visualize lead times
def visualize_lead_times(df):
    # Create a bar chart
    fig = px.bar(df, x='SupplierID', y='AverageLeadTime',
                 title='Average Lead Time for Each Supplier Over the Past Year',
                 labels={'AverageLeadTime': 'Average Lead Time (Days)', 'SupplierID': 'Supplier ID'})
    show_to_user(fig)

# Main execution
if __name__ == ""__main__"":
    # Get the average lead time data
    df = get_average_lead_time()
    
    # Visualize the lead times using a bar chart
    visualize_lead_times(df)
```","The input code's SQL query uses a different join structure and table - it joins 'products' with 'Order Details' and then 'orders' instead of joining 'suppliers' with 'products' and then 'orders' directly as in the reference code. This leads to the use of a different field for 'SupplierID'. Furthermore, it's possible that 'Order Details' is an intermediary table not intended to affect the primary analysis, which is based on 'suppliers'. Additionally, the WHERE clause uses 'DATEADD(year, -1, CURRENT_DATE)' instead of 'BETWEEN CURDATE() - INTERVAL 1 YEAR AND CURDATE()', which might affect the date range logic, depending on the SQL dialect. These differences could affect the correctness of the business logic intended for analyzing supplier lead times.",None
"Which employee has the most orders completed in a given month, and can we visualize this data with a bar chart to compare order completion among employees?","```python
import plotly.express as px

# Define the SQL query to get the count of orders for each employee in June 2023
sql_query = """"""
SELECT orders.EmployeeID, COUNT(orders.OrderID) AS OrderCount 
FROM orders 
WHERE MONTH(orders.OrderDate) = 6 AND YEAR(orders.OrderDate) = 2023 
GROUP BY orders.EmployeeID 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Find the employee with the most orders completed
if not order_data.empty:
    top_employee = order_data.iloc[0]
    # Print the employee with the most orders
    print(f""Employee with the most orders completed: EmployeeID {top_employee['EmployeeID']}, Orders: {top_employee['OrderCount']}"")
else:
    print(""No orders found for June 2023."")

# Create a bar chart to visualize order completion among employees
fig = px.bar(order_data, x='EmployeeID', y='OrderCount', title='Order Completion by Employee in June 2023')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the month and year for analysis
month = '2023-09'  # Adjust as needed

# SQL query to get completed orders by employee for the given month
sql_query = f""""""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    COUNT(o.OrderID) AS OrdersCompleted
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
WHERE 
    DATE_FORMAT(o.OrderDate, '%Y-%m') = '{month}'
GROUP BY 
    e.EmployeeID
ORDER BY 
    OrdersCompleted DESC
LIMIT 1
""""""

# Execute the SQL query to retrieve data
top_employee_df = execute_sql_query(sql_query)

# Query to get all employee order counts for visualization
sql_query_all = f""""""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    COUNT(o.OrderID) AS OrdersCompleted
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
WHERE 
    DATE_FORMAT(o.OrderDate, '%Y-%m') = '{month}'
GROUP BY 
    e.EmployeeID
""""""

# Execute the SQL query to retrieve all employees' data
all_employees_df = execute_sql_query(sql_query_all)

# Visualization for order completion comparison
fig = px.bar(all_employees_df, x='EmployeeName', y='OrdersCompleted', 
              title='Order Completion Comparison Among Employees for September 2023',
              labels={'EmployeeName': 'Employee Name', 'OrdersCompleted': 'Orders Completed'})

# Show the top employee and the bar chart to the user
show_to_user(top_employee_df)
show_to_user(fig)
```","The input code correctly retrieves the employee with the most orders completed in a specific month and uses SQL queries and pandas for data manipulation. It also uses Plotly Express to visualize the data with a bar chart, comparing order completion among employees, which aligns with the business analytics request. Despite minor differences (e.g., inclusion of employee names, slightly different SQL query format), the logic is consistent with the reference implementation: retrieve order data, identify the top employee, and visualize the results using a bar chart.","```python
import pandas as pd
import plotly.express as px

# Given SQL query to fetch the required data
sql_query = """"""
SELECT employees.FirstName, employees.LastName, COUNT(orders.OrderID) AS orders_completed 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE MONTH(orders.OrderDate) = ? AND YEAR(orders.OrderDate) = ? 
GROUP BY employees.EmployeeID 
ORDER BY orders_completed DESC
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str, params: tuple) -> pd.DataFrame:
    # This function would execute the SQL query and return a pandas DataFrame.
    # It's a placeholder for the actual implementation.
    pass

# Fetch the current month and year
current_month, current_year = 10, 2023  # Example month and year, replace with actual extraction logic

# Execute the SQL query with the current month and year parameters
params = (current_month, current_year)
df = execute_sql_query(sql_query, params)

# Select the employee with the most orders completed
top_employee = df.iloc[0]

# Display the top employee
show_to_user(pd.DataFrame([top_employee]))

# Visualize the order completion data with a bar chart
fig = px.bar(
    df,
    x='FirstName',
    y='orders_completed',
    text='orders_completed',
    title=f""Order Completion by Employee - {current_month}/{current_year}"",
    labels={'FirstName': 'Employee Name', 'orders_completed': 'Orders Completed'},
    hover_data={'FirstName': df['FirstName'] + ' ' + df['LastName']}
)
fig.update_traces(textposition='outside')

# Display the bar chart
show_to_user(fig)
```","The input code differs from the reference in key aspects: It selects columns from both employees and orders instead of only from orders, differs in SQL parameters (dynamic month/year), and visualizes data with different x labels (FirstName vs EmployeeID). The logic and querying approach are not completely aligned with the reference implementation.",Base
Find the maximum reorder level for products from each supplier and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SupplierID, MAX(ReorderLevel) AS MaxReorderLevel 
FROM products 
GROUP BY SupplierID;
""""""

# Execute the SQL query and fetch data into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='MaxReorderLevel', 
             title='Maximum Reorder Level by Supplier',
             labels={'SupplierID': 'Supplier ID', 'MaxReorderLevel': 'Max Reorder Level'})

# Display the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT SupplierID, MAX(ReorderLevel) AS MaxReorderLevel
FROM products
GROUP BY SupplierID
""""""

max_reorder_level_df = execute_sql_query(sql_query)

fig = px.bar(max_reorder_level_df, x='SupplierID', y='MaxReorderLevel', 
              title='Maximum Reorder Level by Supplier',
              labels={'SupplierID': 'Supplier ID', 'MaxReorderLevel': 'Max Reorder Level'})

show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It executes a SQL query to find the maximum reorder level for products from each supplier, groups by SupplierID, and visualizes the results using a bar chart with Plotly. The logic and steps match the reference implementation, ensuring the request is accurately addressed.","```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = """"""
SELECT p.SupplierID, MAX(p.ReorderLevel) AS MaxReorderLevel
FROM products p
GROUP BY p.SupplierID;
""""""

# Step 2: Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Step 3: Visualize the results using a bar chart
fig = px.bar(data, x='SupplierID', y='MaxReorderLevel', 
             title='Maximum Reorder Level by Supplier', 
             labels={'SupplierID': 'Supplier ID', 'MaxReorderLevel': 'Maximum Reorder Level'})

# Step 4: Display the plot
show_to_user(fig)
```","The input code correctly implements the business analytics request. It defines and executes an SQL query to find the maximum reorder level for products from each supplier, groups the results by SupplierID, and creates a bar chart using Plotly to visualize the results. The procedure and logic align with the reference implementation, although variable names and some minor syntax are slightly different. Both codes produce the same output as per the requirement.",both
Which shipping company was used the most in the previous quarter? Please include a bar chart to visualize the usage frequency of each company.,"```python
import pandas as pd
import plotly.express as px

# Define SQL query to get usage frequency of each shipping company in the previous quarter
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount 
FROM orders 
WHERE (
    (QUARTER(OrderDate) = QUARTER(CURDATE()) - 1 AND YEAR(OrderDate) = YEAR(CURDATE())) 
    OR 
    (QUARTER(CURDATE()) = 1 AND YEAR(OrderDate) = YEAR(CURDATE()) - 1
)) 
GROUP BY ShipVia 
ORDER BY UsageCount DESC;
""""""

# Execute SQL query and get results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the shipping company usage frequency
fig = px.bar(df, x='ShipVia', y='UsageCount', title='Shipping Company Usage Frequency in Previous Quarter')

# Display the bar chart to the user
show_to_user(fig)

# Determine the most used shipping company
most_used_company = df.iloc[0]['ShipVia']
show_to_user(pd.DataFrame({'Most Used Shipping Company': [most_used_company]}))
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the start and end date of the previous quarter
today = datetime.today()
first_day_of_current_quarter = (today - pd.offsets.QuarterBegin()).date()
last_day_of_previous_quarter = first_day_of_current_quarter - timedelta(days=1)
first_day_of_previous_quarter = (last_day_of_previous_quarter - pd.offsets.QuarterEnd()).date()

# SQL query to get the shipping company usage in the previous quarter
sql_query = f""""""
SELECT ShipVia, COUNT(*) AS usage_count
FROM orders
WHERE OrderDate >= '{first_day_of_previous_quarter}' AND OrderDate <= '{last_day_of_previous_quarter}'
GROUP BY ShipVia
ORDER BY usage_count DESC
""""""

# Execute the SQL query and retrieve the data
df_shipping_usage = execute_sql_query(sql_query)

# Visualization
fig = px.bar(df_shipping_usage, x='ShipVia', y='usage_count', title='Shipping Company Usage in Previous Quarter',
             labels={'ShipVia': 'Shipping Company', 'usage_count': 'Usage Count'})
show_to_user(fig)
```","The provided Python code accurately determines the usage frequency of shipping companies in the previous quarter and visualizes the results in a bar chart. The logic for calculating the dates of the previous quarter, querying the shipping data, and generating the bar chart matches the intent of the reference implementation. Both implementations use SQL to fetch data on shipping usage, group and count the data by 'ShipVia', order by usage count, and use Plotly to create a bar chart. Differences in SQL syntax (e.g., handling of quarter calculations) do not affect the correctness relative to the requested business question.","```python
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT shippers.CompanyName, COUNT(orders.OrderID) AS usage_count 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE QUARTER(orders.OrderDate) = QUARTER(CURDATE()) - 1 
AND YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY shippers.CompanyName 
ORDER BY usage_count DESC;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize usage frequency of each shipping company
fig = px.bar(df, x='CompanyName', y='usage_count', title='Shipping Company Usage in Previous Quarter')

# Display the bar chart to the user
show_to_user(fig)
```","The input code does not fully address the business analytics request because it does not handle cases where the previous quarter is in the previous year, such as when the current quarter is Q1. This is inconsistent with the reference implementation, which accounts for the transition between years.",Base
Which employee handled the most on-time deliveries in the last year? Please include a bar chart to visualize the number of on-time deliveries per employee.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OnTimeDeliveries 
FROM orders 
WHERE ShippedDate <= RequiredDate 
AND YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY EmployeeID 
ORDER BY OnTimeDeliveries DESC;
""""""

# Execute the SQL query and fetch the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='OnTimeDeliveries', 
             title='On-Time Deliveries per Employee (Last Year)',
             labels={'OnTimeDeliveries': 'Number of On-Time Deliveries', 'EmployeeID': 'Employee ID'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch on-time deliveries grouped by EmployeeID for the last year
sql_query = """"""
SELECT 
    EmployeeID, 
    COUNT(OrderID) AS OnTimeDeliveries
FROM 
    orders
WHERE 
    ShippedDate <= RequiredDate 
    AND ShippedDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    EmployeeID
ORDER BY 
    OnTimeDeliveries DESC
""""""

# Execute the SQL query
on_time_deliveries = execute_sql_query(sql_query)

# Identify the employee with the most on-time deliveries
top_employee = on_time_deliveries.iloc[0]

# Create a bar chart for the number of on-time deliveries per employee
fig = px.bar(on_time_deliveries, x='EmployeeID', y='OnTimeDeliveries', 
             title='On-Time Deliveries per Employee', 
             labels={'OnTimeDeliveries': 'Number of On-Time Deliveries', 'EmployeeID': 'Employee ID'})

# Show the results to the user
show_to_user(fig)

top_employee
```","The input code uses `ShippedDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)` to filter the last year, which includes arbitrary dates over the past 365 days from today, while the reference uses `YEAR(OrderDate) = YEAR(CURDATE()) - 1` to focus on the previous calendar year. This difference in date filtering doesn't align with the business request for 'last year'.","```python
import pandas as pd
import plotly.express as px

# SQL query as given
sql_query = """"""
SELECT employees.EmployeeID, 
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) AS OnTimeDeliveries 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.OrderDate > DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY employees.EmployeeID 
ORDER BY OnTimeDeliveries DESC
""""""

# Execute the SQL query and get the results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should implement the logic to connect to your database, execute the given SQL query,
    # and return the result as a pandas DataFrame. 
    # This is a placeholder implementation.
    pass

# Placeholder function to visualize results using Plotly
def show_to_user(data):
    # This function should implement the logic to display the data using whichever
    # method is appropriate (printing for DataFrame, or showing for Plotly).
    pass

# Fetch the data using the provided SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of on-time deliveries per employee
fig = px.bar(data, x='EmployeeID', y='OnTimeDeliveries', title='On-Time Deliveries by Employee')

# Display the bar chart
show_to_user(fig)
```","The input code checks for deliveries within the last 365 days using 'OrderDate > DATE_SUB(CURDATE(), INTERVAL 1 YEAR)', which differs from the reference code's approach of targeting the last calendar year with 'YEAR(OrderDate) = YEAR(CURDATE()) - 1'. This could lead to different sets of data being queried. Additionally, the SQL logic in the input code includes a CASE WHEN structure which is not necessary as the filter condition belongs in the WHERE clause, as done in the reference code.",None
"How many employees were hired before 2000? Additionally, provide a line graph showing the hiring trends over the years.","```python
import pandas as pd
import plotly.express as px

# Utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to execute the SQL query and return the results as a DataFrame
    pass

def show_to_user(data):
    # This function displays the provided data, either as a DataFrame or Plotly figure
    pass

# SQL query to count employees hired before 2000
query_pre_2000 = ""SELECT COUNT(*) as count FROM employees WHERE HireDate < '2000-01-01';""
pre_2000_df = execute_sql_query(query_pre_2000)
show_to_user(pre_2000_df)

# SQL query to get hiring trends over the years
query_hiring_trends = """"""
SELECT YEAR(HireDate) as Year, COUNT(*) as NumHires 
FROM employees 
GROUP BY YEAR(HireDate)
ORDER BY Year;
""""""
hiring_trends_df = execute_sql_query(query_hiring_trends)

# Create a line graph for hiring trends
fig = px.line(hiring_trends_df, x='Year', y='NumHires', title='Hiring Trends Over the Years')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to find number of employees hired before the year 2000
count_query = ""SELECT COUNT(*) AS EmployeeCount FROM employees WHERE HireDate < '2000-01-01'""
employee_count_df = execute_sql_query(count_query)

# Query to get hiring trends over the years
trends_query = """"""
SELECT YEAR(HireDate) AS Year, COUNT(*) AS Hires
FROM employees
GROUP BY Year
ORDER BY Year
""""""
hiring_trends_df = execute_sql_query(trends_query)

# Create line graph for hiring trends
fig = px.line(hiring_trends_df, x='Year', y='Hires', title='Hiring Trends Over the Years')

# Show results to user
show_to_user(employee_count_df)
show_to_user(fig)
```","The input code correctly fulfills the business analytics request following the same logic as the reference implementation. It executes a SQL query to count the employees hired before 2000, stores the result in 'employee_count_df', and captures it using 'show_to_user'. Additionally, it executes another SQL query to obtain the hiring trends over the years, creates a line graph using Plotly Express, and displays it. The structure and logic align with the reference implementation, even though variable names differ slightly.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    pass

def show_to_user(data):
    # Placeholder function for displaying data
    pass

# SQL query to count employees hired before 2000
sql_count_query = ""SELECT COUNT(*) AS EmployeesHiredBefore2000 FROM employees WHERE HireDate < '2000-01-01';""
count_df = execute_sql_query(sql_count_query)
show_to_user(count_df)

# SQL query to get hiring trends over the years
sql_trend_query = """"""
SELECT 
    EXTRACT(YEAR FROM HireDate) AS HireYear, 
    COUNT(*) AS EmployeeCount 
FROM 
    employees 
GROUP BY 
    HireYear 
ORDER BY 
    HireYear;
""""""
trend_df = execute_sql_query(sql_trend_query)

# Generate line graph using Plotly
fig = px.line(trend_df, x='HireYear', y='EmployeeCount', title='Hiring Trends Over the Years')
show_to_user(fig)
```","The input code correctly answers the business analytics request by querying the number of employees hired before 2000 and generating a line graph for hiring trends. It uses appropriate SQL queries for both tasks, extracts the year from the HireDate, and uses Plotly to create the graph. The logic is consistent with the reference implementation.",both
"Which employees have a higher average order value than their direct manager, and how can we visualize this comparison effectively?","```python
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str):
    # Placeholder for SQL query execution
    pass

def show_to_user(data):
    # Placeholder for data display function
    pass

# SQL query to identify employees with higher average order value than their manager
sql_query = """"""
SELECT a.EmployeeID, AVG(c.UnitPrice * c.Quantity * (1 - c.Discount)) AS EmployeeAvgOrderValue, d.EmployeeID AS ManagerID
FROM employees a 
JOIN orders b ON a.EmployeeID = b.EmployeeID 
JOIN [Order Details] c ON b.OrderID = c.OrderID 
JOIN employees d ON a.ReportsTo = d.EmployeeID 
GROUP BY a.EmployeeID, d.EmployeeID 
HAVING AVG(c.UnitPrice * c.Quantity * (1 - c.Discount)) > 
(SELECT AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) 
 FROM orders o 
 JOIN [Order Details] od ON o.OrderID = od.OrderID 
 WHERE o.EmployeeID = d.EmployeeID);
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualize the comparison using bar chart
fig = px.bar(result_df, x='EmployeeID', y='EmployeeAvgOrderValue',
             title='Employees with Higher Average Order Value than Their Manager',
             labels={'EmployeeID': 'Employee ID', 'EmployeeAvgOrderValue': 'Average Order Value'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve average order values for employees and their managers
sql_query = """"""
SELECT 
    e.EmployeeID AS EmployeeID,
    e.FirstName AS EmployeeFirstName,
    e.LastName AS EmployeeLastName,
    m.EmployeeID AS ManagerID,
    m.FirstName AS ManagerFirstName,
    m.LastName AS ManagerLastName,
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AvgOrderValue
FROM 
    employees e
LEFT JOIN
    orders o ON e.EmployeeID = o.EmployeeID
LEFT JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
LEFT JOIN 
    employees m ON e.ReportsTo = m.EmployeeID
GROUP BY 
    e.EmployeeID, m.EmployeeID
""""""

employee_avg_values = execute_sql_query(sql_query)

# Step 2: Identify employees with higher average order values than their managers
comparison_df = employee_avg_values.copy()
comparison_df['ManagerAvgOrderValue'] = comparison_df.groupby('ManagerID')['AvgOrderValue'].transform('mean')
higher_performers = comparison_df[comparison_df['AvgOrderValue'] > comparison_df['ManagerAvgOrderValue']]

# Step 3: Visualize the comparison
fig = px.bar(higher_performers,
             x='EmployeeFirstName',
             y='AvgOrderValue',
             color='ManagerFirstName',
             title='Employees with Higher Average Order Value than Their Managers',
             labels={'AvgOrderValue': 'Average Order Value', 'EmployeeFirstName': 'Employee'},
             barmode='group')

show_to_user(fig)
```","The input Python code achieves the same goal as the reference implementation: it identifies employees who have a higher average order value than their managers. It uses a SQL query to retrieve the average order values and then compares employees' order values directly with the average values of their managers. While the implementation details differ, such as using `LEFT JOIN` and `transform` for comparison, the logic and outcome align with the business analytics request and reference implementation.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy placeholder function to simulate SQL execution
    # Replace with actual logic to interact with the database
    return pd.DataFrame()

# Utility function for showing results
def show_to_user(data):
    # Dummy placeholder function to simulate result display
    # Replace with actual logic to display data
    pass

# SQL to fetch employees and their managers' average order values
sql_query = """"""
SELECT emp1.EmployeeID, emp1.FirstName, emp1.LastName,
    emp2.FirstName as ManagerFirstName, emp2.LastName as ManagerLastName,
    emp1.AVGOrderValue, emp2.AVGOrderValue as ManagerAVGOrderValue
FROM (
    SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
        AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AVGOrderValue
    FROM employees
    JOIN orders ON employees.EmployeeID = orders.EmployeeID
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
    GROUP BY employees.EmployeeID
) emp1
JOIN (
    SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
        AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AVGOrderValue
    FROM employees
    JOIN orders ON employees.EmployeeID = orders.EmployeeID
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
    GROUP BY employees.EmployeeID
) emp2
ON emp1.ManagerID = emp2.EmployeeID
WHERE emp1.AVGOrderValue > emp2.AVGOrderValue
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Visualize the comparison using a bar plot
fig = px.bar(
    df,
    x='EmployeeID',
    y=['AVGOrderValue', 'ManagerAVGOrderValue'],
    labels={'value': 'Average Order Value', 'variable': 'Role'},
    title='Comparison of Average Order Values: Employees vs. Managers'
)

# Display the visualization to the user
show_to_user(fig)
```","The input code is incorrect for the following reasons: 1) The inner SQL subqueries reference 'ManagerID', which is not available because it's not selected or joined correctly. 2) The SQL logic differs from the reference implementation since the subqueries define a self-join that is not needed. 3) The input code uses the same structure for employee and manager subqueries, which leads to a mismatch in understanding which employees report to which managers, contrary to the request. The reference implementation correctly calculates average order values and compares them between employees and their direct managers.",Base
What is the average units in stock per product category? Please include a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# Predefined utility functions (not implemented here)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to execute the SQL query and return a DataFrame
    pass

def show_to_user(data):
    # This function is assumed to display a DataFrame or Plotly figure
    pass

# SQL query to get the average units in stock per product category
sql_query = """"""
SELECT CategoryID, AVG(UnitsInStock) AS AvgUnitsInStock
FROM products
GROUP BY CategoryID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(df, x='CategoryID', y='AvgUnitsInStock', title='Average Units in Stock per Product Category')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
    SELECT p.CategoryID, AVG(p.UnitsInStock) AS AvgUnitsInStock
    FROM products p
    JOIN categories c ON p.CategoryID = c.CategoryID
    GROUP BY p.CategoryID
""""""

average_units_df = execute_sql_query(sql_query)

fig = px.bar(average_units_df, x='CategoryID', y='AvgUnitsInStock', 
             title='Average Units in Stock per Product Category', 
             labels={'CategoryID': 'Product Category ID', 'AvgUnitsInStock': 'Average Units in Stock'})

show_to_user(fig)
```","The evaluated code correctly implements the business analytics request. It calculates the average units in stock per product category using a SQL query with a JOIN to include category information. Although it includes an unnecessary JOIN with the categories table (assuming CategoryID is already in products), it does not affect the correctness. The visualization with Plotly Express matches the requirements, effectively displaying a bar chart with the same parameters as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the data
sql_query = """"""
SELECT CategoryName, AVG(UnitsInStock) AS AverageUnitsInStock
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY CategoryName;
""""""
# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation, replace with actual database connection and execution
    # Example: using SQLAlchemy and pandas to read SQL query into DataFrame
    return pd.read_sql_query(sql_query, connection)

# Execute the SQL query to get categories and average units in stock
df_avg_units = execute_sql_query(sql_query)

# Create a bar chart to visualize average units in stock per product category
fig = px.bar(df_avg_units, x='CategoryName', y='AverageUnitsInStock',
             title='Average Units in Stock per Product Category',
             labels={'AverageUnitsInStock': 'Average Units in Stock'},
             template='plotly')

# Function to show the visualization
def show_to_user(data):
    # Assumes data is a Plotly Figure
    data.show()

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates the average units in stock per product category and visualizes it with a bar chart. It uses 'CategoryName' instead of 'CategoryID', which is a valid approach as it joins with the categories table. Both implementations fulfill the business analytics request, answering the question using consistent logic.",both
"Which shipping methods are most frequently used, and can we visualize the frequency using a bar chart?","
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT o.ShipVia, COUNT(o.OrderID) AS UseCount 
FROM orders o 
GROUP BY o.ShipVia 
ORDER BY UseCount DESC;
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the frequency of shipping methods
fig = px.bar(df, x='ShipVia', y='UseCount', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'UseCount': 'Usage Count'})

# Display the figure using the utility function
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
""""""

shipping_methods_df = execute_sql_query(sql_query)

fig = px.bar(shipping_methods_df, x='ShipVia', y='Frequency',
             title='Frequency of Shipping Methods',
             labels={'ShipVia': 'Shipping Method', 'Frequency': 'Frequency Count'})

show_to_user(fig)
```","The provided code correctly implements the requested analysis. It executes an SQL query that counts the frequency of each shipping method and orders the results by frequency in descending order, exactly as required. The code then uses Plotly to create a bar chart with the shipping methods on the x-axis and their frequency counts on the y-axis, similarly to the reference implementation. Both codes achieve the same functionality and logic, despite minor differences in variable names and labels.","```python
import plotly.express as px

# Execute the SQL query and get the data as a pandas DataFrame
data = execute_sql_query(""SELECT ShipVia, COUNT(OrderID) AS Frequency FROM orders GROUP BY ShipVia ORDER BY Frequency DESC;"")

# Visualizing the data using a bar chart
fig = px.bar(data, x='ShipVia', y='Frequency', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'Frequency': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)
```","The input code accurately fulfills the business analytics request to determine the most frequently used shipping methods and visualizes the results using a bar chart. It replicates the reference implementation's logic by executing a similar SQL query to group and count the occurrences of each ShipVia, ordering them in descending order. It then visualizes the data with Plotly Express, analogous to the reference implementation. The differences in variable names ('Frequency' vs 'UseCount') and labels do not affect the functionality or correctness of the code.",both
Find the supplier with the largest revenue from sales and create a bar chart to visualize the revenue comparison among top suppliers.,"```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function body for the purpose of this task
    # Replace with actual database connection logic
    data = {
        'SupplierID': [1, 2, 3, 4, 5],
        'TotalRevenue': [50000, 75000, 32000, 42000, 60000]
    }
    return pd.DataFrame(data)

# Function to display data
def show_to_user(data):
    # Simulated function body for the purpose of this task
    # In practice, use Plotly's visualization display capabilities
    print(data)

# SQL query to find supplier revenues
sql_query = """"""
SELECT products.SupplierID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID 
ORDER BY TotalRevenue DESC;
""""""

# Execute the query and get the results into a DataFrame
df = execute_sql_query(sql_query)

# Extract top suppliers (optional sorting as it's sorted in SQL)
top_suppliers_df = df  # Already sorted by SQL query

# Create a bar chart to visualize the revenue comparison among top suppliers
fig = px.bar(top_suppliers_df, x='SupplierID', y='TotalRevenue', title='Revenue Comparison Among Top Suppliers')

# Display the figure using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.CompanyName
ORDER BY TotalRevenue DESC
LIMIT 10
""""""

top_suppliers_df = execute_sql_query(sql_query)

fig = px.bar(top_suppliers_df, x='CompanyName', y='TotalRevenue', title='Top 10 Suppliers by Revenue', labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code follows the same logic as the reference code: querying suppliers' revenues, organizing, and visualizing them in a bar chart. It uses similar operations (SQL joins, aggregations, ordering by revenue) and achieves the same business goal—identifying top suppliers by revenue and displaying the results. Both involve the same data retrieval and visualization approach. It additionally limits the results to the top 10, which doesn't conflict with the goal.","```python
import pandas as pd
import plotly.express as px

# SQL query to find the supplier with the largest revenue
sql_query_top_supplier = """"""
SELECT suppliers.SupplierID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID 
ORDER BY TotalRevenue DESC 
LIMIT 1;
""""""

# SQL query to get revenue comparison among top suppliers
sql_query_top_suppliers = """"""
SELECT suppliers.SupplierID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID 
ORDER BY TotalRevenue DESC 
LIMIT 10;  # Adjust the number of suppliers as needed
""""""

# Execute the SQL query for top suppliers
top_suppliers_df = execute_sql_query(sql_query_top_suppliers)

# Generate a bar chart for revenue comparison among top suppliers
fig = px.bar(top_suppliers_df, x='SupplierID', y='TotalRevenue', 
             title='Top Suppliers by Revenue')

# Use the utility function to display the bar chart
show_to_user(fig)
```","The input code correctly implements the requirement to find the top suppliers by revenue and create a bar chart for revenue comparisons. The input code uses SQL queries to retrieve the necessary data sorted by total revenue (with a LIMIT clause for a specific number of suppliers), which adheres to the logic of the reference code. Although the input code introduces a query to fetch the top supplier separately, this is not detrimental to the task and can be considered optional enrichment. The visualization using Plotly is consistent with the requirement, fulfilling the request to visualize the top suppliers' revenue, which makes the input correct.",both
Determine the products that have not been sold at all and represent them in a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
    SELECT p.ProductID, p.ProductName 
    FROM products p 
    LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
    WHERE od.ProductID IS NULL;
'''

# Execute the SQL query and retrieve data as a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(products_df, x='ProductName', y='ProductID', title='Unsold Products')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have not been sold
sql_query = """"""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL
""""""

# Execute the SQL query and retrieve the data
unsold_products_df = execute_sql_query(sql_query)

# Count the number of unsold products
unsold_products_count = unsold_products_df['ProductName'].value_counts()

# Create a bar chart
fig = px.bar(unsold_products_df, x='ProductName', y=unsold_products_count, title='Unsold Products')

# Show the chart to the user
show_to_user(fig)
```","The input code incorrectly attempts to use 'value_counts()' for the y-axis data but passes the entire series, 'unsold_products_count', to the bar chart. The y parameter in 'px.bar' expects a column name from the DataFrame instead of a Series. The input code should directly specify 'y='ProductID'' since the product count is inherent from the DataFrame created from the SQL query. The reference implementation correctly constructs the bar chart by mapping 'ProductID' to the y-axis without performing additional calculations on product counts, directly visualizing all unsold products.","```python
import plotly.express as px
import pandas as pd

# SQL query to find products never sold
sql_query = """"""
SELECT p.ProductID, p.ProductName 
FROM products p 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.ProductID IS NULL;
""""""

# Execute the SQL query
unsold_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    unsold_products_df,
    x='ProductName',
    y='ProductID',
    title='Products Not Sold At All',
    labels={'ProductName': 'Product Name', 'ProductID': 'Product ID'}
)

# Display the bar chart
show_to_user(fig)
```","The input code successfully identifies products that have not been sold by executing an SQL query identical to the one in the reference implementation. It then creates a bar chart using Plotly, similar to the reference code. The code also uses appropriate labels for the chart axes, but this does not affect the correctness of the logic or output. Finally, it displays the bar chart, satisfying the business analytics request.",Finetuned
"What is the percentage of orders delivered on time each month, and can this be visualized in a line chart to show trends over time?","```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query is defined elsewhere
# Assuming show_to_user is defined elsewhere

def analyze_on_time_delivery():
    sql_query = """"""
    SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
           100.0 * COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) AS OnTimeDeliveryRate
    FROM orders
    GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
    """"""
    
    # Execute the SQL query and get the result as a DataFrame
    df = execute_sql_query(sql_query)

    # Plot the results using Plotly
    fig = px.line(df, x='Month', y='OnTimeDeliveryRate', title='On-Time Delivery Rate by Month', labels={
        'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)',
        'Month': 'Month'
    })

    # Show the plot
    show_to_user(fig)

# Call the function to perform the analysis and visualization
analyze_on_time_delivery()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Calculate percentage of on-time deliveries
order_data['OnTimePercentage'] = (order_data['OnTimeDeliveries'] / order_data['TotalOrders']) * 100

# Create a line chart for on-time delivery percentage
fig = px.line(order_data, x='Month', y='OnTimePercentage', title='On-time Delivery Percentage per Month', labels={'OnTimePercentage':'On-time Delivery Percentage (%)'})
show_to_user(fig)
```","The input code correctly calculates the percentage of on-time deliveries per month by dividing the count of on-time deliveries by the total orders and multiplying by 100, which is consistent with the reference implementation. Both codes execute a SQL query to aggregate data on a monthly basis and use Plotly to create a line chart displaying the trend over time. The logic between both implementations is similar, ensuring that the business analytics request is properly addressed.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the data
sql_query = """"""
SELECT DATE_TRUNC('month', orders.OrderDate) AS Month,
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 100.0 / COUNT(*) AS OnTimeDeliveryRate
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query using the utility function
data = execute_sql_query(sql_query)

# Ensure the Month is in datetime format for proper plotting
data['Month'] = pd.to_datetime(data['Month'])

# Create a line chart using Plotly to visualize the percentage of orders delivered on time each month
fig = px.line(data, x='Month', y='OnTimeDeliveryRate', title='Monthly On-Time Delivery Rate',
              labels={'OnTimeDeliveryRate': 'On-Time Delivery (%)', 'Month': 'Month'})

# Show the visualization to the user 
show_to_user(fig)
```","Both code implementations aim to calculate the monthly on-time delivery rate and visualize it using a line chart. The input code calculates the delivery percentage in the SQL statement similarly to the reference code and ensures the 'Month' is in datetime format for correct plotting. While there are slight differences in SQL syntax (DATE_TRUNC vs DATE_FORMAT), the logic remains consistent. Both use Plotly for visualization and label the chart appropriately.",both
What is the total number of units on order for each product category? Include a bar chart to visualize the data.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CategoryID, SUM(UnitsOnOrder) AS TotalUnitsOnOrder 
FROM products 
GROUP BY CategoryID;
""""""

# Execute the query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='TotalUnitsOnOrder', title='Total Units On Order by Product Category')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(p.UnitsOnOrder) AS TotalUnitsOnOrder
FROM products p
GROUP BY p.CategoryID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CategoryID', y='TotalUnitsOnOrder', title='Total Units on Order by Product Category')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It performs the same SQL query to sum the UnitsOnOrder for each CategoryID and correctly groups by the CategoryID, adhering to the logic of the reference code. It also uses Plotly to create a bar chart with the same parameters. Although variable names differ slightly, the logic and outcome match the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total units on order for each product category
sql_query = """"""
SELECT PC.CategoryID, SUM(P.UnitsOnOrder) AS TotalUnitsOnOrder
FROM ProductCategory PC
JOIN products P ON PC.CategoryID = P.CategoryID
GROUP BY PC.CategoryID;
""""""

# Function to execute SQL query and return a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total units on order for each product category
fig = px.bar(df, x='CategoryID', y='TotalUnitsOnOrder', title='Total Units On Order by Product Category',
             labels={'CategoryID': 'Product Category', 'TotalUnitsOnOrder': 'Total Units On Order'})

# Display the bar chart to the user
show_to_user(fig)
```","Both implementations calculate the total units on order for each product category. The input code achieves this by joining the ProductCategory and products tables, which is an additional step compared to the reference code. However, the join operation does not affect the correctness of the logic as it retains the same group by CategoryID to sum the UnitsOnOrder. The data visualization is correctly implemented using Plotly in both codes and displays the total units on order for each category. Therefore, the input code correctly answers the business analytics request following the logic of the reference code.",both
"What is the total freight cost for each shipping method, and can you provide a bar chart visualization to illustrate the comparison?","```python
import pandas as pd
import plotly.express as px

# Example utility function implementations
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation for context
    # In reality, this would interface with a database to execute the provided SQL query.
    pass

def show_to_user(data):
    # Placeholder implementation for context
    # This would display the DataFrame or Plotly figure to the user.
    pass

# SQL Query that needs to be executed
sql_query = ""SELECT ShipVia, SUM(Freight) AS TotalFreightCost FROM orders GROUP BY ShipVia""

# Execute the SQL query to get a pandas DataFrame
data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data_df, x='ShipVia', y='TotalFreightCost', title='Total Freight Cost by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'TotalFreightCost': 'Total Freight Cost'})

# Show the resulting plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipVia
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipVia', y='TotalFreight', title='Total Freight Cost by Shipping Method', labels={'ShipVia': 'Shipping Method', 'TotalFreight': 'Total Freight Cost'})
show_to_user(fig)
```","The input Python code correctly executes an SQL query that groups the data by 'ShipVia' and sums the 'Freight', similar to the reference implementation. It then creates a bar chart with appropriate labels and titles using Plotly. The overall logic and purpose align with the reference code, fulfilling the business analytics request to visualize total freight cost by shipping method.","```python
import pandas as pd
import plotly.express as px  

# SQL Query
sql_query = """"""
SELECT o.ShipVia, SUM(o.Freight) AS TotalFreight 
FROM orders o 
GROUP BY o.ShipVia;
""""""

# Execute the SQL query and fetch the results
df = execute_sql_query(sql_query)

# Create a bar chart to compare total freight cost for each shipping method
fig = px.bar(df, x='ShipVia', y='TotalFreight', 
             title='Total Freight Cost by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'TotalFreight': 'Total Freight Cost'})

# Display the bar chart
show_to_user(fig)
```","The input code executes a similar SQL query to the reference implementation, aggregating the 'Freight' cost by 'ShipVia' from the 'orders' table. Both codes create a Plotly bar chart using the results, with appropriate labels and titles. The only differences are minor, such as the SQL query format and variable names, which do not affect the correctness.",both
What is the average discount provided across all products? Please include a histogram to visualize the distribution of discounts.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get discount data
sql_query = ""SELECT Discount FROM [Order Details];""

# Execute SQL query and fetch the data
discount_data = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = discount_data['Discount'].mean()

# Display the average discount
result_df = pd.DataFrame({'Average Discount': [average_discount]})
show_to_user(result_df)

# Create a histogram to visualize the distribution of discounts
fig = px.histogram(discount_data, x='Discount', title='Distribution of Discounts', labels={'Discount': 'Discount Rate'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Discount
FROM [Order Details]
""""""
discounts_df = execute_sql_query(sql_query)

average_discount = discounts_df['Discount'].mean()

fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts')
show_to_user(fig)

average_discount
```","The input Python code correctly calculates the average discount by taking the mean of the 'Discount' column in the retrieved DataFrame. It then uses Plotly Express to generate a histogram of the discounts. The logic matches the reference implementation: executing a SQL query to select discounts, calculating the average, and displaying a histogram. Both implementations fulfill the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to retrieve discount data
sql_query = ""SELECT Discount FROM [Order Details];""
discounts_df = execute_sql_query(sql_query)

# Calculate the average discount using pandas
average_discount = discounts_df['Discount'].mean()

# Display the average discount to the user
show_to_user(pd.DataFrame({'Average Discount': [average_discount]}))

# Create a histogram to visualize the distribution of discounts
fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts', nbins=20)

# Show the histogram to the user
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation, addressing the business request to calculate the average discount and visualize the distribution with a histogram. Both snippets use a SQL query to extract discount data, calculate the average using pandas, and present the results to the user. The histogram is created similarly, with nbins optionally set in the input code, which does not alter the correctness.",both
Which suppliers have not been used in any orders? Include a bar chart to visualize the count of unused suppliers.,"```python
import plotly.express as px

# Given SQL query
sql_query = '''
SELECT s.SupplierID 
FROM suppliers s 
LEFT JOIN products p ON s.SupplierID = p.SupplierID 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.OrderID IS NULL;
'''

# Utility function to execute the SQL query
unused_suppliers_df = execute_sql_query(sql_query)

# Count of unique unused suppliers
unused_suppliers_count = unused_suppliers_df['SupplierID'].nunique()

# Create a DataFrame with SupplierID and Count
visualization_df = unused_suppliers_df['SupplierID'].value_counts().reset_index()
visualization_df.columns = ['SupplierID', 'Count']

# Create a bar chart
if not visualization_df.empty:
    fig = px.bar(visualization_df, x='SupplierID', y='Count', title='Unused Suppliers Count')
else:
    fig = px.bar(title='No unused suppliers found')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName
FROM suppliers s
LEFT JOIN products p ON s.SupplierID = p.SupplierID
LEFT JOIN orders o ON p.ProductID = o.OrderID
WHERE o.OrderID IS NULL
""""""

unused_suppliers_df = execute_sql_query(sql_query)

fig = px.bar(unused_suppliers_df, x='CompanyName', y=unused_suppliers_df.index + 1, title='Unused Suppliers Count', labels={'y':'Count', 'CompanyName':'Supplier'})
show_to_user(fig)
```","The input code has a fundamental error in the SQL statement. It attempts to join 'orders' using 'ProductID' with 'OrderID', which is incorrect as it should join 'Order Details' on this field, not 'orders'. This would result in an incorrect identification of unused suppliers. The logic also produces a visual count using the DataFrame index, instead of counting unused suppliers, which is not aligned with the desired output or the reference code.","```python
import pandas as pd
import plotly.express as px

# Define SQL query to find unused suppliers
sql_query = """"""
SELECT s.SupplierID 
FROM suppliers s 
LEFT JOIN products p ON s.SupplierID = p.SupplierID 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
LEFT JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderID IS NULL;
""""""

# Execute the query using the provided utility function
unused_suppliers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the count of unused suppliers
fig = px.bar(
    x=[f'Unused Suppliers'], 
    y=[len(unused_suppliers_df)], 
    labels={'x': 'Category', 'y': 'Count'}, 
    title='Count of Unused Suppliers'
)

# Display the figure using the provided utility function
show_to_user(fig)
```","The input code is not correct because it introduces an unnecessary extra join with the 'orders' table which is not present in the reference code. The condition 'o.OrderID IS NULL' is redundant since the filtering should be done with 'od.OrderID IS NULL' based on the reference code. Moreover, the visualization method is different: the input code plots a single bar for the total count of unused suppliers while the reference implementation plots multiple bars for each SupplierID, which provides more detail. Thus, the input fails to replicate the same logic as the reference code.",None
Calculate the total sales revenue per supplier for the last fiscal year and create a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue per supplier for the last fiscal year
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS SupplierRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) - 1 
GROUP BY suppliers.CompanyName 
ORDER BY SupplierRevenue DESC;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder implementation. It should execute the SQL query and return a pandas DataFrame.
    # Example: return pd.read_sql_query(sql_query, database_connection)
    pass

def show_to_user(data):
    # This function should display the data or visualization.
    # Example: for pandas DataFrame: display(data)
    # For plotly figures: data.show()
    pass

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='SupplierRevenue', title='Total Sales Revenue per Supplier for Last Fiscal Year')

# Use the utility to show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to calculate total sales revenue per supplier for the last fiscal year
sql_query = """"""
SELECT 
    s.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    suppliers s ON p.SupplierID = s.SupplierID
WHERE 
    YEAR(o.OrderDate) = YEAR(CURDATE()) - 1
GROUP BY 
    s.SupplierID, s.CompanyName
""""""

# Execute the SQL query to retrieve the data
revenue_data = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales revenue per supplier
fig = px.bar(revenue_data, x='CompanyName', y='TotalRevenue', 
             title='Total Sales Revenue per Supplier for Last Fiscal Year',
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier Name'})

# Display the figure to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request as specified. Both the input and reference queries retrieve the total sales revenue per supplier for the last fiscal year by summing the product of unit price, quantity, and discount from related tables. The input code adheres to the same logic as the reference: it uses proper joins on 'orders', 'order details', 'products', and 'suppliers' tables, filters by the last fiscal year, groups by company name, and orders the results. It then visualizes this data as a bar chart with Plotly, correctly specifying axis labels and the chart title.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the data for the last fiscal year
sql_query = """"""
SELECT p.SupplierID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY p.SupplierID;
""""""

# Use the utility function to execute the query
# and store the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total sales per supplier
fig = px.bar(
    sales_data, 
    x='SupplierID', 
    y='TotalSales', 
    title='Total Sales Revenue per Supplier for Last Fiscal Year',
    labels={'TotalSales': 'Total Sales Revenue', 'SupplierID': 'Supplier ID'}
)

# Display the bar chart using the utility function
show_to_user(fig)
```","The input code does not join with the 'suppliers' table to fetch the 'CompanyName', which is required to match the output of the reference implementation. Instead, it groups and visualizes by 'SupplierID'. Additionally, the input code is missing the join with the 'orders' table, which is used to filter the orders by year in the reference implementation.",Base
"What are the top five customers based on order volume, and can you provide a bar chart to visualize their order volumes?","
```python
import plotly.express as px
import pandas as pd

# Mock function to imitate executing an SQL query and returning a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Example data returned from the query
    data = {
        'CustomerID': ['C123', 'C456', 'C789', 'C101', 'C112'],
        'OrderVolume': [150, 130, 120, 110, 100]
    }
    return pd.DataFrame(data)

# Mock function to display data analysis or visualization results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the top five customers based on order volume
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderVolume 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderVolume DESC 
LIMIT 5;
""""""

# Execute the query and obtain the results as a DataFrame
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the order volumes of the top five customers
fig = px.bar(top_customers_df, x='CustomerID', y='OrderVolume', title='Top Five Customers by Order Volume')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.CustomerID, COUNT(od.OrderID) AS OrderVolume
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID
ORDER BY OrderVolume DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CustomerID', y='OrderVolume', title='Top 5 Customers by Order Volume')
show_to_user(fig)
```","The input code references a different SQL query that involves a JOIN with 'Order Details', whereas the reference code does not use a JOIN. This affects the logic of obtaining order volumes and changes the results. Therefore, the input code does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Function to execute given SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating the database query execution
    # In practice, this would interact with a database
    pass

# Function to show data or visualizations to user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch the top five customers based on order volume
sql_query = """"""
SELECT 
    customers.CustomerID, 
    COUNT(orders.OrderID) AS order_volume 
FROM 
    orders 
JOIN 
    customers 
ON 
    orders.CustomerID = customers.CustomerID 
GROUP BY 
    customers.CustomerID 
ORDER BY 
    order_volume DESC 
LIMIT 5
""""""

# Execute the SQL query to get the data
top_customers_df = execute_sql_query(sql_query)

# Visualizing the top five customers' order volumes using a bar chart
fig = px.bar(top_customers_df, x='CustomerID', y='order_volume',
             title='Top 5 Customers by Order Volume', 
             labels={'CustomerID': 'Customer ID', 'order_volume': 'Order Volume'})

# Show the plot to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request. Both the reference and input implementations aim to fetch and visualize the top five customers based on order volume using similar logic. Although the input is more detailed in specifying the SQL query to include a join with a `customers` table, it still adheres to the overall logic required. Both codes use Plotly to create a bar chart for visualization and simulate fetching data from a database.",Finetuned
What are the top 5 cities with the most supplier companies? Please include a bar chart to visualize the number of supplier companies in these cities.,"```python
import pandas as pd
import plotly.express as px

# SQL query to select the top 5 cities with the most supplier companies
sql_query = """"""
SELECT City, COUNT(DISTINCT SupplierID) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
LIMIT 5;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='City', y='SupplierCount', title='Top 5 Cities with Most Supplier Companies')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT City, COUNT(SupplierID) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
LIMIT 5;
""""""

top_cities_df = execute_sql_query(sql_query)

fig = px.bar(top_cities_df, x='City', y='SupplierCount', title='Top 5 Cities with Most Supplier Companies', labels={'SupplierCount': 'Number of Supplier Companies'})
show_to_user(fig)
```","The input code does not correctly count distinct SupplierIDs within each city. The SQL query in the input code uses 'COUNT(SupplierID)' rather than 'COUNT(DISTINCT SupplierID)', which means it counts all SupplierIDs, including duplicates, rather than only unique SupplierIDs. This could lead to an incorrect number of supplier companies per city.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT s.City, COUNT(DISTINCT s.SupplierID) AS NumberOfSuppliers 
FROM suppliers s 
GROUP BY s.City 
ORDER BY NumberOfSuppliers DESC 
LIMIT 5;
'''

# Execute the SQL query
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of supplier companies in each city
fig = px.bar(top_cities_df, x='City', y='NumberOfSuppliers',
             title='Top 5 Cities with Most Supplier Companies',
             labels={'NumberOfSuppliers': 'Number of Suppliers', 'City': 'City'})

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly implements the business analytics request and adheres to the same logic as the reference implementation. Both versions perform a SQL query to select the top 5 cities with the most supplier companies, count distinct SupplierIDs grouped by city, order the results by the count in descending order, and limit it to 5 entries. The visualization part uses Plotly to create a bar chart with labeled axes, and the chart is displayed to the user. The logical steps and the final outcome are consistent across both pieces of code.",Finetuned
"What is the most common region suppliers are from, and can you provide a bar chart to visualize the distribution of suppliers across different regions?","```python
import plotly.express as px

# SQL query to find the most common region suppliers are from
sql_query = """"""
SELECT Region, COUNT(*) as SupplierCount 
FROM suppliers 
GROUP BY Region 
ORDER BY SupplierCount DESC;
""""""

# Execute the SQL query and receive the result in a DataFrame
df = execute_sql_query(sql_query)

# Display the DataFrame to provide data analysis
show_to_user(df)

# Create a bar chart to visualize the distribution of suppliers across regions
fig = px.bar(df, x='Region', y='SupplierCount', title='Supplier Distribution by Region')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Region, COUNT(*) AS SupplierCount
FROM suppliers
GROUP BY Region
ORDER BY SupplierCount DESC
LIMIT 1;
""""""

most_common_region_df = execute_sql_query(sql_query)

most_common_region = most_common_region_df['Region'].values[0]

region_distribution_query = """"""
SELECT Region, COUNT(*) AS SupplierCount
FROM suppliers
GROUP BY Region;
""""""

region_distribution_df = execute_sql_query(region_distribution_query)

fig = px.bar(region_distribution_df, x='Region', y='SupplierCount', title='Distribution of Suppliers Across Regions')
show_to_user(fig)
```","The input code correctly calculates the most common region and visualizes the supplier distribution across regions. It first finds the most common region but doesn't use it further for the bar chart, which still fulfills the business request of visualizing all regions. The chart creation logic is consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get supplier counts by region
sql_query = """"""
SELECT Region, COUNT(*) AS SupplierCount 
FROM suppliers 
GROUP BY Region 
ORDER BY SupplierCount DESC;
""""""
df_suppliers = execute_sql_query(sql_query)

# Visualize the distribution of suppliers across different regions
fig = px.bar(df_suppliers, x='Region', y='SupplierCount', 
             title='Distribution of Suppliers Across Regions')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly executes the same SQL query as the reference code to count suppliers by region. It generates a bar chart using Plotly to visualize the data, adhering to the same logic and achieving the same result. Differences like variable names or chart titles do not affect correctness.",both
"Find employees who have worked for more than 10 years and their number of orders handled, and visualize the distribution of orders handled by these employees.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query is already defined elsewhere
# Assume show_to_user is already defined elsewhere

# SQL Query
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) as NumberOfOrders
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE YEAR(CURRENT_DATE) - YEAR(e.HireDate) > 10 
GROUP BY e.EmployeeID;
""""""

# Execute SQL query and get the result as a DataFrame
employee_orders_df = execute_sql_query(sql_query)

# Plot the distribution of the number of orders handled by these employees
fig = px.histogram(employee_orders_df, x='NumberOfOrders', nbins=20,
                   title='Distribution of Orders Handled by Employees with >10 Years of Service')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE DATEDIFF(CURDATE(), e.HireDate) > 3650
GROUP BY e.EmployeeID
""""""

employee_orders_df = execute_sql_query(sql_query)

fig = px.histogram(employee_orders_df, x='NumberOfOrders', title='Distribution of Orders Handled by Employees with Over 10 Years of Experience')
show_to_user(fig)
```","The input code correctly implements the logic to find employees who have worked for more than 10 years and counts the number of orders they have handled. It uses the DATEDIFF function to ensure employees have worked over 3650 days, which equates to over 10 years. The visualization displays the distribution of the number of orders handled, similar to the reference implementation. While the input code includes employee names, it does not affect the core logic, thus both codes logically achieve the business analysis request.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # This is a placeholder function. Implement your database connection logic here.
    # For example, execute the query and return the results as a pandas DataFrame.
    pass

def show_to_user(data):
    # This is a placeholder function. Implement logic to display data or figures.
    # For example, if data is a pandas DataFrame, print it.
    if isinstance(data, pd.DataFrame):
        print(data)
    elif hasattr(data, 'show'):
        data.show()

# SQL query to find employees with more than 10 years of service and their number of orders
sql_query = """"""
SELECT
    employees.EmployeeID,
    COUNT(orders.OrderID) AS OrderCount
FROM
    employees
JOIN
    orders ON employees.EmployeeID = orders.EmployeeID
WHERE
    DATEDIFF(CURRENT_DATE, employees.HireDate) > 3650
GROUP BY
    employees.EmployeeID;
""""""

# Execute the SQL query and store the result in a DataFrame
employees_orders_df = execute_sql_query(sql_query)

# Visualize the distribution of orders handled by employees
fig = px.histogram(employees_orders_df, x='OrderCount', nbins=10,
                   title='Distribution of Orders Handled by Employees with >10 Years of Service',
                   labels={'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The provided code uses a slightly different method to calculate the employment duration (DATEDIFF instead of YEAR difference), but it achieves the same logical outcome—identifying employees who have been with the company for over 10 years. It groups by employee ID and counts the number of orders handled, matching the reference implementation's logic. Both implementations then visualize the distribution of orders successfully. Therefore, the code meets the business analytics request correctly.",both
"What is the total freight cost by country, and can it be represented with a bar chart for clearer comparison?","```python
import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreightCost 
FROM orders 
GROUP BY ShipCountry;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipCountry', y='TotalFreightCost', 
             title='Total Freight Cost by Country',
             labels={'ShipCountry': 'Country', 'TotalFreightCost': 'Freight Cost'},
             template='plotly_dark')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipCountry
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Country', labels={'TotalFreight': 'Total Freight Cost', 'ShipCountry': 'Country'})
show_to_user(fig)
```","The input code computes the total freight cost by country using SQL and visualizes it as a bar chart. It adheres to the same logic as the reference implementation: executing an equivalent SQL query and using Plotly to create a bar chart. The key differences, such as variable names and label details, do not affect the overall correctness or logic equivalence.","```python
import pandas as pd
import plotly.express as px

def execute_business_analysis():
    # Define the SQL query
    sql_query = """"""
    SELECT o.ShipCountry, SUM(o.Freight) AS TotalFreight 
    FROM orders o 
    GROUP BY o.ShipCountry;
    """"""
    
    # Execute SQL query and fetch the data
    df = execute_sql_query(sql_query)
    
    # Create a bar chart using Plotly for better comparison
    fig = px.bar(df, x='ShipCountry', y='TotalFreight',
                 title='Total Freight Cost by Country',
                 labels={'ShipCountry': 'Country', 'TotalFreight': 'Total Freight Cost'},
                 template='plotly')
    
    # Show the bar chart to the user
    show_to_user(fig)

execute_business_analysis()
```","The input code correctly executes the SQL query to calculate the total freight cost by country, using a query which matches the reference logic. It groups the freight costs by 'ShipCountry', sums them up, and assigns the result to a DataFrame. The use of Plotly to create a bar chart is consistent with the reference, employing similar parameters. Although there is a minor difference in the label for 'TotalFreightCost' vs 'TotalFreight', it does not affect the logic or the correctness of the code. Both implementations adhere to the business request by providing a bar chart for data visualization.",both
Determine the top 5 customers by lifetime value and present the results in a bar chart.,"
import plotly.express as px
import pandas as pd

# SQL query string
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS LifetimeValue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY LifetimeValue DESC 
LIMIT 5;
""""""

# Utility function to execute the SQL query and retrieve data
def execute_sql_query(sql_query: str):
    # Placeholder for the query execution
    # Replace with actual implementation to fetch data using a database connection
    # Returning a mock DataFrame for illustration
    return pd.DataFrame({
        'CustomerID': ['C1', 'C2', 'C3', 'C4', 'C5'],
        'LifetimeValue': [5000, 4500, 4400, 4300, 4200]
    })

# Execute the SQL query
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_customers_df, x='CustomerID', y='LifetimeValue', 
             title='Top 5 Customers by Lifetime Value',
             labels={'LifetimeValue': 'Lifetime Value ($)', 'CustomerID': 'Customer ID'})

# Utility function to display the result to the user
def show_to_user(data):
    # If the data is a DataFrame, show it. If it's a Plotly figure, display it.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    LifetimeValue DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='LifetimeValue', title='Top 5 Customers by Lifetime Value')
show_to_user(fig)
```","The input Python code satisfies the business analytics request to determine the top 5 customers by lifetime value and display results in a bar chart. Despite minor differences from the reference implementation, such as including 'CompanyName' in the SELECT clause and the x-axis of the bar chart, the core logic remains intact. It retrieves the required 5 customers based on lifetime value, groups data correctly, and displays it using Plotly.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 5 customers by lifetime value
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY LifetimeValue DESC 
LIMIT 5;
""""""

# Utility function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for context
    # This would normally use a DBAPI connection to execute and fetch the results
    pass

# Execute the SQL query
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart to present the results
fig = px.bar(
    top_customers_df,
    x='CustomerID',
    y='LifetimeValue',
    title='Top 5 Customers by Lifetime Value',
    labels={'LifetimeValue': 'Lifetime Value ($)', 'CustomerID': 'Customer ID'}
)

# Utility function to display the visualization
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Display the bar chart
show_to_user(fig)
```","The input code correctly aims to determine the top 5 customers by lifetime value using a specified SQL query. Although the `execute_sql_query` function implementation is missing, this matches the provided context which uses a placeholder or a dummy function for data retrieval. Both versions build a Plotly bar chart using the same logic, and display it similarly with the `show_to_user` function. Thus, the input code adheres to the intended functionality like the reference.",both
Identify the regions with the highest order volumes and provide a bar chart visualization to illustrate the differences.,"```python
import pandas as pd
import plotly.express as px

# Function to execute the given SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function executes the provided SQL query
    # and returns the result as a pandas DataFrame
    pass

# Function to display the results to the user
def show_to_user(data):
    # Assume this function can display a DataFrame or Plotly figure
    pass

# SQL Query to get order volumes by region
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderVolume 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OrderVolume DESC;
""""""

# Execute the query and get the result as a DataFrame
order_volume_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(order_volume_df, x='ShipRegion', y='OrderVolume', title='Order Volumes by Region')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderVolume
FROM orders
GROUP BY ShipRegion
ORDER BY OrderVolume DESC
""""""

order_volumes = execute_sql_query(sql_query)

fig = px.bar(order_volumes, x='ShipRegion', y='OrderVolume', 
             title='Order Volumes by Region', 
             labels={'ShipRegion': 'Region', 'OrderVolume': 'Order Volume'})

show_to_user(fig)
```","The input Python code correctly implements the business analytics request by querying order volumes by region, creating a bar chart to visualize these volumes, and displaying the chart to the user. It follows the same logic as the reference implementation. The addition of labels for clarity does not affect functionality and adheres to the original request.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch region order volumes
sql_query = """"""
SELECT ShipRegion, COUNT(*) as OrderVolume 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OrderVolume DESC;
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize order volumes by region
fig = px.bar(df, x='ShipRegion', y='OrderVolume', title='Order Volumes by Region')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code follows the same logic as the reference implementation. Both codes execute an SQL query to obtain order volumes by region and create a Plotly bar chart for visualization. The difference in naming (e.g., COUNT(OrderID) vs. COUNT(*)) does not alter the logic or result since both queries effectively group by ShipRegion and count orders. Thus, the input code correctly fulfills the business analytics request.",both
Which employee generated the highest sales in Q2 2023? Please include a bar chart showing the sales figures for the top five employees.,"```python
import plotly.express as px
import pandas as pd

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL query execution
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    pass

# Define the SQL query to get employee sales data for Q2 2023
sql_query = """"""
SELECT employees.FirstName, employees.LastName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY employees.EmployeeID
ORDER BY total_sales DESC
LIMIT 5
""""""

# Execute the SQL query to get the data
sales_data_df = execute_sql_query(sql_query)

# Find the employee with the highest sales
if not sales_data_df.empty:
    top_employee = sales_data_df.iloc[0]
    first_name = top_employee['FirstName']
    last_name = top_employee['LastName']
    highest_sales_amount = top_employee['total_sales']

    # Prepare visualization
    fig = px.bar(
        sales_data_df,
        x='FirstName',
        y='total_sales',
        title=f""Top 5 Employees by Sales in Q2 2023 (Top: {first_name} {last_name})"",
        labels={'total_sales': 'Total Sales'},
        hover_data={'LastName': True, 'FirstName': True}
    )

    # Display the visualization
    show_to_user(fig)
else:
    print(""No sales data found for the specified period."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY employee_sales DESC
LIMIT 5
""""""

employee_sales_df = execute_sql_query(sql_query)

top_employee = employee_sales_df.iloc[0]

bar_fig = px.bar(employee_sales_df, 
                 x=employee_sales_df['FirstName'] + ' ' + employee_sales_df['LastName'], 
                 y='employee_sales', 
                 title='Top 5 Employees by Sales in Q2 2023', 
                 labels={'employee_sales': 'Sales', 'x': 'Employee'})

show_to_user(bar_fig)
top_employee
```","The input Python code correctly executes a SQL query to retrieve sales data for employees in Q2 2023. It sums sales (considering UnitPrice, Quantity, and Discount), groups by EmployeeID, FirstName, and LastName, and orders them to get the top five. The plotting logic is also consistent, generating a bar chart with employee names and their corresponding sales. The slight differences in column names and chart customization do not affect the logic or correctness, and the code fulfills the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch the data for the top five employees
sql_query = """"""
    SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
    FROM employees e
    JOIN orders o ON e.EmployeeID = o.EmployeeID
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    WHERE o.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
    GROUP BY e.EmployeeID
    ORDER BY TotalSales DESC
    LIMIT 5;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
top_employees_df = execute_sql_query(sql_query)

# Extract the employee with the highest sales
highest_sales_employee = top_employees_df.iloc[0]

# Display the employee with the highest sales information
show_to_user(highest_sales_employee.to_frame().T)

# Create a bar chart for the top five employees
fig = px.bar(
    top_employees_df,
    x='EmployeeID',
    y='TotalSales',
    title='Top 5 Employees by Sales in Q2 2023',
    labels={'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'},
    text='TotalSales'
)

# Display the bar chart using the utility function
show_to_user(fig)
```","The input code misses retrieving and displaying employee names, which are included in the reference. It only shows the EmployeeID, while the business requirement is to identify the employee by name. This is a key part of the request as the reference implementation queries for FirstName and LastName and includes them in the visualization. The input code does not adhere to this part of the business logic.",Base
How many orders were placed and not yet shipped? Include a chart showing the number of unshipped orders by order date.,"```python
import plotly.express as px
import pandas as pd

# SQL query to be executed
sql_query_unshipped_count = """"""
SELECT COUNT(OrderID) AS UnshippedOrders FROM orders WHERE ShippedDate IS NULL;
""""""

sql_query_unshipped_by_date = """"""
SELECT OrderDate, COUNT(OrderID) AS UnshippedOrders
FROM orders
WHERE ShippedDate IS NULL
GROUP BY OrderDate
""""""

# Execute the SQL queries
unshipped_count_df = execute_sql_query(sql_query_unshipped_count)
unshipped_by_date_df = execute_sql_query(sql_query_unshipped_by_date)

# Display the number of unshipped orders
show_to_user(unshipped_count_df)

# Create a line chart of unshipped orders by order date
fig = px.line(unshipped_by_date_df, x='OrderDate', y='UnshippedOrders', title='Unshipped Orders by Order Date')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderDate, COUNT(OrderID) AS UnshippedOrders
FROM orders
WHERE ShippedDate IS NULL
GROUP BY OrderDate
ORDER BY OrderDate
""""""

unshipped_orders_df = execute_sql_query(sql_query)

unshipped_count = unshipped_orders_df['UnshippedOrders'].sum()

fig = px.bar(unshipped_orders_df, x='OrderDate', y='UnshippedOrders', title='Number of Unshipped Orders by Order Date')
show_to_user(fig)

unshipped_count
```","The input Python code correctly calculates the number of unshipped orders and produces a chart with the number of unshipped orders by order date. The code uses a single SQL query to retrieve the data needed, which includes calculating the total unshipped orders and grouping by order date. It computes the sum of unshipped orders for the total count and uses a bar chart instead of a line chart to display orders by date. Although the visualization differs, the business questions are addressed correctly.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query_unshipped_orders = """"""
SELECT OrderDate, COUNT(OrderID) AS UnshippedOrders
FROM orders
WHERE ShippedDate IS NULL
GROUP BY OrderDate
ORDER BY OrderDate;
""""""

# Execute the SQL query and obtain the result as a pandas DataFrame
unshipped_orders_df = execute_sql_query(sql_query_unshipped_orders)

# Generate a bar chart showing the number of unshipped orders by order date
fig_unshipped_orders = px.bar(
    unshipped_orders_df,
    x='OrderDate',
    y='UnshippedOrders',
    title='Number of Unshipped Orders by Order Date',
    labels={'OrderDate': 'Order Date', 'UnshippedOrders': 'Unshipped Orders'}
)

# Display the bar chart to the user
show_to_user(fig_unshipped_orders)
```","The provided code only generates a chart showing unshipped orders by order date, but it does not calculate or display the total count of unshipped orders separately. In the reference implementation, two separate SQL queries are used: one to calculate the total number of unshipped orders and another to group those by order date for visualization. The input code only implements the latter part, omitting a critical part of the business analytics request.",Base
"What is the total freight cost incurred for each shipping country, and how can this be visualized?","```python
import plotly.express as px
import pandas as pd

# Given SQL query
sql_query = """"""
SELECT o.ShipCountry, SUM(o.Freight) AS TotalFreight 
FROM orders o 
GROUP BY o.ShipCountry;
""""""

# Execute the SQL query and retrieve the data
freight_data = execute_sql_query(sql_query)

# Create a bar chart for visualization using Plotly
fig = px.bar(
    freight_data, 
    x='ShipCountry', 
    y='TotalFreight', 
    title='Total Freight Cost by Shipping Country',
    labels={'TotalFreight': 'Total Freight Cost', 'ShipCountry': 'Ship Country'},
    template='plotly'
)

# Display the plot using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipCountry
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Shipping Country')
show_to_user(fig)
```","The input code correctly executes the SQL query to sum the freight cost by shipping country, just like the reference code. The SQL query structure and logic match the reference implementation. The visualization using Plotly Express to create a bar chart is also consistent with the reference, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch total freight cost incurred for each shipping country
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY ShipCountry;
""""""

# Execute the query using the provided utility function
data_df = execute_sql_query(sql_query)

# Visualize the total freight cost using Plotly
fig = px.bar(data_df, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Shipping Country')

# Display the visualization
show_to_user(fig)
```","The input Python code correctly implements the requested business analytics task, which is to calculate the total freight cost for each shipping country. It executes an SQL query aggregating freight costs by ShipCountry, and visualizes the results as a bar chart using Plotly. This matches the logic and goal of the reference implementation.",both
"Which products are below their reorder level, and can you provide a visualization to illustrate the quantities compared to the reorder levels?","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute SQL query and get results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a visualization comparing UnitsInStock and ReorderLevel for each product
fig = px.bar(df, x='ProductName', y=['UnitsInStock', 'ReorderLevel'],
             title='Product Stock Levels vs Reorder Levels',
             labels={'value': 'Quantity', 'ProductName': 'Product'},
             barmode='group')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""
products_below_reorder_level = execute_sql_query(sql_query)

fig = px.bar(products_below_reorder_level, 
              x='ProductName', 
              y=['UnitsInStock', 'ReorderLevel'], 
              title='Products Below Reorder Level',
              labels={'value': 'Quantity', 'variable': 'Stock Status'},
              barmode='group')

show_to_user(fig)
```","The input code adds an additional filter 'Discontinued = 0' that is not present in the reference code. This filter changes the logic by excluding discontinued products from the analysis. Therefore, while the input code successfully identifies and visualizes products below their reorder level, it does not adhere strictly to the logic specified in the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Retrieve products below reorder level
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;""
products_df = execute_sql_query(sql_query)

# Create a visualization using Plotly
fig = px.bar(products_df, 
             x='ProductName', 
             y=['UnitsInStock', 'ReorderLevel'], 
             title='Products Below Reorder Level',
             labels={'value': 'Quantity', 'variable': 'Status'},
             barmode='group')

# Display the visualization
show_to_user(fig)
```",The input code accurately fulfills the request and follows the same logic as the reference implementation. Both codes execute an SQL query to get products below their reorder levels and use Plotly to create a grouped bar chart visualization comparing 'UnitsInStock' and 'ReorderLevel' for each product. Minor differences in titles and label names do not affect the correctness regarding the task requirements.,Finetuned
Which employees have not recorded any sales this year? Include a bar chart showing the number of sales per employee for those with zero sales.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find employees with no sales this year
sql_query = """"""
SELECT e.EmployeeID 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID AND YEAR(o.OrderDate) = YEAR(CURDATE()) 
WHERE o.OrderID IS NULL;
""""""

# Execute the SQL query
employees_no_sales_df = execute_sql_query(sql_query)

# Directly use the result, as these are already employees with zero sales
# Create a DataFrame with SalesCount set to zero
zero_sales_employees = employees_no_sales_df.copy()
zero_sales_employees['SalesCount'] = 0

# Generate a bar chart using Plotly
fig = px.bar(
    zero_sales_employees, 
    x='EmployeeID', 
    y='SalesCount', 
    title='Number of Sales per Employee with Zero Sales This Year',
    labels={'SalesCount': 'Number of Sales', 'EmployeeID': 'Employee ID'}
)

# Show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the current year
current_year = pd.to_datetime('now').year

# SQL query to find employees with no sales this year
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID AND YEAR(o.OrderDate) = {current_year}
GROUP BY e.EmployeeID
HAVING COUNT(o.OrderID) = 0;
""""""

# Execute the SQL query
zero_sales_employees = execute_sql_query(sql_query)

# Create a bar chart for the employees with zero sales
fig = px.bar(zero_sales_employees, 
             x='EmployeeID', 
             y='FirstName', 
             title='Employees with Zero Sales This Year',
             labels={'FirstName': 'Employee Name'},
             color='LastName')

# Show the result to the user
show_to_user(fig)
```","The input code includes employee first and last names in the query and uses them in the bar chart, whereas the reference solution considers only EmployeeID and assigns a 'SalesCount' of zero for the bar chart. Additionally, the y-axis in the bar chart of the input code uses 'FirstName,' which is incorrect for representing a sales count, leading to differing outputs in visualization.","```python
import pandas as pd
import plotly.express as px

# Assume these utility functions are correctly implemented
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the function that executes SQL and returns a DataFrame
    pass

def show_to_user(data):
    # Placeholder for the function that displays data or visualization to users
    pass

# SQL query to find employees with no sales this year
sql_query = """"""
SELECT e.EmployeeID, e.EmployeeName 
FROM employees e 
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID 
AND YEAR(o.OrderDate) = YEAR(CURDATE()) 
WHERE o.OrderID IS NULL;
""""""

# Execute the query and get results
employees_no_sales = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(
    employees_no_sales,
    x='EmployeeName',
    y='EmployeeID',  # Y value not necessary, can use any constant as it won't be shown
    title='Employees with Zero Sales This Year',
    labels={'EmployeeName': 'Employees'},
    text='EmployeeID'  # showing ID for visualization context
)

# Since these employees have zero sales, we provide a dummy value for bar height
fig.update_traces(y=[1]*len(employees_no_sales), textposition='auto')

# Improve layout
fig.update_layout(showlegend=False, yaxis_title='Number of Sales', yaxis_range=[0, 1])

# Show bar chart
show_to_user(fig)
```","The input code uses 'EmployeeName' instead of 'EmployeeID' for the x-axis, which deviates from the reference logic. Additionally, it inaccurately visualizes zero sales by setting a constant height for the bars instead of using zero, misleading the representation.",None
Which products are below their reorder level and need to be restocked? Provide a bar chart visualization of these products with their current stock levels.,"```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user are pre-defined functions

# Given SQL query to execute
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query to get the DataFrame
products_to_restock_df = execute_sql_query(sql_query)

# Visualize data using a bar chart
fig = px.bar(
    products_to_restock_df,
    x='ProductName',
    y='UnitsInStock',
    title='Products Below Reorder Level',
    labels={'UnitsInStock': 'Current Stock Level'},
    text='UnitsInStock'
)

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""

products_below_reorder_level = execute_sql_query(sql_query)

fig = px.bar(products_below_reorder_level, 
              x='ProductName', 
              y='UnitsInStock', 
              title='Products Below Reorder Level', 
              labels={'UnitsInStock': 'Current Stock Level', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code includes a condition (`Discontinued = 0`) not present in the reference code. This affects the logic by potentially excluding products that should be considered. Additionally, the input code retrieves the 'ProductID', though it is not used in the visualization, which is not an exact match to the reference logic. Therefore, it does not adhere precisely to the original request.","
```python
import plotly.express as px
import pandas as pd

# SQL Query to fetch products below their reorder level
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products 
WHERE UnitsInStock < ReorderLevel;
""""""

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mocked function to simulate SQL execution
    # In a real environment, this function would connect to a database
    # and execute the query, returning the result as a pandas DataFrame.
    data = {
        'ProductID': [1, 2, 3],
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'UnitsInStock': [20, 15, 5],
    }
    return pd.DataFrame(data)

# Utility function to show data analysis or visualization results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query and fetch the result into a pandas DataFrame
products_below_reorder_level_df = execute_sql_query(sql_query)

# Visualizing the products below their reorder level with a bar chart
fig = px.bar(
    products_below_reorder_level_df, 
    x='ProductName', 
    y='UnitsInStock', 
    title='Products Below Reorder Level',
    labels={'UnitsInStock': 'Units in Stock'}
)

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly executes a SQL query to fetch products where 'UnitsInStock' is less than 'ReorderLevel'. The key elements in both the reference and input implementations are the same: executing the SQL query, obtaining a DataFrame with relevant data, and visualizing it using a bar chart. Although the implementation details for functions like 'execute_sql_query' and 'show_to_user' are different, they fulfill the same purpose as in the reference implementation by producing and displaying the correct output.",Finetuned
"Which employee handled the most orders that were shipped late? Additionally, provide a bar chart showing the number of late shipments handled by each employee.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS LateOrders
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE ShippedDate > RequiredDate
GROUP BY employees.EmployeeID
ORDER BY LateOrders DESC;
""""""

# Execute the SQL query to get the data into a DataFrame
late_orders_df = execute_sql_query(sql_query)

# Identify the employee who handled the most late orders
# Ensure the DataFrame is not empty to avoid indexing errors
if not late_orders_df.empty:
    top_employee = late_orders_df.iloc[0]

    # Display the top employee information
    show_to_user(pd.DataFrame([top_employee]))

# Create and display a bar chart for the number of late shipments handled by each employee
fig = px.bar(late_orders_df, x='EmployeeID', y='LateOrders', title='Number of Late Shipments by Employee')
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS LateShipments
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY e.EmployeeID
ORDER BY LateShipments DESC
LIMIT 1
""""""

top_employee = execute_sql_query(sql_query)

late_shipments_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS LateShipments
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY e.EmployeeID
""""""

late_shipments_df = execute_sql_query(late_shipments_query)

fig = px.bar(late_shipments_df, x='LastName', y='LateShipments', 
             title='Number of Late Shipments Handled by Each Employee', 
             labels={'LastName': 'Employee', 'LateShipments': 'Number of Late Shipments'})

show_to_user(top_employee)
show_to_user(fig)
```","The input code effectively fulfills the business analytics request. It identifies the employee with the most late shipments using a SQL query with a LIMIT 1 clause, which gives the top employee. It also gathers data for all employees to create a bar chart of late shipments. Even though the reference code combines data retrieval and visualization in a single sequence, the input code splits these into more detailed steps with separate queries for the top employee and the bar chart. Both approaches correctly filter and analyze the data to answer the given business question.","import plotly.express as px

# Define the SQL query to find the employee with the most late orders.
sql_query = """"""
SELECT o.EmployeeID, COUNT(*) AS LateOrdersCount
FROM orders o
WHERE o.ShippedDate > o.RequiredDate
GROUP BY o.EmployeeID
ORDER BY LateOrdersCount DESC;
""""""

# Execute the SQL query and retrieve the results in a pandas DataFrame.
late_orders_df = execute_sql_query(sql_query)

# Identify the employee with the most late orders.
top_employee = late_orders_df.iloc[0]
        
# Output the employee with the most late orders to the user.
show_to_user(top_employee)

# Create a bar chart to show the number of late shipments handled by each employee.
fig = px.bar(
    late_orders_df,
    x='EmployeeID',
    y='LateOrdersCount',
    title='Number of Late Shipments Handled by Each Employee',
    labels={'EmployeeID': 'Employee ID', 'LateOrdersCount': 'Late Orders Count'}
)

# Display the bar chart.
show_to_user(fig)
","The input code correctly answers the business analytics request and follows the same logic as the reference implementation. Both codes execute a SQL query to retrieve the number of late orders handled by each employee and order the results to identify the employee with the most late orders. The input code uses COUNT(*) and aliases it as LateOrdersCount, which is functionally equivalent to COUNT(orders.OrderID) as LateOrders in the reference code. Both implementations create a bar chart to display the number of late shipments handled by each employee and output the employee with the most late orders.",both
List all products that have never been ordered and provide a visual representation of these products.,"```python
import plotly.express as px
import pandas as pd

# Execute SQL query to get products that have never been ordered
query = """"""
SELECT ProductName 
FROM products 
WHERE ProductID NOT IN (
    SELECT DISTINCT ProductID 
    FROM [Order Details]
);
""""""
# Fetch the data using the utility function
unordered_products_df = execute_sql_query(query)

# Display the data if needed for analysis
show_to_user(unordered_products_df)

# Generate a bar chart for visual representation of unordered products
fig = px.bar(unordered_products_df, x='ProductName', title='Products Never Ordered')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL;
""""""
# Execute the SQL query
never_ordered_products = execute_sql_query(sql_query)

# Visual representation of products that have never been ordered
fig = px.bar(never_ordered_products, x='ProductName', y='ProductID', title='Products That Have Never Been Ordered')
show_to_user(fig)
```","The input code correctly identifies products that have never been ordered using a LEFT JOIN and a IS NULL condition, ensuring the product does not appear in the order details. This is analogous to NOT IN with DISTINCT used in the reference code. Additionally, the input code provides a visual using Plotly, similar to the reference implementation, satisfying the business request.","```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL;
""""""

# Execute the SQL query and get the results in a DataFrame
products_never_ordered = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visually represent products that have never been ordered
fig = px.bar(products_never_ordered, x='ProductName', 
             title='Products That Have Never Been Ordered',
             labels={'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code successfully identifies products that have never been ordered by using a LEFT JOIN to find products with no matching entries in the 'Order Details' table (i.e., where 'od.ProductID IS NULL'). This approach achieves the same result as the reference code, which uses a NOT IN clause. The visualization part is also correct, generating a bar chart for these products. The logic and outcome align with the reference implementation's requirements.",both
"What is the percentage of orders delivered on or before the required date each month, and can you provide a line chart to visualize this over time?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    100.0 * COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) AS OnTimeDeliveryRate 
FROM 
    orders 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m');
'''

# Execute the SQL query and retrieve the results as a DataFrame
monthly_delivery_df = execute_sql_query(sql_query)

# Create a line chart to visualize the on-time delivery rate over time
fig = px.line(monthly_delivery_df, x='Month', y='OnTimeDeliveryRate', title='Monthly On-Time Delivery Rate')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(RequiredDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

df = execute_sql_query(sql_query)
df['OnTimePercentage'] = (df['OnTimeDeliveries'] / df['TotalOrders']) * 100

fig = px.line(df, x='Month', y='OnTimePercentage', title='Percentage of On-time Deliveries per Month', labels={'OnTimePercentage': 'On-time Delivery Percentage'})
show_to_user(fig)
```","Both implementations calculate the on-time delivery rate per month and create a line chart to visualize this metric over time. The reference code uses a calculation within the SQL query, while the input code does it in pandas after retrieving the data. Despite this difference, the logic and end result are the same: calculating the percentage of on-time deliveries for each month and visualizing it.","```python
import pandas as pd
import plotly.express as px

# SQL query, assuming utility function execute_sql_query is already defined
sql_query = """"""
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(*)) * 100 AS OnTimeDeliveryRate
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query and get the result as a DataFrame
def get_on_time_delivery_rate():
    df = execute_sql_query(sql_query)
    df['OnTimeDeliveryRate'] = df['OnTimeDeliveryRate'].astype(float)  # Ensure the datatype is correct
    return df

# Visualization function
def visualize_on_time_delivery_rate(df):
    fig = px.line(
        df,
        x='Month',
        y='OnTimeDeliveryRate',
        title='Monthly On-Time Delivery Rate',
        labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'Month': 'Month'},
        markers=True
    )
    show_to_user(fig)  # Utilizes the provided utility to show the figure to the user

# Main execution
if __name__ == ""__main__"":
    df_on_time_delivery_rate = get_on_time_delivery_rate()
    visualize_on_time_delivery_rate(df_on_time_delivery_rate)
```","The input Python code correctly calculates the percentage of on-time deliveries using SQL. It formats the month, calculates the percentage of on-time deliveries, and visualizes the results with a line chart. The logic aligns with the reference implementation, even though there are some differences in the details, such as ensuring the data type of 'OnTimeDeliveryRate'. Overall, the core functionality and final outcome are consistent with the reference, addressing the requested business analytics task effectively.",both
Which city has the highest average shipping cost? Can you provide a bar chart to visualize the average shipping costs by city?,"```python
import plotly.express as px
import pandas as pd

# Example SQL query to get the average shipping cost by city
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AvgShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AvgShippingCost DESC;
""""""

# Execute the SQL query to get the data
df_shipping_costs = execute_sql_query(sql_query)

# Create a bar chart visualizing the average shipping costs by city
fig = px.bar(df_shipping_costs, x='ShipCity', y='AvgShippingCost',
             title='Average Shipping Costs by City',
             labels={'ShipCity': 'City', 'AvgShippingCost': 'Average Shipping Cost'},
             text='AvgShippingCost')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AverageShippingCost DESC
""""""

average_shipping_costs = execute_sql_query(sql_query)

fig = px.bar(average_shipping_costs, x='ShipCity', y='AverageShippingCost',
             title='Average Shipping Costs by City',
             labels={'AverageShippingCost': 'Average Shipping Cost', 'ShipCity': 'City'})

show_to_user(fig)
```","The input Python code correctly follows the logic of the reference code. It calculates average shipping costs per city via a SQL query and uses Plotly Express to create a bar chart for visualization. The slight differences in variable names and the absence of text labels in the bar chart are inconsequential to the task requirements, which focus on identifying and visualizing which city has the highest average shipping cost.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch average freight cost by city
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AvgFreightCost 
FROM orders 
GROUP BY ShipCity 
ORDER BY AvgFreightCost DESC
""""""

# Execute the SQL query and get the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average shipping costs by city
fig = px.bar(df, x='ShipCity', y='AvgFreightCost', 
             title='Average Shipping Costs by City',
             labels={'ShipCity': 'City', 'AvgFreightCost': 'Average Freight Cost'})

# Display the bar chart
show_to_user(fig)
```","The provided Python code meets the requirements of the business analytics request, which is to find the city with the highest average shipping cost and visualize it using a bar chart. The logic of fetching data and creating a visualization is consistent with the reference implementation. Both codes execute a SQL query to calculate the average freight cost by city, sort the results in descending order of cost, and use Plotly Express to create a bar chart. The difference in variable names (AvgFreightCost vs. AvgShippingCost) doesn't affect the correctness, as both are equivalent in context. Therefore, the provided code is correct.",both
Determine which products have had discounts applied most frequently and provide a bar chart to visualize the frequency of discounts for each product.,"
import plotly.express as px
import pandas as pd

# SQL Query to fetch data
sql_query = """"""
SELECT p.ProductName, COUNT(od.Discount) AS DiscountCount
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE od.Discount > 0 
GROUP BY p.ProductName 
ORDER BY DiscountCount DESC;
""""""

# Execute SQL query and store the result in a DataFrame
discount_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the frequency of discounts for each product
fig = px.bar(discount_data, x='ProductName', y='DiscountCount', 
             title='Frequency of Discounts Applied to Products',
             labels={'ProductName': 'Product Name', 'DiscountCount': 'Discount Frequency'})

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, COUNT(od.Discount) AS DiscountFrequency
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
GROUP BY p.ProductID, p.ProductName
ORDER BY DiscountFrequency DESC
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductName', y='DiscountFrequency', title='Frequency of Discounts Applied to Products')
show_to_user(fig)
```","The input code correctly implements the logic from the reference code. Both codes calculate the frequency of discounts applied to products by joining the 'products' and 'Order Details' tables, filtering where the discount is greater than zero, and grouping by product. The column names and order are slightly different, but the essential logic and output are the same. Both implementations produce a bar chart to visualize the discount frequency.","```python
import pandas as pd
import plotly.express as px

# SQL Query to determine frequency of discounts for each product
sql_query = """"""
SELECT 
    p.ProductName, 
    COUNT(od.Discount) AS DiscountFrequency 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
WHERE 
    od.Discount > 0 
GROUP BY 
    p.ProductName 
ORDER BY 
    DiscountFrequency DESC;
""""""

# Execute the SQL query and get the result in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented and connects to the database
    # It executes the given SQL query and returns a pandas DataFrame
    pass

# Display the DataFrame to the user
def show_to_user(data):
    # This function is assumed to take a DataFrame or Plotly figure and display it
    pass

# Execute the SQL query to get the discount frequency data
discount_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    discount_data,
    x='ProductName',
    y='DiscountFrequency',
    title='Product Discount Frequency',
    labels={'ProductName': 'Product Name', 'DiscountFrequency': 'Frequency of Discounts'}
)

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly implements the logic specified in the business analytics request and matches the logic of the reference implementation. Both codes execute an SQL query to join the 'products' and '[Order Details]' tables, count how often a discount was applied per product, and then visualize this data with a Plotly bar chart. The differences in variable names ('DiscountCount' vs 'DiscountFrequency') and chart titles do not affect the overall correctness of the code.",both
Identify the countries with the most unique suppliers and visualize the results with a bar chart.,"```python
import plotly.express as px

# SQL query to get unique suppliers by country
sql_query = """"""
SELECT Country, COUNT(DISTINCT SupplierID) AS UniqueSuppliers 
FROM suppliers 
GROUP BY Country 
ORDER BY UniqueSuppliers DESC;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of unique suppliers by country
fig = px.bar(df, x='Country', y='UniqueSuppliers', title='Unique Suppliers by Country')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Country, COUNT(DISTINCT SupplierID) as UniqueSuppliers
FROM suppliers
GROUP BY Country
ORDER BY UniqueSuppliers DESC
""""""

supplier_data = execute_sql_query(sql_query)

fig = px.bar(supplier_data, x='Country', y='UniqueSuppliers', 
             title='Countries with the Most Unique Suppliers',
             labels={'UniqueSuppliers': 'Number of Unique Suppliers', 'Country': 'Country'})

show_to_user(fig)
```","The input Python code correctly retrieves and visualizes the data as specified in the business analytics request. It follows the same logic as the reference code: querying the database to count unique suppliers by country, ordering the results by the count, and using Plotly to create a bar chart. The differences, like some aesthetic adjustments with labels and title, do not affect the correctness of the implementation.","```python
import pandas as pd
import plotly.express as px

# Execute the provided SQL query to retrieve the data
sql_query = """"""
SELECT o.Country, COUNT(DISTINCT o.SupplierID) AS UniqueSuppliers
FROM suppliers o
GROUP BY o.Country
ORDER BY UniqueSuppliers DESC;
""""""
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of unique suppliers per country
fig = px.bar(df, x='Country', y='UniqueSuppliers', 
             title='Unique Suppliers by Country',
             labels={'UniqueSuppliers': 'Number of Unique Suppliers'})

# Display the plot
show_to_user(fig)
```","The input code correctly implements the business requirement by executing a SQL query that retrieves the number of unique suppliers per country using COUNT(DISTINCT o.SupplierID). It then utilizes Plotly to create a bar chart, similar to the reference code. The differences in implementation, such as alias usage in the SQL query, do not affect the core logic or outcome. Both codes aim to visualize the same data effectively.",both
Which employees are linked to the most orders? Include a bar chart to visualize the number of orders per employee.,"```python
import plotly.express as px

# Function to create bar chart showing number of orders per employee
def visualize_orders_per_employee():
    # SQL query to get count of orders per employee
    sql_query = """"""
    SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
    FROM orders 
    GROUP BY EmployeeID 
    ORDER BY OrderCount DESC;
    """"""
    
    # Execute SQL query
    df = execute_sql_query(sql_query)
    
    # Create a bar chart using plotly for visualization
    fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Number of Orders per Employee')
    
    # Display the visualization to the user
    show_to_user(fig)

# Call the function
visualize_orders_per_employee()
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of orders per employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
orders_per_employee = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_per_employee, x='EmployeeID', y='OrderCount', 
             title='Number of Orders per Employee', 
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'})

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code performs the same task as the reference implementation. Both scripts execute a SQL query to count the number of orders per employee, and then use Plotly to create a bar chart visualizing the results. The input code adds labels to the axes in the plot, but this does not affect the correctness relative to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Execute SQL query to get the number of orders per employee.
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS NumberOfOrders 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID 
ORDER BY NumberOfOrders DESC;
""""""

# Function to simulate the utility function that executes SQL and returns a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for the purpose of this example. Replace with actual DB connection code.
    return pd.DataFrame({
        'EmployeeID': [1, 2, 3],
        'NumberOfOrders': [150, 120, 100]
    })

# Function to simulate the utility function to show results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the query
df_orders_per_employee = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of orders per employee
fig = px.bar(
    df_orders_per_employee,
    x='EmployeeID',
    y='NumberOfOrders',
    title='Number of Orders per Employee',
    labels={'NumberOfOrders': 'Number of Orders', 'EmployeeID': 'Employee ID'}
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to count the number of orders per employee, joins the 'employees' and 'orders' tables, and groups the results by EmployeeID. It then orders the results by the number of orders in descending order, akin to the reference implementation. Although the input includes a join on the 'employees' table, this does substantively match the intended outcome, assuming employees without orders are not relevant. Both codes use Plotly to generate a bar chart visualizing the data correctly. The differences in labels and simulation of database interaction do not affect the correctness concerning the business question.",both
"Which city has the highest number of orders placed in 2023, and can you provide a bar chart to visualize the number of orders across all cities?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per city in 2023
sql_query = """"""
SELECT orders.ShipCity, COUNT(orders.OrderID) AS num_orders 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY orders.ShipCity 
ORDER BY num_orders DESC
""""""

# Execute the SQL query
city_orders_df = execute_sql_query(sql_query)

# Extract the city with the highest number of orders
if not city_orders_df.empty:
    top_city = city_orders_df.iloc[0]

# Visualize the number of orders across all cities using a bar chart
fig = px.bar(city_orders_df, x='ShipCity', y='num_orders', 
             title='Number of Orders by City in 2023',
             labels={'num_orders': 'Number of Orders', 'ShipCity': 'City'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
# SQL query to get the number of orders per city in 2023
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS num_orders
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY ShipCity
ORDER BY num_orders DESC
""""""

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Get the city with the highest number of orders
top_city = order_data.iloc[0]

# Create a bar chart to visualize the number of orders across all cities
import plotly.express as px

fig = px.bar(order_data, x='ShipCity', y='num_orders', title='Number of Orders per City in 2023')
show_to_user(fig)

top_city
```","The input code fulfills both parts of the request: identifying the city with the highest number of orders and generating a bar chart of orders per city. It follows the same logic as the reference code, querying the database and using Plotly for visualization. Both implementations extract the top city using 'iloc[0]'. Differences in variable names and slight changes in plot labels don't affect functionality.","```python
import plotly.express as px
import pandas as pd

# Execute the SQL query to get the number of orders per city for 2023
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS TotalOrders 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY ShipCity 
ORDER BY TotalOrders DESC;
""""""
orders_df = execute_sql_query(sql_query)

# Find the city with the highest number of orders
top_city = orders_df.iloc[0]
show_to_user(top_city)

# Create a bar chart for the number of orders across all cities
fig = px.bar(
    orders_df, 
    x='ShipCity', 
    y='TotalOrders', 
    title='Number of Orders by City in 2023',
    labels={'TotalOrders': 'Total Orders', 'ShipCity': 'City'}
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly replicates the logic and outcome of the reference code. Both perform an SQL query to retrieve the number of orders per city for 2023, group by city, and sort by the number of orders in descending order. They then identify the top city and display a bar chart visualizing the number of orders across all cities. The minor differences in variable names ('TotalOrders' vs 'num_orders') do not affect the correctness of the logic or the intended output of the analysis.",both
"How many products have zero units in stock, and provide a bar chart visualization of the count by product category?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of products with zero stock by category
sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS NumberOfProductsWithZeroStock
FROM products
WHERE UnitsInStock = 0
GROUP BY CategoryID;
""""""

# Execute the SQL query and store result in a DataFrame
df_zero_stock_by_category = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(
    df_zero_stock_by_category,
    x='CategoryID',
    y='NumberOfProductsWithZeroStock',
    title='Count of Products with Zero Stock by Product Category',
    labels={'CategoryID': 'Product Category', 'NumberOfProductsWithZeroStock': 'Number of Products'}
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, COUNT(*) as ZeroStockCount
FROM products p
WHERE p.UnitsInStock = 0
GROUP BY p.CategoryID
""""""
zero_stock_df = execute_sql_query(sql_query)

fig = px.bar(zero_stock_df, x='CategoryID', y='ZeroStockCount', title='Count of Products with Zero Units in Stock by Category')
show_to_user(fig)
```","The input code correctly counts the number of products with zero units in stock for each product category using a SQL query that matches the logic of the reference implementation. Both codes group by CategoryID and count the products with zero stock. Additionally, both implementations use Plotly Express to create a bar chart visualizing the counts by category, with appropriate titles and labels. Therefore, while variable names differ, the input code is logically consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get product count with zero units in stock and their categories
sql_query = """"""
SELECT Category, COUNT(*) as ZeroStockProducts 
FROM products 
WHERE UnitsInStock = 0 
GROUP BY Category;
""""""

# Execute the SQL query using the utility function
zero_stock_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly for visualization
fig = px.bar(zero_stock_df, x='Category', y='ZeroStockProducts', 
             title='Count of Products with Zero Units in Stock by Category',
             labels={'ZeroStockProducts': 'Number of Zero Stock Products'})

# Display the visualization using the utility function
show_to_user(fig)
```","The input Python code correctly queries the count of products with zero units in stock by category. The SQL query and logic match the reference implementation. The variable names for the category and the count are different but have the same effect. The bar chart is created using Plotly, similar to the reference code, and displays the results correctly. Therefore, the input code meets the business analytics request effectively.",both
Analyze the correlation between employee job title and sales performance and provide visualizations to illustrate the relationship.,"import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT employees.Title, AVG(TotalSales) AS AverageSales
FROM (
    SELECT employees.Title, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
    FROM employees
    JOIN orders ON employees.EmployeeID = orders.EmployeeID
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
    GROUP BY employees.EmployeeID, employees.Title
) AS EmployeeSales
GROUP BY employees.Title;
""""""

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would contain the logic to execute a SQL query
    # and return the result as a pandas DataFrame.
    # For demonstration purposes, we will assume it returns the following DataFrame.
    return pd.DataFrame({
        'Title': ['Junior Sales Associate', 'Senior Sales Executive', 'Sales Manager'],
        'AverageSales': [15000, 30000, 45000]
    })

# Function to display data
def show_to_user(data):
    # This function would normally include logic to display a DataFrame or Plotly figure.
    # For simplicity, this is just a placeholder for demonstration.
    print(data)

# Execute the SQL query and retrieve the data
data = execute_sql_query(sql_query)

# Create a Plotly visualization
fig = px.bar(data, x='Title', y='AverageSales', 
             title='Correlation Between Job Title and Sales Performance',
             labels={'Title': 'Job Title', 'AverageSales': 'Average Sales'},
             color='AverageSales')

# Show the visualization
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.Title, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.Title
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='Title', y='TotalSales', title='Employee Sales Performance by Job Title', 
             labels={'Title': 'Job Title', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code directly sums TotalSales grouped by Title, whereas the reference code calculates the average sales per employee before grouping by Title to get the average sales by job title. The input code fails to calculate an average, missing the logic used in the reference implementation.","```python
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Assume get_data_from_database and show_to_user are predefined functions

# Function to analyze job title and sales performance correlation
def analyze_job_title_sales_performance():
    # SQL query to fetch data
    sql_query = """"""
    SELECT titles.TitleName, SUM([Order Details].UnitPrice * [Order Details].Quantity * 
    (1 - [Order Details].Discount)) AS TotalSales FROM employees 
    JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
    JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
    JOIN titles ON employees.EmployeeID = titles.EmployeeID 
    JOIN [Order Details] ON employees.EmployeeID = [Order Details].EmployeeID 
    GROUP BY titles.TitleName;
    """"""
    
    # Execute the query using the utility function
    df = get_data_from_database(sql_query)

    # Create a bar plot to visualize the correlation between job titles and total sales
    plt.figure(figsize=(12, 6))
    sns.barplot(data=df, x='TitleName', y='TotalSales')
    
    plt.title('Correlation between Job Title and Sales Performance')
    plt.xlabel('Job Title')
    plt.ylabel('Total Sales')
    
    # Show visualization using the utility function
    show_to_user(plt)
    
    # Optionally, show the DataFrame for additional insights
    show_to_user(df)

# Execute the analysis
analyze_job_title_sales_performance()
```","The input code does not align with the reference implementation due to differences in the SQL query logic and dataset joins. Specifically, the input uses additional joins such as `employeeTerritories` and `territories` which are not present in the reference implementation. Moreover, the calculation of `TotalSales` groups by `titles.TitleName` instead of `employees.Title`, leading to a potential mismatch in results. The visualization part also differs by using seaborn and matplotlib instead of Plotly, which is acceptable but equally important is ensuring the data queried and visualized are consistent with the problem statement and reference logic.",None
"What is the average order fulfillment time for each month, and can you provide a line chart to visualize the trends?","```python
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the given SQL query and return a DataFrame
    # For the purpose of this example, let's assume it returns a mock DataFrame
    data = {
        'Month': ['2023-01', '2023-02', '2023-03'],
        'AvgFulfillmentTime': [5.2, 4.8, 5.5]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This function should display data or a plot to the user
    # Can handle both pandas DataFrame and Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to calculate average fulfillment time per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query and get results as a DataFrame
df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize trends
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Average Order Fulfillment Time Per Month', 
              labels={'AvgFulfillmentTime': 'Avg Fulfillment Time (Days)'})

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS average_fulfillment_time
FROM 
    orders
GROUP BY 
    month
ORDER BY 
    month;
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)

fig = px.line(average_fulfillment_time_df, x='month', y='average_fulfillment_time', 
              title='Average Order Fulfillment Time by Month', 
              labels={'average_fulfillment_time': 'Average Fulfillment Time (Days)', 'month': 'Month'})
show_to_user(fig)
```","The input code correctly calculates the average fulfillment time for each month using a SQL query that mirrors the logic of the reference implementation. It utilizes DATE_FORMAT and AVG(DATEDIFF(...)) to compute the average time. Furthermore, it uses Plotly to create a line chart with appropriate titles and labels, just like the reference implementation, adhering to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function will execute the SQL query and return a pandas DataFrame
    # Replace with actual implementation
    pass

def show_to_user(data):
    # This function will show the data to the user
    # Replace with actual implementation
    pass

# SQL query from the business analytic request
sql_query = """"""
SELECT
    EXTRACT(MONTH FROM orders.OrderDate) AS month,
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time
FROM orders
GROUP BY month
ORDER BY month;
""""""

# Execute the query to get data
df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize the average fulfillment time per month
fig = px.line(df, x='month', y='avg_fulfillment_time', title='Avg Order Fulfillment Time per Month')

# Display the line chart using the utility function
show_to_user(fig)
```","The reference code uses `DATE_FORMAT` for formatting dates as 'YYYY-MM' strings, whereas the input code uses `EXTRACT(MONTH FROM ...)`, which only extracts the month as a number. This leads to differences in data aggregation and representation, as the input code doesn't handle years. Additionally, the input code lacks a realistic implementation of `execute_sql_query`, which suggests it doesn't fulfill the request completely as intended.",Base
Identify orders with a shipping delay greater than 7 days and create a bar chart to show the number of delays per product category.,"```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = """"""
SELECT OrderID, ProductCategory
FROM orders
WHERE ShippedDate > RequiredDate + INTERVAL '7' DAY;
""""""

# Step 2: Execute the SQL query and retrieve data
delayed_orders_df = execute_sql_query(sql_query)

# Step 3: Count delays per product category
delays_per_category = delayed_orders_df['ProductCategory'].value_counts().reset_index()
delays_per_category.columns = ['ProductCategory', 'DelayCount']

# Step 4: Create a bar chart using Plotly
fig = px.bar(delays_per_category, x='ProductCategory', y='DelayCount',
             title='Number of Shipping Delays per Product Category',
             labels={'ProductCategory': 'Product Category', 'DelayCount': 'Number of Delays'})

# Step 5: Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(DATEDIFF(o.ShippedDate, o.RequiredDate) > 7) AS DelayCount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    DATEDIFF(o.ShippedDate, o.RequiredDate) > 7
GROUP BY 
    od.ProductID
""""""

delays_df = execute_sql_query(sql_query)

fig = px.bar(delays_df, 
              x='ProductID', 
              y='DelayCount', 
              title='Number of Shipping Delays Greater than 7 Days per Product Category',
              labels={'ProductID': 'Product ID', 'DelayCount': 'Number of Delays'})

show_to_user(fig)
```","The input code does not align with the business analytics request. It groups delays by 'ProductID' instead of 'ProductCategory', which is necessary for addressing the request. Furthermore, the code incorrectly attempts to use 'SUM' on a condition in the SELECT clause, instead of utilizing 'COUNT' or simply counting occurrences of the grouped category in a subsequent DataFrame operation. Therefore, it doesn't adhere to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for executing the SQL query.
    # In a real scenario, this function would interface with a database.
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data.head())
    else:
        data.show()

# SQL query to fetch orders with a shipping delay greater than 7 days
sql_query = """"""
SELECT orders.OrderID, orders.ProductCategory 
FROM orders 
WHERE DATEDIFF(orders.ShippedDate, orders.RequiredDate) > 7;
""""""

# Execute the SQL query and get the results in a DataFrame
delayed_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to display the number of delays per product category
fig = px.bar(delayed_orders_df, x='ProductCategory', title='Shipping Delays per Product Category')

# Show the bar chart to the user
show_to_user(fig)
```","The input code lacks the critical step of counting delays per product category, as performed in the reference code using 'value_counts' to compute 'DelayCount'. The 'px.bar' function in the input code directly uses 'delayed_orders_df' but does not aggregate the delay counts, which means the resulting chart might not display the required delays per category correctly.",None
"How many products are currently at or above their reorder level, and can you provide a bar chart to visualize the count of products by category?","
import pandas as pd
import plotly.express as px

# SQL query to get the count of products at or above their reorder level
sql_query_count = """"""
SELECT COUNT(*) AS AtOrAboveReOrder
FROM products
WHERE UnitsInStock >= ReorderLevel;
""""""

# SQL query to get products by category where UnitsInStock >= ReorderLevel
sql_query_category = """"""
SELECT Category, COUNT(*) AS ProductCount
FROM products
WHERE UnitsInStock >= ReorderLevel
GROUP BY Category;
""""""

# Execute SQL queries
df_count = execute_sql_query(sql_query_count)
df_category = execute_sql_query(sql_query_category)

# Visualization: Bar chart of products by category
fig = px.bar(df_category, x='Category', y='ProductCount', title='Count of Products by Category at or Above Reorder Level')

# Display results
show_to_user(df_count)
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID, 
    COUNT(*) AS ProductCount
FROM 
    products p
WHERE 
    p.UnitsInStock >= p.ReorderLevel AND 
    p.Discontinued = 0
GROUP BY 
    p.CategoryID
""""""

product_counts = execute_sql_query(sql_query)

fig = px.bar(product_counts, x='CategoryID', y='ProductCount', title='Count of Products by Category at or Above Reorder Level')
show_to_user(fig)
```","The input code evaluates products at or above reorder level but adds an extra condition (p.Discontinued = 0), which is not in the reference implementation. Additionally, it uses CategoryID instead of Category, which implies a potential mismatch in the category field used, potentially leading to different categorization results.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to count products at or above reorder level
sql_query_count = ""SELECT COUNT(*) AS product_count FROM products WHERE UnitsInStock >= ReorderLevel;""
products_count_df = execute_sql_query(sql_query_count)

# Display the number count to the user
show_to_user(products_count_df)

# Execute SQL query to get count of products by category
sql_query_category_count = """"""
SELECT CategoryID, COUNT(*) as product_count 
FROM products 
WHERE UnitsInStock >= ReorderLevel 
GROUP BY CategoryID;
""""""
category_count_df = execute_sql_query(sql_query_category_count)

# Create a bar chart to visualize count of products by category
fig = px.bar(
    category_count_df, 
    x='CategoryID', 
    y='product_count', 
    title='Count of Products by Category',
    labels={'CategoryID': 'Category', 'product_count': 'Product Count'}
)

# Display the bar chart
show_to_user(fig)
```","The provided code correctly executes SQL queries to count products at or above the reorder level and groups them by category. It uses 'CategoryID' instead of 'Category', but the logic aligns with the reference implementation by grouping and counting products where 'UnitsInStock' is greater than or equal to 'ReorderLevel'. The code then generates a bar chart with appropriate titles and labels to visualize the result, meeting the requirements of the business analytics request.",Finetuned
"What is the current inventory turnover ratio, and can we visualize it with a trend line over the past year?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the inventory turnover ratio
sql_query_turnover_ratio = """"""
SELECT 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS turnover_ratio
FROM 
    products 
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID;
""""""

# Execute the SQL query and get the turnover ratio
overall_turnover_df = execute_sql_query(sql_query_turnover_ratio)

# Display the current inventory turnover ratio
show_to_user(overall_turnover_df)

# SQL query to get inventory turnover data over the past year
sql_query_trend = """"""
SELECT 
    DATE_FORMAT([Order Details].OrderDate, '%Y-%m') AS order_month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS turnover_ratio
FROM 
    products 
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID
WHERE 
    [Order Details].OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    order_month
ORDER BY 
    order_month;
""""""

# Execute the SQL query to get data over the past year
trend_df = execute_sql_query(sql_query_trend)

# Plot a trend line for inventory turnover ratio over the past year
fig = px.line(trend_df, x='order_month', y='turnover_ratio', title='Inventory Turnover Ratio Trend Over the Past Year')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.Quantity * od.UnitPrice) AS COGS,
    AVG(p.UnitsInStock) AS avg_inventory
FROM
    products p
JOIN
    [Order Details] od ON p.ProductID = od.ProductID
JOIN
    orders o ON od.OrderID = o.OrderID
WHERE
    o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 year')
GROUP BY
    month
ORDER BY
    month;
""""""

inventory_data = execute_sql_query(sql_query)
inventory_data['Inventory_Turnover_Ratio'] = inventory_data['COGS'] / inventory_data['avg_inventory']

fig = px.line(inventory_data, x='month', y='Inventory_Turnover_Ratio', title='Inventory Turnover Ratio Trend Over The Past Year')
show_to_user(fig)
```","The input Python code calculates a monthly inventory turnover ratio for the past year using the sum of cost of goods sold (COGS) and the average inventory. This is similar to the reference code logic which uses the total sales [Order Details].Quantity * [Order Details].UnitPrice and divides it by the average number of units in stock (products.UnitsInStock). Both codes aim to visualize the trend of the inventory turnover ratio over the past year using a line plot. The key operations and calculations closely align, making the input code correct in terms of functionality and logic compared to the reference code.","
import pandas as pd
import plotly.express as px

# SQL query to fetch historical inventory turnover data
sql_query = """"""
SELECT 
    Year, 
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS inventory_turnover_ratio 
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID 
WHERE 
    YEAR(od.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY 
    Year;
""""""

# Execute the SQL query and retrieve data
inventory_turnover_df = execute_sql_query(sql_query)

# Check if data is not empty
if not inventory_turnover_df.empty:
    # Visualizing the inventory turnover ratio trend
    fig = px.line(
        inventory_turnover_df, 
        x='Year', 
        y='inventory_turnover_ratio', 
        title='Inventory Turnover Ratio Trend Over the Past Year'
    )

    # Display the visualization
    show_to_user(fig)
else:
    # Display a message if no data is found
    show_to_user(pd.DataFrame({'Message': ['No data available for the current year']}))
","The provided code differs significantly in logic and implementation from the reference code. The reference code calculates and displays both the current inventory turnover ratio and its monthly trend over the past year using a specific SQL query and formats the month using DATE_FORMAT. However, the provided code only attempts to calculate the turnover ratio for the current year and lacks the trend component. Additionally, the reference code groups by 'order_month' while the input code groups by 'Year', which does not align with the reference requirement of providing a monthly trend.",Base
"What is the correlation between employee sales and years of service, and can it be visualized with a scatter plot to enhance understanding?","```python
import pandas as pd
import plotly.express as px
from scipy.stats import pearsonr

# Assuming execute_sql_query and show_to_user are defined elsewhere as per environment constraints

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       (YEAR(CURDATE()) - YEAR(employees.HireDate)) AS years_of_service, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query and load the data into a DataFrame
df = execute_sql_query(sql_query)

# Calculate the correlation between employee sales and years of service
correlation, _ = pearsonr(df['years_of_service'], df['employee_sales'])
print(f""Correlation between employee sales and years of service: {correlation}"")

# Create a scatter plot with Plotly
fig = px.scatter(df, x='years_of_service', y='employee_sales',
                 labels={'years_of_service': 'Years of Service', 'employee_sales': 'Employee Sales'},
                 title=f'Scatter Plot of Employee Sales vs. Years of Service (Correlation: {correlation:.2f})')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS employee_sales, 
    DATEDIFF(CURDATE(), e.HireDate) / 365 AS years_of_service
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
""""""

data = execute_sql_query(sql_query)

correlation = data[['employee_sales', 'years_of_service']].corr().iloc[0, 1]

fig = px.scatter(data, x='years_of_service', y='employee_sales', 
                 title=f'Correlation between Employee Sales and Years of Service: {correlation:.2f}',
                 labels={'years_of_service': 'Years of Service', 'employee_sales': 'Employee Sales'})

show_to_user(fig)
```","The input code correctly computes the correlation between employee sales and years of service using SQL. It then calculates the correlation coefficient using Pandas' .corr() method, similar to the scipy pearsonr function in the reference code. Both implementations use a scatter plot with Plotly to visualize the correlation, adhering to the same logic and achieving the same outcome as the reference implementation.","Sure, I can write the necessary Python code to perform the correlation analysis and visualize it with a scatter plot.

```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT EmployeeID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS EmployeeSales, 
    (YEAR(CURRENT_DATE) - YEAR(HireDate)) AS YearsOfService 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate database access
    # In practice, this would execute the SQL and return a DataFrame
    pass

# Function to display data to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate correlation
correlation = df[['EmployeeSales', 'YearsOfService']].corr().iloc[0, 1]
print(f""Correlation between EmployeeSales and YearsOfService: {correlation}"")

# Visualize the correlation with a scatter plot
fig = px.scatter(df, x='YearsOfService', y='EmployeeSales',
                 title='Scatter Plot of Employee Sales vs Years of Service',
                 labels={'EmployeeSales':'Employee Sales', 'YearsOfService':'Years of Service'},
                 trendline='ols')
                 
# Display the plot
show_to_user(fig)
```

### Explanation of the Code:
1. **SQL Query Execution**: The code includes a function `execute_sql_query` that is a placeholder for executing the provided SQL query. You'll need to implement the actual DB connection and query execution logic.

2. **Correlation Calculation**: The correlation between `EmployeeSales` and `YearsOfService` is calculated using the `.corr()` method of pandas, specifically targeting the two columns.

3. **Scatter Plot Visualization**: The results are visualized using Plotly's `px.scatter`, creating a scatter plot that includes a trendline to better illustrate the correlation.

4. **User Interaction**: Finally, the correlation value and visualization are prepared to either print or show using the `show_to_user` function. The scatter plot allows for a better understanding of the relationship between employee sales and years of service.","The input Python code fulfills the business analytics request and aligns logically with the reference implementation. Both scripts execute a similar SQL query to retrieve the necessary data, compute the correlation between employee sales and years of service using the appropriate methods (albeit differently with pandas corr and scipy pearsonr), and visualize the results using Plotly for a scatter plot. These differences in implementation approach do not alter the correctness of the solution. The inclusion of a trendline in the input code is an enhancement and does not deviate from the request's requirements.",both
"Which city has received the highest number of shipments, and can you provide a bar chart to visualize the comparison among the top cities?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get shipments count by city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS Shipments 
FROM orders 
GROUP BY ShipCity 
ORDER BY Shipments DESC;
""""""

# Execute the query using the utility function
shipment_data = execute_sql_query(sql_query)

# Print the city with the highest number of shipments
print(f""The city with the highest number of shipments is: {shipment_data.iloc[0]['ShipCity']}"")

# Create a bar chart to visualize the top cities
fig = px.bar(shipment_data, x='ShipCity', y='Shipments', title='Shipments by City')

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipCity
ORDER BY ShipmentCount DESC
LIMIT 10;
""""""

top_cities_df = execute_sql_query(sql_query)

fig = px.bar(top_cities_df, x='ShipCity', y='ShipmentCount', 
             title='Top Cities by Number of Shipments', 
             labels={'ShipCity': 'City', 'ShipmentCount': 'Number of Shipments'})

show_to_user(fig)
```","The input code correctly executes a query to get the cities with the highest number of shipments and creates a bar chart to visualize the data. Although the input code limits the results to the top 10 cities, the primary goal—identifying the city with the highest number of shipments and creating a visualization—is achieved. The logic corresponds with the reference implementation by effectively querying, organizing, and visualizing shipment data.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function - the actual implementation will run the query and return a DataFrame
    pass

# Placeholder function to show results to the user
def show_to_user(data):
    # Placeholder function - the actual implementation will display the DataFrame or Plotly figure
    pass

# SQL query to get the top cities by shipment count
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS NumberOfShipments 
FROM orders 
GROUP BY ShipCity 
ORDER BY NumberOfShipments DESC
""""""

# Execute the SQL query to get the data into a DataFrame
df_shipments = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top cities by shipment count
fig = px.bar(
    df_shipments,
    x='ShipCity',
    y='NumberOfShipments',
    title='Top Cities by Number of Shipments',
    labels={'ShipCity': 'City', 'NumberOfShipments': 'Number of Shipments'}
)

# Display the bar chart
show_to_user(fig)
```","The input code does not print the city with the highest number of shipments, whereas the reference code does. This omission means the input code does not fully satisfy the business analytics request.",Base
"Calculate the percentage of orders shipped on time, and create a pie chart to visualize the proportion of orders shipped on time versus late.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are defined elsewhere
def calculate_and_visualize_on_time_percentage():
    # SQL query to calculate on-time shipment percentage
    sql_query = '''
    SELECT 
        (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID)) AS OnTimePercentage,
        COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) AS LateOrders
    FROM orders;
    '''

    # Execute the SQL query
    result_df = execute_sql_query(sql_query)

    # Calculate the percentage of late orders
    on_time_percent = result_df.at[0, 'OnTimePercentage']
    late_percent = 100.0 - on_time_percent

    # Create a DataFrame for the pie chart
    pie_data = pd.DataFrame({
        'Status': ['On Time', 'Late'],
        'Percentage': [on_time_percent, late_percent]
    })

    # Create a pie chart using Plotly
    fig = px.pie(pie_data, names='Status', values='Percentage',
                 title='Orders Shipped On Time vs Late')

    # Display the pie chart
    show_to_user(fig)

# Execute the function
calculate_and_visualize_on_time_percentage()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTime,
    COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) AS Late
FROM orders
""""""

data = execute_sql_query(sql_query)

on_time = data['OnTime'].iloc[0]
late = data['Late'].iloc[0]

labels = ['On Time', 'Late']
values = [on_time, late]

fig = px.pie(values=values, names=labels, title='Proportion of Orders Shipped On Time vs Late')
show_to_user(fig)
```","Both implementations accomplish the task of calculating the proportion of on-time versus late orders and visualizing it using a pie chart. The evaluated code computes the count of on-time and late orders, directly using these counts to visualize the proportions with Plotly. Unlike the reference code, it does not explicitly calculate the percentage of on-time orders, but the pie chart representation ultimately displays the same information using the counts. Thus, the logic aligns with the business request, even though the implementation details differ.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to calculate on-time and late orders
sql_query = """"""
SELECT 
    COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN orders.OrderID END) AS on_time_orders, 
    COUNT(CASE WHEN orders.ShippedDate > orders.RequiredDate THEN orders.OrderID END) AS late_orders 
FROM orders;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate raw counts and the percentage
on_time_orders = orders_df['on_time_orders'][0]
late_orders = orders_df['late_orders'][0]
total_orders = on_time_orders + late_orders
on_time_percentage = (on_time_orders / total_orders) * 100

# Prepare data for visualization
data = {
    'Category': ['On Time', 'Late'],
    'Count': [on_time_orders, late_orders]
}
df = pd.DataFrame(data)

# Create pie chart with Plotly
fig = px.pie(df, names='Category', values='Count', title='Proportion of Orders Shipped On Time vs Late')

# Show the pie chart
show_to_user(fig)

# Optionally, show the on-time percentage to the user
on_time_df = pd.DataFrame({'On Time Percentage': [on_time_percentage]})
show_to_user(on_time_df)
```","The input code computes the percentage and number of on-time and late orders using a SQL query that aligns with logic in the reference implementation. It also calculates on-time percentage and total orders. The pie chart visualization uses the on-time and late counts directly, akin to the reference code's approach using percentages. The final visualization and output effectively satisfy the business analytics request.",both
"List all orders with their shipment region and corresponding total order value, and provide a data visualization to compare total order values across different regions.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the orders with their shipment region and total order value
sql_query = """"""
SELECT o.OrderID, o.ShipRegion, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.OrderID, o.ShipRegion;
""""""

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: replace with actual implementation to execute the SQL query
    # and fetch results into a pandas DataFrame.
    pass

# Utility function to display data or visualization
def show_to_user(data):
    # Placeholder function: replace with actual implementation to show the data or visualization to the user
    pass

# Executing the query and getting the DataFrame
orders_df = execute_sql_query(sql_query)

# Grouping data by ShipRegion to get the sum of order values per region
region_order_values = orders_df.groupby('ShipRegion')['OrderValue'].sum().reset_index()

# Creating the visualization using Plotly
fig = px.bar(region_order_values, 
             x='ShipRegion', 
             y='OrderValue', 
             title='Total Order Values by Shipment Region', 
             labels={'OrderValue': 'Total Order Value', 'ShipRegion': 'Shipment Region'})

# Displaying the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve orders with shipment region and total order value
sql_query = """"""
SELECT 
    o.ShipRegion, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.ShipRegion
""""""

# Execute the SQL query
order_values = execute_sql_query(sql_query)

# Create the bar chart for total order values across different regions
fig = px.bar(order_values, x='ShipRegion', y='TotalOrderValue', 
             title='Total Order Values by Shipment Region', 
             labels={'TotalOrderValue': 'Total Order Value', 'ShipRegion': 'Shipment Region'})

# Display the chart to the user
show_to_user(fig)
```",The input code does not adhere to the full requirements of the business analytics request. It only lists total order values by region but does not include individual order details such as the OrderID with the shipment region. This deviates from the logic specified in the reference implementation which provides a breakdown by orders as well.,"```python
import plotly.express as px
import pandas as pd

# Step 1: Execute the provided SQL query to get the order data
sql_query = """"""
SELECT o.OrderID, o.ShipRegion, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.OrderID, o.ShipRegion;
""""""

# Execute the query
order_data = execute_sql_query(sql_query)

# Step 2: Visualize the total order values across different regions
order_summary = order_data.groupby('ShipRegion', as_index=False).sum(numeric_only=True)
fig = px.bar(order_summary, x='ShipRegion', y='OrderValue', title='Total Order Values by Shipment Region')

# Step 3: Display the result
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request by executing a SQL query to retrieve order data with the shipment region and order value. It then groups the data by 'ShipRegion' and visualizes the total order values across different regions using a bar chart from Plotly. Despite minor differences, such as using 'as_index=False' in groupby and 'numeric_only=True' in sum, the logic aligns with the reference implementation, and the objective is met.",Finetuned
"Find the employee with the highest average order value and visualize the results using a bar chart.""
","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AvgOrderValue 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY AvgOrderValue DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
# Plotly is used for graph visualization
fig = px.bar(result_df, x='EmployeeID', y='AvgOrderValue', 
             title='Employee with Highest Average Order Value',
             labels={'AvgOrderValue': 'Average Order Value', 'EmployeeID': 'Employee ID'})

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY AverageOrderValue DESC
LIMIT 1
""""""
highest_avg_order_value_df = execute_sql_query(sql_query)

fig = px.bar(highest_avg_order_value_df, 
             x='FirstName', 
             y='AverageOrderValue',
             title='Employee with Highest Average Order Value',
             labels={'FirstName': 'Employee Name', 'AverageOrderValue': 'Average Order Value'})
show_to_user(fig)
```","The code correctly executes a SQL query to find the employee with the highest average order value, similar to the reference code. Although it adds FirstName and LastName to the selection and visualization, this does not change the underlying logic or results of identifying the employee with the highest average order value. The visualization also remains correct, showing the employee's name instead of ID, which is an acceptable variation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT EmployeeID, AVG([UnitPrice] * [Quantity] * (1 - Discount)) AS AverageOrderValue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY EmployeeID 
ORDER BY AverageOrderValue DESC
LIMIT 1
""""""

# Execute the query and get the result as a DataFrame
employee_data_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average order value
fig = px.bar(
    employee_data_df,
    x='EmployeeID',
    y='AverageOrderValue',
    title='Employee with Highest Average Order Value',
    labels={'AverageOrderValue': 'Average Order Value'}
)

# Show the visualization to the user
show_to_user(fig)
```","The input code does not correctly implement the specified logic from the reference code. The primary difference is that the SQL query in the input code omits JOINing the 'employees' table to match with 'orders', which means it doesn't correctly find the EmployeeID for employees. The reference query involves JOINs with both 'employees' and 'orders', while the input version only JOINs 'Order Details' and 'orders'. This would result in a mismatch in identifying the correct employee with the highest average order value.",Base
"What is the average age of employees who have made a sale in the last year, and can you provide a histogram of their ages?","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user functions are provided and available.

# SQL query to retrieve employee ages who made sales in the last year.
sql_query = """"""
SELECT DATEDIFF(CURRENT_DATE, e.BirthDate) / 365 AS Age
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
""""""

# Execute the SQL query and store the result in a DataFrame
ages_df = execute_sql_query(sql_query)

# Calculate the average age
average_age = ages_df['Age'].mean()

# Display the average age
show_to_user(pd.DataFrame({'AverageAge': [average_age]}))

# Create and display a histogram of ages
fig = px.histogram(ages_df, x='Age', title='Histogram of Employee Ages')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Define the date one year ago
one_year_ago = datetime.now().date() - pd.DateOffset(years=1)

# SQL query to get employees who made a sale in the last year
sql_query = f""""""
SELECT e.EmployeeID, e.BirthDate
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= '{one_year_ago}'
""""""

# Execute the query
sales_data = execute_sql_query(sql_query)

# Calculate age
sales_data['Age'] = (pd.to_datetime(datetime.now().date()) - pd.to_datetime(sales_data['BirthDate'])).dt.days // 365

# Calculate average age
average_age = sales_data['Age'].mean()

# Create a histogram of ages
fig = px.histogram(sales_data, x='Age', title='Histogram of Ages of Employees Who Made Sales in the Last Year')
show_to_user(fig)

average_age
```","The input code correctly retrieves the employees' birthdates and calculates their ages for those who made sales in the last year. The average age is calculated using the mean function on the age column. It also utilizes Plotly to generate a histogram of these ages. Although the SQL query syntax and calculation method for age differ slightly, it achieves the same logic and result as the reference implementation, thus answering the business question correctly.","```python
import pandas as pd
import plotly.express as px

# Assuming the following utility functions are available
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function connects to the database, executes the SQL query,
    # and returns the result as a pandas DataFrame.
    pass

def show_to_user(data):
    # Displays data or a visualization to the user.
    pass

# SQL Query to retrieve average age of employees
average_age_sql = """"""
SELECT AVG(YEAR(CURRENT_DATE) - YEAR(E. birthdate)) AS average_age 
FROM employees E 
JOIN orders O ON E.EmployeeID = O.EmployeeID 
WHERE O.OrderDate > CURRENT_DATE - INTERVAL 1 YEAR;
""""""

# Execute the SQL query
average_age_df = execute_sql_query(average_age_sql)

# Display the average age result
show_to_user(average_age_df)

# SQL Query to retrieve ages of employees who made sales in the last year
ages_sql = """"""
SELECT YEAR(CURRENT_DATE) - YEAR(E.birthdate) AS age
FROM employees E 
JOIN orders O ON E.EmployeeID = O.EmployeeID 
WHERE O.OrderDate > CURRENT_DATE - INTERVAL 1 YEAR;
""""""

# Execute the SQL query to get ages
ages_df = execute_sql_query(ages_sql)

# Create a histogram of their ages
fig = px.histogram(ages_df, x='age', title='Histogram of Employee Ages Who Made Sales in the Last Year')

# Display the histogram
show_to_user(fig)
```","The input code does not match the reference code's logic for calculating average age. It calculates average age directly in SQL, averaging only whole years, whereas the reference implementation calculates exact ages by factoring in the day and month from 'BirthDate'. Additionally, the reference uses 'DATEDIFF' to achieve more precision in age calculation and calculates the average in Python. The histogram logic is correct, but the discrepancy in average age calculation makes the input incorrect overall.",Base
What is the sum of all discounts given on 'Order Details' and can this be visualized over time to identify trends?,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the sum of all discounts over time
sql_query = """"""
SELECT SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscounts, o.OrderDate
FROM [Order Details] od
JOIN Orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderDate
ORDER BY o.OrderDate;
""""""

# Fetch data using the utility function
discounts_over_time = execute_sql_query(sql_query)

# Visualize the trend of discounts over time
fig = px.line(discounts_over_time, x='OrderDate', y='TotalDiscounts', 
              title='Sum of Discounts Over Time', 
              labels={'OrderDate': 'Date', 'TotalDiscounts': 'Total Discounts'})
              
# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS order_month,
    SUM(od.Discount) AS total_discount
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    order_month
ORDER BY 
    order_month
""""""

discount_data = execute_sql_query(sql_query)

fig = px.line(discount_data, x='order_month', y='total_discount', title='Total Discounts Over Time')
show_to_user(fig)
```","The input code is not calculating the discounts correctly. The reference computes the sum of discounts as 'SUM(od.Discount * od.Quantity * od.UnitPrice)', taking into account the Discount, Quantity, and UnitPrice, while the input only sums up 'od.Discount'. Additionally, the input groups by month whereas the reference groups by actual order date.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the function that actually executes the SQL and returns a DataFrame
    raise NotImplementedError(""This function should execute the given SQL and return a DataFrame."")

def show_to_user(data):
    # Placeholder to show the results
    if isinstance(data, plotly.graph_objs.Figure):
        # Display the Plotly figure
        print(""Plotly figure to be displayed"")
    elif isinstance(data, pd.DataFrame):
        # Display the DataFrame
        print(data)
        
# SQL query to get the sum of all discounts along with OrderDate for trend analysis
sql_query = """"""
SELECT SUM(od.Discount) AS TotalDiscount, o.OrderDate
FROM [Order Details] od
JOIN Orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderDate
ORDER BY o.OrderDate;
""""""

# Execute the query and get the result in a DataFrame
discounts_df = execute_sql_query(sql_query)

# Ensure discount data is aggregated over time
discounts_over_time = discounts_df.groupby('OrderDate')['TotalDiscount'].sum().reset_index()

# Create a line plot for the total discounts over time
fig = px.line(discounts_over_time, x='OrderDate', y='TotalDiscount', 
              title='Total Discounts Over Time', labels={'TotalDiscount': 'Total Discount', 'OrderDate': 'Date'})

# Display the plot to the user
show_to_user(fig)
```","The input code calculates the sum of discounts as SUM(od.Discount), which doesn't account for Quantity and UnitPrice, unlike the reference code which uses SUM(od.Discount * od.Quantity * od.UnitPrice). Thus, the business logic differs and the calculation is incorrect.",None
How many orders were shipped late last month? Include a trend line visualization to show late shipments over the past six months.,"```python
import pandas as pd
import plotly.express as px

# Sample utility functions based on constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for real database interaction
    # Assume the function connects to a database and returns a DataFrame
    pass

def show_to_user(data):
    # Displays data or visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to retrieve late shipments for last month
sql_query_last_month = """"""
SELECT COUNT(OrderID) as late_shipments 
FROM orders 
WHERE ShippedDate > RequiredDate 
AND DATE_TRUNC('month', ShippedDate) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month');
""""""

late_shipments_last_month_df = execute_sql_query(sql_query_last_month)

# SQL query to retrieve trend of late shipments over the past six months
sql_query_trend = """"""
SELECT DATE_TRUNC('month', ShippedDate) as month, COUNT(OrderID) as late_shipments
FROM orders 
WHERE ShippedDate > RequiredDate 
AND ShippedDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '6 month')
GROUP BY month
ORDER BY month;
""""""

late_shipments_trend_df = execute_sql_query(sql_query_trend)

# Visualization
fig = px.line(late_shipments_trend_df, x='month', y='late_shipments',
              title='Trend of Late Shipments Over the Past Six Months')

# Show results
show_to_user(late_shipments_last_month_df)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to get the number of late shipments last month
sql_query_late_orders = f""""""
SELECT COUNT(*) AS LateShipments
FROM orders
WHERE ShippedDate > RequiredDate 
AND ShippedDate >= '{first_day_last_month.strftime(""%Y-%m-%d"")}' 
AND ShippedDate <= '{last_day_last_month.strftime(""%Y-%m-%d"")}'
""""""
late_orders_df = execute_sql_query(sql_query_late_orders)

# SQL query to get late shipments over the past six months
sql_query_trend = """"""
SELECT DATE_TRUNC('month', ShippedDate) AS Month, 
       COUNT(*) AS LateShipments
FROM orders
WHERE ShippedDate > RequiredDate 
AND ShippedDate >= CURRENT_DATE - INTERVAL '6 months'
GROUP BY Month
ORDER BY Month
""""""
trend_df = execute_sql_query(sql_query_trend)

# Visualization of the trend line
fig = px.line(trend_df, x='Month', y='LateShipments', title='Late Shipments Over the Past Six Months', 
              labels={'LateShipments': 'Number of Late Shipments', 'Month': 'Month'})
show_to_user(fig)

# Show the late shipments count for last month
show_to_user(late_orders_df)
```","The input Python code correctly calculates the number of late shipments for the last month and trends over the past six months. It adheres to the logic of the reference implementation by using SQL queries with appropriate date filtering and logic for counting late shipments. The input code also includes a trend line visualization for late shipments over the past six months, just as the reference implementation does. Minor differences in variable naming and SQL syntax for date calculation do not impact the correctness of the output, making the input code functionally equivalent to the reference.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating a database query execution
    # In a real-world scenario, this function will interact with a database
    pass

def show_to_user(data):
    # Simulating showing data to user
    # This will display the DataFrame or Plotly figure
    pass

# SQL query to get the count of late shipments for last month
last_month_sql = """"""
SELECT COUNT(o.OrderID) AS LateOrders 
FROM orders o 
WHERE o.ShippedDate > o.RequiredDate 
AND EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 MONTH') 
AND EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '1 MONTH');
""""""

# SQL query to get late shipments for the past six months
trend_sql = """"""
SELECT EXTRACT(YEAR FROM o.OrderDate) AS Year, 
       EXTRACT(MONTH FROM o.OrderDate) AS Month, 
       COUNT(o.OrderID) AS LateOrders
FROM orders o
WHERE o.ShippedDate > o.RequiredDate 
AND o.OrderDate >= CURRENT_DATE - INTERVAL '6 MONTH'
GROUP BY Year, Month
ORDER BY Year, Month;
""""""

# Execute SQL queries
last_month_late_orders_df = execute_sql_query(last_month_sql)
trend_df = execute_sql_query(trend_sql)

# Show the count of late shipments for last month
show_to_user(last_month_late_orders_df)

# Create a trend line visualization for late shipments over the past six months
trend_df['Date'] = trend_df.apply(lambda row: datetime(int(row['Year']), int(row['Month']), 1), axis=1)
fig = px.line(
    trend_df,
    x='Date',
    y='LateOrders',
    title='Late Shipments Over the Past Six Months',
    labels={'LateOrders': 'Late Orders', 'Date': 'Month'}
)
show_to_user(fig)
```","The input code uses `OrderDate` instead of `ShippedDate` to filter and truncate months, which differs from the reference implementation. This affects the correctness, as the condition should focus on `ShippedDate` and `RequiredDate` to determine late shipments.",Base
How many customers were retained from Q1 to Q2 in 2023? Include a bar chart showing retention by month.,"
import pandas as pd
import plotly.express as px

# SQL query to get retained customers by month
sql_query_retained_by_month = """"""
SELECT 
    MONTH(o.OrderDate) AS month,
    COUNT(DISTINCT o.CustomerID) AS retained_customers 
FROM orders o 
WHERE o.CustomerID IN (
    SELECT CustomerID FROM orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
) 
AND o.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY MONTH(o.OrderDate)
""""""

# Define utility functions (mock implementations)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the SQL query and return a pandas DataFrame
    # Implement database connection and execution logic here
    pass

def show_to_user(data):
    # This function should handle displaying data or visualization results
    # Implement linking with appropriate visualization/display libraries here
    pass

# Execute the SQL query to get retained customers by month
retained_customers_df = execute_sql_query(sql_query_retained_by_month)

# Create a bar chart for customer retention by month
fig = px.bar(
    retained_customers_df,
    x='month',
    y='retained_customers',
    title='Customer Retention by Month from Q1 to Q2 in 2023',
    labels={'month': 'Month', 'retained_customers': 'Retained Customers'}
)

# Display the chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve customer IDs from Q1 and Q2
query_q1 = """"""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""
query_q2 = """"""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
""""""

df_q1 = execute_sql_query(query_q1)
df_q2 = execute_sql_query(query_q2)

# Step 2: Identify retained customers
retained_customers = df_q1[df_q1['CustomerID'].isin(df_q2['CustomerID'])]

# Step 3: Count retained customers
retained_count = retained_customers.shape[0]

# Step 4: Prepare data for bar chart showing monthly retention
monthly_retention_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS month, 
       COUNT(DISTINCT CustomerID) AS retained_customers 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-06-30' 
AND CustomerID IN (SELECT CustomerID FROM orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31')
GROUP BY month 
ORDER BY month
""""""

monthly_retention_df = execute_sql_query(monthly_retention_query)

# Step 5: Create the bar chart
fig = px.bar(monthly_retention_df, x='month', y='retained_customers', title='Customer Retention by Month (Q1 to Q2 2023)')
show_to_user(fig)
```","The input code does not correctly identify retained customers according to the specified logic. The retained customers are filtered from Q1 who appear again in Q2, whereas the provided implementation merely counts all Q2 customers who also have appearances in the specified range. Moreover, the SQL logic and filtering steps differ from the reference where the input version uses a more complex approach involving execution of multiple SQL queries with potential redundant operations.","```python
import pandas as pd
import plotly.express as px

# Define the SQL queries
retained_query = """"""
SELECT customers.CustomerID, customers.CompanyName 
FROM (
    SELECT DISTINCT CustomerID 
    FROM orders 
    WHERE EXTRACT(YEAR FROM OrderDate) = 2023 
    AND EXTRACT(QUARTER FROM OrderDate) IN (1, 2)
) AS subquery 
JOIN customers ON subquery.CustomerID = customers.CustomerID 
WHERE customers.CustomerID IN (
    SELECT CustomerID 
    FROM orders 
    WHERE EXTRACT(YEAR FROM OrderDate) = 2023 
    AND EXTRACT(QUARTER FROM OrderDate) = 2
) AND customers.CustomerID IN (
    SELECT CustomerID 
    FROM orders 
    WHERE EXTRACT(YEAR FROM OrderDate) = 2023 
    AND EXTRACT(QUARTER FROM OrderDate) = 1
);
""""""

# Function for executing the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function, to be replaced with actual database connection logic
    pass

# Run the query to get retained customers
retained_customers_df = execute_sql_query(retained_query)

# Month-wise retention for bar chart
orders_2023_query = """"""
SELECT CustomerID, EXTRACT(MONTH FROM OrderDate) AS OrderMonth 
FROM orders 
WHERE EXTRACT(YEAR FROM OrderDate) = 2023
""""""

orders_2023_df = execute_sql_query(orders_2023_query)

# Count of retained customers by month
retention_by_month = orders_2023_df.groupby('OrderMonth').CustomerID.apply(
    lambda x: len(set(x) & set(retained_customers_df.CustomerID))
).reset_index(name='RetainedCustomers')

# Create a bar chart for retention by month
fig = px.bar(
    retention_by_month,
    x='OrderMonth',
    y='RetainedCustomers',
    title='Customer Retention by Month (2023)',
    labels={'OrderMonth': 'Month', 'RetainedCustomers': 'Number of Retained Customers'}
)

# Function to show the visualization to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        # Display dataframe if needed
        print(data)
    elif isinstance(data, px.Figure):
        # Display plotly figure
        data.show()

# Show the bar chart to the user
show_to_user(fig)
```","The provided code does not correctly implement the business analytics request. The reference implementation focuses on counting distinct customers who placed orders both in Q1 and Q2 2023 and groups the count by month for Q2 only. The input code first queries customers who ordered in both quarters and then attempts a month-wise retention count for all months of 2023. The logic for determining retained customers differs from the reference, and it aggregates all months rather than focusing on Q2. Additionally, the input code's month-wise logic doesn't match the reference as it mixes customer extraction logic across all months without proper filtering for Q1 and Q2 separately.",None
"What is the total number of units sold by supplier, and can this be visualized using a bar chart for better comparison?","
```python
import plotly.express as px

# Helper functions as per the environment constraints
def execute_sql_query(sql_query: str):
    import pandas as pd
    # This function simulates the execution of an SQL query and returns a pandas DataFrame.
    # In a real implementation, you would execute the SQL against a database connection.
    # Example simulated data for the sake of this task:
    data = {
        'CompanyName': ['Supplier A', 'Supplier B', 'Supplier C'],
        'total_units_sold': [1000, 1500, 1200]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # In a real implementation, this function would display the results to the user.
    # Here it's a placeholder to meet the environment's requirements.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query from the user's request
sql_query = '''
SELECT suppliers.CompanyName, SUM([Order Details].Quantity) AS total_units_sold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
GROUP BY suppliers.CompanyName
ORDER BY total_units_sold DESC
'''

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='total_units_sold', title='Total Units Sold by Supplier')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.SupplierID, SUM([Order Details].Quantity) AS total_units_sold
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.SupplierID
""""""

# Execute the SQL query to get total units sold by supplier
units_sold_by_supplier = execute_sql_query(sql_query)

# Creating a bar chart for better comparison
fig = px.bar(units_sold_by_supplier, x='SupplierID', y='total_units_sold',
             title='Total Units Sold by Supplier', labels={'SupplierID': 'Supplier ID', 'total_units_sold': 'Total Units Sold'})

show_to_user(fig)
```","The input code does not match the reference logic. The SQL query in the input implementation aggregates sales by `SupplierID` instead of `CompanyName`. There is no join from `products` to `suppliers` to get the supplier names, which is essential for a meaningful comparison by name as requested. The input code thus fails to fulfill the business request to show units sold by supplier name.","```python
import plotly.express as px
import pandas as pd

# SQL query to get total number of units sold by supplier
sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalUnitsSold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.SupplierID;
""""""

# Execute the SQL query and store the result in a DataFrame
supplier_units_df = execute_sql_query(sql_query)

# Create a bar chart for better comparison of total units sold by supplier
fig = px.bar(
    supplier_units_df,
    x='SupplierID',
    y='TotalUnitsSold',
    title='Total Units Sold by Supplier',
    labels={'SupplierID': 'Supplier ID', 'TotalUnitsSold': 'Total Units Sold'},
    template='plotly'
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code calculates the total units sold by SupplierID rather than by CompanyName as in the reference code. SupplierID may not convey the same information as the CompanyName, making it difficult for users to understand the supplier details clearly. Additionally, it doesn't order the results by total units sold in descending order.",None
"Which customers are from a specific country, have placed orders, and how can the distribution be visualized effectively?","```python
import pandas as pd
import plotly.express as px

# SQL query to identify customers from a specific country with orders
sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE customers.Country = 'Specific Country';
""""""

# Execute SQL query and get the results in a DataFrame
customers_with_orders_df = execute_sql_query(sql_query)

# Group by CompanyName to understand the distribution of orders
customer_distribution = customers_with_orders_df['CompanyName'].value_counts().reset_index()
customer_distribution.columns = ['CompanyName', 'OrderCount']

# Create a bar chart to visualize the distribution of orders
fig = px.bar(customer_distribution, x='CompanyName', y='OrderCount',
             title='Order Distribution of Customers from a Specific Country',
             labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

country = 'SpecificCountry'  # Replace with the desired country

sql_query = f""""""
SELECT c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Country, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE c.Country = '{country}'
GROUP BY c.CustomerID, c.CompanyName, c.ContactName, c.ContactTitle, c.Country
HAVING COUNT(o.OrderID) > 0
""""""

customer_data = execute_sql_query(sql_query)

fig = px.bar(customer_data, x='CompanyName', y='OrderCount', title=f'Order Distribution of Customers from {country}', 
             labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer Company Name'})

show_to_user(fig)
```","The input code correctly identifies customers from a specified country who have placed orders. It uses similar logic to the reference implementation by executing a SQL query to join the customers and orders tables, filtering by country, and aggregating orders per customer. It then visualizes the distribution of orders using a bar chart. The added fields in the SQL query (ContactName, ContactTitle) do not impact the correctness in terms of meeting the business analytics request. The structure and functionality align with the reference.","
import pandas as pd
import plotly.express as px

# Utility function placeholders for the given constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Logic to execute the given SQL query and return results as a DataFrame
    pass

def show_to_user(data):
    # Logic to display the data analysis or graph
    pass

# SQL Query to fetch customers who are from a specific country and have placed orders.
sql_query = """"""
SELECT DISTINCT customers.CustomerID 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE customers.Country = 'SpecificCountry';
""""""

# Executing SQL query and storing the result in a DataFrame
df_customers = execute_sql_query(sql_query)

# Check the distribution of customers (e.g., count of CustomerIDs)
customer_distribution = df_customers['CustomerID'].value_counts().reset_index()
customer_distribution.columns = ['CustomerID', 'Count']

# Visualize the distribution using a bar chart
fig = px.bar(customer_distribution, x='CustomerID', y='Count', title='Customer Distribution by Country and Orders')

# Display the figure
show_to_user(fig)
","The input code does not match the reference implementation's logic. The reference counts 'CompanyName', while the input counts 'CustomerID'. The input also uses 'DISTINCT' in the SQL query incorrectly, resulting in a misinterpretation of customer order distribution. The visualization title also does not align with the reference.",Base
Which supplier has the longest average lead time? Include a bar chart to compare the average lead times of all suppliers.,"import pandas as pd
import plotly.express as px

# SQL query to get average lead times for each supplier
sql_query = """"""
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, suppliers.CompanyName 
ORDER BY AvgLeadTime DESC;
""""""

# Execute the SQL query and get the results as a DataFrame
suppliers_lead_times = execute_sql_query(sql_query)

# Create a bar chart to visualize the average lead times for all suppliers
fig = px.bar(suppliers_lead_times, 
             x='CompanyName', 
             y='AvgLeadTime', 
             title='Average Lead Time by Supplier',
             labels={'CompanyName': 'Supplier', 'AvgLeadTime': 'Average Lead Time (days)'},
             text_auto=True)

# Show the bar chart to the user
show_to_user(fig)

# Identify the supplier with the longest average lead time
# Since the DataFrame is sorted in descending order by AvgLeadTime, the first row will have the longest lead time
longest_lead_time_supplier = suppliers_lead_times.iloc[0]

# Convert the result to a DataFrame for display
longest_lead_time_df = pd.DataFrame([longest_lead_time_supplier])

# Show the longest lead time supplier
show_to_user(longest_lead_time_df)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
GROUP BY s.SupplierID, s.CompanyName
""""""
lead_time_df = execute_sql_query(sql_query)

longest_lead_time_supplier = lead_time_df.loc[lead_time_df['AvgLeadTime'].idxmax()]

fig = px.bar(lead_time_df, x='CompanyName', y='AvgLeadTime', title='Average Lead Times of Suppliers')
show_to_user(fig)

longest_lead_time_supplier
```","The provided code does not accurately reflect the SQL logic in the reference implementation. The WHERE clause in the input code uses a subquery that seems potentially redundant and might not effectively join with the 'Order Details' as specified in the reference. Additionally, while both codes attempt to visualize average lead times using a bar chart, the aggregation and order of operations can lead to different results if the SQL logic is not identical. The 'idxmax()' method is correctly used to determine the longest lead time supplier. However, due to the difference in the SQL logic, the final result may vary.","
import plotly.express as px
import pandas as pd


def get_longest_average_lead_time_supplier():
    # SQL query to get average lead time for each supplier
    sql_query = """"""
    SELECT s.CompanyName, 
           AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime 
    FROM suppliers s 
    JOIN products p ON s.SupplierID = p.SupplierID 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    JOIN orders o ON o.OrderID = od.OrderID 
    GROUP BY s.CompanyName 
    ORDER BY AvgLeadTime DESC;
    """"""
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Display the supplier with the longest average lead time
    answer_longest_lead_time = df.iloc[[0]]  # Longest lead time is the first row
    show_to_user(answer_longest_lead_time)
    
    # Create a bar chart to compare average lead times of all suppliers
    fig = px.bar(df, x='CompanyName', y='AvgLeadTime', 
                 title='Average Lead Time by Supplier',
                 labels={'AvgLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
    
    # Display the bar chart
    show_to_user(fig)

# Call the function to execute the analysis and visualization
get_longest_average_lead_time_supplier()
","The input code correctly implements the business request. It calculates the average lead time for each supplier using a SQL query, orders the results in descending order, and labels the first row as the supplier with the longest average lead time. It also creates a bar chart using Plotly Express to visualize the average lead times for all suppliers. Although the approach differs slightly, the logic aligns with the reference implementation, fulfilling the business analytics request.",Finetuned
What are the top 5 products by sales volume? Please include a bar chart to visualize the sales volume for these products.,"
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are predefined functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for executing SQL queries
    pass

def show_to_user(data):
    # Placeholder function for displaying data to the user
    pass

# SQL query to fetch top 5 products by sales volume
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS SalesVolume
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY SalesVolume DESC
LIMIT 5;
""""""

# Execute the SQL query and get the result as a DataFrame
top_products_df = execute_sql_query(sql_query)

# Check the resulting DataFrame
print(top_products_df)

# Create a bar chart using Plotly to visualize the sales volume for the top 5 products
fig = px.bar(top_products_df, x='ProductName', y='SalesVolume', 
             title='Top 5 Products by Sales Volume',
             labels={'SalesVolume': 'Sales Volume', 'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS SalesVolume
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY SalesVolume DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='SalesVolume', title='Top 5 Products by Sales Volume')
show_to_user(fig)
```","The input Python code correctly answers the business analytics request. It retrieves the top 5 products by sales volume using an SQL query, similar to the reference code. It joins the 'products' table with the '[Order Details]' table, groups the results by ProductID and ProductName, and orders by sales volume. The bar chart visualization is correctly implemented using Plotly. Despite the minor difference in SQL query structure, the logic and functionality are equivalent to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assuming fetch_data and show_to_user are already implemented in the environment.

# Step 1: Execute the SQL query to get the data
sql_query = """"""
SELECT products.ProductID, products.ProductName, 
SUM([Order Details].Quantity) AS sales_volume 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID, products.ProductName 
ORDER BY sales_volume DESC 
LIMIT 5;
""""""
sales_data = fetch_data(sql_query)

# Step 2: Create a bar chart to visualize the sales volume of the top 5 products
fig = px.bar(
    sales_data,
    x='ProductName',
    y='sales_volume',
    title='Top 5 Products by Sales Volume',
    labels={'sales_volume': 'Sales Volume', 'ProductName': 'Product Name'}
)

# Step 3: Show the visualization to the user
show_to_user(fig)
```","The input code correctly executes an SQL query to fetch the top 5 products by sales volume, similarly to the reference code. Both implementations group by product name and order by sales volume in descending order. They also match in creating a bar chart with Plotly and displaying it using a designated function. Despite the minor difference in SQL query syntax (using product IDs in the GROUP BY clause), the logic and outcome align with the reference implementation.",both
"Which products are currently at or below their reorder level, and can this be visualized through a bar chart to highlight those products?","
# Importing necessary libraries
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query and get the result as a DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(products_df, x='ProductName', title='Products at or Below Reorder Level')

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0
""""""

products_below_reorder = execute_sql_query(sql_query)

fig = px.bar(products_below_reorder, x='ProductName', y='UnitsInStock', 
              title='Products at or Below Reorder Level', 
              labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code accurately retrieves products at or below their reorder level and visualizes them in a bar chart. It includes additional filtering by excluding discontinued products, which doesn't contradict the main requirement. The visualization logic aligns with the reference, using Plotly to create a bar chart based on the ProductName.","```python
import pandas as pd
import plotly.express as px

# Given SQL Query
sql_query = ""SELECT ProductID, ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database execution
    # This function should be replaced with the actual code to execute the query.
    pass

def show_to_user(data):
    # Placeholder function to display data, execute as appropriate
    # If data is a plotly figure, it should execute the plotting.
    pass

# Execute the SQL query and get the result in a DataFrame
product_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(product_data, x='ProductName', y='ProductID', 
             labels={'ProductID': 'Product ID', 'ProductName': 'Product Name'},
             title='Products at or Below Reorder Level',
             text='ProductID')

# Show the bar chart to the user
show_to_user(fig)
```","The input code and the reference implementation differ in logic. The input code plots 'ProductID' on the y-axis and includes 'ProductID' as text labels in the chart, which doesn’t match the reference code's requirement of visualizing 'ProductName' only. The reference code focuses solely on visualizing 'ProductName' on the x-axis without any y-axis variable, which better highlights the products at or below reorder level.",Base
How many orders have a discount applied? Include a bar chart showing the number of discounted orders by product category.,"
import pandas as pd
import plotly.express as px

# SQL query to count distinct orders with a discount and get product category
sql_query = """"""
SELECT c.CategoryName, COUNT(DISTINCT o.OrderID) as DiscountedOrders
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN Products p ON od.ProductID = p.ProductID
JOIN Categories c ON p.CategoryID = c.CategoryID
WHERE od.Discount > 0
GROUP BY c.CategoryName;
""""""

# Function to execute the SQL query and return the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function to replace actual database interaction
    # In a real scenario, this should be implemented to interact with an actual database
    data = {
        ""CategoryName"": [""Beverages"", ""Condiments"", ""Confections""],
        ""DiscountedOrders"": [20, 10, 15]
    }
    return pd.DataFrame(data)

# Run the SQL query using provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryName', y='DiscountedOrders', title='Discounted Orders by Product Category')

# Display the figure using the utility function
def show_to_user(data):
    # This utility function could be larger depending on its specifications
    data.show()

show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(CASE WHEN od.Discount > 0 THEN 1 ELSE 0 END) AS DiscountedOrders
FROM 
    [Order Details] od
GROUP BY 
    od.ProductID
""""""

discounted_orders_df = execute_sql_query(sql_query)

total_discounted_orders = discounted_orders_df['DiscountedOrders'].sum()

bar_chart = px.bar(discounted_orders_df, x='ProductID', y='DiscountedOrders', 
                   title='Number of Discounted Orders by Product Category')

show_to_user(bar_chart)

total_discounted_orders
```","The input code calculates discounted orders by ProductID, not by CategoryName, and doesn't join tables to get category information as required. It sums discounted orders without grouping by category, unlike the reference code. Therefore, it doesn't adhere to the same logic or answer the business request correctly.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query is defined elsewhere, as per environment constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation
    pass

def show_to_user(data):
    # Placeholder for actual implementation
    pass

# SQL query to get order IDs with a discount
discounted_orders_query = ""SELECT DISTINCT OrderID FROM [Order Details] WHERE Discount > 0;""

# Execute the SQL query to get the discounted orders
discounted_orders_df = execute_sql_query(discounted_orders_query)

# Get the count of unique discounted orders
discounted_orders_count = len(discounted_orders_df)

# Display the count to the user
show_to_user(discounted_orders_df)

# SQL query to count discounted orders by product category
discounted_orders_by_category_query = """"""
SELECT p.CategoryID, c.CategoryName, COUNT(DISTINCT od.OrderID) as DiscountedOrderCount
FROM [Order Details] od
JOIN Products p ON od.ProductID = p.ProductID
JOIN Categories c ON p.CategoryID = c.CategoryID
WHERE od.Discount > 0
GROUP BY p.CategoryID, c.CategoryName;
""""""

# Execute the SQL query to get discounted orders by category
discounted_orders_by_category_df = execute_sql_query(discounted_orders_by_category_query)

# Generate a bar chart using Plotly
fig = px.bar(
    discounted_orders_by_category_df,
    x='CategoryName',
    y='DiscountedOrderCount',
    title='Number of Discounted Orders by Product Category',
    labels={'CategoryName': 'Product Category', 'DiscountedOrderCount': 'Discounted Order Count'}
)

# Display the bar chart
show_to_user(fig)
```
","The input Python code correctly fulfills the business analytics request and adheres to the logic of the reference implementation. The code successfully queries for unique orders with discounts and counts them by product category. It then generates a bar chart showing the number of discounted orders per category. The main difference is a clearer separation of distinct order counting and category grouping, but logically it aligns with the reference implementation.",Finetuned
"Which suppliers have the shortest average lead time for deliveries, and can you provide a bar chart comparing the average lead times of each supplier?","```python
import pandas as pd
import plotly.express as px

# SQL query string
sql_query = """"""
SELECT suppliers.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID 
ORDER BY avg_lead_time ASC
""""""

# Execute the SQL query and get the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average lead times of each supplier
fig = px.bar(df, x='SupplierID', y='avg_lead_time', title='Average Lead Time by Supplier',
             labels={'avg_lead_time': 'Average Lead Time (days)', 'SupplierID': 'Supplier ID'},
             text='avg_lead_time')

# Customize the layout for better readability
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig.update_layout(yaxis=dict(title='Average Lead Time (days)'), xaxis=dict(title='Supplier ID'))

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time
FROM orders
JOIN products ON orders.OrderID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY average_lead_time ASC
""""""

lead_time_df = execute_sql_query(sql_query)

fig = px.bar(lead_time_df, x='CompanyName', y='average_lead_time', title='Average Lead Time by Supplier')
show_to_user(fig)
```","The input code has issues compared to the reference implementation. It uses a JOIN condition that combines orders with products using OrderID matching ProductID, which seems logically incorrect. It should JOIN on OrderDetails to combine with orders using OrderID. Also, it adds suppliers.CompanyName in the GROUP BY clause, but this doesn't align with the reference code's focus on SupplierID alone. The chart uses 'CompanyName' instead of 'SupplierID' for x-axis, deviating from the reference implementation. These discrepancies lead to possible logic errors and mismatched analysis intent.","```python
import pandas as pd
import plotly.express as px

# Assuming the execute_sql_query function is defined elsewhere in the environment
# and returns a DataFrame.

def calculate_and_plot_shortest_lead_time_suppliers():
    # SQL query to get suppliers with average lead time
    sql_query = """"""
    SELECT 
        s.SupplierID, 
        AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime 
    FROM 
        suppliers s 
    JOIN 
        products p ON s.SupplierID = p.SupplierID 
    JOIN 
        [Order Details] od ON p.ProductID = od.ProductID 
    JOIN 
        orders o ON o.OrderID = od.OrderID 
    GROUP BY 
        s.SupplierID 
    ORDER BY 
        AvgLeadTime ASC;
    """"""

    # Execute the SQL query and get the result in a DataFrame
    df_suppliers = execute_sql_query(sql_query)

    # Create a bar chart using Plotly
    fig = px.bar(df_suppliers, x='SupplierID', y='AvgLeadTime',
                 title='Suppliers with Shortest Average Lead Time',
                 labels={'AvgLeadTime': 'Average Lead Time (days)', 'SupplierID': 'Supplier ID'})

    # Display the bar chart
    show_to_user(fig)

# Call the function to execute the analysis and visualization
calculate_and_plot_shortest_lead_time_suppliers()
```","The input Python code is correct because it follows the same logic and structure as the reference implementation. Both codes execute a SQL query to calculate the average lead time for each supplier by joining the suppliers, products, order details, and orders tables. The query results are ordered by average lead time in ascending order. Both implementations use Plotly to create a bar chart that visualizes the average lead times of each supplier, and display the chart to the user. The differences in the alias names and structure of the SQL query do not affect the correctness of the logic.",Finetuned
What is the monthly growth rate in sales for each employee? Please provide a line chart to visualize the trend for each employee over time.,"```python
import pandas as pd
import plotly.express as px

# Assuming the execute_sql_query function is available to use
sql_query = """"""
SELECT 
    e.EmployeeID, 
    YEAR(o.OrderDate) AS Year, 
    MONTH(o.OrderDate) AS Month, 
    (SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) - 
    LAG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) 
    OVER (PARTITION BY e.EmployeeID ORDER BY YEAR(o.OrderDate), MONTH(o.OrderDate))) / 
    LAG(SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))) 
    OVER (PARTITION BY e.EmployeeID ORDER BY YEAR(o.OrderDate), MONTH(o.OrderDate))
    AS MonthlyGrowth 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, YEAR(o.OrderDate), MONTH(o.OrderDate);
""""""

# Execute the query and get the data
df = execute_sql_query(sql_query)

# Data processing if necessary
# Remove rows with NaN MonthlyGrowth which results from LAG function for first entries
df.dropna(subset=['MonthlyGrowth'], inplace=True)

# Create a line chart using Plotly
fig = px.line(df, x='Month', y='MonthlyGrowth', color='EmployeeID', 
              line_group='EmployeeID', title='Monthly Growth Rate in Sales for Each Employee',
              labels={'MonthlyGrowth': 'Monthly Growth', 'Month': 'Month'},
              facet_col='Year', facet_col_wrap=3)

# Show the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, Month
ORDER BY 
    e.EmployeeID, Month;
""""""

sales_data = execute_sql_query(sql_query)

sales_data['GrowthRate'] = sales_data.groupby('EmployeeID')['TotalSales'].pct_change() * 100

fig = px.line(sales_data, 
              x='Month', 
              y='GrowthRate', 
              color='EmployeeID', 
              title='Monthly Sales Growth Rate by Employee',
              labels={'GrowthRate': 'Growth Rate (%)', 'Month': 'Month'})
show_to_user(fig)
```","The input code correctly calculates the monthly growth rate in sales for each employee. It uses the `pct_change` method to calculate the percentage change in total sales month over month, which aligns with the logic in the reference implementation that calculates the growth rate using the SQL LAG function. Both implementations create a line chart to visualize the growth rate over time for each employee. While the details such as the exact SQL query differ (e.g., additional selection of employee's first and last name in the input), the necessary logic and output visualization addressing the business requirement are effectively achieved.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation based on business environment
    pass

def show_to_user(data):
    # Implementation based on business environment
    pass

# SQL query to get monthly sales data for each employee
sql_query_sales = """"""
SELECT 
    YEAR(o.OrderDate) AS Year, 
    MONTH(o.OrderDate) AS Month, 
    e.EmployeeID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY YEAR(o.OrderDate), MONTH(o.OrderDate), e.EmployeeID;
""""""

# Execute the SQL query to get the data
monthly_sales_df = execute_sql_query(sql_query_sales)

# Calculate the monthly growth rate in sales for each employee
monthly_sales_df = monthly_sales_df.sort_values(by=['Year', 'Month'])
monthly_sales_df['MonthlyGrowth'] = monthly_sales_df.groupby('EmployeeID')['MonthlySales'].pct_change()

# Prepare the line chart to visualize the trend
fig = px.line(
    monthly_sales_df,
    x='Month', 
    y='MonthlyGrowth', 
    color='EmployeeID',
    markers=True, 
    title='Monthly Growth Rate in Sales for Each Employee'
)

# Show the line chart to the user
show_to_user(fig)
```","The input code calculates the monthly growth rate using `pct_change()`, which is correct. However, the reference code also uses `LAG()` with analytic functions in SQL to directly calculate growth rates while grouping by EmployeeID, Year, and Month, which is a more direct approach than sorting and using pandas methods. Both methods are correct logically, but the visualization in the input code lacks the 'facet_col' and 'facet_col_wrap' used in the reference implementation, which allows for displaying a separate subplot for each year. This results in a less informative chart.",Base
"What is the monthly trend of new customers acquired, and can it be represented with a line chart to visualize the changes over time?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = """"""
    SELECT DATE_TRUNC('month', OrderDate) AS Month, 
           COUNT(DISTINCT CustomerID) AS NewCustomers 
    FROM orders 
    GROUP BY Month 
    ORDER BY Month;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
data = execute_sql_query(sql_query)

# Convert Month to datetime for proper plotting
data['Month'] = pd.to_datetime(data['Month'])

# Create a line chart using Plotly
fig = px.line(data, x='Month', y='NewCustomers', title='Monthly Trend of New Customers Acquired')

# Show the line chart to the user
show_to_user(fig)
```","```python
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(DISTINCT CustomerID) AS NewCustomers
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

new_customers_df = execute_sql_query(sql_query)

import plotly.express as px

fig = px.line(new_customers_df, x='Month', y='NewCustomers', 
              title='Monthly Trend of New Customers Acquired',
              labels={'Month': 'Month', 'NewCustomers': 'Number of New Customers'})
show_to_user(fig)
```","The input code achieves the same outcome as the reference code. It retrieves the monthly data on new customers using a SQL query and then visualizes it using Plotly. While the date formatting uses a different SQL function (DATE_FORMAT instead of DATE_TRUNC), it effectively serves the purpose of grouping by month. The visualization logic aligns with the reference code's intent to display a line chart of new customers over time.","```python
import pandas as pd
import plotly.express as px

# The utility function that executes the provided SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    pass  # Placeholder for SQL execution logic

# The utility function that displays data to the user
def show_to_user(data):
    pass  # Placeholder for display logic

# Define the SQL query for retrieving monthly trends of new customers
sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM Customers.CustomerDate) AS Year, 
    EXTRACT(MONTH FROM Customers.CustomerDate) AS Month, 
    COUNT(*) AS NewCustomers 
FROM 
    Customers 
GROUP BY 
    Year, Month 
ORDER BY 
    Year, Month;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df_new_customers = execute_sql_query(sql_query)

# Create a line chart to visualize the trend of new customers over time
fig = px.line(
    df_new_customers, 
    x=pd.to_datetime(df_new_customers[['Year', 'Month']].assign(DAY=1)), 
    y='NewCustomers', 
    labels={'x': 'Month', 'NewCustomers': 'New Customers'},
    title='Monthly Trend of New Customers Acquired'
)

# Display the visualization
show_to_user(fig)
```","The input code query extracts from the Customers' table using CustomerDate, whereas the reference implementation uses data from 'orders' table and OrderDate. Customers table might lead to counting new customer entries rather than orders. Moreover, the reference implementation uses DATE_TRUNC for month truncation versus separate EXTRACT statements in the input; this could lead to similar outcomes, but the discrepancy in data source might impact results. The logic and source table must match the business request and reference implementation's logic context.",Base
"What is the total quantity of products ordered by each customer, and can you provide a bar chart to visualize this data?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for database query execution
    # In an actual implementation, this function would execute the query
    pass

# Function to display data analysis or visualization

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch the total quantity of products ordered by each customer
sql_query = """"""
SELECT c.CustomerID, SUM(od.Quantity) AS TotalQuantity 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
customer_order_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(customer_order_data, x='CustomerID', y='TotalQuantity', 
             title='Total Quantity of Products Ordered by Each Customer',
             labels={'TotalQuantity': 'Total Quantity', 'CustomerID': 'Customer ID'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, SUM(od.Quantity) AS TotalQuantity
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
""""""

customer_order_data = execute_sql_query(sql_query)

fig = px.bar(customer_order_data, x='CompanyName', y='TotalQuantity', title='Total Quantity of Products Ordered by Each Customer')
show_to_user(fig)
```","The input code correctly computes the total quantity of products ordered by each customer and visualizes it using a bar chart. The main difference is that the input code also includes 'CompanyName' in the SQL query and uses it in the chart's x-axis instead of 'CustomerID'. This inclusion of company name is a valid enhancement and does not change the overall logic or the correctness of the response to the business analytics request. Therefore, the code still fulfills the requirement correctly.","```python
import plotly.express as px

# Execute the SQL query to retrieve the data
sql_query = """"""
SELECT o.CustomerID, SUM(od.Quantity) AS TotalQuantity
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CustomerID', y='TotalQuantity', title='Total Quantity of Products Ordered by Each Customer')

# Display the visualization to the user
show_to_user(fig)
```","The input code calculates the total quantity of products ordered by each customer but uses the wrong field 'o.CustomerID'. It should use 'c.CustomerID' and join with the 'customers' table to ensure the query includes all customers. The reference implementation connects customers with orders, ensuring proper aggregation by CustomerID using a customer table join.",Base
"What is the total sales value in the last quarter, and can you provide a bar chart to visualize the sales trend over the months?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales for the last quarter
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales, 
    MONTH(orders.OrderDate) AS month
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31'
GROUP BY 
    MONTH(orders.OrderDate)
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Calculate the total sales value
# Note: sales_data['total_sales'] here contains aggregated sales per month

# Print total sales value for the entire quarter
# Although it is shown the following iteration is redundant because
# total_sales_value = sales_data['total_sales'].sum() gives the sum value 
# so below iteration could be removed
print(f""Total Sales in the Last Quarter: ${sales_data['total_sales'].sum():.2f}"")

# Create a bar chart to visualize the sales trend over the months
fig = px.bar(sales_data, x='month', y='total_sales', 
             labels={'month':'Month', 'total_sales':'Total Sales'}, 
             title='Sales Trend Over the Months')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Define the last quarter dates
current_date = datetime.now()
if current_date.month in [1, 2, 3]:
    start_date = datetime(current_date.year - 1, 10, 1)
    end_date = datetime(current_date.year - 1, 12, 31)
else:
    start_date = datetime(current_date.year, (current_date.month - 1) // 3 * 3 + 1, 1)
    end_date = datetime(current_date.year, start_date.month + 2, 31)

# SQL query to get total sales in the last quarter
total_sales_query = f""""""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""
total_sales_df = execute_sql_query(total_sales_query)

# SQL query to get sales trend over the months
sales_trend_query = f""""""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS monthly_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY month
ORDER BY month
""""""
sales_trend_df = execute_sql_query(sales_trend_query)

# Show total sales to the user
show_to_user(total_sales_df)

# Generate and show sales trend bar chart
fig = px.bar(sales_trend_df, x='month', y='monthly_sales', title='Sales Trend Over the Months', labels={'monthly_sales': 'Sales', 'month': 'Month'})
show_to_user(fig)
```","The input code calculates total sales for the last quarter and creates a bar chart for the sales trend. However, there are differences and potential issues with date calculation: (1) The input code determines the start and end dates dynamically based on the current month, which differs from the hardcoded dates in the reference implementation (for Q4 2023). This could result in incorrect dates depending on when the code is run. (2) The use of '31' as the end day without validating the month's last day can cause an error for months that do not have 31 days. (3) The input code separates the calculations into two queries, whereas the reference implementation uses one. While this doesn't affect correctness, it's different in terms of efficiency and approach. Finally, the input code uses 'DATE_FORMAT', which is not SQL standard but specific to some SQL dialects, possibly affecting its execution depending on the database.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Define the SQL query to get total sales in the last quarter
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months');
""""""

# Execute the SQL query to get the total sales
sales_data = execute_sql_query(sql_query)

# Extract the total sales value
total_sales_last_quarter = sales_data['TotalSales'][0]

# Display the total sales value to the user
show_to_user(pd.DataFrame({'Total Sales Last Quarter': [total_sales_last_quarter]}))

# Define the SQL query to get monthly sales data for the last quarter
sql_query_monthly = """"""
SELECT DATE_TRUNC('month', o.OrderDate) AS Month,
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months')
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query to get monthly sales data
monthly_sales_data = execute_sql_query(sql_query_monthly)

# Create a bar chart using Plotly to visualize the sales trend over the months
fig = px.bar(monthly_sales_data, x='Month', y='MonthlySales', title='Sales Trend Over the Last Quarter')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly calculates the total sales in the last quarter by executing a SQL query that sums up sales from an appropriate date range calculated using the current date. The code then visualizes the monthly sales trend using a bar chart created with Plotly, aligning with the intent of the reference implementation by grouping and displaying sales by month within the last quarter.",Finetuned
"What is the monthly customer retention rate for 2023, and can you provide a line chart to visualize the trend over the months?","```python
import pandas as pd
import plotly.express as px

# SQL query for customer retention rate
sql_query = """"""
    SELECT 
        EXTRACT(MONTH FROM OrderDate) AS Month, 
        COUNT(DISTINCT o1.CustomerID) * 1.0 / NULLIF(
            (SELECT COUNT(DISTINCT o2.CustomerID) FROM orders o2 WHERE o2.OrderDate < '2023-01-01'), 0
        ) AS RetentionRate 
    FROM orders o1 
    WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
    GROUP BY EXTRACT(MONTH FROM OrderDate);
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str):
    # This function executes the SQL query and returns a pandas DataFrame
    # In a real scenario, this might connect to a database and execute the query
    pass

# Use the utility function to execute the query and get a DataFrame
df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if df is not None and not df.empty:
    # Create a line chart using Plotly
    fig = px.line(
        df, 
        x='Month', 
        y='RetentionRate', 
        title='Monthly Customer Retention Rate for 2023',
        labels={'RetentionRate': 'Retention Rate', 'Month': 'Month'}
    )
    # Use the utility function to show the figure
    show_to_user(fig)
else:
    print(""No data available to display."")
```","```python
import pandas as pd
import plotly.express as px

start_date = '2023-01-01'
end_date = '2023-12-31'

sql_query = f""""""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS Month,
    COUNT(DISTINCT o.CustomerID) AS ReturningCustomers
FROM 
    orders o
WHERE 
    o.OrderDate >= '{start_date}' AND o.OrderDate <= '{end_date}' 
    AND o.CustomerID IN (
        SELECT DISTINCT CustomerID 
        FROM orders 
        WHERE OrderDate < '{start_date}'
    )
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

returning_customers_df = execute_sql_query(sql_query)

sql_query_total = f""""""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS Month,
    COUNT(DISTINCT o.CustomerID) AS TotalCustomers
FROM 
    orders o
WHERE 
    o.OrderDate >= '{start_date}' AND o.OrderDate <= '{end_date}'
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

total_customers_df = execute_sql_query(sql_query_total)

monthly_retention_df = pd.merge(returning_customers_df, total_customers_df, on='Month', how='outer', suffixes=('_Returning', '_Total'))
monthly_retention_df['RetentionRate'] = monthly_retention_df['ReturningCustomers'] / monthly_retention_df['TotalCustomers']

fig = px.line(monthly_retention_df, x='Month', y='RetentionRate', title='Monthly Customer Retention Rate for 2023', labels={'RetentionRate':'Retention Rate'})
show_to_user(fig)
```","The reference code calculates the retention rate based on the fraction of distinct returning customers relative to customers before 2023. In contrast, the evaluated code calculates the retention rate as the fraction of distinct returning customers for each month in 2023 relative to total customers in the same month. The evaluated code measures customer loyalty within 2023 but doesn't address pre-2023 retention as specified in the reference.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query with a placeholder for the year
sql_query_template = """"""
SELECT 
    EXTRACT(MONTH FROM orders.OrderDate) AS month, 
    COUNT(DISTINCT CASE WHEN orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' THEN orders.CustomerID END) / 
    NULLIF(COUNT(DISTINCT CASE WHEN orders.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' THEN orders.CustomerID END), 0) AS retention_rate 
FROM 
    orders 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY 
    month
ORDER BY 
    month;
""""""

# Execute the SQL query
sql_query = sql_query_template.format(year=2023)
retention_rate_df = execute_sql_query(sql_query)

# Ensure the retention rate is correctly calculated
retention_rate_df['retention_rate'] = retention_rate_df['retention_rate'].fillna(0)

# Create a line chart to visualize the retention rate trend
fig = px.line(retention_rate_df,
              x='month',
              y='retention_rate',
              title='Monthly Customer Retention Rate for 2023',
              labels={'month': 'Month', 'retention_rate': 'Retention Rate'},
              markers=True)

# Display the line chart
show_to_user(fig)
```","The input code calculates the retention rate by comparing unique customers from 2023 to those in 2022, whereas the reference implementation computes it based on initial customers before 2023. This difference affects the logic, making it incorrect as per the reference.",None
"What is the average discount applied to orders per supplier, and can you provide a bar chart to illustrate the average discount for each supplier?","
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.SupplierName, 
AVG([Order Details].Discount) AS AverageDiscount 
FROM suppliers 
INNER JOIN products ON suppliers.SupplierID = products.SupplierID 
INNER JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.SupplierID, suppliers.SupplierName;
""""""

# Execute SQL query function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder to simulate the data returned by the actual SQL execution in your environment
    data = {
        ""SupplierID"": [1, 2, 3],
        ""SupplierName"": [""Supplier A"", ""Supplier B"", ""Supplier C""],
        ""AverageDiscount"": [0.05, 0.1, 0.07]
    }
    return pd.DataFrame(data)

# Get the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discount per supplier
fig = px.bar(df, x='SupplierName', y='AverageDiscount',
             title='Average Discount per Supplier',
             labels={'AverageDiscount': 'Average Discount', 'SupplierName': 'Supplier Name'},
             text='AverageDiscount')

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS avg_discount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='SupplierID', y='avg_discount', title='Average Discount per Supplier', labels={'avg_discount': 'Average Discount', 'SupplierID': 'Supplier ID'})
show_to_user(fig)
```","The input code does not match the reference implementation correctly. The reference code joins three tables (suppliers, products, and Order Details) to get the SupplierName and SupplierID, and calculates the average discount per supplier. The input code only joins two tables (products and Order Details) and misses joining the suppliers table, thus it cannot provide the SupplierName. Additionally, the input code uses 'SupplierID' as the x-axis, which makes it less informative compared to using 'SupplierName' as in the reference.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    suppliers.CompanyName, 
    AVG([Order Details].Discount) AS avg_discount 
FROM 
    suppliers 
JOIN 
    products ON suppliers.SupplierID = products.SupplierID 
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY 
    suppliers.CompanyName
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to visualize the average discount per supplier
fig = px.bar(df, x='CompanyName', y='avg_discount', title='Average Discount per Supplier')

# Display the bar chart to the user
show_to_user(fig)
```","The input code successfully retrieves the average discount per supplier and creates a bar chart to visualize this information. Although the column labels and SQL SELECT fields differ ('CompanyName' vs 'SupplierName' and 'avg_discount' vs 'AverageDiscount'), the core logic aligns with the reference implementation: both join the relevant tables, group by supplier identifier/name, and calculate the average discount. The use of similar functions from Plotly to create the chart reinforces the correctness of the provided code.",Finetuned
"What is the total revenue generated from each product, and can you provide a bar chart to visualize the results?","```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str):
    # This function would interact with a database to fetch data
    # Placeholder example returning a DataFrame
    data = {
        'ProductName': ['Product1', 'Product2'],
        'TotalRevenue': [1000, 1500]
    }
    return pd.DataFrame(data)

# Utility function to display data or plots
def show_to_user(data):
    # Shows data analysis results or visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get total revenue by product
sql_query = """"""
SELECT ProductName, SUM(Quantity * UnitPrice * (1 - Discount)) AS TotalRevenue
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY ProductName;
""""""

# Execute the SQL query and get the results in a DataFrame
revenue_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total revenue by product
fig = px.bar(revenue_df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
""""""

revenue_df = execute_sql_query(sql_query)

fig = px.bar(revenue_df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product', labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly calculates the total revenue generated from each product using SQL and plots a bar chart using Plotly, which matches the logic of the reference implementation. Both codes perform the same SQL query using a JOIN between 'Order Details' and 'products', and they group by product name to calculate 'TotalRevenue'. The visualization step also adheres to the requirements using a bar chart.","
```python
import pandas as pd
import plotly.express as px

# SQL query to get total revenue from each product
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) as TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName;
""""""

# Execute the query and store the result in a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total revenue by product
fig = px.bar(data, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

# Display the visualization to the user
show_to_user(fig)
```
","The input code is not correct because it does not account for discounts in calculating the total revenue. The reference implementation includes the discount in the calculation: SUM(Quantity * UnitPrice * (1 - Discount)). The input code simplifies it to: SUM(Quantity * UnitPrice), which may result in a different total revenue value without considering discounts.",Base
"Which supplier has the most diverse product range, and can you provide a bar chart showing the number of different products offered by each supplier?","```python
import pandas as pd
import plotly.express as px

# SQL query to get product range for each supplier
sql_query = """"""
SELECT SupplierID, COUNT(DISTINCT CategoryID) AS ProductRange
FROM products
GROUP BY SupplierID;
""""""

# Execute SQL query using the utility function
df = execute_sql_query(sql_query)

# Find the supplier with the most diverse product range
top_supplier = df.sort_values(by='ProductRange', ascending=False).head(1)

# Display the top supplier
show_to_user(top_supplier)

# Create a bar chart of the number of different products offered by each supplier
fig = px.bar(df, x='SupplierID', y='ProductRange', title='Product Range by Supplier')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count the number of different products offered by each supplier
sql_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) AS ProductCount
FROM suppliers s
LEFT JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID
ORDER BY ProductCount DESC
""""""

# Execute the SQL query and retrieve the data
supplier_product_data = execute_sql_query(sql_query)

# Create a bar chart showing the number of different products offered by each supplier
fig = px.bar(supplier_product_data, x='CompanyName', y='ProductCount', 
             title='Number of Different Products Offered by Each Supplier',
             labels={'CompanyName': 'Supplier', 'ProductCount': 'Number of Products'})

# Show the bar chart to the user
show_to_user(fig)

# Identify the supplier with the most diverse product range
most_diverse_supplier = supplier_product_data.iloc[0]
most_diverse_supplier_info = pd.DataFrame([most_diverse_supplier])
show_to_user(most_diverse_supplier_info)
```","The input code counts the number of products each supplier offers using `COUNT(p.ProductID)` and orders them. It doesn't measure product diversity in terms of distinct categories (`CategoryID`) as in the reference code. Additionally, the input code uses LEFT JOIN on suppliers to products, which retains all suppliers even with no products, which may not align with measuring product diversity.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT SupplierID, COUNT(DISTINCT ProductID) AS DifferentProducts 
FROM products 
GROUP BY SupplierID 
ORDER BY DifferentProducts DESC;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Plotting the data as a bar chart to visualize the number of different products offered by each supplier
fig = px.bar(df, x='SupplierID', y='DifferentProducts', title='Number of Different Products by Supplier')

# Show the bar chart to the user
show_to_user(fig)
```","The input code and reference implementation are different in terms of logic. The reference code calculates the diversity of a supplier's product range by counting distinct CategoryIDs, whereas the input code counts distinct ProductIDs. The business request pertains to assessing product range diversity, which implies a count of unique categories rather than individual products.",None
Get the supplier details for products with the lowest units in stock and visualize the data in a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve supplier details for products with the lowest units in stock
sql_query = """"""
SELECT p.ProductName, s.SupplierID FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitsInStock = (SELECT MIN(UnitsInStock) FROM products);
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Check if data is not empty
if not data.empty:
    # Create a bar chart to visualize the data
    fig = px.bar(data, x='ProductName', y='SupplierID', title='Supplier Details for Products with Lowest Units in Stock')
    
    # Show the chart
    show_to_user(fig)
else:
    # Show the data if there are no results to visualize
    show_to_user(data)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitsInStock, s.SupplierID, s.SupplierName
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitsInStock = (
    SELECT MIN(UnitsInStock) FROM products
)
""""""

supplier_details = execute_sql_query(sql_query)

fig = px.bar(supplier_details, x='ProductName', y='UnitsInStock', color='SupplierID',
             title='Supplier Details for Products with Lowest Units in Stock',
             labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code includes additional details such as ProductID, UnitsInStock, SupplierName, and uses color coding in the bar chart, which are not part of the reference implementation's logic. The reference focuses specifically on matching the ProductName and SupplierID for products with the lowest units in stock without any additional attributes or coloring.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to mimic executing an SQL query.
    # In a real scenario, this would connect to a database and fetch data.
    pass

def show_to_user(data):
    # Placeholder function to mimic displaying data or a visualization.
    # In a real scenario, this would handle data frames or Plotly figures appropriately.
    pass

# SQL query to get the supplier details for products with the lowest units in stock
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, s.ContactName, p.ProductName, p.UnitsInStock 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
WHERE p.UnitsInStock = (SELECT MIN(UnitsInStock) FROM products);
""""""

# Execute the SQL query
supplier_details_df = execute_sql_query(sql_query)

# Visualizing the data using a bar chart with Plotly
fig = px.bar(supplier_details_df, 
             x='ProductName', 
             y='UnitsInStock', 
             color='CompanyName',
             title=""Supplier Details for Products with Lowest Units in Stock"",
             labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units In Stock'},
             barmode='group')

# Show the visualization to the user
show_to_user(fig)
```","The provided code meets the requirements of the business analytics request and aligns with the logic of the reference implementation. Both codes retrieve supplier details for products with the lowest units in stock. The input code additionally includes the company's and contact's names, which does not contradict the business requirement. The visualization uses a bar chart to display the product names and their corresponding units in stock, with supplier information included as a color-coded group to enhance interpretability. Therefore, the logic and goal of the reference implementation are preserved.",Finetuned
"What is the distribution of employees across different cities, and can this be visualized using a bar chart or map?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve city-wise employee distribution
sql_query = """"""
SELECT City, COUNT(EmployeeID) AS EmployeeCount FROM employees GROUP BY City;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(df, x='City', y='EmployeeCount', title='Employee Distribution by City')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT City, COUNT(EmployeeID) AS EmployeeCount
FROM employees
GROUP BY City;
""""""

employee_distribution = execute_sql_query(sql_query)

fig = px.bar(employee_distribution, x='City', y='EmployeeCount', title='Distribution of Employees Across Cities', labels={'EmployeeCount': 'Number of Employees', 'City': 'City'})
show_to_user(fig)
```","The input code correctly retrieves and processes the data to show the distribution of employees across different cities. It uses a SQL query to group by city and count employees, which matches the reference logic. It visualizes the data with a bar chart using Plotly Express, similar to the reference code. Despite slight changes in labels and title wording, the core logic and objective are met.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.City, COUNT(e.EmployeeID) AS EmployeeCount 
FROM employees e 
GROUP BY e.City;
""""""

# Execute the SQL query and retrieve the data
employee_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of employees across different cities
fig = px.bar(employee_data, x='City', y='EmployeeCount', title='Employee Distribution by City')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly executes a similar SQL query to retrieve the count of employees by city and visualizes the results using a bar chart with Plotly. The logic matches the reference implementation, fulfilling the business analytics request.",both
How many orders are shipped using more than one shipping method? Provide a visualization showing the distribution of shipping methods used in combination.,"```python
import pandas as pd
import plotly.express as px

# SQL query to count orders with more than one shipping method
sql_query_count = """"""
SELECT COUNT(*) AS OrderCount FROM (
    SELECT OrderID, COUNT(DISTINCT ShipVia) AS MethodCount 
    FROM orders 
    GROUP BY OrderID 
    HAVING MethodCount > 1
) AS MultiMethodOrders;
""""""

# SQL query to gather shipping method combinations
sql_query_methods = """"""
SELECT OrderID, ShipVia 
FROM orders 
WHERE OrderID IN (
    SELECT OrderID 
    FROM orders 
    GROUP BY OrderID 
    HAVING COUNT(DISTINCT ShipVia) > 1
);
""""""

# Execute the SQL queries using the utility function
order_count_df = execute_sql_query(sql_query_count)
shipment_methods_df = execute_sql_query(sql_query_methods)

# Display the count of orders with more than one shipping method
show_to_user(order_count_df)

# Analyze the combinations of shipping methods
combination_df = shipment_methods_df.groupby('OrderID')['ShipVia'].apply(lambda x: ', '.join(x.astype(str))).reset_index()
method_distribution_df = combination_df['ShipVia'].value_counts().reset_index()
method_distribution_df.columns = ['Combination', 'Count']

# Create a visualization of the distribution of shipping method combinations
fig = px.bar(method_distribution_df, x='Combination', y='Count', title='Distribution of Shipping Method Combinations')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to find orders shipped using more than one shipping method
sql_query = """"""
SELECT OrderID, COUNT(DISTINCT ShipVia) AS ShippingMethodsCount
FROM orders
GROUP BY OrderID
HAVING COUNT(DISTINCT ShipVia) > 1
""""""
multi_shipping_orders = execute_sql_query(sql_query)

# Count the total number of orders with multiple shipping methods
num_multi_shipping_orders = len(multi_shipping_orders)

# Visualization showing the distribution of shipping methods used in combination
shipping_methods_distribution = multi_shipping_orders['ShippingMethodsCount'].value_counts().reset_index()
shipping_methods_distribution.columns = ['ShippingMethodsCount', 'NumberOfOrders']

fig = px.bar(shipping_methods_distribution, 
             x='ShippingMethodsCount', 
             y='NumberOfOrders', 
             title='Distribution of Shipping Methods Used in Combination',
             labels={'ShippingMethodsCount': 'Number of Shipping Methods', 
                     'NumberOfOrders': 'Number of Orders'})

show_to_user(fig)
```","The input code does not directly count the number of distinct shipping method combinations used, nor does it match the logic of the reference code. Instead, it calculates a general count of orders with multiple shipping methods, but doesn't provide the actual combinations as shown in the reference which groups combinations. The reference code also visualizes combinations, not just the count of methods per order.","```python
import plotly.express as px
import pandas as pd

# SQL query to find orders using more than one shipping method
sql_query = """"""
SELECT o.OrderID, STRING_AGG(DISTINCT o.FreightCarrier, ', ') AS ShippingMethods
FROM orders o
GROUP BY o.OrderID
HAVING COUNT(DISTINCT o.FreightCarrier) > 1;
""""""

# Function to execute SQL query and return results as a pandas DataFrame
orders_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not orders_df.empty:
    # Process each order's ShippingMethods to count occurrences
    orders_df = orders_df.assign(ShippingMethods=orders_df['ShippingMethods'].str.split(', '))
    explode_orders_df = orders_df.explode('ShippingMethods')
    
    # Group by the combination of shipping methods and count occurrences
    shipping_distribution = explode_orders_df.groupby('ShippingMethods').size().reset_index(name='Count')
    
    # Create a bar plot using Plotly to visualize the distribution
    fig = px.bar(shipping_distribution, x='ShippingMethods', y='Count',
                 title='Distribution of Shipping Methods Used in Combination',
                 labels={'ShippingMethods': 'Shipping Methods', 'Count': 'Number of Orders'})

    # Display the figure to the user
    show_to_user(fig)
else:
    print(""No orders found that use more than one shipping method."")
```","The input code does not correctly evaluate the number of orders with more than one shipping method and does not display this count to the user. The reference code computes and displays the count of such orders, while the input code only checks for their existence. Additionally, the input code uses a different SQL column name ('FreightCarrier' instead of 'ShipVia'), which might be incorrect based on the reference context, and it does not aggregate combinations correctly for visualization.",None
What is the total revenue attributed to each supplier? Please include a bar chart to visualize the revenue distribution among suppliers.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get total revenue for each supplier
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.CompanyName;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function body for executing SQL query
    # Replace this block with actual implementation to connect to the database and retrieve data
    data = {
        'CompanyName': ['Supplier A', 'Supplier B', 'Supplier C'],
        'TotalRevenue': [25000, 50000, 35000]
    }
    return pd.DataFrame(data)

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='TotalRevenue', 
             title='Total Revenue by Supplier', 
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier'})

# Function to display the result
def show_to_user(data):
    # Placeholder function body to show data
    # In actual scenario, replace with code to show plot or DataFrame
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID, s.CompanyName
""""""

supplier_revenue_df = execute_sql_query(sql_query)

fig = px.bar(supplier_revenue_df, x='CompanyName', y='TotalRevenue', title='Total Revenue by Supplier', labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input Python code follows the same logic as the reference implementation. It calculates the total revenue for each supplier by summing the product of UnitPrice, Quantity, and adjusted for Discount within a SQL query. The SQL query syntax and logic are correct and equivalent to the reference implementation. The visualization of data using Plotly to create a bar chart is also consistent with the reference. Therefore, the input code is correct as it fulfills the business analytics request and adheres to the logic of the reference code.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT
    suppliers.SupplierID,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM
    suppliers
JOIN
    products ON suppliers.SupplierID = products.SupplierID
JOIN
    [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY
    suppliers.SupplierID;
""""""

# Execute the SQL query using the provided utility function
def execute_sql_query(sql_query: str):
    # Simulate function operation
    # In practice, there would be database connection and query execution
    # Here we return a sample DataFrame for illustration
    data = {
        'SupplierID': [1, 2, 3],
        'TotalRevenue': [1500, 2500, 3500]
    }
    return pd.DataFrame(data)

# Fetch the results into a DataFrame
df = execute_sql_query(sql_query)

# Create the bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='TotalRevenue', title='Total Revenue by Supplier')

# Display the bar chart
def show_to_user(data):
    # Simulate function operation
    # In practice, this would display data or a figure to the user
    if isinstance(data, pd.DataFrame):
        print(""Displaying DataFrame:"")
        print(data)
    elif hasattr(data, 'show'):
        print(""Displaying Plotly figure:"")
        data.show()

show_to_user(fig)
```","The input code calculates total revenue by 'SupplierID', not 'CompanyName' as the reference implementation does. This may cause a mismatch if 'SupplierID' and 'CompanyName' do not correlate as expected. Additionally, the sample data in the input uses different revenue values, altering the intended outcome. To be correct, the input should group by 'CompanyName' and provide equivalent sample output to match the reference logic.",Base
"Which month had the highest average order value, and provide a bar chart to visualize the monthly average order values?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS AvgOrderValue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY DATE_TRUNC('month', OrderDate)
ORDER BY AvgOrderValue DESC;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the monthly average order values
fig = px.bar(data, x='Month', y='AvgOrderValue', title='Monthly Average Order Values')

# Display the plot
show_to_user(fig)

# Get the month with the highest average order value
highest_avg_order_value_month = data.iloc[0]

# Display the month with the highest average order value
show_to_user(pd.DataFrame([highest_avg_order_value_month]))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    AverageOrderValue DESC
LIMIT 1
""""""

highest_avg_order_value = execute_sql_query(sql_query)

sql_query_all_months = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

monthly_avg_order_values = execute_sql_query(sql_query_all_months)

fig = px.bar(monthly_avg_order_values, x='Month', y='AverageOrderValue', 
             title='Monthly Average Order Values', labels={'AverageOrderValue': 'Average Order Value'})
show_to_user(fig)
```","The provided code does not correctly fulfill the request. It executes two SQL queries, one to find the month with the highest average order value and another to compute the average order values for all months. However, it does not display the month with the highest average order value as required. Additionally, the 'LIMIT 1' clause in the first SQL query returns only the top result, which isn't necessary unless the result is used. The reference implementation displays the month with the highest value and the corresponding chart.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get average monthly order values
sql_query = """"""
SELECT
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) /
    COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM
    orders o
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY
    DATE_TRUNC('month', o.OrderDate)
ORDER BY
    Month;
""""""

# Execute the SQL query
monthly_order_values = execute_sql_query(sql_query)

# Find the month with the highest average order value
max_month = monthly_order_values.loc[monthly_order_values['AverageOrderValue'].idxmax()]

# Print the month with the highest average order value
show_to_user(f""Month with highest average order value: {max_month['Month']}"")

# Generate a bar chart to visualize the monthly average order values
fig = px.bar(
    monthly_order_values,
    x='Month',
    y='AverageOrderValue',
    title='Monthly Average Order Values',
    labels={'AverageOrderValue': 'Average Order Value', 'Month': 'Month'},
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly queries the database for monthly average order values and finds the month with the highest value. Although the input code orders by month while the reference orders by average order value, it still achieves the correct result by using `idxmax()` to find the maximum average order value. It also generates a bar chart similar to the reference implementation. Both scripts adhere to the business requirement.",Finetuned
"What is the inventory turnover ratio for each product category last quarter, and can you provide a bar chart to visualize these ratios?","```python
import pandas as pd
import plotly.express as px

# Business analytic request code implementation
def analyze_inventory_turnover():
    # Define the SQL query
    sql_query = """"""
    SELECT c.CategoryName, 
           SUM([Order Details].Quantity * [Order Details].UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS turnover_ratio
    FROM [Order Details]
    JOIN products p ON [Order Details].ProductID = p.ProductID
    JOIN categories c ON p.CategoryID = c.CategoryID
    WHERE [Order Details].OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
    GROUP BY c.CategoryName
    """"""
    
    # Execute SQL query using the provided utility function
    df_turnover = execute_sql_query(sql_query)
    
    # Create a bar chart using Plotly
    fig = px.bar(df_turnover, x='CategoryName', y='turnover_ratio', 
                 title='Inventory Turnover Ratio per Product Category (Last Quarter)',
                 labels={'turnover_ratio': 'Turnover Ratio', 'CategoryName': 'Product Category'})
    
    # Display the bar chart
    show_to_user(fig)

# Execute the function to analyze and visualize inventory turnover
analyze_inventory_turnover()
```","```python
import pandas as pd
import plotly.express as px

last_quarter_start = '2023-07-01'
last_quarter_end = '2023-09-30'

sql_query = f""""""
SELECT 
    categories.CategoryName, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM 
    [Order Details]
JOIN 
    products ON [Order Details].ProductID = products.ProductID
JOIN 
    categories ON products.CategoryID = categories.CategoryID
WHERE 
    orders.OrderDate BETWEEN '{last_quarter_start}' AND '{last_quarter_end}'
GROUP BY 
    categories.CategoryName
""""""

turnover_df = execute_sql_query(sql_query)

fig = px.bar(turnover_df, x='CategoryName', y='inventory_turnover_ratio', title='Inventory Turnover Ratio by Product Category')
show_to_user(fig)
```","The evaluated code does not follow the same logic as the reference implementation. Notably, it does not handle division by zero (using NULLIF) for calculating the turnover ratio. Additionally, the SQL query references 'orders.OrderDate', but the table seems to be '[Order Details]'. The date range is also different from the reference implementation, which could result in evaluating a different quarter, but that's contextually unclear without further information. Finally, the column names in the SQL query and visualization should be consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholders, assume they are defined elsewhere as per the environment constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Executes SQL query and returns a pandas DataFrame
    pass

def show_to_user(data):
    # Displays data or a Plotly figure
    pass

# SQL Query that calculates the inventory turnover ratio for each product category last quarter
sql_query = """"""
SELECT 
    p.CategoryID, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnover 
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID 
JOIN 
    orders o ON od.OrderID = o.OrderID 
WHERE 
    o.OrderDate >= DATE_TRUNC('QUARTER', CURRENT_DATE - INTERVAL '1 QUARTER') 
    AND o.OrderDate < DATE_TRUNC('QUARTER', CURRENT_DATE) 
GROUP BY 
    p.CategoryID;
""""""

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='InventoryTurnover', 
             title='Inventory Turnover Ratio by Product Category (Last Quarter)',
             labels={'InventoryTurnover': 'Inventory Turnover Ratio', 'CategoryID': 'Product Category'})
# Display the bar chart
show_to_user(fig)
```","The input code does not correctly calculate the inventory turnover ratio as specified. The reference code uses a specific SQL query joining with the categories table and groups by CategoryName to get turnover ratios by category. The input code, on the other hand, groups by CategoryID and does not utilize the categories table, which means the category names won't be displayed correctly in the visualization. Furthermore, the logic to determine the last quarter's date range does not directly correspond to the reference code, which explicitly uses fixed dates. This discrepancy could lead to different sets of data being queried.",None
"List all products and their respective stock and order quantities, and provide a bar chart to visualize the comparison between stock and order quantities for each product.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function, would include actual database execution logic
    # Example return: Use proper database handling to replace this DataFrame
    data = {
        ""ProductName"": [""Product A"", ""Product B"", ""Product C""],
        ""UnitsInStock"": [20, 50, 30],
        ""UnitsOnOrder"": [5, 10, 15]
    }
    return pd.DataFrame(data)

# Utility function to show data to the user
def show_to_user(data):
    # Simulated function, would be customized as needed for display
    pass

# SQL query
sql_query = ""SELECT ProductName, UnitsInStock, UnitsOnOrder FROM products;""

# Execute query to get DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df, 
    x='ProductName', 
    y=['UnitsInStock', 'UnitsOnOrder'], 
    barmode='group',
    title='Comparison of Stock and Order Quantities by Product',
    labels={'value':'Quantity', 'ProductName':'Product'}
)

# Display the figure using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitsInStock, UnitsOnOrder
FROM products
""""""

product_data = execute_sql_query(sql_query)

fig = px.bar(product_data, 
              x='ProductName', 
              y=['UnitsInStock', 'UnitsOnOrder'], 
              barmode='group', 
              title='Comparison of Stock and Order Quantities for Each Product',
              labels={'value': 'Quantity', 'variable': 'Status'})
show_to_user(fig)
```","The input code fulfills the business analytics request correctly. It executes an SQL query to retrieve the product name along with their stock and order quantities, as required. The retrieved data is then used to create a bar chart using Plotly, comparing 'UnitsInStock' and 'UnitsOnOrder' for each product. The logic is consistent with the reference implementation, despite minor differences in variable names and chart label specifications.","```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitsInStock, SUM(od.Quantity) AS UnitsOnOrder 
FROM products p 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName, p.UnitsInStock;
""""""

# Execute the SQL query to get the data into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to compare stock and order quantities
fig = px.bar(
    df, 
    x='ProductName', 
    y=['UnitsInStock', 'UnitsOnOrder'],
    labels={'value': 'Quantity', 'variable': 'Stock vs Order'},
    title='Comparison of Product Stock and Order Quantities'
)

# Display the bar chart
show_to_user(fig)
```","The input code correctly retrieves product data and visualizes stock and order quantities similarly to the reference. It uses a SQL query with JOIN and GROUP BY to calculate 'UnitsOnOrder', which is a valid alternative to the reference's static data. The Plotly bar chart configuration achieves the same goal of illustrating stock vs. order quantities. The minor differences in SQL and chart label details do not affect the overall correctness in fulfilling the business request.",both
"Which supplier has delivered the highest total number of product units, and can this information be visualized in a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the supplier with the highest total number of product units
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnits 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID 
ORDER BY TotalUnits DESC 
LIMIT 1;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# If we have results, visualize them
if not result_df.empty:
    # Create a bar chart to visualize the supplier's total units
    fig = px.bar(result_df, x='SupplierID', y='TotalUnits',
                 title='Supplier with Highest Total Number of Product Units',
                 labels={'SupplierID': 'Supplier ID', 'TotalUnits': 'Total Units'},
                 text='TotalUnits')
    
    # Show the bar chart to the user
    show_to_user(fig)
else:
    # If the result is empty, show the user a message
    no_data_df = pd.DataFrame({'Message': ['No data available']})
    show_to_user(no_data_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, SUM(od.Quantity) AS TotalUnits
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY s.CompanyName
ORDER BY TotalUnits DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)
supplier_name = result_df['CompanyName'].values[0]
total_units = result_df['TotalUnits'].values[0]

bar_chart_df = pd.DataFrame({
    'Supplier': [supplier_name],
    'Total Units Delivered': [total_units]
})

fig = px.bar(bar_chart_df, x='Supplier', y='Total Units Delivered', title='Supplier with Highest Total Units Delivered')
show_to_user(fig)
```","Both the reference and input code aim to find the supplier with the highest total number of product units delivered. They use SQL to aggregate and sum quantities based on suppliers, ordering by total units in descending order, and limiting the result to the top supplier. The input code uses slightly different SQL table names and joins, but achieves the same logical goal. Both implementations visualize the result in a bar chart and display it using `show_to_user()`.","```python
import plotly.express as px
import pandas as pd

# SQL query to find the supplier with the highest total units delivered
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity) AS TotalUnits 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID 
ORDER BY TotalUnits DESC;
""""""

# Execute the SQL query and retrieve the data
data = execute_sql_query(sql_query)

# Check if data is empty
if data.empty:
    show_to_user(""No data available."")
else:
    # Extract the supplier with the highest total units and plot the chart
    top_supplier = data.head(1)
    
    # Visualize the data using a bar chart (though it will only have one bar)
    fig = px.bar(top_supplier, x='SupplierID', y='TotalUnits', title='Top Supplier by Total Units Delivered')

    # Show the top supplier data to the user
    show_to_user(top_supplier)
    
    # Display the bar chart
    show_to_user(fig)
```","The input code correctly implements the logic required by the business analytics request. It executes an SQL query to determine which supplier has delivered the highest total number of product units, sorts the results in descending order, and retrieves the top result. It then visualizes this result using a bar chart, aligning with the reference code's logic. Both codes handle the case where no data is available, ensuring meaningful feedback is provided to the user. The primary difference is the method of data extraction after the SQL query execution, but both approaches ultimately produce the same result: displaying the top supplier's data.",both
"Which shipper has the highest on-time delivery rate in 2023? Additionally, can you provide a bar chart to compare the on-time delivery rates of all shippers?","
import pandas as pd
import plotly.express as px

# Utility function placeholder. Replace with the actual implementation.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Imagine this function runs the SQL and returns a DataFrame.
    pass

def show_to_user(data):
    # Imagine this function displays the data or figure to the user.
    pass

# SQL query to get on-time delivery rates for all shippers in 2023
sql_query = """"""
SELECT shippers.CompanyName, 
       (COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) / 
       CAST(COUNT(orders.OrderID) AS FLOAT) * 100) AS on_time_delivery_rate 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY shippers.CompanyName 
ORDER BY on_time_delivery_rate DESC;
""""""

# Execute the query and get results as a DataFrame
df = execute_sql_query(sql_query)

# Determine the shipper with the highest on-time delivery rate
top_shipper = df.iloc[0]
print(""Shipper with highest on-time delivery rate in 2023:"")
print(top_shipper)

# Create a bar chart to compare the on-time delivery rates of all shippers
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate', 
             title='On-Time Delivery Rates of Shippers in 2023',
             labels={'on_time_delivery_rate': 'On-Time Delivery Rate (%)',
                     'CompanyName': 'Shipper'})

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, 
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY shippers.CompanyName
ORDER BY on_time_delivery_rate DESC;
""""""

on_time_delivery_df = execute_sql_query(sql_query)

highest_shipper = on_time_delivery_df.iloc[0]

comparison_query = """"""
SELECT shippers.CompanyName, 
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS on_time_delivery_rate
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY shippers.CompanyName;
""""""

comparison_df = execute_sql_query(comparison_query)

fig = px.bar(comparison_df, x='CompanyName', y='on_time_delivery_rate', title='On-time Delivery Rate by Shipper in 2023')
show_to_user(fig)

highest_shipper
```","The provided Python code correctly follows the logic of the reference implementation. It executes an SQL query to find the on-time delivery rates for shippers in 2023, identifies the shipper with the highest rate, and generates a bar chart comparing all shippers' rates. The two queries used serve the same purpose as the single query in the reference by prioritizing simplicity and separation of tasks, which is logically consistent with the business request.","
import pandas as pd
import plotly.express as px

# SQL query to fetch on-time delivery rates for all shippers in 2023
sql_query = """"""
SELECT ShipVia, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN OrderID END) * 1.0 / COUNT(OrderID)) * 100 AS OnTimeRate 
FROM orders 
WHERE YEAR(ShippedDate) = 2023 
GROUP BY ShipVia 
ORDER BY OnTimeRate DESC;
""""""

# Execute the SQL query to fetch data
df_shippers = execute_sql_query(sql_query)

# Determine which shipper has the highest on-time delivery rate
best_shipper = df_shippers.iloc[0]['ShipVia']
best_shiper_rate = df_shippers.iloc[0]['OnTimeRate']

# Create a bar chart to compare the on-time delivery rates of all shippers
fig = px.bar(df_shippers, x='ShipVia', y='OnTimeRate', 
             title='On-Time Delivery Rates of Shippers in 2023',
             labels={'OnTimeRate': 'On-Time Delivery Rate (%)', 'ShipVia': 'Shipper'})

# Show the bar chart to the user
show_to_user(fig)

# Show the shipper with the highest on-time delivery rate
highest_rate_df = pd.DataFrame({'Best Shipper': [best_shipper], 'Highest Rate (%)': [best_shiper_rate]})
show_to_user(highest_rate_df)
","The input code uses `ShipVia` without joining with the `shippers` table, which results in using a numeric ID instead of the shipper's name. The code calculates the on-time rate using `YEAR(ShippedDate) = 2023`, which may exclude orders shipped late in 2023; the reference uses `OrderDate` which considers all orders in 2023. Additionally, the code returns a numeric ID and fails to transform it into a meaningful shipper company name in the output.",Base
"Which products should be considered for discontinuation based on sales, and how can a sales trend chart enhance the understanding of these products' performance?","```python
import pandas as pd
import plotly.express as px

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # A mock function representing the execution of an SQL query
    # Replace with actual database connection in a real scenario
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'TotalQuantity': [50, 30, 20],
        'ReorderLevel': [60, 40, 25]
    }
    df = pd.DataFrame(data)
    return df.query('TotalQuantity < ReorderLevel')

def show_to_user(data):
    # A mock function to display data or visualization
    print(data)

# SQL Query and Data Extraction
sql_query = """"""
SELECT ProductName
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY ProductName
HAVING SUM([Order Details].Quantity) < MIN(ReorderLevel);
""""""
products_to_discontinue = execute_sql_query(sql_query)

# Business Logic to Identify Products for Discontinuation
discontinued_products = products_to_discontinue['ProductName'].tolist()

# Visual Representation of Sales Trends for Products
# Assuming we have sales time series data available for trend visualization
sales_data = {
    'ProductName': ['Product A', 'Product A', 'Product B', 'Product B', 'Product C', 'Product C'],
    'Date': ['2023-07-01', '2023-08-01', '2023-07-01', '2023-08-01', '2023-07-01', '2023-08-01'],
    'Sales': [20, 30, 10, 20, 15, 5]
}
df_sales_trend = pd.DataFrame(sales_data)

# Filter sales data for products identified for discontinuation
sales_trend_discontinued = df_sales_trend[df_sales_trend['ProductName'].isin(discontinued_products)]

# Plotting sales trend
fig = px.line(sales_trend_discontinued, x='Date', y='Sales', color='ProductName',
              title='Sales Trend for Products Considered for Discontinuation')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve product performance data
sql_query_performance = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""
performance_data = execute_sql_query(sql_query_performance)

# Identify products for discontinuation (e.g., those with TotalSales < threshold)
threshold = 50
products_to_discontinue = performance_data[performance_data['TotalSales'] < threshold]

# SQL query to retrieve sales trend data
sql_query_trend = """"""
SELECT p.ProductID, p.ProductName, DATE_FORMAT(o.OrderDate, '%Y-%m') AS SaleMonth,
       SUM(od.Quantity) AS MonthlySales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY p.ProductID, p.ProductName, SaleMonth
ORDER BY SaleMonth
""""""
trend_data = execute_sql_query(sql_query_trend)

# Visualize sales trend for products selected for discontinuation
fig = px.line(trend_data[trend_data['ProductID'].isin(products_to_discontinue['ProductID'])],
               x='SaleMonth', y='MonthlySales', color='ProductName',
               title='Sales Trend of Products Considered for Discontinuation')
show_to_user(fig)

# Show results of products to discontinue
show_to_user(products_to_discontinue)
```","The input code does not correctly implement the logic specified in the reference code. The reference implementation identifies products to discontinue based on 'TotalQuantity < ReorderLevel'. However, the input code uses 'TotalSales < threshold', which is a different criterion. Additionally, the reference implementation filters and visualizes sales trends for identified products using predefined sales data, while the input code retrieves historical sales data via a SQL query, which deviates from the reference logic.","```python
import plotly.express as px
import pandas as pd

# SQL query to extract data from the database
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE p.Discontinued = 0 
GROUP BY p.ProductID, p.ProductName 
ORDER BY TotalSales ASC
""""""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Identify products for potential discontinuation: those with zero sales
discontinued_products = products_df[products_df['TotalSales'] == 0]

# Display products considered for discontinuation
show_to_user(discontinued_products)

# Create a sales trend chart to better understand product performance
sales_trend_chart = px.line(
    products_df, 
    x='ProductID', 
    y='TotalSales', 
    title='Sales Trend of Products',
    labels={'TotalSales': 'Total Sales', 'ProductID': 'Product ID'}
)

# Display the sales trend chart
show_to_user(sales_trend_chart)
```","The input code checks for products with zero sales instead of comparing total sales with a reorder level, which deviates from the provided logic of the reference code. Additionally, the input code orders by total sales in ascending order, while the reference implementation identifies products where sales are less than the reorder level using a specific condition. Furthermore, the sales trend chart in the input code plots total sales against Product ID, whereas the reference plots sales over time by date for identified products.",None
Determine the month with the highest total product sales value and provide a bar chart to visualize monthly sales values.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly sales values
sql_query = """"""
    SELECT EXTRACT(MONTH FROM o.OrderDate) AS SalesMonth, 
           SUM(od.Quantity * od.UnitPrice) AS TotalSales 
    FROM [Order Details] od 
    JOIN orders o ON od.OrderID = o.OrderID 
    GROUP BY SalesMonth 
    ORDER BY SalesMonth;
""""""

# Execute the SQL query and retrieve the data
monthly_sales_df = execute_sql_query(sql_query)

# Find the month with the highest total sales value
highest_sales_month = monthly_sales_df.loc[monthly_sales_df['TotalSales'].idxmax()]

# Create a bar chart to visualize monthly sales values
fig = px.bar(monthly_sales_df, x='SalesMonth', y='TotalSales', 
             title='Monthly Sales Values',
             labels={'SalesMonth': 'Month', 'TotalSales': 'Total Sales Value'},
             text='TotalSales')

# Show the figure using the utility function
show_to_user(fig)

# Optionally print or show the month with the highest sales
show_to_user(pd.DataFrame([highest_sales_month]).reset_index(drop=True))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM 
    ""Order Details"" od
JOIN 
    orders o ON od.OrderID = o.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    p.Discontinued = 0
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

monthly_sales = execute_sql_query(sql_query)

highest_sales_month = monthly_sales.loc[monthly_sales['TotalSales'].idxmax()]

fig = px.bar(monthly_sales, x='Month', y='TotalSales', title='Monthly Sales Values', labels={'TotalSales': 'Total Sales ($)', 'Month': 'Month'})
show_to_user(fig)

highest_sales_month
```","The input code uses DATE_TRUNC for month extraction and accounts for discontinued products and discounts, which introduces additional criteria not present in the reference code. The reference code uses EXTRACT(MONTH FROM o.OrderDate) for month extraction and doesn't apply discounts or product discontinuation filters, which aligns it more closely with the straightforward task requirement.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve monthly sales data
sql_query = """"""
SELECT DATE_TRUNC('month', O.OrderDate) AS Month, 
       SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales 
FROM [Order Details] OD 
JOIN orders O ON OD.OrderID = O.OrderID 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute SQL query to get data
sales_data = execute_sql_query(sql_query)

# Log the monthly sales data
show_to_user(sales_data)

# Determine the month with the highest total sales
max_sales_month = sales_data.loc[sales_data['TotalSales'].idxmax()]

# Visualize the monthly sales data
fig = px.bar(sales_data, x='Month', y='TotalSales', 
             title='Monthly Product Sales Values',
             labels={'Month':'Month', 'TotalSales':'Total Sales'},
             text='TotalSales')

# Enhance chart readability
fig.update_layout(xaxis_title='Month',
                  yaxis_title='Total Sales',
                  xaxis_tickformat='%Y-%m')

# Display the bar chart
show_to_user(fig)
```","The input code calculates the total sales using a different formula by including a discount multiplier. This can lead to different results if discounts affect the totals. Additionally, the input code uses DATE_TRUNC to group by full date 'month', which can impact the grouping precision. These differences mean the logic does not fully adhere to the reference implementation.",None
What are the top 5 cities with the highest number of orders? Please include a bar chart to visualize the order counts for these cities.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to fetch the top 5 cities with the highest number of orders
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS order_count 
FROM orders 
GROUP BY ShipCity 
ORDER BY order_count DESC 
LIMIT 5
""""""
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the order counts for these cities
fig = px.bar(top_cities_df, x='ShipCity', y='order_count', 
             title='Top 5 Cities with Highest Number of Orders', 
             labels={'ShipCity': 'City', 'order_count': 'Number of Orders'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS order_count
FROM orders
GROUP BY ShipCity
ORDER BY order_count DESC
LIMIT 5;
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='ShipCity', y='order_count', title='Top 5 Cities with Highest Number of Orders')
show_to_user(fig)
```","The input Python code fulfills the business analytics request by selecting the top 5 cities with the highest number of orders and creating a bar chart to visualize these counts. It follows the same logic and queries as the reference implementation. Although some syntax and formatting variations exist, they do not affect the outcome or correctness of the code.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC 
LIMIT 5;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the order counts for the top 5 cities
fig = px.bar(df, x='ShipCity', y='OrderCount', title='Top 5 Cities by Order Count')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code executes an SQL query correctly targeting the top 5 cities with the highest number of orders by grouping on 'ShipCity' and counting the 'OrderID'. The query limits the results to 5 cities with the highest counts. It then uses Plotly Express to create a bar chart, similar to the reference implementation. Although the code structure and variable names are slightly different (e.g., 'OrderCount' vs. 'order_count'), the logic and output are equivalent, fulfilling the business analytics request.",both
"Which product generated the highest sales revenue in March 2023, and can a bar chart be used to visualize the sales revenue of each product?","```python
import pandas as pd
import plotly.express as px

# SQL query to get sales revenue per product for March 2023
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS sales_revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31' 
GROUP BY products.ProductName 
ORDER BY sales_revenue DESC
""""""

# Execute the SQL query to get results in a DataFrame
df = execute_sql_query(sql_query)

# Display the product with the highest sales revenue
highest_sales_product = df.head(1)
show_to_user(highest_sales_product)

# Visualize the sales revenue of each product using a bar chart
fig = px.bar(df, x='ProductName', y='sales_revenue', title='Sales Revenue of Each Product in March 2023')
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY total_revenue DESC
LIMIT 1;
""""""

highest_sales_product = execute_sql_query(sql_query)

product_name = highest_sales_product['ProductName'].values[0]
total_revenue = highest_sales_product['total_revenue'].values[0]

revenue_query = """"""
SELECT products.ProductName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE orders.OrderDate BETWEEN '2023-03-01' AND '2023-03-31'
GROUP BY products.ProductName;
""""""

revenue_data = execute_sql_query(revenue_query)

fig = px.bar(revenue_data, x='ProductName', y='total_revenue', title='Sales Revenue by Product in March 2023')
show_to_user(fig)
```","The input code correctly retrieves the product with the highest sales revenue in March 2023 using an SQL query. It also creates and displays a bar chart of the sales revenue for each product, in line with the business analytics request and the logic detailed in the reference implementation. The main difference is that the input code uses two queries: one to find the highest-grossing product and another to generate the bar chart data. This does not affect correctness as it fulfills the task requirements.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This should connect to the database and execute the query, returning a DataFrame
    pass

def show_to_user(data):
    # This function serves to display pandas DataFrame or Plotly figures
    pass

# SQL query to obtain sales revenue for each product in March 2023
sql_query = """"""
SELECT p.ProductID, 
       SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
WHERE MONTH(o.OrderDate) = 3 
  AND YEAR(o.OrderDate) = 2023 
GROUP BY p.ProductID 
ORDER BY TotalRevenue DESC;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Find the product with the highest sales
highest_sales_product = sales_data.head(1)

# Display the product generating the highest sales revenue
show_to_user(highest_sales_product)

# Create a bar chart for the sales revenue of each product
bar_chart = px.bar(sales_data, x='ProductID', y='TotalRevenue', title='Sales Revenue by Product for March 2023')

# Display the bar chart
show_to_user(bar_chart)
```","The input code incorrectly calculates 'TotalRevenue' by not considering discounts applied to each order line item. The reference code uses 'SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))' which accounts for discounts, whereas the input code uses 'SUM(od.Quantity * od.UnitPrice)' which does not include discounts. This can lead to an incorrect highest sales product. Product name representation is also missing in the input code's SQL query.",Base
What is the average order fulfillment time each month? Please include a line chart to visualize monthly trends.,"import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY DATE_TRUNC('month', OrderDate);
""""""

# Execute the SQL query and get results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(df, x='Month', y='AverageFulfillmentTime', title='Average Order Fulfillment Time by Month')

# Display the result to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)

fig = px.line(average_fulfillment_time_df, x='Month', y='AvgFulfillmentTime', 
              title='Average Order Fulfillment Time by Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'Month': 'Month'})
show_to_user(fig)
```","The input Python code correctly computes the average order fulfillment time for each month, similar to the reference implementation. It uses a SQL query to group data by month and calculates the average difference in days between the 'ShippedDate' and 'OrderDate'. The difference in using DATE_FORMAT versus DATE_TRUNC is contextual based on SQL dialect but both are meant to aggregate by month. The resulting data is visualized using a line chart in Plotly, which aligns with the business request to visualize monthly trends. The labels added in the line chart enhance clarity but do not change the logic. Thus, the implementation aligns with the reference implementation's logic and produces the correct results.","```python
import pandas as pd
import plotly.express as px

# SQL query to get average order fulfillment time each month
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') as month,
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) as avg_fulfillment_time
FROM orders
GROUP BY month
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Convert month column to datetime for proper sorting
df['month'] = pd.to_datetime(df['month'])

# Create a line chart to visualize monthly trends of average fulfillment time
fig = px.line(df, x='month', y='avg_fulfillment_time', 
              title='Monthly Average Order Fulfillment Time',
              labels={'month': 'Month', 'avg_fulfillment_time': 'Avg Fulfillment Time (days)'})

# Display the line chart using the utility function
show_to_user(fig)
```","The provided code correctly addresses the business analytics request. It queries the average order fulfillment time for each month using a similar logic to the reference implementation. Both codes compute the average of date differences between 'ShippedDate' and 'OrderDate', grouped by month. While the SQL syntax differs slightly, it achieves the same result. The input code also uses Plotly to create a line chart for visualization and ensures the 'month' column is treated as a datetime type for proper sorting, which aligns with the reference code's intention.",both
"What is the percentage of orders delivered before the required date for the last three months, and can this be shown with a monthly trend line chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the percentage of on-time deliveries for the last three months
sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS month,
    100.0 * COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN orders.OrderID END) / COUNT(orders.OrderID) AS on_time_rate
FROM 
    orders 
WHERE 
    orders.OrderDate BETWEEN DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 months' AND CURRENT_DATE
GROUP BY 
    month
ORDER BY 
    month
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly trend of the on-time delivery rate
fig = px.line(data, x='month', y='on_time_rate', title='Monthly On-Time Delivery Rate', labels={'on_time_rate': 'On-Time Delivery Rate (%)', 'month': 'Month'})

# Display the line chart
show_to_user(fig)
```","```python
from datetime import datetime, timedelta
import pandas as pd
import plotly.express as px

# Calculate the date range for the last three months
end_date = datetime.now()
start_date = end_date - timedelta(days=90)

# SQL query to get the monthly on-time delivery rates for the last three months
sql_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) * 100 AS on_time_delivery_percentage
FROM 
    orders
WHERE 
    OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY 
    month
ORDER BY 
    month;
""""""

# Execute the SQL query and store the results in a DataFrame
delivery_data = execute_sql_query(sql_query)

# Create a line chart to show the on-time delivery percentage trend
fig = px.line(delivery_data, x='month', y='on_time_delivery_percentage', 
              title='On-time Delivery Percentage Trend for the Last Three Months', 
              labels={'on_time_delivery_percentage': 'On-time Delivery Percentage'})

# Show the chart to the user
show_to_user(fig)
```","The input code correctly implements the logic described in the reference implementation. Both codes calculate the percentage of orders that were delivered on time over the last three months, although they use slightly different SQL functions ('DATE_TRUNC' vs. 'DATE_FORMAT') which are platform-specific. The SQL query logic remains consistent in that both count the orders delivered on time divided by the total, and output a percentage. Both codes execute the query, store results in a pandas DataFrame, and utilize Plotly Express to create a line chart to display the trend. Therefore, the input code meets the business analytics request as effectively as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate percentage of orders delivered on time for the last three months
sql_query = """"""
    SELECT DATE_TRUNC('month', OrderDate) as Month,
           COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(*) AS OnTimeDeliveryRate
    FROM orders
    WHERE OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '3 months'
    GROUP BY Month
    ORDER BY Month;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Replace with actual implementation
    pass

# Function to display the data to the user
def show_to_user(data):
    # Placeholder function: Replace with actual visualization
    pass

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Ensure df is not None and has the necessary columns
if df is not None and 'Month' in df.columns and 'OnTimeDeliveryRate' in df.columns:
    # Convert Month to datetime if it's not already
    df['Month'] = pd.to_datetime(df['Month'])

    # Generate a line chart using Plotly
    fig = px.line(df, x='Month', y='OnTimeDeliveryRate', title='Monthly On-Time Delivery Rate for Last 3 Months')

    # Display the figure
    show_to_user(fig)
else:
    show_to_user(""Error: Data not available for the specified period."")
```","The input code correctly implements the logic to calculate the percentage of orders delivered on or before the required date over the past three months. It uses SQL to compute this percentage by comparing the ShippedDate and RequiredDate. It also correctly groups the result by month and sorts it accordingly. The result is then visualized using a line chart with Plotly, similar to the reference implementation. Thus, the input code aligns with the business analytics request.",both
"Which products have the highest reorder level, and can this be visualized in a bar chart for better clarity?","```python
import pandas as pd
import plotly.express as px

# SQL query to get products with the highest reorder level
sql_query = """"""
SELECT ProductName, ReorderLevel 
FROM products 
WHERE ReorderLevel = (
    SELECT MAX(ReorderLevel) 
    FROM products
);
""""""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(products_df)

# Create a bar chart for better clarity
fig = px.bar(products_df, x='ProductName', y='ReorderLevel', title='Products with Highest Reorder Level')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, ReorderLevel
FROM products
ORDER BY ReorderLevel DESC
""""""
products_reorder = execute_sql_query(sql_query)

fig = px.bar(products_reorder, x='ProductName', y='ReorderLevel', title='Products by Reorder Level', labels={'ReorderLevel': 'Reorder Level', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code sorts all products by ReorderLevel in descending order but does not filter to only show products with the highest ReorderLevel. The reference code uses a subquery to select products with the maximum ReorderLevel, ensuring only those are displayed. The input code may visualize many products, not just those with the highest reorder level.","```python
import plotly.express as px

# SQL query to fetch products with the highest reorder level
sql_query = ""SELECT ProductName, ReorderLevel FROM products ORDER BY ReorderLevel DESC;""

# Execute the SQL query and fetch results into a DataFrame
products_df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(products_df, x='ProductName', y='ReorderLevel', 
             title='Products with Highest Reorder Levels',
             labels={'ProductName': 'Product Name', 'ReorderLevel': 'Reorder Level'})

# Display the bar chart
show_to_user(fig)
```","The input code retrieves all products sorted by 'ReorderLevel' in descending order and displays them, whereas the reference implementation specifically selects only those with the highest 'ReorderLevel'. Consequently, the results will differ if there are multiple products with various reorder levels, as the input code does not filter the maximum values like the reference code.",None
Which supplier contributed the most to our total sales? Please include a data visualization to illustrate the contribution of each supplier.,"```python
import plotly.express as px
import pandas as pd

# SQL query
sql_query = """"""
SELECT suppliers.SupplierID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
          (1 - [Order Details].Discount)) AS supplier_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID 
ORDER BY supplier_sales DESC
""""""

# Execute the SQL query using the utility function and return DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize supplier contributions
fig = px.bar(sales_data, 
             x='SupplierID', 
             y='supplier_sales', 
             title='Supplier Contribution to Total Sales',
             labels={'SupplierID': 'Supplier ID', 'supplier_sales': 'Total Sales'},
             template='plotly_dark')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY total_sales DESC
""""""

supplier_sales = execute_sql_query(sql_query)

fig = px.bar(supplier_sales, x='CompanyName', y='total_sales', 
             title='Total Sales Contribution by Supplier', 
             labels={'CompanyName': 'Supplier', 'total_sales': 'Total Sales'})
show_to_user(fig)
```","The input code correctly implements the required logic as the reference code. Both codes calculate the total sales per supplier by joining the relevant tables, computing the sales, and using a GROUP BY clause. The input code includes the supplier's company name for more detailed labeling, which is acceptable. The data visualization effectively illustrates the contribution of each supplier as requested.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS supplier_sales 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.CompanyName 
ORDER BY supplier_sales DESC
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the contribution of each supplier
fig = px.bar(df, x='CompanyName', y='supplier_sales', title='Sales Contribution by Supplier', labels={'supplier_sales': 'Sales Amount', 'CompanyName': 'Supplier'})

# Display the visualized data
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request by identifying which supplier contributed the most to total sales. The SQL query logic is equivalent to the reference implementation, calculating total sales per supplier and ordering it in descending order. The visualization uses Plotly to create a bar chart, similar to the reference code, with appropriate labeling and a clear title. The only difference is that the input code uses 'CompanyName' instead of 'SupplierID,' but this still meets the requirements as the code logic remains consistent with the reference implementation.",both
"What is the average discount for each order, and can this be visualized using a histogram or bar chart to show the distribution across orders?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT OrderID, AVG(Discount) AS AverageDiscount FROM [Order Details] GROUP BY OrderID;
'''

# Execute the SQL query and get the result as a DataFrame
order_discounts_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discount per order
fig = px.bar(order_discounts_df, x='OrderID', y='AverageDiscount', 
             title='Average Discount per Order',
             labels={'OrderID': 'Order ID', 'AverageDiscount': 'Average Discount'},
             height=400)

# Utilize the utility function to display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.histogram(average_discount_df, x='AverageDiscount', title='Distribution of Average Discounts per Order')
show_to_user(fig)
```","Both implementations correctly calculate the average discount per order using a similar SQL query. The reference code uses a bar chart with 'OrderID' on the x-axis to show individual averages per order, while the input code uses a histogram to show the distribution of average discounts. The use of a histogram is valid according to the request, which allows for either a histogram or a bar chart. The logic for calculating average discounts is consistent between both codes.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL and return result as DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution
    # This should execute the SQL query and return the result as a DataFrame
    pass

# Function to display data or visualization
def show_to_user(data):
    # Placeholder to display the DataFrame or Plotly figure
    pass

# SQL query to get the average discount per order
sql_query = """"""
SELECT OrderID, AVG(Discount) AS AvgDiscount 
FROM [Order Details]
GROUP BY OrderID;
""""""

# Execute the SQL query and fetch the result
df = execute_sql_query(sql_query)

# Plot using a bar chart to visualize the average discount per order
fig = px.bar(df, x='OrderID', y='AvgDiscount', 
             title='Average Discount Per Order',
             labels={'OrderID': 'Order ID', 'AvgDiscount': 'Average Discount'},
             template='plotly')

# Show the bar chart to the user
show_to_user(fig)
```","The input code is correct because it follows the same logic as the reference implementation. Both codes execute a SQL query to calculate the average discount for each order, store the results in a DataFrame, and then create a bar chart using Plotly to visualize the average discount per order. Minor differences in variable names and presentation (e.g., 'AvgDiscount' vs. 'AverageDiscount') do not affect the correctness.",both
"How often are products reordered compared to their reorder level, and can this be visualized with a bar chart showing reorder frequency against reorder levels for each product?","```python
import plotly.express as px
import pandas as pd

# SQL query to get the product reorder information
sql_query = """"""
SELECT ProductName, (UnitsOnOrder - ReorderLevel) AS ReorderDifference 
FROM products 
WHERE (UnitsOnOrder - ReorderLevel) > 0;
""""""

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation would connect to a database, execute the query, and return a DataFrame
    pass

# Fetching data from the database using the SQL query
data_df = execute_sql_query(sql_query)

# Visualizing the reorder frequency compared to reorder levels
fig = px.bar(data_df, x='ProductName', y='ReorderDifference', 
             labels={'ReorderDifference': 'Reorder Frequency'},
             title='Reorder Frequency vs Reorder Levels for Each Product')

# Displaying the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, p.ReorderLevel, 
       COUNT(od.ProductID) AS ReorderFrequency
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName, p.ReorderLevel
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ReorderLevel', y='ReorderFrequency', 
              color='ProductName', 
              labels={'ReorderLevel': 'Reorder Level', 'ReorderFrequency': 'Reorder Frequency'},
              title='Reorder Frequency vs Reorder Level for Each Product')

show_to_user(fig)
```","The input code does not adhere to the same logic as the reference implementation. The reference implementation calculates 'ReorderDifference' as the difference between 'UnitsOnOrder' and 'ReorderLevel' and considers only products where this difference is positive. The input code calculates 'ReorderFrequency' based on a count of product orders and does not filter by 'UnitsOnOrder' and 'ReorderLevel' difference. Additionally, the input bar chart uses 'ReorderLevel' as the x-axis, which doesn't match the purpose of visualizing the difference or frequency correctly in relation to the reorder levels.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT 
    p.ProductName, 
    COUNT(DISTINCT od.OrderID) AS ReorderFrequency, 
    p.ReorderLevel 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    p.ProductName, p.ReorderLevel 
ORDER BY 
    ReorderFrequency DESC;
""""""

# Function to execute the SQL query and return the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize reorder frequency against reorder levels
fig = px.bar(
    df,
    x='ProductName',
    y='ReorderFrequency',
    title='Reorder Frequency vs Reorder Levels for Each Product',
    labels={'ReorderFrequency': 'Reorder Frequency', 'ProductName': 'Product Name'},
    hover_data={'ReorderLevel': True},
    text='ReorderLevel'
)

# Show the plotly figure to the user
show_to_user(fig)
```","The input code calculates 'ReorderFrequency' by counting distinct orders for each product (using a JOIN on 'Order Details'), whereas the reference implementation focuses on calculating the 'ReorderDifference' by comparing 'UnitsOnOrder' and 'ReorderLevel'. Both the logic and purpose differ; the input code does not compare against reorder levels directly as requested.",None
"How many orders are shipped to each city, and can you provide a bar chart or map to visualize the distribution by city?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY ShipCity;
""""""

# Execute the SQL query to get the data
orders_data = execute_sql_query(sql_query)

# Generate the bar chart
fig = px.bar(orders_data, x='ShipCity', y='OrderCount', title='Orders Shipped to Each City')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC;
""""""

order_counts = execute_sql_query(sql_query)

fig = px.bar(order_counts, x='ShipCity', y='OrderCount', title='Number of Orders Shipped to Each City', labels={'OrderCount': 'Number of Orders', 'ShipCity': 'City'})
show_to_user(fig)
```","The input code correctly calculates the number of orders shipped to each city using a SQL query, which aligns with the reference code's logic. It groups by 'ShipCity' and counts 'OrderID', equivalent to counting all records as 'OrderID' is present in each. The code also uses Plotly to create a bar chart visualization of this data and displays it. Although the order of cities by 'OrderCount' is added (ORDER BY OrderCount DESC), it does not alter the correctness of the solution according to the given task.","```python
import pandas as pd
import plotly.express as px

# SQL query to extract data
sql_query = """"""
SELECT ShipCity, COUNT(*) AS OrderCount 
FROM orders 
GROUP BY ShipCity;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders shipped to each city
fig = px.bar(orders_df, x='ShipCity', y='OrderCount', 
             title='Number of Orders Shipped by City',
             labels={'ShipCity': 'City', 'OrderCount': 'Number of Orders'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request by executing a SQL query to count the number of orders shipped to each city and storing the result in a DataFrame. It then visualizes the data using a bar chart with Plotly Express. Although there are slight differences from the reference, such as using pandas and customizing chart labels, the logic and outcome remain equivalent to the reference implementation.",both
"How many orders were shipped late in each month, and can we visualize this trend using a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to determine the number of late orders per month
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    COUNT(*) AS LateOrders 
FROM 
    orders 
WHERE 
    ShippedDate > RequiredDate 
GROUP BY 
    DATE_TRUNC('month', OrderDate);
""""""

# Execute the SQL query and store the result in a DataFrame
late_orders_df = execute_sql_query(sql_query)

# Ensure 'Month' column is in datetime format for consistent plotting
late_orders_df['Month'] = pd.to_datetime(late_orders_df['Month'])

# Create a bar chart to visualize the trend of late orders per month
fig = px.bar(late_orders_df, x='Month', y='LateOrders', 
             title='Monthly Late Orders', 
             labels={'Month': 'Month', 'LateOrders': 'Number of Late Orders'},
             template='plotly')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS LateOrders
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

late_orders_df = execute_sql_query(sql_query)

fig = px.bar(late_orders_df, x='Month', y='LateOrders', title='Late Orders Shipped Per Month')
show_to_user(fig)
```","The input code correctly addresses the business analytics request by calculating the number of late orders per month and visualizing it using a bar chart. It uses the SQL query to count late orders, groups them by month, and orders the results. Although it uses `DATE_FORMAT` instead of `DATE_TRUNC`, it still effectively groups orders by month. The visualization is similar to the reference code, utilizing Plotly to create a bar chart. These differences do not affect the logic or outcome, so the input code is correct.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.ShippedDate, '%Y-%m') AS month, 
    COUNT(orders.OrderID) AS late_orders 
FROM orders 
WHERE orders.ShippedDate > orders.RequiredDate 
GROUP BY month;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
late_orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the trend of late orders
fig = px.bar(late_orders_df, x='month', y='late_orders',
             labels={'month': 'Month', 'late_orders': 'Number of Late Orders'},
             title='Monthly Late Orders Trend')

# Display the visualization to the user
show_to_user(fig)
```","The input code addresses the same business request as the reference by calculating the number of orders shipped late each month. The SQL query in the input uses DATE_FORMAT to group by month, analogous to DATE_TRUNC in the reference, providing the same monthly granularity. Both codes count late orders and visualize results with a bar chart, using Plotly Express. Though there are slight syntactic differences, the logic and outcome align with the business analytics request and reference implementation.",both
"Which shipping method is used most frequently, and can this be represented visually with a bar chart?","import pandas as pd
import plotly.express as px

# SQL query to get the count of orders for each shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipVia
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
shipping_data = execute_sql_query(sql_query)

# Visualize the shipping method frequency using a bar chart
fig = px.bar(
    shipping_data, 
    x='ShipVia', 
    y='OrderCount', 
    title='Most Frequently Used Shipping Methods',
    labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'}
)

# Display the bar chart using the utility function
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
LIMIT 1;
""""""

most_frequent_shipping_method = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT ShipVia, COUNT(*) AS Frequency
FROM orders
GROUP BY ShipVia;
""""""

shipping_methods_frequency = execute_sql_query(sql_query_all)

fig = px.bar(shipping_methods_frequency, x='ShipVia', y='Frequency', 
             title='Frequency of Shipping Methods', 
             labels={'ShipVia': 'Shipping Method', 'Frequency': 'Number of Orders'})

show_to_user(fig)
```","The input code correctly counts the frequency of each shipping method using a SQL query, similar to the reference implementation. It first queries the most frequent shipping method with a LIMIT 1 (though not used in visualization) and then gets all for visualization. The bar chart generated accurately reflects the frequency of each shipping method, adhering to the business analytics request and logic of the reference code.","```python
import plotly.express as px

# Execute the SQL query to get the frequency count of each shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount FROM orders GROUP BY ShipVia ORDER BY UsageCount DESC;
""""""
data_frame = execute_sql_query(sql_query)

# Create a bar chart using Plotly to represent the frequency of each shipping method
fig = px.bar(data_frame, x='ShipVia', y='UsageCount', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'UsageCount': 'Frequency'})

# Display the bar chart using the provided utility function
show_to_user(fig)
```","The provided code correctly addresses the business analytics request by executing an SQL query to obtain the count of orders for each shipping method. It uses the same logic as the reference code: grouping by 'ShipVia', counting 'OrderID', and sorting by the count in descending order. The visualization step also matches, creating a bar chart with Plotly and displaying it, fulfilling the request for a visual representation.",both
Find the reorder levels for products nearing zero stock and create a visualization to highlight those products.,"```python
import plotly.express as px
import pandas as pd

# Function to execute the SQL query and fetch data
def execute_sql_query(sql_query: str):
    # Mock implementation of the SQL execution
    # Replace this with actual database connection and query execution
    # For simplicity, returning a pandas DataFrame with sample data
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'ReorderLevel': [50, 30, 20],
        'UnitsInStock': [10, 5, 15]
    }
    df = pd.DataFrame(data)
    return df[df['UnitsInStock'] < df['ReorderLevel']]

# Function to display the results or visualization
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)  # Replace with actual display logic
    else:
        data.show()  # Show the Plotly figure

# SQL query to find products nearing zero stock
sql_query = """"""
SELECT products.ProductName, products.ReorderLevel
FROM products WHERE products.UnitsInStock < products.ReorderLevel
""""""

# Execute the SQL query
df_reorder = execute_sql_query(sql_query)

# Create a bar chart to visualize products nearing reorder levels
fig = px.bar(df_reorder, x='ProductName', y='ReorderLevel',
             title='Reorder Levels for Products Nearing Zero Stock',
             labels={'ReorderLevel': 'Reorder Level'},
             text='ReorderLevel')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitsInStock, p.ReorderLevel
FROM products p
WHERE p.UnitsInStock <= p.ReorderLevel
""""""

inventory_data = execute_sql_query(sql_query)

fig = px.bar(inventory_data, x='ProductName', y='UnitsInStock',
             title='Products Nearing Zero Stock',
             labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'},
             color='UnitsInStock', text='UnitsInStock')

show_to_user(fig)
```","The input code focuses on plotting 'UnitsInStock' instead of 'ReorderLevel' as per the reference logic. The condition uses 'UnitsInStock <= ReorderLevel' instead of '<', which is a minor logic mismatch from the reference implementation. Moreover, 'ProductID' retrieval is unnecessary as per the reference requirement.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
    SELECT ProductName, ReorderLevel 
    FROM products 
    WHERE UnitsInStock <= ReorderLevel - ReorderLevel * 0.1;
""""""

# Execute the SQL query and return results as a DataFrame
df_reorder_levels = execute_sql_query(sql_query)

# Create a bar chart visualization using Plotly
fig = px.bar(
    df_reorder_levels, 
    x='ProductName', 
    y='ReorderLevel', 
    title='Products Needing Reorder',
    labels={'ReorderLevel': 'Reorder Level'},
    template='plotly_dark'
)

# Display the visualization
show_to_user(fig)
","The input code uses a different condition in the SQL query for determining which products are selected. It uses 'UnitsInStock <= ReorderLevel - ReorderLevel * 0.1' instead of 'UnitsInStock < ReorderLevel'. This changes the logic from the reference implementation. Additionally, the input code uses a different visualization theme (template='plotly_dark'), which, while not directly affecting correctness, indicates a difference from the reference implementation. The reference implementation checks products strictly below the reorder level.",None
"Which employee territories are underperforming in terms of sales, and can we create a visual comparison chart to highlight differences?","import plotly.express as px
import pandas as pd

# SQL Query to fetch the required data
sql_query = '''
SELECT territories.TerritoryDescription, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS territory_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
GROUP BY territories.TerritoryID, 
         territories.TerritoryDescription 
ORDER BY territory_sales
'''

# Function to execute SQL query and fetch data as DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # The implementation to establish database connection and fetch data is assumed.
    # For illustration, it returns a dummy DataFrame structure.
    # Replace the below line with actual database querying code.
    return pd.DataFrame()

# Executing the SQL query to get territory sales data
territory_sales_df = execute_sql_query(sql_query)

# Detect underperforming territories by calculating some threshold for underperformance
# Here, we might consider the bottom 25% territories as underperforming
threshold = territory_sales_df['territory_sales'].quantile(0.25)
underperforming_territories_df = territory_sales_df[territory_sales_df['territory_sales'] <= threshold]

# Create a visual comparison chart using Plotly
fig = px.bar(territory_sales_df, x='TerritoryDescription', y='territory_sales',
             title='Employee Territory Sales Comparison',
             color=territory_sales_df['territory_sales'] <= threshold,
             labels={'territory_sales':'Sales'},
             category_orders={'TerritoryDescription': territory_sales_df.sort_values('territory_sales')['TerritoryDescription']})

# Highlight the underperforming territories
fig.update_traces(marker=dict(color='#FF4136'), selector=dict(marker_color=True))
fig.update_traces(marker=dict(color='#0074D9'), selector=dict(marker_color=False))

# Show the visualization to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT et.TerritoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM employeeTerritories et
JOIN employees e ON et.EmployeeID = e.EmployeeID
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY et.TerritoryID
HAVING SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) < (SELECT AVG(total_sales) FROM 
(SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM employeeTerritories et
JOIN employees e ON et.EmployeeID = e.EmployeeID
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY et.TerritoryID) AS sales_data)
""""""

underperforming_territories = execute_sql_query(sql_query)

fig = px.bar(underperforming_territories, x='TerritoryID', y='total_sales',
             title='Underperforming Territories in Sales',
             labels={'total_sales': 'Total Sales', 'TerritoryID': 'Territory ID'})
show_to_user(fig)
```","The input code calculates underperformance using a threshold based on the average sales, rather than the bottom 25% quantile of sales as the reference code does. Therefore, the logic for identifying underperforming territories is different. Furthermore, the reference implementation uses TerritoryDescription for visualization, while the input code uses TerritoryID, and also misses coloring the bars to highlight underperforming territories.","
import pandas as pd
import plotly.express as px

# SQL query to fetch underperforming territories based on sales data
sql_query = """"""
SELECT employees.EmployeeID, 
       territories.TerritoryDescription, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM employees 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, territories.TerritoryDescription 
HAVING SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) < 
     (SELECT AVG(sub_sales.territory_sales) 
      FROM (
          SELECT territories.TerritoryID, 
                 SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS territory_sales 
          FROM employees 
          JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
          JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
          JOIN orders ON employees.EmployeeID = orders.EmployeeID 
          JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
          GROUP BY territories.TerritoryID
      ) sub_sales)
""""""

# Execute the SQL query and store the result in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This should execute the SQL query and return a pandas DataFrame.
    # For this example, we assume its implementation is available.
    pass  # To be replaced with actual implementation

# Fetch the data
underperforming_df = execute_sql_query(sql_query)

# Create a bar chart to visualize underperforming territories
fig = px.bar(underperforming_df, 
             x='TerritoryDescription', 
             y='total_sales', 
             text='total_sales',
             title='Underperforming Territories in Sales',
             labels={'total_sales': 'Total Sales', 'TerritoryDescription': 'Territory'},
             color='TerritoryDescription')

# Display the figure
def show_to_user(data):
    # This function should display pandas DataFrame or Plotly figure.
    pass  # To be replaced with actual implementation

show_to_user(fig)
","The input code's SQL logic is different from the reference implementation. The input code combines sales by employees and territories, while the reference focuses solely on territories. The threshold logic also differs: the reference uses the 25th percentile, while the input compares to average sales. Furthermore, the input code's visualization does not distinguish underperforming territories effectively.",None
Identify the employee with the most orders shipped late and create a bar chart to illustrate the number of late shipments per employee.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS LateOrders 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.RequiredDate < o.ShippedDate 
GROUP BY e.EmployeeID;
""""""

# Execute SQL query and get the result as a pandas DataFrame
late_orders_df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the number of late shipments per employee
fig = px.bar(
    late_orders_df, 
    x='EmployeeID', 
    y='LateOrders', 
    title='Number of Late Shipments per Employee',
    labels={'EmployeeID': 'Employee ID', 'LateOrders': 'Late Orders'},
    text_auto=True
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       COUNT(o.OrderID) AS LateShipments
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY e.EmployeeID
ORDER BY LateShipments DESC
""""""

late_shipments_df = execute_sql_query(sql_query)

if not late_shipments_df.empty:
    fig = px.bar(late_shipments_df, 
                  x='EmployeeName', 
                  y='LateShipments', 
                  title='Number of Late Shipments per Employee', 
                  labels={'LateShipments': 'Number of Late Shipments', 'EmployeeName': 'Employee'})
    show_to_user(fig)
```","The input code correctly identifies the employee with the most orders shipped late by calculating the number of shipments where the shipped date is later than the required date. It groups the data by EmployeeID, similar to the reference implementation. Additionally, the input code orders the results by the number of late shipments in descending order. It then creates a bar chart using the employee name instead of EmployeeID, which aligns with the reference logic as it still visually represents the late shipments per employee. The result adheres to the logic of identifying and visualizing late shipments per employee.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to identify employees with late shipped orders
sql_query = """"""
SELECT EmployeeID, COUNT(*) AS LateOrders
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY EmployeeID;
""""""

# Execute the SQL query and store the result in a DataFrame
late_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of late shipments per employee
fig = px.bar(
    late_orders_df,
    x='EmployeeID',
    y='LateOrders',
    title='Number of Late Shipments per Employee',
    labels={'EmployeeID': 'Employee ID', 'LateOrders': 'Late Orders Count'}
)

# Display the bar chart
show_to_user(fig)
```","The input code and the reference code implement the same logic to identify employees with the most orders shipped late. Both SQL queries find the 'EmployeeID' and count the 'OrderID' or rows where the 'ShippedDate' is later than the 'RequiredDate', though they use slightly different approaches (with and without a JOIN). The visualizations in both codes use Plotly to create a bar chart of late shipments per employee. The input code effectively fulfills the business request as described.",both
"Which products have not been ordered at all, and can you provide a bar chart to visualize these products?","```python
import plotly.express as px

# SQL query to find products that have not been ordered
sql_query = """"""
SELECT ProductName FROM products
WHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM [Order Details]);
""""""

# Execute the SQL query to get a DataFrame of products not ordered
unordered_products_df = execute_sql_query(sql_query)

# Visualize the unordered products using a bar chart
fig = px.bar(unordered_products_df, x='ProductName', title='Products Not Ordered')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get products that have not been ordered at all
sql_query = """"""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL
""""""

# Execute SQL query
unordered_products_df = execute_sql_query(sql_query)

# Create bar chart for unordered products
fig = px.bar(unordered_products_df, x='ProductName', y='ProductID', title='Products Not Ordered at All', labels={'ProductID':'Count of Unordered Products'})
show_to_user(fig)
```","Both implementations achieve the same goal of identifying products that have not been ordered. The reference code uses a subquery with DISTINCT to exclude ordered products, while the input code uses a LEFT JOIN to identify products with no matching orders, indicated by NULL. Both approaches are correct SQL techniques for this task. The input code includes a 'y' axis in the bar chart, which does not affect correctness as the visualization still accurately represents the necessary information.","
```python
import plotly.express as px

# Define the SQL query to find products that have not been ordered
sql_query = """"""
SELECT p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL;
""""""

# Execute the SQL query to get the unordered products
unordered_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the products that have not been ordered
fig = px.bar(unordered_products_df, x='ProductName', title='Products Not Ordered At All')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly identifies products that have not been ordered by using a LEFT JOIN to ensure it captures products with no corresponding order details, aligning with the reference's NOT IN approach. Both implementations result in unordered products being visualized in a bar chart.",both
Which city has the lowest on-time delivery rate? Include a bar chart to visualize the on-time delivery rates across all cities.,"```python
import plotly.express as px
import pandas as pd

# Provided utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation
    pass

# Provided utility function to show results to the user
def show_to_user(data):
    # Placeholder implementation
    pass

# SQL query to get on-time delivery rates
sql_query = """"""
SELECT ShipCity, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0) / COUNT(*) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipCity 
ORDER BY OnTimeDeliveryRate ASC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Determine the city with the lowest on-time delivery rate
lowest_on_time_city = df.iloc[0]['ShipCity']
lowest_on_time_rate = df.iloc[0]['OnTimeDeliveryRate']

# Output the city with the lowest on-time delivery rate
print(f""The city with the lowest on-time delivery rate is: {lowest_on_time_city}"")

# Create a bar chart of on-time delivery rates across all cities
fig = px.bar(df, x='ShipCity', y='OnTimeDeliveryRate', title='On-Time Delivery Rates by City', labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, 
       COUNT(OrderID) AS TotalOrders,
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries,
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(OrderID)) AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipCity
""""""

delivery_data = execute_sql_query(sql_query)

lowest_on_time_delivery_rate = delivery_data.loc[delivery_data['OnTimeDeliveryRate'].idxmin()]

fig = px.bar(delivery_data, x='ShipCity', y='OnTimeDeliveryRate', 
             title='On-time Delivery Rates by City',
             labels={'OnTimeDeliveryRate': 'On-time Delivery Rate', 'ShipCity': 'City'})

show_to_user(fig)

lowest_on_time_delivery_rate
```","The evaluated code correctly calculates the on-time delivery rate by dividing the count of on-time deliveries by the total orders for each city, similar to the reference implementation. It uses an SQL query to extract the necessary data and identifies the city with the lowest on-time delivery rate. The bar chart visualizing on-time delivery rates across cities is also correctly generated using Plotly, as specified. Despite slight differences in query implementation and approach to finding the city with the lowest rate, the logic aligns with the reference implementation, making it correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to get on-time delivery rates for all cities
sql_query = """"""
SELECT 
    ShipCity, 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID) AS OnTimeRate 
FROM 
    orders 
GROUP BY 
    ShipCity
""""""

# Execute SQL query and get results in a DataFrame
df = execute_sql_query(sql_query)

# Find the city with the lowest on-time delivery rate
lowest_on_time_city = df.sort_values('OnTimeRate').iloc[0]

# Generate a bar chart of on-time delivery rates across all cities
fig = px.bar(df, x='ShipCity', y='OnTimeRate', title='On-Time Delivery Rates by City')

# Display both the lowest on-time city and the bar chart
show_to_user(df)  # Show the entire DataFrame for context
show_to_user(lowest_on_time_city.to_frame().T)  # Display the city with lowest on-time rate
show_to_user(fig)  # Display the bar chart
```","The input code correctly calculates the on-time delivery rate for each city and identifies the city with the lowest rate, matching the logic of the reference implementation. Both codes use SQL to aggregate and sort the delivery rates. Additionally, both produce a bar chart visualizing the rates. Minor differences such as percentage calculation and additional data displays don't affect the correctness.",both
Find employees living in the same city as their manager and provide a chart showing the number of employees per city.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find employees living in the same city as their manager
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, e.City
FROM employees e
JOIN employees m ON e.ReportsTo = m.EmployeeID
WHERE e.City = m.City;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
employees_same_city_df = execute_sql_query(sql_query)

# Count the number of employees per city
employees_per_city = employees_same_city_df.groupby('City').size().reset_index(name='EmployeeCount')

# Create a bar chart to show the number of employees per city
fig = px.bar(employees_per_city, x='City', y='EmployeeCount', title='Number of Employees per City')

# Show the visualization result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find employees living in the same city as their manager
sql_query = """"""
SELECT e.City, COUNT(e.EmployeeID) AS EmployeeCount
FROM employees e
JOIN employees m ON e.ReportsTo = m.EmployeeID
WHERE e.City = m.City
GROUP BY e.City
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart to show the number of employees per city
fig = px.bar(result_df, x='City', y='EmployeeCount', title='Number of Employees per City (Same as Manager)', labels={'EmployeeCount': 'Number of Employees'})

# Show the chart to the user
show_to_user(fig)
```","The provided Python code uses a SQL query to find employees living in the same city as their manager, similar to the reference implementation. It groups the data by city and counts the number of employees, which matches the logic of the reference code. Both codes achieve the same end result: creating a chart of employee counts per city where they reside with their managers.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT City, COUNT(EmployeeID) as NumberOfEmployees 
FROM employees 
WHERE City = (SELECT City FROM employees WHERE EmployeeID = ManagerID) 
GROUP BY City;
""""""

# Execute SQL query and get result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation, replace with actual database call
    # Example: return pd.read_sql(sql_query, connection)
    return pd.DataFrame({
        'City': ['New York', 'Los Angeles'],
        'NumberOfEmployees': [10, 8]
    })

# Visualize the result
def show_to_user(data):
    # Mock implementation for the example
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the query and get the data
employees_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(employees_df, x='City', y='NumberOfEmployees',
             title='Number of Employees per City',
             labels={'NumberOfEmployees': 'Number of Employees', 'City': 'City'})

# Show the chart
show_to_user(fig)
```","The provided code attempts to count employees in cities where the city of an employee matches the city of their manager. However, there's a logical error in the SQL query. The subquery '(SELECT City FROM employees WHERE EmployeeID = ManagerID)' is likely incorrect because 'ManagerID' is not defined. The reference code correctly joins employees and managers by 'e.ReportsTo = m.EmployeeID' and checks for city equality within the same join condition.",Base
"  
""Find the difference in sales between the current and previous year for each employee and create a bar chart to visualize these differences.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder: Implement the database connection and query execution.
    # This should return a pandas DataFrame with the query results.
    pass

def show_to_user(data):
    # Placeholder: Implement the logic to display either a DataFrame or a Plotly figure.
    # This function should handle displaying the results appropriately.
    pass

# SQL Query to get the sales difference for each employee
sql_query = """"""
SELECT 
    e.EmployeeID, 
    (SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END) -
     SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END)) AS SalesDifference 
FROM 
    employees e 
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY 
    e.EmployeeID;
""""""

# Execute the SQL query and retrieve the results into a DataFrame
sales_difference_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize sales differences
fig = px.bar(sales_difference_df, x='EmployeeID', y='SalesDifference', 
             title='Sales Difference between Current and Previous Year for Each Employee', 
             labels={'SalesDifference': 'Sales Difference', 'EmployeeID': 'Employee ID'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    COALESCE(SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) THEN od.UnitPrice * od.Quantity * (1 - od.Discount) END), 0) AS CurrentYearSales,
    COALESCE(SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) END), 0) AS PreviousYearSales
FROM 
    employees e
LEFT JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
LEFT JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID;
""""""

sales_df = execute_sql_query(sql_query)

sales_df['SalesDifference'] = sales_df['CurrentYearSales'] - sales_df['PreviousYearSales']

fig = px.bar(sales_df, x='EmployeeID', y='SalesDifference', text='SalesDifference', 
             title='Sales Difference Between Current and Previous Year by Employee',
             labels={'EmployeeID': 'Employee ID', 'SalesDifference': 'Difference in Sales'})

show_to_user(fig)
```","The input code calculates the sales difference for each employee by querying current and previous year sales separately and then computing the difference in the DataFrame. It uses a LEFT JOIN, which ensures all employees are included, even if they have no sales in the queried years. The bar chart visualization aligns with the reference code's logic by plotting the calculated 'SalesDifference' for each 'EmployeeID'. Thus, it matches the business analytics request and logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the sales difference
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    employees.FirstName, 
    employees.LastName, 
    (SUM(CASE WHEN YEAR(orders.OrderDate) = 2023 THEN [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) ELSE 0 END) - 
    SUM(CASE WHEN YEAR(orders.OrderDate) = 2022 THEN [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) ELSE 0 END)) AS SalesDifference 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName;
""""""

# Execute the SQL query
sales_difference_df = execute_sql_query(sql_query)

# Ensure data is sorted for better visual representation
sales_difference_df = sales_difference_df.sort_values(by='SalesDifference')

# Create the bar chart using Plotly
fig = px.bar(
    sales_difference_df,
    x=sales_difference_df['FirstName'] + ' ' + sales_difference_df['LastName'],  # Combine first and last names
    y='SalesDifference',
    title='Sales Difference Between 2023 and 2022 for Each Employee',
    labels={'y': 'Sales Difference', 'x': 'Employee'},
    text='SalesDifference'
)

# Customize the layout
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(margin=dict(l=40, r=40, t=40, b=40), xaxis_title='Employee', yaxis_title='Sales Difference ($)',
                  xaxis_tickangle=-45)

# Show the figure to the user
show_to_user(fig)
```","The input Python code correctly calculates the sales difference between two consecutive years for each employee, similar to the reference code. Both codes execute a SQL query to find the difference in sales for the current and previous year, considering discount and unit price. The input code includes additional employee details (first and last names) and sorts the DataFrame before visualizing the results in a bar chart. While the input code customizes the bar chart further and includes employee names on the x-axis, these variations do not affect the logic or correctness of the implementation as required by the business analytics request.",both
"  
""Which specific products need to be reordered immediately, and what is their reorder status visualized using a bar chart?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the logic to connect to your database and execute the SQL query.
    # Here we assume it returns a pandas DataFrame from the SQL result.
    pass

def show_to_user(data):
    # This function should take a pandas DataFrame or Plotly figure and display it correctly.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get products that need to be reordered immediately
sql_query = """"""
SELECT ProductName FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;
""""""

# Execute SQL query
products_to_reorder_df = execute_sql_query(sql_query)

# Verify that the DataFrame is not empty
if not products_to_reorder_df.empty:
    # Bar chart visualization using Plotly
    fig = px.bar(products_to_reorder_df, x='ProductName', title='Products to Reorder Immediately')
    
    # Display the plot
    show_to_user(fig)
else:
    # If no products need to be reordered, notify the user
    print(""There are no products that need to be reordered immediately."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ProductID,
    ProductName,
    UnitsInStock,
    ReorderLevel
FROM 
    products
WHERE 
    Discontinued = 0 AND 
    UnitsInStock <= ReorderLevel
""""""

reorder_data = execute_sql_query(sql_query)

fig = px.bar(reorder_data, 
              x='ProductName', 
              y='UnitsInStock', 
              title='Products Needing Reorder',
              labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'},
              color='UnitsInStock')

show_to_user(fig)
```","The evaluated code and the reference implementation have differences in the logic for displaying the results. The reference code first checks if the DataFrame is empty before visualizing, ensuring only non-empty results are plotted. The evaluated code directly attempts to create a plot without this check, which may lead to errors if the DataFrame is empty. Additionally, the evaluated code includes more columns in the SQL query which are not specifically required by the business analytics request, such as UnitsInStock for the visualization.","```python
import plotly.express as px

def check_reorder_status():
    # SQL query to find products that need to be reordered
    query = """"""
    SELECT ProductName, UnitsInStock - ReorderLevel AS ReorderNeed 
    FROM products 
    WHERE UnitsInStock <= ReorderLevel 
    AND Discontinued = 0;
    """"""
    
    # Execute the SQL query using the utility function
    products_df = execute_sql_query(query)
    
    # Create a bar chart to visualize the reorder status
    fig = px.bar(
        products_df, 
        x='ProductName', 
        y='ReorderNeed', 
        title='Products Needing Reorder',
        labels={'ReorderNeed': 'Units to Reorder'},
        template='plotly'
    )

    # Display the chart using the utility function
    show_to_user(fig)

# Run the function to check and visualize the reorder status
check_reorder_status()
```","The input code includes an additional calculation: 'UnitsInStock - ReorderLevel AS ReorderNeed', which differs from the reference implementation. The reference implementation checks for products needing reorder based solely on 'UnitsInStock <= ReorderLevel'. Additionally, the reference code checks if the DataFrame is empty before visualization, while the input code does not. The visualized data differs, as the input code includes 'ReorderNeed' on the y-axis, not present in the reference.",None
What are the top three countries by total sales? Please include a bar chart to visualize the sales by country.,"```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are predefined utility functions

# Define the SQL query
sql_query = """"""
SELECT o.ShipCountry, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS CountrySales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.ShipCountry 
ORDER BY CountrySales DESC 
LIMIT 3
""""""

# Execute the SQL query and obtain the results in a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(result_df, 
             x='ShipCountry', 
             y='CountrySales', 
             title='Top 3 Countries by Total Sales', 
             labels={'CountrySales': 'Total Sales ($)', 'ShipCountry': 'Country'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.ShipCountry, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders AS o
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY o.ShipCountry
ORDER BY TotalSales DESC
LIMIT 3;
""""""

top_countries_sales = execute_sql_query(sql_query)

fig = px.bar(top_countries_sales, 
             x='ShipCountry', 
             y='TotalSales', 
             title='Top Three Countries by Total Sales',
             labels={'TotalSales': 'Total Sales', 'ShipCountry': 'Country'})
show_to_user(fig)
```","The input Python code follows the same logic as the reference code. It computes the top three countries by total sales using a SQL query and visualizes the results with a bar chart. Although there are slight differences in labels and titles, the essential operations and logic remain consistent with the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Assuming the SQL function utils.execute_sql_query is already defined
sql_query = """"""
SELECT customers.Country, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.Country 
ORDER BY total_sales DESC 
LIMIT 3
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df_sales_by_country = utils.execute_sql_query(sql_query)

# Ensure the DataFrame has the expected columns
if 'Country' in df_sales_by_country.columns and 'total_sales' in df_sales_by_country.columns:
    # Create a bar chart using Plotly
    fig = px.bar(df_sales_by_country, x='Country', y='total_sales', 
                 title='Top 3 Countries by Total Sales',
                 labels={'total_sales': 'Total Sales', 'Country': 'Country'},
                 text='total_sales')

    # Display the bar chart to the user
    utils.show_to_user(fig)
else:
    utils.show_to_user('Error: Expected columns not found in the data.')
```","Both implementations correctly query and calculate total sales by country, group and order the results by sales in descending order, and limit the results to the top three countries. They both use Plotly to create a bar chart with the same intended labels, and they assume the use of similar utility functions for executing queries and showing results. The slight differences in SQL query syntax and utility function calls do not affect the correctness according to the specified business requirement.",both
"Identify the suppliers with late shipments on orders, and provide a bar chart showing the frequency of late shipments by supplier.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function to mimic SQL execution
    pass

def show_to_user(data):
    # Dummy function to display data or plots
    pass

# SQL query to identify suppliers with late shipments
sql_query = """"""
SELECT suppliers.CompanyName, COUNT(*) as LateShipments
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.RequiredDate < orders.ShippedDate
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query
late_shipments_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the frequency of late shipments by supplier
fig = px.bar(late_shipments_df, x='CompanyName', y='LateShipments', title='Late Shipments by Supplier')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, COUNT(o.OrderID) AS LateShipments
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (
    SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID
)
WHERE o.ShippedDate > o.RequiredDate
GROUP BY s.CompanyName
ORDER BY LateShipments DESC
""""""

late_shipments_df = execute_sql_query(sql_query)

fig = px.bar(late_shipments_df, x='CompanyName', y='LateShipments', 
             title='Frequency of Late Shipments by Supplier', 
             labels={'CompanyName': 'Supplier', 'LateShipments': 'Number of Late Shipments'})

show_to_user(fig)
```","The input code correctly identifies suppliers with late shipments and creates a bar chart showing the frequency of late shipments by supplier. The SQL query logic matches the reference implementation's intent and structure: joining tables to link suppliers to orders and filtering by late shipments (where 'ShippedDate' is later than 'RequiredDate'). It also groups by 'CompanyName' and counts the occurrences ('LateShipments'). The visualization part uses Plotly to create and display a bar chart, consistent with the reference code, even though additional chart customizations like labels and sorting have been applied.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT s.SupplierID, COUNT(*) AS LateShipmentCount 
FROM suppliers s 
JOIN orders o ON s.SupplierID = o.SupplierID 
WHERE o.ShippedDate > o.RequiredDate 
GROUP BY s.SupplierID;
""""""

# Execute the SQL query using the provided utility function
late_shipments_df = execute_sql_query(sql_query)

# Generate a bar chart for the frequency of late shipments by supplier
fig = px.bar(late_shipments_df, x='SupplierID', y='LateShipmentCount', 
             title='Frequency of Late Shipments by Supplier',
             labels={'SupplierID': 'Supplier ID', 'LateShipmentCount': 'Late Shipment Count'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code checks for late shipments by joining directly on suppliers and orders using SupplierID, which is incorrect. The reference implementation joins suppliers, products, order details, and orders, then checks for late shipments by comparing RequiredDate and ShippedDate. The input code skips the necessary joins and does not access the CompanyName column. Consequently, it doesn't align with the reference logic.",Base
"What is the average shipping cost per order by shipping company, and can you visualize this data using a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch average shipping cost per order by shipping company
sql_query = """"""
SELECT 
    shippers.CompanyName, 
    AVG(orders.Freight) AS avg_shipping_cost 
FROM 
    orders 
JOIN 
    shippers 
ON 
    orders.ShipVia = shippers.ShipperID 
GROUP BY 
    shippers.CompanyName
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str):
    # Assuming connection to the database exists and is named `conn`
    # Replace 'conn' with actual connection object
    df = pd.read_sql(sql_query, conn)
    return df

# Fetch the data
dataframe = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(dataframe, x='CompanyName', y='avg_shipping_cost',
             title='Average Shipping Cost per Order by Shipping Company',
             labels={'avg_shipping_cost': 'Average Shipping Cost', 'CompanyName': 'Shipping Company'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, AVG(orders.Freight) AS average_shipping_cost 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName
""""""

shipping_cost_data = execute_sql_query(sql_query)

fig = px.bar(shipping_cost_data, x='CompanyName', y='average_shipping_cost', 
             title='Average Shipping Cost per Order by Shipping Company', 
             labels={'average_shipping_cost': 'Average Shipping Cost', 'CompanyName': 'Shipping Company'})

show_to_user(fig)
```","The input code performs the same operation as the reference code. It generates a SQL query to calculate the average shipping cost per order by joining the 'orders' and 'shippers' tables, grouping by 'CompanyName'. Both scripts use Plotly to create a bar chart titled 'Average Shipping Cost per Order by Shipping Company' and display the chart using 'show_to_user'. The difference in variable names is acceptable as they do not alter the logic or outcome.","```python
import plotly.express as px
import pandas as pd

# SQL query to execute
sql_query = """"""
    SELECT shippers.CompanyName, AVG(orders.Freight) AS AvgShippingCost
    FROM orders 
    JOIN shippers ON orders.ShipVia = shippers.ShipperID 
    GROUP BY shippers.CompanyName;
""""""

# Execute the SQL query to get the data
avg_shipping_cost_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(avg_shipping_cost_df, 
             x='CompanyName', 
             y='AvgShippingCost', 
             title='Average Shipping Cost per Order by Shipping Company',
             labels={'AvgShippingCost': 'Average Shipping Cost', 'CompanyName': 'Shipping Company'})

# Display the visualization to the user
show_to_user(fig)
```","The input Python code correctly answers the business analytics request by fetching the average shipping cost per order by shipping company and visualizing it with a bar chart using Plotly. It follows the same logic as the reference implementation, with only minor differences in the use of column names and the specification of the SQL query. Both implementations execute a SQL query, process the data using Pandas, and create a bar chart with Plotly to display the results.",both
List suppliers located in the same city and include a map visualization to show their locations.,"```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user functions are already defined

# Define the SQL query to find suppliers in the same city
sql_query = """"""
SELECT s1.SupplierID, s1.CompanyName, s1.City, s1.Latitude, s1.Longitude 
FROM suppliers s1 
JOIN suppliers s2 ON s1.City = s2.City AND s1.SupplierID < s2.SupplierID
GROUP BY s1.SupplierID, s1.CompanyName, s1.City, s1.Latitude, s1.Longitude
""""""

# Execute the SQL query and get the results as a pandas DataFrame
suppliers_data = execute_sql_query(sql_query)

# Check if there are any results
if not suppliers_data.empty:
    # Create a map visualization with Plotly
    fig = px.scatter_mapbox(suppliers_data,
                            lat=""Latitude"",
                            lon=""Longitude"",
                            text=""CompanyName"",
                            hover_name=""CompanyName"",
                            hover_data={""City"": True},
                            title=""Suppliers Located in the Same City"",
                            mapbox_style=""carto-positron"",
                            zoom=5)

    # Use the utility function to display the Plotly figure
    show_to_user(fig)
else:
    # In case the DataFrame is empty, display a message
    show_to_user(pd.DataFrame({""Message"": [""No suppliers found in the same city.""]}))
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    SupplierID, 
    CompanyName, 
    ContactName, 
    Address, 
    City, 
    Region, 
    PostalCode, 
    Country 
FROM 
    suppliers 
WHERE 
    City IN (SELECT City FROM suppliers GROUP BY City HAVING COUNT(*) > 1)
""""""

suppliers_df = execute_sql_query(sql_query)

if not suppliers_df.empty:
    fig = px.scatter_geo(suppliers_df, 
                         lat=[0]*len(suppliers_df), 
                         lon=[0]*len(suppliers_df), 
                         text='CompanyName', 
                         hover_name='ContactName',
                         title='Suppliers Location Map',
                         scope='world')

    show_to_user(fig)
else:
    show_to_user(""No suppliers found in the same city."")
```","The input code does not correctly address the business request. The SQL query only filters suppliers within the same city but does not provide latitude and longitude data required for map visualization. It uses a constant zero for both latitudes and longitudes in the map, which is not correct. Additionally, the map should use 'scatter_mapbox' for the same type of visualization as the reference implementation.","import pandas as pd
import plotly.express as px

# SQL Query to fetch suppliers located in the same city
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, s.City 
FROM suppliers s 
JOIN (
    SELECT City 
    FROM suppliers 
    GROUP BY City 
    HAVING COUNT(DISTINCT SupplierID) > 1
) AS sc ON s.City = sc.City;
""""""

# Execute the SQL query using the provided utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function. In practice, this should interact with a database.
    pass

suppliers_df = execute_sql_query(sql_query)

# Generate a map visualization
fig = px.scatter_mapbox(
    suppliers_df,
    lat='Latitude',  # Ensure these columns are fetched via SQL or later adjustment
    lon='Longitude', # Ensure these columns are fetched via SQL or later adjustment
    hover_name='CompanyName',
    hover_data=['City'],
    title='Suppliers Located in the Same City',
    mapbox_style=""open-street-map""
)

# Display the map visualization using the utility function
def show_to_user(data):
    # Placeholder function. In practice, this should display the input data.
    pass

show_to_user(fig)
","The input code does not correctly find suppliers located in the same city. The reference code uses a self-join to ensure that only cities with multiple suppliers are included by selecting pairs with distinct SupplierIDs. The input code counts distinct SupplierIDs per city but does not ensure latitude and longitude data is fetched, which is necessary for the map visualization.",None
"How many customers have been retained from 2022 to 2023? Additionally, provide a bar chart comparing the retention numbers across these years.","```python
import pandas as pd
import plotly.express as px

# Define the utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to run the SQL query and return results as a DataFrame
    # The implementation details are assumed, and the following is a placeholder for demonstration
    return pd.DataFrame()

def show_to_user(data):
    # This function should be implemented to display data or figures
    # The implementation details are assumed, and the following is a placeholder for demonstration
    # `data` can be a DataFrame or a Plotly figure
    pass

# Step 1: Execute the SQL query to get the retained customers' count
sql_query = """"""
SELECT COUNT(DISTINCT retained.CustomerID) AS RetainedCount FROM
(SELECT CustomerID FROM orders WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31') AS previous
INNER JOIN
(SELECT CustomerID FROM orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31') AS current
ON previous.CustomerID = current.CustomerID
""""""

retained_customers_df = execute_sql_query(sql_query)

# Step 2: Create a dataframe for visualizing retention across years
# For simplicity, we'll assume execute_sql_query can be used similarly to get counts for each year
retention_2022_df = execute_sql_query(
    ""SELECT COUNT(DISTINCT CustomerID) AS Count FROM orders WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'""
)
retention_2023_df = execute_sql_query(
    ""SELECT COUNT(DISTINCT CustomerID) AS Count FROM orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'""
)

# Create a DataFrame for visualization
comparison_df = pd.DataFrame({
    'Year': ['2022', '2023'],
    'Customer Count': [
        retention_2022_df.iloc[0]['Count'],
        retained_customers_df.iloc[0]['RetainedCount']
    ]
})

# Step 3: Generate the bar chart
fig = px.bar(comparison_df, x='Year', y='Customer Count', title='Customer Retention 2022 vs 2023')

# Step 4: Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL queries to get customer retention data for 2022 and 2023
query_2022 = """"""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
""""""

query_2023 = """"""
SELECT DISTINCT CustomerID 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the queries
customers_2022 = execute_sql_query(query_2022)
customers_2023 = execute_sql_query(query_2023)

# Count retained customers
retained_customers = len(set(customers_2022['CustomerID']).intersection(set(customers_2023['CustomerID'])))
total_customers_2022 = len(customers_2022)
total_customers_2023 = len(customers_2023)

# Prepare data for the bar chart
retention_data = pd.DataFrame({
    'Year': ['2022', '2023'],
    'Customer Count': [total_customers_2022, total_customers_2023]
})

# Create the bar chart
fig = px.bar(retention_data, x='Year', y='Customer Count', title='Customer Retention Comparison: 2022 vs 2023')
show_to_user(fig)

retained_customers
```","The input code calculates and visualizes the total customer counts for each year instead of the retained customers from 2022 to 2023. The reference code focuses on the retained customers' count between the two years, displaying retention in the bar chart, while the input calculates and shows overall counts.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # Mocked function for executing SQL query
    # Returns a pandas DataFrame with the given SQL query results
    pass

def show_to_user(data):
    # Display data or plot
    pass

# SQL Queries to fetch unique customers for 2022 and 2023
sql_query_2022 = """"""
SELECT DISTINCT customers.CustomerID 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE EXTRACT(YEAR FROM orders.OrderDate) = 2022;
""""""

sql_query_2023 = """"""
SELECT DISTINCT customers.CustomerID 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE EXTRACT(YEAR FROM orders.OrderDate) = 2023;
""""""

# Execute SQL queries
df_2022 = execute_sql_query(sql_query_2022)
df_2023 = execute_sql_query(sql_query_2023)

# Calculate retained customers
retained_customers = df_2022.merge(df_2023, on='CustomerID', how='inner').shape[0]

# Data for bar chart
retention_data = pd.DataFrame({
    'Year': [2022, 2023],
    'UniqueCustomers': [df_2022.shape[0], df_2023.shape[0]],
    'Retained': [retained_customers, retained_customers]
})

# Plotting bar chart
fig = px.bar(
    retention_data, 
    x='Year', 
    y=['UniqueCustomers', 'Retained'],
    barmode='group',
    labels={'value': 'Count', 'variable': 'Metric'},
    title=""Customer Retention from 2022 to 2023""
)

# Show the plot using show_to_user
show_to_user(fig)
```","The provided code is correct because it effectively calculates the number of customers retained from 2022 to 2023 using SQL queries to fetch distinct customers for each year and then merging the DataFrames to find common customers. It also visualizes the number of unique customers and retained customers using a bar chart, aligning with the logic of the reference implementation.",Finetuned
"Which customer placed the most orders in the last year, and visualize the top ten customers by the number of orders?","import plotly.express as px

# SQL query to get the top ten customers by the number of orders in the last year
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 10;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Display the customer with the most orders
most_orders_customer = orders_df.iloc[0]
show_to_user(most_orders_customer)

# Visualization of the top ten customers by the number of orders
fig = px.bar(
    orders_df,
    x='CustomerID',
    y='OrderCount',
    title='Top Ten Customers by Number of Orders in 2022',
    labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'},
    text='OrderCount'
)

# Show the visualization
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# SQL query to find the number of orders placed by each customer in the last year
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 10;
""""""

# Execute the SQL query and retrieve the data
top_customers_df = execute_sql_query(sql_query)

# Determine the customer who placed the most orders
most_orders_customer = top_customers_df.iloc[0]

# Visualization of top ten customers by the number of orders
fig = px.bar(top_customers_df, x='CustomerID', y='OrderCount', title='Top 10 Customers by Number of Orders',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Display the result
show_to_user(fig)

most_orders_customer
```","The input code uses a different time range compared to the reference code. The reference code is set to retrieve orders specifically in the calendar year 2022 ('2022-01-01' to '2022-12-31'), while the input code uses a dynamic date range of the last year from the current date using `DATE_SUB(CURDATE(), INTERVAL 1 YEAR)`. This could result in a different set of orders being retrieved, especially if the current date is not at the start of a new year. Thus, the input code does not adhere to the business analytics request as demonstrated in the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Given SQL query to retrieve the top ten customers by the number of orders in the last year
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) AS NumOrders 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) - 1 
GROUP BY c.CustomerID 
ORDER BY NumOrders DESC 
LIMIT 10;
""""""

# Execute the SQL query using the utility function to fetch data as a pandas DataFrame
df_top_customers = execute_sql_query(sql_query)

# Visualize the top ten customers by the number of orders using Plotly
fig = px.bar(df_top_customers, x='CustomerID', y='NumOrders', 
             title='Top 10 Customers by Number of Orders in the Last Year',
             labels={'NumOrders': 'Number of Orders'},
             text='NumOrders')

# Update layout for better readability
fig.update_traces(texttemplate='%{text}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide', xaxis_title='Customer ID')

# Display the visualization
show_to_user(fig)
```","The input code does not show the customer with the most orders before creating the visualization as the reference code does. Additionally, it incorrectly uses EXTRACT(YEAR FROM CURRENT_DATE) - 1 to filter the last year's orders, which may not match the '2022-01-01' to '2022-12-31' range explicitly stated in the task.",None
Which region has the most orders? Please include a bar chart to visualize the number of orders per region.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch order count per region
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS NumOrders
FROM orders
GROUP BY ShipRegion
ORDER BY NumOrders DESC;
""""""

# Execute the SQL query and get the result as a DataFrame
df_orders_per_region = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of orders per region
fig = px.bar(df_orders_per_region, x='ShipRegion', y='NumOrders', title='Number of Orders per Region')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.Region, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.Region
ORDER BY NumberOfOrders DESC
""""""
orders_per_region = execute_sql_query(sql_query)

fig = px.bar(orders_per_region, x='Region', y='NumberOfOrders', title='Number of Orders per Region', labels={'NumberOfOrders': 'Number of Orders'})
show_to_user(fig)
```","The input code uses a different table (employees) and assumes a join condition with the orders table, which is not present in the reference code. The reference code directly groups orders by ShipRegion using only the orders table. This affects the logic and potential results of the query, diverging from the specified business request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to find the number of orders per region
sql_query = """"""
SELECT 
    ShipRegion, 
    COUNT(OrderID) AS NumberOfOrders 
FROM 
    orders 
GROUP BY 
    ShipRegion 
ORDER BY 
    NumberOfOrders DESC;
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per region
fig = px.bar(orders_df, x='ShipRegion', y='NumberOfOrders', 
             title='Number of Orders per Region',
             labels={'ShipRegion': 'Region', 'NumberOfOrders': 'Number of Orders'},
             template='plotly')

# Display the Bar chart
show_to_user(fig)
```",The input Python code correctly queries the number of orders per region using a similar SQL query as the reference code and produces a bar chart with Plotly. Both implementations group by 'ShipRegion' and order by the number of orders in descending order. The input code also includes additional labels and plotting options that do not affect the correctness.,Finetuned
"What is the trend over time of orders shipped more than a week after the order date, and how many such orders are there?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch order trends
sql_query = """"""
SELECT o.OrderDate, COUNT(o.OrderID) AS DelayedOrders
FROM orders o
WHERE DATEDIFF(o.ShippedDate, o.OrderDate) > 7
GROUP BY o.OrderDate
ORDER BY o.OrderDate;
""""""

# Execute SQL query and get data in a DataFrame
orders_data = execute_sql_query(sql_query)

# Display total number of delayed orders
total_delayed_orders = orders_data['DelayedOrders'].sum()
summary_df = pd.DataFrame({'Total Delayed Orders': [total_delayed_orders]})
show_to_user(summary_df)

# Plot the trend of delayed orders over time
fig = px.line(orders_data, x='OrderDate', y='DelayedOrders', title='Trend of Delayed Orders Over Time')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderDate,
    COUNT(*) AS LateOrders
FROM 
    orders
WHERE 
    ShippedDate > DATEADD(DAY, 7, OrderDate)
GROUP BY 
    OrderDate
ORDER BY 
    OrderDate
""""""

late_orders_df = execute_sql_query(sql_query)

fig = px.line(late_orders_df, x='OrderDate', y='LateOrders', title='Trend of Late Orders Over Time')
show_to_user(fig)
```",The input code correctly implements the business analytics request. It retrieves the count of orders shipped more than a week after the order date by filtering with the SQL condition for 7 days after the order date. Both provided and reference implementations use equivalent logic despite differing SQL syntax (DATEDIFF vs. DATEADD). The plotting of the trend over time and the data retrieval are consistent with the reference implementation's objectives.,"```python
import pandas as pd
import plotly.express as px

# Execute SQL query to get trend data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS LateOrders
FROM orders
WHERE ShippedDate > DATE_ADD(OrderDate, INTERVAL 7 DAY)
GROUP BY Month;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # Return a sample DataFrame for the purpose of this example
    return pd.DataFrame({
        'Month': ['2023-01', '2023-02', '2023-03'],
        'LateOrders': [10, 15, 20]
    })

# Run the SQL query to get the data
df = execute_sql_query(sql_query)

# Visualize the trend using Plotly
fig = px.line(df, x='Month', y='LateOrders', title='Trend of Orders Shipped Late Over Time',
              labels={'Month': 'Month', 'LateOrders': 'Number of Late Orders'})

# Function to display the plot
def show_to_user(data):
    # Placeholder for actual show logic
    data.show()

# Show the trend graph to the user
show_to_user(fig)
```","The input code groups the data by month (DATE_FORMAT) instead of each OrderDate, which changes the level of granularity compared to the reference code. The reference code groups by OrderDate, allowing daily analysis, whereas the input code groups by month, aggregating data and potentially obscuring trends within a month. Additionally, the input code does not calculate the total number of delayed orders, missing part of the requested analysis.",Base
"    ""Which employee has the highest sales in the last month, and can this be shown in a bar chart?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the actual SQL execution, returns a DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying data or figures to the user
    pass

# SQL query to get the employee with the highest sales in the last month
sql_query = """"""
SELECT e.EmployeeID,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE)
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the query and get the result as a DataFrame
result_df = execute_sql_query(sql_query)

# Print the result DataFrame for debugging purposes
print(""DataFrame Result:"")
print(result_df)

# Check if the result contains any data
if not result_df.empty:
    # Create a bar chart using Plotly
    fig = px.bar(result_df, x='EmployeeID', y='TotalSales', title='Employee with Highest Sales in the Last Month')
    
    # Display the figure to the user
    show_to_user(fig)
else:
    print(""No data available for the specified query."")
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the start and end dates for the last month
today = datetime.now()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to get total sales by each employee for the last month
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
  AND o.OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
LIMIT 1;
""""""

highest_sales_employee = execute_sql_query(sql_query)

# Generate a bar chart
fig = px.bar(highest_sales_employee, x='LastName', y='TotalSales', 
             title='Highest Sales Employee in Last Month', 
             labels={'LastName': 'Employee Name', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code correctly calculates the total sales for each employee for the last month, orders the results to get the highest sales, and then generates a bar chart. The logic aligns with the reference code, with differences such as additional employee name fields and specific date calculations, which do not affect the correctness of the task.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE) 
    AND orders.OrderDate < CURRENT_DATE 
GROUP BY 
    employees.EmployeeID 
ORDER BY 
    TotalSales DESC 
LIMIT 1
""""""

# Execute the SQL query and retrieve the data
# Note: ensure execute_sql_query is defined to run the query and return results as a DataFrame
df = execute_sql_query(sql_query)

# Assign each EmployeeID a unique value to avoid any possible rendering issues
df['EmployeeID'] = df['EmployeeID'].astype(str)

# Create a bar chart using Plotly
fig = px.bar(df, 
             x='EmployeeID', 
             y='TotalSales', 
             title='Highest Sales by Employee in Last Month',
             labels={'TotalSales':'Total Sales', 'EmployeeID':'Employee ID'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It executes a similar SQL query to retrieve the employee with the highest sales in the last month by joining the necessary tables and calculating `TotalSales`. The query results are then used to create a Plotly bar chart, which is displayed to the user. The differences in syntax, such as handling the date range with an additional `AND orders.OrderDate < CURRENT_DATE`, do not alter the correctness of the logic. The main tasks of generating the SQL query, executing it, and displaying the results in a bar chart are correctly implemented.",both
Find the total number of products in each category and create a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# Function to execute an SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function. In a real-world scenario, this would interface with a database.
    pass

# Placeholder function to display data or plots
def show_to_user(data):
    pass

# SQL query to get the total number of products in each category
sql_query = ""SELECT CategoryID, COUNT(ProductID) AS TotalProducts FROM products GROUP BY CategoryID;""

# Execute the query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total products in each category
fig = px.bar(df, x='CategoryID', y='TotalProducts', title='Total Products in Each Category')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, COUNT(p.ProductID) AS TotalProducts
FROM products p
GROUP BY p.CategoryID
""""""

category_totals = execute_sql_query(sql_query)

fig = px.bar(category_totals, x='CategoryID', y='TotalProducts', 
              title='Total Number of Products in Each Category',
              labels={'CategoryID': 'Category ID', 'TotalProducts': 'Total Products'})

show_to_user(fig)
```","The input code correctly implements the required functionality as specified in the business analytics request. It performs the SQL query to count products per category using the same logic as the reference implementation. It also generates a bar chart using Plotly to visualize the results, following the same steps as the reference code. The additional use of labels in the chart configuration enhances readability but does not alter the logic or output. Therefore, the input code is correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of products in each category
sql_query = """"""
SELECT CategoryID, COUNT(*) AS ProductCount FROM products GROUP BY CategoryID
""""""

# Execute the SQL query and get the results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='ProductCount', title='Total Number of Products in Each Category')

# Display the bar chart to the user
show_to_user(fig)
```","The provided code accurately fulfills the business analytics request by counting the number of products in each category and creating a bar chart for visualization. It uses a similar query logic as the reference implementation, grouping by CategoryID and counting products. The column aliases differ but achieve the same result. Therefore, the function adheres to the logic and expected output.",both
"What is the inventory turnover ratio for each product in 2023, and can you provide a bar chart to compare these ratios visually?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # The actual implementation of this function is assumed to execute the SQL query
    # and return a DataFrame. Here it's left as a placeholder.
    pass

# Function to display data or visualization results
def show_to_user(data):
    # The actual implementation of this function is assumed to display data or visualizations.
    # Here it's left as a placeholder.
    pass

# Define the SQL query to fetch inventory turnover ratio
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / NULLIF(AVG(products.UnitsInStock), 0) AS inventory_turnover_ratio 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY products.ProductID
""""""

# Execute the SQL query and get the result into a DataFrame
df_turnover = execute_sql_query(sql_query)

# Create a bar chart to visualize the inventory turnover ratio
fig = px.bar(df_turnover, x='ProductID', y='inventory_turnover_ratio', 
             title='Inventory Turnover Ratio for Each Product in 2023',
             labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio', 'ProductID': 'Product ID'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, 
       products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY products.ProductID, products.ProductName
""""""

inventory_turnover_ratios = execute_sql_query(sql_query)

fig = px.bar(inventory_turnover_ratios, 
             x='ProductName', 
             y='inventory_turnover_ratio', 
             title='Inventory Turnover Ratio for Each Product in 2023',
             labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code includes a few discrepancies from the reference implementation. Firstly, it adds 'ProductName' in the SELECT clause and GROUP BY, which is not present in the reference code. Secondly, the input code uses AVG(products.UnitsInStock) without a NULLIF safeguard, unlike the reference code that uses NULLIF to handle division by zero. Additionally, the WHERE clause uses 'YEAR(orders.OrderDate) = 2023' without an explicit 'JOIN orders' clause, which could result in an error. These differences can lead to incorrect results or runtime errors, thus not adhering to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch inventory turnover ratio for each product in 2023
sql_query = """"""
SELECT 
    products.ProductName, 
    (SUM([Order Details].Quantity * [Order Details].UnitPrice) / NULLIF(AVG(products.UnitsInStock), 0)) AS inventory_turnover_ratio 
FROM 
    [Order Details] 
JOIN 
    products 
ON 
    [Order Details].ProductID = products.ProductID 
JOIN 
    orders 
ON 
    [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY 
    products.ProductID, products.ProductName
""""""

# Execute the query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to compare inventory turnover ratios visually
fig = px.bar(df, x='ProductName', y='inventory_turnover_ratio', 
             title='Inventory Turnover Ratio for Each Product in 2023',
             labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio'},
             template='plotly')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly calculates the inventory turnover ratio for each product in 2023, adhering to the same logic as the reference implementation. It queries for SUM of quantity times unit price divided by the average units in stock, filtered by the specified dates. Grouping logic is consistent, with only a difference in selecting 'ProductName' instead of 'ProductID' for the x-axis of the bar chart. The bar chart visualizes the data as requested, fulfilling the business analytics criteria.",Finetuned
How many products have stock levels below their reorder level? Include a bar chart to visualize the number of products per category with low stock levels.,"
import pandas as pd
import plotly.express as px

# SQL query to get products with stock levels below reorder level
sql_query = """"""
SELECT ProductID, CategoryID, Products.ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel;
""""""

# Execute the SQL query
df_low_stock = execute_sql_query(sql_query)

# Group by category to count the number of low stock products
low_stock_by_category = df_low_stock.groupby('CategoryID').size().reset_index(name='low_stock_count')

# Create a bar chart to visualize
fig = px.bar(low_stock_by_category, x='CategoryID', y='low_stock_count',
             labels={'CategoryID': 'Category ID', 'low_stock_count': 'Low Stock Products'},
             title='Number of Products with Low Stock Levels by Category')

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitsInStock, p.ReorderLevel, c.CategoryName
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
WHERE p.UnitsInStock < p.ReorderLevel
""""""

low_stock_products = execute_sql_query(sql_query)

low_stock_count = low_stock_products.groupby('CategoryName').size().reset_index(name='Count')

fig = px.bar(low_stock_count, x='CategoryName', y='Count', title='Number of Products with Low Stock Levels per Category')
show_to_user(fig)

product_count_below_reorder_level = low_stock_products.shape[0]
show_to_user(pd.DataFrame({'Low Stock Product Count': [product_count_below_reorder_level]}))
```","Both the reference and input implementations correctly execute an SQL query to determine products with stock levels below their reorder levels, group these products by category, and visualize the counts using a bar chart. The differences lie in column selection and presentation, which do not affect the correctness in terms of the business request. The input code provides additional functionality by counting the total number of such products, which is an expansion rather than a deviation from the core task.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to fetch products with stock levels below reorder level
sql_query = """"""
SELECT ProductID, Category, ProductName 
FROM products 
WHERE UnitsInStock < ReorderLevel
""""""

# Execute the SQL query using the execute_sql_query function
low_stock_products_df = execute_sql_query(sql_query)

# Count the number of low stock products per category
products_per_category = low_stock_products_df.groupby('Category').size().reset_index(name='Number of Products')

# Create a bar chart using Plotly
fig = px.bar(products_per_category, x='Category', y='Number of Products', 
             title='Number of Products Below Reorder Level by Category', 
             labels={'Number of Products': 'Products', 'Category': 'Category'})

# Display the chart using the show_to_user function
show_to_user(fig)
```","The input code uses a different column name 'Category' instead of 'CategoryID' used in the reference. The SQL query also selects different columns. This indicates a possible schema mismatch or oversight, affecting the ability to replicate the logic of the reference implementation.",Base
"What is the total value of unshipped orders, and can we visualize this data over time to identify any trends?","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch unshipped order values over time
sql_query = """"""
SELECT 
    orders.OrderDate, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS UnshippedValue 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    ShippedDate IS NULL 
GROUP BY 
    orders.OrderDate
ORDER BY 
    orders.OrderDate;
""""""

# Execute the SQL query and get the data in a pandas DataFrame
unshipped_data = execute_sql_query(sql_query)

# Visualization of unshipped order values over time
fig = px.line(unshipped_data, x='OrderDate', y='UnshippedValue', title='Unshipped Order Values Over Time')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    DATE(OrderDate) AS OrderDate,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalValue
FROM
    orders o
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
WHERE
    o.ShippedDate IS NULL
GROUP BY
    DATE(OrderDate)
ORDER BY
    OrderDate
""""""

unshipped_orders_df = execute_sql_query(sql_query)
total_value = unshipped_orders_df['TotalValue'].sum()

fig = px.line(unshipped_orders_df, x='OrderDate', y='TotalValue', title='Total Value of Unshipped Orders Over Time')
show_to_user(fig)

total_value
```","The input code correctly calculates the total value of unshipped orders and visualizes this data over time, analogous to the reference implementation. Both implementations execute a SQL query summing up the unshipped order values by order date and plot this information as a line chart. Although the input code calculates the overall sum (total_value), it does not affect the correctness as it fulfills the core requirement: trend visualization.","
import pandas as pd
import plotly.express as px

# Assume these utility functions are predefined

def execute_sql_query(sql_query: str):
    # Mock implementation; replace with actual database interaction.
    data = {
        'OrderDate': ['2023-01-01', '2023-02-01', '2023-03-01'],
        'UnshippedValue': [1000, 1500, 1700]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock implementation; replace with functionality to display data/visualizations
    print(data)

# SQL query to fetch unshipped orders and their total value
sql_query = """"""
SELECT 
    OrderDate,
    SUM(UnitPrice * Quantity * (1 - Discount)) AS UnshippedValue 
FROM 
    orders o 
JOIN 
    [Order Details] od 
ON 
    o.OrderID = od.OrderID 
WHERE 
    NOT EXISTS (SELECT 1 FROM shippings s WHERE o.OrderID = s.OrderID)
GROUP BY 
    OrderDate;
""""""

# Execute the SQL query and get the data
df_unshipped_orders = execute_sql_query(sql_query)

# Convert OrderDate to datetime for proper visualization
df_unshipped_orders['OrderDate'] = pd.to_datetime(df_unshipped_orders['OrderDate'])

# Visualize the unshipped order value over time using Plotly
fig = px.line(df_unshipped_orders, x='OrderDate', y='UnshippedValue', title='Total Value of Unshipped Orders Over Time')

# Display the plot
show_to_user(fig)
","The input code differs from the reference implementation in the way it determines unshipped orders. The reference implementation checks if 'ShippedDate IS NULL', while the input code uses a 'NOT EXISTS' query with the 'shippings' table to determine if an order hasn't been shipped. This different logic might lead to different results if the schema or data handling is not consistent across queries.",Base
"Which customers received shipments to multiple countries, and can you provide a visual map of the countries involved for each customer?","
```python
import pandas as pd
import plotly.express as px

# SQL to identify customers with shipments to multiple countries
sql_query = """"""
SELECT c.CustomerID, o.ShipCountry 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID, o.ShipCountry
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Filter customers with shipments to multiple countries
counts = df.groupby('CustomerID')['ShipCountry'].nunique()
multiple_countries_customers = counts[counts > 1].index
filtered_df = df[df['CustomerID'].isin(multiple_countries_customers)]

# Group by CustomerID to collect countries into a list
customers_countries = filtered_df.groupby('CustomerID')['ShipCountry'].apply(list).reset_index()

# Generate visual map for each customer
for _, row in customers_countries.iterrows():
    customer_id = row['CustomerID']
    countries = row['ShipCountry']
    
    # Create the data for the map
    map_df = pd.DataFrame(countries, columns=['Country'])
    
    # Plotly map visualization
    fig = px.scatter_geo(map_df, locations='Country', title=f'Customer {customer_id} Shipments')
    
    # Show the map to the user
    show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

# Step 1: Execute SQL query to get customers with shipments to multiple countries
sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    o.ShipCountry 
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
GROUP BY 
    c.CustomerID, c.CompanyName, o.ShipCountry
HAVING 
    COUNT(DISTINCT o.ShipCountry) > 1
ORDER BY 
    c.CustomerID;
""""""

customers_multiple_countries = execute_sql_query(sql_query)

# Step 2: Aggregate the countries for each customer
country_data = customers_multiple_countries.groupby(['CustomerID', 'CompanyName'])['ShipCountry'].apply(list).reset_index()

# Step 3: Visualize the map for each customer
fig = px.choropleth(locations=country_data['ShipCountry'].explode(),
                    locationmode='country names',
                    title='Countries of Shipments for Customers with Multiple Countries',
                    color=country_data['CustomerID'].repeat(country_data['ShipCountry'].str.len()).reset_index(drop=True),
                    labels={'CustomerID': 'Customer ID'})

show_to_user(fig)
```","The input code logic differs from the reference logic. It uses SQL's HAVING clause directly to filter customers with shipments to multiple countries within the query, whereas the reference implementation filters after SQL execution. Additionally, the visualization part differs: the input code uses `px.choropleth` for a single collective map of all customers instead of individual maps per customer as in the reference code.","import pandas as pd
import plotly.express as px

# Placeholder function for business analytic request and response handling
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This should contain the actual implementation to execute the SQL and fetch results
    pass

def show_to_user(data):
    # This should contain the actual implementation to display data
    pass

# SQL Query to find customers with shipments to multiple countries
sql_query = """"""
SELECT CustomerID, COUNT(DISTINCT ShipCountry) AS CountryCount
FROM orders
GROUP BY CustomerID
HAVING CountryCount > 1;
""""""

# Execute the query and get the data
customers_with_multiple_countries = execute_sql_query(sql_query)

# Placeholder data retrieval of detailed information for each customer
detailed_sql_query = """"""
SELECT CustomerID, ShipCountry
FROM orders
WHERE CustomerID IN (
    SELECT CustomerID
    FROM orders
    GROUP BY CustomerID
    HAVING COUNT(DISTINCT ShipCountry) > 1
);
""""""

# Get the detailed shipment data for the relevant customers
detailed_shipments = execute_sql_query(detailed_sql_query)

# Create a map for each customer showing the different countries
for customer_id, group in detailed_shipments.groupby('CustomerID'):
    countries = group['ShipCountry'].unique()
    
    # Create a Plotly map for the customer
    fig = px.choropleth(locations=countries, locationmode='country names',
                        title=f'Shipment Countries for Customer ID: {customer_id}')
    
    # Show the map to the user
    show_to_user(fig)","The input code correctly identifies customers with shipments to multiple countries and generates a map for each customer. The logic used to retrieve the customers and countries is consistent with the reference code. Both utilize SQL queries to find customers and countries, and group the data accordingly. The visualization part also aligns well, using Plotly to display the countries for each customer. Despite some differences in SQL query structure and plotting function, the input code adheres to the business request and the logic of the reference implementation.",Finetuned
"Which suppliers provide the most products, and can this be visualized in a bar chart to compare the quantity of products supplied by each supplier?","```python
import plotly.express as px

# SQL query for data retrieval
sql_query = """"""
SELECT s.SupplierName, COUNT(*) AS ProductCount 
FROM products p 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
GROUP BY s.SupplierName 
ORDER BY ProductCount DESC
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly for visualization
fig = px.bar(data, x='SupplierName', y='ProductCount',
             title='Number of Products Supplied by Each Supplier',
             labels={'SupplierName': 'Supplier', 'ProductCount': 'Number of Products'},
             template='plotly')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, COUNT(p.ProductID) AS ProductCount
FROM products p
GROUP BY p.SupplierID
ORDER BY ProductCount DESC
""""""

supplier_data = execute_sql_query(sql_query)

fig = px.bar(supplier_data, x='SupplierID', y='ProductCount', title='Number of Products Supplied by Each Supplier', labels={'SupplierID': 'Supplier ID', 'ProductCount': 'Number of Products'})
show_to_user(fig)
```","The input code does not match the reference implementation in terms of the business question and logic. The reference code uses SUPPLIER names for grouping, while the input code groups by SupplierID, which might not reflect the supplier names. This can lead to different results and visualization since names provide more explicit information than IDs. Additionally, the input lacks a JOIN with the suppliers table, meaning there's no conversion from SupplierID to SupplierName.","```python
import pandas as pd
import plotly.express as px

# Mock function to simulate SQL execution and data retrieval
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would perform the actual SQL execution.
    # Here, it's mocked to return a sample DataFrame.
    # In practice, replace the following with actual database query execution
    data = {
        ""SupplierID"": [1, 2, 3],
        ""ProductCount"": [10, 5, 8]
    }
    return pd.DataFrame(data)

# Mock function to simulate displaying data to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif hasattr(data, ""show""):
        data.show()

# SQL query from the business analytic request
sql_query = """"""
SELECT SupplierID, COUNT(ProductID) AS ProductCount
FROM products
GROUP BY SupplierID
ORDER BY ProductCount DESC;
""""""

# Execute SQL query and get results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='ProductCount',
             title='Number of Products Supplied by Each Supplier',
             labels={'ProductCount': 'Number of Products'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code uses 'SupplierID' instead of 'SupplierName' for visualization and grouping, which does not match the reference code's logic and request. The query in the input code groups by SupplierID and doesn't join with the suppliers table to get SupplierName. Therefore, it does not answer the business analytics request for listing suppliers by name.",None
"Which products have the highest unit prices in each category, and can this be visualized using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Assuming `execute_sql_query` and `show_to_user` are already defined as specified

# SQL query to retrieve products with the highest unit prices in each category
sql_query = """"""
SELECT p.CategoryID, p.ProductName, p.UnitPrice 
FROM products p 
JOIN (
    SELECT CategoryID, MAX(UnitPrice) AS MaxPrice 
    FROM products 
    GROUP BY CategoryID
) pm 
ON p.CategoryID = pm.CategoryID AND p.UnitPrice = pm.MaxPrice;
""""""

# Execute the SQL query and retrieve the result as a pandas DataFrame
product_data = execute_sql_query(sql_query)

# Visualize the result using a bar chart if possible
if not product_data.empty:
    fig = px.bar(product_data, x='CategoryID', y='UnitPrice', color='ProductName',
                 title='Highest Unit Price Products in Each Category',
                 labels={'CategoryID': 'Category ID', 'UnitPrice': 'Unit Price'})
    show_to_user(fig)
else:
    show_to_user(product_data)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, p.ProductName, p.UnitPrice
FROM products p
WHERE p.Discontinued = 0
AND p.CategoryID IS NOT NULL
ORDER BY p.CategoryID, p.UnitPrice DESC
""""""

products_df = execute_sql_query(sql_query)
highest_price_products = products_df.groupby('CategoryID').first().reset_index()

fig = px.bar(highest_price_products, x='CategoryID', y='UnitPrice', 
             text='ProductName', title='Highest Unit Prices by Category')

show_to_user(fig)
```","The provided code does not accurately fulfill the business analytics request. The SQL query retrieves products ordered by UnitPrice in descending order without ensuring it selects the highest priced product per category, which leads to incorrect products being chosen if multiple products have the same price in different categories. Additionally, the code lacks the same conditional filters present in the reference implementation (such as MAX aggregation with JOIN), and may miss cases where multiple products share the highest price within a category. This can cause incorrect results reflected in the bar chart visualization.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.CategoryID, p.ProductName, p.UnitPrice 
FROM products p 
WHERE p.UnitPrice = (
    SELECT MAX(p2.UnitPrice) 
    FROM products p2 
    WHERE p2.CategoryID = p.CategoryID
);
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str):
    # Mock execution, replace with actual database logic
    # Assuming connection and execution
    # conn = your_database_connection()
    # df = pd.read_sql_query(sql_query, conn)
    # For this example, we mock the DataFrame
    df = pd.DataFrame({
        'CategoryID': [1, 2, 3],
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'UnitPrice': [100.0, 50.0, 75.0]
    })
    return df

# Show data to the user
def show_to_user(data):
    # Check if the data is a DataFrame for displaying
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        # In actual implementation, use display function for better visual representation
        print(""Plotting the visualization..."")
        data.show()

# Fetch the data
products_df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(products_df, x='CategoryID', y='UnitPrice', 
             title='Highest Unit Prices by Product Category', 
             text='ProductName')

# Show the bar chart
show_to_user(fig)
```","The input code correctly answers the question by selecting products with the highest unit prices per category using a correlated subquery. It matches the logic of the reference implementation, which achieves the same result using a JOIN with a subquery approach. Both methods return the same required data and create a bar chart visualization for the output.",Finetuned
What is the distribution of employee salaries? Please include a histogram to visualize the distribution.,"
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT Salary FROM employees;
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Create a histogram to visualize the salary distribution
fig = px.histogram(df, x='Salary', title='Distribution of Employee Salaries', labels={'x': 'Salary', 'y': 'Frequency'}, nbins=30)

# Display the histogram to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Salary FROM employees""
salaries_df = execute_sql_query(sql_query)

fig = px.histogram(salaries_df, x='Salary', title='Distribution of Employee Salaries', nbins=30)
show_to_user(fig)
```","The input Python code effectively uses a SQL query to retrieve 'Salary' from the 'employees' table. It then uses Plotly Express to create a histogram with the salary data. The title and bin count of the histogram match those in the reference code. Both implementations display the histogram using 'show_to_user'. Therefore, the logic and purpose align correctly with the reference code.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # This function is assumed to interact with a database and return a pandas DataFrame.
    # Placeholder implementation; in reality, it would execute the SQL query.
    data = {
        'Salary': [30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000],
        'Count': [10, 20, 30, 25, 15, 10, 5, 2]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This function is assumed to display data to the user.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to get the histogram data
sql_query = """"""
SELECT Salary, COUNT(*) AS Count
FROM employees
GROUP BY Salary
ORDER BY Salary;
""""""

# Execute the SQL query
salary_data = execute_sql_query(sql_query)

# Create the histogram using Plotly
fig = px.bar(salary_data, x='Salary', y='Count', title='Employee Salary Distribution')

# Display the histogram
show_to_user(fig)
```","The input Python code evaluates a grouped summary of salaries rather than a distribution of individual salaries. It uses a bar chart instead of a histogram, and it aggregates the data into 'Count' whereas the reference code uses individual salary values for a histogram. Thus, it does not follow the same logic as the reference implementation.",Base
"What is the average discount given on each product, and can we visualize this data with a bar chart to compare the discounts?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, AVG(od.Discount) AS AverageDiscount 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query and obtain the results in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function; replace with actual database execution logic
    pass

# Function to display data or visualization results
def show_to_user(data):
    # Placeholder function; replace with actual display logic
    pass

# Execute the query to get the data
discount_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(discount_data, x='ProductName', y='AverageDiscount', 
             title='Average Discount Given on Each Product', 
             labels={'AverageDiscount': 'Average Discount', 'ProductName': 'Product Name'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, AVG(od.Discount) AS AverageDiscount
FROM products AS p
JOIN [Order Details] AS od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='ProductName', y='AverageDiscount', title='Average Discount per Product')
show_to_user(fig)
```","The input code correctly calculates the average discount for each product and matches the logic of the reference code. It uses a similar SQL query to group by product name and calculate the average discount, and it correctly visualizes the result using a bar chart with Plotly.","
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT 
    p.ProductID, 
    AVG(od.Discount) AS AvgDiscount 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    p.ProductID;
""""""

# Execute the SQL query and get the result into a DataFrame
discounts_df = execute_sql_query(sql_query)

# Visualize the average discount given on each product with a bar chart
fig = px.bar(discounts_df, x='ProductID', y='AvgDiscount', 
             title='Average Discount by Product',
             labels={'ProductID': 'Product ID', 'AvgDiscount': 'Average Discount'},
             template='plotly')

# Display the bar chart using the utility function
show_to_user(fig)
","The input code groups discounts by ProductID instead of ProductName, which may miss the requirement of the business request to visualize discounts with product names for easier comparison. Even though Product IDs might be unique identifiers, using Product Names aligns better with user understanding, as reflected in the reference implementation. Additionally, the input code sets a different Plotly template, but this does not affect the correctness regarding the business request.",Base
"What is the average discount given on all orders, and can you provide a histogram to visualize the distribution of discounts?","
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function for executing SQL query
    # This would be implemented to connect to a database and return a DataFrame
    pass

def show_to_user(data):
    # Dummy function for displaying data or visualization results
    # This would be implemented to handle display logic
    pass

# SQL query to get the discount data
sql_query = ""SELECT Discount FROM [Order Details];""
discount_data = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = discount_data['Discount'].mean()

# Display the average discount to the user
average_discount_df = pd.DataFrame({'Average Discount': [average_discount]})
show_to_user(average_discount_df)

# Create a histogram to visualize the distribution of discounts
fig = px.histogram(discount_data, x='Discount', title='Distribution of Discounts', nbins=30)

# Show the histogram to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Discount
FROM [Order Details]
""""""
discounts_df = execute_sql_query(sql_query)

average_discount = discounts_df['Discount'].mean()

histogram_fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts', labels={'Discount': 'Discount'})
show_to_user(histogram_fig)

average_discount
```","The input code correctly calculates the average discount using the `mean()` function on the 'Discount' column from the `discounts_df` DataFrame. It then uses Plotly to create a histogram of the discounts. The `execute_sql_query` function retrieves the necessary data, and the histogram is displayed using `show_to_user()`, aligning with the reference implementation's logic.","```python
import pandas as pd
import plotly.express as px

# SQL query to get all discount values from the database.
sql_query = ""SELECT Discount FROM [Order Details]""

# Execute the query and load the result into a DataFrame.
discounts_df = execute_sql_query(sql_query)

# Calculate the average discount.
average_discount = discounts_df['Discount'].mean()

# Display the average discount.
show_to_user(pd.DataFrame({'Average Discount': [average_discount]}))

# Create a histogram to visualize the distribution of discounts.
fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts')

# Display the histogram.
show_to_user(fig)
```","The input code successfully replicates the logic and processes of the reference implementation. Both codes execute a SQL query to retrieve discount data, calculate the average discount, and utilize plotly express to generate a histogram of the discount distribution. The functions `execute_sql_query` and `show_to_user` are placeholders in both implementations. The input code adheres to the requirements by calculating the average discount and visualizing the discount distribution, fulfilling the business analytics request.",both
Calculate the inventory turnover ratio for all products and visualize the results using a bar chart to compare turnover ratios across different products.,"```python
import pandas as pd
import plotly.express as px

# SQL query to calculate inventory turnover ratio
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio 
FROM products 
INNER JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName;
""""""

# Function to execute the SQL query and retrieve the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a mock implementation. Replace with actual database connection logic.
    # Example: Use a connection to get data and convert to DataFrame.
    pass

# Get the DataFrame from the SQL query
df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not df.empty:
    # Create a bar chart to visualize turnover ratios
    fig = px.bar(df, x='ProductName', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio by Product')

    # Display the figure using the show_to_user utility function
    show_to_user(fig)
else:
    print(""No data available to display."")

# Function to display the visualization
def show_to_user(data):
    # This is a mock implementation. Replace with actual display logic.
    # Example: Data could be displayed in Jupyter or a web application.
    pass
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate inventory turnover ratio for all products
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS CostOfGoodsSold,
    AVG(p.UnitsInStock) AS AverageInventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

# Execute the SQL query
turnover_data = execute_sql_query(sql_query)

# Create a bar chart to visualize inventory turnover ratios
fig = px.bar(turnover_data, x='ProductName', y='InventoryTurnoverRatio', 
             title='Inventory Turnover Ratio by Product',
             labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})

# Show the chart to the user
show_to_user(fig)
```","The input Python code correctly calculates the inventory turnover ratio by joining the 'products' and '[Order Details]' tables, ensuring that sales are summed and average inventory is used for ratio calculation. The input code includes a safeguard against division by zero using NULLIF, similar to how SQL handles safe division. It also correctly groups by 'ProductID' and 'ProductName'. The visualization part uses Plotly Express to create a bar chart labeled with 'Inventory Turnover Ratio', aligning with the business request. Despite slight differences in column names, the logic aligns with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Simulating the execution of the SQL query
sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic.
    # For demo purposes, return an empty DataFrame or replace with logic to fetch data.
    return pd.read_sql(sql_query, connection)

# Execute the SQL query
inventory_data = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(
    inventory_data,
    x='ProductName',
    y='InventoryTurnoverRatio',
    title='Inventory Turnover Ratio for Products',
    labels={'ProductName': 'Product Name', 'InventoryTurnoverRatio': 'Turnover Ratio'}
)

# Show the figure to the user
show_to_user(fig)
```","The input Python code correctly calculates the inventory turnover ratio for each product by joining the 'products' and 'Order Details' tables, summing the product of 'Quantity' and 'UnitPrice', and dividing by the average 'UnitsInStock'. It uses the SQL's NULLIF function to handle division by zero, which is a refinement of the reference implementation. The visualization part also matches by creating a bar chart using Plotly. Both the reference and input codes achieve the same end result, thus making the input code correct.",both
"What is the total sales revenue generated by each employee, and can it be visualized to compare performances effectively?","
```python
import pandas as pd
import plotly.express as px

# Assume this utility function is provided
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to run the given SQL query
    # and return a pandas DataFrame.
    pass

# Assume this utility function is provided
def show_to_user(data):
    # This function is assumed to display data analysis
    # results or visualization results. It accepts a pandas DataFrame
    # or Plotly figure.
    pass

# SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the data in a DataFrame
df_sales = execute_sql_query(sql_query)

# Visualize the total sales revenue by employee using a bar chart
fig = px.bar(df_sales, x='EmployeeID', y='TotalSales',
             title='Total Sales Revenue by Employee',
             labels={'TotalSales': 'Total Sales Revenue', 'EmployeeID': 'Employee ID'},
             text='TotalSales')  # Add text labels to bars for clarity

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total sales revenue generated by each employee
sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) as EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
ORDER BY 
    TotalSales DESC
""""""

# Execute the SQL query
employee_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales revenue generated by each employee
fig = px.bar(employee_sales_df, x='EmployeeName', y='TotalSales', 
             title='Total Sales Revenue by Employee',
             labels={'TotalSales':'Total Sales Revenue', 'EmployeeName':'Employee Name'},
             color='TotalSales')

# Show the visualization to the user
show_to_user(fig)
```","The provided code meets the business analytics request and adheres to the logic of the reference implementation. It computes the total sales revenue for each employee similarly, by calculating the sum of sales from the joined orders and order details tables grouped by employee. It adds the employee name concatenation for a more descriptive visualization which is a valid enhancement but does not alter the core logic of computing total sales per employee. The code visualizes the results using Plotly's bar chart and outputs it efficiently using the `show_to_user` function.","```python
import pandas as pd
import plotly.express as px

# Given function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    pass

def show_to_user(data):
    # Placeholder for actual display logic
    pass


def get_total_sales_by_employee():
    # SQL query to fetch total sales by each employee
    sql_query = """"""
    SELECT employees.EmployeeID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
    FROM employees 
    JOIN orders ON employees.EmployeeID = orders.EmployeeID 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    GROUP BY employees.EmployeeID
    """"""
    
    # Execute SQL query and get results in a DataFrame
    sales_data_df = execute_sql_query(sql_query)
    
    # Visualize the total sales by employee using a bar chart
    fig = px.bar(sales_data_df, x='EmployeeID', y='TotalSales', 
                 title='Total Sales Revenue by Employee',
                 labels={'TotalSales': 'Total Sales Revenue', 'EmployeeID': 'Employee ID'},
                 template='plotly')
    
    # Show the bar chart to the user
    show_to_user(fig)

# Call the function
get_total_sales_by_employee()
```","The input code correctly follows the same logic as the reference implementation. It uses a similar SQL query to calculate the total sales revenue for each employee and visualizes the result with a bar chart using Plotly, ensuring clarity with labels and a title. The function call structure and visualization output are in line with the business analytics request.",both
"How many discontinued products are still listed, and what is the trend over time displayed in a bar chart?","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are already defined within the environment

# SQL query to get the total number of discontinued products over time
sql_query = """"""
SELECT YearListed, COUNT(*) as DiscontinuedCount
FROM products
WHERE Discontinued = 1
GROUP BY YearListed
ORDER BY YearListed;
""""""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Create a bar chart to show the trend of discontinued products over time
fig = px.bar(discontinued_products_df, x='YearListed', y='DiscontinuedCount', 
             title='Trend of Discontinued Products Over Time', 
             labels={'YearListed': 'Year', 'DiscontinuedCount': 'Number of Discontinued Products'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ORDER_DATE, '%Y-%m') AS Month,
    COUNT(ProductID) AS DiscontinuedCount
FROM 
    products
WHERE 
    Discontinued = 1
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='Month', y='DiscontinuedCount', title='Count of Discontinued Products Over Time')
show_to_user(fig)
```","The input code is incorrect because it groups discontinued products by 'Month' using the 'ORDER_DATE' field instead of grouping by 'YearListed'. It also uses DATE_FORMAT to aggregate by month, which deviates from the yearly aggregation specified in the request and reference implementation.","```python
import pandas as pd
import plotly.express as px

# Given SQL query to fetch discontinued products over time
sql_query = """"""
SELECT products.Discontinued, products.CreatedAt
FROM products
WHERE products.Discontinued = 1
""""""

# Execute the SQL query using the provided utility function
products_df = execute_sql_query(sql_query)

# Parse the CreatedAt datetime format if necessary
products_df['CreatedAt'] = pd.to_datetime(products_df['CreatedAt'])

# Count the number of discontinued products listed by year
discontinued_trend = products_df.resample('Y', on='CreatedAt').count().reset_index()
discontinued_trend.columns = ['Year', 'Count']

# Visualize the trend in a bar chart using Plotly
fig = px.bar(discontinued_trend, x='Year', y='Count', title='Trend of Discontinued Products Over Time')

# Show the bar chart to the user
show_to_user(fig)
```","The input code is not correct because it does not group by the year but instead uses resampling to count the row instances directly on the CreatedAt field. Additionally, unlike the reference implementation, it doesn't use the YearListed field for grouping discontinued products by year. The logic doesn't match the specified task of grouping and counting based on YearListed.",None
"  
""Which region has the highest number of orders in 2023, and can this be represented in a bar chart for comparison?""  ","```python
import pandas as pd
import plotly.express as px

# SQL Query to find the region with the highest number of orders in 2023
sql_query = """"""
SELECT region.RegionDescription, COUNT(orders.OrderID) AS order_count 
FROM orders 
JOIN territories ON orders.ShipRegion = territories.TerritoryID 
JOIN region ON territories.RegionID = region.RegionID 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY region.RegionDescription 
ORDER BY order_count DESC
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for comparison
fig = px.bar(data, x='RegionDescription', y='order_count', 
             title='Number of Orders per Region in 2023',
             labels={'RegionDescription':'Region', 'order_count':'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS order_count 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY ShipRegion 
ORDER BY order_count DESC
""""""

order_data = execute_sql_query(sql_query)

fig = px.bar(order_data, x='ShipRegion', y='order_count', 
             title='Number of Orders by Region in 2023', 
             labels={'ShipRegion': 'Region', 'order_count': 'Number of Orders'})

show_to_user(fig)
```","The input code does not join the necessary tables to obtain the region descriptions. It queries based solely on the 'ShipRegion' from the 'orders' table and does not link to the 'territories' and 'region' tables as in the reference code. This means the input code might not correctly map the 'ShipRegion' to the regions intended by the business request. Therefore, the input code does not adhere to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY ShipRegion 
ORDER BY OrderCount DESC;
""""""

# Function to execute SQL and return the result
def execute_sql_query(sql_query: str):
    # The actual execution would interface with a database; here we simulate data retrieval.
    data = {
        'ShipRegion': ['North', 'South', 'East', 'West'],
        'OrderCount': [150, 135, 120, 110]
    }
    df = pd.DataFrame(data)
    return df

# Function to display results to user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif hasattr(data, 'show'):
        data.show()

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Find the region with the highest number of orders
highest_orders = orders_df.head(1)  # Already sorted by OrderCount DESC

# Display the region with the highest number of orders
show_to_user(highest_orders)

# Create a bar chart for comparison
fig = px.bar(orders_df, x='ShipRegion', y='OrderCount', 
             title='Number of Orders by Region in 2023',
             labels={'OrderCount': 'Order Count'},
             text='OrderCount')

# Show the bar chart
show_to_user(fig)
```","The input code does not correctly implement the SQL query or logic. The reference code performs joins with 'territories' and 'region' tables to get 'RegionDescription', whereas the input code only counts orders by 'ShipRegion', which is incorrect for the same logic. Additionally, the input code uses BETWEEN for date filtering instead of YEAR, which should not affect the outcome, but the primary issue is the lack of joins and proper grouping by regions.",None
"What is the average shipping cost per order for each customer country, and can this be visualized using a bar chart?","
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user are predefined utility functions

# SQL query to calculate the average shipping cost per order for each customer country
sql_query = """"""
SELECT customers.Country, AVG(orders.Freight) AS avg_shipping_cost
FROM orders
JOIN customers ON orders.CustomerID = customers.CustomerID
GROUP BY customers.Country
""""""

# Execute the SQL query and retrieve the results into a pandas DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to visualize the average shipping cost per country
fig = px.bar(df, x='Country', y='avg_shipping_cost', title='Average Shipping Cost per Order by Country')

# Show the visualization to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, AVG(Freight) AS average_shipping_cost
FROM orders
GROUP BY ShipCountry
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='ShipCountry', y='average_shipping_cost', 
             title='Average Shipping Cost per Order by Country', 
             labels={'average_shipping_cost': 'Average Shipping Cost', 'ShipCountry': 'Country'})

show_to_user(fig)
```",The input code uses 'ShipCountry' from the 'orders' table instead of joining with the 'customers' table to get 'Country' as in the reference code. The logic differs because it averages shipping cost using a column directly from the 'orders' table rather than ensuring it relates to the customer country in the way the reference code specifies.,"Certainly! Below is a Python code snippet that executes the SQL query and visualizes the average shipping cost per order for each customer country using a bar chart.

```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve average shipping cost per order for each customer country
sql_query = """"""
SELECT CustomerCountry, AVG(Freight) AS AvgFreightCost 
FROM orders 
GROUP BY CustomerCountry
""""""

# Execute the SQL query using the utility function provided
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average shipping cost per customer country
fig = px.bar(df, x='CustomerCountry', y='AvgFreightCost', 
             title='Average Shipping Cost per Order by Customer Country',
             labels={'CustomerCountry': 'Country', 'AvgFreightCost': 'Average Freight Cost'},
             template='plotly')

# Display the bar chart using the utility function
show_to_user(fig)
```

This script invokes the required utility functions to perform the analysis and display the results as a bar chart. Make sure you have the necessary permissions and environment set up to execute this script in your business context.","The input Python code uses 'CustomerCountry' instead of joining the 'customers' table using 'CustomerID' to get the 'Country'. The SQL logic does not match the reference which joins 'orders' with 'customers' to ensure accurate country data, hence the aggregation may be incorrect.",None
"What is the average discount applied to products in each order, and can you provide a bar chart to visualize the distribution of average discounts by order?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT OrderID, AVG(Discount) AS AvgDiscount
FROM [Order Details]
GROUP BY OrderID;
""""""

# Execute SQL Query
df = execute_sql_query(sql_query)

# Visualization: Bar Chart
fig = px.bar(df, x='OrderID', y='AvgDiscount', title='Average Discount Per Order', 
             labels={'AvgDiscount': 'Average Discount', 'OrderID': 'Order ID'})

# Display the Bar Chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.OrderID, 
    AVG(od.Discount) AS AverageDiscount
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    o.OrderID
""""""

average_discounts = execute_sql_query(sql_query)

fig = px.bar(average_discounts, x='OrderID', y='AverageDiscount', 
             title='Average Discount Applied to Products by Order',
             labels={'OrderID': 'Order ID', 'AverageDiscount': 'Average Discount'})
show_to_user(fig)
```","The input code correctly executes the SQL query to calculate the average discount per order and visualizes the results using a bar chart. The join with 'orders' is redundant if 'OrderID' is already in 'Order Details', but it does not affect the correctness due to correct grouping and aggregation. The logic and output are aligned with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query
sql_query = """"""
SELECT OrderID, AVG(Discount) AS AverageDiscount
FROM [Order Details]
GROUP BY OrderID;
""""""

# Step 2: Execute the SQL query and get the results as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # NOTE: The implementation of this function is assumed to be available.
    pass

# Execute the SQL query
order_discounts_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart using Plotly
fig = px.bar(order_discounts_df, x='OrderID', y='AverageDiscount', 
             title='Average Discount by Order',
             labels={'OrderID': 'Order ID', 'AverageDiscount': 'Average Discount'})

# Step 4: Show the bar chart to the user
def show_to_user(data):
    # NOTE: The implementation of this function is assumed to be available.
    pass

show_to_user(fig)
```","The provided code follows the same logic as the reference implementation. It calculates the average discount per order using a SQL query and visualizes the results with a Plotly bar chart, matching all key elements specified in the reference code. Variable names differ slightly (AvgDiscount vs. AverageDiscount) but these differences are superficial and do not affect correctness.",both
"What are the details of orders where a discount was applied, and can this information be represented in a suitable data visualization?","```python
import plotly.express as px

# SQL query
sql_query = ""SELECT * FROM [Order Details] WHERE Discount > 0;""

# Execute the SQL query
order_details_df = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(order_details_df, x='OrderID', y='Discount', 
             title='Orders with Discount Applied',
             labels={'OrderID': 'Order ID', 'Discount': 'Discount Amount'},
             hover_data=order_details_df.columns)

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get details of orders with discounts
sql_query = """"""
SELECT od.OrderID, od.ProductID, p.ProductName, od.UnitPrice, od.Quantity, od.Discount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE od.Discount > 0
""""""

# Execute SQL query
order_details_with_discount = execute_sql_query(sql_query)

# Visualization
fig = px.bar(order_details_with_discount, 
              x='ProductName', 
              y='Quantity', 
              color='Discount', 
              title='Order Details with Discounts',
              labels={'Quantity': 'Quantity Ordered', 'Discount': 'Discount Applied'})
show_to_user(fig)
```","The input code and reference code have differences. The input code joins the 'Order Details' with 'products' to include 'ProductName', which is not in the reference code. The visualization also differs; the input code uses 'ProductName' on the x-axis and 'Quantity' with color-coded 'Discount', while the reference uses 'OrderID' on the x-axis and 'Discount'. These differences result in a visualization that doesn't conform to the logic of the reference implementation.","```python
import plotly.express as px

# SQL query to retrieve order details where a discount was applied
sql_query = ""SELECT * FROM [Order Details] WHERE Discount > 0;""

# Execute the SQL query to retrieve the data
orders_with_discount_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(orders_with_discount_df)

# Visualization: A bar chart showing the discount amounts applied to orders
fig = px.bar(
    orders_with_discount_df,
    x='OrderID',
    y='Discount',
    title='Orders with Discount Applied',
    labels={'OrderID': 'Order ID', 'Discount': 'Discount Amount'},
    color='ProductID'  # Optional: use different colors for each product
)

# Display the visualization
show_to_user(fig)
```","The input code correctly executes a SQL query to retrieve order details where a discount is applied, which matches the logic of the reference code. It then visualizes the data using a bar chart, similar to the reference implementation. The added color distinction based on 'ProductID' is an enhancement but does not conflict with the business request. Both implementations achieve the requested functionality and visualization.",Finetuned
Which products are most frequently ordered? Include a bar chart to visualize the top ten products by order frequency.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to extract product order frequencies
sql_query = '''
SELECT ProductID, COUNT(ProductID) AS Frequency 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY Frequency DESC;
'''

# Execute the SQL query and load the data into a DataFrame
df_products = execute_sql_query(sql_query)

# Select the top 10 most frequently ordered products
top_10_products = df_products.head(10)

# Create a bar chart using Plotly to visualize the top 10 products by order frequency
fig = px.bar(top_10_products, x='ProductID', y='Frequency', 
             title='Top 10 Most Frequently Ordered Products',
             labels={'ProductID': 'Product ID', 'Frequency': 'Order Frequency'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
LIMIT 10;
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductID', y='TotalQuantity', 
              title='Top 10 Products by Order Frequency', 
              labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity Ordered'})

show_to_user(fig)
```","The input code uses 'SUM(od.Quantity)' to rank the products by total quantity ordered, whereas the reference code uses 'COUNT(ProductID)' to determine how frequently a product is ordered. These are not equivalent: the input code ranks by total quantity, while the reference ranks by order count.","
import pandas as pd  
import plotly.express as px  

# Define SQL query  
sql_query = '''  
SELECT products.ProductID, COUNT(orders.ProductID) AS OrderFrequency  
FROM orders  
JOIN products ON orders.ProductID = products.ProductID  
GROUP BY products.ProductID  
ORDER BY OrderFrequency DESC  
'''  

def execute_sql_query(sql_query: str) -> pd.DataFrame:  
    # Placeholder for executing SQL query, should be replaced with the actual implementation  
    data = pd.DataFrame({  
        'ProductID': range(1, 21),  # Example ProductIDs  
        'OrderFrequency': [20, 19, 18, 17, 16, 15, 14, 13, 12, 11]  # Example OrderFrequency  
    })  
    return data  

def show_to_user(data):  
    # Placeholder for showing data to user, should be replaced with the actual implementation  
    if isinstance(data, pd.DataFrame):  
        print(data)  
    else:  
        data.show()  

# Execute the SQL query to get data  
df = execute_sql_query(sql_query)  

# Get top ten products by order frequency  
top_ten_df = df.head(10)  

# Create a bar chart using Plotly  
fig = px.bar(top_ten_df, x='ProductID', y='OrderFrequency',  
             title='Top Ten Products by Order Frequency',  
             labels={'ProductID': 'Product ID', 'OrderFrequency': 'Order Frequency'})  

# Show the bar chart to the user  
show_to_user(fig)  
","The input code correctly implements the business analytics request by selecting the top ten products based on frequency from a simulated dataset. It also creates and displays a bar chart using Plotly, similar to the reference implementation. Although the input code includes a placeholder `execute_sql_query` function, it aligns with the reference implementation's logic by ordering products by frequency and visualizing them. The SQL query and bar chart logic are consistent with the reference code, meeting the task requirements.",Finetuned
"What is the total discount offered across all orders this month, and can you provide a bar chart showing discounts by week?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total discount offered across all orders this month
sql_total_discount = """"""
SELECT SUM(od.Discount) AS TotalDiscount 
FROM [Order Details] od 
WHERE DATE_TRUNC('month', CURRENT_DATE) = DATE_TRUNC('month', OrderDate);
""""""

# Retrieve the total discount data
total_discount_df = execute_sql_query(sql_total_discount)

# Show the total discount to the user
show_to_user(total_discount_df)

# SQL query to get discounts by week for visualisation
sql_weekly_discounts = """"""
SELECT DATE_TRUNC('week', OrderDate) as Week, SUM(od.Discount) AS DiscountSum 
FROM [Order Details] od 
WHERE DATE_TRUNC('month', CURRENT_DATE) = DATE_TRUNC('month', OrderDate) 
GROUP BY DATE_TRUNC('week', OrderDate)
ORDER BY Week;
""""""

# Retrieve the weekly discount data
weekly_discount_df = execute_sql_query(sql_weekly_discounts)

# Create a bar chart using Plotly to show discounts by week
fig = px.bar(weekly_discount_df, x='Week', y='DiscountSum', title='Weekly Discounts for Current Month')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total discounts and discounts by week for the current month
sql_query = """"""
SELECT 
    SUM(Discount) AS TotalDiscount,
    DATE_TRUNC('week', o.OrderDate) AS DiscountWeek
FROM 
    [Order Details] od
JOIN 
    Orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE)
GROUP BY 
    DiscountWeek
ORDER BY 
    DiscountWeek;
""""""

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Calculate total discount
total_discount = discount_data['TotalDiscount'].sum()

# Create a bar chart for discounts by week
fig = px.bar(discount_data, x='DiscountWeek', y='TotalDiscount', 
             title=f'Total Discounts Offered This Month: ${total_discount:.2f}', 
             labels={'DiscountWeek': 'Week', 'TotalDiscount': 'Discount Amount'})
             
# Show the total discount and bar chart to the user
show_to_user(fig)
```","The input code calculates the total discount by summing the 'TotalDiscount' column, which is incorrect since this column represents weekly sums, not a total for the month. Additionally, it combines the computation of total discount and weekly computations in a single SQL query, whereas the reference code separates these concerns into two queries. Consequently, the input code does not align with the reference implementation's logic as it misrepresents the total discount for the month.","
```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Logic to execute SQL and return DataFrame
    pass

# Utility function to show data or visualization
def show_to_user(data):
    # Logic to show the DataFrame or Plotly figure
    pass

# SQL query to calculate the total discount for the current month
total_discount_query = """"""
SELECT 
    SUM(od.Quantity * od.UnitPrice * od.Discount) AS TotalDiscount 
FROM 
    [Order Details] od 
JOIN 
    orders o ON od.OrderID = o.OrderID 
WHERE 
    MONTH(o.OrderDate) = MONTH(CURRENT_DATE) 
    AND YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
""""""

# Execute the SQL query and get the total discount
total_discount_df = execute_sql_query(total_discount_query)

# Display the total discount
show_to_user(total_discount_df)

# SQL query to get discounts by week for the current month
discount_by_week_query = """"""
SELECT 
    WEEK(o.OrderDate) AS OrderWeek, 
    SUM(od.Quantity * od.UnitPrice * od.Discount) AS TotalDiscount 
FROM 
    [Order Details] od 
JOIN 
    orders o ON od.OrderID = o.OrderID 
WHERE 
    MONTH(o.OrderDate) = MONTH(CURRENT_DATE) 
    AND YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY 
    OrderWeek
""""""

# Execute the SQL query and get the discounts by week
discount_by_week_df = execute_sql_query(discount_by_week_query)

# Create a bar chart using Plotly
fig = px.bar(discount_by_week_df, x='OrderWeek', y='TotalDiscount', title='Discounts by Week for Current Month')

# Display the bar chart
show_to_user(fig)
```
","The evaluated code incorrectly calculates the total discount. The reference code simply sums up the discounts for the orders, while the evaluated code multiplies Quantity, UnitPrice, and Discount. This results in a different logic and possibly incorrect total. Additionally, the evaluated code uses WEEK and MONTH functions which might behave differently than DATE_TRUNC for handling dates, potentially leading to different results, especially for week grouping.",None
"Which products had the highest discount applied last month, and can we visualize this with a bar chart showing products and discount percentages?","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder; actual implementation should connect to a database
    pass

# Function to send data or visualizations to the user
def show_to_user(data):
    # This is a placeholder; actual implementation should handle displaying the data
    pass

# SQL query to find products with the highest discount applied last month
sql_query = """"""
SELECT p.ProductName, od.Discount 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE od.OrderDate >= DATEADD(month, -1, GETDATE()) 
AND od.OrderDate < GETDATE() 
ORDER BY od.Discount DESC
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# If the dataframe is empty, send a notification to the user
if df.empty:
    show_to_user(""No discounts applied last month."")
else:
    # Create a bar chart using Plotly
    fig = px.bar(df, x='ProductName', y='Discount', title='Products with Highest Discounts Last Month')

    # Display the bar chart to the user
    show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get products with the highest discount applied last month
sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       AVG(od.Discount) * 100 AS DiscountPercentage
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID FROM orders 
    WHERE EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '1 month')
    AND EXTRACT(MONTH FROM OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 month')
)
GROUP BY p.ProductID, p.ProductName
ORDER BY DiscountPercentage DESC
LIMIT 10;
""""""

# Execute the query
discount_data = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(discount_data, x='ProductName', 
             y='DiscountPercentage', 
             title='Top Products by Discount Percentage Last Month',
             labels={'DiscountPercentage': 'Discount Percentage (%)', 'ProductName': 'Product Name'},
             color='DiscountPercentage')

# Show the visualization
show_to_user(fig)
```","The input code calculates 'AVG(od.Discount)' which averages the discounts per product, while the reference code selects 'od.Discount' and orders by it directly, implying individual highest discount values rather than averages. Additionally, the input code limits results to the top 10, which isn't specified in the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query to find the products with the highest discount applied last month
sql_query = """"""
SELECT ProductID, MAX(Discount) AS MaxDiscount
FROM [Order Details]
WHERE OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE)
AND OrderDate < CURRENT_DATE
GROUP BY ProductID
ORDER BY MaxDiscount DESC;
""""""

# Execute the SQL query to get the data in a pandas DataFrame
discount_data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the products and their discount percentages
fig = px.bar(discount_data_df, x='ProductID', y='MaxDiscount',
             title='Products with Highest Discounts Last Month',
             labels={'MaxDiscount': 'Discount Percentage', 'ProductID': 'Product ID'},
             text='MaxDiscount')

# Display the bar chart
show_to_user(fig)
```","The input code is not correct because it groups by ProductID and calculates MAX(Discount), which doesn't align with the reference logic of selecting all discounts applied and ordering by highest discounts. Additionally, it doesn't join the 'products' table to retrieve the ProductName, which is essential for displaying the correct product details in the chart. Thus, the visualization might not accurately reflect the products with the highest discounts by month, as the aggregation method and data context differ from the reference.",None
Calculate the customer retention rate for January 2022 and provide a line chart to visualize retention trends over time.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for executing SQL and returning DataFrame
    pass

def show_to_user(data):
    # Placeholder function for displaying data or figures
    pass

# SQL query to calculate retention rate for January 2022
sql_query_jan_2022 = """"""
SELECT (COUNT(DISTINCT CASE WHEN orders.OrderDate BETWEEN '2022-01-01' AND '2022-01-31' THEN orders.CustomerID END) * 1.0 / 
COUNT(DISTINCT CASE WHEN orders.OrderDate < '2022-01-01' THEN orders.CustomerID END)) AS RetentionRate 
FROM orders;
""""""

# Execute the SQL query
retention_rate_df = execute_sql_query(sql_query_jan_2022)

# Extract the January 2022 retention rate
jan_2022_retention_rate = retention_rate_df['RetentionRate'].iloc[0]

# Fake data for retention trends over time for visualization demonstration purposes
# In practice, this data should be gathered through executing similar SQL commands over required periods
date_range = pd.date_range(start='2021-01-01', end='2022-12-31', freq='M')
retention_trends_data = {
    'Date': date_range,
    'RetentionRate': [0.85, 0.83, 0.87, 0.82, 0.80, 0.83, 0.81, 0.84, 0.86, 0.82, 0.88, 0.81,  # 2021
                      0.79, jan_2022_retention_rate, 0.80, 0.78, 0.77, 0.79, 0.80, 0.82, 0.83, 0.84, 0.81, 0.85]  # 2022
}

retention_trends_df = pd.DataFrame(retention_trends_data)

# Create the line chart
fig = px.line(retention_trends_df, x='Date', y='RetentionRate', title='Customer Retention Trends Over Time', 
              labels={'Date': 'Month', 'RetentionRate': 'Retention Rate'})

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get customer count before January 2022
sql_query_before = """"""
SELECT COUNT(DISTINCT CustomerID) as total_customers
FROM orders
WHERE OrderDate < '2022-01-01'
""""""
total_customers_df = execute_sql_query(sql_query_before)
total_customers = total_customers_df['total_customers'].iloc[0]

# SQL query to get returning customers in January 2022
sql_query_retaining = """"""
SELECT COUNT(DISTINCT CustomerID) as returning_customers
FROM orders
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-01-31'
""""""
returning_customers_df = execute_sql_query(sql_query_retaining)
returning_customers = returning_customers_df['returning_customers'].iloc[0]

# Calculate retention rate
retention_rate = (returning_customers / total_customers) * 100 if total_customers > 0 else 0

# SQL query to analyze retention trends over time
sql_query_trends = """"""
SELECT DATE_TRUNC('month', OrderDate) as month,
       COUNT(DISTINCT CustomerID) as total_customers,
       COUNT(DISTINCT CASE WHEN OrderDate >= '2022-01-01' THEN CustomerID END) as returning_customers
FROM orders
GROUP BY month
ORDER BY month
""""""
trends_df = execute_sql_query(sql_query_trends)
trends_df['retention_rate'] = (trends_df['returning_customers'] / trends_df['total_customers']) * 100
trends_df['month'] = trends_df['month'].dt.strftime('%Y-%m')

# Visualization of retention trends
fig = px.line(trends_df, x='month', y='retention_rate', title='Customer Retention Rate Over Time', labels={'retention_rate': 'Retention Rate (%)'})
show_to_user(fig)

retention_rate
```","The input code incorrectly calculates the retention rate. The logic should compare the number of returning customers in January 2022 to those who made any purchases before this period. However, the input code does not ensure that returning customers were also customers before January 2022, as it only counts unique customers in January 2022. Additionally, the visualization query is incorrect. It calculates 'returning_customers' incorrectly by not restricting the comparison to customers before each respective month.","```python
import pandas as pd
import plotly.express as px

# Assume these functions are already implemented
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function executes an SQL query and returns a pandas DataFrame
    pass

def show_to_user(data):
    # This function displays data analysis or visualization results
    pass

# SQL query to get the retention rate
sql_query = """"""
SELECT (COUNT(DISTINCT o1.CustomerID) * 100.0 / NULLIF(COUNT(DISTINCT o2.CustomerID), 0)) AS customer_retention_rate
FROM orders o1
LEFT JOIN orders o2 ON o1.CustomerID = o2.CustomerID
WHERE DATE_TRUNC('month', o1.OrderDate) = '2022-01-01'
  AND (o2.OrderDate BETWEEN '2021-12-01' AND '2021-12-31')
""""""

# Calculate retention for January 2022
df_retention = execute_sql_query(sql_query)

# Add a date column for visualization
df_retention['Date'] = pd.to_datetime('2022-01-01')

# Use a larger time frame to create a trend
sql_query_trend = """"""
SELECT (COUNT(DISTINCT o1.CustomerID) * 100.0 / NULLIF(COUNT(DISTINCT o2.CustomerID), 0)) AS customer_retention_rate,
DATE_TRUNC('month', o1.OrderDate) AS month
FROM orders o1
LEFT JOIN orders o2 ON o1.CustomerID = o2.CustomerID
WHERE o1.OrderDate <= '2022-01-31'
  AND o2.OrderDate BETWEEN '2021-12-01' AND '2021-12-31'
GROUP BY month
ORDER BY month
""""""

# Get retention trend data
df_trend = execute_sql_query(sql_query_trend)

# Create a line chart to visualize customer retention trends
fig = px.line(df_trend, x='month', y='customer_retention_rate', title='Customer Retention Rate Over Time', labels={'customer_retention_rate': 'Retention Rate (%)'})

# Show the chart to the user
show_to_user(fig)
```","The provided code uses a LEFT JOIN and compares the order dates to calculate retention differently from the reference implementation. It uses specific month truncation and checks, potentially altering the results. Additionally, while both snippets aim to visualize retention trends, the SQL logic differs in detail, affecting the correctness in context to the reference logic.",None
"What percentage of customers are repeat buyers in 2023, and can we visualize this as a pie chart comparing repeat to first-time buyers?","```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database query execution
    # Return a DataFrame with simulated data
    data = {
        'repeat_customer_rate': [0.25]  # Simulated response from the SQL query
    }
    return pd.DataFrame(data)

# Execute the SQL query for repeat customer rate
sql_query = """"""
SELECT (COUNT(DISTINCT o2023.CustomerID) * 1.0 / NULLIF(COUNT(DISTINCT oBefore2023.CustomerID), 0)) AS repeat_customer_rate
FROM orders o2023
JOIN orders oBefore2023 ON o2023.CustomerID = oBefore2023.CustomerID
WHERE o2023.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
AND oBefore2023.OrderDate < '2023-01-01'
""""""

# Fetch the result
result_df = execute_sql_query(sql_query)

# Calculate percentages for repeat and first-time buyers
repeat_customer_rate = result_df['repeat_customer_rate'][0]
first_time_customer_rate = 1 - repeat_customer_rate

# Create a DataFrame for the pie chart
data = {
    'Type': ['Repeat Buyers', 'First-Time Buyers'],
    'Percentage': [repeat_customer_rate, first_time_customer_rate]
}
df = pd.DataFrame(data)

# Create a pie chart
fig = px.pie(df, names='Type', values='Percentage', title='Customer Buying Behavior in 2023')

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
WITH CustomerStatus AS (
    SELECT 
        CustomerID,
        COUNT(OrderID) AS OrderCount
    FROM 
        orders
    WHERE 
        OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
    GROUP BY 
        CustomerID
)
SELECT 
    CASE WHEN OrderCount > 1 THEN 'Repeat Buyer' ELSE 'First-Time Buyer' END AS BuyerType,
    COUNT(*) AS CustomerCount
FROM 
    CustomerStatus
GROUP BY 
    BuyerType;
""""""

buyer_data = execute_sql_query(sql_query)

total_customers = buyer_data['CustomerCount'].sum()
buyer_data['Percentage'] = (buyer_data['CustomerCount'] / total_customers) * 100

fig = px.pie(buyer_data, names='BuyerType', values='Percentage', title='Customer Types in 2023')
show_to_user(fig)
```","The input code does not align with the reference code's logic. The input code classifies customers based on the number of orders made in 2023 ('OrderCount > 1' indicates a repeat buyer). This logic implies repeat purchase within the same year, not if the customer had purchased in previous years. The reference code checks if customers who bought in 2023 also bought before 2023 to determine repeat buyers, which adheres to the business request.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are defined elsewhere.

# SQL query to get the percentage of repeat buyers
sql_repeat_buyers = """"""
SELECT (COUNT(DISTINCT customer_id) FILTER (WHERE order_count > 1)::FLOAT / COUNT(DISTINCT customer_id)) * 100 AS repeat_buyers_percentage 
FROM (
    SELECT c.CustomerID, COUNT(o.OrderID) AS order_count 
    FROM customers c 
    JOIN orders o ON c.CustomerID = o.CustomerID 
    WHERE EXTRACT(YEAR FROM o.OrderDate) = 2023 
    GROUP BY c.CustomerID
) subquery;
""""""

# Execute the SQL query to get the repeat buyers percentage
repeat_buyers_df = execute_sql_query(sql_repeat_buyers)

# Calculate the percentage of first-time buyers
repeat_buyers_percentage = repeat_buyers_df.iloc[0]['repeat_buyers_percentage']
first_time_buyers_percentage = 100 - repeat_buyers_percentage

# Prepare data for the pie chart
pie_chart_data = {
    ""Buyer Type"": [""Repeat Buyers"", ""First-time Buyers""],
    ""Percentage"": [repeat_buyers_percentage, first_time_buyers_percentage]
}

pie_chart_df = pd.DataFrame(pie_chart_data)

# Create the pie chart using Plotly
fig = px.pie(
    pie_chart_df, 
    values='Percentage', 
    names='Buyer Type',
    title='2023 Customer Purchase Behavior'
)

# Display the pie chart
show_to_user(fig)
```",The input code calculates the percentage of repeat buyers incorrectly. It filters customers who have more than one order in 2023 whereas the reference code checks for orders before 2023 to identify repeat buyers. The logic needs to account for customers who bought both before and in 2023.,None
"How much revenue has each customer generated over their lifetime, and can this be visualized in a bar chart to compare across customers?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to get customer lifetime value
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID
""""""

# Execute the SQL query and retrieve data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize customer lifetime value
fig = px.bar(df, x='CustomerID', y='customer_lifetime_value', 
             title='Customer Lifetime Value',
             labels={'customer_lifetime_value': 'Lifetime Revenue', 'CustomerID': 'Customer ID'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT customers.CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CustomerID', y='customer_lifetime_value', title='Customer Lifetime Value', labels={'customer_lifetime_value':'Lifetime Value', 'CustomerID':'Customer ID'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It retrieves the customer lifetime value using a SQL query that calculates the total revenue for each customer by summing the product of UnitPrice, Quantity, and applying the Discount from Order Details. This matches the logic of the reference implementation. The resultant data is then visualized as a bar chart with Plotly, comparing the lifetime revenue across customers. The minor difference in the label name ('Lifetime Value' vs 'Lifetime Revenue') is inconsequential to the logic or outcome.","```python
import plotly.express as px

# Assuming these functions are defined elsewhere in your environment:
# execute_sql_query(sql_query: str): Executes an SQL query and returns a DataFrame.
# show_to_user(data): Displays data, either as a DataFrame or a Plotly figure.

# SQL query to retrieve total revenue per customer
sql_query = """"""
SELECT 
    customers.CustomerID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * 
    (1 - [Order Details].Discount)) AS TotalRevenue 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.CustomerID;
""""""

# Execute the SQL query and get the data in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total revenue generated by each customer
fig = px.bar(df, x='CustomerID', y='TotalRevenue', title='Customer Lifetime Revenue',
             labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly answers the question by calculating the total revenue each customer has generated over their lifetime. It uses the same logic as the reference implementation, querying the database for customer lifetime value using a similar SQL query and grouping by CustomerID. The visualization step also matches the requirement to display a bar chart comparing customers, making use of Plotly's bar chart functionality with appropriate labels and titles.",both
"What is the total quantity sold for each product this month, and can you provide a bar chart to visualize the results?","```python
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute SQL query and return DataFrame
    pass

def show_to_user(data):
    # Placeholder function to show DataFrame or Plotly figure
    pass

# SQL query to get total quantity sold for each product this month
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE DATE_TRUNC('month', CURRENT_DATE) = DATE_TRUNC('month', od.OrderDate) 
GROUP BY p.ProductName;
""""""

# Execute the query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Total Quantity Sold for Each Product This Month')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the current month
current_month = pd.Timestamp.now().strftime('%Y-%m')

# SQL query to get total quantity sold for each product this month
sql_query = f""""""
    SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
    FROM products p
    JOIN [Order Details] od ON p.ProductID = od.ProductID
    WHERE DATE_FORMAT(od.OrderDate, '%Y-%m') = '{current_month}'
    GROUP BY p.ProductID, p.ProductName
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(data, x='ProductName', y='TotalQuantitySold', title='Total Quantity Sold This Month by Product')

# Show the result to the user
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by calculating the total quantity sold for each product this month. It uses a similar SQL logic compared to the reference code by summing quantities per product for the current month. The difference lies in the SQL syntax for date filtering and grouping columns, but the logic and outcome remain the same. Additionally, it successfully creates and displays a bar chart, adhering to the request.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are predefined functions

# SQL query to retrieve total quantity sold for each product this month
sql_query = """"""
SELECT 
    products.ProductName, 
    SUM([Order Details].Quantity) AS total_quantity 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    MONTH(orders.OrderDate) = MONTH(CURRENT_DATE) 
    AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY 
    products.ProductName
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the results
fig = px.bar(data, x='ProductName', y='total_quantity', title='Total Quantity Sold for Each Product This Month')

# Display the bar chart
show_to_user(fig)
```","The input code performs the desired analysis correctly. It calculates the total quantity sold for each product this month using similar logic to the reference code. Both codes use a SQL query that selects product names and sums the quantities, filtering the order dates to the current month. The GROUP BY clause is correctly used to aggregate quantities by product name. The input code also correctly utilizes Plotly to create and display a bar chart. Although there is a slight difference in SQL syntax due to the use of different date functions, both achieve the same logical outcome.",both
"Which city received the most shipments, and can this be shown with a bar chart to compare shipment volumes across cities?","```python
import pandas as pd
import plotly.express as px

# Execute SQL query to get shipment data
sql_query = """"""
SELECT ShipCity, COUNT(*) AS Shipments 
FROM orders 
GROUP BY ShipCity 
ORDER BY Shipments DESC
""""""
shipment_data = execute_sql_query(sql_query)

# Bar chart visualization
fig = px.bar(shipment_data, x='ShipCity', y='Shipments',
             title='Shipments by City',
             labels={'ShipCity': 'City', 'Shipments': 'Number of Shipments'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipCity
ORDER BY ShipmentCount DESC
""""""

shipment_data = execute_sql_query(sql_query)

fig = px.bar(shipment_data, x='ShipCity', y='ShipmentCount', title='Shipment Volumes Across Cities',
             labels={'ShipCity': 'City', 'ShipmentCount': 'Number of Shipments'})
show_to_user(fig)
```","The input code correctly answers the business analytics request by retrieving the shipment data grouped by city, counting the number of orders per city, and ordering it in descending order by the count. This logic is consistent with the reference implementation. Both codes create a bar chart using Plotly Express to visualize the shipment volumes across cities. Although the column name in the input code (ShipmentCount) is different from the reference (Shipments), it does not affect the correctness or logic of the solution.","```python
import plotly.express as px

# SQL query
sql_query = ""SELECT ShipCity, COUNT(OrderID) AS NumShipments FROM orders GROUP BY ShipCity ORDER BY NumShipments DESC;""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to compare shipment volumes across cities
fig = px.bar(df, x='ShipCity', y='NumShipments', title='Number of Shipments per City')

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by executing an SQL query to count and order shipments by ShipCity, similar to the reference code. It uses Plotly to create a bar chart comparing shipment volumes across cities and displays it, aligning with the logic of the reference implementation.",both
Identify suppliers who supply discontinued products and create a bar chart to visualize the number of discontinued products each supplier provides.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get supplier IDs of discontinued products
sql_query = ""SELECT SupplierID, COUNT(*) as DiscontinuedCount FROM products WHERE Discontinued = 1 GROUP BY SupplierID;""

# Execute the SQL query using the utility function
df_discontinued = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of discontinued products each supplier provides
fig = px.bar(df_discontinued, x='SupplierID', y='DiscontinuedCount', 
             title='Number of Discontinued Products per Supplier',
             labels={'DiscontinuedCount': 'Number of Discontinued Products'})

# Show the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT SupplierID, COUNT(ProductID) AS Discontinued_Count
FROM products
WHERE Discontinued = 1
GROUP BY SupplierID
""""""

discontinued_products = execute_sql_query(sql_query)

fig = px.bar(discontinued_products, x='SupplierID', y='Discontinued_Count', 
             title='Number of Discontinued Products per Supplier', 
             labels={'SupplierID': 'Supplier ID', 'Discontinued_Count': 'Number of Discontinued Products'})
show_to_user(fig)
```","The provided Python code correctly implements the business analytics request. The SQL query selects `SupplierID` and counts the discontinued products (where `Discontinued = 1`), grouping by `SupplierID`, which matches the logic of the reference implementation. The subsequent bar chart creation using Plotly displays the number of discontinued products per supplier, adhering to the desired visualization. Therefore, the code is correct as it satisfies the stated requirement and logic of the reference.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get suppliers with discontinued products
sql_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) as DiscontinuedProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.Discontinued = 1
GROUP BY s.CompanyName
ORDER BY DiscontinuedProductCount DESC;
""""""

# Execute the SQL query to get the data
data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of discontinued products per supplier
fig = px.bar(data_df, x='CompanyName', y='DiscontinuedProductCount', 
             title='Number of Discontinued Products by Supplier',
             labels={'CompanyName':'Supplier', 'DiscontinuedProductCount':'Number of Discontinued Products'})

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. Both pieces of code aim to identify suppliers who supply discontinued products and visualize the data using a bar chart. The input code selects `CompanyName` instead of `SupplierID`, which is a reasonable enhancement adding context to the visualization. The logic of counting discontinued products per supplier is consistent with the reference implementation. Thus, the input code meets the requirements and adheres to the same logic.",both
"Which employee had the most sales in the last quarter, and can we see a bar chart showing each employee's sales performance?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to select the employee with the most sales in the last quarter
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATEADD(QUARTER, -1, CURRENT_DATE) 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query to get sales data
sales_data_df = execute_sql_query(sql_query)

# Display the employee with the most sales
top_sales_employee = sales_data_df.head(1)
show_to_user(top_sales_employee)

# Create a bar chart for each employee's sales performance
fig = px.bar(sales_data_df, x='EmployeeID', y='TotalSales', title='Employee Sales Performance in Last Quarter')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales per employee for the last quarter
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_FORMAT(CURRENT_DATE - INTERVAL 3 MONTH, '%Y-01-01')
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Get the employee with the most sales
top_employee = sales_data.iloc[0]

# Create a bar chart for each employee's sales performance
fig = px.bar(sales_data, x='EmployeeName', y='TotalSales', title='Employee Sales Performance Last Quarter')

# Show the results to the user
show_to_user(fig)

# Display the top employee with the most sales
show_to_user(pd.DataFrame([top_employee]))
```","The input code has a different method to determine the date range for the last quarter's sales. It uses 'DATE_FORMAT(CURRENT_DATE - INTERVAL 3 MONTH, '%Y-01-01')' instead of 'DATEADD(QUARTER, -1, CURRENT_DATE)'. This might not accurately capture the last quarter depending on the current date. Additionally, the input uses 'CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName' which is not in the reference code but doesn't affect correctness. However, the date logic flaw results in incorrect code.","```python
import pandas as pd
import plotly.express as px

# Assuming the presence of a utility function execute_sql_query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the actual SQL execution code
    pass

# Assuming the presence of a utility function show_to_user
def show_to_user(data):
    # Placeholder for the actual display code
    pass

# SQL query to get sales performance of each employee in the last quarter
sql_query = """"""
SELECT employees.EmployeeID, FirstName, LastName, 
       SUM([Order_Details].UnitPrice * [Order_Details].Quantity * 
           (1 - [Order_Details].Discount)) AS total_sales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order_Details] ON orders.OrderID = [Order_Details].OrderID 
WHERE QUARTER(orders.OrderDate) = QUARTER(CURDATE() - INTERVAL 3 MONTH) 
AND YEAR(orders.OrderDate) = YEAR(CURDATE() - INTERVAL 3 MONTH) 
GROUP BY employees.EmployeeID, FirstName, LastName 
ORDER BY total_sales DESC
""""""

# Execute the query and get the data
sales_df = execute_sql_query(sql_query)

# Find the employee with the most sales
if not sales_df.empty:
    top_employee = sales_df.iloc[0]
    
    # Display the top employee
    show_to_user(pd.DataFrame([top_employee]))
else:
    show_to_user(pd.DataFrame([{'Message': 'No sales data available for the last quarter'}]))

# Create a bar chart for each employee's sales performance
fig = px.bar(sales_df, x='FirstName', y='total_sales', title='Employee Sales Performance in Last Quarter')

# Show the bar chart
show_to_user(fig)
```","Both implementations perform similar actions: they execute a SQL query to fetch sales data per employee for the last quarter and visualize the results with a bar chart. The key aspects such as calculating total sales, filtering on order dates, and presenting the top sales employee and a bar chart are correctly implemented in both codes. The input code adds first and last names but adheres to the same logical steps.",Finetuned
"Which products have orders that significantly exceed their reorder levels, and how can this be visualized using a bar chart to compare order volumes and reorder levels?","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is a placeholder and should connect to the database to execute the SQL
    # For demonstration, we return an empty DataFrame
    return pd.DataFrame() 

# Function to display the results
def show_to_user(data):
    # This function should be implemented to display DataFrame or Plotly figures
    pass

# SQL query to retrieve products with orders exceeding their reorder levels
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) as TotalOrders, p.ReorderLevel
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName, p.ReorderLevel
HAVING SUM(od.Quantity) > p.ReorderLevel;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not df.empty:
    # Create a bar chart to compare order volumes and reorder levels
    fig = px.bar(df, x='ProductName', y=['TotalOrders', 'ReorderLevel'],
                 title='Products with Orders Exceeding Reorder Levels',
                 labels={'value': 'Quantity', 'variable': 'Metric'},
                 barmode='group')

    # Display the bar chart using the show_to_user function
    show_to_user(fig)
else:
    # If the DataFrame is empty, show an appropriate message
    show_to_user(pd.DataFrame({'message': ['No products found with orders exceeding reorder levels']}))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity) AS TotalOrdered, 
       p.ReorderLevel
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName, p.ReorderLevel
HAVING SUM(od.Quantity) > p.ReorderLevel
""""""

product_data = execute_sql_query(sql_query)

fig = px.bar(product_data, 
              x='ProductName', 
              y='TotalOrdered', 
              title='Products Ordered Exceeding Reorder Levels',
              labels={'TotalOrdered': 'Total Ordered', 'ProductName': 'Product Name'},
              text='ReorderLevel')

fig.add_scatter(x=product_data['ProductName'], 
                y=product_data['ReorderLevel'], 
                mode='lines+markers', 
                name='Reorder Level', 
                line=dict(color='red', dash='dash'))

show_to_user(fig)
```","The input code deviates from the reference code in several ways, particularly in visualization. Instead of rendering a grouped bar chart comparing 'TotalOrders' and 'ReorderLevel', it uses a bar chart with only 'TotalOrdered' and adds a scatter plot for 'ReorderLevel'. This approach contrasts the reference's intent to directly compare order quantities and reorder levels within the same bar group. Additionally, the input code doesn't address the scenario where there's no data output from the SQL query.","```python
import plotly.express as px
import pandas as pd

# Execute the SQL query to get the relevant data
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS OrderVolume, p.ReorderLevel 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE SUM(od.Quantity) > p.ReorderLevel 
GROUP BY p.ProductName, p.ReorderLevel;
""""""

# Placeholder for the utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to the database and execute the given SQL query
    # For now, we assume it returns a pandas DataFrame
    pass

# Get the results from the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize Order Volumes vs Reorder Levels
fig = px.bar(df, x='ProductName', y='OrderVolume', 
             title='Products with Orders Exceeding Reorder Levels',
             labels={'OrderVolume': 'Order Volume', 'ProductName': 'Product Name'},
             hover_data={'ReorderLevel': True},
             text='ReorderLevel', orientation='v')

# Set the y-axis title and display the chart
fig.update_layout(yaxis_title='Volume', barnorm='percent')

# Show the visualization
show_to_user(fig)
```","The input code uses a SQL query with a WHERE clause that incorrectly attempts to use SUM directly, which is not valid in SQL as it needs to be part of a HAVING clause after GROUP BY. Additionally, the input code creates a bar chart for only 'OrderVolume', while the reference code includes both 'OrderVolume' and 'ReorderLevel' for comparison in grouped bars.",None
"Analyze the products with higher sales than the average monthly performance, and create a bar chart to visualize these product sales.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholder
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implement the SQL execution logic returning a pandas DataFrame
    pass

def show_to_user(data):
    # Implement the visualization display logic
    pass

# SQL query to fetch ProductIDs with sales higher than average
sql_query = """"""
SELECT ProductID FROM (
    SELECT ProductID, SUM(Quantity) AS TotalQuantity 
    FROM [Order Details] 
    GROUP BY ProductID
) AS ProductPerformance 
WHERE TotalQuantity > (
    SELECT AVG(TotalQuantity) 
    FROM (
        SELECT ProductID, SUM(Quantity) AS TotalQuantity 
        FROM [Order Details] 
        GROUP BY ProductID
    ) AS AvgPerformance
);
""""""

# Execute the SQL query and get the result
products_above_avg_df = execute_sql_query(sql_query)

# Perform the visualization
if not products_above_avg_df.empty:
    # Assuming 'product_sales_df' DataFrame is available with 'ProductID' and 'TotalQuantity'
    # Create a sample product_sales_df for demonstration
    product_sales_df = pd.DataFrame({
        'ProductID': [1, 2, 3, 4, 5],
        'TotalQuantity': [200, 150, 300, 180, 500]  # Example data
    })

    # Filtering the DataFrame to include only products above average
    product_ids = products_above_avg_df['ProductID']
    filtered_product_sales_df = product_sales_df[product_sales_df['ProductID'].isin(product_ids)]

    # Create a bar chart for the filtered DataFrame
    fig = px.bar(filtered_product_sales_df, x='ProductID', y='TotalQuantity', 
                 title=""Products with Sales Above Average"")

    # Display the plot
    show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve sales data
sales_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""
sales_data = execute_sql_query(sales_query)

# Step 2: Calculate the average monthly sales
average_sales = sales_data['TotalSales'].mean()

# Step 3: Filter products with sales higher than average
high_performance_products = sales_data[sales_data['TotalSales'] > average_sales]

# Step 4: Create a bar chart to visualize high-performance product sales
fig = px.bar(high_performance_products, 
             x='ProductName', 
             y='TotalSales', 
             title='Products with Higher Sales Than Average Monthly Performance',
             labels={'TotalSales': 'Sales', 'ProductName': 'Product Name'})

show_to_user(fig)
```","Both implementations aim to find products with sales higher than average. The input code retrieves product sales data, calculates the average sales, filters products with sales above this average, and visualizes the results. The approach aligns logically with the reference implementation by filtering and charting the high-performance products, even if the SQL queries and visualization details differ slightly.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch product sales data
sql_query = """"""
SELECT products.ProductId, 
       SUM([Order Details].Quantity) AS ProductSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductId 
GROUP BY products.ProductId;
""""""

# Execute the SQL query
product_sales_df = execute_sql_query(sql_query)

# Calculate the average monthly performance
average_sales = product_sales_df['ProductSales'].mean()

# Filter products with sales higher than the average
above_average_products = product_sales_df[product_sales_df['ProductSales'] > average_sales]

# Create a bar chart to visualize product sales
fig = px.bar(above_average_products, 
             x='ProductId', 
             y='ProductSales', 
             title='Products with Higher Sales than Average Monthly Performance')

# Show the figure
show_to_user(fig)
```","The input code calculates the average over all available data rather than the monthly average. The reference code implies averaging total quantities by their 'monthly performance', potentially indicating a requirement for monthly granularity that the input code does not account for.",Base
Identify the most common shipping recipient names and provide a bar chart to visualize their frequency.,"
```python
import plotly.express as px

# SQL query to find the most common shipping recipient names
sql_query = """"""
SELECT ShipName, COUNT(*) AS Frequency 
FROM orders 
GROUP BY ShipName 
ORDER BY Frequency DESC 
LIMIT 5;
""""""

# Execute the SQL query and store the result in a DataFrame
ship_name_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the frequencies of the shipping recipient names
fig = px.bar(ship_name_data, x='ShipName', y='Frequency', title='Top 5 Most Common Shipping Recipient Names')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipName, COUNT(*) as Frequency
FROM orders
GROUP BY ShipName
ORDER BY Frequency DESC
LIMIT 10;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ShipName', y='Frequency', title='Most Common Shipping Recipient Names', labels={'ShipName': 'Recipient Name', 'Frequency': 'Frequency'})
show_to_user(fig)
```","The input code retrieves the top 10 most common shipping recipient names, whereas the reference implementation retrieves the top 5. This difference in the LIMIT clause means that the input code doesn't adhere to the same logic as the reference. Both implementations correctly visualize the data using a bar chart, but the data selection is inconsistent with the reference.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipName, COUNT(*) AS Frequencies 
FROM orders 
GROUP BY ShipName 
ORDER BY Frequencies DESC;
""""""

# Execute the SQL query and get the data
df_shipment_names = execute_sql_query(sql_query)

# Create a bar chart to visualize the frequency of shipping recipient names
fig = px.bar(df_shipment_names, x='ShipName', y='Frequencies', 
             title='Frequency of Shipping Recipient Names', 
             labels={'ShipName': 'Shipping Recipient Name', 'Frequencies': 'Frequency'})

# Display the bar chart to the user
show_to_user(fig)
",The input code does not limit the output to the top 5 most common shipping recipient names as specified in the business analytics request. It retrieves all names ordered by their frequency. This differs from the reference implementation that uses 'LIMIT 5' in the SQL query.,None
Find the top 3 cities with the most suppliers and create a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# The SQL query as per the business request
sql_query = """"""
SELECT City, COUNT(*) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
LIMIT 3;
""""""

# Execute the SQL query using the provided utility function
supplier_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(supplier_data, x='City', y='SupplierCount', title='Top 3 Cities with Most Suppliers')

# Display the Plotly figure using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT City, COUNT(SupplierID) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
LIMIT 3;
""""""

top_cities_df = execute_sql_query(sql_query)

fig = px.bar(top_cities_df, x='City', y='SupplierCount', 
              title='Top 3 Cities with Most Suppliers',
              labels={'SupplierCount': 'Number of Suppliers', 'City': 'City'})
show_to_user(fig)
```","The provided input code correctly implements the business request and adheres to the same logic as the reference implementation. It selects the city and counts the number of suppliers, groups by city, orders them in descending order by supplier count, and limits the results to the top 3. It then creates a bar chart using Plotly, which aligns with the reference implementation's logic.","```python
import pandas as pd
import plotly.express as px

# Step 1: SQL Query
sql_query = """"""
SELECT City, COUNT(*) AS SupplierCount 
FROM suppliers 
GROUP BY City 
ORDER BY SupplierCount DESC 
LIMIT 3;
""""""

# Step 2: Execute SQL Query
df = execute_sql_query(sql_query)

# Step 3: Create Bar Chart
fig = px.bar(df, x='City', y='SupplierCount', title='Top 3 Cities with Most Suppliers')

# Step 4: Show Bar Chart
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It constructs the same SQL query to select the top 3 cities with the most suppliers, groups and orders by 'SupplierCount'. It then uses Plotly to create a bar chart of these results and displays it, just like the reference implementation. The logic and functionality are consistent with the reference, fulfilling the request requirements.",both
Which customers have placed the most orders? Include a bar chart to visualize the top customers by order count.,"
import pandas as pd
import plotly.express as px

# SQL query to get the customers and their order counts
sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) AS OrderCount
FROM orders o
GROUP BY o.CustomerID
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df_orders = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top customers by order count
fig = px.bar(df_orders, x='CustomerID', y='OrderCount', 
             title='Top Customers by Order Count',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'})

# Display the visualization to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) as OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderCount DESC
LIMIT 10;
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='OrderCount', title='Top Customers by Order Count', labels={'CompanyName': 'Customer', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input code provides a correct solution to the business analytics request. It retrieves the top customers by order count, similar to the reference implementation. While it includes `CompanyName`, the SQL logic of joining `customers` with `orders` and ordering results by `OrderCount` achieves the same goal. The addition of `LIMIT 10` and the use of `CompanyName` for labeling in the bar chart enhances the visualization. Both implementations result in a bar chart displaying the top customers by order count, fulfilling the request.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT CustomerID, COUNT(CustomerID) AS OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
""""""

# Fetch the data using the provided utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function will be defined within the environment
    # and will return a pandas DataFrame from the executed SQL query.
    pass

# Execute the query and get the data
customer_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    customer_orders_df,
    x='CustomerID',
    y='OrderCount',
    title='Top Customers by Order Count',
    labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'}
)

# Display the bar chart using the provided show_to_user function
def show_to_user(data):
    # This function will be defined within the environment
    # to display the data or figure passed to it.
    pass

show_to_user(fig)
```","The input code correctly implements the business analytics request using a SQL query to get the number of orders each customer placed, similar to the reference code. It then uses Plotly to create a bar chart visualizing the top customers by order count. The logic and functionality align with the reference implementation, despite some minor differences such as the column naming approach in the COUNT function.",both
"What is the current stock level for each product, and can we visualize this data through a bar chart?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to your database and return a DataFrame
    pass  # Replace with actual implementation

def show_to_user(data):
    # This function handles how data or plots are shown to the user
    pass  # Replace with actual implementation

# SQL query to fetch product stock levels
sql_query = ""SELECT ProductID, UnitsInStock FROM products;""

# Execute SQL query and get the result as a DataFrame
stock_data = execute_sql_query(sql_query)

# Create a bar chart for stock levels
fig = px.bar(stock_data, x='ProductID', y='UnitsInStock', title='Current Stock Levels by Product')

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitsInStock 
FROM products
WHERE Discontinued = 0
""""""

stock_data = execute_sql_query(sql_query)

fig = px.bar(stock_data, x='ProductName', y='UnitsInStock', title='Current Stock Level per Product')
show_to_user(fig)
```","The input code filters out discontinued products by adding a WHERE clause, whereas the reference code does not apply such a filter. This results in a different dataset being visualized if there are discontinued products in the database.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to retrieve product stock levels
sql_query = ""SELECT ProductID, UnitsInStock FROM products;""

# Execute the SQL query and get the result as a pandas DataFrame
product_stock_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the current stock level for each product
fig = px.bar(
    product_stock_data,
    x='ProductID',
    y='UnitsInStock',
    title=""Current Product Stock Levels"",
    labels={'ProductID': 'Product ID', 'UnitsInStock': 'Units In Stock'}
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation by executing a SQL query to retrieve product stock levels, creating a bar chart using Plotly, and displaying it to the user. The variable names and plot customization slightly differ, but they do not affect the overall functionality.",Finetuned
"Calculate the overall product performance score using a composite measure of sales and inventory levels, and visualize the results to identify trends or patterns.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    (SUM(od.Quantity) * (1 - p.Discontinued)) / (p.UnitsInStock + 1) AS ProductPerformanceScore 
FROM 
    [Order Details] od 
JOIN 
    products p 
ON 
    od.ProductID = p.ProductID 
GROUP BY 
    p.ProductID, p.ProductName;  # Added p.ProductName to GROUP BY
""""""

# Execute the SQL query and fetch data into a pandas DataFrame
df = execute_sql_query(sql_query)

# Sort the DataFrame based on ProductPerformanceScore to identify trends or patterns
df_sorted = df.sort_values(by='ProductPerformanceScore', ascending=False)

# Create a bar plot since product names might not be suitable for a line plot
fig = px.bar(df_sorted, x='ProductName', y='ProductPerformanceScore', title=""Product Performance Trends"")

# Show the visualization to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query_performance = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity) AS TotalSales,
    p.UnitsInStock
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

performance_df = execute_sql_query(sql_query_performance)

performance_df['PerformanceScore'] = performance_df['TotalSales'] / performance_df['UnitsInStock'].replace(0, pd.NA)

fig = px.line(performance_df, x='ProductID', y='PerformanceScore', title='Overall Product Performance Score', markers=True)
show_to_user(fig)
```","The input code calculates the PerformanceScore differently from the reference code. The reference implementation calculates the ProductPerformanceScore using the formula (SUM(od.Quantity) * (1 - p.Discontinued)) / (p.UnitsInStock + 1), incorporating a factor for discontinued products. The input code doesn't accommodate discontinued products and uses a different formula: TotalSales / UnitsInStock, which can lead to division by zero if UnitsInStock is zero. Additionally, the input code uses a line plot instead of a bar plot for visualization, which differs from the reference code's choice for categorical data represented by product names.","```python
import plotly.express as px
import pandas as pd

# Assume these utility functions are already defined
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing SQL query and returning a DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    pass

# Define the SQL query for executing
sql_query = """"""
SELECT p.ProductName, 
    (SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)) AS PerformanceScore 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Visualizing the results using Plotly
fig = px.bar(data, x='ProductName', y='PerformanceScore', 
             title='Product Performance Score',
             labels={'PerformanceScore': 'Performance Score'},
             template=""plotly_white"")

# Show the visualization
show_to_user(fig)
```","The input code calculates the PerformanceScore using `SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)` which differs from the reference code logic `(SUM(od.Quantity) * (1 - p.Discontinued)) / (p.UnitsInStock + 1)`. The inclusion of `od.UnitPrice` and usage of `AVG(p.UnitsInStock)` changes the composite measure significantly. Additionally, the reference code factors in if a product is discontinued, which the input code does not.",None
"Which products have reached their reorder level as of the current date, and can you provide a visualization such as a bar chart to display the quantity of each product at the reorder level?","```python
import pandas as pd
import plotly.express as px

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would execute the given SQL query and return a pandas DataFrame.
    # Implementation details are omitted as it's assumed to be predefined.
    pass

# Utility function to display data or visualization
def show_to_user(data):
    # This function would display the given DataFrame or Plotly figure to the user.
    # Implementation details are omitted as it's assumed to be predefined.
    pass

# The SQL query to find products that have reached their reorder level
sql_query = """"""
SELECT products.ProductName, products.UnitsInStock 
FROM products 
WHERE products.UnitsInStock <= products.ReorderLevel
""""""

# Execute the SQL query and obtain the result as a DataFrame
df_reorder_level_products = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the products and their quantities
fig = px.bar(df_reorder_level_products, 
             x='ProductName', 
             y='UnitsInStock', 
             title='Products at Reorder Level',
             labels={'UnitsInStock':'Quantity in Stock', 'ProductName':'Product Name'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find products at reorder level
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel 
FROM products
WHERE UnitsInStock <= ReorderLevel
""""""

# Execute the SQL query
products_at_reorder_level = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(products_at_reorder_level, 
             x='ProductName', 
             y='UnitsInStock', 
             title='Products at Reorder Level',
             labels={'UnitsInStock': 'Quantity at Reorder Level', 'ProductName': 'Product'},
             text='UnitsInStock')

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code performs the same logical steps as the reference implementation. Both codes execute a SQL query to select products at or below their reorder level and use Plotly to create a bar chart visualizing these products by their names and units in stock. The differences, such as additional columns in the SQL query and slight variations in labels, do not affect the correctness concerning the business analytics request.","import plotly.express as px
import pandas as pd

# Utility function to execute the SQL query and get results
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # Example return statement to simulate data fetching
    return pd.DataFrame({
        ""ProductName"": [""Product A"", ""Product B"", ""Product C""],
        ""UnitsInStock"": [50, 30, 10]
    })

# SQL query to find products at reorder level
sql_query = """"""
    SELECT products.ProductName, products.UnitsInStock 
    FROM products 
    WHERE products.UnitsInStock <= products.ReorderLevel
""""""

# Execute SQL query
df_products_at_reorder_level = execute_sql_query(sql_query)

# Create a bar chart to visualize products at reorder level
fig = px.bar(df_products_at_reorder_level,
             x='ProductName',
             y='UnitsInStock',
             title='Products at Reorder Level',
             labels={'UnitsInStock':'Units in Stock', 'ProductName':'Product Name'})

# Display the figure using the provided utility function
show_to_user(fig)
","The provided Python code correctly executes an SQL query to retrieve products that have reached their reorder level by comparing 'UnitsInStock' with 'ReorderLevel'. It then creates and displays a bar chart using Plotly to visualize the products and their quantities, similar to the reference implementation. The query, data extraction logic, and visualization are in line with the business analytics request.",both
"What is the total discount given for each product, and can you visualize it using a bar chart?","
import plotly.express as px

# SQL Query
sql_query = '''
SELECT ProductID, 
       SUM(UnitPrice * Quantity * Discount) AS TotalDiscount 
FROM [Order Details] 
GROUP BY ProductID;
'''

# Execute the SQL query and load the result into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalDiscount', title='Total Discount by Product')

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.Discount * od.UnitPrice * od.Quantity) AS Total_Discount
FROM 
    [Order Details] od
GROUP BY 
    od.ProductID
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductID', y='Total_Discount', 
             title='Total Discount Given for Each Product', 
             labels={'ProductID': 'Product ID', 'Total_Discount': 'Total Discount'})
show_to_user(fig)
```","The input code adheres to the same logic as the reference implementation. It calculates the total discount per product by summing the product of Discount, UnitPrice, and Quantity for each ProductID, the same as the reference code. Additionally, the visualization part is consistent, using Plotly to create a bar chart. Differences in wording, such as column aliases, do not impact the correctness of the solution.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total discount for each product
sql_query = """"""
SELECT 
    products.ProductID, 
    SUM([Order Details].Discount * [Order Details].Quantity * [Order Details].UnitPrice) AS TotalDiscount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total discount by product
fig = px.bar(
    df, 
    x='ProductID', 
    y='TotalDiscount', 
    title='Total Discount Given for Each Product',
    labels={'ProductID': 'Product ID', 'TotalDiscount': 'Total Discount'},
    template='plotly'
)

# Display the bar chart to the user
show_to_user(fig)
```","The provided input code fetches and visualizes the total discount for each product similarly to the reference code. Both codes execute SQL queries to sum the discounts grouped by ProductID. The difference in joining the 'products' table does not affect the outcome, as both queries essentially aggregate discounts by ProductID. The visualization with Plotly also aligns with the request. Hence, the input code is correct.",both
"How many products are currently discontinued, and can this information be displayed in a bar chart to highlight trends over time?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch discontinued products over time.
sql_query = """"""
SELECT YEAR(DiscontinueDate) AS Year, COUNT(*) AS DiscontinuedProducts
FROM products
WHERE Discontinued = 1
GROUP BY YEAR(DiscontinueDate)
ORDER BY YEAR(DiscontinueDate);
""""""

# Fetch data using the provided utility function
discontinued_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the trend of discontinued products over time
fig = px.bar(discontinued_data, x='Year', y='DiscontinuedProducts', title='Discontinued Products Over Time')

# Display the plot using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    COUNT(*) AS DiscontinuedCount
FROM 
    products
WHERE 
    Discontinued = 1
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

discontinued_products_df = execute_sql_query(sql_query)

fig = px.bar(discontinued_products_df, x='Month', y='DiscontinuedCount', 
             title='Number of Discontinued Products Over Time',
             labels={'DiscontinuedCount': 'Number of Discontinued Products', 'Month': 'Month'})
show_to_user(fig)
```","The input code queries for the count of discontinued products based on the 'OrderDate' instead of the 'DiscontinueDate', and it groups by month rather than year. The reference code groups by year and uses 'DiscontinueDate' for querying, which is crucial to meeting the business analytics request accurately.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return results in a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation is assumed to be provided elsewhere
    pass

# Function to show the analysis or visualization results
def show_to_user(data):
    # Implementation is assumed to be provided elsewhere
    pass

# SQL query to get the count of discontinued products by date
sql_query = """"""
SELECT COUNT(*) AS DiscontinuedCount, DiscontinuedDate
FROM products
WHERE Discontinued = 1
GROUP BY DiscontinuedDate
ORDER BY DiscontinuedDate;
""""""

# Execute the query
discontinued_df = execute_sql_query(sql_query)

# Validate the DataFrame
if discontinued_df is not None and not discontinued_df.empty:
    # Create a bar chart to visualize the discontinued products over time
    fig = px.bar(discontinued_df, x='DiscontinuedDate', y='DiscontinuedCount',
                 title='Discontinued Products Over Time',
                 labels={'DiscontinuedDate': 'Date', 'DiscontinuedCount': 'Number of Discontinued Products'})
    
    # Show the bar chart to the user
    show_to_user(fig)
else:
    print(""No data available for discontinued products."")
```","The input code groups discontinued products by the exact discontinuation date rather than by year, as in the reference code. This results in a different grouping logic and consequently a different visualization that does not meet the business analytics request or match the reference implementation's approach.",None
Calculate the lifetime value of each customer and create a visual representation to compare customer values effectively.,"```python
import pandas as pd
import plotly.express as px

# Assume this function executes an SQL query and returns a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation
    pass

# Assume this function displays data analysis or visualization results
def show_to_user(data):
    # Placeholder implementation
    pass

# SQL query to calculate the lifetime value of each customer
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
       (1 - [Order Details].Discount)) AS LifetimeValue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query to get the customer lifetime value data
customer_lifetime_value_df = execute_sql_query(sql_query)

# Create a bar chart to compare customer lifetime values
fig = px.bar(customer_lifetime_value_df, 
             x='CustomerID', 
             y='LifetimeValue', 
             title='Customer Lifetime Value Comparison', 
             labels={'LifetimeValue': 'Lifetime Value', 'CustomerID': 'Customer ID'})

# Use the utility function to display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS CustomerLifetimeValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID
""""""

customer_lifetime_values = execute_sql_query(sql_query)

fig = px.bar(customer_lifetime_values, 
              x='CustomerID', 
              y='CustomerLifetimeValue', 
              title='Customer Lifetime Value Comparison',
              labels={'CustomerID': 'Customer ID', 'CustomerLifetimeValue': 'Lifetime Value'})
show_to_user(fig)
```","The input code is functionally equivalent to the reference code. Both SQL queries perform the same operation, calculating the customer lifetime value by summing the product of UnitPrice, Quantity, and the discount factor for each customer's orders. They both group by CustomerID and use Plotly to create a bar chart with similar labels and titles. Variable names differ slightly, but the logic and outcome are identical.","```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to fetch Customer Lifetime Value
sql_query = """"""
SELECT 
    customers.CustomerID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * 
    (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID
""""""

# Step 2: Execute the SQL query using the utility function
customer_lifetime_df = execute_sql_query(sql_query)

# Step 3: Visualize the customer lifetime value
fig = px.bar(
    customer_lifetime_df,
    x='CustomerID',
    y='customer_lifetime_value',
    title='Customer Lifetime Value Comparison',
    labels={'customer_lifetime_value': 'Lifetime Value'},
    template='plotly'
)

# Step 4: Show the plot to the user
show_to_user(fig)
```","The input Python code correctly executes the SQL query to calculate the lifetime value of each customer, similar to the reference implementation. Even though the column alias for lifetime value ('customer_lifetime_value') differs slightly, it holds the same meaning and logic. The visualization uses plotly.express as a bar chart to effectively compare customer values, similar to the reference code. Therefore, the logic and outcome are consistent, making the code correct.",both
"What is the average discount given by each employee on their orders, and can this be visualized in a bar chart to compare discounts effectively?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, AVG(od.Discount) AS AverageDiscount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a full name column for better visualization
df['FullName'] = df['FirstName'] + ' ' + df['LastName']

# Create a bar chart using Plotly to visualize the average discount by employee
fig = px.bar(df, x='FullName', y='AverageDiscount',
             title='Average Discount by Employee',
             labels={'AverageDiscount': 'Average Discount (%)'},
             height=400)

# This assumes the existence of a function show_to_user that is defined somewhere in the codebase
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
       AVG(od.Discount) AS AverageDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY e.EmployeeID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='EmployeeName', y='AverageDiscount', 
             title='Average Discount Given by Each Employee', 
             labels={'AverageDiscount': 'Average Discount', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","Both code implementations correctly calculate the average discount given by each employee by executing a SQL query that joins the 'employees', 'orders', and 'Order Details' tables. They then group the results by employee details to compute the average discount. The queried data is visualized using a Plotly bar chart. Differences in string concatenation (using a SQL CONCAT function versus Python addition) do not alter the logic or outcome. Thus, the input code follows the same logic and fulfills the business requirement accurately.","```python
import plotly.express as px
import pandas as pd

# Utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for illustrative purposes
    # In practice, this would involve executing an SQL query against a database
    # For example: using pandas.read_sql_query with a given SQLAlchemy connection
    sql_gender_map = {'John': 'M', 'Jane': 'F'}
    data = {'EmployeeID': [1, 2], 'FirstName': ['John', 'Jane'],
            'AvgDiscount': [0.1, 0.15]}
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# SQL Query
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName,
AVG([Order Details].Discount) AS AvgDiscount
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID, employees.FirstName;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discount per employee
fig = px.bar(df, x='FirstName', y='AvgDiscount',
             title='Average Discount Given by Each Employee',
             labels={'AvgDiscount': 'Average Discount', 'FirstName': 'Employee'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code does not fully adhere to the business analytics request and reference implementation. The input query calculates the average discount per employee and uses only the FirstName for labels, while the reference uses both FirstName and LastName to create a full name. Additionally, the reference code uses both FirstName and LastName for grouping in the SQL query, which the input code does not do. This discrepancy can lead to inaccurate representation if multiple employees share the same first name. Lastly, the input code's plotting labels are not aligned with the reference code, which may affect interpretability.",Base
Identify the top-performing products based on sales and visualize the results using a bar chart.,"
```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ProductName, SUM(Quantity) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE products.Discontinued = 0 
GROUP BY ProductName 
ORDER BY TotalSales DESC 
LIMIT 10;
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductName', y='TotalSales', title='Top 10 Performing Products Based on Sales')

# Display the visualization
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 10;
""""""

top_products_df = execute_sql_query(sql_query)
fig = px.bar(top_products_df, x='ProductName', y='TotalSales', title='Top Performing Products Based on Sales')
show_to_user(fig)
```","The input code does not filter out discontinued products, as seen in the reference implementation. This could lead to incorrect identification of top-performing products if there are discontinued products with high sales. The query misses the condition `WHERE products.Discontinued = 0` to exclude such products.","```python
import plotly.express as px
import pandas as pd

# Business Analytic Request: Identify top-performing products based on sales and visualize them.

# Utility function to execute the SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration purposes
    # Replace this section with actual implementation to connect to the database and execute the query
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C', 'Product D', 'Product E'],
        'total_sales': [1000, 900, 800, 700, 600]
    }
    return pd.DataFrame(data)

# SQL query to retrieve top 5 products by sales
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS total_sales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY total_sales DESC
LIMIT 5;
""""""

# Execute the SQL query using the utility function
top_products_df = execute_sql_query(sql_query)

# Create a bar chart visualization using Plotly
fig = px.bar(top_products_df, x='ProductName', y='total_sales',
             title='Top 5 Performing Products by Sales',
             labels={'total_sales': 'Total Sales', 'ProductName': 'Product Name'})

# Display the visualization to the user
show_to_user(fig)
```","The evaluated code calculates total sales using `Quantity * UnitPrice`, whereas the reference calculates total sales using only `Quantity`. The evaluated code retrieves the top 5 products and considers all products (not filtering discontinued ones), while the reference retrieves the top 10 and excludes discontinued products.",None
"What is the variance in shipping costs for each month, and can this be visualized in a line chart?","```python
import pandas as pd
import plotly.express as px

# Business Analytic Request
# What is the variance in shipping costs for each month, and can this be visualized in a line chart?

# SQL query to retrieve the needed data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
       VARIANCE(Freight) AS FreightVariance 
FROM orders 
GROUP BY OrderMonth;
""""""

# Execute the SQL query to retrieve data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a line chart to visualize the variance in shipping costs for each month
fig = px.line(df, x='OrderMonth', y='FreightVariance', 
              title='Monthly Variance in Shipping Costs',
              labels={'OrderMonth': 'Order Month', 'FreightVariance': 'Freight Variance'})

# Display the line chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    VARIANCE(Freight) AS FreightVariance
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

freight_variance_df = execute_sql_query(sql_query)

fig = px.line(freight_variance_df, x='OrderMonth', y='FreightVariance', 
              title='Variance in Shipping Costs per Month',
              labels={'OrderMonth': 'Month', 'FreightVariance': 'Shipping Cost Variance'})
show_to_user(fig)
```","Both codes retrieve the monthly variance of shipping costs using the same SQL query logic, grouping by 'OrderMonth'. They also use Plotly to generate a line chart with equivalent configurations. Differences in label titles and order clauses do not impact correctness.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the variance of shipping costs for each month
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month, 
       VARIANCE(Freight) AS FreightVariance 
FROM orders 
GROUP BY EXTRACT(YEAR FROM OrderDate), 
         EXTRACT(MONTH FROM OrderDate);
""""""

# Execute the SQL query and fetch the results into a DataFrame
df = execute_sql_query(sql_query)

# Convert Year and Month to a single datetime for better plotting
df['Date'] = pd.to_datetime(df[['Year', 'Month']].assign(DAY=1))

# Sort the DataFrame by Date for proper plotting
df.sort_values(by='Date', inplace=True)

# Create a line chart using Plotly to visualize the variance in shipping costs per month
fig = px.line(df, x='Date', y='FreightVariance',
              title='Monthly Variance in Shipping Costs',
              labels={'FreightVariance': 'Variance', 'Date': 'Month'},
              markers=True)

# Display the line chart to the user
show_to_user(fig)
```","The input code and the reference implementation both calculate the monthly variance in shipping costs and visualize it using a line chart. The input code extracts year and month separately, combines them into a date object for accurate plotting, and sorts the DataFrame to ensure the line chart is organized by time. This matches the business analytics goal specified. Though the method is slightly different (using EXTRACT vs. DATE_FORMAT), the logic and outcome align with the reference code.",both
"What is the total freight cost for each shipping country, and can you provide a bar chart to illustrate the results?","```python
import plotly.express as px

# SQL query to retrieve the total freight cost for each shipping country
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY ShipCountry
""""""

# Execute the SQL query and get the results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to illustrate the total freight cost per shipping country
fig = px.bar(df, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Shipping Country')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipCountry
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Shipping Country')
show_to_user(fig)
```","The provided Python code correctly implements the business analytics request by querying the total freight cost per shipping country and creating a bar chart to illustrate the results. It follows the same logic as the reference implementation, using Plotly Express for visualization and executing the SQL query to retrieve the data.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the total freight cost per shipping country
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreightCost 
FROM orders 
GROUP BY ShipCountry
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to visualize total freight cost by shipping country
fig = px.bar(df, x='ShipCountry', y='TotalFreightCost', title='Total Freight Cost by Shipping Country')

# Display the visualization to the user
show_to_user(fig)
```","The provided Python code correctly addresses the business analytics request. It executes a SQL query to calculate the total freight cost per shipping country and uses Plotly to create a bar chart to illustrate the results. Although the alias for the total freight column is different ('TotalFreightCost' vs. 'TotalFreight'), the logic aligns with the reference implementation, and the visualization is correctly generated and displayed.",both
What is the month-by-month growth in total sales? Please include a line chart to visualize the trend.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to get the monthly sales data
sql_query = """"""
SELECT DATE_FORMAT(O.OrderDate, '%Y-%m') AS Month, 
SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TotalSales 
FROM orders O 
JOIN [Order Details] OD ON O.OrderID = OD.OrderID 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the query using the utility function
sales_data = execute_sql_query(sql_query)

# Calculate month-over-month growth
sales_data['Month'] = pd.to_datetime(sales_data['Month'], format='%Y-%m')
sales_data['Growth'] = sales_data['TotalSales'].pct_change() * 100  # Convert to percentage growth

# Line chart to visualize total sales trend
fig = px.line(sales_data, x='Month', y='TotalSales', title='Month-by-Month Total Sales Growth',
              labels={'TotalSales': 'Total Sales', 'Month': 'Month'})

# Show the figure
show_to_user(fig)

# Optionally, show the growth as well
show_to_user(sales_data[['Month', 'Growth']])
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY Month
ORDER BY Month;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='Month', y='TotalSales', title='Month-by-Month Growth in Total Sales', labels={'TotalSales': 'Total Sales', 'Month': 'Month'})
show_to_user(fig)
```","The provided input code lacks calculation of month-over-month growth. The reference code computes the percentage change in total sales from month to month and assigns it to a 'Growth' column, which the input code does not do. Consequently, the input code does not fully meet the requirements of the business analytics request as it omits the growth analysis component.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function: Assume this is implemented to execute the SQL query
    # and return the results as a pandas DataFrame
    pass

# Utility function to show results to the user
def show_to_user(data):
    # Mock function: Assume this is implemented to display pandas DataFrame
    # or Plotly figure
    pass

# SQL query to get month-by-month growth in total sales
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query and get the data in a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Calculate the month-by-month growth
sales_data['Growth'] = sales_data['MonthSales'].pct_change() * 100

# Fill NaN with 0% growth as the first month has no prior month to compare
sales_data['Growth'].fillna(0, inplace=True)

# Create a line chart to visualize the trend
fig = px.line(sales_data, x='Month', y='Growth', title='Monthly Growth in Total Sales (%)', labels={'Growth': 'Growth (%)'})

# Display the line chart to the user
show_to_user(fig)
```","The provided code calculates the percentage growth of sales month-over-month and creates a line chart of the growth percentages, while the reference code calculates the total sales and plots a line chart showing these total sales over time. The task was to visualize total sales over time, not the growth percentages.",None
"What is the total freight cost for shipped orders, and can you provide a line graph to show trends over time?","```python
import pandas as pd
import plotly.express as px

# Step 1: Define SQL query to get Freight Costs and Shipped Dates
sql_query = """"""
SELECT ShippedDate, SUM(Freight) AS TotalFreightCost
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY ShippedDate
ORDER BY ShippedDate;
""""""

# Step 2: Execute the SQL query and get the data in a pandas DataFrame
order_data = execute_sql_query(sql_query)

# Step 3: Create a line graph to show trends over time using Plotly
fig = px.line(order_data, x='ShippedDate', y='TotalFreightCost', 
              title='Total Freight Cost Over Time',
              labels={'ShippedDate': 'Date', 'TotalFreightCost': 'Total Freight Cost'},
              markers=True)

# Step 4: Display the line graph to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    SUM(Freight) AS TotalFreight
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

freight_data = execute_sql_query(sql_query)
fig = px.line(freight_data, x='Month', y='TotalFreight', title='Total Freight Cost for Shipped Orders Over Time')
show_to_user(fig)
```","The input code segments the freight costs by month using DATE_FORMAT, whereas the reference code groups by the exact ShippedDate. This changes the granularity of the data aggregation and affects the trend analysis. The input code does not align with the daily trend analysis requested per the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the total freight cost for shipped orders over time
query = """"""
SELECT DATE(ShippedDate) AS ShippedDate, SUM(Freight) AS TotalFreightCost
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY DATE(ShippedDate)
ORDER BY Date;
""""""

# Fetch the data using the utility function
orders_data = execute_sql_query(query)

# Check if the returned DataFrame is empty, and print a message if it is
if orders_data.empty:
    show_to_user(pd.DataFrame({""Message"": [""No shipped orders data available.""]}))
else:
    # Create a line graph of Total Freight Cost over time
    fig = px.line(orders_data, x='ShippedDate', y='TotalFreightCost', 
                  title='Total Freight Cost for Shipped Orders Over Time',
                  labels={'ShippedDate': 'Shipped Date', 'TotalFreightCost': 'Total Freight Cost'})

    # Show the graph to the user
    show_to_user(fig)
```","The input code correctly calculates the total freight cost for shipped orders over time and generates a line graph to show trends. Although the input code uses DATE() to group by date and includes a check for empty data, these differences do not affect the logic of summing and displaying freight costs over shipped dates, which aligns with the reference implementation.",Finetuned
How much revenue is generated from orders with more than 10 units and can it be visualized with a bar chart to show revenue distribution by product category?,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    p.Category AS ProductCategory, 
    SUM(od.UnitPrice * od.Quantity) AS Revenue 
FROM 
    [Order Details] od 
JOIN 
    Products p ON od.ProductID = p.ProductID 
WHERE 
    od.Quantity > 10 
GROUP BY 
    p.Category;
""""""

# Execute the query and get results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue distribution by product category
fig = px.bar(df, x='ProductCategory', y='Revenue', title='Revenue Distribution by Product Category for Orders with More Than 10 Units')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS Revenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Quantity > 10
GROUP BY p.CategoryID
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='CategoryID', y='Revenue', title='Revenue Distribution by Product Category')
show_to_user(fig)
```","The input code has differences from the reference implementation: it groups by 'CategoryID' instead of 'Category', which might lead to different results if 'CategoryID' does not map to distinct categories directly. Also, it applies a discount in the revenue calculation, which the reference does not consider.","```python
import pandas as pd
import plotly.express as px

# Execute SQL query to get revenue and product category
sql_query = """"""
SELECT SUM(od.UnitPrice * od.Quantity) AS Revenue, p.Category
FROM OrderDetails od
JOIN Products p ON od.ProductID = p.ProductID
WHERE od.Quantity > 10
GROUP BY p.Category;
""""""

# Use the utility function to fetch data from the database
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function body, replace with actual SQL execution logic
    # Return a sample DataFrame for illustration purposes
    data = {
        'Category': ['Category A', 'Category B', 'Category C'],
        'Revenue': [1000, 2000, 1500]
    }
    return pd.DataFrame(data)

# Get the data from the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the revenue by product category
fig = px.bar(df, x='Category', y='Revenue', title='Revenue Distribution by Product Category')

# Use the utility function to show the visualization
def show_to_user(data) -> None:
    # Dummy function body, replace with actual logic to display data
    if isinstance(data, px.Figure):
        data.show()
    else:
        print(data)

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates the revenue for orders with more than 10 units by joining the 'OrderDetails' and 'Products' tables and grouping the data by product category, which aligns with the reference implementation. It then visualizes the revenue distribution by product category using a bar chart with Plotly, consistent with the business analytics request and reference implementation. Despite differences in variable names and function placeholders, the logic and outcome are equivalent.",Finetuned
How many orders were shipped on time each month? Include a line graph to visualize the monthly on-time shipment trends.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, COUNT(OrderID) AS OnTimeOrders
FROM orders
WHERE ShippedDate <= RequiredDate
GROUP BY DATE_TRUNC('month', OrderDate);
""""""

# Execute the SQL query and fetch the result as a DataFrame
order_data_df = execute_sql_query(sql_query)

# Create a line plot using Plotly
fig = px.line(order_data_df, x='Month', y='OnTimeOrders', title='Monthly On-Time Orders',
              labels={'Month': 'Month', 'OnTimeOrders': 'Number of On-Time Orders'})

# Show the line graph to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(*) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeOrders
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

order_data = execute_sql_query(sql_query)

order_data['OnTimeRate'] = order_data['OnTimeOrders'] / order_data['TotalOrders']

fig = px.line(order_data, x='Month', y='OnTimeRate', title='Monthly On-time Shipment Trends', labels={'OnTimeRate': 'On-time Shipment Rate'})
show_to_user(fig)
```","The input code calculates the on-time shipment rate and plots the 'OnTimeRate' for each month, not the actual count of on-time orders. The business request and reference implementation focus on counting the on-time orders, not their rate, and plotting that count.","```python
import pandas as pd
import plotly.express as px

# Execute the provided SQL query to fetch the required data
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       COUNT(OrderID) AS OnTimeOrders 
FROM orders 
WHERE ShippedDate <= RequiredDate 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
'''

# Using the utility function to execute SQL query and obtain the result as a DataFrame
df = execute_sql_query(sql_query)

# Convert the 'Month' column to datetime for better plotting
df['Month'] = pd.to_datetime(df['Month'])

# Create a line graph to visualize the monthly on-time shipment trends
fig = px.line(df, x='Month', y='OnTimeOrders', title='Monthly On-Time Shipments')

# Display the visualization to the user
show_to_user(fig)
```","The input Python code correctly implements the requested analysis by calculating the number of on-time shipments per month and visualizing the trend with a line graph. The differences in SQL syntax are appropriate adjustments for the SQL dialect (DATE_FORMAT vs. DATE_TRUNC). The conversion of the 'Month' column to datetime for plotting is consistent with the reference implementation's logic, and the graph creation and display steps align with the reference code, making the input implementation correct.",Finetuned
"What is the variance in shipping costs across different regions, and can this be visualized using a box plot for each region?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the variance of shipping costs across different regions
sql_query = """"""
SELECT ShipRegion, VAR_SAMP(Freight) AS FreightVariance FROM orders GROUP BY ShipRegion;
""""""

# Execute the SQL query to fetch the data
df_variance = execute_sql_query(sql_query)

# SQL query to get the raw freight data for plotting purposes
sql_query_raw_freight = """"""
SELECT ShipRegion, Freight FROM orders;
""""""

# Execute the SQL query to fetch the raw freight data
df_raw_freight = execute_sql_query(sql_query_raw_freight)

# Generate the box plot using Plotly
fig = px.box(df_raw_freight, x='ShipRegion', y='Freight',
             title='Shipping Cost Variance by Region',
             labels={'Freight': 'Freight Cost', 'ShipRegion': 'Region'})

# Show the box plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, Freight
FROM orders
""""""
data = execute_sql_query(sql_query)

variance_data = data.groupby('ShipRegion')['Freight'].var().reset_index()
variance_data.columns = ['ShipRegion', 'Variance']

fig = px.box(data, x='ShipRegion', y='Freight', title='Shipping Cost Variance by Region')
show_to_user(fig)
```","The input code calculates the variance of shipping costs across different regions correctly by grouping the data and using the .var() method. It also visualizes the distribution of freight costs with a box plot, matching the intent of the reference implementation. Both approaches fetch freight data, compute variance per region, and visualize using a box plot, aligning with the specified analytic request.","```python
import pandas as pd
import plotly.express as px

# Mock function for executing the SQL query and returning a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation
    # Assuming proper database connection and execution for fetching data
    pass

# Mock function for showing results to the user
def show_to_user(data):
    # Placeholder implementation
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get variance in shipping costs per region
sql_query = """"""
SELECT ShipRegion, VARIANCE(Freight) AS VarianceFreight FROM orders GROUP BY ShipRegion;
""""""

# Execute the query and get the results in a DataFrame
df_variance = execute_sql_query(sql_query)

# Create a box plot using Plotly to visualize variance of shipping costs by region
fig = px.box(df_variance, x='ShipRegion', y='VarianceFreight', title='Variance in Shipping Costs by Region',
             labels={'VarianceFreight': 'Variance of Freight', 'ShipRegion': 'Region'})

# Show the visualization to the user
show_to_user(fig)
```","The input code incorrectly creates a box plot of the variance values themselves, rather than individual shipment costs. It fetches variance data directly from the SQL query, which is not suitable for box plots, as box plots require raw data to show distribution. The reference implementation correctly retrieves the raw freight data for plotting.",Base
"What percentage of orders have a shipping cost greater than $100? Additionally, provide a pie chart to visualize the distribution of orders by shipping cost threshold.","```python
import plotly.express as px
import pandas as pd

# Given SQL queries
percentage_query = """"""
SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders) AS Percentage 
FROM orders 
WHERE Freight > 100;
""""""

orders_distribution_query = """"""
SELECT 
    COUNT(CASE WHEN Freight > 100 THEN 1 END) AS Above_100,
    COUNT(CASE WHEN Freight <= 100 THEN 1 END) AS At_or_Below_100
FROM orders;
""""""

# Execute queries and retrieve data
percentage_df = execute_sql_query(percentage_query)
orders_distribution_df = execute_sql_query(orders_distribution_query)

# Display the percentage result
show_to_user(percentage_df)

# Prepare data for visualization
distribution_data = {
    ""Shipping Cost"": [""Above $100"", ""At or Below $100""],
    ""Count"": [orders_distribution_df.iloc[0]['Above_100'], orders_distribution_df.iloc[0]['At_or_Below_100']]
}

distribution_df = pd.DataFrame(distribution_data)

# Create pie chart
fig = px.pie(distribution_df, names='Shipping Cost', values='Count', title='Distribution of Orders by Shipping Cost')

# Show the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Freight
FROM orders
""""""
orders_df = execute_sql_query(sql_query)

total_orders = len(orders_df)
high_shipping_cost_orders = len(orders_df[orders_df['Freight'] > 100])
percentage_high_shipping_cost = (high_shipping_cost_orders / total_orders) * 100

shipping_cost_distribution = orders_df['Freight'].apply(lambda x: 'Greater than $100' if x > 100 else 'Less than or equal to $100')
distribution_counts = shipping_cost_distribution.value_counts()

fig = px.pie(names=distribution_counts.index, values=distribution_counts.values, title=""Shipping Cost Distribution"")
show_to_user(fig)

percentage_high_shipping_cost
```",The input code correctly calculates the percentage of orders with shipping costs greater than $100 using Python operations equivalent to the SQL in the reference. It also accurately creates a pie chart to visualize order distribution by shipping cost thresholds. Both the logic and output requirements align with the reference implementation.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders) AS expensive_percentage FROM orders WHERE Freight > 100;""

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation: In a real scenario, this function would connect to a database
    # and execute the provided SQL query.
    if ""Freight > 100"" in sql_query:
        # Simulated return value for this example, assume there are 20% expensive orders
        return pd.DataFrame({'expensive_percentage': [20]})
    return pd.DataFrame()


def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Fetch the result
result_df = execute_sql_query(sql_query)

# Calculate the percentage of orders with shipping cost greater than $100
percentage_above_100 = result_df['expensive_percentage'].iloc[0]

# Prepare data for visualization
data_for_pie_chart = pd.DataFrame({
    'Category': ['Above $100', 'Below $100'],
    'Count': [percentage_above_100, 100 - percentage_above_100]  # Assuming total is 100 for simplification
})

# Create a pie chart
fig = px.pie(data_for_pie_chart, values='Count', names='Category', title='Distribution of Orders by Shipping Cost Threshold')

# Show the percentage and pie chart
show_to_user(result_df)
show_to_user(fig)
```","The input code correctly calculates the percentage of orders with shipping costs greater than $100 using a SQL query. It then forms a pie chart to visualize the distribution of shipping costs above and below the $100 threshold. The logic corresponds to the reference implementation, providing correct percentage calculation and visual representation.",both
"What is the most common order quantity, and can a histogram be provided to visualize the distribution of order quantities?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od.Quantity, COUNT(od.Quantity) AS Frequency 
FROM [Order Details] od 
GROUP BY od.Quantity;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
order_data = execute_sql_query(sql_query)

# Determine the most common order quantity
most_common_quantity = order_data.loc[order_data['Frequency'].idxmax()]

# Print the most common order quantity
print(""Most common order quantity:"", most_common_quantity['Quantity'])

# Create a histogram to visualize the distribution of order quantities
fig = px.histogram(order_data, x='Quantity', y='Frequency', 
                   title='Distribution of Order Quantities')

# Display the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.Quantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
""""""

order_data = execute_sql_query(sql_query)

most_common_order_quantity = order_data['Quantity'].mode()[0]

fig = px.histogram(order_data, x='Quantity', title='Distribution of Order Quantities', 
                   labels={'Quantity': 'Order Quantity'})

show_to_user(fig)

most_common_order_quantity
```","The input code does not adhere to the same logic as the reference implementation. The reference code groups by 'Quantity' and counts the frequency, allowing the determination of the most common quantity using count. The input code simply uses 'mode()' to find the most frequent quantity without calculating frequencies from a grouped result. Additionally, the SQL query in the input code includes a JOIN that isn't present in the reference query, which might alter the data being analyzed.","```python
import pandas as pd
import plotly.express as px

# Given the utility functions
def execute_sql_query(sql_query: str):
    # Dummy function to simulate execution of SQL query
    # This would normally interface with your SQL database
    # Returns a DataFrame with historical order quantities
    return pd.DataFrame({'Quantity': [5]*25 + [10]*15 + [15]*10})

def show_to_user(data):
    # Dummy function to simulate displaying data
    # If the data type is a DataFrame, print it; if it's a Plotly figure, show it
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to find the most common order quantity
sql_query = """"""
SELECT od.Quantity, COUNT(*) AS Frequency 
FROM [Order Details] od 
GROUP BY od.Quantity 
ORDER BY Frequency DESC 
LIMIT 1;
""""""

# Execute SQL query to get order quantities
order_quantities_df = execute_sql_query(""SELECT od.Quantity FROM [Order Details] od;"")
order_quantity_counts = order_quantities_df['Quantity'].value_counts().reset_index()
order_quantity_counts.columns = ['Quantity', 'Frequency']

# Find the most common order quantity
most_common_quantity_df = execute_sql_query(sql_query)

# Display the most common order quantity
show_to_user(most_common_quantity_df)

# Create a histogram to visualize the distribution of order quantities
fig = px.histogram(order_quantities_df, x='Quantity', title='Distribution of Order Quantities')

# Show the histogram
show_to_user(fig)
```","The input code correctly determines the most common order quantity by using a SQL query to retrieve quantities and calculate their frequencies. It finds the most common order quantity using SQL with an ORDER BY and LIMIT clause, similar to the reference implementation that uses pandas to determine the most frequent quantity. The input code also uses Plotly to create a histogram of order quantities, matching the requirement for visualization. The logic and output are consistent with the reference code, despite differences in implementation details.",Finetuned
"What are the top-selling products based on total sales in the last month, and can we visualize this data using a bar chart?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Function to execute SQL query and return the result as pandas DataFrame
    # Dummy implementation for illustration
    # Replace with actual database connection logic
    pass

def show_to_user(data):
    # Function to display data analysis or visualization results
    pass

# SQL Query to get the top-selling products of the last month
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE MONTH(OrderDate) = MONTH(CURRENT_DATE) - 1 AND YEAR(OrderDate) = YEAR(CURRENT_DATE)
GROUP BY od.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 5;
""""""

# Execute the SQL query
top_selling_df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
if top_selling_df is not None and not top_selling_df.empty:
    fig = px.bar(
        top_selling_df,
        x='ProductName',
        y='TotalSales',
        title='Top 5 Selling Products in the Last Month',
        labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'}
    )
    show_to_user(fig)
else:
    print(""No data available for the given period."")
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last month
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# SQL query to get total sales by product in the last month
sql_query = f""""""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID FROM Orders WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
)
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 10;
""""""

# Execute the SQL query and retrieve the data
top_selling_products = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(top_selling_products, x='ProductName', y='TotalSales', title='Top-Selling Products in the Last Month', labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code calculates the date range for the last 30 days instead of using the logic for the previous calendar month. This can lead to discrepancies if run on different days of the month. Additionally, it uses `LIMIT 10`, which is not aligned with `LIMIT 5` in the reference code. The input code includes a discount calculation that is not present in the reference. Therefore, the logic differs from the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the top-selling products based on total sales in the last month
sql_query = """"""
SELECT [Order Details].ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE EXTRACT(YEAR FROM orders.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
AND EXTRACT(MONTH FROM orders.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE) - 1 
GROUP BY [Order Details].ProductID
ORDER BY TotalSales DESC
""""""

# Execute SQL query to get data
top_selling_products_df = execute_sql_query(sql_query)

# Visualize the data using a bar chart with Plotly
fig = px.bar(top_selling_products_df, 
             x='ProductID', 
             y='TotalSales', 
             title='Top-Selling Products Based on Total Sales in Last Month',
             labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales'},
             height=400)

# Show the visualization to the user
show_to_user(fig)
```","The input code fetches data related to ProductID instead of ProductName, omitting the JOIN with the products table needed for product names. Furthermore, it does not use the LIMIT clause to restrict to the top 5 products as required by the business request.",None
"Find the product with the most significant percentage sales growth month-over-month, and visualize the growth trend with a line chart.","import pandas as pd
import plotly.express as px


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing SQL query and returning as DataFrame
    # This should be replaced with actual database interaction code
    pass


def show_to_user(data):
    # Displaying data or visualization to user
    pass

# SQL Query to find the product with the most significant percentage sales growth
sql_query = """"""
SELECT p.ProductID, 
       ((SUM(CASE WHEN EXTRACT(MONTH FROM od.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE) THEN od.Quantity ELSE 0 END) - 
         SUM(CASE WHEN EXTRACT(MONTH FROM od.OrderDate) = EXTRACT(MONTH FROM DATE_ADD('month', -1, CURRENT_DATE)) THEN od.Quantity ELSE 0 END)) / 
       NULLIF(SUM(CASE WHEN EXTRACT(MONTH FROM od.OrderDate) = EXTRACT(MONTH FROM DATE_ADD('month', -1, CURRENT_DATE)) THEN od.Quantity ELSE 0 END), 0)) * 100 AS SalesGrowth 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductID 
ORDER BY SalesGrowth DESC 
LIMIT 1;
""""""

# Execute the query to retrieve data
sales_growth_data = execute_sql_query(sql_query)

# Visualize the growth trend for the top product
if sales_growth_data is not None and not sales_growth_data.empty:
    product_id = sales_growth_data.iloc[0]['ProductID']

    # SQL Query to get monthly sales data for the specific product
    trend_query = f""""""
    SELECT EXTRACT(MONTH FROM od.OrderDate) AS Month, SUM(od.Quantity) AS TotalQuantity
    FROM [Order Details] od
    WHERE od.ProductID = {product_id}
    GROUP BY EXTRACT(MONTH FROM od.OrderDate)
    ORDER BY Month;
    """"""

    # Execute the query to retrieve trend data
    trend_data = execute_sql_query(trend_query)

    # Create a line chart to visualize the growth trend
    if trend_data is not None and not trend_data.empty:
        fig = px.line(trend_data, x='Month', y='TotalQuantity', title=f'Growth Trend for Product ID {product_id}', 
                      labels={'TotalQuantity': 'Total Quantity Sold', 'Month': 'Month'}, markers=True)

        # Show visualization
        show_to_user(fig)
    else:
        print(""No trend data available for visualization."")
else:
    print(""No data available for visualization."")","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_TRUNC('month', o.OrderDate) AS SaleMonth,
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, p.ProductName, SaleMonth
ORDER BY 
    SaleMonth
""""""

sales_data = execute_sql_query(sql_query)

sales_data['TotalSales'] = sales_data['TotalSales'].astype(float)

monthly_growth = sales_data.groupby(['ProductID', 'ProductName'])\
    .apply(lambda x: x.set_index('SaleMonth').TotalSales.pct_change())\
    .reset_index(name='GrowthRate')

max_growth_product = monthly_growth.loc[monthly_growth['GrowthRate'].idxmax()]

growth_trend = monthly_growth[monthly_growth['ProductID'] == max_growth_product['ProductID']]

fig = px.line(growth_trend, x='SaleMonth', y='GrowthRate', title=f'Growth Trend for {max_growth_product[""ProductName""]}')
show_to_user(fig)
```","The input code calculates percentage sales growth for all products using pandas and identifies the product with the maximum growth across all months. The reference uses SQL to find the product with the maximum growth only between the current and previous month and visualizes its trend. Thus, the logic and approach differ from the reference.","```python
import pandas as pd
import plotly.express as px

# Utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is supposed to execute the SQL query and return the results as a pandas DataFrame.
    # Replace with actual implementation.
    pass

def show_to_user(data):
    # Displays data or visualizations. 
    # Replace with actual implementation.
    pass


# SQL Query to get month-over-month sales growth for all products
sql_query = """"""
SELECT products.ProductID, 
       MONTH(OrderDate) AS Month, 
       YEAR(OrderDate) AS Year, 
       100 * (SUM(od.Quantity * od.UnitPrice) - LAG(SUM(od.Quantity * od.UnitPrice)) OVER (PARTITION BY products.ProductID ORDER BY YEAR(OrderDate), 
       MONTH(OrderDate))) / NULLIF(LAG(SUM(od.Quantity * od.UnitPrice)) OVER (PARTITION BY products.ProductID ORDER BY YEAR(OrderDate), 
       MONTH(OrderDate)), 0) AS SalesGrowth 
FROM [Order Details] od 
JOIN products ON od.ProductID = products.ProductID 
GROUP BY products.ProductID, YEAR(OrderDate), MONTH(OrderDate) 
ORDER BY SalesGrowth DESC;
""""""

# Execute the SQL query and get the DataFrame
sales_growth_df = execute_sql_query(sql_query)

# Find the product with the most significant percentage sales growth
max_growth_product = sales_growth_df.iloc[0]

# Filter data for the product with the most significant sales growth
product_id = max_growth_product['ProductID']
filtered_df = sales_growth_df[sales_growth_df['ProductID'] == product_id]

# Create a line chart to visualize the sales growth trend
fig = px.line(filtered_df, x='Month', y='SalesGrowth', title=f'Sales Growth Trend for Product {product_id}')

# Display the line chart
show_to_user(fig)
```","The provided code calculates sales growth based on revenue (Quantity * UnitPrice) month-over-month, while the reference implementation focuses on sales growth in terms of quantity. Additionally, the provided code uses analytical functions (LAG) and addresses a broader set of all products rather than identifying the product with the maximum growth first. Also, the visualization part is based on 'SalesGrowth' instead of 'TotalQuantity'. These differences lead to a deviation from the intended logic of the reference code.",None
"What is the average number of orders processed per employee each month, and how can this be visualized to show trends over time?","
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for illustration purposes
    # You'll need to replace this with your actual database connection logic
    # The SQL execution should return a pandas DataFrame
    return pd.read_sql(sql_query, con=your_database_connection)

def show_to_user(data):
    # Dummy implementation for illustration purposes
    # This would be where you'd display the plot or DataFrame to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query based on the given input
sql_query = """"""
SELECT employees.EmployeeID, 
       COUNT(orders.OrderID) / COUNT(DISTINCT DATE_FORMAT(orders.OrderDate, '%Y-%m')) AS AvgOrdersPerMonth 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID;
""""""

# Fetch data using the defined utility function
data = execute_sql_query(sql_query)

# Visualizing the data to show trends over time
# Assuming we need a time series visualization of average orders per month per employee
fig = px.bar(data, x='EmployeeID', y='AvgOrdersPerMonth', 
              title='Average Number of Orders Processed Per Employee',
              labels={'AvgOrdersPerMonth': 'Average Orders Per Month', 'EmployeeID': 'Employee ID'})

# Using the utility function to show visualization to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    COUNT(DISTINCT EmployeeID) AS TotalEmployees
FROM 
    orders
GROUP BY 
    Month
""""""

orders_per_month = execute_sql_query(sql_query)

orders_per_month['AverageOrdersPerEmployee'] = orders_per_month['TotalOrders'] / orders_per_month['TotalEmployees']

fig = px.line(orders_per_month, x='Month', y='AverageOrdersPerEmployee', title='Average Number of Orders Processed per Employee Each Month')
show_to_user(fig)
```","The input Python code calculates the average number of orders processed per employee each month, but it does it differently than the reference implementation. The reference code calculates a historical average of orders per month for each employee, while the input code calculates the average across all employees per month. Additionally, the reference implementation is focused on producing a bar chart per employee, whereas the input code visualizes the results as a line chart over time. These differences in logic and visualization purpose lead to different interpretations of the business request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve the average number of orders processed per employee each month
sql_query = """"""
SELECT EXTRACT(YEAR FROM orders.OrderDate) AS Year,
       EXTRACT(MONTH FROM orders.OrderDate) AS Month,
       AVG(orders_per_employee.EmployeeOrders) AS AvgOrders
FROM (SELECT e.EmployeeID, 
             COUNT(o.OrderID) AS EmployeeOrders, 
             EXTRACT(YEAR FROM o.OrderDate) AS OrderYear, 
             EXTRACT(MONTH FROM o.OrderDate) AS OrderMonth 
      FROM employees e 
      JOIN orders o ON e.EmployeeID = o.EmployeeID 
      GROUP BY e.EmployeeID, EXTRACT(YEAR FROM o.OrderDate), EXTRACT(MONTH FROM o.OrderDate)) AS orders_per_employee 
GROUP BY Year, Month;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Here, normally you would connect to your database and execute the query
    # For example purposes, returning a dummy DataFrame
    data = {
        'Year': [2023, 2023],
        'Month': [1, 2],
        'AvgOrders': [15.0, 14.5]
    }
    return pd.DataFrame(data)

# Execute the SQL query and get the results in a DataFrame
avg_orders_df = execute_sql_query(sql_query)

# Combine Year and Month into a single datetime column for better plotting
avg_orders_df['Date'] = pd.to_datetime(avg_orders_df[['Year', 'Month']].assign(DAY=1))

# Plot the data using Plotly
fig = px.line(avg_orders_df, x='Date', y='AvgOrders', title='Average Orders Processed per Employee Each Month',
              labels={'AvgOrders': 'Average Orders', 'Date': 'Date'})

# Show the plot to the user
show_to_user(fig)
```","The input code calculates the average orders per employee per month across all employees, rather than for each individual employee as in the reference implementation. The visualization also differs; the input code uses a line plot to show trends over time for an overall average, whereas the reference uses a bar chart per employee.",None
"What is the average fulfillment time for orders in Q1 2023? Additionally, include a timeline chart showing the trend of fulfillment times throughout the quarter.","import pandas as pd
import plotly.express as px

# SQL query to calculate the average fulfillment time
sql_query = """"""
SELECT orders.OrderDate, DATEDIFF(orders.ShippedDate, orders.OrderDate) AS fulfillment_time
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Calculate the average fulfillment time for Q1 2023
avg_fulfillment_time = orders_df['fulfillment_time'].mean()

# Print the average fulfillment time
print(f""The average fulfillment time for orders in Q1 2023 is {avg_fulfillment_time:.2f} days."")

# Generate a timeline chart to show the trend of fulfillment times
timeline_chart = px.line(
    orders_df,
    x='OrderDate',
    y='fulfillment_time',
    title='Trend of Fulfillment Times Q1 2023',
    labels={'fulfillment_time': 'Fulfillment Time (days)', 'OrderDate': 'Order Date'}
)

# Show the timeline chart
show_to_user(timeline_chart)","```python
import pandas as pd
import plotly.express as px

# SQL query to get average fulfillment time for orders in Q1 2023
sql_query_avg_fulfillment = """"""
SELECT AVG(DATEDIFF(ShippedDate, OrderDate)) AS average_fulfillment_time 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""
average_fulfillment = execute_sql_query(sql_query_avg_fulfillment)

# SQL query to get daily fulfillment times for Q1 2023 for trend
sql_query_trend = """"""
SELECT DATE(ShippedDate) AS fulfillment_date, AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY fulfillment_date
ORDER BY fulfillment_date
""""""
trend_data = execute_sql_query(sql_query_trend)

# Generate timeline chart
fig = px.line(trend_data, x='fulfillment_date', y='avg_fulfillment_time', title='Average Fulfillment Time Trend (Q1 2023)')
show_to_user(fig)
```","The input code misses the specific calculation and display of the overall average fulfillment time for Q1 2023. Instead, it calculates the average for each shipment date and uses it for the trend chart. The reference implementation directly calculates and prints the average fulfillment time for the entire quarter and then plots the daily trend. The input code splits the SQL logic into two parts and doesn't capture the overall average before plotting.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average fulfillment time and the timeline of fulfillment times for Q1 2023
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS fulfillment_time, 
       OrderDate 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31';
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate the average fulfillment time
avg_fulfillment_time = orders_df['fulfillment_time'].mean()

# Prepare the result as a DataFrame for showing
result_df = pd.DataFrame({'AvgFulfillmentTime': [avg_fulfillment_time]})

# Show the average fulfillment time
show_to_user(result_df)

# Create a timeline chart to show the trend of fulfillment times
fig = px.line(orders_df, x='OrderDate', y='fulfillment_time', 
              title='Fulfillment Time Trend - Q1 2023',
              labels={'fulfillment_time': 'Fulfillment Time (days)', 'OrderDate': 'Order Date'})

# Show the timeline chart
show_to_user(fig)
```","The input code correctly calculates the average fulfillment time and generates a trend chart for Q1 2023. The SQL query, average calculation, and Plotly line chart creation align logically with the reference implementation. The difference in how the average result is displayed (using a DataFrame versus a print statement) is a stylistic change, not affecting correctness.",Finetuned
"Which products are most frequently ordered together, and can you provide a visualization such as a heatmap to illustrate the associations?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od1.ProductID, od2.ProductID, COUNT(*) AS OrderedTogetherCount 
FROM [Order Details] od1 
JOIN [Order Details] od2 
ON od1.OrderID = od2.OrderID AND od1.ProductID < od2.ProductID 
GROUP BY od1.ProductID, od2.ProductID 
ORDER BY OrderedTogetherCount DESC;
""""""

# Execute the SQL query
order_together_df = execute_sql_query(sql_query)

# Pivot the DataFrame to create a matrix suitable for a heatmap
heatmap_data = order_together_df.pivot(index='ProductID_x', columns='ProductID_y', values='OrderedTogetherCount').fillna(0)

# Plot the heatmap using Plotly
fig = px.imshow(heatmap_data, 
                labels=dict(x=""ProductID"", y=""ProductID"", color=""Ordered Together Count""), 
                x=heatmap_data.columns, 
                y=heatmap_data.index, 
                zmin=0,
                zmax=heatmap_data.values.max())

# Customize the heatmap for better readability
fig.update_layout(title=""Heatmap of Products Ordered Together"",
                  xaxis_title=""Product ID"",
                  yaxis_title=""Product ID"")

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
import numpy as np

sql_query = """"""
SELECT od1.ProductID AS Product1, od2.ProductID AS Product2, COUNT(*) AS Frequency
FROM [Order Details] od1
JOIN [Order Details] od2 ON od1.OrderID = od2.OrderID AND od1.ProductID < od2.ProductID
GROUP BY od1.ProductID, od2.ProductID
ORDER BY Frequency DESC
LIMIT 20;
""""""

product_pairs = execute_sql_query(sql_query)

heatmap_data = pd.pivot_table(product_pairs, values='Frequency', index='Product1', columns='Product2', fill_value=0)

fig = px.imshow(heatmap_data, 
                labels=dict(x=""Product 2"", y=""Product 1"", color=""Frequency""),
                x=heatmap_data.columns,
                y=heatmap_data.index,
                title=""Product Pair Frequency Heatmap"",
                color_continuous_scale='Viridis')

show_to_user(fig)
```","The input Python code evaluates the same business analytics request as the reference implementation by identifying products frequently ordered together using a SQL query. It then visualizes these associations using a heatmap via Plotly. It follows the same logic: conducting a self-join on the [Order Details] table to find product pairs ordered together, aggregating the count, and creating a heatmap. Minor differences such as column labels and color scale do not affect correctness.","import pandas as pd
import plotly.express as px
from scipy.sparse import csr_matrix
from sklearn.metrics.pairwise import cosine_similarity

# Business logic function
def get_frequent_combinations():
    # SQL query to retrieve the data of interest
    sql_query = """"""
    SELECT od1.ProductID AS Product_1, od2.ProductID AS Product_2, COUNT(*) AS Order_Count
    FROM [Order Details] od1
    JOIN [Order Details] od2
    ON od1.OrderID = od2.OrderID AND od1.ProductID <> od2.ProductID
    GROUP BY od1.ProductID, od2.ProductID
    """"""
    
    # Execute the SQL query to get the data
    df = execute_sql_query(sql_query)

    # Creating a pivot table to represent product associations
    pivot_table = df.pivot_table(index='Product_1', columns='Product_2', values='Order_Count', fill_value=0)

    # Calculate cosine similarity
    csr_pivot = csr_matrix(pivot_table.values)
    cosine_sim = cosine_similarity(csr_pivot)
    
    # Create a DataFrame for similarity to plot
    similarities = pd.DataFrame(cosine_sim, index=pivot_table.index, columns=pivot_table.columns)
    
    # Generate a heatmap using Plotly
    fig = px.imshow(similarities, 
                    labels=dict(x=""Products"", y=""Products"", color=""Similarity""),
                    x=similarities.columns,
                    y=similarities.index,
                    color_continuous_scale='Viridis',
                    title='Product Association Heatmap')
    
    # Display the heatmap
    show_to_user(fig)

# Call the function to execute
get_frequent_combinations()
","The input code calculates cosine similarity between product order counts, which does not directly represent 'most frequently ordered together' as required. It deviates from the reference, which counts co-occurrences of products in the same orders. The reference creates a pivot table directly based on these counts and uses that data for the heatmap. The input inaccurately abstracts the associations with cosine similarity, thus not adhering to the original business request.",Base
Find the average order quantity per product and create a bar chart to visualize the results.,"```python
import plotly.express as px
import pandas as pd

# Assume execute_sql_query is already implemented and returns a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation not shown
    pass

def show_to_user(data):
    # Implementation not shown; accepts a DataFrame or Plotly figure
    pass

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, AVG(od.Quantity) AS AverageQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query and obtain a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='AverageQuantity', title='Average Order Quantity per Product')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

data = execute_sql_query(sql_query)

data['AverageQuantity'] = data['TotalQuantity'] / data['TotalQuantity'].count()

fig = px.bar(data, x='ProductName', y='AverageQuantity', title='Average Order Quantity per Product')
show_to_user(fig)
```","The input code calculates 'AverageQuantity' incorrectly. It divides 'TotalQuantity' by the count of total quantities instead of calculating the average of order quantities for each product. This differs from the logic used in the reference code, which properly uses AVG(od.Quantity) in the SQL query to find the average per product.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT ProductID, AVG(Quantity) as AvgQuantity 
FROM [Order Details] 
GROUP BY ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='AvgQuantity', title='Average Order Quantity per Product')

# Display the visualization
show_to_user(fig)
```","The input code calculates the average order quantity per ProductID instead of per ProductName as required. The reference code joins the products and order details tables to get the ProductName for each ProductID before calculating the average. The input code omits this join and computes the average solely based on ProductID, which doesn't fulfill the business request to visualize averages per product by name.",None
Which recipient received the highest number of shipments? Include a bar chart to visualize the number of shipments per recipient.,"```python
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT ShipName, COUNT(OrderID) AS NumShipments 
FROM orders 
GROUP BY ShipName 
ORDER BY NumShipments DESC;
""""""

# Execute the query and get the data as a DataFrame
shipments_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of shipments per recipient
fig = px.bar(
    shipments_df, 
    x='ShipName', 
    y='NumShipments', 
    title=f'Number of Shipments per Recipient',
    labels={'ShipName': 'Recipient', 'NumShipments': 'Number of Shipments'},
    text='NumShipments'
)

# Update the layout for better readability
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')

# Show analysis to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipName, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipName
ORDER BY ShipmentCount DESC
LIMIT 1;
""""""

highest_recipient_df = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT ShipName, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipName;
""""""

all_shipments_df = execute_sql_query(sql_query_all)

fig = px.bar(all_shipments_df, x='ShipName', y='ShipmentCount',
             title='Number of Shipments per Recipient',
             labels={'ShipName': 'Recipient Name', 'ShipmentCount': 'Number of Shipments'})

show_to_user(fig)

highest_recipient_df
```","The provided code correctly answers the business analytics request. It identifies the recipient who received the highest number of shipments using a SQL query with a limit of 1, and it generates a bar chart with the number of shipments per recipient using Plotly. While the logic uses two separate queries, one for all shipments and one for the top recipient, it still adheres to the requirement of visualizing shipments per recipient and identifying the recipient with the most shipments. Therefore, it aligns with the intended analysis.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of shipments per recipient
sql_query = '''
SELECT o.ShipVia, COUNT(o.OrderID) AS num_shipments 
FROM orders o 
GROUP BY o.ShipVia 
ORDER BY num_shipments DESC;
'''

# Execute the SQL query to get the data
df_shipments = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of shipments per recipient
fig = px.bar(df_shipments, x='ShipVia', y='num_shipments', 
             title='Number of Shipments per Recipient',
             labels={'ShipVia': 'Recipient', 'num_shipments': 'Number of Shipments'})

# Display the bar chart
show_to_user(fig)
```","The input code uses a different grouping field 'ShipVia' instead of 'ShipName' to count shipments, which alters the logic of identifying the recipient as per the requirement. Therefore, it does not answer the question correctly compared to the reference implementation.",Base
"What is the distribution of order quantities for each employee over the last three months, and can you provide a visual representation of this distribution?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT e.FirstName, e.LastName, od.Quantity 
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
ORDER BY e.FirstName, e.LastName;
""""""

# Execute the SQL query and get the DataFrame
data = execute_sql_query(sql_query)

# Display the raw data (if needed for debugging or validation)
show_to_user(data)

# Create a new column for full name
data['FullName'] = data['FirstName'] + ' ' + data['LastName']

# Create a Plotly box plot to represent the distribution
fig = px.box(
    data, 
    x='FullName', 
    y='Quantity', 
    title='Distribution of Order Quantities for Each Employee Over the Last Three Months',
    labels={'FullName': 'Employee', 'Quantity': 'Order Quantity'},
    notched=True
)

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

three_months_ago = datetime.now() - timedelta(days=90)
three_months_ago_str = three_months_ago.strftime('%Y-%m-%d')

sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= '{three_months_ago_str}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

data = execute_sql_query(sql_query)

fig = px.histogram(data, x='TotalQuantity', color='LastName', barmode='overlay',
                   title='Distribution of Order Quantities for Each Employee over the Last Three Months',
                   labels={'TotalQuantity': 'Order Quantity', 'LastName': 'Employee'})
show_to_user(fig)
```","The input code calculates the total order quantity per employee (using SUM and GROUP BY) instead of showing the distribution of individual order quantities. The reference implementation uses a box plot to show distribution per employee, while the input uses a histogram with total quantities, which doesn't match the requested analytics requirement.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.FirstName, employees.LastName, 
       SUM([Order Details].Quantity) AS TotalQuantity 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 3 MONTH) AND CURDATE() 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar plot for the distribution of order quantities per employee
fig = px.bar(df, x='FirstName', y='TotalQuantity', 
             title='Distribution of Order Quantities per Employee Over the Last 3 Months',
             labels={'TotalQuantity': 'Total Order Quantity'},
             hover_data=['LastName'])

# Show the plot
show_to_user(fig)
```","The input code calculates the total quantity for each employee using a GROUP BY SQL statement and visualizes this with a bar plot. The reference code uses individual order quantities and displays a box plot to show the distribution for each employee. The logic and visual representation differ significantly: reference code visualizes order quantity distribution using a box plot, while the input code aggregates quantities and uses a bar plot.",None
"Which products have an inventory turnover ratio below the average, and can a bar chart visualize these ratios compared to the average?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch relevant data
sql_query = """"""
SELECT ProductName, TurnoverRatio FROM (
    SELECT p.ProductName, 
           SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS TurnoverRatio
    FROM [Order Details] od
    JOIN products p ON od.ProductID = p.ProductID
    GROUP BY p.ProductName
) AS Turnover
WHERE TurnoverRatio < (
    SELECT AVG(TurnoverRatio) FROM (
        SELECT SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS TurnoverRatio
        FROM [Order Details] od
        JOIN products p ON od.ProductID = p.ProductID
        GROUP BY p.ProductID
    ) AS AvgTurnover
);
""""""

# Execute the SQL query and get the results as a pandas DataFrame
def execute_sql_query(sql_query):
    # This is a placeholder function. Replace it with actual database execution code.
    return pd.DataFrame()

turnover_df = execute_sql_query(sql_query)

# Calculate the average turnover ratio for visualization
avg_turnover_ratio = turnover_df['TurnoverRatio'].mean()

# Create a bar chart using Plotly
fig = px.bar(turnover_df, x='ProductName', y='TurnoverRatio',
             title='Products with Turnover Ratio Below Average',
             labels={'TurnoverRatio': 'Turnover Ratio'},
             template='plotly')

# Add a line for the average turnover ratio
fig.add_hline(y=avg_turnover_ratio, line_dash=""dash"", line_color=""red"", 
              annotation_text=""Average Turnover Ratio"", annotation_position=""bottom right"")

# Show the visualization to the user
def show_to_user(data):
    # This is a placeholder function. Replace it with actual display code.
    pass

show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

inventory_data = execute_sql_query(sql_query)

average_ratio = inventory_data['InventoryTurnoverRatio'].mean()
below_average_products = inventory_data[inventory_data['InventoryTurnoverRatio'] < average_ratio]

fig = px.bar(below_average_products, 
             x='ProductName', 
             y='InventoryTurnoverRatio', 
             title='Products with Inventory Turnover Ratio Below Average',
             labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

show_to_user(fig)
```","The provided code correctly calculates products with inventory turnover ratios below the average. It uses SQL to calculate the turnover ratio and filters products accordingly. The visualization with Plotly is also consistent with the reference, showing a bar chart of products with below-average turnover ratios.","```python
import pandas as pd
import plotly.express as px

# Assuming required functions are already defined:
# execute_sql_query: function to execute SQL query and return a DataFrame
# show_to_user: function to display the output

# SQL query to find products with inventory turnover below the average
sql_query = """"""
SELECT p.ProductID, p.ProductName, 
SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) as InventoryTurnover
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
HAVING SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) < 
(
    SELECT AVG(InventoryTurnover)
    FROM (
        SELECT SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p2.UnitsInStock), 0) as InventoryTurnover
        FROM products p2
        JOIN [Order Details] od ON p2.ProductID = od.ProductID
        GROUP BY p2.ProductID
    ) AS Subquery
);
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Bar chart visualization of Inventory Turnover ratios
fig = px.bar(df, x='ProductName', y='InventoryTurnover', 
             title='Products with Inventory Turnover Ratio Below Average',
             labels={'InventoryTurnover': 'Inventory Turnover Ratio'})

# Show the bar chart
show_to_user(fig)
```","The input code assumes the use of NULLIF to handle potential division by zero in the calculation of the InventoryTurnover ratio, which addresses a corner case. However, the main issue with the input code is that it directly calculates and compares turnover values in the HAVING clause without separately computing the average and filtering product records. Moreover, the visualization lacks the addition of an average turnover line, unlike the reference implementation, which uses add_hline to draw a line for the average turnover. Therefore, the input code doesn't fully replicate the logic and results of the reference implementation.",Base
"How many active products have stock quantities between their reorder level and maximum, and can this be visualized with a bar chart or histogram?","```python
import pandas as pd
import plotly.express as px

# Assuming the function execute_sql_query is already defined in the environment 

# SQL Query to get active products with stock between reorder level and maximum
sql_query = """"""
SELECT ProductID 
FROM products 
WHERE UnitsInStock > ReorderLevel AND UnitsInStock < MaxStockLevel AND Discontinued = 0;
""""""

# Execute SQL query and get the results in a DataFrame
active_products_df = execute_sql_query(sql_query)

# Count the number of active products
active_product_count = active_products_df['ProductID'].count()

# Create a DataFrame for visualization
visualization_df = pd.DataFrame({
    'Status': ['Active Products'],
    'Count': [active_product_count]
})

# Generate a bar chart using Plotly
fig = px.bar(visualization_df, x='Status', y='Count', title='Active Products Stock Status')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT COUNT(*) AS ActiveProducts
FROM products
WHERE Discontinued = 0 
AND UnitsInStock > ReorderLevel 
AND UnitsInStock < (ReorderLevel + UnitsOnOrder);
""""""
active_products_df = execute_sql_query(sql_query)

active_product_count = active_products_df['ActiveProducts'].iloc[0]

hist_data = {
    'Status': ['Active Products in Range'],
    'Count': [active_product_count]
}
hist_df = pd.DataFrame(hist_data)

fig = px.bar(hist_df, x='Status', y='Count', title='Active Products Stock Count Between Reorder Level and Maximum')
show_to_user(fig)
```","The input code uses a different condition for maximum stock level: 'UnitsInStock < (ReorderLevel + UnitsOnOrder)' instead of 'UnitsInStock < MaxStockLevel'. This does not align with the reference implementation's logic. The visualization part is correct, but the data filtering condition is incorrect according to the reference logic.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT COUNT(*) AS product_count
FROM products
WHERE Discontinued = 0 AND UnitsInStock BETWEEN ReorderLevel AND MaxUnits;
""""""

# Execute the SQL query
product_data = execute_sql_query(sql_query)

# Extract the product count
product_count = product_data['product_count'].iloc[0]

# Create a DataFrame for visualization
visualization_data = pd.DataFrame({'Range': ['In Stock'], 'Count': [product_count]})

# Create a bar chart using Plotly
fig = px.bar(visualization_data, x='Range', y='Count', title='Active Products in Stock Range')

# Show the bar chart
show_to_user(fig)
```","The input code uses 'BETWEEN' which includes the boundary values. The business logic requires products with stock strictly between reorder level and max stock. Additionally, the input code refers to a non-existent 'MaxUnits' column instead of 'MaxStockLevel'.",None
Identify the top 5 customers by total revenue and provide a bar chart to visualize their revenue contributions.,"
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch top 5 customers by total revenue.
sql_query = '''
SELECT 
    c.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM 
    customers c 
JOIN 
    orders o ON c.CustomerID = o.CustomerID 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY 
    c.CustomerID 
ORDER BY 
    TotalRevenue DESC 
LIMIT 5;
'''

# Use the utility function to execute the SQL query and store the results in a DataFrame.
top_customers_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to visualize the revenue contributions of the top 5 customers.
fig = px.bar(
    top_customers_df, 
    x='CustomerID', 
    y='TotalRevenue', 
    title='Top 5 Customers by Total Revenue',
    labels={'TotalRevenue': 'Total Revenue', 'CustomerID': 'Customer ID'},
    text='TotalRevenue'
)

# Display the bar chart to the user.
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    TotalRevenue DESC
LIMIT 5;
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='TotalRevenue', 
              title='Top 5 Customers by Total Revenue', 
              labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The input code correctly addresses the business request by identifying the top 5 customers based on total revenue and visualizing their contributions using a bar chart. The minor difference in the input code is using 'CompanyName' instead of 'CustomerID' for the x-axis, which still fulfills the requirement to identify top customers and does not affect the correctness of the implementation.","```python
# Assume 'execute_sql_query' and 'show_to_user' are already defined.

# SQL Query to get the top 5 customers by total revenue
sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM 
    customers c 
JOIN 
    orders o ON c.CustomerID = o.CustomerID 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY 
    c.CustomerID, c.CompanyName 
ORDER BY 
    TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query to get a DataFrame
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 customers by revenue
import pandas as pd
import plotly.express as px

fig = px.bar(
    top_customers_df, 
    x='CompanyName', 
    y='TotalRevenue', 
    title='Top 5 Customers by Total Revenue',
    labels={'CompanyName': 'Customer Name', 'TotalRevenue': 'Total Revenue'},
    text='TotalRevenue'
)

# Add a data label to the bars
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')

# Show the bar chart to the user
show_to_user(fig)
```","The input code meets the business analytics request by accurately identifying the top 5 customers based on total revenue. It uses a SQL query to aggregate revenue data, orders the results to find the top customers, and visualizes these results with a bar chart using Plotly. Although it includes an additional 'CompanyName' field, it does not affect the primary goal of the request and adds context. The bar chart correctly shows the top 5 customers' revenues, adhering to the logic and output format of the reference implementation.",both
"What is the most popular product by quantity ordered, and can this be represented in a bar chart?","
import plotly.express as px
import pandas as pd

# SQL Query to get the quantity ordered for each product
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) as TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Display the most popular product
most_popular_product = data.iloc[0]
print(""Most Popular Product by Quantity Ordered:"", most_popular_product['ProductName'])

# Visualize the data in a bar chart
fig = px.bar(data, x='ProductName', y='TotalQuantity', title='Popularity of Products by Quantity Ordered')
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve product and quantity ordered
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalOrdered DESC
LIMIT 1
""""""

# Execute the SQL query
most_popular_product = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(most_popular_product, x='ProductName', y='TotalOrdered', title='Most Popular Product by Quantity Ordered')

# Show the result to the user
show_to_user(fig)
```","The input code limits the query to a single product by using 'LIMIT 1'. This results in only the most popular product being retrieved, which makes it impossible to create a bar chart comparing all products by quantity ordered. The reference implementation retrieves the quantities for all products and then orders them, displaying all in the bar chart.","```python
import plotly.express as px

# SQL query string
sql_query = """"""
SELECT [Order Details].ProductID, SUM([Order Details].Quantity) AS TotalQuantity
FROM [Order Details]
GROUP BY [Order Details].ProductID
ORDER BY TotalQuantity DESC
LIMIT 1;
""""""

# Execute the SQL query and retrieve the results as a DataFrame
df = execute_sql_query(sql_query)

# Visualize the most popular product by quantity ordered in a bar chart
fig = px.bar(df, x='ProductID', y='TotalQuantity', 
             title='Most Popular Product by Quantity Ordered', 
             labels={'TotalQuantity': 'Total Quantity', 'ProductID': 'Product ID'})

# Display the figure to the user
show_to_user(fig)
```","The input Python code doesn't correctly answer the business analytics request because it only retrieves the top product by ProductID without joining to get the ProductName. The query also includes a LIMIT 1, which means it only retrieves the most popular product, rather than all products for a full analysis and visualization. Furthermore, a meaningful visualization comparing product popularity cannot be created from just one product. The reference code retrieves all products with their quantities for a comprehensive bar chart.",None
"Who are the top 5 customers by lifetime value, and can a bar chart be provided to visualize the differences in their values?","```python
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN customers ON orders.CustomerID = customers.CustomerID
GROUP BY customers.CustomerID
ORDER BY customer_lifetime_value DESC
LIMIT 5
""""""

# Utility function to execute SQL and get DataFrame
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_customers_df, x='CustomerID', y='customer_lifetime_value',
             title='Top 5 Customers by Lifetime Value',
             labels={'customer_lifetime_value': 'Lifetime Value ($)',
                     'CustomerID': 'Customer ID'})

# Display the plot using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID, customers.CompanyName 
ORDER BY customer_lifetime_value DESC 
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='customer_lifetime_value', 
             title='Top 5 Customers by Lifetime Value', 
             labels={'customer_lifetime_value': 'Lifetime Value', 'CompanyName': 'Customer Name'})

show_to_user(fig)
```","The input Python code correctly answers the business analytics request by identifying the top 5 customers by lifetime value and visualizing the results in a bar chart. Both the input and reference implementations calculate customer lifetime value in the same way using SQL. The input code groups by CustomerID and CompanyName, while the reference only uses CustomerID, but this does not affect the computation or selection of the top 5 customers. The visualization uses the customer's name instead of the ID, which is an acceptable enhancement. Thus, the logic of the reference implementation is maintained.","```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS customer_lifetime_value 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY customer_lifetime_value DESC 
LIMIT 5;
""""""

# Function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Implementation for executing SQL and reading into DataFrame
    # The function connects to the database, executes the query, and returns a DataFrame
    pass

# Function to display data
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# Execute the SQL query to get the DataFrame
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 customers by lifetime value
fig = px.bar(
    top_customers_df,
    x='CustomerID',
    y='customer_lifetime_value',
    title='Top 5 Customers by Lifetime Value',
    labels={'customer_lifetime_value': 'Lifetime Value'},
    text='customer_lifetime_value'
)

# Show the figure using the utility function
show_to_user(fig)
```","The input Python code correctly answers the business analytics request by calculating and visualizing the top 5 customers by lifetime value, similar to the reference implementation. It uses the same SQL logic to aggregate and order the data based on lifetime value and employs Plotly for visualization. While the two implementations differ slightly in style (e.g., table aliases, inclusion of customer lifetime value as text on the chart), the overall logic and results are consistent with the business requirement.",both
Identify the products with the most stock variability (highest fluctuation) and create a line chart to visualize the fluctuations over time.,"
```python
import pandas as pd
import plotly.express as px

# Utility Function: Execute SQL and retrieve data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated database execution, replace with actual DB call in production
    return pd.DataFrame({
        'ProductName': ['ProdA', 'ProdB', 'ProdC'],
        'StockVariance': [20, 15, 30]
    })

# Utility Function: Show to user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Main analysis and visualization
def analyze_stock_variability():
    # SQL query
    sql_query = """"""
    SELECT ProductName, MAX(UnitsInStock) - MIN(UnitsInStock) AS StockVariance
    FROM products
    GROUP BY ProductName
    ORDER BY StockVariance DESC;
    """"""
    
    # Execute the query and get the data
    df = execute_sql_query(sql_query)
    
    # Create a line chart using Plotly
    fig = px.line(df, x='ProductName', y='StockVariance', 
                  title='Product Stock Variability',
                  labels={'StockVariance': 'Stock Variability', 'ProductName': 'Product Name'})
    
    # Display the chart
    show_to_user(fig)

# Run the analysis
analyze_stock_variability()
```","```python
import pandas as pd
import plotly.express as px

# Retrieve stock data grouped by product and month
sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_TRUNC('month', od.OrderDate) AS Month,
    SUM(od.Quantity) AS TotalSold,
    AVG(p.UnitsInStock) AS AvgStock
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName, Month
ORDER BY 
    Month;
""""""
stock_data = execute_sql_query(sql_query)

# Calculate stock variability
stock_data['StockFluctuation'] = stock_data.groupby('ProductID')['AvgStock'].transform(lambda x: x.std())

# Get products with highest stock variability
fluctuating_products = stock_data.groupby(['ProductID', 'ProductName'])['StockFluctuation'].max().reset_index()
fluctuating_products = fluctuating_products.sort_values(by='StockFluctuation', ascending=False)

# Get top N products (for visualization purposes)
top_n = 10
top_fluctuating_products = fluctuating_products.head(top_n)

# Retrieve monthly stock data for top fluctuating products
top_product_ids = top_fluctuating_products['ProductID'].tolist()
sql_query_stock_trend = f""""""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_TRUNC('month', od.OrderDate) AS Month,
    SUM(od.Quantity) AS TotalSold,
    AVG(p.UnitsInStock) AS AvgStock
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
WHERE 
    p.ProductID IN ({','.join(map(str, top_product_ids))})
GROUP BY 
    p.ProductID, p.ProductName, Month
ORDER BY 
    Month, p.ProductID;
""""""
stock_trend_data = execute_sql_query(sql_query_stock_trend)

# Create a line chart for stock fluctuations over time
fig = px.line(stock_trend_data, x='Month', y='AvgStock', color='ProductName', title='Stock Variability Over Time for Top Products')
show_to_user(fig)
```","The reference implementation calculates stock variability by finding the difference between the maximum and minimum units in stock for each product, using this to gauge fluctuation. The input code calculates the standard deviation of the average monthly stock, which may suggest variability, but doesn’t directly reflect the max-min range as required by the business request. Additionally, the reference code involves executing a SQL query to rank products by variability and plotting that result directly, while the input code involves additional steps and a different metric (standard deviation), leading to a potential misalignment with the intended analysis.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return data as DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation of SQL query execution
    # This will actually interact with your database
    pass

# Function to show data analysis or visualization results
def show_to_user(data):
    # Mock function to display data
    # This will display the DataFrame or Plotly figure
    pass

# SQL query to find products with highest stock variability
sql_query_variability = """"""
SELECT ProductID, 
       STDEV(CAST(UnitPrice AS FLOAT)) AS PriceHighVariation 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY PriceHighVariation DESC;
""""""

# Execute the SQL query to get stock variability
variability_df = execute_sql_query(sql_query_variability)

# Additional SQL query to get historical stock levels over time if needed
sql_query_stock_over_time = """"""
SELECT ProductID, OrderDate, SUM(Quantity) AS StockLevel
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ProductID, OrderDate
ORDER BY OrderDate;
""""""

# Execute additional SQL query
stock_df = execute_sql_query(sql_query_stock_over_time)

# Match products with high variability to their stock fluctuation over time
# This is based on common understanding; need to ensure ProductID filtering is applied correctly
# stock_df should contain actual data of interest

# Create a line chart to visualize stock fluctuations over time
fig = px.line(stock_df, x='OrderDate', y='StockLevel', color='ProductID',
              title='Stock Variability Over Time by Product',
              labels={'StockLevel': 'Stock Level', 'OrderDate': 'Date'})

# Display the figure using show_to_user
show_to_user(fig)
```","The input code evaluates price variability instead of stock variability (it calculates PriceHighVariation using STDEV on UnitPrice), which does not align with the business request that focuses on stock fluctuations. The SQL logic and variable names indicate the code diverges significantly in approach by not assessing stock variability directly nor creating a relevant product stock variability line chart using the appropriate stock data.",None
Which employees have earned a salary above the average and display the results in a bar chart?,"```python
import plotly.express as px
import pandas as pd

# SQL query to retrieve employees with salary above average
sql_query = """"""
SELECT EmployeeID, Salary 
FROM employees 
WHERE Salary > (SELECT AVG(Salary) FROM employees);
""""""

# Execute the SQL query and retrieve results as a pandas DataFrame
employees_above_avg = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(employees_above_avg, x='EmployeeID', y='Salary', title='Employees Earning Above Average Salary')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve employee data along with their salaries
employee_query = ""SELECT EmployeeID, FirstName, LastName, Salary FROM employees""
employees_df = execute_sql_query(employee_query)

# Step 2: Calculate the average salary
average_salary = employees_df['Salary'].mean()

# Step 3: Filter employees who earn above the average salary
above_average_df = employees_df[employees_df['Salary'] > average_salary]

# Step 4: Create a bar chart to display results
fig = px.bar(above_average_df, x='FirstName', y='Salary', text='LastName', title='Employees with Salary Above Average')
show_to_user(fig)
```","The provided code correctly identifies employees with a salary above the average, calculates the average salary, filters the employees accordingly, and finally plots a bar chart using the filtered data. While it includes additional details like FirstName and LastName, this does not alter the correctness of the logic or result. The use of extra columns for display enhances the output but adheres to the primary logic of the reference implementation.","```python
import plotly.express as px

# Define the SQL query to get employees with salaries above the average
sql_query = ""SELECT * FROM employees WHERE Salary > (SELECT AVG(Salary) FROM employees);""

# Execute the SQL query using the utility function
employees_above_average = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    employees_above_average,
    x='EmployeeID',  # Assuming EmployeeID is a unique identifier
    y='Salary',
    title='Employees with Salary Above Average',
    labels={'Salary': 'Salary', 'EmployeeID': 'Employee ID'}
)

# Display the bar chart using the utility function
show_to_user(fig)
```","The input Python code correctly executes an SQL query to fetch employees with salaries above the average and visualizes them as a bar chart using Plotly. The logic in the input code matches the reference implementation, as it filters employees based on salaries greater than the average and displays this information in a bar chart using EmployeeID and Salary.",both
"Which employees have more than five years of employment, and can this be represented in a bar chart by department?","```python
import pandas as pd
import plotly.express as px

# Define necessary utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    """"""
    This function should execute the provided SQL query and return the result as a pandas DataFrame.
    """"""
    # Mocking the return for demonstration
    # In a real scenario, this would interface with a database
    data = {
        'EmployeeID': [1, 2, 3, 4, 5],
        'Department': ['HR', 'Engineering', 'Marketing', 'Engineering', 'HR']
    }
    return pd.DataFrame(data)

def show_to_user(data):
    """"""
    This function displays the provided data to the user.
    It accepts either a DataFrame or a Plotly figure.
    """"""
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Business logic to fulfill the request
sql_query = """"""
    SELECT EmployeeID, Department 
    FROM employees 
    WHERE DATEDIFF(CURRENT_DATE, HireDate) / 365 > 5;
""""""
df = execute_sql_query(sql_query)

# Group by department to count employees with more than five years of employment
dept_counts = df.groupby('Department').size().reset_index(name='Count')

# Create a bar chart to represent the data
fig = px.bar(dept_counts, x='Department', y='Count', title='Employees with More Than 5 Years of Employment by Department')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Calculate the cutoff date for employees with more than 5 years of employment
cutoff_date = datetime.now().date().replace(year=datetime.now().year - 5)

# SQL query to get employees hired before the cutoff date along with their departments
sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    e.HireDate, 
    d.DepartmentName
FROM 
    employees e
JOIN 
    departments d ON e.DepartmentID = d.DepartmentID
WHERE 
    e.HireDate < '{cutoff_date}'
"""""".format(cutoff_date=cutoff_date)

# Execute the SQL query and store the results in a DataFrame
employees_df = execute_sql_query(sql_query)

# Count employees by department
employee_counts = employees_df['DepartmentName'].value_counts().reset_index()
employee_counts.columns = ['DepartmentName', 'EmployeeCount']

# Create a bar chart representation by department
fig = px.bar(employee_counts, x='DepartmentName', y='EmployeeCount', 
             title='Employees with More than 5 Years of Employment by Department',
             labels={'EmployeeCount': 'Number of Employees', 'DepartmentName': 'Department'})
             
show_to_user(fig)
```","The input code filters employees based on 'HireDate < cutoff_date', whereas the reference code uses 'DATEDIFF(CURRENT_DATE, HireDate) / 365 > 5'. Both intend to retrieve employees with more than 5 years of employment, but the input code calculates 'cutoff_date' incorrectly by trying to subtract years directly, which may not handle leap years or exact dates correctly. The reference code aligns correctly with business logic using the date difference division, making it more accurate. Additionally, the input code has an extra query complexity by joining with 'departments', which isn't required in the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database connection and query execution
    # Implement database connection logic here and replace example_df with real query result
    example_df = pd.DataFrame({
        'EmployeeID': [1, 2, 3],
        'FirstName': ['John', 'Alice', 'Bob'],
        'LastName': ['Doe', 'Smith', 'Brown'],
        'Department': ['HR', 'IT', 'Sales'],
        'EmploymentDuration': pd.to_datetime([f'2000-01-01', '2015-06-15', '2012-11-01']),
        'years_employment': [6, 8, 11]
    })
    return example_df

# Function to show results to the user
def show_to_user(data):
    # Print DataFrame or display Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to select employees with more than 5 years of employment
sql_query = '''
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, employees.Department 
FROM employees 
WHERE DATEDIFF(CURRENT_DATE, employees.EmploymentDuration) > 5 * 365.25
'''

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Filter data to find employees with more than 5 years
df['years_employment'] = (pd.to_datetime('today') - df['EmploymentDuration']) // pd.Timedelta('365.25D')
df_filtered = df[df['years_employment'] > 5]

# Create a bar chart using Plotly
fig = px.bar(df_filtered, x='Department', y='years_employment',
             title='Employees with More than 5 Years of Employment by Department',
             text='years_employment')

# Show the bar chart to the user
show_to_user(fig)
```","The input code does not strictly adhere to the logic specified in the business request. First, the input code calculates years of employment directly using the EmploymentDuration column, which differs from the SQL logic where 'DATEDIFF(CURRENT_DATE, HireDate)' is used. Moreover, the input code's bar chart uses 'years_employment' as the y-value instead of counting employees per department. The reference code calculates employee counts per department to fulfill the request within the chart. These differences indicate a logic mismatch between the input and reference implementations.",None
What are the top three regions with the highest on-time delivery rate? Please include a bar chart to visualize the on-time delivery rates across all regions.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get on-time delivery rate for all regions
sql_query = """"""
SELECT ShipRegion, 
       100.0 * COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OnTimeDeliveryRate DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the top three regions with the highest on-time delivery rate
top_three_regions = df.head(3)
show_to_user(top_three_regions)

# Create a bar chart to visualize the on-time delivery rates across all regions
fig = px.bar(df, x='ShipRegion', y='OnTimeDeliveryRate', title='On-Time Delivery Rates by Region')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipRegion,
    COUNT(OrderID) AS total_orders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS on_time_deliveries
FROM 
    orders
GROUP BY 
    ShipRegion
""""""

df = execute_sql_query(sql_query)

df['on_time_rate'] = df['on_time_deliveries'] / df['total_orders']

top_regions = df.nlargest(3, 'on_time_rate')

fig = px.bar(df, x='ShipRegion', y='on_time_rate', title='On-time Delivery Rates by Region', labels={'on_time_rate': 'On-time Delivery Rate'})
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate as a percentage by dividing the number of on-time deliveries by the total number of orders for each region. It then selects the top three regions with the highest on-time delivery rate using the nlargest function. Furthermore, it generates a bar chart using Plotly to visualize these rates. This approach aligns with the logic used in the reference implementation, even though there are slight differences in the SQL and Python code structure. Therefore, the input code is correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch on-time delivery rates for all regions
sql_query_all_regions = """"""
SELECT Region, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(*)) AS OnTimeRate 
FROM orders 
GROUP BY Region 
ORDER BY OnTimeRate DESC;
""""""

# Execute the SQL query to get a DataFrame of all regions
all_regions_df = execute_sql_query(sql_query_all_regions)

# Select the top three regions with the highest on-time delivery rate
top_regions_df = all_regions_df.head(3)

# Create a bar chart using Plotly to visualize on-time delivery rates across all regions
fig = px.bar(all_regions_df, x='Region', y='OnTimeRate',
             title='On-Time Delivery Rates by Region',
             labels={'OnTimeRate': 'On-Time Rate (%)', 'Region': 'Region'},
             text='OnTimeRate')

# Display the bar chart
show_to_user(fig)

# Display the top three regions
show_to_user(top_regions_df)
```","Both implementations correctly query the on-time delivery rates for each region, rank them, and select the top three. The SQL logic is consistent, using a CASE statement to determine on-time deliveries divided by total orders. Both implementations order the results by on-time delivery rate in descending order. The output includes a bar chart using Plotly and displays the top three regions. Minor differences in SQL and language naming do not affect the logic or outcome.",both
Which products have the highest orders on discount? Please include a bar chart to show the quantity of orders for each product on discount.,"```python
import pandas as pd
import plotly.express as px

# SQL query as provided
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * od.Discount) AS DiscountedRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
GROUP BY p.ProductID, p.ProductName
ORDER BY DiscountedRevenue DESC;
""""""

# Execute the SQL query and get the results in a DataFrame
discounted_orders_df = execute_sql_query(sql_query)

# Display the DataFrame for review
show_to_user(discounted_orders_df)

# Plot a bar chart to visualize the discounted revenue for each product
fig = px.bar(
    discounted_orders_df,
    x='ProductName',
    y='DiscountedRevenue',
    title='Products with Highest Discounted Revenue',
    labels={'DiscountedRevenue': 'Total Discounted Revenue'},
    text='DiscountedRevenue'
)

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
""""""

# Execute the SQL query to get the product orders on discount
discounted_orders_df = execute_sql_query(sql_query)

# Create a bar chart for the quantity of orders for products on discount
fig = px.bar(discounted_orders_df, 
             x='ProductName', 
             y='TotalQuantity', 
             title='Products with the Highest Orders on Discount',
             labels={'TotalQuantity': 'Quantity of Orders', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code is evaluating the total quantity of orders for products on discount, whereas the reference code is calculating the total discounted revenue for each product. The business request specifically asks for the highest orders on discount, which corresponds to the input code. However, the input code deviates from the reference in terms of logic priority—quantity vs. revenue. Thus, it doesn't match the logic of the reference implementation, which focuses on revenue rather than quantity.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholder
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration
    # Replace with actual SQL execution logic
    data = {
        'ProductID': [1, 2, 3],
        'QuantityOnDiscount': [150, 120, 90]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock implementation for demonstration
    # Replace with actual logic to display data
    print(data)

# SQL query to get products with the highest quantity of orders on discount
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS QuantityOnDiscount
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE [Order Details].Discount > 0
GROUP BY products.ProductID
ORDER BY QuantityOnDiscount DESC
""""""

# Execute SQL query to get data
df_orders_on_discount = execute_sql_query(sql_query)

# Create bar chart visualization using Plotly
fig = px.bar(df_orders_on_discount, x='ProductID', y='QuantityOnDiscount', 
             title='Products with Highest Orders on Discount', 
             labels={'ProductID': 'Product ID', 'QuantityOnDiscount': 'Quantity on Discount'})

# Display the bar chart
show_to_user(fig)
```","The provided code is not correct. The reference implementation calculates the 'DiscountedRevenue' by taking into account the product of Quantity, UnitPrice, and Discount, whereas the input code computes 'QuantityOnDiscount,' which only sums the quantities. The input code does not account for the 'DiscountedRevenue,' which is what the business analytics request is targeting. Therefore, the logic does not match the reference implementation.",None
"What are the top 5 products with the highest revenue, and can you provide a bar chart to illustrate the results?","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user utility functions are already defined.

# SQL query to get the top 5 products by revenue
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(top_products_df, x='ProductID', y='TotalRevenue', title='Top 5 Products by Revenue')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    Revenue DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='Revenue', title='Top 5 Products by Revenue', labels={'ProductID': 'Product ID', 'Revenue': 'Revenue'})
show_to_user(fig)
```","The input code correctly implements the required task to find the top 5 products with the highest revenue. It computes revenue using the formula 'UnitPrice * Quantity * (1 - Discount)', groups by 'ProductID', and orders the results in descending order by revenue with a limit of 5, similar to the reference implementation. The small change in column naming from 'TotalRevenue' to 'Revenue' does not affect the correctness. Additionally, the inclusion of a JOIN operation on the 'orders' table does not deviate from the original purpose, provided it doesn't alter the result, which isn't clear but assumed to be pertinent. The visualization is handled appropriately using Plotly's bar chart, and the results are displayed similarly. Therefore, the input code is considered correct.","```python
import plotly.express as px

# Execute the provided SQL query to get the data
sql_query = """"""
SELECT
    p.ProductName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM
    products p
JOIN
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY
    p.ProductName
ORDER BY
    Revenue DESC
LIMIT 5;
""""""

# Retrieving the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='Revenue', title='Top 5 Products by Revenue')

# Show the figure to the user
show_to_user(fig)
```","The input Python code correctly answers the business request by calculating the top 5 products with the highest revenue and displaying a bar chart. Although it differs from the reference implementation by using 'ProductName' instead of 'ProductID', it adheres to the same logic and fulfills the business analytics request. The SQL query correctly calculates revenue, groups by product name, and limits to the top 5, and the resulting chart is created and displayed using Plotly, as required.",both
"What is the average inventory level for each supplier, and can a bar chart visualize these averages?","
```python
import pandas as pd
import plotly.express as px

# SQL query to gather average inventory data
sql_query = """"""
SELECT SupplierID, AVG(UnitsInStock) AS AvgInventory
FROM products
GROUP BY SupplierID;
""""""

# Utility function to execute SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation of SQL execution (details omitted)
    # Returns a DataFrame with the result of the query
    pass

# Function to show visualization or data to the user
def show_to_user(data):
    # Implementation for displaying data (details omitted)
    pass

# Execute the query to get the data
inventory_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize average inventory levels per supplier
fig = px.bar(inventory_data, x='SupplierID', y='AvgInventory', title='Average Inventory Level per Supplier', labels={'AvgInventory': 'Average Inventory', 'SupplierID': 'Supplier ID'})

# Use the utility function to show the chart to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT SupplierID, AVG(UnitsInStock) AS AverageInventory
FROM products
GROUP BY SupplierID
""""""

average_inventory_df = execute_sql_query(sql_query)

fig = px.bar(average_inventory_df, x='SupplierID', y='AverageInventory', 
             title='Average Inventory Level for Each Supplier',
             labels={'SupplierID': 'Supplier ID', 'AverageInventory': 'Average Inventory Level'})
show_to_user(fig)
```","The input Python code is correct because it accurately computes the average inventory level for each supplier using a SQL query similar to the reference code. Both codes group the inventory data by SupplierID and compute the average using AVG. The visualization is done with Plotly's bar chart in both implementations, and the labels and titles are appropriately set. Although there are slight differences in variable naming ('AverageInventory' vs. 'AvgInventory'), these do not affect the correctness of the logic or functionality.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the average inventory level for each supplier
sql_query = ""SELECT SupplierID, AVG(UnitsInStock) AS AvgInventory FROM products GROUP BY SupplierID;""

# Function to execute the SQL query
def execute_sql_query(sql_query: str):
    # Mock implementation for illustration purposes
    return pd.DataFrame({
        'SupplierID': [1, 2, 3],
        'AvgInventory': [100.5, 150.2, 200.3]
    })

# Executing the SQL query and getting the results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Creating a bar chart using Plotly to visualize the average inventory levels
fig = px.bar(df, x='SupplierID', y='AvgInventory', title='Average Inventory Level by Supplier', labels={'AvgInventory': 'Average Inventory'})

# Display the bar chart to the user
def show_to_user(data):
    # Placeholder for actual implementation to display data
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()  # Shows the plotly figure

show_to_user(fig)
```","The input Python code correctly implements the business analytics request. The SQL query to calculate the average inventory levels for each supplier is consistent with the reference implementation. A mock implementation returns a sample DataFrame with the appropriate structure. Plotly is used to create a bar chart that visualizes the data, and the 'show_to_user' function displays the chart. The logic is consistent with the reference code, fulfilling the specified requirements.",both
What are the top 3 regions with the highest order volumes? Please include a bar chart to visualize the differences in order volumes among the top regions.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # This is a mock implementation of the actual SQL execution function
    # In practice, this would execute the SQL and return a DataFrame
    data = {
        'TerritoryDescription': ['Region A', 'Region B', 'Region C', 'Region D'],
        'order_count': [120, 110, 100, 90]  # Dummy data for demonstration
    }
    df = pd.DataFrame(data)
    return df


def show_to_user(data):
    # This is a mock implementation of displaying data/visualization
    # In practice, this would display/return the results
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()


# SQL query to fetch top 3 regions by order volume
sql_query = """"""
SELECT territories.TerritoryDescription, COUNT(orders.OrderID) AS order_count 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
GROUP BY territories.TerritoryDescription 
ORDER BY order_count DESC 
LIMIT 3
""""""

# Execute the SQL query and get the result in a DataFrame
order_volume_df = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(order_volume_df)

# Create a bar chart using Plotly to visualize the order volumes
fig = px.bar(order_volume_df, x='TerritoryDescription', y='order_count',
             title='Top 3 Regions by Order Volume',
             labels={'order_count': 'Order Volume', 'TerritoryDescription': 'Region'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.ShipRegion AS region, 
    COUNT(o.OrderID) AS order_volume 
FROM 
    orders o 
GROUP BY 
    o.ShipRegion 
ORDER BY 
    order_volume DESC 
LIMIT 3
""""""

top_regions_df = execute_sql_query(sql_query)

fig = px.bar(top_regions_df, 
              x='region', 
              y='order_volume', 
              title='Top 3 Regions with Highest Order Volumes',
              labels={'region': 'Region', 'order_volume': 'Order Volume'})
show_to_user(fig)
```","The input code uses 'ShipRegion' from the 'orders' table, which implies that it defines regions differently than the reference code. The reference code combines several tables to determine territory-based order counts, which might result in different regions and counts. Thus, the input code doesn't adhere to the same logic.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholder
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the logic to execute the SQL query
    # and return the result as a pandas DataFrame.
    pass

def show_to_user(data):
    # This function should handle the display of either a DataFrame or Plotly Figure.
    pass

# SQL query to fetch top 3 regions with the highest order volumes.
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderVolume
FROM orders
GROUP BY ShipRegion
ORDER BY OrderVolume DESC
LIMIT 3;
""""""

# Execute the SQL query and get the results in a DataFrame.
top_regions_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the order volumes.
fig = px.bar(top_regions_df, x='ShipRegion', y='OrderVolume',
             title='Top 3 Regions by Order Volume',
             labels={'ShipRegion': 'Region', 'OrderVolume': 'Order Volume'})

# Show the bar chart to the user.
show_to_user(fig)
```","The input code uses 'ShipRegion' instead of 'TerritoryDescription' and only considers the 'orders' table without joining with 'employees', 'employeeTerritories', and 'territories' needed to properly aggregate by TerritoryDescription as in the reference implementation. Therefore, it doesn't adhere to the same logic required by the business analytics request.",None
"What is the average discount applied to each product, and can you display this information using a bar chart?","
import pandas as pd
import plotly.express as px

# SQL query to retrieve product names and average discounts
sql_query = """"""
SELECT p.ProductName, AVG(od.Discount) AS AverageDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ProductName', y='AverageDiscount', 
             title='Average Discount Applied to Each Product',
             labels={'ProductName': 'Product Name', 'AverageDiscount': 'Average Discount'})

# Display the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, 
             x='ProductName', 
             y='AverageDiscount', 
             title='Average Discount Applied to Each Product', 
             labels={'AverageDiscount': 'Average Discount', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The provided input code is correct because it achieves the same goal as the reference implementation. Both codes execute an SQL query to compute the average discount for each product and display the result using a Plotly bar chart. The input code includes ProductID in the GROUP BY clause, which doesn't affect the correctness as it groups by ProductName anyway. The visualization logic and display method match the reference.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch average discount per product
sql_query = """"""
SELECT p.ProductName, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
""""""

# Fetching the data using the utility function
df = execute_sql_query(sql_query)

# Creating a bar chart using Plotly
fig = px.bar(
    df,
    x='ProductName',
    y='AverageDiscount',
    title='Average Discount per Product',
    labels={'ProductName': 'Product Name', 'AverageDiscount': 'Average Discount'}
)

# Displaying the bar chart
show_to_user(fig)
```","The provided input code correctly follows the logic of the reference implementation. Both implementations execute a SQL query to retrieve the average discount applied to each product. They then create a bar chart using Plotly, with the appropriate titles and labels. The query, data fetching, and visualization processes are consistent across both implementations, fulfilling the business analytics request.",both
How many sales were made by employees hired in the last year? Include a bar chart showing sales per employee.,"```python
import plotly.express as px
import pandas as pd

# Assuming the execute_sql_query and show_to_user functions are implemented correctly

def execute_sql_query(sql_query: str):
    # This function should be implemented to execute the SQL query and return results as a pandas DataFrame
    pass

def show_to_user(data):
    # This function should be implemented to either display a DataFrame or a Plotly figure
    pass

# SQL query to get the number of sales made by employees hired in the last year
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS RecentSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE e.HireDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the results as a DataFrame
sales_data = execute_sql_query(sql_query)

# Visualize the sales data using a bar chart
fig = px.bar(sales_data, x='EmployeeID', y='RecentSales', title='Sales by Employees Hired in the Last Year')

# Display the chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date one year ago from today
one_year_ago = datetime.now() - timedelta(days=365)

# SQL query to get employees hired in the last year along with their sales
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.HireDate >= '{one_year_ago.strftime('%Y-%m-%d')}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Show the total number of sales made
total_sales_count = sales_data['TotalSales'].count()
print(f""Total sales made by employees hired in the last year: {total_sales_count}"")

# Create a bar chart showing sales per employee
fig = px.bar(sales_data, x='FirstName', y='TotalSales', 
             title='Sales Per Employee Hired in the Last Year',
             labels={'FirstName': 'Employee Name', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The provided code calculates 'TotalSales' as the sum of sales amounts rather than counting the number of sales/orders. It also uses 'FirstName' for visualization instead of 'EmployeeID', which could lead to ambiguous results if multiple employees share the same first name. Additionally, the input code computes total sales amounts using 'UnitPrice', 'Quantity', and 'Discount', which deviates from just counting orders.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch sales data for employees hired in 2022
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Sales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.HireDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY e.EmployeeID;
""""""

# Execute the query and store the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Generate a bar chart showing sales per employee
fig = px.bar(sales_data, x='EmployeeID', y='Sales', title='Sales per Employee (Hired in Last Year)',
             labels={'Sales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Display the bar chart using the utility function
show_to_user(fig)
```","The input code calculates the total sales value (sum of product prices times quantities) by employees hired in the last year, while the reference implementation counts the number of sales (orders) by those employees. The logic and metrics are different, resulting in a different analysis outcome.",None
How many units of each product are on order? Include a bar chart to display the breakdown by product.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function, replace with actual SQL execution logic
    # Here, it's assumed to return a DataFrame as mentioned in the constraints
    pass

def show_to_user(data):
    # Mock function, replace with actual visualization logic
    # Accepts a pandas DataFrame or Plotly figure
    pass

# SQL query to fetch product orders
sql_query = ""SELECT ProductID, UnitsOnOrder FROM products;""

# Execute the SQL query and get the result as a DataFrame
df_products = execute_sql_query(sql_query)

# Generate a bar chart to display the breakdown by product
fig = px.bar(df_products, x='ProductID', y='UnitsOnOrder',
             title='Units on Order by Product',
             labels={'ProductID': 'Product ID', 'UnitsOnOrder': 'Units on Order'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductName,
    p.UnitsOnOrder
FROM 
    products p
WHERE 
    p.Discontinued = 0
ORDER BY 
    p.ProductName;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='UnitsOnOrder', title='Units on Order by Product')
show_to_user(fig)
```","The input code filters out discontinued products with 'p.Discontinued = 0', which is not part of the reference implementation. Consequently, the input does not match the logic completely, as it excludes some data that should be included.","```python
import pandas as pd
import plotly.express as px

# Given utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would connect to a database, execute the query, and return the result as a pandas DataFrame
    pass

def show_to_user(data):
    # This function would display data analysis or visualization results
    pass

# SQL query to retrieve product units on order
sql_query = ""SELECT ProductID, OnOrder FROM products WHERE OnOrder > 0;""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize units on order by product
fig = px.bar(df, x='ProductID', y='OnOrder', title='Units on Order by Product', labels={'OnOrder': 'Units on Order'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code uses 'OnOrder' instead of 'UnitsOnOrder' used in the reference implementation. This deviation presumes that the input query retrieves field names incorrectly and may not match the database schema or logic expected in the reference code. Therefore, the logic may not be correct based on the specified request and the reference code.",None
"Which orders were shipped after the required date, and can this be visualized using a timeline or bar chart to compare shipment and required dates?","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT OrderID, ShippedDate, RequiredDate
FROM orders
WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query and retrieve the result as a DataFrame
orders_df = execute_sql_query(sql_query)

# Convert date columns to datetime
orders_df['ShippedDate'] = pd.to_datetime(orders_df['ShippedDate'])
orders_df['RequiredDate'] = pd.to_datetime(orders_df['RequiredDate'])

# Create a bar chart comparing ShippedDate and RequiredDate
fig = px.bar(
    orders_df,
    x='OrderID',
    y=['ShippedDate', 'RequiredDate'],
    barmode='group',
    title='Comparison of Shipping Dates and Required Dates'
)

# Show the visualization to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, RequiredDate, ShippedDate
FROM orders
WHERE ShippedDate > RequiredDate
""""""
orders_late = execute_sql_query(sql_query)

if not orders_late.empty:
    orders_late['OrderID'] = orders_late['OrderID'].astype(str)
    fig = px.bar(orders_late, x='OrderID', y=['RequiredDate', 'ShippedDate'], 
                 title='Comparison of Shipped Dates vs Required Dates',
                 labels={""value"": ""Date"", ""variable"": ""Date Type""},
                 barmode='group')
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame(columns=[""No late shipments found""]))
```",The input Python code correctly answers the business analytics request by retrieving orders where the shipped date is after the required date. It also uses the same logic as the reference implementation to visualize the data with a bar chart. Differences such as the order of date columns and additional label settings in the bar chart are acceptable as they do not affect the correctness of the solution. The use of an early check for an empty DataFrame is a valid improvement and does not disrupt the main requirement.,"```python
import plotly.express as px
import pandas as pd

# Placeholder function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function will be implemented to interact with the actual database
    # For now, it returns a mock DataFrame with example data
    data = {
        'OrderID': [1, 2, 3],
        'ShippedDate': ['2023-01-10', '2023-01-15', '2023-01-20'],
        'RequiredDate': ['2023-01-09', '2023-01-14', '2023-01-18']
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This is a placeholder for the function that displays data or visualizations to the user
    print(data)

# SQL query to fetch orders shipped after the required date
sql_query = ""SELECT OrderID, ShippedDate, RequiredDate FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Convert date columns to datetime objects for accurate plotting
orders_df['ShippedDate'] = pd.to_datetime(orders_df['ShippedDate'])
orders_df['RequiredDate'] = pd.to_datetime(orders_df['RequiredDate'])

# Create a bar chart to visualize the shipped and required dates
df_melted = orders_df.melt(id_vars='OrderID', value_vars=['ShippedDate', 'RequiredDate'],
                           var_name='DateType', value_name='Date')

# Generate the bar chart using Plotly
fig = px.bar(df_melted, x='OrderID', y='Date', color='DateType',
             title=""Comparison of Shipment and Required Dates"",
             labels={'Date': ""Date"", 'OrderID': ""Order ID""})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly replicates the logic of the reference implementation. It executes a SQL query to fetch orders where 'ShippedDate' is after 'RequiredDate', converts the date columns to datetime objects, and generates a bar chart using Plotly to compare shipment and required dates for each order. The main difference is the use of `melt()` in the input code, which still provides an equivalent bar chart visualization by using the 'color' argument to differentiate 'ShippedDate' and 'RequiredDate'.",both
Which product has the highest sales revenue? Please include a bar chart to visualize the sales revenue for each product.,"```python
import plotly.express as px

# SQL query to fetch sales revenue for each product
sql_query = """"""
SELECT products.ProductID, 
       products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID, products.ProductName 
ORDER BY TotalRevenue DESC;
""""""

# Execute SQL query and get results in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ProductName', y='TotalRevenue', title='Sales Revenue by Product')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS SalesRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY SalesRevenue DESC
LIMIT 1;
""""""

highest_sales_product = execute_sql_query(sql_query)

product_id = highest_sales_product['ProductID'].values[0]
product_name = highest_sales_product['ProductName'].values[0]
sales_revenue = highest_sales_product['SalesRevenue'].values[0]

all_sales_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS SalesRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName;
""""""

all_sales_data = execute_sql_query(all_sales_query)

fig = px.bar(all_sales_data, 
              x='ProductName', 
              y='SalesRevenue', 
              title='Sales Revenue by Product',
              labels={'SalesRevenue': 'Sales Revenue ($)', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly addresses the business analytics request by determining which product has the highest sales revenue and visualizing the sales revenue for each product. It first executes a query to determine the product with the highest sales revenue, which aligns with the reference implementation goal. The input code then performs another query to retrieve the sales revenue for each product and uses Plotly to create a bar chart, similar to the reference code. This outputs the necessary visualization. Therefore, the logic and goals are consistent with the reference, even though it involves an additional step to obtain the highest sales product.","```python
import pandas as pd
import plotly.express as px

# Assuming the SQL query is defined elsewhere as a string variable
sql_query = """"""
SELECT ProductName, 
       SUM(([Order Details].Quantity * [Order Details].UnitPrice) * (1 - [Order Details].Discount)) AS ProductRevenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY ProductName 
ORDER BY ProductRevenue DESC;
""""""

# Fetch the results using the utility function
# The utility function fetch_data_from_sql executes the SQL query
# and returns the result in a DataFrame format
products_df = fetch_data_from_sql(sql_query)

# Find the product with the highest sales revenue
highest_revenue_product = products_df.iloc[0]

# Display the highest sales revenue product data
show_to_user(highest_revenue_product.to_frame().T)

# Create a bar chart to visualize sales revenue for each product
fig = px.bar(products_df, x='ProductName', y='ProductRevenue', title='Sales Revenue by Product')

# Display the bar chart using the show_to_user utility function
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It executes an SQL query to compute total sales revenue for each product, orders the results by revenue, and creates a bar chart using Plotly to visualize the data. The logic is consistent with the reference implementation, as it retrieves the same information and displays it accordingly. While the variable names and utility function names differ, these do not affect the correctness of the data analysis process.",both
What is the most frequently ordered product? Please include a bar chart to show the frequency of each product ordered.,"```python
import plotly.express as px

# SQL Query to get the frequency of each product ordered
sql_query = """"""
SELECT ProductName, COUNT([Order Details].OrderID) AS OrderCount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY ProductName 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get the data into a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart with Plotly to visualize the frequency of each product ordered
fig = px.bar(data, x='ProductName', y='OrderCount', title='Frequency of Products Ordered')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalOrdered DESC
LIMIT 1
""""""

most_frequent_product = execute_sql_query(sql_query)

sql_query_frequency = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrdered
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

frequency_data = execute_sql_query(sql_query_frequency)

fig = px.bar(frequency_data, x='ProductName', y='TotalOrdered', title='Frequency of Each Product Ordered', labels={'TotalOrdered': 'Total Ordered', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The reference implementation counts the number of orders for each product (using COUNT on OrderID) while the input implementation sums the quantities of products ordered (using SUM on Quantity). This means the input code is identifying the most ordered product in terms of quantity, whereas the reference queries in terms of distinct order entries. Additionally, the input code queries and identifies the single most ordered product with a LIMIT 1 clause, which is unnecessary for generating the bar chart.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query for all products' frequencies
sql_query_all_products = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalFrequency 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalFrequency DESC;
""""""

# Execute the SQL query to retrieve product frequencies
products_df = execute_sql_query(sql_query_all_products)

# Generate the bar chart with Plotly
fig = px.bar(
    products_df,
    x='ProductName',
    y='TotalFrequency',
    title='Frequency of Each Product Ordered',
    labels={'TotalFrequency': 'Total Orders'},
    text_auto=True
)

# Display the bar chart
show_to_user(fig)
```","The input code calculates the frequency using the 'SUM(od.Quantity)' which tallies the total quantity ordered for each product, whereas the reference code uses 'COUNT' to count the number of orders each product was included in. These are different metrics: total quantity ordered vs. number of orders. Thus, the logic is not identical.",None
"What is the total discount provided by each employee, and could you provide a bar chart to visualize the discounts by employee?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Assume this function is implemented and correctly interacts with the database
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation - replace with real database interaction
    pass

def show_to_user(data):
    # Assume this method correctly displays the DataFrame or Plotly figure
    pass

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='TotalDiscount', title='Total Discount by Employee')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.Discount) AS TotalDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

discounts_df = execute_sql_query(sql_query)

fig = px.bar(discounters_df, x='FirstName', y='TotalDiscount', title='Total Discount Provided by Each Employee', text='TotalDiscount')
show_to_user(fig)
```","The input code's SQL query calculates the TotalDiscount as a simple sum of the Discounts without considering the Quantity and UnitPrice like the reference code. Additionally, the input code groups by EmployeeID, FirstName, and LastName, thus altering the grouping logic. It also uses 'FirstName' instead of 'EmployeeID' on the x-axis of the bar chart, which differs from the reference implementation.","```python
import pandas as pd
import plotly.express as px

# The SQL query as specified in the business request
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Function to execute the SQL query and return the results as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for the sake of example, replace with actual database code
    # Example return:
    # return pd.DataFrame({
    #     ""EmployeeID"": [1, 2, 3],
    #     ""TotalDiscount"": [100.0, 200.0, 150.0]
    # })
    pass

# Execute the SQL query to get the DataFrame
discount_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(discount_df, x='EmployeeID', y='TotalDiscount', 
             title='Total Discount Provided by Each Employee',
             labels={'TotalDiscount': 'Total Discount', 'EmployeeID': 'Employee ID'})

# Display the bar chart to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

show_to_user(fig)
```","Both implementations perform the same operation to calculate the total discount by multiplying UnitPrice, Quantity, and Discount, aggregated by each EmployeeID. The difference in the order of multiplication does not affect the outcome. Both implementations also create a bar chart to visualize the data using Plotly. Thus, the input code is correct as it adheres to the logic of the reference implementation.",Finetuned
"What is the average shipping cost per order for the last month, and can you provide a bar chart to visualize the distribution of shipping costs across different order sizes?","
```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get order details from the last month
sql_query = """"""
SELECT Freight, OrderID FROM orders WHERE OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE);
""""""

# Execute the query and store the results in a DataFrame
orders_df = execute_sql_query(sql_query)

# Calculate the average shipping cost per order for the last month
average_shipping_cost = orders_df['Freight'].mean()

# Display the average shipping cost to the user
average_cost_df = pd.DataFrame({'Average Shipping Cost': [average_shipping_cost]})
show_to_user(average_cost_df)

# Create a bar chart to visualize the distribution of shipping costs across different order sizes
orders_df['OrderSize'] = pd.qcut(orders_df['Freight'], q=4, labels=['Small', 'Medium', 'Large', 'Extra Large'])

# Create a bar chart using Plotly
fig = px.bar(
    orders_df,
    x='OrderSize',
    y='Freight',
    title='Distribution of Shipping Costs by Order Size',
    labels={'Freight': 'Shipping Cost', 'OrderSize': 'Order Size'},
    color='OrderSize',
    barmode='group'
)

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last month
end_date = datetime.now().replace(day=1) - timedelta(days=1)
start_date = end_date.replace(day=1)

# SQL query to get the average shipping cost and the distribution of shipping costs per order
sql_query = f""""""
SELECT
    Freight,
    COUNT(OrderID) AS OrderCount
FROM
    orders
WHERE
    OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY
    Freight
""""""

# Execute the SQL query
shipping_data = execute_sql_query(sql_query)

# Calculate the average shipping cost
average_shipping_cost = shipping_data['Freight'].mean()

# Create a bar chart to visualize the distribution of shipping costs
bar_chart = px.bar(
    shipping_data,
    x='Freight',
    y='OrderCount',
    title='Distribution of Shipping Costs Across Different Order Sizes',
    labels={'Freight': 'Shipping Cost', 'OrderCount': 'Number of Orders'}
)

# Show average shipping cost and bar chart
show_to_user(pd.DataFrame({'Average Shipping Cost': [average_shipping_cost]}))
show_to_user(bar_chart)
```","The input code does not correctly compute the average shipping cost per order. It averages across the distinct freight values, not across individual orders. Additionally, it calculates a count of orders per freight value, which deviates from the original task. The reference code correctly computes the average by considering each order's freight individually. The bar chart in the input code also deviates in logic by representing freight values on the x-axis and their counts, unlike the reference which categorizes based on defined order sizes using quantiles.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average shipping cost per order for the last month
sql_query_avg_shipping = """"""
SELECT AVG(orders.Freight) AS average_shipping_cost
FROM orders
WHERE orders.OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
AND orders.OrderDate < DATE_TRUNC('month', CURRENT_DATE);
""""""

# SQL query to get shipping costs and order sizes for visualization
sql_query_shipping_distribution = """"""
SELECT orders.Freight AS shipping_cost, orders.OrderSize
FROM orders
WHERE orders.OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
AND orders.OrderDate < DATE_TRUNC('month', CURRENT_DATE);
""""""

# Execute SQL query to get average shipping cost
avg_shipping_df = execute_sql_query(sql_query_avg_shipping)

# Execute SQL query to get shipping costs and order sizes
shipping_distribution_df = execute_sql_query(sql_query_shipping_distribution)

# Display the average shipping cost to the user
show_to_user(avg_shipping_df)

# Create a bar chart to visualize the distribution of shipping costs across different order sizes
fig = px.bar(shipping_distribution_df, x='OrderSize', y='shipping_cost',
             title='Distribution of Shipping Costs Across Order Sizes', 
             labels={'OrderSize': 'Order Size', 'shipping_cost': 'Shipping Cost'},
             barmode='group')

# Provide the bar chart to the user
show_to_user(fig)
```","The input code does not calculate the average shipping cost per order directly as the reference does, because it queries for 'average_shipping_cost' via SQL and doesn't utilize the given Freight values for the calculation. The reference code utilizes Python's DataFrame mean function which is distinct due to its direct calculation approach. Additionally, the input code depends on a database column 'OrderSize', which the reference code calculates using q-cut on Freight values. Hence, the input does not adhere to the same logic and process as the reference.",None
"What is the total sales revenue for each category? Additionally, create a bar chart to visualize the revenue distribution across categories.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSales 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue distribution across categories
fig = px.bar(df, x='CategoryName', y='TotalSales', title='Total Sales Revenue by Category')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
""""""

total_revenue_df = execute_sql_query(sql_query)

fig = px.bar(total_revenue_df, x='CategoryID', y='TotalRevenue', title='Total Sales Revenue by Category')
show_to_user(fig)
```","The input code does not include the CategoryName in the SELECT clause or GROUP BY clause, only CategoryID. It also factors in the discount during revenue calculation, which isn't present in the reference implementation. Additionally, it does not join the categories table to retrieve the CategoryName needed for clarity in the bar chart.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to execute
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName
""""""

# Execute the SQL query to get the data
sales_data_df = execute_sql_query(sql_query)

# Create a bar chart for the total sales revenue by category
fig = px.bar(sales_data_df, x='CategoryName', y='total_sales', 
             title='Total Sales Revenue by Category', 
             labels={'total_sales': 'Total Sales Revenue', 'CategoryName': 'Category'},
             template='plotly')

# Display the bar chart
show_to_user(fig)
```","The input code differs in logic due to the inclusion of the Discount factor in the calculation of total sales, which is not present in the reference implementation. The reference code calculates total sales based solely on the UnitPrice and Quantity without any discount adjustments. This results in different total sales figures, which means it does not adhere to the same logic as the reference implementation.",None
Which customers placed orders in January that were shipped by a specific shipping method? Include a chart to visualize the number of orders per customer.,"```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT customers.CompanyName, COUNT(orders.OrderID) as NumOrders
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
WHERE EXTRACT(MONTH FROM orders.OrderDate) = 1 AND orders.ShipVia = 1
GROUP BY customers.CompanyName;
'''

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per customer
fig = px.bar(
    orders_data,
    x='CompanyName',
    y='NumOrders',
    title='Number of Orders per Customer in January (Shipped Via Method 1)',
    labels={'CompanyName': 'Customer', 'NumOrders': 'Number of Orders'}
)

# Show the chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the specific shipping method (replace 'SPECIFIC_SHIPPING_METHOD' with the actual ID)
specific_shipping_method = 'SPECIFIC_SHIPPING_METHOD'

# SQL query to retrieve customers who placed orders in January with the specific shipping method
sql_query = f""""""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE EXTRACT(MONTH FROM o.OrderDate) = 1
AND o.ShipVia = {specific_shipping_method}
GROUP BY c.CustomerID, c.CompanyName
""""""

# Execute the SQL query
customer_orders_df = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(customer_orders_df, x='CompanyName', y='OrderCount',
             title='Number of Orders per Customer in January',
             labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer Name'})

# Show the result to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request and follows the same logic as the reference implementation. It retrieves customers who placed orders in January with a specified shipping method, which is achieved through a SQL query. The SQL query includes filtering by the month of the order date and grouping by customer. The same aggregation function (COUNT) is used, and results are grouped by CustomerID and CompanyName just like in the reference implementation. The visualization is also correctly implemented using Plotly Express to create a bar chart showing the number of orders per customer, similar to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL and return a DataFrame
def execute_sql_query(sql_query: str):
    # Placeholder for the actual SQL execution logic.
    # In practice, this will connect to the database and return a DataFrame.
    pass  

# Utility function to display data or figures
def show_to_user(data):
    # Placeholder for the actual display logic
    pass

# SQL Query based on the business analytic request
sql_query = """"""
SELECT DISTINCT customers.CustomerID, customers.CompanyName
FROM customers
INNER JOIN orders ON customers.CustomerID = orders.CustomerID
INNER JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
AND shippers.CompanyName = 'Specific Shipping Method'
""""""

# Execute the SQL query
customers_df = execute_sql_query(sql_query)

# Fetch additional data to count orders per customer for the same period
orders_count_df = execute_sql_query(""""""
SELECT customers.CustomerID, COUNT(orders.OrderID) as OrderCount
FROM customers
INNER JOIN orders ON customers.CustomerID = orders.CustomerID
INNER JOIN shippers ON orders.ShipVia = shippers.ShipperID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
AND shippers.CompanyName = 'Specific Shipping Method'
GROUP BY customers.CustomerID
"""""")

# Merge to include company names in the order count data
merged_df = pd.merge(customers_df, orders_count_df, on='CustomerID')

# Create a bar chart using Plotly to visualize the number of orders per customer
fig = px.bar(merged_df, x='CompanyName', y='OrderCount', title='Number of Orders per Customer in January by Specific Shipping Method')

# Display the chart
show_to_user(fig)
```","The given code doesn't align with the reference implementation in key areas. Firstly, the input code uses shipper's company name (`shippers.CompanyName = 'Specific Shipping Method'`) instead of a specific `orders.ShipVia = 1` condition. This differs from the logic in the reference implementation. Additionally, the SQL query in the input code utilizes `BETWEEN '2023-01-01' AND '2023-01-31'` for January, which is correct but should be aligned with the explicit month extraction seen in the reference. This eventually affects the correctness, as the reference logic relies on EXTRACTing the month directly. Furthermore, the input code includes merging two different query results to form the final dataset, whereas the reference implementation achieves this in a single query. These differences imply that the input code does not match the logic of the reference.",Base
Calculate the total potential revenue for products in stock and create a bar chart to display the revenue by product category.,"```python
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function is implemented elsewhere and returns a DataFrame
    pass

def show_to_user(data):
    # Assume this function is implemented elsewhere for displaying data
    pass

# SQL query to calculate total potential revenue by product category
sql_query = """"""
SELECT 
    categories.CategoryName, 
    SUM(products.UnitPrice * products.UnitsInStock) AS PotentialRevenue
FROM 
    products
JOIN 
    categories ON products.CategoryID = categories.CategoryID
WHERE 
    products.Discontinued = 0
GROUP BY 
    categories.CategoryName;
""""""

# Execute the SQL query
df_revenue = execute_sql_query(sql_query)

# Create a bar chart to display the revenue by product category
fig = px.bar(df_revenue, x='CategoryName', y='PotentialRevenue', 
             title='Potential Revenue by Product Category',
             labels={'PotentialRevenue': 'Potential Revenue', 'CategoryName': 'Product Category'})

# Show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(p.UnitPrice * p.UnitsInStock) AS TotalRevenue
FROM products p
WHERE p.UnitsInStock > 0 AND p.Discontinued = 0
GROUP BY p.CategoryID
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='CategoryID', y='TotalRevenue', title='Total Potential Revenue by Product Category')
show_to_user(fig)
```","The input code does not match the logic of the reference code. The reference query calculates potential revenue by joining the products with categories to display revenue by category name, while the input query calculates revenue only by CategoryID without joining to get the category names. Thus, it doesn't adhere to the business analytics request of showing revenue by product category name.","import pandas as pd
import plotly.express as px

# Sample function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation assumed to fetch data from database
    pass

# Sample function to display data analysis or visualization results
def show_to_user(data):
    # Implementation assumed to display data or figure
    pass

# SQL query to get product data including price, units in stock, and category
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.Category, p.UnitPrice, p.UnitsInStock
FROM products p;
""""""

# Execute the SQL query to get data
product_data = execute_sql_query(sql_query)

# Calculate potential revenue for each product
product_data['PotentialRevenue'] = product_data['UnitPrice'] * product_data['UnitsInStock']

# Calculate total potential revenue for products in stock
total_revenue = product_data['PotentialRevenue'].sum()

# Create a bar chart to display revenue by product category
revenue_by_category = product_data.groupby('Category')['PotentialRevenue'].sum().reset_index()
fig = px.bar(revenue_by_category, x='Category', y='PotentialRevenue', title='Revenue by Product Category')

# Show the bar chart to the user
show_to_user(fig)

# Optionally, we could display the total potential revenue as well
total_revenue_df = pd.DataFrame({'TotalPotentialRevenue': [total_revenue]})
show_to_user(total_revenue_df)","The input code calculates total potential revenue and displays a bar chart by category but does not correctly filter out discontinued products. The reference code includes a filter for 'Discontinued = 0', ensuring only active products are considered, which is missing in the input code.",None
How many returning customers were there in 2023? Include a line graph to show trend changes over each month.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are already defined utility functions.

# SQL query to get the number of returning customers per month in 2023
sql_query = """"""
SELECT 
    DATE_TRUNC('month', o1.OrderDate) AS month, 
    COUNT(DISTINCT o1.CustomerID) AS returning_customers 
FROM 
    orders o1 
WHERE 
    o1.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
    AND o1.CustomerID IN (
        SELECT DISTINCT o2.CustomerID 
        FROM orders o2 
        WHERE o2.OrderDate < '2023-01-01'
    ) 
GROUP BY 
    DATE_TRUNC('month', o1.OrderDate)
ORDER BY 
    month;
""""""

# Execute the SQL query
returning_customers_df = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(returning_customers_df, x='month', y='returning_customers', 
              title='Monthly Returning Customers in 2023', 
              labels={'returning_customers': 'Returning Customers', 'month': 'Month'})

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    COUNT(DISTINCT CustomerID) AS returning_customers
FROM 
    orders
WHERE 
    OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY 
    month
ORDER BY 
    month;
""""""

returning_customers_df = execute_sql_query(sql_query)

fig = px.line(returning_customers_df, x='month', y='returning_customers', title='Returning Customers Trend in 2023')
show_to_user(fig)
```","The input code does not filter for returning customers specifically. It counts all unique customers per month in 2023. The reference code filters for customers who made purchases before 2023, ensuring only returning customers are counted. Additionally, it uses DATE_FORMAT instead of DATE_TRUNC, which might not work identically depending on the SQL dialect.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS order_month,
    COUNT(DISTINCT orders.CustomerID) AS returning_customers
FROM 
    orders 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
    AND orders.CustomerID IN (
        SELECT CustomerID 
        FROM orders 
        WHERE OrderDate < '2023-01-01'
    )
GROUP BY 
    order_month
ORDER BY
    order_month;
""""""

# Execute SQL query and get results in a DataFrame
data = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(
    data, 
    x='order_month', 
    y='returning_customers', 
    title='Monthly Returning Customers in 2023',
    labels={'order_month': 'Month', 'returning_customers': 'Count of Returning Customers'}
)

# Display the figure
show_to_user(fig)
```","The input code correctly retrieves the number of returning customers per month in 2023 using a SQL query, similar to the reference code. The logic for identifying returning customers (those who made a purchase before 2023) is intact. It uses the same structure for the SQL query and the same method to generate and display the line graph using Plotly. Therefore, it adheres to the same logic as the reference implementation.",Finetuned
"Which employee has generated the highest total sales, and can you provide a bar chart to compare the sales of all employees?","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales for each employee
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC;
""""""

# Execute the query and get the data into a DataFrame
df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not df.empty:
    # Get the employee with the highest total sales
    top_employee = df.iloc[0]

    # Print top employee details
    print(f""Employee with highest sales: EmployeeID={top_employee['EmployeeID']}, TotalSales={top_employee['TotalSales']}"")

    # Create a bar chart comparing sales of all employees using Plotly
    fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Total Sales by Employee', labels={'TotalSales':'Total Sales', 'EmployeeID':'Employee ID'})

    # Show the bar chart
    show_to_user(fig)
else:
    print(""No sales data available."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)

highest_sales_employee = sales_data.iloc[0]
bar_chart = px.bar(sales_data, x='EmployeeName', y='TotalSales', title='Total Sales by Employee')

show_to_user(bar_chart)
```","The input code correctly implements the business analytics request by selecting the total sales for each employee, sorting them, and displaying both the highest sales employee and a bar chart of all employees' sales. The key steps and logic align with the reference implementation, such as the SQL query for summing sales per employee, using Plotly to create the bar chart, and showing the chart with `show_to_user`.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation
    pass

def show_to_user(data):
    # Placeholder for actual implementation
    pass

# SQL query to get total sales by employee
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
GROUP BY employees.EmployeeID
ORDER BY TotalSales DESC
""""""

# Execute the query and get the results in a DataFrame
sales_data = execute_sql_query(sql_query)

# Determine the employee with the highest total sales
top_employee = sales_data.head(1)

# Display the top employee's data
show_to_user(top_employee)

# Create a bar chart to compare the sales of all employees
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Total Sales by Employee')

# Show the bar chart to the user
show_to_user(fig)
```","The provided code correctly follows the same business logic as the reference implementation. It executes a SQL query to retrieve total sales for each employee, identifies the employee with the highest sales, and generates a bar chart to visualize the sales data. The use of the 'head(1)' method correctly extracts the top employee, and the order and logic of the query are consistent with the reference. Although the methods for displaying results are placeholders, they are consistent with the intended functionality.",both
Calculate the Customer Lifetime Value for each customer and include a data visualization to compare the values across different customer segments.,"```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    customers.CustomerID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    customers ON orders.CustomerID = customers.CustomerID 
GROUP BY 
    customers.CustomerID
""""""

# Execute SQL query
customer_lifetime_df = execute_sql_query(sql_query)

# Assume we have a column 'Segment' in the customer data for segmentation
# Here, we simulate adding this column for visualization purposes.
# In real case, retrieve segments from SQL or another source
customer_segments = ['A', 'B', 'C', 'A', 'B']  # Example segment data
customer_lifetime_df['Segment'] = customer_segments[:len(customer_lifetime_df)]

# Visualizing Customer Lifetime Value across different segments
fig = px.bar(
    customer_lifetime_df, 
    x='CustomerID', 
    y='customer_lifetime_value', 
    color='Segment',
    title='Customer Lifetime Value by Segment',
    labels={'customer_lifetime_value': 'Customer Lifetime Value ($)', 'CustomerID': 'Customer ID'}
)

# Show to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate Customer Lifetime Value
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value,
       customerDemographics.CustomerDesc AS customer_segment
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN customers ON orders.CustomerID = customers.CustomerID
JOIN customerCustomerDemo ON customers.CustomerID = customerCustomerDemo.CustomerID
JOIN customerDemographics ON customerCustomerDemo.CustomerTypeID = customerDemographics.CustomerTypeID
GROUP BY customers.CustomerID, customerDemographics.CustomerDesc
""""""

# Execute the SQL query
customer_lifetime_value_df = execute_sql_query(sql_query)

# Data visualization
fig = px.bar(customer_lifetime_value_df, 
              x='CustomerID', 
              y='customer_lifetime_value', 
              color='customer_segment', 
              title='Customer Lifetime Value by Segments', 
              labels={'customer_lifetime_value': 'Lifetime Value', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```","The input code accurately computes the Customer Lifetime Value (CLV) using a similar SQL query structure as the reference code, with the addition of joining with customer demographics to incorporate customer segments directly from the database. This differs from the reference implementation, where segments are added manually. The data visualization logic is consistent, utilizing Plotly for creating a bar chart to compare CLV across segments, aligning with the business analytics request. Therefore, the logic and output are correct despite differences in implementation details.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate Customer Lifetime Value
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query
customer_lifetime_value_df = execute_sql_query(sql_query)

# Data visualization using Plotly
fig = px.bar(
    customer_lifetime_value_df,
    x='CustomerID',
    y='customer_lifetime_value',
    title='Customer Lifetime Value by Customer',
    labels={'customer_lifetime_value': 'Customer Lifetime Value', 'CustomerID': 'Customer ID'}
)

# Display the visualization
show_to_user(fig)
```","The input code lacks the customer segmentation component present in the reference implementation. While both scripts correctly calculate Customer Lifetime Value using similar SQL logic, the input code does not account for customer segments in the visualization, a requirement specified in the request. Consequently, the visualization does not compare values across different customer segments as the reference implementation does.",Base
"What is the average lead time for each supplier's deliveries, and can you provide a bar chart to illustrate the differences?","```python
import pandas as pd
import plotly.express as px

# The given SQL query to calculate average lead time for each supplier
sql_query = """"""
SELECT s.CompanyName, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY s.CompanyName;
""""""

# Execute the SQL query and get results in a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to illustrate the differences in average lead time
fig = px.bar(data, x='CompanyName', y='AverageLeadTime', 
             title='Average Lead Time for Each Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})

# Display the bar chart
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    s.SupplierID, 
    s.CompanyName, 
    AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    orders o ON p.ProductID = o.OrderID
GROUP BY 
    s.SupplierID, s.CompanyName
""""""

lead_time_data = execute_sql_query(sql_query)

fig = px.bar(lead_time_data, x='CompanyName', y='AvgLeadTime',
             title='Average Lead Time for Each Supplier',
             labels={'AvgLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'},
             color='AvgLeadTime')

show_to_user(fig)
```","The SQL query in the input code has an error: it incorrectly joins 'products' and 'orders' tables directly on 'ProductID' and 'OrderID', while it should join 'products' with 'Order Details' on 'ProductID' and then join 'Order Details' with 'orders' on 'OrderID'. This mistake will lead to incorrect results while calculating the average lead time.","```python
import pandas as pd
import plotly.express as px

# SQL query provided for execution
sql_query = """"""
SELECT 
    suppliers.SupplierID, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM 
    suppliers 
INNER JOIN 
    products ON suppliers.SupplierID = products.SupplierID 
INNER JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID 
INNER JOIN 
    orders ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    suppliers.SupplierID;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function is defined to execute the SQL query and return a DataFrame
    pass

def show_to_user(data):
    # Assume this function is defined to display DataFrame or Plotly figures
    pass

# Execute the SQL query to get the necessary data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', 
             title='Average Lead Time by Supplier', 
             labels={'AverageLeadTime':'Average Lead Time (days)', 'SupplierID':'Supplier ID'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code calculates average lead time by 'SupplierID' but the reference code uses 'CompanyName'. The chart labels also differ: 'Supplier ID' vs 'CompanyName'. To match the logic, the input should include 'CompanyName' in the SQL query and use it in the bar chart.",None
"What is the total discount given per month in 2023, and can you provide a line chart to visualize these monthly discounts?","
```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve data
sql_query = """"""
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM(UnitPrice * Quantity * Discount) AS TotalDiscount
FROM
    orders O
JOIN
    [Order Details] OD ON O.OrderID = OD.OrderID
WHERE 
    YEAR(OrderDate) = 2023
GROUP BY
    Month;
""""""

# Function to execute the SQL query and return the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: In a real scenario, this would execute the SQL against a database
    # For example, using SQLAlchemy or similar library
    pass

# Function to display data analysis results or visualizations
def show_to_user(data):
    # Placeholder function: In a real scenario, this would display the plot or DataFrame
    # For example, using Streamlit, Dash, or a Jupyter notebook
    pass

# Execute the query and fetch the data
discount_data = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(discount_data, x='Month', y='TotalDiscount', title='Total Discount per Month in 2023')

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].Discount * [Order Details].UnitPrice * [Order Details].Quantity) AS TotalDiscount
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    YEAR(orders.OrderDate) = 2023
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

discounts_df = execute_sql_query(sql_query)

fig = px.line(discounts_df, x='Month', y='TotalDiscount', title='Monthly Discounts in 2023')
show_to_user(fig)
```","The input code correctly calculates the total discount per month for 2023, using similar query logic as the reference implementation. It retrieves the 'Month' and 'TotalDiscount' by joining the 'orders' and 'Order Details' tables, filtering by year, grouping by month, and ordering the results. The visualization step also aligns with the reference code using Plotly to create a line chart, ensuring the business analytics request is fulfilled.","
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM [Order Details] od 
JOIN orders o ON o.OrderID = od.OrderID 
WHERE DATE_PART('year', o.OrderDate) = 2023 
GROUP BY DATE_TRUNC('month', o.OrderDate) 
ORDER BY Month;
""""""

# Execute the SQL query to fetch data
monthly_discounts_df = execute_sql_query(sql_query)

# Ensure the Month column is of datetime type
monthly_discounts_df['Month'] = pd.to_datetime(monthly_discounts_df['Month'])

# Create a line chart to visualize the total discount per month
fig = px.line(
    monthly_discounts_df, 
    x='Month', 
    y='TotalDiscount', 
    title='Total Discount Per Month in 2023',
    labels={'Month': 'Month', 'TotalDiscount': 'Total Discount'},
    markers=True
)

# Show the plot to the user
show_to_user(fig)
","Both codes aim to calculate the total discount given per month in 2023 and visualize it using a line chart. The input code provided uses a different SQL syntax, appropriate for a database like PostgreSQL (DATE_TRUNC, DATE_PART), whereas the reference uses MySQL syntax (DATE_FORMAT, YEAR). Despite these differences, the logical operations are equivalent: calculating monthly aggregates of discounts for orders placed in the year 2023. The input code also includes additional steps to ensure the 'Month' column is a datetime type and adds markers to the line chart, which are acceptable variations but do not affect the correctness of the core logic. Therefore, the input code correctly addresses the business analytics request within the logical framework of the reference implementation.",both
"What is the product with the highest inventory turnover ratio, and can this be visualized in a bar chart to compare across all products?","```python
import pandas as pd
import plotly.express as px

# SQL Query to get inventory turnover ratio for all products
sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS TotalSales,
    AVG(NULLIF(p.UnitsInStock, 0)) AS AvgUnitsInStock
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    p.ProductName;
""""""

# Execute SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Calculate inventory turnover ratio
df['InventoryTurnoverRatio'] = df['TotalSales'] / df['AvgUnitsInStock']

# Find the product with the highest inventory turnover ratio
max_turnover_product = df[df['InventoryTurnoverRatio'] == df['InventoryTurnoverRatio'].max()]

# Display the product with the highest inventory turnover ratio
show_to_user(max_turnover_product)

# Visualize the inventory turnover ratios using a bar chart
fig = px.bar(df, x='ProductName', y='InventoryTurnoverRatio', 
             title='Inventory Turnover Ratio by Product', 
             labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS TotalSales, 
    AVG(p.UnitsInStock) AS AverageInventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, 
    p.ProductName
ORDER BY 
    InventoryTurnoverRatio DESC
""""""

turnover_data = execute_sql_query(sql_query)
highest_turnover_product = turnover_data.iloc[0]

fig = px.bar(turnover_data, x='ProductName', y='InventoryTurnoverRatio', title='Inventory Turnover Ratio by Product')
show_to_user(fig)

highest_turnover_product
```","The input code correctly implements the logic to calculate the inventory turnover ratio, orders the products by this ratio in descending order, and selects the highest one. It visualizes the turnover ratios as a bar chart using Plotly, as requested. The SQL query accurately calculates the ratio and handles potential division by zero, similar to the reference implementation. Despite minor differences such as query ordering and pre-calculating the ratio within SQL, the logic aligns with the business request and reference implementation.","```python
import plotly.express as px
import pandas as pd

# Function to execute
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution code
    # Example: return pd.read_sql(sql_query, connection)
    pass

def show_to_user(data):
    # Display the results to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()
    else:
        raise ValueError(""Unsupported data type"")

# SQL Query
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice) /
       AVG(NULLIF(p.UnitsInStock, 0)) AS InventoryTurnover 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY p.ProductName 
ORDER BY InventoryTurnover DESC;
""""""

# Execute the SQL query and get the DataFrame
inventory_turnover_df = execute_sql_query(sql_query)

# Visualize the inventory turnover using a bar chart
fig = px.bar(inventory_turnover_df, 
             x='ProductName', 
             y='InventoryTurnover', 
             title='Inventory Turnover Ratio by Product',
             labels={'InventoryTurnover':'Inventory Turnover Ratio', 'ProductName':'Product Name'})

# Show the visualization to the user
show_to_user(fig)
```","The provided implementation achieves the same objective as the reference code. It calculates the inventory turnover ratio and visualizes it in a bar chart. Although the calculation of the ratio is done directly in the SQL query instead of as a subsequent step in pandas, the logic remains consistent. It orders the products by turnover in SQL, and both versions show the visualization.",both
How many units of each product are on order? Please include a bar chart to visualize the data for easier comparison.,"```python
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT ProductID, ProductName, UnitsOnOrder FROM products WHERE UnitsOnOrder > 0;
""""""

# Utilize the utility function to execute the query and get the data as a DataFrame
units_on_order_df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the number of units on order for each product
fig = px.bar(
    units_on_order_df,
    x='ProductName',
    y='UnitsOnOrder',
    title='Units on Order for Each Product',
    labels={'UnitsOnOrder': 'Units on Order', 'ProductName': 'Product Name'}
)

# Display the figure using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitsOnOrder 
FROM products
WHERE Discontinued = 0
""""""

product_orders_df = execute_sql_query(sql_query)

fig = px.bar(product_orders_df, x='ProductName', y='UnitsOnOrder', 
             title='Units on Order for Each Product', 
             labels={'UnitsOnOrder': 'Units On Order', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code includes a WHERE clause filtering products that are not discontinued ('WHERE Discontinued = 0'), which doesn't match the reference query condition ('WHERE UnitsOnOrder > 0'). This may exclude products with non-zero 'UnitsOnOrder' that are discontinued, leading to potential discrepancies with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query
sql_query = ""SELECT ProductID, UnitsOnOrder FROM products;""
products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize units on order for each product
fig = px.bar(products_df, x='ProductID', y='UnitsOnOrder', title='Units on Order by Product', labels={'UnitsOnOrder': 'Units on Order', 'ProductID': 'Product ID'})

# Display the figure
show_to_user(fig)
```","The input code is not correct because it includes all products regardless of whether UnitsOnOrder is greater than zero. It should filter out products with UnitsOnOrder of zero. Additionally, it uses 'ProductID' instead of 'ProductName' for the x-axis, which is less informative.",None
How many orders were fulfilled on time this month? Include a line chart illustrating daily fulfillment rates.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the number of on-time orders for the current month
sql_query = """"""
SELECT
    OrderID,
    ShippedDate,
    RequiredDate
FROM
    orders
WHERE
    ShippedDate <= RequiredDate
    AND MONTH(ShippedDate) = MONTH(CURRENT_DATE)
    AND YEAR(ShippedDate) = YEAR(CURRENT_DATE)
""""""

# Function to execute the query and obtain the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for the function which would actually
    # interface with a database to run the provided query.
    # Here, we'll use a placeholder DataFrame.
    return pd.DataFrame({
        'OrderID': [1, 2, 3, 4],
        'ShippedDate': pd.to_datetime(['2023-10-01', '2023-10-02', '2023-10-02', '2023-10-03']),
        'RequiredDate': pd.to_datetime(['2023-10-02', '2023-10-05', '2023-10-02', '2023-10-04'])
    })

# Execute the SQL query and fetch the data
orders_df = execute_sql_query(sql_query)

# Count the number of on-time orders
on_time_orders = len(orders_df)

# Prepare data for daily fulfillment rates
orders_df['Fulfilled'] = orders_df['ShippedDate'] <= orders_df['RequiredDate']
daily_fulfillment = orders_df.groupby('ShippedDate').agg(on_time_orders=('Fulfilled', 'sum')).reset_index()

# Generate the line chart using Plotly
fig = px.line(daily_fulfillment, x='ShippedDate', y='on_time_orders', title='Daily Fulfillment Rates')

# Function to display the visualization
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.line().__class__):
        data.show()

# Display the results to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Define the current month
now = datetime.now()
start_date = now.replace(day=1).strftime('%Y-%m-%d')
end_date = (now.replace(day=1) + pd.DateOffset(months=1)).strftime('%Y-%m-%d')

# Query to get on-time fulfilled orders this month
sql_on_time_query = f""""""
SELECT 
    DATE(ShippedDate) AS fulfillment_date,
    COUNT(OrderID) AS fulfilled_orders
FROM 
    orders
WHERE 
    ShippedDate <= RequiredDate AND 
    OrderDate >= '{start_date}' AND 
    OrderDate < '{end_date}'
GROUP BY 
    DATE(ShippedDate)
""""""

# Execute the query
on_time_fulfillment_df = execute_sql_query(sql_on_time_query)

# Calculate total fulfilled orders this month
total_fulfilled = on_time_fulfillment_df['fulfilled_orders'].sum()

# Create a line chart for daily fulfillment rates
on_time_fulfillment_df['fulfillment_rate'] = on_time_fulfillment_df['fulfilled_orders'] / on_time_fulfillment_df['fulfilled_orders'].sum()
fig = px.line(on_time_fulfillment_df, x='fulfillment_date', y='fulfillment_rate', title='Daily On-Time Fulfillment Rates')

# Show the results
show_to_user(fig)

# Display the count of total orders fulfilled on time
show_to_user(pd.DataFrame({'Total Orders Fulfilled On Time': [total_fulfilled]}))
```","The input code queries 'OrderDate' instead of 'ShippedDate' to filter current month's fulfilled orders, which doesn't align with the reference code logic. Also, it calculates 'fulfillment_rate' as a fraction of daily fulfilled orders over the total fulfilled orders, deviating from using the count of on-time orders as in the reference code. The reference implementation checks for orders where 'ShippedDate' is within the month and compares 'ShippedDate' to 'RequiredDate'.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get on-time order fulfillment for the current month
sql_query = """"""
SELECT 
    orders.OrderDate,
    COUNT(orders.OrderID) AS total_orders,
    SUM(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 ELSE 0 END) AS on_time_orders
FROM orders
WHERE 
    MONTH(orders.OrderDate) = MONTH(CURRENT_DATE) AND 
    YEAR(orders.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY orders.OrderDate
ORDER BY orders.OrderDate
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate the fulfillment rate per day
orders_df['fulfillment_rate'] = orders_df['on_time_orders'] / orders_df['total_orders'] * 100

# Create a line chart showing daily fulfillment rates
fig = px.line(
    orders_df, 
    x='OrderDate', 
    y='fulfillment_rate', 
    title='Daily Fulfillment Rates for Current Month',
    labels={'fulfillment_rate': 'Fulfillment Rate (%)'}
)

# Show the chart to the user
show_to_user(fig)
```","The input code calculates the 'fulfillment_rate' as a percentage for each day by dividing on-time orders by total orders. However, the business request asks for the count of on-time orders, matching logic with the reference implementation. The fulfillment rate should be a simple count of on-time orders per day, not a percentage of total orders. Additionally, the SQL query logic in the input code is different from the reference code in terms of how it defines and calculates 'on_time_orders'.",None
"What is the trend in the number of orders over time, and can a line chart be used to visualize this trend?","
import plotly.express as px
import pandas as pd

# SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Visualize the trend in the number of orders over time using a line chart
fig = px.line(df, x='Month', y='OrderCount', title='Trend in Number of Orders Over Time')

# Show the visualization to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderDate, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY OrderDate
ORDER BY OrderDate
""""""

orders_trend_df = execute_sql_query(sql_query)

fig = px.line(orders_trend_df, x='OrderDate', y='NumberOfOrders', title='Trend in Number of Orders Over Time')
show_to_user(fig)
```","The input code groups by 'OrderDate' instead of truncating to 'month' like the reference code. It shows daily order counts rather than monthly, which does not align with the specified request to identify trends over time in the same manner as the reference code using a monthly aggregation.","```python
import plotly.express as px
import pandas as pd

# SQL query to get data for trend analysis
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Ensure 'Month' column is in datetime format
orders_data['Month'] = pd.to_datetime(orders_data['Month'])

# Create a line chart using Plotly to visualize the trend
line_chart = px.line(
    orders_data, 
    x='Month', 
    y='NumberOfOrders', 
    title='Trend in Number of Orders Over Time',
    labels={'NumberOfOrders': 'Number of Orders', 'Month': 'Month'}
)

# Display the line chart to the user
show_to_user(line_chart)
```","The input Python code performs the same operations as the reference implementation. Both codes execute an SQL query to count the number of orders grouped by month, returning a DataFrame. The input code then converts the 'Month' column to datetime format, which ensures accurate plotting. A line chart is created using Plotly to visualize the trend in the number of orders over time. Both implementations display the chart to the user, fulfilling the business analytics request. Although the variable names differ slightly, the logic and process are equivalent.",Finetuned
Find products with a sales decline over the past three months and visualize the trend using a line chart.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the database query execution
    # Assuming this function connects to a database and returns a DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying the data or visualization
    # Assuming this function handles both DataFrame and Plotly figure objects
    pass

# SQL query to get the necessary products with sales decline
sql_query = """"""
SELECT p.ProductID, p.ProductName, od.OrderDate, od.Quantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID FROM orders 
    WHERE OrderDate BETWEEN DATEADD(MONTH, -3, CURRENT_DATE) AND CURRENT_DATE
)
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Ensure the OrderDate is in datetime format
df['OrderDate'] = pd.to_datetime(df['OrderDate'])

# Aggregate data by ProductID, ProductName, and month
monthly_sales = df.groupby([df['ProductID'], df['ProductName'], df['OrderDate'].dt.to_period('M')])['Quantity'].sum().reset_index()
monthly_sales['OrderDate'] = monthly_sales['OrderDate'].dt.to_timestamp()

# Get the list of products that have declining sales in the last month compared to the previous months
declining_products = monthly_sales.groupby(['ProductID', 'ProductName']).apply(
    lambda group: group.iloc[-1]['Quantity'] < group.iloc[-2:-1]['Quantity'].sum()
)

declining_products = declining_products[declining_products]

# Filter the monthly sales data for these declining products
decline_df = monthly_sales[monthly_sales['ProductID'].isin(declining_products.index.get_level_values('ProductID'))]

# Visualize the trend using a line chart
fig = px.line(
    decline_df,
    x='OrderDate',
    y='Quantity',
    color='ProductName',
    title='Sales Trend for Products with Decline Over Past Three Months'
)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get sales data for the past three months
sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    Orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate >= CURRENT_DATE - INTERVAL '3 months'
GROUP BY 
    p.ProductID, p.ProductName, DATE_TRUNC('month', o.OrderDate)
ORDER BY 
    p.ProductID, Month;
""""""

# Execute the SQL query and load data into DataFrame
sales_data = execute_sql_query(sql_query)

# Pivot the data to get months as columns
pivoted_data = sales_data.pivot(index='ProductID', columns='Month', values='TotalSales').fillna(0)

# Calculate the sales decline by comparing the last three months
pivoted_data['Decline'] = pivoted_data.iloc[:, -1] < pivoted_data.iloc[:, -2]

# Filter products with a decline in sales
declining_products = pivoted_data[pivoted_data['Decline']]

# Prepare data for visualization
visualization_data = sales_data[sales_data['ProductID'].isin(declining_products.index)]

# Create line chart to visualize the sales trend for declining products
fig = px.line(visualization_data, x='Month', y='TotalSales', color='ProductName', title='Sales Trends of Declining Products')

# Show the visualization to the user
show_to_user(fig)
```","The input code incorrectly compares the quantity in the most recent month with only the previous month to identify a decline. The reference code checks if the latest month's quantity is less than the sum of all preceding months within the last three months. Additionally, the input code's SQL query uses DATE_TRUNC, which is not used in the reference code. This changes the data aggregation method, potentially altering the data analysis logic.","```python
import pandas as pd
import plotly.express as px

# Placeholder for the execute_sql_query function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating SQL query execution and returning dummy data
    data = {
        'ProductID': [101, 102, 103],
        'DeclineAmount': [1500, 1300, 1000],
    }
    return pd.DataFrame(data)

# SQL query to find products with sales decline
sql_query = """"""
SELECT p.ProductID, 
       SUM(CASE WHEN MONTH(o.OrderDate)=MONTH(CURRENT_DATE)-1 AND YEAR(o.OrderDate)=YEAR(CURRENT_DATE) THEN od.Quantity ELSE 0 END) - 
       SUM(CASE WHEN MONTH(o.OrderDate)=MONTH(CURRENT_DATE)-3 AND YEAR(o.OrderDate)=YEAR(CURRENT_DATE) THEN od.Quantity ELSE 0 END) AS DeclineAmount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH) AND CURRENT_DATE 
GROUP BY p.ProductID 
HAVING DeclineAmount < 0;
""""""

# Execute the SQL query to get the data
df_decline = execute_sql_query(sql_query)

# Visualize the products with sales decline over the past three months
fig = px.line(df_decline, x='ProductID', y='DeclineAmount', 
              title='Products with Sales Decline Over the Past Three Months',
              labels={'DeclineAmount':'Decline Amount', 'ProductID':'Product ID'})

# Display the visualization
show_to_user(fig)
```","The input code calculates the sales decline differently compared to the reference implementation. The reference code analyzes sales trends over a 3-month period and checks if the last month's sales declined compared to the previous months using a time-series approach. The input code computes a 'DeclineAmount' by calculating the difference in sales between two specific months, not considering the time-series trend as in the reference code. Additionally, the input visualization represents decline based on this incorrect calculation.",None
"What is the average time taken to fulfill orders each month, and can you provide a line chart to visualize the monthly trends?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       AVG(DATE_PART('day', ShippedDate - OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query and return the result as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating the function that executes SQL and returns a DataFrame
    # This function should connect to a database, execute the query, 
    # and return the result as a pandas DataFrame.
    # Here we define a mock version for demonstration purposes.
    data = {
        'Month': ['2023-01-01', '2023-02-01', '2023-03-01'],  # Sample data
        'AvgFulfillmentTime': [4.5, 4.2, 3.8]
    }
    return pd.DataFrame(data)

# Define the function to display data to the user
def show_to_user(data):
    # Assuming this function displays the data or visualization to the user
    # For plotly figures, it would use fig.show(). For demonstration, we pass.
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.line().__class__):
        data.show()

# Obtain the data
df = execute_sql_query(sql_query)

# Generate the line chart using Plotly
fig = px.line(df, x='Month', y='AvgFulfillmentTime', 
              title='Average Fulfillment Time per Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)', 'Month': 'Month'})

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS Avg_Fulfillment_Time
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='Month', y='Avg_Fulfillment_Time', 
              title='Average Order Fulfillment Time per Month',
              labels={'Avg_Fulfillment_Time': 'Average Fulfillment Time (Days)', 'Month': 'Month'})

show_to_user(fig)
```","The input code correctly calculates the average fulfillment time by month and visualizes it using a line chart. It uses DATE_FORMAT and DATEDIFF functions, which are standard in SQL for formatting dates and calculating differences. The logic aligns with the reference code that uses DATE_TRUNC and DATE_PART functions. Although the SQL functions vary due to possible database dialect differences, the overall logic and output are consistent with the reference implementation.","
```python
import pandas as pd
import plotly.express as px

# Assuming the execute_sql_query function is defined elsewhere as per the constraints.
def main():
    sql_query = """"""
    SELECT 
        TO_CHAR(orders.OrderDate, 'YYYY-MM') AS month, 
        AVG((orders.ShippedDate - orders.OrderDate)) AS avg_fulfillment_time 
    FROM orders 
    GROUP BY TO_CHAR(orders.OrderDate, 'YYYY-MM');
    """"""
    
    # Execute the SQL query to get the data
    data_df = execute_sql_query(sql_query)
    
    # Display the DataFrame to the user
    show_to_user(data_df)
    
    # Create a line chart to visualize the monthly trends
    fig = px.line(
        data_df, 
        x='month', 
        y='avg_fulfillment_time', 
        title='Average Fulfillment Time per Month',
        labels={'avg_fulfillment_time': 'Average Fulfillment Time (days)'}
    )
    
    # Display the chart
    show_to_user(fig)

# Execute the main function
if __name__ == ""__main__"":
    main()
```

","The input Python code correctly calculates the average fulfillment time per month using SQL. It groups by month and calculates the average days between the order and shipped dates just like the reference implementation. It then uses Plotly to create a line chart to visualize the data, similar to the reference implementation. The minor difference in SQL syntax does not affect the logic or output, as both codes achieve the same objective.",both
What percentage of orders were placed by returning customers? Can this be represented in a pie chart?,"```python
import pandas as pd
import plotly.express as px

def analyze_returning_customer_percentage():
    # SQL query to fetch the percentage of orders from returning customers
    sql_query = """"""
    SELECT 
        COUNT(DISTINCT o.CustomerID) * 100.0 / 
        (SELECT COUNT(DISTINCT CustomerID) FROM orders WHERE OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR)) 
        AS ReturningCustomerPercentage 
    FROM orders o 
    WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) 
    AND o.CustomerID IN 
        (SELECT CustomerID FROM orders WHERE OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR));
    """"""
    
    # Execute the SQL query and get results into a DataFrame
    result_df = execute_sql_query(sql_query)
    
    # Calculate the percentage of returning and new customers
    returning_percentage = result_df['ReturningCustomerPercentage'][0]
    new_percentage = 100 - returning_percentage
    
    # Create a DataFrame for the pie chart
    pie_data = pd.DataFrame({
        'Customer Type': ['Returning Customers', 'New Customers'],
        'Percentage': [returning_percentage, new_percentage]
    })
    
    # Create a pie chart using Plotly
    fig = px.pie(pie_data, values='Percentage', names='Customer Type', 
                 title='Percentage of Orders by Returning Customers')
    
    # Show the pie chart
    show_to_user(fig)

# Call the function to perform the analysis and visualization
analyze_returning_customer_percentage()
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of total orders and returning customer orders
sql_query = """"""
SELECT 
    COUNT(DISTINCT OrderID) AS TotalOrders,
    COUNT(DISTINCT CASE WHEN CustomerID IN 
        (SELECT CustomerID FROM customers WHERE CustomerID IN 
            (SELECT CustomerID FROM orders GROUP BY CustomerID HAVING COUNT(OrderID) > 1)) 
        THEN OrderID END) AS ReturningCustomerOrders
FROM orders
""""""

# Execute the SQL query and retrieve data
result_df = execute_sql_query(sql_query)

# Calculate the percentage of orders placed by returning customers
total_orders = result_df['TotalOrders'][0]
returning_customer_orders = result_df['ReturningCustomerOrders'][0]

percentage_returning = (returning_customer_orders / total_orders) * 100

# Prepare data for pie chart
data = {
    'Customer Type': ['Returning Customers', 'New Customers'],
    'Percentage': [percentage_returning, 100 - percentage_returning]
}
pie_df = pd.DataFrame(data)

# Create a pie chart
fig = px.pie(pie_df, names='Customer Type', values='Percentage', title='Percentage of Orders by Customer Type')

# Show the result to the user
show_to_user(fig)
```","The input code calculates the percentage of orders from returning customers based on order IDs, not distinct customer IDs, which is different from the reference logic. The reference code determines this percentage by comparing distinct returning customers within a specific time frame. Thus, the input code doesn't adhere to the same business logic.","```python
import plotly.express as px
import pandas as pd

# Given SQL query
sql_query = """"""
SELECT (COUNT(DISTINCT CASE WHEN c.CustomerID IN (
    SELECT DISTINCT o.CustomerID FROM orders o
    WHERE o.OrderDate < CURRENT_DATE()
) THEN orders.OrderID END) / 
COUNT(DISTINCT orders.OrderID)) * 100 AS ReturningCustomerPercentage 
FROM orders
""""""

# Execute the SQL query and get the result in a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation of this function is provided in the environment
    pass

# Function to display data analysis results
def show_to_user(data):
    # Implementation of this function is provided in the environment
    pass

# Execute the SQL query
df = execute_sql_query(sql_query)

# Retrieve the returning customer percentage
returning_percentage = df['ReturningCustomerPercentage'].iloc[0]

# Create a summary DataFrame for the pie chart
summary_df = pd.DataFrame({
    ""Category"": [""Returning Customers"", ""New Customers""],
    ""Percentage"": [returning_percentage, 100 - returning_percentage]
})

# Create a pie chart
fig = px.pie(summary_df, names='Category', values='Percentage',
             title='Percentage of Orders by Returning Customers')

# Show the pie chart
show_to_user(fig)
```","The provided code calculates the percentage of returning customers incorrectly. It checks if each order is from a customer who placed any order in the past, but it does not limit the previous orders to those made over a year ago, as specified in the reference. Therefore, it fails to filter returning customers correctly against the criteria that the reference implementation specifies.",None
"How much revenue did each region generate, and can you visualize the results using a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to get revenue per region
sql_query = """"""
SELECT ShipRegion, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Revenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipRegion;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue by region
fig = px.bar(data, x='ShipRegion', y='Revenue', title='Revenue by Region', labels={'ShipRegion': 'Region', 'Revenue': 'Revenue ($)'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.Region, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY s.Region
""""""

revenue_by_region = execute_sql_query(sql_query)

fig = px.bar(revenue_by_region, x='Region', y='Revenue', title='Revenue by Region')
show_to_user(fig)
```","The input code calculates revenue by joining tables through 'ProductID' and 'SupplierID', incorrectly using suppliers' region instead of shipping region. The reference code uses 'ShipRegion' from orders, which aligns with the business request.","```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented already, returning a DataFrame
    # after executing the given SQL query using a database connection.
    pass

# Utility function to display data
def show_to_user(data):
    # This function is assumed to be implemented already.
    pass

# SQL query to fetch revenue data by region
sql_query = """"""
SELECT region, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY region;
""""""

# Execute the SQL query and get the result as a DataFrame
df_revenue_by_region = execute_sql_query(sql_query)

# Create a bar chart using Plotly for visualizing the revenue by region
fig = px.bar(df_revenue_by_region, x='region', y='total_revenue',
             title='Total Revenue by Region',
             labels={'total_revenue': 'Total Revenue'},
             template='plotly')

# Display the bar chart to the user
show_to_user(fig)
```","The input code is incorrect due to two main issues: the SQL query references a table named 'customers' instead of using 'orders' directly for 'ShipRegion', and the query uses 'region' which may not match 'ShipRegion' as specified in the original request. The logic for calculating revenue is otherwise consistent with the reference implementation. The visualization is correctly implemented using Plotly.",None
Which employee has the highest total sales so far this year? Provide a bar chart to visualize the top-performing employees' sales.,"```python
import pandas as pd
import plotly.express as px

# Given SQL query for executing and retrieving employee sales data
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
""""""

# Fetch data using the provided utility function
sales_df = execute_sql_query(sql_query)

# Filter to top employees based on total sales
top_employees_df = sales_df.head(10)  # Assuming visualization for top 10

# Create a bar chart using Plotly
fig = px.bar(
    top_employees_df,
    x='EmployeeID',
    y='TotalSales',
    title='Top Performing Employees by Total Sales - Current Year',
    labels={'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'}
)

# Display the visualized figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by employee for the current year
sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) = YEAR(CURDATE())
GROUP BY 
    e.EmployeeID
ORDER BY 
    TotalSales DESC
LIMIT 10;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(sales_data, x='EmployeeName', y='TotalSales', title='Top Performing Employees Sales', labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee Name'})

# Show the result to the user
show_to_user(fig)
```","The input code correctly addresses the task by selecting employees with the highest sales for the current year. It constructs the SQL query similarly, ensuring total sales are summed up appropriately and orders the results by sales. Additionally, it includes concatenating employee names for improved readability in the visualization, which aligns with additional user-friendliness and does not alter the intended logic. The use of LIMIT in the SQL query directly returns the top 10 results for visualization and the plot is created and displayed using Plotly, fulfilling the requirement to visualize the top-performing employees.","```python
import plotly.express as px
import pandas as pd

# Assume the execute_sql_query function is predefined
sales_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY e.EmployeeID, e.FirstName, e.LastName 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query and get the results in a DataFrame
sales_data = execute_sql_query(sales_query)

# Extract the top performer, if needed, or visualized all for comparison
# top_performer = sales_data.head(1)  # Optional: could use it to highlight only the top performer

# Create a bar chart using Plotly
fig = px.bar(sales_data, 
             x='FirstName', 
             y='TotalSales', 
             text='TotalSales', 
             title='Top Performing Employees by Sales This Year',
             labels={'FirstName': 'Employee Name', 'TotalSales': 'Total Sales'},
             hover_data={'LastName': True})

# Display the bar chart
show_to_user(fig)
```","The input code meets the business analytics request by identifying employees with the highest total sales this year and visualizing them with a bar chart. It extends the reference code by including 'FirstName' and 'LastName' in the query for better clarity, but still orders them by 'TotalSales' and plots them using Plotly. These differences remain consistent with the logic in the reference code. Therefore, the input code can be considered correct.",both
What are the top 3 employees by sales amount? Include a bar chart to visualize the sales amounts of these employees.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 3 employees by sales amount
sql_query = """"""
SELECT EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS SalesAmount 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY EmployeeID 
ORDER BY SalesAmount DESC 
LIMIT 3
""""""

# Assuming this function is defined to execute SQL and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the actual implementation
    pass

# Assuming this function is defined to show plotly figures or pandas DataFrame
def show_to_user(data):
    # This is a placeholder for the actual implementation
    pass

# Execute the SQL query and get the results in a DataFrame
df_top_employees = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 3 employees' sales amounts using Plotly
fig = px.bar(df_top_employees, x='EmployeeID', y='SalesAmount',
             title='Top 3 Employees by Sales Amount',
             labels={'SalesAmount': 'Sales Amount', 'EmployeeID': 'Employee ID'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders AS o
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY o.EmployeeID
ORDER BY TotalSales DESC
LIMIT 3
""""""

top_employees = execute_sql_query(sql_query)

fig = px.bar(top_employees, 
             x='EmployeeID', 
             y='TotalSales', 
             title='Top 3 Employees by Sales Amount',
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales Amount'},
             color='TotalSales')

show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation, which is to find the top 3 employees by sales amount. Both implementations execute a similar SQL query, grouping by EmployeeID, calculating the total sales, and ordering by sales in descending order. The input code correctly uses Plotly to create a bar chart visualizing the top 3 employees' sales amounts. The only differences are in SQL aliasing and Plotly color specification, which do not affect the correctness of the solution.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve top 3 employees by sales amount
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
""""""

# Execute the SQL query and store the result in a DataFrame
top_employees_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales amounts of the top 3 employees
fig = px.bar(top_employees_df, 
             x='EmployeeID', 
             y='TotalSales', 
             title='Top 3 Employees by Sales Amount',
             labels={'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Display the bar chart to the user
show_to_user(fig)
```","The provided code correctly adheres to the logic of the reference code, using a similar approach to execute an SQL query to retrieve the top 3 employees by sales amount. The query correctly joins the necessary tables and computes the sales totals using the same calculation. It also visualizes the results using a Plotly bar chart, similar to the reference implementation.",both
"Which employee had the highest sales last month, and can you provide a bar chart to visualize the sales of each employee?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
    AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) 
GROUP BY 
    employees.EmployeeID 
ORDER BY 
    TotalSales DESC
""""""

# Function to execute SQL query and return data in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder: Replace with actual database connection and query execution
    # Example: df = pd.read_sql(sql_query, connection)
    # Simulated result for illustration
    data = {
        'EmployeeID': [1, 2, 3],  # Dummy employee IDs
        'TotalSales': [2000, 1500, 2500]  # Dummy sales data
    }
    df = pd.DataFrame(data)
    return df

# Execute the SQL query
sales_df = execute_sql_query(sql_query)

# Find the employee with the highest sales
highest_sales_employee = sales_df.loc[sales_df['TotalSales'].idxmax()]

# Create a bar chart for visualization using Plotly
fig = px.bar(sales_df, x='EmployeeID', y='TotalSales', title='Sales by Employee for Last Month')

# Display visualization
def show_to_user(data):
    # Simulation for the function that will display the output
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Show the bar chart to the user
show_to_user(fig)

# Output the result of the highest sales employee
show_to_user(pd.DataFrame([highest_sales_employee]))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_FORMAT(CURRENT_DATE - INTERVAL 1 MONTH, '%Y-%m-01') 
  AND o.OrderDate < DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC;
""""""

sales_data = execute_sql_query(sql_query)

highest_sales_employee = sales_data.iloc[0]
bar_chart = px.bar(sales_data, x='EmployeeName', y='TotalSales', title='Employee Sales Last Month')

show_to_user(bar_chart)

highest_sales_employee
```","Both the reference and input code aim to determine the employee with the highest sales in the previous month and visualize it using a bar chart. The input code correctly retrieves sales data, computes the total for each employee, and uses Plotly for visualization. It also considers the same business logic for calculating monthly sales by using SQL to filter orders based on the previous month's date range and applies the same aggregation to calculate 'TotalSales'. The differences, such as the inclusion of 'EmployeeName', do not affect the correctness concerning the business request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch sales data for each employee for the last month
sql_query = """"""
SELECT EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS EmployeeSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE OrderDate = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' 
GROUP BY EmployeeID 
""""""

# Execute the SQL query and get the results as a DataFrame
df_sales = execute_sql_query(sql_query)

# Identify the employee with the highest sales
highest_sales_employee = df_sales.loc[df_sales['EmployeeSales'].idxmax()]

# Create a bar chart to visualize the sales of each employee
fig = px.bar(df_sales, x='EmployeeID', y='EmployeeSales', title='Employee Sales for Last Month')

# Display the bar chart
show_to_user(fig)

# Optionally, display the employee with the highest sales
highest_sales_info = pd.DataFrame([highest_sales_employee])
show_to_user(highest_sales_info)
```","The input code does not correctly filter the orders for the last month. It uses DATE_TRUNC to get the first day of the current month, but it applies it in a way that only retrieves orders from exactly one day last month. The reference code correctly handles the last month by checking both the month and the year, ensuring it accounts for all days in the previous month. Fixing this logic is required for the input code to align with the reference implementation and answer the business question correctly.",Base
"What is the shipping cost per order for each shipping method, and can you provide a comparative bar chart to visualize the differences?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average shipping cost per shipping method
sql_query = """"""
SELECT ShipVia, AVG(Freight) AS avg_shipping_cost 
FROM orders 
GROUP BY ShipVia
""""""

# Function to execute the SQL query and get the data as a DataFrame
df = execute_sql_query(sql_query)

# Create a comparative bar chart using Plotly
fig = px.bar(
    df,
    x='ShipVia',
    y='avg_shipping_cost',
    title='Average Shipping Cost per Shipping Method',
    labels={'ShipVia': 'Shipping Method', 'avg_shipping_cost': 'Average Shipping Cost'},
    color='ShipVia'
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName AS shipping_method, 
       AVG(orders.Freight) AS shipping_cost_per_order 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName
""""""

shipping_cost_data = execute_sql_query(sql_query)

fig = px.bar(shipping_cost_data, 
             x='shipping_method', 
             y='shipping_cost_per_order', 
             title='Shipping Cost per Order by Shipping Method', 
             labels={'shipping_method': 'Shipping Method', 'shipping_cost_per_order': 'Shipping Cost per Order'})

show_to_user(fig)
```","Both implementations aim to calculate the average freight cost per shipping method from an 'orders' dataset. The input Python code calculates the average shipping cost per 'shippers.CompanyName' using a join on the 'shippers' table, while the reference uses 'ShipVia'. Both approaches are logically equivalent, aggregating by shipping method and calculating average freight. The input code correctly adapts the query and uses Plotly to generate a comparative bar chart similar to the reference. Hence, it adheres to the required logic and answers the business question effectively.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY ShipVia;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate SQL query execution
    # In a real scenario, this would interface with a database
    raise NotImplementedError(""This should connect to your database and execute the query."")

def show_to_user(data):
    # Placeholder function to display data
    # In a real scenario, this would print data or display a plot
    raise NotImplementedError(""This should display the data or visualization."")

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipVia', y='AvgShippingCost', title='Average Shipping Cost per Method')

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly calculates the average shipping cost per shipping method using SQL and creates a comparative bar chart with Plotly. The differences in capitalization in column naming ('avg_shipping_cost' vs 'AvgShippingCost') and minor changes in labels and titles do not affect the logic or outcome of the implementation. Therefore, it adheres to the same logic as the reference implementation.",both
"  
""What are the products with below-average sales but above-average stock levels? Include a scatter plot to visualize the relationship between sales and stock levels for these products.""  ","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query is already defined
# Assume show_to_user is already defined

# SQL to get below-average sales but above-average stock products
sql_query = """"""
SELECT ProductName, SUM(Quantity) AS TotalSales, AVG(products.UnitsInStock) AS AvgStock
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY ProductName
HAVING SUM(Quantity) < (SELECT AVG(total_quantity) FROM (SELECT SUM(Quantity) AS total_quantity FROM [Order Details] GROUP BY ProductID) AS subquery)
AND AVG(products.UnitsInStock) > (SELECT AVG(UnitsInStock) FROM products)
""""""

# Execute SQL query and get the data
data = execute_sql_query(sql_query)

# Scatter plot to visualize the relationship between sales and stock levels
fig = px.scatter(data, x='TotalSales', y='AvgStock', text='ProductName', title='Products with Below-Average Sales but Above-Average Stock Levels')
fig.update_traces(textposition='top center')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Retrieve sales data
sales_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalSales
FROM [Order Details] od
GROUP BY od.ProductID
""""""
sales_data = execute_sql_query(sales_query)

# Retrieve stock data
stock_query = """"""
SELECT p.ProductID, p.UnitsInStock
FROM products p
""""""
stock_data = execute_sql_query(stock_query)

# Merge sales and stock data
product_data = pd.merge(sales_data, stock_data, on='ProductID')

# Calculate averages
average_sales = product_data['TotalSales'].mean()
average_stock = product_data['UnitsInStock'].mean()

# Filter for below-average sales and above-average stock
filtered_products = product_data[(product_data['TotalSales'] < average_sales) & 
                                  (product_data['UnitsInStock'] > average_stock)]

# Create scatter plot
fig = px.scatter(filtered_products, x='TotalSales', y='UnitsInStock', 
                 hover_data=['ProductID'], 
                 title='Products with Below-Average Sales and Above-Average Stock Levels',
                 labels={'TotalSales': 'Total Sales', 'UnitsInStock': 'Units In Stock'})

# Show the filtered products and scatter plot
show_to_user(filtered_products)
show_to_user(fig)
```","The input code retrieves total sales and stock data separately, then merges them based on ProductID. It computes average sales and stock levels, and filters products with below-average sales and above-average stock, matching the logic of the reference implementation. The input adds a scatter plot with the same purpose, showing the relationship between sales and stock levels for these filtered products. Therefore, it adheres to the business analytics request effectively.","```python
import pandas as pd
import plotly.express as px

# Define SQL query to find products with below-average sales and above-average stock levels
sql_query = """"""
SELECT p.ProductName, p.UnitsInStock, SUM(od.Quantity) as TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName, p.UnitsInStock
HAVING SUM(od.Quantity) < (SELECT AVG(TotalSales) FROM 
                             (SELECT SUM(od2.Quantity) AS TotalSales 
                              FROM [Order Details] od2 
                              JOIN products p2 ON p2.ProductID = od2.ProductID 
                              GROUP BY p2.ProductID) AS Subquery1)
AND p.UnitsInStock > (SELECT AVG(UnitsInStock) FROM products)
""""""

# Execute the SQL query and return a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Create the scatter plot using Plotly
fig = px.scatter(
    products_df, 
    x='TotalSales', 
    y='UnitsInStock', 
    text='ProductName',
    labels={
        ""TotalSales"": ""Total Sales"",
        ""UnitsInStock"": ""Units In Stock""
    },
    title=""Products with Below-Average Sales but Above-Average Stock Levels""
)

# Add hover data for better understanding
fig.update_traces(textposition='top center')

# Display the scatter plot
show_to_user(fig)
```","The input code correctly retrieves products with below-average sales and above-average stock levels using a similar logic to the reference implementation. It uses SQL aggregation to calculate total sales per product and compares these to the average values. Both implementations join the 'products' and 'Order Details' tables and filter results based on calculated averages. The visualization part matches the requirements and uses a scatter plot with appropriate labels and titles, similar to the reference.",both
"Which product had the highest sales volume last quarter, and can we visualize this using a bar chart for comparison?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM `Order Details` od
JOIN orders o ON od.OrderID = o.OrderID
WHERE QUARTER(o.OrderDate) = QUARTER(CURDATE() - INTERVAL 3 MONTH)
AND YEAR(o.OrderDate) = YEAR(CURDATE() - INTERVAL 3 MONTH)
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
LIMIT 1;
""""""

# Execute the SQL query to fetch the data
data_df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
if not data_df.empty:
    fig = px.bar(data_df, x='ProductID', y='TotalQuantity',
                 labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'},
                 title='Sales Volume by Product for Last Quarter')
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Message': ['No data available for the last quarter.']}))
```","```python
import pandas as pd
import plotly.express as px

# Define the last quarter date range
last_quarter_start = '2023-07-01'
last_quarter_end = '2023-09-30'

# SQL query to get total sales per product in the last quarter
sql_query = f""""""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate BETWEEN '{last_quarter_start}' AND '{last_quarter_end}'
GROUP BY 
    od.ProductID
ORDER BY 
    TotalSales DESC
LIMIT 10
""""""

# Execute the SQL query and return a DataFrame
sales_data = execute_sql_query(sql_query)

# Find the product with the highest sales volume
highest_sales_product = sales_data.iloc[0]

# Visualization of the sales data
fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Sales Volume per Product Last Quarter')
show_to_user(fig)
```","The input code evaluates 'TotalSales' (considering price and discount) instead of 'TotalQuantity' for products. The business analytics request asks for the highest sales volume, which implies quantity, not total sales value. The input code also limits the results to the top 10 products by sales value, whereas the reference code selects only the product with the highest quantity sold. Lastly, the input code uses a fixed date range instead of dynamically determining the last quarter as in the reference.","```python
import pandas as pd
import plotly.express as px

# Assume the utility functions are defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # Should return a pandas DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    pass

# SQL query to fetch product sales data for last quarter
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS product_quantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE QUARTER(orders.OrderDate) = QUARTER(CURDATE()) - 1 
AND YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY products.ProductID 
ORDER BY product_quantity DESC 
LIMIT 1
""""""

# Execute the SQL query and get results in a DataFrame
product_sales_df = execute_sql_query(sql_query)

# Extract the product name with the highest sales volume
highest_selling_product = product_sales_df.iloc[0]

# Visualization using a bar chart for comparison among products
# Modify the limit in the SQL query if needed
comparison_sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS product_quantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE QUARTER(orders.OrderDate) = QUARTER(CURDATE()) - 1 
AND YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY products.ProductID 
ORDER BY product_quantity DESC
""""""

# Execute the modified query to get data for all products
comparison_df = execute_sql_query(comparison_sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    comparison_df,
    x='ProductName',
    y='product_quantity',
    title=""Product Sales Volume Comparison for Last Quarter"",
    labels={'ProductName': 'Product Name', 'product_quantity': 'Sales Volume'}
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code and reference code differ in their logic for identifying the relevant quarter. The reference code adjusts both the year and quarter to calculate the last quarter from the current date by using CURRENT_DATE - INTERVAL 3 MONTHS, while the input code adjusts only the quarter using QUARTER(CURDATE()) - 1 without considering year difference. This can lead to incorrect quarter computation if the current date is in the first quarter of a year. Additionally, the input code treats '[Order Details]' as a distinct SQL table rather than using an alias, which may cause issues in SQL syntax depending on the database being used.",None
"What are the total sales for each shipping country, and can you provide a bar chart to visualize the results?","
```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales by shipping country
sql_query = """"""
SELECT ShipCountry, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
       (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipCountry;
""""""

# Execute SQL query using the provided utility function
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total sales for each shipping country
fig = px.bar(sales_data, 
             x='ShipCountry', 
             y='TotalSales', 
             title='Total Sales by Shipping Country',
             labels={'TotalSales': 'Total Sales', 'ShipCountry': 'Shipping Country'})

# Show the visualization to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.ShipCountry, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.ShipCountry
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ShipCountry', y='TotalSales', 
             title='Total Sales by Shipping Country', 
             labels={'TotalSales': 'Total Sales', 'ShipCountry': 'Shipping Country'})

show_to_user(fig)
```","The input code is functionally equivalent to the reference implementation. Both codes execute a SQL query to calculate the total sales for each shipping country by joining the 'orders' and 'Order Details' tables, grouping by 'ShipCountry', and summing the sales. They both use Plotly's bar chart to visualize the results and display the chart to the user. The variable names and slight variations in SQL aliasing do not affect the logic or functionality.","import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT 
    o.ShipCountry, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM 
    orders o 
JOIN 
    [Order Details] od 
ON 
    o.OrderID = od.OrderID 
GROUP BY 
    o.ShipCountry;
""""""

# Execute the SQL query and get the results as a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total sales by shipping country
fig = px.bar(sales_data, x='ShipCountry', y='TotalSales', title='Total Sales by Shipping Country')

# Display the bar chart to the user
show_to_user(fig)","The input Python code performs the same operations as the reference implementation: it executes a SQL query that sums the total sales for each shipping country and utilizes Plotly to create a bar chart of the results. Both codes join the 'orders' and '[Order Details]' tables on 'OrderID', calculate 'TotalSales', and group by 'ShipCountry'. The difference in table aliasing does not affect the core logic or functionality, ensuring correctness in answering the business request.",both
What is the rate of orders with a fulfillment time under 5 days? Can you include a trend line chart to visualize fulfillment times over the past year?,"```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation assumed to be provided; returns a DataFrame
    pass

# Function to display data analysis or Plotly figure
def show_to_user(data):
    # Implementation assumed to be provided
    pass

# SQL query to calculate the rate of orders with fulfillment time under 5 days
quick_fulfillment_sql = """"""
SELECT (
    CAST(COUNT(CASE WHEN DATEDIFF(ShippedDate, OrderDate) < 5 THEN OrderID END) AS FLOAT) 
    / COUNT(OrderID)
) * 100 AS QuickFulfillmentRate 
FROM orders;
""""""

# Execute the SQL query
quick_fulfillment_df = execute_sql_query(quick_fulfillment_sql)

# Show the quick fulfillment rate
show_to_user(quick_fulfillment_df)

# SQL query to get fulfillment times over the past year
trend_sql = """"""
SELECT OrderDate, DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE OrderDate >= DATEADD(year, -1, GETDATE());
""""""

# Execute the SQL query for trend data
trend_df = execute_sql_query(trend_sql)

# Create a trend line chart using Plotly
fig = px.line(
    trend_df,
    x='OrderDate',
    y='FulfillmentTime',
    title='Fulfillment Time Trend Over the Past Year',
    labels={'OrderDate': 'Order Date', 'FulfillmentTime': 'Fulfillment Time (Days)'}
)

# Display the trend line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate fulfillment times and filter orders
sql_query = """"""
SELECT 
    OrderID,
    DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime,
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
    AND OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate the rate of orders with fulfillment time under 5 days
orders_under_5_days = orders_df[orders_df['FulfillmentTime'] < 5]
fulfillment_rate = len(orders_under_5_days) / len(orders_df)

# Group by month to create a trend line
trend_df = orders_df.groupby('OrderMonth').mean().reset_index()

# Create a trend line chart
fig = px.line(trend_df, x='OrderMonth', y='FulfillmentTime', title='Average Fulfillment Time Over the Past Year')
show_to_user(fig)

fulfillment_rate
```","The input code calculates the fulfillment rate correctly by dividing the number of orders under 5 days by the total number of orders. However, it calculates the average fulfillment time grouped by month, which deviates from the reference code that calculates daily fulfillment times. Additionally, the SQL query in the input code filters orders by 'OrderMonth' using DATE_FORMAT, thereby altering the trend analysis logic, deviating from the reference implementation's daily trend tracking.","```python
import pandas as pd
import plotly.express as px
import datetime

# Define the SQL query to get the fulfillment time data
sql_query_fulfillment_times = """"""
SELECT 
    ShippedDate, 
    DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTimeInDays 
FROM orders;
""""""

# Execute the SQL query to get the fulfillment times
fulfillment_times_df = execute_sql_query(sql_query_fulfillment_times)

# Filter the data for fulfillment times under 5 days
under_5_days_df = fulfillment_times_df[fulfillment_times_df['FulfillmentTimeInDays'] < 5]

# Calculate the rate of orders with a fulfillment time under 5 days
rate_under_5_days = len(under_5_days_df) / len(fulfillment_times_df)

# Prepare the data for the trend line chart
# Filter data for the past year
past_year_date = datetime.datetime.now() - pd.DateOffset(years=1)
trend_data_df = fulfillment_times_df[fulfillment_times_df['ShippedDate'] >= past_year_date]

# Create a trend line chart using Plotly
fig = px.line(trend_data_df, x='ShippedDate', y='FulfillmentTimeInDays', 
              title='Trend of Fulfillment Times Over the Past Year', 
              labels={'FulfillmentTimeInDays': 'Fulfillment Time (Days)', 'ShippedDate': 'Date'})

# Show the trend line chart to the user
show_to_user(fig)

# Display the rate of orders with fulfillment time under 5 days
rate_df = pd.DataFrame({'RateUnder5Days': [rate_under_5_days]})
show_to_user(rate_df)
```","The input Python code correctly calculates the rate of orders with a fulfillment time under 5 days by filtering the DataFrame for records where 'FulfillmentTimeInDays' is less than 5 and dividing by the total number of orders. The trend line chart is plotted for fulfillment times over the past year using 'ShippedDate' and 'FulfillmentTimeInDays', which aligns with the logic of the reference implementation. The calculation of rates and the visualization of data are consistent with the business analytics request.",Finetuned
"Who are the top 5 sales employees based on total sales, and can you provide a bar chart to visualize their performance?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the top 5 sales employees based on total sales
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Function to execute the SQL query and retrieve the data
def execute_sql_query(sql_query: str):
    # Dummy implementation, replace with actual database connection and execution logic
    data = {
        'EmployeeID': [1, 2, 3, 4, 5],
        'TotalSales': [5000, 4500, 4000, 3500, 3000]
    }
    return pd.DataFrame(data)

# Fetching the top 5 sales employees
sales_data = execute_sql_query(sql_query)

# Create bar chart using Plotly to visualize the performance of top 5 sales employees
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Top 5 Sales Employees by Total Sales')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 5;
""""""

top_sales_employees = execute_sql_query(sql_query)

fig = px.bar(top_sales_employees, x=top_sales_employees[""FirstName""] + "" "" + top_sales_employees[""LastName""], 
              y='TotalSales', title='Top 5 Sales Employees', labels={'x': 'Employee', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code correctly identifies the top 5 sales employees by total sales and visualizes their performance using a similar logic to the reference implementation. The input code differs slightly in that it retrieves the first and last names of employees and concatenates them for labeling the bar chart, which is an acceptable variation that fulfills the business analytics request. The logic of aggregation, ordering, and limiting results is consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

def execute_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for executing the SQL query.
    # In practice, this would interface with your database to return a DataFrame.
    pass

def show_to_user(data):
    # Placeholder function to display results.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch the top 5 sales employees based on total sales
sql_query = """"""
SELECT employees.EmployeeID, 
       employees.FirstName, 
       employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC 
LIMIT 5
""""""

# Execute the SQL query and get a DataFrame
top_sellers_df = execute_query(sql_query)

# Create a bar chart using Plotly to visualize the top 5 sales employees
fig = px.bar(top_sellers_df, 
             x='FirstName', 
             y='total_sales', 
             title='Top 5 Sales Employees',
             labels={'total_sales': 'Total Sales ($)', 'FirstName': 'First Name'},
             text='total_sales')

# Format the bar chart for better readability
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
fig.update_xaxes(categoryorder='total descending')  # Ensure bars are ordered by sales
fig.update_yaxes(title_text='Total Sales ($)', ticksuffix='$')

# Display the chart to the user
show_to_user(fig)
```","The input Python code correctly implements the required logic as specified by the business analytics request and aligns with the reference implementation. Both codes aim to identify the top 5 sales employees based on total sales by executing an SQL query to calculate the total sales per employee. The calculation of total sales is done as (UnitPrice * Quantity * (1 - Discount)). The input code also uses Plotly to create a bar chart visualizing the performance of these employees. Additionally, the code includes formatting for readability enhancements which do not affect the core functionality. Therefore, the input code satisfies the requirements and adheres to logic similar to the reference implementation.",both
"What is the average age of employees, and can this be visualized with a histogram showing the distribution of ages?","import pandas as pd
import plotly.express as px

# SQL Query to get average age of employees
sql_query = """"""
SELECT TIMESTAMPDIFF(YEAR, BirthDate, CURDATE()) AS Age FROM employees;
""""""

# Function to execute the SQL query and retrieve data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Function logic to execute SQL query and return result as DataFrame
    pass

# Function to display the result
def show_to_user(data):
    # Function logic to display the data
    pass

# Execute SQL query to get ages
ages_df = execute_sql_query(sql_query)

# Calculate average age
avg_age = ages_df['Age'].mean()

# Display average age
print(f""Average Age of Employees: {avg_age}"")

# Create and display age distribution histogram
fig = px.histogram(ages_df, x='Age', title='Age Distribution of Employees')
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    YEAR(CURDATE()) - YEAR(BirthDate) AS Age
FROM 
    employees
""""""
age_data = execute_sql_query(sql_query)

average_age = age_data['Age'].mean()
histogram = px.histogram(age_data, x='Age', title=""Distribution of Employee Ages"")
show_to_user(histogram)

average_age
```","The input code correctly calculates the average age of employees by subtracting the birth year from the current year, similar to the reference code's use of TIMESTAMPDIFF to determine ages. It then computes the mean of the ages to get the average age and visualizes the data with a histogram using Plotly, consistent with the reference implementation's intended logic and output.","```python
import pandas as pd
import plotly.express as px

# Placeholder function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to run an SQL query and return the result as a DataFrame
    pass

# Placeholder function to show data analysis or visualization results to the user
def show_to_user(data):
    # This function should be implemented to display data
    pass

# SQL query to fetch employee age data
sql_query = """"""
SELECT FLOOR(DATEDIFF(CURDATE(), BirthDate) / 365.25) AS Age
FROM employees;
""""""

# Execute the SQL query to get employee ages
ages_df = execute_sql_query(sql_query)

# Calculate the average age
average_age = ages_df['Age'].mean()

# Display the average age to the user
show_to_user(pd.DataFrame({'Average Age': [average_age]}))

# Create a histogram to visualize the distribution of ages
fig = px.histogram(ages_df, x='Age', title='Distribution of Employee Ages')

# Display the histogram
show_to_user(fig)
```","The input code correctly addresses the task by computing the average age of employees and displaying a histogram of the age distribution. It matches the logic of the reference implementation, with minor differences in SQL query syntax and data display, but these do not affect the correctness of the solution.",both
How many orders have been shipped late? Include a visualization to show the frequency of late shipments over time.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get all orders that have been shipped late
sql_query = """"""
SELECT orders.OrderID, orders.ShippedDate, orders.RequiredDate 
FROM orders 
WHERE orders.ShippedDate > orders.RequiredDate;
""""""

# Function to execute the SQL query and return a DataFrame
late_shipments_df = execute_sql_query(sql_query)

# Ensure that 'ShippedDate' is in datetime format
late_shipments_df['ShippedDate'] = pd.to_datetime(late_shipments_df['ShippedDate'])

# Group by the shipped date and count how many shipments were late
late_shipments_over_time = late_shipments_df.groupby('ShippedDate').size().reset_index(name='LateShipmentsCount')

# Plotting the frequency of late shipments over time using Plotly
fig = px.line(late_shipments_over_time, x='ShippedDate', y='LateShipmentsCount', title='Frequency of Late Shipments Over Time')

# Display the plot
show_to_user(fig)

# Display the total count of late shipments
total_late_orders = late_shipments_df.shape[0]
show_to_user(pd.DataFrame({'TotalLateOrders': [total_late_orders]}))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderDate, 
    COUNT(*) as LateShipments
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    OrderDate
ORDER BY 
    OrderDate
""""""

late_shipments_df = execute_sql_query(sql_query)

fig = px.line(late_shipments_df, x='OrderDate', y='LateShipments', title='Frequency of Late Shipments Over Time', labels={'LateShipments': 'Number of Late Shipments'})
show_to_user(fig)

total_late_orders = late_shipments_df['LateShipments'].sum()
total_late_orders
```","The input code uses 'OrderDate' for grouping, which is not equivalent to 'ShippedDate' in the reference. The reference implementation groups by 'ShippedDate' which is more logical to track shipments given their nature. Additionally, it doesn’t display the total number of late orders, compared to the reference which outputs this information.","```python
import pandas as pd
import plotly.express as px


def get_late_orders():
    """"""
    Execute the SQL query to get the late orders.
    """"""
    sql_query = '''
    SELECT o.OrderID, o.ShippedDate
    FROM orders o
    WHERE o.ShippedDate > o.RequiredDate
    '''

    late_orders = execute_sql_query(sql_query)
    return late_orders


def visualize_late_orders_frequency(late_orders):
    """"""
    Visualize the frequency of late shipments over time.
    """"""
    late_orders['ShippedDate'] = pd.to_datetime(late_orders['ShippedDate'])
    late_orders_count = late_orders.groupby(late_orders['ShippedDate'].dt.to_period('M')).size().reset_index(name='Frequency')
    late_orders_count.columns = ['Month', 'Frequency']

    fig = px.line(late_orders_count, x='Month', y='Frequency', title='Frequency of Late Shipments Over Time')
    show_to_user(fig)


# Main execution
late_orders_df = get_late_orders()
visualize_late_orders_frequency(late_orders_df)
```","The input code groups shipments by month for visualization, while the reference groups by day. This changes the granularity of the visualization and could misrepresent the data frequency compared to the reference implementation's method.",None
"Which products have the highest average monthly sales growth, and can this be illustrated with a line chart to show the trend over time?","```python
import pandas as pd
import plotly.express as px

# Assume that execute_sql_query and show_to_user are already implemented based on the given constraints.

# SQL Query to get average monthly sales growth per product
sql_query = """"""
SELECT 
    ProductID, 
    (SUM([Order Details].Quantity) / COUNT(DISTINCT EXTRACT(YEAR_MONTH FROM order_date))) AS AvgMonthlySalesGrowth 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY AvgMonthlySalesGrowth DESC;
""""""

# Executing the SQL query to fetch data
df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.line(
    df, 
    x='ProductID', 
    y='AvgMonthlySalesGrowth', 
    title='Average Monthly Sales Growth by Product',
    labels={'AvgMonthlySalesGrowth': 'Average Monthly Sales Growth', 'ProductID': 'Product ID'}
)

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to retrieve monthly sales data
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, p.ProductName, Month
ORDER BY 
    Month
""""""

# Execute the SQL query
monthly_sales_data = execute_sql_query(sql_query)

# Calculate monthly sales growth
monthly_sales_data['SalesGrowth'] = monthly_sales_data.groupby('ProductID')['TotalSales'].pct_change()

# Calculate average monthly sales growth for each product
average_growth = monthly_sales_data.groupby('ProductID')['SalesGrowth'].mean().reset_index()
average_growth = average_growth.merge(monthly_sales_data[['ProductID', 'ProductName']].drop_duplicates(), on='ProductID')

# Sort by average sales growth
average_growth = average_growth.sort_values(by='SalesGrowth', ascending=False)

# Prepare for visualization
fig = px.line(monthly_sales_data, x='Month', y='TotalSales', color='ProductName', 
              title='Monthly Sales Growth Trend by Product')

# Show the results to the user
show_to_user(fig)
```","The input code calculates the percentage change in monthly sales (SalesGrowth) for each product using `pct_change()`, rather than average monthly sales growth as required. It plots TotalSales over time, not AvgMonthlySalesGrowth. The reference code directly computes AvgMonthlySalesGrowth via SQL without time-specific trends, and visualizes 'ProductID' against 'AvgMonthlySalesGrowth'. The logic does not match the reference that focuses on average growth per product directly, not trends over individual months.","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly sales data for each product
sql_query = '''
WITH MonthlySales AS (
    SELECT products.ProductName, 
           DATE_TRUNC('month', [Order Details].OrderDate) AS Month, 
           SUM([Order Details].Quantity) AS TotalQuantity 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    GROUP BY products.ProductName, Month
) 
SELECT ProductName, 
       Month, 
       TotalQuantity, 
       LAG(TotalQuantity) OVER (PARTITION BY ProductName ORDER BY Month) AS PrevMonthQuantity, 
       TotalQuantity - LAG(TotalQuantity) OVER (PARTITION BY ProductName ORDER BY Month) AS SalesGrowth 
FROM MonthlySales;
'''

# Fetching data
data_df = execute_sql_query(sql_query)

# Calculating average monthly sales growth per product
avg_growth_df = data_df.groupby('ProductName')['SalesGrowth'].mean().reset_index()
avg_growth_df.columns = ['ProductName', 'AvgMonthlyGrowth']

# Identifying products with the highest average monthly growth
# Note: To find products with highest growth, you can sort or filter `avg_growth_df`

# Visualize monthly sales growth trend for each product over time
fig = px.line(data_df,
              x='Month',
              y='SalesGrowth',
              color='ProductName',
              title='Monthly Sales Growth Trend by Product',
              labels={'SalesGrowth': 'Sales Growth', 'Month': 'Month'})

# Show visualization
show_to_user(fig)
```","The input code does not solve the problem as described in the business analytics request. The reference code calculates average monthly sales growth directly via SQL for each product and then displays it, ensuring products with the highest growth are easily identifiable from the sorted result. The input code, however, calculates sales growth changes for each month per product using a window function, then averages these changes in Python. While this method calculates the growth, it diverges in approach from the reference, particularly as it doesn't sort or identify the highest averages directly and the visualization focuses on sales growth trends, not average growth.",None
Identify the month with the highest sales volume and create a line or bar chart to visualize monthly sales trends.,"```python
import pandas as pd
import plotly.express as px

# Mock function implementations
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This will mock the data response for the purpose of this task
    data = {
        'Year': [2023, 2023, 2023, 2023],
        'Month': [1, 2, 3, 4],
        'TotalSalesVolume': [200, 250, 300, 220]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Retrieve monthly sales data
sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM orders.order_date) AS Year, 
    EXTRACT(MONTH FROM orders.order_date) AS Month, 
    SUM([Order Details].Quantity) AS TotalSalesVolume 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Year, Month 
ORDER BY Year, Month
""""""
sales_data = execute_sql_query(sql_query)

# Identify the month with the highest sales volume
highest_sales_month = sales_data.loc[sales_data['TotalSalesVolume'].idxmax()]

# Output the month with the highest sales volume
show_to_user(pd.DataFrame([highest_sales_month]))

# Visualize monthly sales trends
fig = px.bar(sales_data, x='Month', y='TotalSalesVolume', title='Monthly Sales Trends')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM(order_details.Quantity) AS Total_Sales
FROM 
    [Order Details] AS order_details
JOIN 
    orders ON order_details.OrderID = orders.OrderID
GROUP BY 
    Month
ORDER BY 
    Total_Sales DESC
""""""

monthly_sales = execute_sql_query(sql_query)

highest_sales_month = monthly_sales.iloc[0]

fig = px.line(monthly_sales, x='Month', y='Total_Sales', title='Monthly Sales Trends')
show_to_user(fig)

highest_sales_month
```","The input code differs in logic from the reference. The input script orders the months by 'Total_Sales' in descending order, thus the highest sales month is assumed to be the first row in the result, bypassing the need for index-based maximum checking. Conversely, the reference code orders by Year and Month and uses `idxmax()` to identify the month with the maximum sales volume. Additionally, the input code uses `DATE_FORMAT` to extract the year and month as a single string, whereas the reference code uses separate columns for year and month. Lastly, the visualizations differ as the input uses a line chart, while the reference uses a bar chart.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get monthly sales data
sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM OrderDate) AS Year, 
    EXTRACT(MONTH FROM OrderDate) AS Month, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) AS MonthlySales 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    Year, Month 
ORDER BY 
    Year, Month;
""""""

# Function to execute SQL query and return a DataFrame
monthly_sales_data = execute_sql_query(sql_query)

# Find the month with the highest sales volume
highest_sales_month = monthly_sales_data.loc[
    monthly_sales_data['MonthlySales'].idxmax()
]

# Extract data for the line chart
fig = px.line(
    monthly_sales_data,
    x=pd.to_datetime(monthly_sales_data[['Year', 'Month']].assign(DAY=1)),
    y='MonthlySales',
    title=f""Monthly Sales Trends (Highest: {highest_sales_month['Month']}/{highest_sales_month['Year']})"",
    labels={'x': 'Month', 'MonthlySales': 'Sales Volume'}
)

# Show the line chart to the user
show_to_user(fig)
```","The input code calculates 'MonthlySales' using 'SUM(Quantity * UnitPrice)' instead of 'SUM(Quantity)' as in the reference. This results in a different calculation metric (sales vs volume). Additionally, the visualization is a line chart with a modified x-axis, whereas the reference uses a bar chart.",None
"Which employees have not processed any orders? Also, create a chart to visualize the proportion of employees who have and have not processed orders.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID
FROM employees
LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE orders.OrderID IS NULL;
""""""

# Execute the SQL query to get employees who haven't processed orders
employees_no_orders_df = execute_sql_query(sql_query)

# Execute SQL query to get total employees count
total_employees_query = ""SELECT COUNT(EmployeeID) as TotalEmployees FROM employees;""
total_employees_df = execute_sql_query(total_employees_query)

# Calculate the number of employees who have processed orders, assuming total data is available
employees_with_orders_count = total_employees_df.iloc[0]['TotalEmployees'] - len(employees_no_orders_df)

# Create a DataFrame for visualization
data = {
    ""Category"": [""Processed Orders"", ""Not Processed Orders""],
    ""Count"": [employees_with_orders_count, len(employees_no_orders_df)]
}
proportion_df = pd.DataFrame(data)

# Create a pie chart to visualize the proportion
fig = px.pie(proportion_df, values='Count', names='Category', title='Proportion of Employees Processing Orders')

# Show the visualization to the user
show_to_user(fig)

# Optionally, show the employees who have not processed any orders
show_to_user(employees_no_orders_df)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get employees who have not processed any orders
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderID IS NULL
""""""
no_orders_df = execute_sql_query(sql_query)

# Calculating proportions
total_employees = no_orders_df.shape[0] + execute_sql_query(""SELECT COUNT(*) FROM employees"").iloc[0, 0]
proportions = {
    'Processed Orders': execute_sql_query(""SELECT COUNT(DISTINCT EmployeeID) FROM orders"").iloc[0, 0],
    'No Processed Orders': no_orders_df.shape[0]
}

# Creating a DataFrame for visualization
proportions_df = pd.DataFrame(list(proportions.items()), columns=['Status', 'Count'])

# Plotting the data
fig = px.pie(proportions_df, values='Count', names='Status', title='Proportion of Employees Who Have/Have Not Processed Orders')
show_to_user(fig)

# Display the employees with no processed orders
show_to_user(no_orders_df)
```","The input code correctly identifies employees who haven't processed any orders using SQL with a LEFT JOIN and WHERE condition. It calculates the proportions correctly by counting distinct EmployeeIDs in orders and using total employee count. It creates visualization using similar logic as the reference, directly comparable. Despite minor variations like including employee names, the input logic aligns well with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to find employees who have not processed any orders
sql_query = """"""
SELECT e.EmployeeID FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderID IS NULL;
""""""

# Executing the SQL query
no_orders_df = execute_sql_query(sql_query)

# Assuming there's another query or method to get all employees
all_employees_query = ""SELECT EmployeeID FROM employees;""
all_employees_df = execute_sql_query(all_employees_query)

# Find employees who have processed orders
processed_orders_df = all_employees_df[~all_employees_df['EmployeeID'].isin(no_orders_df['EmployeeID'])]

# Create a DataFrame for the visualization
status_df = pd.DataFrame({
    'Processed Orders': ['No', 'Yes'],
    'Count': [no_orders_df.shape[0], processed_orders_df.shape[0]]
})

# Create a pie chart to visualize the data
fig = px.pie(status_df, values='Count', names='Processed Orders', title='Proportion of Employees by Order Processing Status')

# Display the results
show_to_user(no_orders_df)
show_to_user(fig)
```","The evaluated code correctly identifies employees who have not processed any orders by executing an SQL query similar to the reference, using a LEFT JOIN to find employees without corresponding orders. It then determines those who have processed orders by comparing with all employees, creating a DataFrame to represent the processed and not processed orders. It visualizes this using a pie chart, effectively meeting the business analytics request. Though implemented with slightly different methods, it adheres to the same logic as the reference implementation.",both
How many orders have been delivered on time? Include a pie chart showing the percentage of on-time versus late deliveries.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL queries
on_time_query = """"""
SELECT 
    COUNT(OrderID) AS on_time_deliveries 
FROM 
    orders 
WHERE 
    ShippedDate <= RequiredDate;
""""""

total_deliveries_query = """"""
SELECT 
    COUNT(OrderID) AS total_deliveries 
FROM 
    orders;
""""""

# Execute the SQL queries
on_time_deliveries_df = execute_sql_query(on_time_query)
total_deliveries_df = execute_sql_query(total_deliveries_query)

# Extract the counts
on_time_deliveries = on_time_deliveries_df.iloc[0][""on_time_deliveries""]
total_deliveries = total_deliveries_df.iloc[0][""total_deliveries""]

# Calculate the late deliveries
late_deliveries = total_deliveries - on_time_deliveries

# Create a DataFrame for visualization
delivery_status_df = pd.DataFrame({
    'Delivery Status': ['On Time', 'Late'],
    'Count': [on_time_deliveries, late_deliveries]
})

# Generate the pie chart using Plotly
fig = px.pie(delivery_status_df, names='Delivery Status', values='Count', 
             title=""Percentage of On-Time vs Late Deliveries"")

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(OrderID) AS total_orders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS on_time_orders
FROM orders
""""""

orders_df = execute_sql_query(sql_query)

on_time_orders = orders_df['on_time_orders'].iloc[0]
total_orders = orders_df['total_orders'].iloc[0]
late_orders = total_orders - on_time_orders

labels = ['On-Time', 'Late']
values = [on_time_orders, late_orders]

fig = px.pie(values=values, names=labels, title='On-Time vs Late Deliveries')
show_to_user(fig)
```","The input code and the reference code both correctly calculate the number of on-time and late deliveries. The input code uses a combined SQL query with a CASE statement to derive both the total orders and on-time orders, whereas the reference code uses two separate queries. Both approaches yield the same counts of on-time and late deliveries. Additionally, both create a pie chart using Plotly to display the percentage of on-time versus late deliveries. The logic and results are equivalent, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get on-time and late orders
sql_query_on_time_delivery = """"""
SELECT 
    o.OrderID, 
    o.ShippedDate, 
    o.RequiredDate 
FROM 
    orders o 
WHERE 
    o.ShippedDate <= o.RequiredDate 
ORDER BY 
    o.ShippedDate
""""""

sql_query_late_delivery = """"""
SELECT 
    o.OrderID, 
    o.ShippedDate, 
    o.RequiredDate
FROM 
    orders o 
WHERE 
    o.ShippedDate > o.RequiredDate
ORDER BY 
    o.ShippedDate
""""""

# Execute SQL queries and get the data frames
on_time_df = execute_sql_query(sql_query_on_time_delivery)
late_df = execute_sql_query(sql_query_late_delivery)

# Count on-time and late deliveries
on_time_count = len(on_time_df)
late_count = len(late_df)

# Create a summary DataFrame for on-time and late counts
summary_df = pd.DataFrame({
    'Status': ['On-time', 'Late'],
    'Count': [on_time_count, late_count]
})

# Create a pie chart using Plotly
fig = px.pie(summary_df, names='Status', values='Count', 
             title='On-time vs Late Deliveries')

# Display the pie chart to the user
show_to_user(fig)

# Optionally, show the counts in a DataFrame form
show_to_user(summary_df)
```","Both the provided code and the reference implementation correctly count on-time deliveries and create a pie chart to visualize the distribution of on-time versus late deliveries. The two code snippets differ in their approach, with the provided code executing separate queries for on-time and late deliveries, while the reference implementation calculates late deliveries based on total deliveries minus on-time deliveries. However, the outcome and logic are consistent with the business analytics request. Both versions generate the required visualization using Plotly and display the results with the `show_to_user` function.",both
Find products with the highest unit price and lowest quantity in stock and display them in a scatter plot for better visualization.,"```python
import pandas as pd
import plotly.express as px

def find_high_low_products():
    # SQL query to find the product with the lowest quantity in stock and highest unit price
    sql_query = """"""
    SELECT ProductID, ProductName, UnitPrice, UnitsInStock 
    FROM products 
    WHERE UnitsInStock = (SELECT MIN(UnitsInStock) FROM products) 
    ORDER BY UnitPrice DESC 
    LIMIT 1;
    """"""

    # Execute the SQL query and get the resulting DataFrame
    low_stock_df = execute_sql_query(sql_query)
    
    # SQL query to find the product with the highest unit price
    sql_query_high_price = """"""
    SELECT ProductID, ProductName, UnitPrice, UnitsInStock 
    FROM products 
    ORDER BY UnitPrice DESC 
    LIMIT 1;
    """"""

    # Execute the SQL query and get the resulting DataFrame
    high_price_df = execute_sql_query(sql_query_high_price)

    # Combine both DataFrames to prepare for visualization
    combined_df = pd.concat([low_stock_df, high_price_df]).drop_duplicates()

    # Create a scatter plot for visualization
    fig = px.scatter(combined_df, x='UnitsInStock', y='UnitPrice', 
                     text='ProductName', 
                     title='Products with Highest Unit Price and Lowest Quantity in Stock', 
                     labels={'UnitsInStock': 'Quantity in Stock', 'UnitPrice': 'Unit Price'})
    
    # Display the plot to the user
    show_to_user(fig)

# Execute the function
find_high_low_products()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductName, 
    p.UnitPrice, 
    p.UnitsInStock 
FROM 
    products p 
WHERE 
    p.Discontinued = 0 
ORDER BY 
    p.UnitPrice DESC, 
    p.UnitsInStock ASC 
LIMIT 10
""""""

products_data = execute_sql_query(sql_query)

fig = px.scatter(products_data, 
                 x='UnitPrice', 
                 y='UnitsInStock', 
                 text='ProductName', 
                 title='Products with Highest Unit Price and Lowest Quantity in Stock')
show_to_user(fig)
```","The input code retrieves the top 10 products with the highest unit price and lowest quantity in stock, while the reference code fetches the single highest unit price and lowest stock product distinctly. Additionally, the input code does not drop duplicates and filters out discontinued products, which is not part of the reference logic.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the data
sql_query = ""SELECT ProductName, UnitPrice, UnitsInStock FROM products ORDER BY UnitPrice DESC;""
data = execute_sql_query(sql_query)

# Filter the data to find the products with the highest UnitPrice and lowest UnitsInStock
filtered_data = data[data['UnitsInStock'] == data['UnitsInStock'].min()]

# Create a scatter plot using Plotly
fig = px.scatter(
    filtered_data,
    x='UnitPrice',
    y='UnitsInStock',
    text='ProductName',
    title=""Product with Highest Unit Price and Lowest Quantity in Stock""
)

fig.update_traces(marker=dict(size=12, color='rgba(152, 0, 0, .8)'),
                  textposition='top center')
fig.update_layout(yaxis=dict(visible=False))  # Hide y axis since it has only one unique value

# Show the plot
show_to_user(fig)
```","The provided code selects products with the lowest quantity in stock but only considers those with the highest unit prices if they share the same minimum stock level. It does not retrieve both the product with the highest unit price and the product with the lowest stock as separate entities. The reference code explicitly retrieves one product with the lowest stock and one with the highest price, regardless of whether these are the same product or not, and plots both.",None
"How many unique customers placed orders each month, and can you provide a line chart to visualize the trends over time?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       COUNT(DISTINCT CustomerID) AS UniqueCustomers 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query and get the results in a DataFrame
data = execute_sql_query(sql_query)

# Create a line chart to visualize the number of unique customers over time
fig = px.line(data, x='Month', y='UniqueCustomers', 
              title='Unique Customers per Month',
              labels={'Month': 'Month', 'UniqueCustomers': 'Unique Customers'})

# Use utility function to show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    COUNT(DISTINCT CustomerID) AS UniqueCustomers
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

unique_customers_df = execute_sql_query(sql_query)

fig = px.line(unique_customers_df, x='Month', y='UniqueCustomers', title='Unique Customers Placed Orders Each Month')
show_to_user(fig)
```","The input code correctly answers the business analytics request. It uses a SQL query to count unique customers by month, similar to the reference implementation. The difference in date formatting (using DATE_FORMAT instead of DATE_TRUNC) is acceptable as it achieves the same grouping by month. The line chart visualizes the trends over time, adhering to the business request.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are defined elsewhere as per constraints

# Define the SQL query to get unique customer counts per month
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
    COUNT(DISTINCT CustomerID) AS UniqueCustomers 
FROM 
    orders 
GROUP BY 
    OrderMonth;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize the trend of unique customers over time
fig = px.line(df, x='OrderMonth', y='UniqueCustomers', title='Unique Customers per Month')

# Display the line chart to the user
show_to_user(fig)
```","The provided Python code correctly addresses the business analytics request and follows the same logic as the reference implementation. Both implementations calculate the number of unique customers who placed orders each month. The only difference is the SQL syntax for date formatting (`DATE_TRUNC` vs `DATE_FORMAT`), which is acceptable since syntax may vary across SQL dialects. Furthermore, both implementations use Plotly to create a line chart, meeting the requirement to visualize the trend over time. Therefore, the input Python code is correct.",both
What percentage of orders are completed without any discount? Include a pie chart to visualize the distribution of discounted and non-discounted orders.,"```python
import pandas as pd
import plotly.express as px

# Assume the following utility functions are pre-defined
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the given SQL query and return a DataFrame
    pass

def show_to_user(data):
    # This function displays the data. It can accept a DataFrame or a Plotly Figure.
    pass

# SQL Queries
total_orders_query = """"""
SELECT COUNT(DISTINCT OrderID) AS TotalOrders FROM [Order Details];
""""""

no_discount_query = """"""
SELECT COUNT(DISTINCT OrderID) AS NoDiscountOrders FROM [Order Details] WHERE Discount = 0;
""""""

# Execute SQL queries
total_orders_df = execute_sql_query(total_orders_query)
no_discount_orders_df = execute_sql_query(no_discount_query)

# Calculate percentages
total_orders = total_orders_df['TotalOrders'].iloc[0]
no_discount_orders = no_discount_orders_df['NoDiscountOrders'].iloc[0]

no_discount_rate = (no_discount_orders / total_orders) * 100
discounted_rate = 100 - no_discount_rate

# Prepare data for the pie chart
data = {
    'Order Type': ['No Discount', 'Discount Applied'],
    'Percentage': [no_discount_rate, discounted_rate]
}

pie_df = pd.DataFrame(data)

# Create pie chart using Plotly
fig = px.pie(pie_df, values='Percentage', names='Order Type', title='Distribution of Discounted vs Non-Discounted Orders')

# Show plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    CASE 
        WHEN Discount = 0 THEN 'No Discount' 
        ELSE 'Discounted' 
    END AS Discount_Status,
    COUNT(OrderID) AS Order_Count
FROM 
    [Order Details]
GROUP BY 
    Discount
""""""

order_data = execute_sql_query(sql_query)

total_orders = order_data['Order_Count'].sum()
order_data['Percentage'] = (order_data['Order_Count'] / total_orders) * 100

fig = px.pie(order_data, 
             values='Order_Count', 
             names='Discount_Status', 
             title='Distribution of Discounted and Non-Discounted Orders')

show_to_user(fig)

percentage_without_discount = order_data.loc[order_data['Discount_Status'] == 'No Discount', 'Percentage'].values[0]
print(f""{percentage_without_discount:.2f}% of orders are completed without any discount."")
```","The input code correctly calculates the percentage of orders completed without any discount and visualizes it with a pie chart. It groups the data by discount status and calculates the percentage of each group, aligning with the logic of the reference code, even though the approach to obtaining the data differs.","```python
import plotly.express as px
import pandas as pd

# Business logic and utility function
def calculate_discounted_orders_percentage():
    # SQL query to get the counts
    sql_query = """"""
    SELECT 
        COUNT(CASE WHEN o.Discount > 0 THEN o.OrderID END) AS DiscountedOrders,
        COUNT(CASE WHEN o.Discount = 0 THEN o.OrderID END) AS NonDiscountedOrders
    FROM orders o;
    """"""

    # Execute the query to get results
    orders_df = execute_sql_query(sql_query)

    # Calculate total orders
    total_orders = orders_df['DiscountedOrders'].iloc[0] + orders_df['NonDiscountedOrders'].iloc[0]

    # Calculate percentage of non-discounted orders
    non_discounted_percentage = (orders_df['NonDiscountedOrders'].iloc[0] / total_orders) * 100

    # Prepare data for visualization
    data = {
        'Category': ['Discounted', 'Non-Discounted'],
        'Count': [orders_df['DiscountedOrders'].iloc[0], orders_df['NonDiscountedOrders'].iloc[0]]
    }
    df = pd.DataFrame(data)

    # Create pie chart using Plotly
    fig = px.pie(df, names='Category', values='Count', title='Order Discount Distribution')

    # Show results
    show_to_user({
        'Non-Discounted Percentage': non_discounted_percentage,
        'Chart': fig
    })

# Execute the function to perform the analysis
calculate_discounted_orders_percentage()
```","The input code correctly calculates the percentage of orders without a discount by using a SQL query to retrieve the number of discounted and non-discounted orders. It computes the total orders correctly, calculates the percentage of non-discounted orders, and constructs a pie chart to visualize the distribution. This process aligns logically with the reference implementation, even though the specific coding approach differs.",both
"Which supplier has the shortest average lead time, and can you provide a visual comparison of the lead times for all suppliers?","import pandas as pd
import plotly.express as px

def shortest_avg_lead_time():
    # Constructing the SQL query to get average lead times per supplier
    sql_query = """"""
    SELECT suppliers.SupplierID, 
           AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
    FROM orders 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
    GROUP BY suppliers.SupplierID 
    ORDER BY avg_lead_time ASC
    """"""
    
    # Execute SQL query
    lead_time_df = execute_sql_query(sql_query)

    # Get the supplier with the shortest average lead time
    shortest_lead_time_supplier = lead_time_df.iloc[0]

    # Visualization: Visual comparison of the lead times for all suppliers
    fig = px.bar(
        lead_time_df, 
        x='SupplierID', 
        y='avg_lead_time',
        title='Average Lead Time by Supplier',
        labels={'avg_lead_time': 'Average Lead Time (days)', 'SupplierID': 'Supplier ID'}
    )

    # Show the result and visualization to the user
    show_to_user(lead_time_df)
    show_to_user(fig)

# Assuming the environment will execute this function
shortest_avg_lead_time()","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.SupplierID, suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time 
FROM orders 
JOIN products ON orders.OrderID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY products.SupplierID, suppliers.CompanyName
""""""

lead_time_data = execute_sql_query(sql_query)
shortest_lead_time_supplier = lead_time_data.loc[lead_time_data['average_lead_time'].idxmin()]

fig = px.bar(lead_time_data, x='CompanyName', y='average_lead_time', 
             title='Average Lead Time by Supplier', 
             labels={'average_lead_time': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)

shortest_lead_time_supplier
```","The input code differs from the reference code in a few key areas: 1) The `FROM` clause in the input code lacks the necessary `JOIN [Order Details]` which could affect the data it processes, assuming an orders-products relationship directly; this may lead to incorrect lead time calculation. 2) The code uses `products.ProductID` with `orders.OrderID`, which could be incorrect without an interfacing table. 3) The input code directly retrieves `SupplierID` and `CompanyName`, but the reference logic focuses on logical joins and `SupplierID` aggregation only. 4) The input visualization uses `CompanyName` instead of `SupplierID`. 5) Result handling and output are the same in essence, but SQL logic and data processing differ. These differences could affect the correctness based on data schema assumptions.","
```python
import pandas as pd
import plotly.express as px

# SQL query to get average lead time for all suppliers
sql_query = """"""
SELECT s.SupplierID, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN orders o ON p.ProductID = o.ProductID 
GROUP BY s.SupplierID 
ORDER BY AvgLeadTime ASC;
""""""

# Execute the SQL query and get the results
df = execute_sql_query(sql_query)

# Determine the supplier with the shortest average lead time
if not df.empty:
    shortest_lead_supplier = df.iloc[0]
else:
    shortest_lead_supplier = None

# Display the supplier with the shortest lead time to the user
show_to_user(shortest_lead_supplier)

# Visualize the lead times for all suppliers
fig = px.bar(df, x='SupplierID', y='AvgLeadTime',
             title='Average Lead Time for Suppliers',
             labels={'AvgLeadTime': 'Average Lead Time (Days)', 'SupplierID': 'Supplier ID'})

# Show the visualization to the user
show_to_user(fig)
```","The evaluated code correctly implements the business analytics request by calculating the average lead time for each supplier and identifying the supplier with the shortest lead time. It then provides a bar chart to compare lead times among all suppliers. Despite differences in table aliases and slightly different SQL join order, the logic aligns with the reference implementation.",Finetuned
"Identify suppliers with more than five discontinued products, and visualize the number of discontinued products per supplier.","```python
import pandas as pd
import plotly.express as px

# Assume this function is a placeholder for actual SQL execution
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock data to simulate the query result
    data = {
        'SupplierID': [1, 2, 3],
        'DiscontinuedCount': [6, 8, 9]
    }
    return pd.DataFrame(data)

# Assume this function is a placeholder for actual data visualization output
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# SQL query to identify suppliers with more than five discontinued products
sql_query = """"""
SELECT s.SupplierID, COUNT(p.ProductID) as DiscontinuedCount
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE p.Discontinued = 1
GROUP BY s.SupplierID
HAVING COUNT(p.ProductID) > 5;
""""""

# Execute SQL query
suppliers_data = execute_sql_query(sql_query)

# Visualize the number of discontinued products per supplier
fig = px.bar(suppliers_data, x='SupplierID', y='DiscontinuedCount',
             title='Number of Discontinued Products per Supplier',
             labels={'DiscontinuedCount':'Number of Discontinued Products', 'SupplierID':'Supplier ID'})

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Query to get the count of discontinued products per supplier
sql_query = """"""
SELECT SupplierID, COUNT(ProductID) AS DiscontinuedCount
FROM products
WHERE Discontinued = 1
GROUP BY SupplierID
HAVING COUNT(ProductID) > 5
""""""

# Execute the SQL query
discontinued_suppliers_df = execute_sql_query(sql_query)

# Step 2: Visualize the number of discontinued products per supplier
fig = px.bar(discontinued_suppliers_df, x='SupplierID', y='DiscontinuedCount',
             title='Suppliers with More Than Five Discontinued Products',
             labels={'DiscontinuedCount': 'Number of Discontinued Products', 'SupplierID': 'Supplier ID'})

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request by querying and visualizing suppliers with more than five discontinued products. The logic of counting discontinued products per supplier and filtering those with more than five matches the reference implementation. Although there is a slight difference in how the SQL query is constructed (use of JOIN in the reference code), the input code assumes a similar context that leads to the same result. Both codes use the same visualization library (Plotly Express) to create a bar chart.","To analyze and visualize the number of discontinued products per supplier, we need to follow these steps using Python and some libraries such as Pandas and Plotly.

1. **Execute the SQL query to retrieve the required data.**
2. **Filter suppliers who have more than five discontinued products.**
3. **Visualize the results using a bar chart to display the number of discontinued products per relevant supplier.**

Here’s how the complete code looks:

```python
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Imagine this function is implemented to execute the SQL query
    # and return the result as a Pandas DataFrame.
    pass

def show_to_user(data):
    # Imagine this function is implemented to show the data
    # or figure to the user appropriately.
    pass

# SQL query to get the number of discontinued products per supplier
sql_query = """"""
SELECT p.SupplierID, COUNT(*) AS DiscontinuedCount 
FROM products p 
WHERE p.Discontinued = 1 
GROUP BY p.SupplierID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Filter suppliers with more than five discontinued products
filtered_df = df[df['DiscontinuedCount'] > 5]

# Visualize the results using Plotly
fig = px.bar(
    filtered_df, 
    x='SupplierID', 
    y='DiscontinuedCount',
    title='Number of Discontinued Products per Supplier',
    labels={'SupplierID': 'Supplier ID', 'DiscontinuedCount': 'Discontinued Products Count'}
)

# Show the visualization
show_to_user(fig)
```

### Explanation of the code:
1. **SQL Execution**: The SQL query is executed to get the supplier IDs along with the count of discontinued products.
2. **Filtering**: We filter the resulting DataFrame to include only those suppliers with more than five discontinued products.
3. **Visualization**: We use Plotly to create a bar chart visualizing the number of discontinued products for each supplier meeting the criteria.
4. **Display**: Finally, the bar chart is displayed to the user.

This approach leverages Python and SQL to fulfill the business analytic requirement efficiently.","The provided code meets the business analytics requirement by querying suppliers with more than five discontinued products, filtering the DataFrame to reflect this requirement, and visualizing the results using a bar chart. Although the initial SQL queries are slightly different in structure, they logically achieve the same result by counting discontinued products by supplier and filtering for those with more than five products. Both codes then visualize the data in a similar manner using Plotly.",both
"Identify cities with the highest average order fulfillment time, and visualize the results using a bar chart.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT ShipCity, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipCity
ORDER BY AvgFulfillmentTime DESC;
""""""

# Execute the SQL query and retrieve data as a DataFrame
cities_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average order fulfillment time by city
fig = px.bar(cities_df, x='ShipCity', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by City')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY ShipCity
ORDER BY AverageFulfillmentTime DESC;
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)

fig = px.bar(average_fulfillment_time_df, 
             x='ShipCity', 
             y='AverageFulfillmentTime', 
             title='Cities with the Highest Average Order Fulfillment Time',
             labels={'AverageFulfillmentTime': 'Average Fulfillment Time (Days)', 'ShipCity': 'City'})

show_to_user(fig)
```","The input code executes an SQL query to retrieve the average fulfillment time for each city and then uses Plotly to create a bar chart. Despite minor differences in column naming ('AverageFulfillmentTime' vs 'AvgFulfillmentTime') and additional chart labeling, the logic and functionality are consistent with the reference implementation. Therefore, it correctly answers the business analytics request.","```python
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT ShipCity, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipCity
ORDER BY AvgFulfillmentTime DESC;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize cities with the highest average order fulfillment time
fig = px.bar(
    df, 
    x='ShipCity', 
    y='AvgFulfillmentTime', 
    title='Average Order Fulfillment Time by City',
    labels={'ShipCity': 'City', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'},
    template='plotly'
)

# Display the figure
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by executing a SQL query to calculate the average order fulfillment time for each city, then generating and displaying a bar chart using Plotly to visualize these metrics. Although it includes additional customization (e.g., labels and template), the core logic aligns with the reference implementation.",both
What is the average freight cost for orders shipped in December? Please include a time series visualization to show the trend of freight costs over the past years.,"{'original': False, 'content': '```python\nimport pandas as pd\nimport plotly.express as px\n\n# Define the SQL query\nsql_query = """"""\nSELECT \n    EXTRACT(YEAR FROM ShippedDate) AS Year,\n    EXTRACT(MONTH FROM ShippedDate) AS Month,\n    Freight\nFROM orders \nWHERE EXTRACT(MONTH FROM ShippedDate) = 12\n""""""\n\n# Execute the SQL query and get the data\ndata = execute_sql_query(sql_query)\n\n# Calculate the average freight cost for December\naverage_freight_cost = data[\'Freight\'].mean()\n\n# Print the average freight cost\nprint(f""Average Freight Cost for December: {average_freight_cost:.2f}"")\n\n# Create a DataFrame for the time series visualization\ndata_grouped = data.groupby(\'Year\')[\'Freight\'].mean().reset_index()\n\n# Create a line plot to show the trend of freight costs over the past years\nfig = px.line(data_grouped, x=\'Year\', y=\'Freight\', \n              title=\'Trend of Freight Costs in December Over the Years\',\n              labels={\'Freight\': \'Average Freight Cost\'})\n\n# Show the plot to the user\nshow_to_user(fig)\n```'}","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve freight costs for December orders across the past years
sql_query = """"""
SELECT 
    YEAR(OrderDate) AS OrderYear, 
    AVG(Freight) AS AverageFreight
FROM 
    orders
WHERE 
    MONTH(OrderDate) = 12
GROUP BY 
    YEAR(OrderDate)
ORDER BY 
    OrderYear
""""""

# Execute the SQL query and get the data
freight_data = execute_sql_query(sql_query)

# Calculate the average freight cost
average_freight_cost = freight_data['AverageFreight'].mean()

# Create a time series visualization
fig = px.line(freight_data, x='OrderYear', y='AverageFreight', 
              title='Average Freight Cost for December Orders Over the Years',
              labels={'AverageFreight': 'Average Freight Cost', 'OrderYear': 'Year'})

# Display the results
show_to_user(pd.DataFrame({'Average Freight Cost for December': [average_freight_cost]}))
show_to_user(fig)
```","The provided code incorrectly uses the OrderDate field instead of the ShippedDate field to filter for December, which is inconsistent with the reference implementation. Additionally, the code calculates the average freight cost across years using the aggregated results of averages per year, instead of directly on the individual freight values of December shipments.","```python
import pandas as pd
import plotly.express as px

# Step 1: Write the SQL query to get average freight cost for December orders
sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM OrderDate) AS Year,
    SUM(Freight) AS TotalFreight
FROM 
    orders
WHERE 
    EXTRACT(MONTH FROM OrderDate) = 12
GROUP BY 
    Year
ORDER BY 
    Year;
""""""

# Step 2: Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate average freight cost
avg_freight_cost = orders_df['TotalFreight'].mean()

# Step 3: Prepare time series visualization for freight costs
fig = px.line(orders_df, x='Year', y='TotalFreight',
              title='Freight Costs Trend During December Over the Years',
              labels={'TotalFreight': 'Total Freight Cost'},
              markers=True)

# Step 4: Show the visualization to the user
show_to_user(fig)

# Step 5: Display the average freight cost for December orders
results_df = pd.DataFrame({'AvgFreightCost': [avg_freight_cost]})
show_to_user(results_df)
```","The reference code uses 'ShippedDate' to filter orders shipped in December, while the input code uses 'OrderDate'. The request refers to orders shipped in December. Additionally, the input code calculates 'TotalFreight' and averages this, whereas the reference correctly uses individual freight values for averaging. Lastly, the reference implements a visualization of average freight costs per year, contrasting with the input code which shows total freight per year.",None
"What is the total revenue generated from orders in the last month, and can it be visualized using a line chart to show daily trends?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function to simulate SQL execution
    # Replace with actual database connection and execution logic
    return pd.DataFrame({
        'OrderDate': pd.date_range(start='2023-09-01', end='2023-09-30', freq='D'),
        'TotalRevenue': [100 + i*5 for i in range(30)]  # Example daily revenue
    })

def show_to_user(data):
    # Mock function to simulate displaying results
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch daily revenue for the last month
sql_query = """"""
SELECT o.OrderDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
  AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE)
GROUP BY o.OrderDate
ORDER BY o.OrderDate;
""""""

# Execute the SQL query to get the data
revenue_data = execute_sql_query(sql_query)

# Create a line chart to visualize the daily revenue
fig = px.line(revenue_data, x='OrderDate', y='TotalRevenue', title='Daily Revenue Trends for Last Month')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the last month's date range
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# SQL query to retrieve total revenue generated from orders in the last month
sql_query = f""""""
SELECT 
    DATE(orders.OrderDate) AS OrderDate, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    orders.OrderDate >= '{start_date.strftime('%Y-%m-%d')}' AND 
    orders.OrderDate <= '{end_date.strftime('%Y-%m-%d')}'
GROUP BY 
    DATE(orders.OrderDate)
ORDER BY 
    DATE(orders.OrderDate);
""""""

# Execute the query and get the DataFrame
revenue_data = execute_sql_query(sql_query)

# Visualize the daily trends in a line chart
fig = px.line(revenue_data, x='OrderDate', y='TotalRevenue', title='Total Revenue Daily Trends in the Last Month')
show_to_user(fig)
```","The input code calculates the date range using a fixed 30-day window ending on the current date, whereas the reference code accurately determines the last calendar month using date truncation. Consequently, the input code may include dates from the current month, misaligning with the business request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to extract daily revenue data for the last month
sql_query = """"""
SELECT 
    DATE(orders.OrderDate) AS OrderDate, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS DailyRevenue
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
GROUP BY 
    DATE(orders.OrderDate)
ORDER BY 
    OrderDate
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate total revenue for the last month
total_revenue = df['DailyRevenue'].sum()

# Inform the user about the total revenue
show_to_user(pd.DataFrame({'TotalRevenue': [total_revenue]}))

# Create a line chart to visualize daily revenue trends
fig = px.line(df, x='OrderDate', y='DailyRevenue', title='Daily Revenue Trends for Last Month')

# Display the line chart
show_to_user(fig)
```","The input code calculates the total revenue by summing the 'DailyRevenue' column, but it does not exactly match the filtering criteria of the reference code. The reference code uses DATE_TRUNC to ensure orders are from the previous complete month only, whereas the input code uses DATE_SUB with an interval of 1 month, which may include partial data from the current month. This discrepancy affects the correctness when aligning with the business analytics request.",None
"What is the inventory turnover ratio for the electronics category in 2023, and can you provide a line chart to show its trend over the year?","```python
import pandas as pd
import plotly.express as px

def get_inventory_turnover_ratio():
    # SQL query to calculate the inventory turnover ratio for electronics in 2023
    sql_query = """"""
    SELECT
        SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS inventory_turnover_ratio,
        MONTH(o.OrderDate) AS order_month
    FROM [Order Details] od
    JOIN products p ON od.ProductID = p.ProductID
    JOIN categories c ON p.CategoryID = c.CategoryID
    JOIN orders o ON od.OrderID = o.OrderID
    WHERE c.CategoryName = 'Electronics' AND YEAR(o.OrderDate) = 2023
    GROUP BY MONTH(o.OrderDate)
    ORDER BY order_month
    """"""
    
    # Execute the SQL query and get the result as a DataFrame
    df = execute_sql_query(sql_query)

    # Create a line chart to show the trend of inventory turnover ratio over the months in 2023
    fig = px.line(df, x='order_month', y='inventory_turnover_ratio',
                  title='Inventory Turnover Ratio Trend for Electronics (2023)',
                  labels={'order_month': 'Month', 'inventory_turnover_ratio': 'Inventory Turnover Ratio'})
    
    # Show the plotly figure to the user
    show_to_user(fig)

# Execute the function
get_inventory_turnover_ratio()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    MONTH(orders.OrderDate) AS month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
JOIN 
    products ON [Order Details].ProductID = products.ProductID
JOIN 
    categories ON products.CategoryID = categories.CategoryID
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
    AND categories.CategoryName = 'Electronics'
GROUP BY 
    MONTH(orders.OrderDate)
ORDER BY 
    month
""""""

inventory_turnover_df = execute_sql_query(sql_query)

fig = px.line(inventory_turnover_df, x='month', y='inventory_turnover_ratio', title='Inventory Turnover Ratio for Electronics Category in 2023')
show_to_user(fig)
```","The input Python code correctly implements the logic to calculate the inventory turnover ratio for the electronics category in 2023. It uses an SQL query to join the necessary tables and filter data for the electronics category and the year 2023. It correctly aggregates sales and average inventory data per month. The SQL logic and grouping by month mirror the reference logic. The resulting DataFrame is used to plot a line chart showing the trend of the inventory turnover ratio, adherent to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch inventory turnover for each month in 2023 for the electronics category
sql_query = """"""
SELECT 
    MONTH(orders.OrderDate) AS order_month, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) as turnover 
FROM `Order Details` 
JOIN orders ON `Order Details`.OrderID = orders.OrderID 
JOIN products ON `Order Details`.ProductID = products.ProductID 
WHERE YEAR(orders.OrderDate) = 2023 AND products.Category = 'Electronics' 
GROUP BY order_month 
ORDER BY order_month;
""""""

# Execute the SQL query
turnover_df = execute_sql_query(sql_query)

# Plot the inventory turnover trend over 2023
fig = px.line(turnover_df, x='order_month', y='turnover', 
              title='Inventory Turnover Ratio for Electronics in 2023',
              labels={'order_month': 'Month', 'turnover': 'Turnover Ratio'})

# Show the plot to the user
show_to_user(fig)
```","The input code attempts to calculate the inventory turnover ratio using the 'Category' field from the 'products' table, which seems incorrect. The reference uses a join on the 'categories' table to filter by 'Electronics'. The input should include a join with the 'categories' table as shown in the reference to ensure correct category filtering. Additionally, the input doesn't handle potential division by zero in 'AVG(products.UnitsInStock)', whereas the reference uses 'NULLIF' to avoid this issue.",Base
"What are the top 5 countries in terms of supplier presence, and can this be represented using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation
    pass

# Utility function to show data/visualization to user
def show_to_user(data):
    # Placeholder for actual implementation
    pass

# SQL Query to get top 5 countries by supplier count
sql_query = """"""
SELECT Country, COUNT(DISTINCT SupplierID) AS SupplierCount
FROM suppliers
GROUP BY Country
ORDER BY SupplierCount DESC
LIMIT 5;
""""""

# Execute the query and store result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Country', y='SupplierCount', title='Top 5 Countries by Supplier Presence')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Country, COUNT(*) AS SupplierCount
FROM suppliers
GROUP BY Country
ORDER BY SupplierCount DESC
LIMIT 5;
""""""

top_countries_df = execute_sql_query(sql_query)

fig = px.bar(top_countries_df, x='Country', y='SupplierCount', title='Top 5 Countries by Supplier Presence')
show_to_user(fig)
```","The input code uses COUNT(*) instead of COUNT(DISTINCT SupplierID). This could result in incorrect supplier counts if a supplier has multiple entries per country. The reference code uses COUNT(DISTINCT SupplierID), which accounts for unique suppliers, ensuring accurate counts. Both the SQL query and visualization steps otherwise align with the reference implementation.","```python
import plotly.express as px

# Assume this function is defined and connected to the data analysis environment
def execute_sql_query(sql_query: str):
    # This function is assumed to execute the SQL query and return a pandas DataFrame
    pass

def show_to_user(data):
    # This function is assumed to display data analysis or visualization results
    pass

# SQL query to find the top 5 countries in terms of supplier presence
sql_query = """"""
SELECT Country, COUNT(DISTINCT SupplierID) AS SupplierPresence 
FROM suppliers 
GROUP BY Country 
ORDER BY SupplierPresence DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the results as a DataFrame
df_top_countries = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df_top_countries,
    x='Country',
    y='SupplierPresence',
    title='Top 5 Countries by Supplier Presence',
    labels={'SupplierPresence': 'Number of Unique Suppliers'},
    height=400
)

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It constructs an SQL query to select the country and the count of distinct suppliers, orders them in descending order, and limits the result to the top 5. It then creates and displays a bar chart of these results, just like the reference code. The differences, such as the height customization and label renaming, do not affect the logic or correctness.",Finetuned
"Which categories have the highest number of discontinued products, and how can a bar chart be used to visualize this data?","```python
import pandas as pd
import plotly.express as px

# Define the utility function to execute SQL query and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation that connects to the database
    # For example purposes, returning a sample DataFrame
    return pd.DataFrame({
        'CategoryID': [1, 2, 3],
        'DiscontinuedCount': [10, 15, 5]
    })

# Define the utility function to show data or visualization to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to retrieve discontinued products count by category
sql_query = """"""
SELECT CategoryID, COUNT(*) AS DiscontinuedCount 
FROM products 
WHERE Discontinued = 1 
GROUP BY CategoryID 
ORDER BY DiscontinuedCount DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the discontinued products by category
fig = px.bar(df, x='CategoryID', y='DiscontinuedCount', 
             title='Discontinued Products by Category',
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Number of Discontinued Products'})

# Show the chart to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS DiscontinuedCount
FROM products
WHERE Discontinued = 1
GROUP BY CategoryID
ORDER BY DiscontinuedCount DESC
""""""

discontinued_data = execute_sql_query(sql_query)

fig = px.bar(discontinued_data, 
             x='CategoryID', 
             y='DiscontinuedCount', 
             title='Number of Discontinued Products by Category',
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Number of Discontinued Products'})

show_to_user(fig)
```","The input Python code correctly answers the business analytics request. It computes the count of discontinued products by category using the SQL query, similar to the reference implementation, and uses Plotly Express to create a bar chart for visualization. The logic and method of visualization match those of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch categories with the highest number of discontinued products
sql_query = """"""
SELECT CategoryID, COUNT(*) as DiscontinuedCount 
FROM products 
WHERE Discontinued = 1 
GROUP BY CategoryID 
ORDER BY DiscontinuedCount DESC;
""""""

# Execute the SQL query and get the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Visualize the number of discontinued products per category using a bar chart
fig = px.bar(df, x='CategoryID', y='DiscontinuedCount', 
             title='Number of Discontinued Products by Category',
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Discontinued Count'})

# Display the visualization
show_to_user(fig)
```","The input Python code correctly implements the logic described in the business analytics request. Both the reference and input codes execute a SQL query to retrieve categories with the highest number of discontinued products and visualize the results using a bar chart. The query structure, use of Plotly for visualization, and the overall approach match the reference implementation. Differences, such as chart title and label wording, do not impact correctness.",both
"Which product has generated the highest revenue, and can we visualize the revenue comparison across all products?","import pandas as pd
import plotly.express as px
from utility_functions import execute_sql_query, show_to_user

# SQL query to get total revenue for each product
sql_query = """"""
SELECT ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalRevenue DESC;
""""""

# Execute SQL query and fetch data
df_revenue = execute_sql_query(sql_query)

# Extract the product with the highest revenue
highest_revenue_product = df_revenue.iloc[0]

# Visualization: Revenue comparison across all products
fig = px.bar(df_revenue, x='ProductID', y='TotalRevenue', title='Revenue Comparison Across Products')

# Display visualization
show_to_user(fig)

# Show the highest revenue product
show_to_user(pd.DataFrame([highest_revenue_product]))","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalRevenue DESC
LIMIT 1
""""""

highest_revenue_product = execute_sql_query(sql_query)

sql_query_revenue_comparison = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
""""""

revenue_comparison_df = execute_sql_query(sql_query_revenue_comparison)

fig = px.bar(revenue_comparison_df, x='ProductID', y='TotalRevenue', title='Revenue Comparison Across Products')
show_to_user(fig)
```","The input code does not extract the product with the highest revenue separately for display, nor does it display such information. The SQL query to find the highest revenue product uses a LIMIT 1 clause, which prevents obtaining a DataFrame suitable for visualizing revenue comparison across all products without executing a second query. In contrast, the reference implementation retrieves all products with their revenues in one query and then extracts and displays the highest revenue product along with a complete visualization.","```python
import pandas as pd
import plotly.express as px

# Assume has_execute_sql_query and show_to_user are defined utility functions
def has_execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    pass

# SQL query to retrieve revenue data
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY TotalRevenue DESC;
""""""

# Execute the SQL query
def execute_query_and_visualize():
    # Execute and fetch the data
    revenue_df = has_execute_sql_query(sql_query)
    
    # Extract the product with the highest revenue
    top_product = revenue_df.head(1)
    
    # Visualize the revenue comparison across all products
    fig = px.bar(revenue_df, x='ProductName', y='TotalRevenue', title='Revenue Comparison Across Products')
    
    # Display the results
    show_to_user(top_product)
    show_to_user(fig)

# Execute the function to perform analysis and visualization
execute_query_and_visualize()
```","The input code correctly retrieves and visualizes the revenue data, matching the logic of the reference code. It determines the highest revenue product and displays a bar chart to compare revenues across all products. Differences in column names and SQL syntax do not affect the correctness.",Finetuned
"Which product generated the highest revenue last quarter, and can a bar chart show the revenue distribution across all products?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to execute the query and return a DataFrame
    pass

def show_to_user(data):
    # This function will display the result which can be a DataFrame or a Plotly figure
    if isinstance(data, pd.DataFrame) or isinstance(data, px.Figure):
        data.show()
    else:
        print(""Unsupported data type. Expecting a pandas DataFrame or Plotly figure."")

# SQL query to get revenue for the last quarter
sql_query = """"""
SELECT od.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue 
FROM orders o 
JOIN [Order Details] od 
ON o.OrderID = od.OrderID 
WHERE QUARTER(o.OrderDate) = QUARTER(CURRENT_DATE) - 1 
  AND YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY od.ProductID 
ORDER BY Revenue DESC
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Display the product with the highest revenue
highest_revenue_product = data.iloc[0]
show_to_user(pd.DataFrame([highest_revenue_product]))

# Create a bar chart for revenue distribution across all products
fig = px.bar(data, x='ProductID', y='Revenue', title='Revenue Distribution by Product')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the start and end dates for the last quarter
last_quarter_start = '2023-07-01'
last_quarter_end = '2023-09-30'

# SQL query to get total revenue per product for the last quarter
sql_query = f""""""
SELECT [Order Details].ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '{last_quarter_start}' AND '{last_quarter_end}'
GROUP BY [Order Details].ProductID
ORDER BY TotalRevenue DESC
LIMIT 1
""""""

# Execute SQL query and retrieve product with highest revenue
highest_revenue_product = execute_sql_query(sql_query)

# SQL query to get revenue distribution across all products for the last quarter
sql_query_distribution = f""""""
SELECT [Order Details].ProductID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE orders.OrderDate BETWEEN '{last_quarter_start}' AND '{last_quarter_end}'
GROUP BY [Order Details].ProductID
""""""

# Execute SQL query for revenue distribution
revenue_distribution = execute_sql_query(sql_query_distribution)

# Create a bar chart for revenue distribution
fig = px.bar(revenue_distribution, x='ProductID', y='TotalRevenue', title='Revenue Distribution Across Products (Last Quarter)')
show_to_user(fig)
```","The input code correctly handles the business analytics request. It identifies the product with the highest revenue from the last quarter and generates a bar chart for revenue distribution across all products. Although the approach to define the quarter and execute queries slightly differs from the reference implementation, it achieves the same result by using a date range and two separate SQL queries: one for the highest revenue product and another for the entire revenue distribution. Both the logic and the final outputs are consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query for the top revenue-generating product last quarter
sql_top_product = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS Revenue 
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID 
JOIN 
    orders o ON od.OrderID = o.OrderID 
WHERE 
    o.OrderDate BETWEEN (CURRENT_DATE - INTERVAL '3 MONTH') AND CURRENT_DATE 
GROUP BY 
    p.ProductName 
ORDER BY 
    Revenue DESC 
LIMIT 1;
""""""

# Execute the SQL query to get the top product by revenue
df_top_product = execute_sql_query(sql_top_product)

# Display the top product
show_to_user(df_top_product)

# SQL query to get the revenue distribution across all products
sql_revenue_distribution = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS Revenue 
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID 
JOIN 
    orders o ON od.OrderID = o.OrderID 
WHERE 
    o.OrderDate BETWEEN (CURRENT_DATE - INTERVAL '3 MONTH') AND CURRENT_DATE 
GROUP BY 
    p.ProductName 
ORDER BY 
    Revenue DESC;
""""""

# Execute the SQL query to get the revenue distribution
df_revenue_distribution = execute_sql_query(sql_revenue_distribution)

# Create a bar chart for revenue distribution using Plotly
fig = px.bar(df_revenue_distribution, x='ProductName', y='Revenue',
             title='Revenue Distribution Across Products (Last Quarter)',
             labels={'ProductName': 'Product Name', 'Revenue': 'Revenue'})

# Display the bar chart
show_to_user(fig)
```","The input code uses a different method to calculate the last quarter by using 'CURRENT_DATE - INTERVAL 3 MONTH', which does not accurately capture the previous quarter's data. Additionally, the code does not account for discounts in revenue calculations, unlike the reference code. These discrepancies lead to potentially differing results from the reference implementation.",Base
"Which product categories generate the most revenue, and can this be visualized with a bar chart to enhance understanding?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.CategoryID, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS Revenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.CategoryID 
ORDER BY Revenue DESC;
""""""

# Execute the SQL query and get the result as a DataFrame
category_revenue_df = execute_sql_query(sql_query)

# Visualize the results with a bar chart using Plotly
fig = px.bar(
    category_revenue_df,
    x='CategoryID',
    y='Revenue',
    title='Revenue by Product Category',
    labels={'CategoryID': 'Product Category', 'Revenue': 'Revenue'},
    text='Revenue'
)

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS Revenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY Revenue DESC
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='CategoryID', y='Revenue', title='Revenue by Product Category')
show_to_user(fig)
```","The input code correctly executes the SQL query, grouping by 'CategoryID' and calculating 'Revenue' similar to the reference. Both codes generate a bar chart using Plotly to visualize the revenue by category. The absence of 'labels' and 'text' in the Plotly figure does not alter the logic or correctness as the visualization would still display the intended relationship between CategoryID and Revenue.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName 
ORDER BY revenue DESC
""""""

# Execute the SQL query to get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue by product category
fig = px.bar(df, x='CategoryName', y='revenue', title='Revenue by Product Category', labels={'revenue': 'Revenue', 'CategoryName': 'Product Category'})

# Display the visualization
show_to_user(fig)
```","The input Python code correctly answers the business analytics request and follows the same logic as the reference implementation. Both SQL queries calculate revenue by combining unit price, quantity, and discount, grouping by product category, and ordering by revenue. The key difference is that the input code uses 'CategoryName' from a 'categories' table, which enhances readability without affecting the logic. The visualization and display methods are consistent across both implementations, making the evaluated code correct.",both
"What is the monthly sales performance for each product, and can you include a line chart to visualize the trends over time?","```python
import pandas as pd
import plotly.express as px

# Assume these utility functions are pre-defined and available in the environment
# from your_environment import execute_sql_query, show_to_user

# SQL query to fetch the monthly sales performance for each product
sql_query = """"""
SELECT ProductName, 
       SUM([Order Details].Quantity) AS MonthlySales, 
       EXTRACT(MONTH FROM OrderDate) AS Month 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY ProductName, Month 
ORDER BY ProductName, Month;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Convert month numbers to names for better readability
sales_data['Month'] = sales_data['Month'].apply(lambda x: pd.to_datetime(str(x), format='%m').strftime('%B'))

# Create a line chart to visualize the monthly sales trends of each product
fig = px.line(sales_data, x='Month', y='MonthlySales', color='ProductName', 
              title='Monthly Sales Performance by Product',
              labels={'MonthlySales': 'Sales Quantity', 'Month': 'Month'},
              markers=True)

# Show the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OD.OrderDate, '%Y-%m') AS Month,
    P.ProductName,
    SUM(OD.Quantity) AS TotalSales
FROM 
    products P
JOIN 
    [Order Details] OD ON P.ProductID = OD.ProductID
GROUP BY 
    Month, P.ProductName
ORDER BY 
    Month, P.ProductName;
""""""

monthly_sales_data = execute_sql_query(sql_query)

fig = px.line(monthly_sales_data, x='Month', y='TotalSales', color='ProductName', 
              title='Monthly Sales Performance by Product',
              labels={'TotalSales': 'Total Sales', 'Month': 'Month'})

show_to_user(fig)
```","The reference code extracts the month number from the OrderDate and aggregates sales for each product by month. The input code uses DATE_FORMAT to format the date into a '%Y-%m' string, which groups data by year-month. This might change the aggregation level if there's a requirement to differentiate sales over multiple years. Additionally, the input code does not use EXTRACT to isolate only the month, impacting the aggregation logic compared to the reference.","Here's the Python code to execute the provided SQL query and create a line chart for the monthly sales performance for each product. The code uses libraries like `pandas` for data handling and `plotly.express` for visualization.

```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the data
sql_query = """"""
SELECT EXTRACT(YEAR FROM o.OrderDate) AS Year, 
       EXTRACT(MONTH FROM o.OrderDate) AS Month, 
       p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY YEAR, Month, p.ProductName 
ORDER BY Year, Month;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate SQL execution
    # In practice, this should connect to a database and execute the query
    pass

# Function to display data analyses or visualizations
def show_to_user(data):
    # Placeholder function to simulate displaying data
    pass

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Adjust the date extraction in the DataFrame
if sales_data is not None and 'Year' in sales_data.columns and 'Month' in sales_data.columns:
    sales_data['YearMonth'] = sales_data['Year'].astype(str) + '-' + sales_data['Month'].astype(str).str.zfill(2)

# Create a line chart to visualize sales trends over time
fig = px.line(
    sales_data, 
    x='YearMonth', 
    y='MonthlySales', 
    color='ProductName',
    title='Monthly Sales Performance for Each Product',
    labels={'YearMonth': 'Year-Month', 'MonthlySales': 'Sales ($)'},
    markers=True
)

# Display the line chart
show_to_user(fig)
```

### Explanation:
1. **SQL Execution**: The SQL query is executed to fetch monthly sales performance data for each product, extracting the year and month from `OrderDate`.
  
2. **Data Visualization**: A line chart is created to visualize the trend of monthly sales per product. Each product's sales are traced over time, facilitating a comparative analysis.

3. **Utility Functions**: The code includes utility functions (`execute_sql_query` and `show_to_user`) meant to be placeholders for actual database connection functions and display functions.

4. **Display the Result**: Finally, the line chart is displayed using the `show_to_user` function, which is designed to handle any Pandas DataFrame or Plotly figure.

This approach ensures that the analyst can track and analyze the sales performance of each product over time efficiently.","The input code incorrectly calculates the MonthlySales by including the discount and unit price, whereas the reference implementation sums by quantity. Additionally, it groups data differently by including the year, which affects output consistency with the reference, and the month is formatted differently in the chart.",None
"How does the sales quantity for a product change each month, and can you provide a line chart to visualize the trend?","```python
import pandas as pd  
import plotly.express as px  

# Sample SQL query to retrieve the required data
sql_query = """"""
SELECT 
    P.ProductID, 
    EXTRACT(MONTH FROM O.OrderDate) AS Month, 
    SUM(OD.Quantity) AS MonthlyQuantity 
FROM 
    [Order Details] OD 
JOIN 
    products P ON OD.ProductID = P.ProductID 
JOIN 
    orders O ON OD.OrderID = O.OrderID 
GROUP BY 
    P.ProductID, EXTRACT(MONTH FROM O.OrderDate);
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a mock implementation for the purpose of this environment
    # Replace this implementation with actual SQL execution logic.
    data = {
        'ProductID': [1, 1, 2, 2],
        'Month': [1, 2, 1, 2],
        'MonthlyQuantity': [100, 150, 200, 250]
    }
    return pd.DataFrame(data)

# Function to display the results to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a line chart to visualize the sales trend over months for each product
fig = px.line(
    df, 
    x='Month', 
    y='MonthlyQuantity', 
    color='ProductID', 
    title='Monthly Sales Quantity by Product',
    labels={'MonthlyQuantity': 'Sales Quantity', 'Month': 'Month'}
)

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity) AS TotalQuantity
FROM 
    [Order Details] od
JOIN 
    Orders o ON od.OrderID = o.OrderID
JOIN 
    products p ON od.ProductID = p.ProductID
WHERE 
    p.Discontinued = 0
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='Month', y='TotalQuantity', title='Monthly Sales Quantity Trend')
show_to_user(fig)
```","The input code aggregates and visualizes sales quantities based on months, but it does not provide a breakdown by product as requested. The reference code groups data by both ProductID and Month, visualizing trends for each product separately using color. The input code only groups by Month and lacks differentiation by ProductID in the resulting line chart.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM(Quantity) AS SalesQuantity 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY Month;
""""""

# Execute the SQL query using provided utility function
sales_data = execute_sql_query(sql_query)

# Ensure data is sorted by month
sales_data = sales_data.sort_values(by='Month')

# Create a line chart using Plotly
fig = px.line(
    sales_data, 
    x='Month', 
    y='SalesQuantity', 
    title='Monthly Sales Quantity Trend',
    labels={'SalesQuantity': 'Sales Quantity', 'Month': 'Month'}
)

# Show the figure to the user
show_to_user(fig)
```","The provided code does not align with the reference code. It groups data by formatted month ('%Y-%m') without distinguishing between different products, whereas the reference groups by product and month. Thus, it does not show product-level trends, which is a key requirement of the request.",None
Identify trends in product sales over the last year using monthly data and represent these trends with an appropriate line chart.,"```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user functions are already defined as per the environment constraints.

# SQL query to retrieve sales data from the last year
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, ProductID, SUM(Quantity) AS TotalSold 
FROM [Order Details] 
WHERE OrderDate >= DATEADD(YEAR, -1, CURRENT_DATE) 
GROUP BY EXTRACT(MONTH FROM OrderDate), ProductID 
ORDER BY Month;
""""""

# Execute SQL query and fetch data into a DataFrame
sales_data = execute_sql_query(sql_query)

# Pivoting the DataFrame to get total sales per month for each product
monthly_sales = sales_data.pivot_table(index='Month', columns='ProductID', values='TotalSold', aggfunc='sum').fillna(0)

# Create a line chart to visualize trends in product sales over the last year
fig = px.line(monthly_sales, 
              labels={'value': 'Total Products Sold', 'Month': 'Month'},
              title='Trends in Product Sales Over the Last Year')

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(O.OrderDate, '%Y-%m') AS Month,
    SUM(OD.Quantity) AS Total_Sales
FROM 
    Orders O
JOIN 
    [Order Details] OD ON O.OrderID = OD.OrderID
WHERE 
    O.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='Month', y='Total_Sales', title='Trends in Product Sales Over the Last Year')
show_to_user(fig)
```","The input code does not adhere to the same logic as the reference implementation. The input code aggregates sales by month across all products combined, while the reference implementation aggregates sales per month for each product separately. This results in a different understanding of product sales trends, as trends specific to individual products are not represented in the input code.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT ProductName, 
    DATE_TRUNC('month', o.OrderDate) AS Month, 
    SUM(od.Quantity) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2022-10-01' AND '2023-09-30' 
GROUP BY ProductName, Month 
ORDER BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Aggregate monthly sales per product
monthly_sales = df.groupby(['Month', 'ProductName']).agg({'TotalSales': 'sum'}).reset_index()

# Pivot the DataFrame for plotting
pivoted_sales = monthly_sales.pivot(index='Month', columns='ProductName', values='TotalSales').fillna(0)

# Generate the line chart using Plotly
fig = px.line(pivoted_sales, x=pivoted_sales.index, y=pivoted_sales.columns, 
              title='Trend of Product Sales Over the Last Year',
              labels={'value': 'Total Sales', 'Month': 'Month'})

# Show the results to the user
show_to_user(fig)
```","The input Python code answers the business request correctly by fetching monthly product sales data from the last year, calculating total sales per product, and visualizing trends with a line chart. It follows the same logic as the reference implementation: querying data, aggregating monthly sales, pivoting the data for visualization, and plotting a line chart. Differences in SQL syntax (e.g., date range) and the inclusion of product names do not affect the correctness since they still adhere to the core logic and requirements of the task.",Finetuned
"What is the growth rate of sales for each employee over the past year, and can it be visualized using a line chart for better understanding?","```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user are already defined somewhere in the environment.

# SQL query to retrieve the growth rate
sql_query = """"""
SELECT e.EmployeeID, 
       (SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
                 THEN od.UnitPrice * od.Quantity * (1 - od.Discount)
                 ELSE 0 END) - 
        SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1 
                 THEN od.UnitPrice * od.Quantity * (1 - od.Discount)
                 ELSE 0 END)) / 
       NULLIF(SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1 
                       THEN od.UnitPrice * od.Quantity * (1 - od.Discount)
                       ELSE 0 END), 0) AS GrowthRate
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query to get data
sales_growth_df = execute_sql_query(sql_query)

# Ensure there's a non-empty DataFrame with correct data
if not sales_growth_df.empty:
    # Plotting the sales growth rate for each employee
    fig = px.line(sales_growth_df, x='EmployeeID', y='GrowthRate', title='Growth Rate of Sales per Employee Over the Past Year')
    
    # Show the figure to the user
    show_to_user(fig)
else:
    # If data is empty or any edge case
    print(""No data found for sales growth rate."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    e.EmployeeID, Month
ORDER BY 
    e.EmployeeID, Month;
""""""

sales_data = execute_sql_query(sql_query)

sales_growth = sales_data.pivot(index='Month', columns='EmployeeID', values='TotalSales').fillna(0)
sales_growth = sales_growth.pct_change().fillna(0) * 100

fig = px.line(sales_growth, title='Growth Rate of Sales for Each Employee Over the Past Year', 
              labels={'value':'Growth Rate (%)', 'index':'Month'})
show_to_user(fig)
```","The input code calculates monthly sales and attempts a percentage change using pivoted data, but this does not align with the business request or reference code logic. The reference code calculates the annual growth rate by comparing total sales from the current and previous year, grouped by employee. The input code mistakenly applies a monthly percentage change, which does not answer the growth over the past year accurately by employee.","```python
import pandas as pd
import plotly.express as px

# Placeholder for the execute_sql_query function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should interact with your SQL database and return the result as a DataFrame.
    # Assume it's implemented and returns a DataFrame when called.
    pass

# Placeholder for the show_to_user function
def show_to_user(data):
    # This function should display the data in a user-friendly format.
    # It can display DataFrames or Plotly figures.
    pass

# SQL query to get the growth rate of sales for each employee over the past year
sql_query = """"""
SELECT e.EmployeeID, 
       (SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURDATE()) THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END) - 
        SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURDATE()) - 1 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END)) / 
        NULLIF(SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURDATE()) - 1 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END), 0) * 100 AS GrowthRate 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not df.empty:
    # Plotting the growth rate for each employee using Plotly
    fig = px.line(df, x='EmployeeID', y='GrowthRate', title='Employee Sales Growth Rate Over the Past Year',
                  labels={'EmployeeID': 'Employee ID', 'GrowthRate': 'Growth Rate (%)'})
    # Show the figure to the user
    show_to_user(fig)
else:
    print(""No data available for the specified query."")
```","The input code correctly calculates the growth rate of sales for each employee over the past year, similarly to the reference implementation. Both implementations follow the same approach: they compute the sales for the current year and the previous year, calculate the growth rate, and plot the data using Plotly. The input adds a multiplication by 100 to convert the growth rate to a percentage, which doesn't change the logic of the calculation but is rather a display enhancement. Both implementations check if the DataFrame is not empty before attempting to plot.",Finetuned
Identify the orders shipped with discount greater than 10% and visualize the distribution of discounts using a histogram or bar chart.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query
sql_query = ""SELECT OrderID, Discount FROM orders JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID WHERE [Order Details].Discount > 0.10;""
orders_with_discount_df = execute_sql_query(sql_query)

# Visualize the distribution of discounts using a histogram
fig = px.histogram(orders_with_discount_df, x='Discount', title='Distribution of Discounts Greater than 10%')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.Discount 
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount > 0.10
""""""

discount_data = execute_sql_query(sql_query)

fig = px.histogram(discount_data, x=""Discount"", title=""Distribution of Discounts Greater than 10%"")
show_to_user(fig)
```","The input Python code correctly executes a SQL query to select discounts greater than 10% and visualizes their distribution using a histogram. The query structure and logic match the reference implementation, focusing on the 'Discount' field. The join between 'Order Details' and 'orders' tables based on 'OrderID' is also consistent with the reference. Thus, the code fulfills the business analytics request accurately.","```python
import pandas as pd
import plotly.express as px

# Assuming the definitions of execute_sql_query and show_to_user
# are provided in the Python environment.

# SQL Query to identify orders with discounts greater than 10%
sql_query = """"""
SELECT OrderID, Discount FROM [Order Details] WHERE Discount > 0.1;
""""""

# Execute the SQL query using the provided utility function
orders_with_discount = execute_sql_query(sql_query)

# Visualize the distribution of discounts using a histogram
fig = px.histogram(orders_with_discount, x='Discount', title='Distribution of Discounts > 10%')

# Display the figure
show_to_user(fig)
```","The input Python code differs from the reference implementation as it only queries the 'Order Details' table. The reference implementation joins 'orders' and 'Order Details' using the OrderID to ensure orders are filtered accurately. Without this join, the query might include incomplete order data, compromising accuracy.",Base
"What is the monthly trend of order values for the top 3 customers by sales, and how can it be visualized to enhance understanding?","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT customers.CustomerID, 
       DATE_TRUNC('month', orders.OrderDate) AS month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID, month 
ORDER BY order_value DESC 
LIMIT 3
""""""

# Execute the SQL query and fetch results into a DataFrame
df = execute_sql_query(sql_query)

# Ensure we have at least 3 top customers for analysis (in case of ties in order_value)
top_customers = df['CustomerID'].unique()

# Correct the logic to only focus on the top 3 customers based on unique occurrence
if len(top_customers) > 3:
    top_customers = top_customers[:3]

# Filter DataFrame for top 3 customers by sales
filtered_df = df[df['CustomerID'].isin(top_customers)]

# Sort the DataFrame for ease of visualization
filtered_df = filtered_df.sort_values(by=['CustomerID', 'month'])

# Create a line plot using Plotly
fig = px.line(filtered_df, 
              x='month', 
              y='order_value', 
              color='CustomerID', 
              title='Monthly Trend of Order Values for Top 3 Customers',
              labels={'order_value': 'Order Value', 'month': 'Month'})

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve the top 3 customers by total sales
top_customers_query = """"""
SELECT CustomerID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY CustomerID 
ORDER BY total_sales DESC 
LIMIT 3
""""""
top_customers_df = execute_sql_query(top_customers_query)

# Step 2: Get monthly order values for these customers
top_customer_ids = tuple(top_customers_df['CustomerID'])

monthly_trend_query = f""""""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS order_month, 
       orders.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS monthly_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.CustomerID IN {top_customer_ids}
GROUP BY order_month, orders.CustomerID
ORDER BY order_month, orders.CustomerID
""""""
monthly_trend_df = execute_sql_query(monthly_trend_query)

# Step 3: Visualize the monthly trend of order values
fig = px.line(monthly_trend_df, x='order_month', y='monthly_sales', color='CustomerID', 
              title='Monthly Trend of Order Values for Top 3 Customers',
              labels={'order_month': 'Order Month', 'monthly_sales': 'Monthly Sales'})
show_to_user(fig)
```","The evaluated code does not limit the monthly sales query to the top 3 customers based on the total sales value. It first retrieves the top 3 customers by sales, but this logic does not ensure that the top customers for monthly sales are also the top overall sales. In the reference implementation, it directly selects the top 3 sales records by monthly values, avoiding a discrepancy that could arise from customers who aren't consistently top each month. Additionally, the reference implementation ensures the top customers are unique by checking the length of unique `CustomerID`s.","```python
import plotly.express as px
import pandas as pd

# Hypothetically defined function to execute an SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Pseudo code to mock SQL execution
    pass

# Hypothetical function to display data to user
def show_to_user(data):
    # Pseudo code for displaying data
    pass

# SQL Query to retrieve data
sql_query = """"""
SELECT YEAR(OrderDate) AS Year, MONTH(OrderDate) AS Month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS MonthlySales,
customers.CustomerID
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN customers ON orders.CustomerID = customers.CustomerID
WHERE customers.CustomerID IN (
    SELECT CustomerID FROM (
        SELECT c.CustomerID, 
        SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalCustomerSales 
        FROM [Order Details] od 
        JOIN orders o ON od.OrderID = o.OrderID 
        JOIN customers c ON o.CustomerID = c.CustomerID 
        GROUP BY c.CustomerID 
        ORDER BY TotalCustomerSales DESC LIMIT 3
    ) AS TopCustomers
)
GROUP BY Year, Month, customers.CustomerID
ORDER BY Year, Month;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Generate a line plot visualizing the monthly trend of order values for the top 3 customers
fig = px.line(df, x='Month', y='MonthlySales', color='CustomerID',
              title='Monthly Trend of Order Values for Top 3 Customers',
              labels={'MonthlySales': 'Monthly Sales', 'Month': 'Month', 'CustomerID': 'Customer ID'},
              line_shape='linear')

# Show the plot to the user
show_to_user(fig)
```","Both implementations aim to retrieve and visualize the monthly trend of order values for the top 3 customers by total sales. The reference code aggregates sales using a common SQL query approach to get the top 3 customers. Similarly, the input code also identifies the top 3 customers by total sales using subqueries and then aggregates monthly sales. Both generate similar line plots using Plotly, with the focus on monthly order values for these top customers. While the syntax and query construction differ slightly, the logic and output are aligned with the business analytics request.",Finetuned
"What is the total quantity ordered for discontinued products, and can this be visualized with a bar chart showing quantities per product?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch data
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE p.Discontinued = 1 
GROUP BY p.ProductName;
""""""

# Execute the SQL query and retrieve the data into a DataFrame
df = execute_sql_query(sql_query)

# Visualize the total quantities ordered for each discontinued product using a bar chart
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Total Quantity Ordered for Discontinued Products')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 1
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC;
""""""

discontinued_products = execute_sql_query(sql_query)

fig = px.bar(discontinued_products, x='ProductName', y='TotalQuantity',
             title='Total Quantity Ordered for Discontinued Products',
             labels={'TotalQuantity': 'Total Quantity Ordered', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input Python code is correct as it executes the same SQL query to calculate the total quantity of discontinued products. The query correctly joins the 'products' and 'Order Details' tables, filters for discontinued products, groups by 'ProductName', and sums the quantities. The difference in logic with the reference code is the addition of 'ORDER BY TotalQuantity DESC', which is acceptable as it only orders the results and does not affect the correctness of the output. Additionally, the code utilizes Plotly Express to generate a bar chart and uses the 'show_to_user' function to display it, just like the reference code. Thus, the input code adheres to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Business Logic Implementation
# SQL query to get quantity ordered for discontinued products
sql_query = """"""
SELECT ProductID, QuantityOrdered FROM [Order Details] 
WHERE ProductID IN (SELECT ProductID FROM products WHERE Discontinued = 1);
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation would connect to your SQL database, run the query,
    # and return the result as a pandas DataFrame.
    pass  # Replace with actual implementation

def show_to_user(data):
    # Replace with the actual implementation that shows the data.
    if isinstance(data, pd.DataFrame):
        print(data)  # Example implementation for data
    else:
        data.show()  # Should handle Plotly figures

# Execute the query and get the data
df_order_details = execute_sql_query(sql_query)

# Check if data is not empty
if not df_order_details.empty:
    # Aggregate quantity per product ID
    df_aggregated = df_order_details.groupby('ProductID').agg({'QuantityOrdered': 'sum'}).reset_index()

    # Create a bar chart using Plotly
    fig = px.bar(df_aggregated, x='ProductID', y='QuantityOrdered', title='Total Quantity Ordered for Discontinued Products')

    # Show the bar chart to the user
    show_to_user(fig)
else:
    print(""No data found for discontinued products."")
```","The input code does not align with the reference implementation as it misses aggregating the quantity by ProductName. It groups by ProductID instead, which might not correspond to descriptive product names required for visualization. The reference uses a subquery to directly retrieve ProductName and sum quantities.",Base
"How many distinct customers made a purchase in Q1 2023 versus Q2 2023, and can we visualize this comparison using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT 
  (SELECT COUNT(DISTINCT orders.CustomerID) 
   FROM orders 
   WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_customers, 
  (SELECT COUNT(DISTINCT orders.CustomerID) 
   FROM orders 
   WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30') AS Q2_customers
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Prepare data for visualization
df = pd.DataFrame({
    ""Quarter"": [""Q1 2023"", ""Q2 2023""],
    ""Distinct Customers"": [data.loc[0, ""Q1_customers""], data.loc[0, ""Q2_customers""]]
})

# Create a bar chart using Plotly
fig = px.bar(df, x=""Quarter"", y=""Distinct Customers"", title=""Distinct Customers in Q1 vs Q2 2023"")

# Show the visualization to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

q1_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS distinct_customers_q1 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

q2_query = """"""
SELECT COUNT(DISTINCT CustomerID) AS distinct_customers_q2 
FROM orders 
WHERE OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
""""""

q1_data = execute_sql_query(q1_query)
q2_data = execute_sql_query(q2_query)

comparison_df = pd.DataFrame({
    'Quarter': ['Q1 2023', 'Q2 2023'],
    'Distinct Customers': [q1_data['distinct_customers_q1'][0], q2_data['distinct_customers_q2'][0]]
})

fig = px.bar(comparison_df, x='Quarter', y='Distinct Customers', 
             title='Distinct Customers Comparison: Q1 2023 vs Q2 2023')

show_to_user(fig)
```","Both implementations perform equivalent SQL queries to count distinct customers for Q1 and Q2 2023. They execute these queries separately but achieve the same result. Data preparation for visualization and the use of Plotly for bar chart creation are logically consistent across both implementations. Therefore, the input Python code is correct.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL queries provided for Q1 and Q2
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function. In practice, this should connect to a database and execute the SQL query.
    # For demonstration, let's assume this function returns a DataFrame.
    pass

q1_sql = ""SELECT COUNT(DISTINCT CustomerID) AS unique_customers FROM orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'""
q2_sql = ""SELECT COUNT(DISTINCT CustomerID) AS unique_customers FROM orders WHERE OrderDate BETWEEN '2023-04-01' AND '2023-06-30'""

# Fetch the data for Q1 and Q2
q1_df = execute_sql_query(q1_sql)
q2_df = execute_sql_query(q2_sql)

# Extract the number of distinct customers
q1_customers = q1_df['unique_customers'].iloc[0]
q2_customers = q2_df['unique_customers'].iloc[0]

# Prepare the data for visualization
data = pd.DataFrame({
    'Quarter': ['Q1 2023', 'Q2 2023'],
    'Distinct Customers': [q1_customers, q2_customers]
})

# Create a bar chart using Plotly
fig = px.bar(data, x='Quarter', y='Distinct Customers', title='Distinct Customers in Q1 vs Q2 2023')

# Display the visualization
show_to_user(fig)
```","The provided code is correct as it accomplishes the same task as the reference implementation. Both implementations execute SQL queries to count distinct customers for Q1 2023 and Q2 2023, extract the results into a Pandas DataFrame, and use Plotly to generate a bar chart for visualization. The logic and output fulfill the business analytics request.",both
"What is the average shipping time for orders shipped to each region, and can you provide a bar chart to visualize the comparison?","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to obtain the data
sql_query = """"""
SELECT ShipRegion, AVG(DATE_PART('day', ShippedDate - OrderDate)) AS AvgShipTime
FROM orders
GROUP BY ShipRegion;
""""""
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(df, x='ShipRegion', y='AvgShipTime', title='Average Shipping Time by Region')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY ShipRegion
""""""

shipping_times_df = execute_sql_query(sql_query)

fig = px.bar(shipping_times_df, 
             x='ShipRegion', 
             y='AverageShippingTime', 
             title='Average Shipping Time by Region', 
             labels={'AverageShippingTime': 'Average Shipping Time (days)', 'ShipRegion': 'Region'})

show_to_user(fig)
```","The provided code is correct as it accomplishes the business analytics request effectively. Both implementations calculate the average shipping time for each region and generate a bar chart to visualize the data. The main differences are stylistic and functional equivalence is maintained: the use of DATEDIFF and WHERE clause to exclude null ShippedDates, which aligns with the business logic. The use of labels in the Plotly chart is an enhancement but doesn't alter the outcome, confirming that the input code adheres to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch average shipping time per region
sql_query = """"""
SELECT ShipRegion, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime 
FROM orders 
GROUP BY ShipRegion;
""""""

# Function to execute the SQL query and retrieve data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL query execution
    # The function is expected to return a pandas DataFrame
    # In a real-world scenario, this would connect to a database
    pass

# Function to display data to the user
def show_to_user(data):
    # Placeholder function to display data
    # In a real scenario, this would define how to present data
    pass

# Fetching the data
df = execute_sql_query(sql_query)

# Create a bar chart visualizing the average shipping time per region
fig = px.bar(
    df,
    x='ShipRegion',
    y='AvgShippingTime',
    title='Average Shipping Time by Region',
    labels={'ShipRegion': 'Region', 'AvgShippingTime': 'Average Shipping Time (days)'}
)

# Display the plot
show_to_user(fig)
```","The input code and the reference implementation fulfill the same business request. Both codes apply an SQL query to calculate the average shipping time per region by subtracting the OrderDate from the ShippedDate. The difference lies in the function used within the SQL query: 'DATE_PART('day', ...)' is equivalent to 'DATEDIFF(...)' for extracting the day part of the date difference. Both produce a DataFrame with 'ShipRegion' and average shipping time data, and both generate a bar chart using Plotly to visualize this data. The chart configurations are consistent between the two codes, ensuring that the purpose of visual comparison of average shipping time by region is met.",both
"What is the total discount given on all orders each month, and can you provide a line chart to illustrate the monthly trends?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, 
       SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
GROUP BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create the line chart using Plotly
fig = px.line(df, x='Month', y='TotalDiscount', title='Monthly Total Discounts on Orders')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.Discount * od.UnitPrice * od.Quantity) AS total_discount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    month
ORDER BY 
    month;
""""""

discount_data = execute_sql_query(sql_query)

fig = px.line(discount_data, x='month', y='total_discount', title='Monthly Total Discount Given on Orders')
show_to_user(fig)
```","The input code correctly calculates total discounts per month by summing the product of Discount, UnitPrice, and Quantity after joining 'orders' and 'Order Details' tables. The SQL function `DATE_TRUNC('month', o.OrderDate)` is analogous to `DATE_FORMAT(o.OrderDate, '%Y-%m')`, used in the reference to extract the monthly period. Although the SQL syntax (brackets vs. backticks) and the order of multiplication differ, the logic is effectively the same. The line chart implementation uses Plotly to visualize the data by month, fulfilling the request.","
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the total discount given on all orders each month
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, SUM(UnitPrice * Quantity * Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY Month;
""""""

# Utility function that simulates SQL query execution
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated data for the purpose of this example
    data = {
        ""Month"": pd.to_datetime([""2023-01-01"", ""2023-02-01"", ""2023-03-01""]),
        ""TotalDiscount"": [1234.56, 7890.12, 3456.78]
    }
    return pd.DataFrame(data)

# Utility function that simulates displaying a figure
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif hasattr(data, 'show'):
        data.show()

# Fetching data using the execute_sql_query utility function
df = execute_sql_query(sql_query)

# Converting the Month column to datetime format if necessary
df['Month'] = pd.to_datetime(df['Month'])

# Creating a line chart to illustrate the monthly trends
fig = px.line(df, x='Month', y='TotalDiscount', title='Monthly Total Discounts')

# Display the figure using the show_to_user utility function
show_to_user(fig)
","The input code computes the monthly total discount using SQL with `DATE_TRUNC('month', OrderDate)` but incorrectly selects data from '[Order Details]', missing the necessary join with 'orders'. This could lead to missing 'OrderDate' as it should be joined from the 'orders' table as indicated by the reference. Moreover, the SQL syntax seems to use a non-standard format with square brackets, which is typically not used in SQL queries. The logic of joining tables correctly is critical for the correctness of the query execution.",Base
What are the top five cities with the highest sales revenue? Please include a bar chart to visualize the comparison among these cities.,"
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the sales data
sql_query = '''
SELECT ShipCity, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS CitySales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipCity 
ORDER BY CitySales DESC 
LIMIT 5;
'''

# Execute the query and get a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ShipCity', y='CitySales',
             title='Top 5 Cities by Sales Revenue',
             labels={'ShipCity': 'City', 'CitySales': 'Sales Revenue'},
             text_auto=True)

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by city
sql_query = """"""
SELECT o.ShipCity, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.ShipCity
ORDER BY TotalSales DESC
LIMIT 5
""""""

# Execute the SQL query
top_cities_sales = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(top_cities_sales, x='ShipCity', y='TotalSales', title='Top 5 Cities with Highest Sales Revenue')

# Show the chart to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to obtain the top 5 cities with the highest sales revenue. The logic used in the SQL query matches the reference implementation, with the proper aggregation and ordering of sales data. Furthermore, it uses Plotly to generate a bar chart visualizing the sales revenue, similar to the reference implementation. Therefore, the code meets the business request requirements.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to execute
sql_query = """"""
SELECT 
    o.ShipCity, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM 
    orders o 
JOIN 
    [Order Details] od 
ON 
    o.OrderID = od.OrderID 
GROUP BY 
    o.ShipCity 
ORDER BY 
    TotalRevenue DESC 
LIMIT 5;
""""""

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Example implementation; replace with actual database interaction code
    pass

# Function to display data or visualizations
def show_to_user(data):
    # Example implementation; replace with actual display logic
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query and get the results
df_top_cities = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top five cities by sales revenue
fig = px.bar(df_top_cities, x='ShipCity', y='TotalRevenue', 
             title='Top 5 Cities by Sales Revenue',
             labels={'ShipCity': 'City', 'TotalRevenue': 'Total Revenue'},
             text_auto=True)

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the business request by selecting the top five cities with the highest sales revenue from a database. It uses a similar SQL query to the reference code with the only difference being in the column alias, which is functionally equivalent. The data is then visualized using a Plotly bar chart, consistent with the reference implementation. Both functions to execute SQL queries and display results are included, adhering to the logic of the reference implementation.",both
"What is the average discount offered on products, and can you provide a histogram to display the distribution of discounts?","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query and retrieve data as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the logic to connect to the database,
    # execute the query, and return the results as a DataFrame.
    # Placeholder code for demonstration purposes.
    pass

# Function to display data or visualization
def show_to_user(data):
    # This function should contain logic to output data or render visualizations.
    # For Plotly figures, it should use the Plotly rendering approach.
    pass

# SQL query to get the average discount
sql_query_avg_discount = ""SELECT AVG(Discount) as AvgDiscount FROM [Order Details];""
avg_discount_df = execute_sql_query(sql_query_avg_discount)

# Extracting average discount from the DataFrame
if not avg_discount_df.empty:
    average_discount = avg_discount_df['AvgDiscount'].iloc[0]
    print(f""Average Discount: {average_discount}"")
else:
    print(""No data available for average discount calculation."")

# SQL query to get all discounts for histogram
sql_query_all_discounts = ""SELECT Discount FROM [Order Details];""
discounts_df = execute_sql_query(sql_query_all_discounts)

# Create a histogram to display the distribution of discounts
if not discounts_df.empty:
    fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts')
    show_to_user(fig)
else:
    print(""No data available for discount distribution."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Discount
FROM [Order Details]
""""""
discount_data = execute_sql_query(sql_query)

average_discount = discount_data['Discount'].mean()

fig = px.histogram(discount_data, x='Discount', title='Distribution of Discounts')
show_to_user(fig)

average_discount
```","The input code correctly calculates the average discount using the mean of the 'Discount' column from the SQL query result, which aligns with the business request. It also uses Plotly to create and display a histogram of the discounts, following a similar approach to the reference implementation by querying the discount data and visualizing it with Plotly. The logic is consistent with the reference implementation, fulfilling both parts of the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Query to fetch the average discount
avg_discount_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# Execute the query and retrieve average discount
avg_discount_df = execute_sql_query(avg_discount_query)

# Display the average discount result
show_to_user(avg_discount_df)

# Query to fetch all discounts for histogram
discounts_query = ""SELECT Discount FROM [Order Details];""

# Execute the query to fetch discounts
discounts_df = execute_sql_query(discounts_query)

# Create a histogram of the discounts
fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts', labels={'Discount': 'Discount'})

# Display the histogram
show_to_user(fig)
```","The input code correctly answers the business analytics request and follows the same logic as the reference implementation. Both implementations execute SQL queries to calculate the average discount and to retrieve all discounts for creating a histogram. After obtaining the results, the average discount is displayed, and a Plotly histogram is created and shown. The use of `show_to_user` ensures the results are communicated effectively, similar to the reference code. Therefore, the input code meets the specified requirements.",both
"What is the total number of products that are out of stock, and can we visualize the data using a bar chart showing the out-of-stock quantities by product category?","```python
import pandas as pd
import plotly.express as px

# Function to perform the analysis
def out_of_stock_analysis():
    # SQL query to get out-of-stock product counts by category
    sql_query = """"""
    SELECT CategoryName, COUNT(*) as OutOfStockCount
    FROM products
    JOIN categories ON products.CategoryID = categories.CategoryID
    WHERE UnitsInStock = 0
    GROUP BY CategoryName
    """"""
    
    # Use the utility function to execute the SQL query
    out_of_stock_data = execute_sql_query(sql_query)
    
    # Visualize using a bar chart
    fig = px.bar(out_of_stock_data, x='CategoryName', y='OutOfStockCount',
                 title='Out-of-Stock Quantities by Product Category',
                 labels={'CategoryName': 'Product Category', 'OutOfStockCount': 'Out of Stock'})
    
    # Display the visualization
    show_to_user(fig)

# Run the analysis
out_of_stock_analysis()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    categories.CategoryName, 
    SUM(products.UnitsInStock) as OutOfStockQuantity 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE products.UnitsInStock = 0 
GROUP BY categories.CategoryName
""""""

out_of_stock_data = execute_sql_query(sql_query)

total_out_of_stock = out_of_stock_data['OutOfStockQuantity'].sum()

fig = px.bar(out_of_stock_data, x='CategoryName', y='OutOfStockQuantity', 
             title=f'Total Out of Stock Products: {total_out_of_stock}',
             labels={'OutOfStockQuantity': 'Out of Stock Quantity', 'CategoryName': 'Product Category'})

show_to_user(fig)
```","The provided input code uses SUM instead of COUNT to calculate out-of-stock products, which doesn't match the logic of the reference implementation. The reference implementation counts the products with zero stock, while the input code incorrectly sums the 'UnitsInStock' field and groups it as 'OutOfStockQuantity'. The visualization naming in the input code implying a count, but the logic calculates a quantity incorrectly.","```python
import pandas as pd
import plotly.express as px

# Step 1: Execute SQL query to get out-of-stock products by category
sql_query = """"""
SELECT ProductCategory, COUNT(*) as OutOfStockCount
FROM products
WHERE QuantityInStock = 0
GROUP BY ProductCategory;
""""""

# Execute SQL query and retrieve results in a DataFrame
out_of_stock_df = execute_sql_query(sql_query)

# Step 2: Visualize data using a bar chart
fig = px.bar(out_of_stock_df, x='ProductCategory', y='OutOfStockCount', 
             title='Out-of-Stock Quantities by Product Category',
             labels={'OutOfStockCount': 'Number of Out of Stock Products'})

# Step 3: Use the provided utility function to display the results
show_to_user(fig)
```","The evaluated code doesn't correctly adhere to the reference implementation due to some discrepancies. The SQL query in the evaluated code lacks a JOIN with the categories table, meaning it won't include category names, which are required for grouping in the reference code. Additionally, the column names used ('ProductCategory' and 'QuantityInStock') do not match the reference implementation ('CategoryName' and 'UnitsInStock'), suggesting a possible schema mismatch or error. These differences mean the evaluated code may not produce the same result as intended.",None
Which customer generated the most revenue last year and can this be visualized with a bar chart showing each customer's revenue?,"```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str):
    # Implementation to connect to database and execute the query
    # In this mock implementation, return an empty DataFrame
    return pd.DataFrame({
        'CustomerID': ['C001', 'C002', 'C003', 'C004'],
        'TotalRevenue': [1500.50, 2300.75, 3000.00, 500.25]
    })

def show_to_user(data):
    # Implementation to show data or a Plotly figure
    # Here we'll just print the DataFrame or show the Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to retrieve revenue data
sql_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= '2022-01-01' AND o.OrderDate <= '2022-12-31' 
GROUP BY c.CustomerID 
ORDER BY TotalRevenue DESC
""""""

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Prepare bar chart using Plotly
fig = px.bar(revenue_data, x='CustomerID', y='TotalRevenue', title='Customer Revenue for 2022')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

last_year = 2022
sql_query = f""""""
SELECT c.CustomerID, c.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = {last_year}
GROUP BY c.CustomerID, c.CompanyName
ORDER BY Revenue DESC
""""""

customer_revenue_df = execute_sql_query(sql_query)
top_customer = customer_revenue_df.iloc[0]

fig = px.bar(customer_revenue_df, x='CompanyName', y='Revenue', title='Customer Revenue for Last Year')
show_to_user(fig)
```","The input Python code accurately follows the same logic as the reference implementation. It calculates the total revenue for each customer for a specified year (2022), sorts them in descending order to identify the top customer, and creates a bar chart using Plotly to visualize each customer's revenue. The code execution involves a SQL query similar to the reference, grouping by customer, and the bar chart displays 'CompanyName' instead of 'CustomerID', which is a valid change. Therefore, the code correctly fulfills the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total revenue per customer from last year
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS customer_revenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY customers.CustomerID 
ORDER BY customer_revenue DESC;
""""""

# Execute SQL query to get data
customer_revenue_df = execute_sql_query(sql_query)

# Select the customer with the most revenue
top_customer = customer_revenue_df.iloc[0]

# Display top customer information
show_to_user(pd.DataFrame([top_customer]))

# Visualize all customers' revenue with a bar chart
fig = px.bar(customer_revenue_df, 
             x='CustomerID', 
             y='customer_revenue',
             title='Customer Revenue for Last Year',
             labels={'customer_revenue': 'Revenue', 'CustomerID': 'Customer ID'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates and visualizes the revenue per customer for the previous year. It retrieves the data with an SQL query, processes it to find and display the top customer's revenue, and visualizes all customer revenues using a bar chart. While it uses `YEAR(CURDATE()) - 1` to determine the date range, the logic aligns with the reference implementation's request for revenue in the previous year. Both versions achieve the same analytical goal and produce the required output.",both
"How many distinct products have been sold, and can you provide a visualization to illustrate the diversity of product categories?","```python
import plotly.express as px
import pandas as pd

# SQL queries
distinct_products_query = ""SELECT COUNT(DISTINCT ProductID) AS distinct_product_count FROM [Order Details];""
product_categories_query = """"""
SELECT CategoryName, COUNT(DISTINCT ProductID) AS count_product
FROM Products
JOIN Categories ON Products.CategoryID = Categories.CategoryID
GROUP BY CategoryName;
""""""

# Execute queries
distinct_products_df = execute_sql_query(distinct_products_query)
product_categories_df = execute_sql_query(product_categories_query)

# Display number of distinct products
show_to_user(distinct_products_df)

# Plot for diversity of product categories
fig = px.bar(product_categories_df, x='CategoryName', y='count_product',
             title='Diversity of Product Categories',
             labels={'count_product': 'Number of Products', 'CategoryName': 'Category Name'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get distinct product categories and their counts
sql_query = """"""
SELECT p.CategoryID, COUNT(DISTINCT p.ProductID) AS DistinctProductCount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.CategoryID
""""""

# Execute the SQL query and get the result as a DataFrame
category_data = execute_sql_query(sql_query)

# Visualization of the data
fig = px.bar(category_data, x='CategoryID', y='DistinctProductCount', 
             title='Distinct Products Sold by Category', 
             labels={'CategoryID': 'Category ID', 'DistinctProductCount': 'Distinct Product Count'})

show_to_user(fig)
```","The provided code does not adhere to the business analytics request as outlined in the reference implementation. The task was to determine the number of distinct products sold and visualize the diversity of product categories. The reference code executes two queries: one to count distinct products and another to count products per category. The provided code only focuses on distinct products within categories and counts products sold, not the overall distinct product count. Moreover, it visualizes distinct products sold by CategoryID, which does not align with showing category diversity as the reference implementation does with CategoryName.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL query execution logic
    pass

# Utility function to display data or visualizations
def show_to_user(data):
    # Placeholder for actual display logic
    pass

# SQL query to find the count of distinct products sold
sql_query_count = ""SELECT COUNT(DISTINCT [Order Details].ProductID) AS DistinctProducts FROM [Order Details];""
distinct_products_df = execute_sql_query(sql_query_count)

# SQL query to get product categories
sql_query_categories = """"""
    SELECT Categories.CategoryName, COUNT(DISTINCT [Order Details].ProductID) AS DistinctProductCount 
    FROM [Order Details] 
    JOIN Products ON [Order Details].ProductID = Products.ProductID
    JOIN Categories ON Products.CategoryID = Categories.CategoryID
    GROUP BY Categories.CategoryName
""""""

# Execute the query to get product categories and counts
product_categories_df = execute_sql_query(sql_query_categories)

# Create a bar chart to visualize the diversity of product categories
fig = px.bar(product_categories_df, x='CategoryName', y='DistinctProductCount',
             title=""Diversity of Product Categories"",
             labels={'CategoryName': 'Product Category', 'DistinctProductCount': 'Number of Distinct Products'})

# Display the results
show_to_user(distinct_products_df)
show_to_user(fig)
```","The input code deviates from the reference implementation in the method of computing distinct products per category. It includes the '[Order Details]' table in the query to aggregate distinct products within categories, which differs from the original business request. The reference code uses the 'Products' table directly for category aggregation. Thus, the logic differs, potentially leading to different results.",None
"What is the average time taken to fulfill orders per month, and can you provide a line graph to illustrate the monthly trends?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM orders 
GROUP BY month
""""""

# Execute the SQL query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(orders_df, x='month', y='avg_fulfillment_time', 
              title='Average Fulfillment Time per Month',
              labels={'avg_fulfillment_time': 'Average Fulfillment Time (days)', 'month': 'Month'})

# Display the visualization
show_to_user(fig)
```","```python
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS order_month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS average_fulfillment_time
FROM 
    orders
GROUP BY 
    order_month
ORDER BY 
    order_month;
""""""

average_fulfillment_df = execute_sql_query(sql_query)

import plotly.express as px

fig = px.line(average_fulfillment_df, x='order_month', y='average_fulfillment_time', title='Average Order Fulfillment Time per Month')
show_to_user(fig)
```","The input code fulfills the business analytics request by calculating the average fulfillment time per month and creating a line graph. It uses SQL to group by month, calculates the average time taken to fulfill orders using DATEDIFF, and utilizes Plotly to create a line chart. Both the logic and outcome match the reference code, conforming to the business requirement.","```python
import pandas as pd
import plotly.express as px

# Utility function that executes a SQL query and returns a pandas DataFrame
def execute_sql_query(sql_query: str):
    # This is a placeholder implementation
    # In practice, this would connect to a database and execute the query
    data = {
        ""Month"": [""2023-01"", ""2023-02"", ""2023-03""],
        ""AvgFulfillTime"": [2.5, 3.0, 2.8]
    }
    return pd.DataFrame(data)

# Utility function to display data or visualization to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get average fulfillment time per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillTime 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a line graph to visualize the average fulfillment time per month
fig = px.line(df, x='Month', y='AvgFulfillTime', title='Average Fulfillment Time per Month', labels={'AvgFulfillTime': 'Average Fulfillment Time (Days)'})

# Show the line graph to the user
show_to_user(fig)
```","The input Python code correctly answers the business analytics request by calculating the average fulfillment time per month and plotting a line graph to illustrate the trends. It follows the same logic as the reference implementation: the SQL query computes the average difference in days between the order date and the shipped date, grouped by month, and the resulting data is visualized using a line graph with Plotly. The naming conventions in the query and labels are slightly different, but these do not affect the correctness or the output.",both
"What is the total order quantity for each product, and how can it be visualized with a bar chart?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query to get the results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalQuantity', 
             title='Total Order Quantity for Each Product',
             labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Order Quantity'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrderQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

order_quantity_df = execute_sql_query(sql_query)

fig = px.bar(order_quantity_df, x='ProductName', y='TotalOrderQuantity',
             title='Total Order Quantity for Each Product',
             labels={'TotalOrderQuantity': 'Total Order Quantity', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code groups by `ProductName` instead of `ProductID`, which is different from the reference code that groups by `ProductID`. This change could lead to incorrect aggregation if products have the same name but different IDs.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query and fetch the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Total Order Quantity per Product', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly executes the SQL query by joining the products and Order Details tables, grouping by ProductID, and summing the quantities as required. It also uses Plotly to create and display a bar chart with appropriate labels. The logic matches the reference implementation, albeit with slight differences in the order of JOIN tables and chart labels, which do not affect the correctness.",Finetuned
"What is the total sales for each product, and can you provide a bar chart to visualize the sales distribution?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT [Order Details].ProductID, 
       SUM([Order Details].UnitPrice * 
           [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
GROUP BY [Order Details].ProductID;
""""""

# Execute the SQL query and get the result as a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart for sales distribution using Plotly
fig = px.bar(sales_data, 
             x='ProductID', 
             y='TotalSales', 
             title='Total Sales for Each Product',
             labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales'},
             text_auto=True)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT [Order Details].ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY [Order Details].ProductID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Total Sales for Each Product')
show_to_user(fig)
```","The input code correctly calculates the total sales for each product using a SQL query that sums up the product of unit price, quantity, and the discount factor. Both the reference and the input code use Plotly to create a bar chart to visualize the sales distribution, displaying 'ProductID' on the x-axis and 'TotalSales' on the y-axis. The input and reference implementations achieve the same analytical outcome and visualization, adhering to the same underlying logic, although there is an additional join clause in the input implementation which does not affect the calculation outcome as long as it maintains the relationships necessary for the 'Order Details' table.","```python
import pandas as pd
import plotly.express as px

# SQL query provided in the request
sql_query = """"""
SELECT ProductID, SUM(Quantity * UnitPrice) AS TotalSales 
FROM [Order Details] 
GROUP BY ProductID;
""""""

# Function to execute the SQL query and return the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating SQL query execution and returning sample data
    data = {
        'ProductID': [1, 2, 3],
        'TotalSales': [250.0, 150.0, 350.0]
    }
    return pd.DataFrame(data)

# Fetch data using the SQL query
df_sales = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales distribution
fig = px.bar(df_sales, x='ProductID', y='TotalSales', 
             title='Total Sales for Each Product', 
             labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales'})

# Display the bar chart
def show_to_user(data):
    if isinstance(data, (pd.DataFrame, pd.Series)):
        print(data)
    else:
        data.show()

show_to_user(fig)
```","The input code does not account for discounts in the TotalSales calculation. The reference implementation uses 'SUM(UnitPrice * Quantity * (1 - Discount))' whereas the input code uses 'SUM(UnitPrice * Quantity)', omitting the discount adjustment. This difference may lead to incorrect sales totals if discounts are present.",Base
Which product generates the highest revenue? Please include a bar chart to visualize the revenue generated by each product.,"```python
import pandas as pd
import plotly.express as px

# Assume these functions are defined elsewhere in the environment.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Executes an SQL query and returns a pandas DataFrame
    pass

def show_to_user(data):
    # Displays data analysis or visualization results
    pass

# SQL query to get total revenue by product
sql_query = '''
SELECT ProductID, SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalRevenue
FROM [Order Details]
GROUP BY ProductID
'''

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize revenue generated by each product
fig = px.bar(df, x='ProductID', y='TotalRevenue', title='Revenue by Product', labels={'TotalRevenue': 'Total Revenue', 'ProductID': 'Product ID'})

# Display the bar chart
show_to_user(fig)

# Find product with the highest revenue
highest_revenue_product = df.loc[df['TotalRevenue'].idxmax()]

# Display the product with the highest revenue
show_to_user(pd.DataFrame([highest_revenue_product]))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalRevenue DESC
LIMIT 1;
""""""

highest_revenue_product = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID;
""""""

all_revenue_data = execute_sql_query(sql_query_all)

fig = px.bar(all_revenue_data, x='ProductID', y='TotalRevenue', title='Revenue Generated by Each Product', labels={'TotalRevenue': 'Revenue', 'ProductID': 'Product ID'})
show_to_user(fig)
```","The input code only identifies the highest revenue product in the SQL query and does not display it separately. Also, it uses a different logic by handling the highest revenue product identification in the SQL query, which doesn't align with the reference implementation that performs this logic in Python using DataFrame operations. Furthermore, the input code does not display the highest revenue product using the `show_to_user` function, which is a requirement in the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query.
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY Revenue DESC;
""""""

# Execute the SQL query and return the results as a pandas DataFrame.
df_revenue = execute_sql_query(sql_query)

# Generate a bar chart to visualize revenue by product.
fig = px.bar(
    df_revenue,
    x='ProductID',
    y='Revenue',
    title='Revenue by Product',
    labels={'Revenue': 'Revenue ($)', 'ProductID': 'Product ID'}
)

# Display the bar chart to the user.
show_to_user(fig)
```","The input code generates a bar chart correctly and displays it. However, it only orders the products by revenue without identifying the product with the highest revenue separately, as the reference code does. The reference implementation also highlights the product with the highest revenue in a separate output step, which the input code lacks.",None
"What is the average fulfillment time for orders in 2023, and can we visualize this with a time series chart to show trends over the year?","```python
import pandas as pd
import plotly.express as px

# SQL query to get daily fulfillment times
sql_query = """"""
SELECT 
    DATE(orders.OrderDate) AS order_date,
    DATEDIFF(orders.ShippedDate, orders.OrderDate) AS fulfillment_time
FROM 
    orders 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Convert order_date to datetime format
orders_df['order_date'] = pd.to_datetime(orders_df['order_date'])

# Calculate the average fulfillment time per day
average_fulfillment_df = orders_df.groupby('order_date')['fulfillment_time'].mean().reset_index()

# Create a time series line chart
fig = px.line(
    average_fulfillment_df,
    x='order_date',
    y='fulfillment_time',
    title='Average Fulfillment Time for Orders in 2023',
    labels={'order_date': 'Date', 'fulfillment_time': 'Average Fulfillment Time (Days)'},
    line_shape='linear'
)

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Execute SQL query to get average fulfillment time by month in 2023
sql_query = """"""
SELECT MONTH(OrderDate) AS month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY MONTH(OrderDate)
ORDER BY month;
""""""
avg_fulfillment_df = execute_sql_query(sql_query)

# Step 2: Visualize the average fulfillment time as a time series chart
fig = px.line(avg_fulfillment_df, x='month', y='avg_fulfillment_time', 
              title='Average Fulfillment Time for Orders in 2023',
              labels={'month': 'Month', 'avg_fulfillment_time': 'Average Fulfillment Time (Days)'})
show_to_user(fig)
```","The input code calculates the average fulfillment time by month in 2023, whereas the reference implementation computes the daily average fulfillment time. The request asks for a time series to show trends over the year, implying a more granular daily analysis rather than a monthly summary. Therefore, the input code does not adhere to the same logic as the reference.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Utility function to execute SQL and return results as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # This should connect to the database, execute the provided SQL query, and return results as a DataFrame
    pass

# SQL query to retrieve average fulfillment time per month for the year 2023
sql_query_to_execute = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM 
    orders 
WHERE 
    YEAR(OrderDate) = 2023 
GROUP BY 
    OrderMonth;
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query_to_execute)

# Parse the OrderMonth as a datetime object
df_orders['OrderMonth'] = pd.to_datetime(df_orders['OrderMonth'])

# Sort the DataFrame by OrderMonth
df_orders.sort_values('OrderMonth', inplace=True)

# Create a time series chart using Plotly
fig = px.line(df_orders, x='OrderMonth', y='AvgFulfillmentTime', 
              title='Average Fulfillment Time per Month for 2023',
              labels={'OrderMonth': 'Month', 'AvgFulfillmentTime': 'Avg Days to Fulfill'})

# Function to show the results to the user
def show_to_user(data):
    # This is a placeholder for displaying data
    # In a real environment, it should show pandas DataFrame or Plotly figure
    pass

# Show the visualization to the user
show_to_user(fig)
```","The input code aggregates the average fulfillment time by month, not by day as the reference code does. This results in a different granularity and trend visualization. The task requires daily averages to match the reference logic.",None
Which category of products generated the most sales in 2023? Please include a bar chart to visualize the sales by product category.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY categories.CategoryName 
ORDER BY sales DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize sales by product category
fig = px.bar(df, x='CategoryName', y='sales', title='Sales by Product Category for 2023')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CategoryName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
JOIN products p ON od.ProductID = p.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY c.CategoryName
ORDER BY total_sales DESC
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='CategoryName', y='total_sales', title='Product Sales by Category in 2023')
show_to_user(fig)
```","The input Python code correctly answers the business request. It calculates total sales per product category in 2023 by summing up the product of UnitPrice, Quantity, and adjusted for Discount, matching the reference code's logic. The SQL query in the input code uses a date range to filter transactions from 2023, which is equivalent to using YEAR() in the reference query. Additionally, the bar chart in the input code visualizes the sales data by category, the same as the reference code. Therefore, the input code adheres to the specified business analytics request and follows the same logic as the reference implementation.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch sales data by category for the year 2023
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE [Order Details].OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName 
ORDER BY total_sales DESC
""""""

# Execute the SQL query
sales_data_df = execute_sql_query(sql_query)

# Visualization: Bar chart of total sales by product category for 2023
fig = px.bar(sales_data_df, x='CategoryName', y='total_sales', 
             title='Total Sales by Product Category in 2023',
             labels={'CategoryName': 'Product Category', 'total_sales': 'Total Sales'},
             text_auto=True)

# Show the visualization to the user
show_to_user(fig)
```","The input code differs from the reference implementation in one key aspect: the SQL query in the input code uses the condition WHERE [Order Details].OrderDate BETWEEN '2023-01-01' AND '2023-12-31' instead of YEAR(orders.OrderDate) = 2023. This can lead to different results if the 'OrderDate' data type does not support direct comparison as intended. Additionally, the input code does not join the 'orders' table directly with [Order Details] for the 'OrderDate' condition, which can lead to incorrect filtering of the relevant 2023 orders.",Base
"What is the trend of total sales revenue over the past year, and can you provide a line chart to illustrate this trend?","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m') 
ORDER BY 
    DATE_FORMAT(OrderDate, '%Y-%m') ASC;
""""""

# Execute SQL query and store the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(sales_data, x='Month', y='TotalSales', 
              title='Trend of Total Sales Revenue Over the Past Year', 
              labels={'TotalSales': 'Total Sales Revenue', 'Month': 'Month'})

# Display the line chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= NOW() - INTERVAL '1 year'
GROUP BY 
    month
ORDER BY 
    month;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='month', y='total_sales', title='Total Sales Revenue Over the Past Year')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request with similar logic to the reference code. It queries total sales revenue by month for the past year, aggregates the sales data, and produces a line chart using Plotly. Both implementations use SQL to perform equivalent operations: formatting dates, summing sales, filtering by date, grouping by month, and ordering. Though the SQL syntax and library calls are slightly different, the logic and output remain the same.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales revenue per month over the past year
sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS order_month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate >= DATEADD('year', -1, CURRENT_DATE) 
GROUP BY 
    order_month 
ORDER BY 
    order_month DESC;
""""""

# Use the utility function to execute the SQL query and get a DataFrame
sales_data = execute_sql_query(sql_query)

# Ensure the data is sorted by order_month for proper trend analysis
sales_data = sales_data.sort_values('order_month')

# Create a line chart using Plotly to illustrate the trend of total sales revenue
fig = px.line(
    sales_data,
    x='order_month',
    y='total_sales',
    title='Trend of Total Sales Revenue Over the Past Year',
    labels={'order_month': 'Month', 'total_sales': 'Total Sales Revenue'},
    markers=True
)

# Display the line chart
show_to_user(fig)
```","The provided Python code accurately retrieves and processes data to show the trend of total sales revenue over the past year. It aligns with the logic of the reference implementation. The SQL queries differ in syntax due to SQL dialect differences, using DATE_TRUNC vs. DATE_FORMAT, and DATEADD vs. DATE_SUB, respectively. Both correctly calculate monthly total sales. In addition, both codes sort the data by month and create a Plotly line chart, fulfilling the business request.",both
Identify the products with the largest discrepancies between units on order and units in stock and visualize the differences using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT ProductID, ProductName, UnitsOnOrder - UnitsInStock AS Discrepancy 
FROM products 
ORDER BY Discrepancy DESC;
""""""

# Execute the SQL query
products_data = execute_sql_query(sql_query)

# Create a bar chart to visualize discrepancies
fig = px.bar(products_data, x='ProductName', y='Discrepancy',
             title='Discrepancy between Units on Order and Units in Stock',
             labels={'Discrepancy': 'Discrepancy Amount'},
             text='Discrepancy')

# Show the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    p.UnitsInStock, 
    p.UnitsOnOrder, 
    ABS(p.UnitsOnOrder - p.UnitsInStock) AS Discrepancy
FROM 
    products p
WHERE 
    p.Discontinued = 0
ORDER BY 
    Discrepancy DESC
LIMIT 10
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='Discrepancy', 
             title='Top 10 Products by Discrepancy between Units on Order and In Stock', 
             labels={'Discrepancy': 'Discrepancy', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input Python code calculates discrepancies using the absolute difference between units on order and units in stock, while the reference implementation uses a direct subtraction (units on order minus units in stock). Additionally, the input limits the results to discontinued products and selects only the top 10 discrepancies, whereas the reference code does not include these conditions.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, (UnitsOnOrder - UnitsInStock) AS Discrepancy 
FROM products ORDERS; 
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Select products with the largest discrepancies
# Assuming we are interested in the top discrepancies, let's sort and select them
top_discrepancies = data.sort_values(by=""Discrepancy"", ascending=False)

# Visualize the discrepancies using a bar chart
fig = px.bar(
    top_discrepancies,
    x=""ProductID"",
    y=""Discrepancy"",
    title=""Top Product Discrepancies Between Units On Order and Units In Stock"",
    labels={""ProductID"": ""Product ID"", ""Discrepancy"": ""Discrepancy""}
)

# Display the bar chart
show_to_user(fig)
```","The input code and the reference code differ significantly in some areas. The input code's SQL query selects from 'products ORDERS', which seems incorrect syntax and might cause an error. It also doesn't include 'ProductName', which is required to fulfill the visualization part of the request. The reference query correctly includes 'ProductName' to ensure proper labeling in the bar chart. Additionally, while both codes aim to sort by 'Discrepancy', the input code does not restrict the number of results shown, which the user might expect if only top discrepancies are desired.",None
"Which suppliers have the lowest average lead time for delivery, and can you provide a bar chart to visualize the comparison?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT 
    suppliers.CompanyName, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY 
    suppliers.CompanyName 
ORDER BY 
    avg_lead_time ASC
'''

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='avg_lead_time', 
             title='Suppliers with Lowest Average Lead Time',
             labels={'avg_lead_time': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time
FROM orders
JOIN products ON orders.OrderID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY average_lead_time ASC
""""""

lead_time_df = execute_sql_query(sql_query)

fig = px.bar(lead_time_df, x='CompanyName', y='average_lead_time', title='Suppliers Average Lead Time for Delivery', labels={'average_lead_time': 'Average Lead Time (Days)'})
show_to_user(fig)
```","The input Python code contains a mistake in the JOIN conditions. Specifically, it joins the 'orders' table with 'products' using the 'OrderID' and 'ProductID' respectively, which is incorrect based on the reference code. The reference implementation correctly joins 'orders' with 'Order Details' using 'OrderID', and 'Order Details' with 'products' using 'ProductID'. This mistake can lead to incorrect results when calculating the average lead times.","```python
import pandas as pd
import plotly.express as px

# Define SQL query for extracting suppliers with the lowest average lead time
sql_query = """"""
SELECT s.CompanyName, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON o.OrderID = od.OrderID 
GROUP BY s.CompanyName 
ORDER BY AvgLeadTime ASC;
""""""

# Execute the SQL query and get a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the comparison of average lead times
fig = px.bar(df, 
             x='CompanyName', 
             y='AvgLeadTime', 
             title='Suppliers with Lowest Average Lead Time for Delivery',
             labels={'CompanyName': 'Supplier', 'AvgLeadTime': 'Average Lead Time (days)'})

# Display the bar chart using the provided utility function
show_to_user(fig)
```","The input Python code accurately performs the same task as the reference implementation. Both codes execute a SQL query to calculate the average lead time suppliers take to deliver orders by joining relevant tables: suppliers, products, orders, and order details. The results are then used to create a bar chart using Plotly. The logic, order of operations, and visualization task match the reference implementation.",Finetuned
"What is the growth rate in customer orders year over year, and can this be visualized using a line chart?","```python
import pandas as pd
import plotly.express as px

# Mock function definitions based on environment constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This mock function should connect to the database and return a DataFrame.
    # For demonstration, let's assume it returns the following DataFrame:
    data = {
        'Year': [2020, 2021, 2022],
        'OrderCount': [100, 150, 180],
        'OrderGrowth': [None, 50, 30]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This function should display the data or figure to the user.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query as provided in the request
sql_query = """"""
SELECT EXTRACT(YEAR FROM o.OrderDate) AS Year, 
       COUNT(o.OrderID) AS OrderCount, 
       COUNT(o.OrderID) - LAG(COUNT(o.OrderID)) OVER (ORDER BY EXTRACT(YEAR FROM o.OrderDate)) AS OrderGrowth 
FROM orders o 
GROUP BY EXTRACT(YEAR FROM o.OrderDate);
""""""

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Correcting OrderGrowthRate calculation
results_df['OrderGrowthRate'] = (results_df['OrderGrowth'] / results_df['OrderCount'].shift(1)) * 100

# Visualize the data using Plotly
fig = px.line(results_df, x='Year', y='OrderGrowthRate', 
              title='Year-over-Year Growth Rate in Customer Orders',
              labels={'OrderGrowthRate': 'Growth Rate (%)'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM OrderDate) AS Year,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
GROUP BY 
    Year
ORDER BY 
    Year;
""""""

order_counts = execute_sql_query(sql_query)
order_counts['GrowthRate'] = order_counts['OrderCount'].pct_change() * 100

fig = px.line(order_counts, x='Year', y='GrowthRate', title='Year Over Year Growth Rate in Customer Orders')
show_to_user(fig)
```","The input code correctly computes the year-over-year growth rate in customer orders. It uses SQL to extract order counts by year, then calculates the percentage change to get the growth rate, aligning with the logic of the reference implementation. Both codes achieve the same result of determining order growth rates year by year, though they differ in calculation method. The visualization part using Plotly for a line chart is also correctly implemented in the input code.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration purposes
    return pd.DataFrame({
        'Year': [2022, 2023],
        'GrowthRate': [10.5, 8.3]
    })

# Function to show results
def show_to_user(data):
    print(data)

# SQL query
sql_query = """"""
SELECT YEAR(OrderDate) AS Year, 
    (COUNT(OrderID) - 
     LAG(COUNT(OrderID), 1) OVER (ORDER BY YEAR(OrderDate))) * 100.0 / LAG(COUNT(OrderID), 1) OVER (ORDER BY YEAR(OrderDate)) AS GrowthRate 
FROM orders 
GROUP BY YEAR(OrderDate);
""""""

# Execute the SQL query to get the data
df_growth_rate = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(df_growth_rate, x='Year', y='GrowthRate', 
              title='Year Over Year Growth Rate in Customer Orders',
              labels={'GrowthRate': 'Growth Rate (%)'})

# Display the line chart
show_to_user(fig)
```","The input code correctly calculates the year-over-year growth rate in customer orders and visualizes it using a line chart. The logic for the growth rate calculation is consistent with the reference code, using SQL to calculate the growth rate and Plotly to visualize it. Although the mock data used in the input code is different and simplified, the core logic remains aligned with the reference implementation.",both
"What is the total sales generated by employees hired in the last five years? Additionally, provide a bar chart showing yearly sales contributions by these employees.","
```python
import pandas as pd
import plotly.express as px

# Assumed utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function; should be replaced by actual implementation
    pass

def show_to_user(data):
    # Dummy function; should be replaced by actual implementation
    pass

# SQL query provided in the request
sql_query = """"""
SELECT YEAR(orders.OrderDate) AS Year, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * 
        (1 - [Order Details].Discount)) AS TotalSales
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE employees.HireDate >= DATE_SUB(CURRENT_DATE, INTERVAL 5 YEAR) 
GROUP BY YEAR(orders.OrderDate);
""""""

# Execute the SQL query
df_sales_with_year = execute_sql_query(sql_query)

# Calculate the total sales generated by employees hired in the last five years
total_sales = df_sales_with_year['TotalSales'].sum()

# Display the total sales
show_to_user(pd.DataFrame({""Total Sales"": [total_sales]}))

# Create a bar chart showing yearly sales contributions
fig = px.bar(df_sales_with_year, x='Year', y='TotalSales', 
             title='Yearly Sales Contributions by Employees (Last 5 Years)')
show_to_user(fig)
```","```python
from datetime import datetime, timedelta
import pandas as pd
import plotly.express as px

# Calculate the date five years ago
five_years_ago = datetime.now() - timedelta(days=5*365)

# SQL query to get total sales and yearly contributions from employees hired in the last five years
sql_query = f""""""
SELECT 
    YEAR(o.OrderDate) AS Year, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    e.HireDate >= '{five_years_ago.strftime('%Y-%m-%d')}'
GROUP BY 
    YEAR(o.OrderDate)
ORDER BY 
    Year
""""""

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Calculate total sales
total_sales = sales_data['TotalSales'].sum()

# Create a bar chart for yearly sales contributions
fig = px.bar(sales_data, x='Year', y='TotalSales', title='Yearly Sales Contributions by Employees Hired in the Last Five Years')

# Show the results
show_to_user(total_sales)
show_to_user(fig)
```","The input Python code correctly implements the business analytics request using the same logic as the reference implementation. Both codes execute a SQL query to retrieve sales data for the last five years, using the employee hire date condition. They compute the total sales and display yearly sales contributions in a bar chart. The calculated total sales and visualization logic match the reference, confirming correctness.","```python
import pandas as pd
import plotly.express as px

# SQL query to get yearly sales contribution from employees hired in the last five years
sql_query = """"""
SELECT 
    YEAR(orders.OrderDate) AS Year,
    SUM(order_details.UnitPrice * order_details.Quantity) AS TotalSales
FROM orders
JOIN employees ON orders.EmployeeID = employees.EmployeeID
JOIN order_details ON orders.OrderID = order_details.OrderID
WHERE YEAR(employees.HireDate) >= YEAR(CURDATE()) - 5
GROUP BY YEAR(orders.OrderDate)
ORDER BY Year;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This code simulates executing the SQL query and returning a DataFrame
    # Replace this block with the actual implementation
    pass

# Function to show the data analysis or visualization
def show_to_user(data):
    # This code simulates showing results to the user
    # Replace this block with the actual implementation
    pass

# Execute the SQL query and store the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the yearly sales contributions
fig = px.bar(sales_data, x='Year', y='TotalSales', title='Yearly Sales Contributions by Recent Hires')

# Show the bar chart to the user
show_to_user(fig)
```","The input code calculates sales without considering the discount, leading to a different total sales calculation compared to the reference. Additionally, it does not compute and display the total sales amount explicitly, which is done in the reference code.",Base
"What is the total quantity ordered for products with discontinued status, and can you provide a bar chart to illustrate the quantities for each product?","```python
import plotly.express as px
import pandas as pd

# SQL Query to get total quantity and product-wise quantities for discontinued products
sql_query_total = """"""
SELECT SUM(Quantity) as TotalQuantity
FROM [Order Details]
INNER JOIN products ON [Order Details].ProductID = products.ProductID
WHERE products.Discontinued = 1;
""""""

sql_query_product_detail = """"""
SELECT products.ProductName, SUM(Quantity) as TotalQuantity
FROM [Order Details]
INNER JOIN products ON [Order Details].ProductID = products.ProductID
WHERE products.Discontinued = 1
GROUP BY products.ProductName;
""""""

# Execute the queries
total_quantity_df = execute_sql_query(sql_query_total)
product_quantities_df = execute_sql_query(sql_query_product_detail)

# Display total quantity ordered for discontinued products
show_to_user(total_quantity_df)

# Generate bar chart for quantities of each discontinued product
fig = px.bar(product_quantities_df, x='ProductName', y='TotalQuantity', 
             labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity'},
             title='Quantities of Discontinued Products')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE p.Discontinued = 1
GROUP BY p.ProductName
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ProductName', y='TotalQuantity', title='Total Quantity Ordered for Discontinued Products')
show_to_user(fig)
```","The input code does not provide the total quantity of all discontinued products combined, which is calculated separately in the reference implementation with an additional SQL query. The input code directly fetches the product-wise quantities and visualizes them, but it lacks computation and display of the overall total quantity.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total quantity ordered for discontinued products
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 1
GROUP BY p.ProductName;
""""""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Generating a bar chart to illustrate quantities for each discontinued product
fig = px.bar(discontinued_products_df, x='ProductName', y='TotalQuantity', 
             title='Total Quantity Ordered for Discontinued Products',
             labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity'})

# Show the bar chart using the utility function
show_to_user(fig)
```","The input code retrieves and visualizes quantities for each discontinued product but does not calculate or display the total quantity for all discontinued products, as requested. The reference implementation separately calculates total quantity, which is missing in the input code.",None
"What is the average order fulfillment time for the last 6 months, and can this be visualized with a trend line graph?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query for extracting average order fulfillment time
sql_query = """"""
SELECT 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS order_fulfillment_time, 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS order_month
FROM 
    orders 
WHERE 
    orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
GROUP BY 
    order_month
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Plotting
fig = px.line(
    data, 
    x=""order_month"", 
    y=""order_fulfillment_time"", 
    title=""Average Order Fulfillment Time Trend (Last 6 Months)"",
    labels={""order_fulfillment_time"": ""Avg Fulfillment Time (days)"", ""order_month"": ""Month""}
)

# Display the plot
show_to_user(fig)
```","```python
from datetime import datetime, timedelta
import pandas as pd
import plotly.express as px

# Calculate the date range for the last 6 months
end_date = datetime.now()
start_date = end_date - timedelta(days=6 * 30)  # Approximation of 6 months

# SQL query to get order fulfillment time for the last 6 months
sql_query = f""""""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time
FROM orders
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY month
ORDER BY month;
""""""

# Execute the SQL query and retrieve the data
fulfillment_data = execute_sql_query(sql_query)

# Create a line plot for average order fulfillment time
fig = px.line(fulfillment_data, x='month', y='avg_fulfillment_time',
              title='Average Order Fulfillment Time (Last 6 Months)',
              labels={'month': 'Month', 'avg_fulfillment_time': 'Average Fulfillment Time (Days)'})

# Show the visualization to the user
show_to_user(fig)
```","The provided code correctly fulfills the business requirement as it calculates the average order fulfillment time for the last 6 months and visualizes it with a trend line graph. Both the reference and provided implementations use SQL queries to extract the necessary data, group by month, and plot the average fulfillment time per month. In terms of logic, the approximation of 6 months using days instead of calendar months is an acceptable variation that does not impact the correctness relative to the business request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get average order fulfillment time for the last 6 months
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time 
FROM 
    orders 
WHERE 
    OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH) 
GROUP BY 
    month;
""""""

# Execute the SQL query and retrieve the data into a DataFrame
df = execute_sql_query(sql_query)

# Sort the DataFrame by month for accurate trend line
df['month'] = pd.to_datetime(df['month'], format='%Y-%m')
df.sort_values('month', inplace=True)

# Visualize the average order fulfillment time with a trend line using Plotly
fig = px.line(df, x='month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time Over Last 6 Months',
              labels={'avg_fulfillment_time': 'Avg Fulfillment Time (days)'},
              markers=True)

# Display the trend line graph
show_to_user(fig)
```","The input code achieves the same objective as the reference implementation. Both codes calculate the average order fulfillment time for the last 6 months using SQL queries and visualize it with a line graph. Though the column names differ slightly, the logic and functionality are equivalent. The input code also includes date sorting for the trend, which enhances the accuracy of the visualization.",both
List orders with a required date earlier than the order date and visualize the data using a timeline chart to highlight discrepancies.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT OrderID, RequiredDate, OrderDate FROM orders WHERE RequiredDate < OrderDate;""

# Execute the SQL query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Convert date columns to datetime if necessary
orders_df['RequiredDate'] = pd.to_datetime(orders_df['RequiredDate'])
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])

# Create a timeline visualization
fig = px.timeline(
    orders_df,
    x_start=""RequiredDate"",
    x_end=""OrderDate"",
    y=""OrderID"",
    title=""Order Date Discrepancies Timeline"",
    labels={""OrderID"": ""Order ID""},
    color_discrete_sequence=[""red""]
)

# Customize the layout for better clarity
fig.update_layout(
    yaxis={'categoryorder': 'total ascending'},
    xaxis_title=""Date"",
    yaxis_title=""Order ID"",
    template='plotly_white'
)

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, OrderDate, RequiredDate
FROM orders
WHERE RequiredDate < OrderDate
""""""
discrepancies_df = execute_sql_query(sql_query)

fig = px.scatter(discrepancies_df, x=""OrderDate"", y=""RequiredDate"", 
                 title=""Discrepancies in Order Dates"",
                 labels={""OrderDate"": ""Order Date"", ""RequiredDate"": ""Required Date""},
                 hover_name=""OrderID"")
show_to_user(fig)
```","The input code does not match the reference implementation in terms of visualization. The reference implementation uses a timeline chart to plot 'RequiredDate' and 'OrderDate' to highlight discrepancies, correctly using 'OrderID' as the y-axis to display each order. The input code instead uses a scatter plot which does not emphasize the timeline of discrepancies. Also, the axes in the input code are reversed compared to the reference task.","```python
import pandas as pd
import plotly.express as px

# SQL Query to find discrepancies in orders
sql_query = """"""
SELECT orders.OrderID, orders.OrderDate, orders.RequiredDate
FROM orders
WHERE orders.RequiredDate < orders.OrderDate;
""""""

# Execute the SQL query and obtain the results as a DataFrame
discrepancies_df = execute_sql_query(sql_query)

# Ensure the dates are in datetime format for accurate plotting
discrepancies_df['OrderDate'] = pd.to_datetime(discrepancies_df['OrderDate'])
discrepancies_df['RequiredDate'] = pd.to_datetime(discrepancies_df['RequiredDate'])

# Create a timeline chart to visualize the discrepancies
fig = px.timeline(discrepancies_df, 
                  x_start=""OrderDate"", 
                  x_end=""RequiredDate"", 
                  y=""OrderID"", 
                  title=""Timeline of Orders with Required Date Earlier than Order Date"",
                  labels={'OrderID': 'Order ID', 'OrderDate': 'Order Date', 'RequiredDate': 'Required Date'},
                  template=""plotly_dark"")

# Show the timeline chart to the user
show_to_user(fig)
```","The provided code creates a timeline chart, but it uses 'OrderDate' as the start and 'RequiredDate' as the end, which is the reverse of the reference implementation. The reference implementation uses 'RequiredDate' as the start and 'OrderDate' as the end to highlight the discrepancies where the required date is earlier than the order date.",None
"What is the total number of orders shipped by each shipping method per employee, and how can this be visualized in a chart for clearer analysis?","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT employees.EmployeeID, ShipVia, COUNT(orders.OrderID) AS ShippedOrders
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
GROUP BY employees.EmployeeID, ShipVia;
'''

# Execute SQL query and fetch data
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total number of orders shipped by each shipping method per employee
fig = px.bar(
    data,
    x='EmployeeID',
    y='ShippedOrders',
    color='ShipVia',
    title='Total Orders Shipped by Each Shipping Method per Employee',
    labels={'ShipVia': 'Shipping Method', 'ShippedOrders': 'Number of Orders', 'EmployeeID': 'Employee ID'},
    barmode='group'
)

# Display visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL Query to get total orders shipped by each shipping method per employee
sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    o.ShipVia,
    COUNT(o.OrderID) AS TotalOrders
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
WHERE 
    o.ShippedDate IS NOT NULL
GROUP BY 
    e.EmployeeID, o.ShipVia
ORDER BY 
    e.EmployeeID, o.ShipVia;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(data, x='EmployeeName', y='TotalOrders', color='ShipVia',
             title='Total Orders Shipped by Each Shipping Method per Employee',
             labels={'TotalOrders': 'Total Orders', 'ShipVia': 'Shipping Method'},
             barmode='group')

# Show the visualization to the user
show_to_user(fig)
```","The input code includes additional logic not present in the reference implementation. Specifically, it concatenates first and last names of employees and filters orders to only those with a non-null 'ShippedDate'. This deviates from the reference, which only requires counting orders by shipping method per employee without any additional filters or concatenations.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are predefined

# SQL query to fetch data
sql_query = """"""
SELECT e.EmployeeID, o.ShipVia, COUNT(o.OrderID) AS TotalOrders 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, o.ShipVia;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total number of orders shipped by each shipping method per employee
fig = px.bar(
    df, 
    x='EmployeeID', 
    y='TotalOrders', 
    color='ShipVia', 
    barmode='group',
    title='Total Orders Shipped by Each Shipping Method per Employee',
    labels={'TotalOrders': 'Total Orders', 'EmployeeID': 'Employee ID', 'ShipVia': 'Shipping Method'}
)

# Show the figure to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request and adheres to the same logic as the reference implementation. Both codes execute a SQL query to fetch the total number of orders shipped by each shipping method per employee, group the results by EmployeeID and ShipVia, and use Plotly Express to create a grouped bar chart for visualization. The differences in variable names such as 'ShippedOrders' vs. 'TotalOrders' and slight stylistic differences in SQL do not affect the correctness of the logic or the output.",Finetuned
Which products have received the highest total discount amounts? Include a bar chart to visualize the top discounted products.,"
```python
import plotly.express as px

# Define the SQL query to fetch the required data
sql_query = """"""
SELECT 
    products.ProductName, 
    SUM([Order Details].UnitPrice * [Order Details].Discount * [Order Details].Quantity) AS Total_Discount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY Total_Discount DESC
""""""

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# No need to sort the data again if already ordered by SQL
# Assuming we want more than one top product, so let's select top 10
# Adjust the 'LIMIT' clause in SQL for database engine compatibility

top_discounted_products = data.head(10)

# Create a bar chart using Plotly to visualize the top discounted products
fig = px.bar(
    top_discounted_products,
    x='ProductName',
    y='Total_Discount',
    title='Top Discounted Products',
    labels={'Total_Discount': 'Total Discount Amount'},
    text='Total_Discount'
)

# Show the bar chart to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Discount) AS TotalDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalDiscount DESC
LIMIT 10
""""""

discounted_products = execute_sql_query(sql_query)

fig = px.bar(discounted_products, x='ProductName', y='TotalDiscount', title='Top Discounted Products', labels={'TotalDiscount': 'Total Discount Amount'})
show_to_user(fig)
```","The input code calculates the total discount by summing only the 'Discount' value, whereas the reference code calculates the total discount by multiplying 'UnitPrice', 'Discount', and 'Quantity'. The logic for computing the discount amount differs, making the input code incorrect in terms of the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve product IDs and their total discount amounts
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY ProductID
ORDER BY TotalDiscount DESC
""""""

# Execute the SQL query and store the results in a pandas DataFrame
data = execute_sql_query(sql_query)

# Ensure data is sorted
data = data.sort_values(by='TotalDiscount', ascending=False)

# Create a bar chart to visualize the top discounted products
fig = px.bar(data, x='ProductID', y='TotalDiscount', title='Top Discounted Products')

# Display the bar chart to the user
show_to_user(fig)
```","The input code retrieves discounts by ProductID without joining the Product table to get ProductName, violating the business request's need to identify products by name. It visualizes ProductID instead of ProductName, breaking consistency with the reference logic that uses product names and displays only the top discounted products.",None
"What is the difference in total revenue between 2021 and 2022, and can this be illustrated with a bar chart comparing the two years?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    (SUM(CASE WHEN YEAR(OrderDate) = 2022 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END) -
    SUM(CASE WHEN YEAR(OrderDate) = 2021 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END)) AS RevenueDifference
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID;
""""""

# Execute the SQL query
revenue_difference_df = execute_sql_query(sql_query)

# Extract the revenue difference
revenue_difference = revenue_difference_df.iloc[0]['RevenueDifference']

# SQL query for revenue in 2021 and 2022 separately
yearly_revenue_query = """"""
SELECT 
    YEAR(OrderDate) as Year,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(OrderDate) IN (2021, 2022)
GROUP BY YEAR(OrderDate);
""""""

# Execute the query
yearly_revenue_df = execute_sql_query(yearly_revenue_query)

# Create a bar chart
fig = px.bar(yearly_revenue_df, x='Year', y='TotalRevenue', title='Total Revenue Comparison: 2021 vs 2022')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    YEAR(o.OrderDate) AS OrderYear,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(o.OrderDate) IN (2021, 2022)
GROUP BY 
    YEAR(o.OrderDate)
""""""

revenue_data = execute_sql_query(sql_query)

revenue_diff = revenue_data.set_index('OrderYear').diff().iloc[-1, 0]

fig = px.bar(revenue_data, x='OrderYear', y='TotalRevenue', title='Total Revenue Comparison between 2021 and 2022')
show_to_user(fig)

revenue_diff
```","The input Python code provides a correct solution to the business analytics request. It calculates the total revenue for each year (2021 and 2022) using an SQL query. Then, it computes the revenue difference between these two years by using the 'diff()' method, which effectively mimics the calculation from the reference implementation. Finally, it uses Plotly to create a bar chart comparing the total revenues for 2021 and 2022, similar to the reference code. The logic for calculating revenue and creating a visual comparison is consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are defined utility functions per the environment constraints.

# SQL query to fetch total revenue for 2021 and 2022
sql_query = """"""
SELECT YEAR(orders.OrderDate) AS year, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM orders 
INNER JOIN [Order Details] 
ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(orders.OrderDate) IN (2021, 2022) 
GROUP BY YEAR(orders.OrderDate);
""""""

# Execute the SQL query and get the result as a DataFrame
revenue_df = execute_sql_query(sql_query)

# Check the DataFrame content
print(revenue_df)

# Create a bar chart to compare the total revenue between 2021 and 2022
fig = px.bar(revenue_df, x='year', y='total_revenue', 
             title='Total Revenue Comparison Between 2021 and 2022',
             labels={'year': 'Year', 'total_revenue': 'Total Revenue'},
             text='total_revenue')

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly fulfills the business analytics request by calculating total revenue for 2021 and 2022 and displaying the results in a bar chart. It aggregates revenue data using SQL, aligns with the logic of the reference implementation, and accurately visualizes the data, even though it doesn't explicitly calculate the difference in revenue directly in the code. Instead, the difference can be inferred from the bar chart, which meets the request requirements.",both
"  
    ""Which customers have placed more than 10 orders? Include a bar chart to visualize the distribution of order counts among these customers.""  ","
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are predefined utility functions

# Execute SQL query to fetch customers with more than 10 orders
sql_query = """"""
SELECT CustomerID 
FROM orders 
GROUP BY CustomerID 
HAVING COUNT(OrderID) > 10;
""""""
customers_df = execute_sql_query(sql_query)

# Add a column to count the orders for visualization purposes
orders_count_query = """"""
SELECT CustomerID, COUNT(OrderID) as OrderCount
FROM orders 
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10
""""""
orders_count_df = execute_sql_query(orders_count_query)

# Visualize the distribution of order counts among these customers using a bar chart
fig = px.bar(orders_count_df, x='CustomerID', y='OrderCount', title='Order Distribution for Customers with More Than 10 Orders')

# Show the plot to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName
HAVING COUNT(o.OrderID) > 10
""""""

customers_with_many_orders = execute_sql_query(sql_query)

fig = px.bar(customers_with_many_orders, x='CompanyName', y='OrderCount', 
              title='Customers with More Than 10 Orders',
              labels={'CompanyName': 'Customer Company Name', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The input Python code correctly identifies customers who have placed more than 10 orders by joining the 'customers' and 'orders' tables, grouping by 'CustomerID' and 'CompanyName', and applying a HAVING clause to filter results. It then uses Plotly Express to create a bar chart, displaying 'CompanyName' on the x-axis and 'OrderCount' on the y-axis. Although it includes 'CompanyName' in the query (unlike the reference code), it still fulfills the business requirement and provides additional information without deviating from the intended logic.","```python
import pandas as pd
import plotly.express as px

# Utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the logic to execute the SQL query and return the result as a pandas DataFrame
    pass

def show_to_user(data):
    # This function should display the data analysis or visualization
    pass

# SQL query to get customers with more than 10 orders
sql_query = """"""
SELECT c.CustomerID 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID 
HAVING COUNT(o.OrderID) > 10;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Check if df is not empty to avoid plotting issues
if not df.empty:
    # Count the number of orders per customer for those with more than 10 orders
    order_counts = df['CustomerID'].value_counts().reset_index()
    order_counts.columns = ['CustomerID', 'OrderCount']

    # Create a bar chart using Plotly
    fig = px.bar(order_counts, x='CustomerID', y='OrderCount',
                 title='Distribution of Order Counts for Customers with More Than 10 Orders',
                 labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

    # Display the bar chart
    show_to_user(fig)
else:
    show_to_user('No customers found with more than 10 orders.')
```","The reference implementation uses a direct SQL query to obtain both the filtered list of customers with more than 10 orders and their respective order counts. The input code first fetches customers with more than 10 orders but then incorrectly uses a `value_counts()` to count orders, which is redundant and incorrect for this task. The input code should replicate the logic of getting the order counts directly from the SQL query like the reference code.",Base
Identify employees who report to a specific manager and represent the data in an organizational chart.,"```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function to simulate database access
    # Replace this with actual database connection and execution logic
    data = {
        'EmployeeID': [1, 2, 3],
        'FirstName': ['John', 'Jane', 'Doe'],
        'LastName': ['Smith', 'Doe', 'Roe']
    }
    return pd.DataFrame(data)

# Utility function to display data or visualization results
def show_to_user(data):
    # Dummy function to simulate showing data
    # Replace this with actual display logic, e.g., using Plotly or printing DataFrame
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Main execution block
def main(manager_id):
    # Formulate SQL query
    sql_query = f""SELECT employees.EmployeeID, employees.FirstName, employees.LastName FROM employees WHERE employees.ReportsTo = {manager_id};""
    
    # Execute SQL query and get the results
    employees_df = execute_sql_query(sql_query)
    
    # Check if there are employees to display
    if employees_df.empty:
        print(""No employees report to this manager."")
        return

    # Create an organizational chart
    fig = px.treemap(
        employees_df,
        path=[px.Constant(""Manager""), 'FirstName', 'LastName'],
        values='EmployeeID',
        title=f""Organizational Chart for Manager ID: {manager_id}""
    )
    
    # Display the organizational chart
    show_to_user(fig)

# Example usage
main(manager_id=5)
```","```python
import pandas as pd
import plotly.graph_objects as go

def create_org_chart(manager_id):
    sql_query = f""""""
    SELECT EmployeeID, FirstName, LastName, ReportsTo
    FROM employees
    WHERE ReportsTo = {manager_id}
    """"""
    employees_df = execute_sql_query(sql_query)
    
    org_data = []
    for _, row in employees_df.iterrows():
        org_data.append({
            'id': row['EmployeeID'],
            'label': f""{row['FirstName']} {row['LastName']}"",
            'parent': row['ReportsTo']
        })
    
    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=[0, 1, 2, 3],  # Dummy data for layout
        y=[0, 1, 2, 3],
        mode='markers+text',
        text=[item['label'] for item in org_data],
        textposition='top center',
        marker=dict(size=20)
    ))

    for item in org_data:
        if item['parent']:
            fig.add_trace(go.Scatter(
                x=[0, 1],  # Dummy data for the line
                y=[0, 1],
                mode='lines',
                line=dict(color='black', width=2),
                showlegend=False
            ))

    show_to_user(fig)

manager_id = 1  # Replace with the specific manager's EmployeeID
create_org_chart(manager_id)
```","While the provided code aims to create an organizational chart and identifies employees reporting to a specific manager, it deviates significantly from the reference implementation. The reference code uses Plotly Express `treemap` for visualization creating a hierarchical structure, whereas the provided code uses Plotly Graph Objects and Scatter plots which does not inherently represent hierarchical data. Additionally, the `Main Execution Block` logic such as checking for an empty DataFrame and construction of the plot layout in the reference implementation is not adhered to. Finally, the line connecting logic does not adjust dynamically to data provided, using placeholder coordinates.","```python
import json
import pandas as pd
import networkx as nx
import plotly.graph_objects as go

# Utility function placeholders
def execute_sql(sql_query: str) -> pd.DataFrame:
    # This function should connect to the database and execute the given SQL query
    # Example connection code would go here
    # Return Mock Data for demo purposes
    return pd.DataFrame({""EmployeeID"": [1, 2], ""FirstName"": [""John"", ""Jane""], ""LastName"": [""Doe"", ""Smith""]})

def show_to_user(data):
    # This function would handle displaying the data or visualization to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, go.Figure):
        data.show()

# Main code based on business request
manager_id = 1  # Example manager ID, could be passed dynamically

# SQL query to get employees reporting to the manager
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName 
FROM employees e 
WHERE e.ReportsTo = {manager_id};
""""""

# Execute SQL query and get results into a DataFrame
employees_df = execute_sql(sql_query)

# Create an organizational chart using NetworkX
G = nx.DiGraph()
G.add_node(f'Manager: {manager_id}')
for _, row in employees_df.iterrows():
    G.add_node(row['EmployeeID'], label=f""{row['FirstName']} {row['LastName']}"")
    G.add_edge(f'Manager: {manager_id}', row['EmployeeID'])

# Render the organizational chart as a Plotly figure
pos = nx.spring_layout(G)
edge_x = []
edge_y = []
for edge in G.edges():
    x0, y0 = pos[edge[0]]
    x1, y1 = pos[edge[1]]
    edge_x.append(x0)
    edge_x.append(x1)
    edge_x.append(None)
    edge_y.append(y0)
    edge_y.append(y1)
    edge_y.append(None)

node_x = []
node_y = []
for node in pos.keys():
    x, y = pos[node]
    node_x.append(x)
    node_y.append(y)

# Create the plotly figure
fig = go.Figure()

# Add edges
fig.add_trace(go.Scatter(
    x=edge_x, y=edge_y, line=dict(width=0.5, color='grey'),
    hoverinfo='none', mode='lines'))

# Add nodes
fig.add_trace(go.Scatter(
    x=node_x, y=node_y, text=[f""{k}: {v['label']}"" for k, v in G.nodes(data=True)],
    mode='markers+text', marker=dict(
        showscale=False, colorscale='YlGnBu', reversescale=True,
        size=10, color='lightblue', line_width=2
    ),
    textposition=""bottom center""))

# Show the figure to the user
show_to_user(fig)
```","The provided code correctly identifies employees who report to a specific manager and represents them in an organizational chart. Both implementations execute a SQL query to fetch reporting employees and then visualize the results. The reference code uses Plotly's treemap for visualization, while the input code uses NetworkX to create a graph structure and Plotly for rendering. Both methods adhere to the business requirement and logically fit the task description.",Finetuned
"Which products have the highest inventory turnover ratio, and can you visualize the results to compare each product's turnover ratio?","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to retrieve the data
sql_query = """"""
SELECT products.ProductID, 
       (SUM([Order Details].Quantity * [Order Details].UnitPrice) / 
       NULLIF(AVG(products.UnitsInStock), 0)) AS InventoryTurnoverRatio 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID 
ORDER BY InventoryTurnoverRatio DESC;
""""""

# Execute the SQL query and get the data as a DataFrame
df = execute_sql_query(sql_query)

# Visualize the results using Plotly
fig = px.bar(df, x='ProductID', y='InventoryTurnoverRatio',
             title='Inventory Turnover Ratio by Product',
             labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'ProductID': 'Product ID'},
             template='plotly_dark')

# Show the interactive bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity * od.UnitPrice) AS total_sales,
    AVG(p.UnitsInStock) AS average_inventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS turnover_ratio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    turnover_ratio DESC
""""""

turnover_df = execute_sql_query(sql_query)

fig = px.bar(turnover_df, 
             x='ProductName', 
             y='turnover_ratio', 
             title='Inventory Turnover Ratio by Product', 
             labels={'turnover_ratio': 'Turnover Ratio', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. Both scripts calculate the inventory turnover ratio as the sum of sales divided by the average inventory for each product. The main difference is that the input code includes the 'ProductName' in the query and visualization, which does not alter the logic. Both codes use Plotly to visualize the results, although the input code labels the x-axis with 'ProductName' instead of 'ProductID'. The calculations and overall data manipulation are consistent, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholder (to be provided in the actual environment)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulate execution and return a DataFrame
    pass

def show_to_user(data):
    # Simulate display to the user (to be real in an actual environment)
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch product inventory turnover
sql_query = '''
SELECT products.ProductName, 
       (SUM([Order Details].Quantity * [Order Details].UnitPrice) / NULLIF(AVG(products.UnitsInStock), 0)) AS inventory_turnover 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE YEAR([Order Details].OrderDate) = 2023 
GROUP BY products.ProductID, products.ProductName 
ORDER BY inventory_turnover DESC;
'''

# Execute the SQL query and fetch the data
data = execute_sql_query(sql_query)

# Visualize the inventory turnover ratio for each product
fig = px.bar(data, x='ProductName', y='inventory_turnover',
             title='Product Inventory Turnover Ratio for 2023',
             labels={'inventory_turnover': 'Inventory Turnover Ratio'},
             template='plotly')

# Show the visualization to the user
show_to_user(fig)
```","The input code filters the data to include only the year 2023 in the SQL statement, which is not done in the reference implementation. This leads to a potential mismatch in the data used for calculating the turnover ratio. Additionally, the input code uses 'ProductName' for visualization, while the reference uses 'ProductID'.",Base
"What is the average discount applied per unit across all orders, and can this be visualized in a bar chart showing discounts by product category?","```python
import pandas as pd
import plotly.express as px

# Assuming the execute_sql_query and show_to_user functions are defined in the environment
def calculate_and_visualize_discount():
    # Step 1: Calculate the average discount applied per unit across all orders
    avg_discount_query = ""SELECT AVG(od.Discount) AS AverageDiscount FROM [Order Details] od;""
    avg_discount_df = execute_sql_query(avg_discount_query)
    
    # Step 2: Fetch discounts by product category for visualization
    category_discount_query = """"""
    SELECT p.CategoryID, c.CategoryName, AVG(od.Discount) AS AverageDiscount
    FROM [Order Details] od
    JOIN [Products] p ON od.ProductID = p.ProductID
    JOIN [Categories] c ON p.CategoryID = c.CategoryID
    GROUP BY p.CategoryID, c.CategoryName;
    """"""
    category_discount_df = execute_sql_query(category_discount_query)

    # Step 3: Visualize the average discount by product category using a bar chart
    fig = px.bar(category_discount_df, x='CategoryName', y='AverageDiscount',
                 title='Average Discount by Product Category',
                 labels={'AverageDiscount': 'Average Discount', 'CategoryName': 'Product Category'},
                 text='AverageDiscount')
    
    # Step 4: Display the visualization to the user
    show_to_user(fig)

# Execute the function to perform calculations and show the chart
calculate_and_visualize_discount()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(od.Discount / od.Quantity) AS AverageDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='CategoryID', y='AverageDiscount', 
             title='Average Discount per Unit by Product Category',
             labels={'CategoryID': 'Product Category', 'AverageDiscount': 'Average Discount per Unit'})
show_to_user(fig)
```","The input code calculates the average discount per unit, which differs from the reference code that calculates the average discount per order detail. The input code divides the discount by quantity, leading to a different calculation logic. Additionally, it doesn't include category names in the visualization, which the business request specifies.","```python
import pandas as pd
import plotly.express as px

def calculate_average_discount_per_unit():
    # SQL query to get the average discount per unit across all orders by product category
    sql_query = """"""
    SELECT Category, AVG(Discount) AS AvgDiscountPerUnit
    FROM OrderDetails
    JOIN Products ON OrderDetails.ProductID = Products.ProductID
    GROUP BY Category;
    """"""
    # Execute SQL query and get the results in a pandas DataFrame
    result_df = execute_sql_query(sql_query)

    # Visualize the average discount per unit by product category using a bar chart
    fig = px.bar(result_df, x='Category', y='AvgDiscountPerUnit',
                 title='Average Discount Per Unit by Product Category',
                 labels={'AvgDiscountPerUnit': 'Average Discount per Unit'},
                 text_auto=True)

    # Display the figure using the utility function
    show_to_user(fig)

# Execute the function
calculate_average_discount_per_unit()
```","The input code calculates the average discount per product category but does not compute the overall average discount per unit across all orders as requested. Additionally, there are discrepancies in the SQL query, such as using 'Category' instead of 'CategoryName', and the GROUP BY clause should include CategoryID and the related joins as in the reference code.",None
How many products have more units on order than in stock? Please provide a bar chart comparing the number of units on order and in stock for these products.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ProductID, ProductName, UnitsOnOrder, UnitsInStock
FROM products
WHERE UnitsOnOrder > UnitsInStock;
'''

# Execute the SQL query to get the relevant data
product_data = execute_sql_query(sql_query)

# Create the bar chart using Plotly
fig = px.bar(product_data, x='ProductName', y=['UnitsOnOrder', 'UnitsInStock'], 
             title='Comparison of Units on Order and Units in Stock',
             labels={'value': 'Units', 'variable': 'Category'},
             barmode='group')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.graph_objects as go

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, UnitsOnOrder
FROM products
WHERE UnitsOnOrder > UnitsInStock
""""""
products_on_order = execute_sql_query(sql_query)

count_products = products_on_order.shape[0]

fig = go.Figure()
fig.add_trace(go.Bar(x=products_on_order['ProductName'], y=products_on_order['UnitsInStock'], name='Units In Stock'))
fig.add_trace(go.Bar(x=products_on_order['ProductName'], y=products_on_order['UnitsOnOrder'], name='Units On Order'))

fig.update_layout(title='Comparison of Units On Order and In Stock',
                  xaxis_title='Product Name',
                  yaxis_title='Number of Units',
                  barmode='group')

show_to_user(fig)
```","The input code correctly implements the business analytics request. Both the reference and input codes execute a SQL query to select products where UnitsOnOrder is greater than UnitsInStock, fulfilling the requirement to find products with more units on order than in stock. The input code calculates the count of such products and uses Plotly (though with graph_objects instead of express) to create a grouped bar chart comparing UnitsOnOrder and UnitsInStock for these products. Despite using different Plotly modules, the logic and output align with the reference implementation.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mocking data fetched from SQL, to be replaced with actual SQL execution code
    return pd.DataFrame({
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'UnitsOnOrder': [150, 200, 250],
        'UnitsInStock': [100, 150, 240]
    })

def show_to_user(data):
    # Mock function to simulate displaying data
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to execute
sql_query = ""SELECT ProductName, UnitsOnOrder, UnitsInStock FROM products WHERE UnitsOnOrder > UnitsInStock;""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Filter products with more units on order than in stock
filtered_df = products_df[products_df['UnitsOnOrder'] > products_df['UnitsInStock']]

# Create a bar chart comparing units on order and in stock
fig = px.bar(
    filtered_df,
    x='ProductName',
    y=['UnitsOnOrder', 'UnitsInStock'],
    title='Units On Order vs In Stock for Selected Products',
    labels={'value': 'Units'},
    barmode='group'
)

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code fulfills the business analytics request by appropriately filtering products with more units on order than in stock, using the condition 'UnitsOnOrder > UnitsInStock'. It then creates a bar chart comparing these units for each product using Plotly, matching the logic of the reference implementation. While the names of the methods and minor details differ slightly (such as the more detailed dataframe filtering), these differences do not affect the correctness or the logic required by the task.",both
What is the average discount given per order item? Please include a bar chart to visualize the distribution of discounts per item category.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the average discount
sql_query_avg_discount = """"""
SELECT AVG([Order Details].Discount) AS avg_discount_given FROM [Order Details]
""""""

# Execute the SQL query to receive the average discount
avg_discount_df = execute_sql_query(sql_query_avg_discount)

# Display the average discount
show_to_user(avg_discount_df)

# SQL query to get discounts and item categories
sql_query_discounts_per_category = """"""
SELECT [Order Details].Discount, [Items].Category
FROM [Order Details]
JOIN [Items] ON [Order Details].ItemID = [Items].ItemID
""""""

# Execute the SQL query to receive discounts per item category
discounts_per_category_df = execute_sql_query(sql_query_discounts_per_category)

# Create a bar chart to visualize the distribution of discounts per item category
fig = px.bar(
    discounts_per_category_df,
    x='Category',
    y='Discount',
    title='Distribution of Discounts per Item Category',
    labels={'Discount': 'Discount Amount', 'Category': 'Item Category'},
    barmode='group'
)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the average discount per order item
sql_query = """"""
SELECT 
    products.CategoryID,
    AVG([Order Details].Discount) AS avg_discount
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.CategoryID
""""""
# Execute the query
discount_data = execute_sql_query(sql_query)

# Generate a bar chart to visualize the distribution of average discounts
fig = px.bar(discount_data, x='CategoryID', y='avg_discount', 
             title='Average Discount per Order Item by Category',
             labels={'CategoryID': 'Product Category', 'avg_discount': 'Average Discount'})

# Show the data to the user
show_to_user(fig)
```","The input code calculates the average discount per category instead of the overall average discount per order item. Additionally, it groups by CategoryID. The visualization plots average discount per category rather than the distribution of individual discounts. The logic in the input code does not align with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Utility function to simulate SQL execution
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function. The actual implementation would execute the query
    # and return the result as a DataFrame.
    pass

# Utility function to display data
def show_to_user(data):
    # This is a placeholder function. It would accept a DataFrame or a Plotly figure
    # and display it accordingly.
    pass

# SQL query to get the average discount per order item
sql_query = ""SELECT AVG(Discount) AS average_discount, ItemCategory FROM [Order Details] GROUP BY ItemCategory;""

# Execute the query and get the result as a DataFrame
order_details_df = execute_sql_query(sql_query)

# Check for NaN or missing values in the DataFrame
if order_details_df.isnull().values.any():
    order_details_df.fillna(value=0, inplace=True)

# Create a bar chart to visualize the distribution of average discounts per item category
fig = px.bar(order_details_df, x='ItemCategory', y='average_discount', 
             title='Average Discount per Order Item Category',
             labels={'average_discount': 'Average Discount', 'ItemCategory': 'Item Category'})

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code modifies the business requirement by calculating the average discount per item category, instead of the overall average discount. The SQL query groups by ItemCategory, which changes the logic compared to the reference implementation. Additionally, it uses a different DataFrame and chart logic, which does not match the required task.",None
"Which city has the highest average shipping cost per order, and can you provide a bar chart to visualize the average shipping costs per city?","```python
import pandas as pd
import plotly.express as px

# Assuming the execute_sql_query and show_to_user utility functions are defined elsewhere
# and imported into this script.

# SQL query to get average freight costs per city
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageFreight
FROM orders
GROUP BY ShipCity
ORDER BY AverageFreight DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualization of average freight costs per city using a bar chart
fig = px.bar(df, x='ShipCity', y='AverageFreight', title='Average Shipping Costs per City')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AverageShippingCost
FROM orders
GROUP BY ShipCity
ORDER BY AverageShippingCost DESC
""""""

average_shipping_costs = execute_sql_query(sql_query)

highest_city = average_shipping_costs.iloc[0]

fig = px.bar(average_shipping_costs, x='ShipCity', y='AverageShippingCost', 
             title='Average Shipping Cost per City', 
             labels={'AverageShippingCost':'Average Shipping Cost', 'ShipCity':'City'})
show_to_user(fig)

highest_city
```","The input Python code correctly follows the logic of the reference implementation. It executes a SQL query to calculate the average shipping cost per city, sorts the results to identify the city with the highest average, produces a bar chart visualization using Plotly Express, and displays it with a utility function. The variable naming and slightly different plot labeling do not deviate from the primary logic and goal expressed in the reference implementation.","import pandas as pd  
import plotly.express as px  

# SQL query to retrieve average freight costs per shipping city
sql_query = """"""
SELECT ShipCity, AVG(Freight) AS AvgFreightCost 
FROM orders 
GROUP BY ShipCity 
ORDER BY AvgFreightCost DESC;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Extract the city with the highest average freight cost
highest_avg_freight_city = df.iloc[0]

# Prepare a bar chart of average shipping costs per city
fig = px.bar(
    df, 
    x='ShipCity', 
    y='AvgFreightCost', 
    title='Average Shipping Cost per City',
    labels={'AvgFreightCost': 'Average Freight Cost', 'ShipCity': 'City'},
    template='plotly'
)

# Show the bar chart to the user
show_to_user(fig)","The input Python code correctly queries the average freight cost per city, orders them in descending order to extract the city with the highest average freight, and visualizes the results with a bar chart. This matches the logic of the reference implementation, even though additional details such as extracting the top city are included.",both
"What proportion of customers are from a specific demographic type, illustrated with a pie chart or bar graph?","
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user functions are pre-defined

# SQL query provided in the business analytic request
sql_query = """"""
SELECT customerDemographics.CustomerDesc, 
       COUNT(customers.CustomerID) AS customer_count, 
       COUNT(customers.CustomerID) * 1.0 / 
       (SELECT COUNT(*) FROM customers) AS proportion 
FROM customerCustomerDemo 
JOIN customers ON customerCustomerDemo.CustomerID = customers.CustomerID 
JOIN customerDemographics ON customerCustomerDemo.CustomerTypeID = customerDemographics.CustomerTypeID 
GROUP BY customerDemographics.CustomerDesc
""""""

# Execute the SQL query to retrieve the data into a DataFrame
df = execute_sql_query(sql_query)

# Create a pie chart to visualize the proportion of customers by demographic type
fig = px.pie(df, names='CustomerDesc', values='proportion', title='Proportion of Customers by Demographic Type')

# Display the visualization
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT cd.CustomerDesc, COUNT(ccd.CustomerID) AS customer_count
FROM customerDemographics cd
JOIN customerCustomerDemo ccd ON cd.CustomerTypeID = ccd.CustomerTypeID
GROUP BY cd.CustomerDesc
""""""

customer_data = execute_sql_query(sql_query)

total_customers = customer_data['customer_count'].sum()
customer_data['proportion'] = customer_data['customer_count'] / total_customers

fig = px.pie(customer_data, names='CustomerDesc', values='proportion', title='Proportion of Customers by Demographic Type')
show_to_user(fig)
```","The input Python code correctly calculates the proportion of customers by demographic type and visualizes it using a pie chart. Although the method to compute proportions differs from the reference implementation, the logic adheres to the same principle: dividing counts of each demographic by the total customer count to get proportions. The visualization outcome will be the same, as both codes end up computing the same proportions despite differences in query and calculation steps.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the proportion of customers by demographic
sql_query = """"""
SELECT 
    demography_type, 
    COUNT(c.CustomerID) * 100.0 / (SELECT COUNT(*) FROM customers) AS proportion 
FROM 
    customers c 
JOIN 
    demographics d ON c.DemographicID = d.DemographicID 
GROUP BY 
    demography_type;
""""""

# Execute the SQL query and get results in a pandas DataFrame
demographics_df = execute_sql_query(sql_query)

# Create a bar chart for the proportion of customers by demographic type
fig = px.bar(demographics_df, x='demography_type', y='proportion', 
             title='Proportion of Customers by Demographic Type',
             labels={'proportion': 'Proportion (%)', 'demography_type': 'Demographic Type'})

# Display the plot
show_to_user(fig)
```","The input code changes the logic from the reference code by multiplying the proportion by 100, resulting in a percentage rather than a proportion. Additionally, it uses bar charts instead of pie charts. The SQL query also differs in structure and table joins, indicating possible changes in table schema or field names ('demography_type' vs 'CustomerDesc'). These changes mean the implementation does not strictly adhere to the logic of the reference implementation.",Base
"  
    ""What is the correlation between employee sales and order fulfillment time, and can a scatter plot illustrate this relationship?""  ","```python
import pandas as pd
import plotly.express as px
from scipy.stats import pearsonr

# SQL query to get the necessary data
sql_query = '''
SELECT
    employees.EmployeeID,
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
GROUP BY employees.EmployeeID
ORDER BY employee_sales DESC;
'''

# Execute the SQL query and get a pandas DataFrame
df = execute_sql_query(sql_query)

# Check if dataframe is empty to prevent errors
if df.empty:
    show_to_user('No data returned from query')
else:
    # Calculate the correlation between employee sales and order fulfillment time
    correlation, p_value = pearsonr(df['employee_sales'], df['avg_fulfillment_time'])

    # Print the correlation result
    analysis_result = pd.DataFrame({
        'Correlation': [correlation],
        'P-Value': [p_value]
    })
    show_to_user(analysis_result)

    # Plotting the scatter plot using Plotly
    fig = px.scatter(
        df, 
        x='employee_sales', 
        y='avg_fulfillment_time', 
        title='Correlation between Employee Sales and Order Fulfillment Time',
        labels={'employee_sales': 'Employee Sales', 'avg_fulfillment_time': 'Average Fulfillment Time'},
        trendline='ols' # Adding a trendline for better visualization
    )

    # Display the plot
    show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

employee_sales_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
GROUP BY employees.EmployeeID
""""""

fulfillment_time_query = """"""
SELECT AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS order_fulfillment_time
FROM orders
""""""

employee_sales_df = execute_sql_query(employee_sales_query)
fulfillment_time_df = execute_sql_query(fulfillment_time_query)

fulfillment_time_value = fulfillment_time_df['order_fulfillment_time'].values[0]
employee_sales_df['order_fulfillment_time'] = fulfillment_time_value

fig = px.scatter(employee_sales_df, x='employee_sales', y='order_fulfillment_time', 
                 labels={'employee_sales': 'Employee Sales', 'order_fulfillment_time': 'Order Fulfillment Time'})
show_to_user(fig)
```","The input code is incorrect. It calculates a single average order fulfillment time for all employees, while the reference calculates an average per employee. Additionally, the correlation between employee sales and fulfillment time is not computed, which is part of the original request.","import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation, assume a real SQL query execution returns a DataFrame
    return pd.read_sql(sql_query, con='your_database_connection')

# Utility function to show results to the user
def show_to_user(data):
    # Display the DataFrame or Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get sales data per employee and average fulfillment time
sql_query = """"""
SELECT 
    employees.EmployeeID,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales,
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the correlation between total_sales and avg_fulfillment_time
correlation = df['total_sales'].corr(df['avg_fulfillment_time'])

# Displaying correlation value
correlation_df = pd.DataFrame({'Correlation': [correlation]})
show_to_user(correlation_df)

# Create a scatter plot to illustrate the relationship
fig = px.scatter(df, x='total_sales', y='avg_fulfillment_time', 
                 title='Scatter Plot of Employee Sales vs Order Fulfillment Time',
                 labels={'total_sales': 'Total Sales', 'avg_fulfillment_time': 'Average Fulfillment Time'})

# Show the scatter plot
show_to_user(fig)","The provided code does not calculate the p-value for the correlation and thus does not fully match the reference implementation. Additionally, it uses different column names ('total_sales' instead of 'employee_sales'), which while functionally similar, should remain consistent to fully adhere to the logic of the reference implementation. Furthermore, it directly uses 'corr()' instead of 'pearsonr()' which doesn't provide the p-value, a part of the reference logic.",None
Name suppliers who have never been involved in any orders and provide a bar chart showing the count of suppliers by region.,"```python
import plotly.express as px
import pandas as pd

# SQL query to find inactive suppliers
inactive_suppliers_query = """"""
SELECT suppliers.CompanyName, suppliers.Region 
FROM suppliers 
WHERE suppliers.SupplierID NOT IN (
    SELECT DISTINCT products.SupplierID 
    FROM products 
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
);
""""""

# Execute the SQL query and get inactive suppliers
i
active_suppliers_df = execute_sql_query(inactive_suppliers_query)

# Count the number of inactive suppliers by region
supplier_count_by_region = inactive_suppliers_df.groupby('Region').size().reset_index(name='Count')

# Create a bar chart using Plotly
fig = px.bar(supplier_count_by_region, x='Region', y='Count', title='Inactive Suppliers by Region')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to find suppliers who have never been involved in any orders
suppliers_query = """"""
SELECT s.SupplierID, s.CompanyName, s.Region 
FROM suppliers s 
LEFT JOIN products p ON s.SupplierID = p.SupplierID 
LEFT JOIN orders o ON p.ProductID = o.OrderID 
WHERE o.OrderID IS NULL;
""""""

# Execute the SQL query to get the suppliers
suppliers_df = execute_sql_query(suppliers_query)

# Query to get the count of suppliers by region
region_query = """"""
SELECT Region, COUNT(*) AS SupplierCount 
FROM suppliers 
GROUP BY Region;
""""""

# Execute the SQL query to get supplier count by region
region_df = execute_sql_query(region_query)

# Create a bar chart for supplier count by region
fig = px.bar(region_df, x='Region', y='SupplierCount', title='Count of Suppliers by Region')
show_to_user(suppliers_df)
show_to_user(fig)
```","The evaluated code and the reference code address two different requirements. The business request and reference code focus on finding suppliers who have never been involved in any orders and plotting their count by region. The evaluated code incorrectly joins the 'orders' table directly to 'products' using 'OrderID', which is logically incorrect, since 'OrderID' should relate to 'Order Details'. Consequently, it doesn't accurately identify suppliers not involved in any orders. Additionally, it shows the count of all suppliers by region, instead of specifically 'inactive' suppliers, resulting in a chart that doesn't align with the reference logic.","```python
import plotly.express as px

# SQL query to fetch suppliers who have never been involved in any orders
sql_query_no_orders = """"""
SELECT CompanyName, Region 
FROM suppliers 
WHERE SupplierID NOT IN (SELECT DISTINCT SupplierID FROM orders);
""""""

# Execute the SQL query
suppliers_no_orders_df = execute_sql_query(sql_query_no_orders)

# Generate the count of suppliers by region
suppliers_count_by_region = suppliers_no_orders_df['Region'].value_counts().reset_index()
suppliers_count_by_region.columns = ['Region', 'Count']

# Create a bar chart using Plotly
fig = px.bar(suppliers_count_by_region, x='Region', y='Count', title='Count of Suppliers by Region')

# Display the bar chart
show_to_user(fig)
```","The input Python code's SQL query checks for suppliers not involved in any 'orders', while the reference checks against 'Order Details' using a join with 'products'. The logic differs: the input code does not correctly identify suppliers with no products in any orders. Additionally, the input code calculates suppliers count by using 'value_counts()', which is correct in logic, but follows a different approach than using 'groupby' and 'size()'.",None
What are the top 5 products by units sold? Please include a bar chart to visualize the data.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 5 products by units sold
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSold
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalSold DESC
LIMIT 5;
""""""

# Execute the query and get the results as a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductName', y='TotalSold', title='Top 5 Products by Units Sold')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 5
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalUnitsSold', title='Top 5 Products by Units Sold')
show_to_user(fig)
```","The input code correctly executes an SQL query to retrieve the top 5 products by units sold, similar to the reference implementation. It specifies the same join and group by logic with correct ordering and limiting. The use of 'ProductID' in the group by is an additional column but does not affect the result adversely. The visualization part using Plotly is also consistent with the requirement, displaying 'ProductName' on the x-axis and 'TotalUnitsSold' on the y-axis, corresponding to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 5 products by units sold
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductID 
ORDER BY TotalUnitsSold DESC 
FETCH FIRST 5 ROWS ONLY;
""""""

# Execute the SQL query
data_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 products by units sold
fig = px.bar(data_df, 
             x='ProductID', 
             y='TotalUnitsSold', 
             title='Top 5 Products by Units Sold',
             labels={'ProductID': 'Product ID', 'TotalUnitsSold': 'Total Units Sold'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code returns the top 5 products by quantity ordered, identifying them by 'ProductID' rather than 'ProductName'. This differs from the reference implementation which uses 'ProductName' to group and order the results. The bar chart in the input code will display 'Product ID' while the requirement specifies using the 'Product Name'.",Base
"How many orders require shipping but have not yet been shipped per employee, and can this be visualized in a bar chart for clearer insights?","```python
import pandas as pd
import plotly.express as px

# SQL query from the request
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    COUNT(orders.OrderID) AS UnshippedOrders 
FROM 
    employees 
JOIN 
    orders 
ON 
    employees.EmployeeID = orders.EmployeeID 
WHERE 
    orders.ShippedDate IS NULL 
    AND orders.RequiredDate IS NOT NULL 
GROUP BY 
    employees.EmployeeID;
""""""

# Function to execute the SQL query and fetch the data
def fetch_unshipped_orders_data():
    return execute_sql_query(sql_query)

# Fetching data using the utility function
unshipped_orders_df = fetch_unshipped_orders_data()

# Creating a bar chart for the unshipped orders per employee
fig = px.bar(
    unshipped_orders_df, 
    x='EmployeeID', 
    y='UnshippedOrders', 
    title='Unshipped Orders per Employee',
    labels={'EmployeeID': 'Employee ID', 'UnshippedOrders': 'Unshipped Orders'},
    text='UnshippedOrders'
)

# Display the figure using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS PendingShipments
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate IS NULL
AND o.RequiredDate <= CURRENT_DATE
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

pending_shipments = execute_sql_query(sql_query)

fig = px.bar(pending_shipments, x='FirstName', y='PendingShipments', 
             title='Pending Shipments per Employee', 
             labels={'FirstName': 'Employee Name', 'PendingShipments': 'Number of Pending Shipments'})
show_to_user(fig)
```","The input code includes additional columns (FirstName, LastName) in the SELECT and GROUP BY clauses, which are not present in the reference implementation. Also, it uses CURRENT_DATE instead of checking if RequiredDate is NOT NULL. This changes the logic and condition for pending shipments.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    COUNT(orders.OrderID) AS PendingOrders 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
WHERE 
    orders.ShippedDate IS NULL 
    AND orders.RequiredDate IS NOT NULL 
GROUP BY 
    employees.EmployeeID;
""""""

# Execute the SQL query and store the result in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration
    # In practice, this would be implemented to actually execute the SQL query
    data = {
        ""EmployeeID"": [1, 2, 3],
        ""PendingOrders"": [5, 3, 8]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock implementation for demonstration
    # In practice, this would handle displaying data frames or plots
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Fetch the data executing the SQL query
orders_pending_by_employee_df = execute_sql_query(sql_query)

# Visualize the result in a bar chart
fig = px.bar(
    orders_pending_by_employee_df, 
    x='EmployeeID', 
    y='PendingOrders', 
    title='Pending Orders by Employee',
    labels={'PendingOrders': 'Number of Pending Orders', 'EmployeeID': 'Employee ID'}
)

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the logic specified in the business analytics request and aligns with the reference implementation. Both codes perform the task of calculating the count of unshipped orders that require shipping per employee using a SQL query with a JOIN between employees and orders, filtering on conditions `orders.ShippedDate IS NULL` and `orders.RequiredDate IS NOT NULL`, and then grouping by `EmployeeID`. The result is visualized as a bar chart using Plotly Express, and the chart is displayed using a defined function. The differences in variable names and function details do not affect the correctness of the analysis.",Finetuned
"Which product categories are generating the most revenue, and can you provide a visual representation of the revenue distribution among these categories?","
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS revenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName 
ORDER BY revenue DESC
""""""

# Execute SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize revenue distribution among categories
fig = px.bar(df, x='CategoryName', y='revenue', 
             title='Revenue Distribution Among Product Categories',
             labels={'CategoryName': 'Product Category', 'revenue': 'Revenue ($)'})

# Display the visualization to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
GROUP BY categories.CategoryName
ORDER BY revenue DESC;
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, 
             x='CategoryName', 
             y='revenue', 
             title='Revenue Distribution by Product Category', 
             labels={'CategoryName': 'Product Category', 'revenue': 'Revenue'})
show_to_user(fig)
```","The input Python code logically adheres to the reference implementation. Both codes perform the same SQL query to calculate the revenue for each product category using a SUM operation on the product of UnitPrice, Quantity, and (1 - Discount). The JOIN operations are identical and ensure correct relationships between tables: [Order Details], orders, products, and categories. Grouping and ordering by revenue are consistent in both implementations. The input code correctly uses Plotly Express to create a bar chart visualizing the revenue distribution. Slight differences in SQL formatting and plot parameters (e.g., plot title and label name) do not affect the correctness of the output, as the primary logic is maintained.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS revenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName 
ORDER BY revenue DESC;
""""""

# Execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function - in practice, this connects to your database
    pass

# Fetch data as a DataFrame
df_revenue_distribution = execute_sql_query(sql_query)

# Plotly visualization
fig = px.pie(df_revenue_distribution, 
             values='revenue', 
             names='CategoryName', 
             title='Revenue Distribution by Product Category')

# Display the result
show_to_user(fig)
```","The input code uses a different visualization type (a pie chart instead of a bar chart) compared to the reference implementation, which changes the way information is conveyed. Additionally, the input code omits joining with the 'orders' table, which may affect the revenue calculation depending on the database schema. Therefore, it does not fully adhere to the logic of the reference implementation.",Base
Identify products that have never been ordered and create a visualization to display these products.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have never been ordered
sql_query = '''
SELECT ProductName 
FROM products 
WHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM [Order Details]);
'''

# Execute the SQL query and fetch the results into a DataFrame
unused_products_df = execute_sql_query(sql_query)

# Create a visualization to display products that have never been ordered
fig = px.bar(unused_products_df, x='ProductName', title='Products Never Ordered')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL
""""""

# Execute the SQL query
never_ordered_products = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(never_ordered_products, x='ProductName', y='ProductID', title='Products Never Ordered', labels={'ProductID': 'Product ID', 'ProductName': 'Product Name'})
show_to_user(fig)
```","Both implementations correctly identify products that have never been ordered using different SQL approaches. The reference code uses a `NOT IN` subquery, whereas the evaluation code uses a `LEFT JOIN` with a `NULL` check. Both achieve the same result. The visualization step in both codes uses Plotly to create a bar chart of these products. The difference in the axis labels does not affect correctness.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to find products never ordered
sql_query = """"""
SELECT ProductID, ProductName FROM products WHERE ProductID NOT IN (SELECT ProductID FROM ""Order Details"");
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate executing the SQL query
    # This would normally connect to a database and fetch results
    # Here it returns an empty DataFrame for demonstration purposes
    return pd.DataFrame({'ProductID': [], 'ProductName': []})

def show_to_user(data):
    # Placeholder function to simulate showing the result to the user
    # This would display the visualization in the actual implementation
    pass

# Execute the query to get products never ordered
unordered_products_df = execute_sql_query(sql_query)

# Check if there are unordered products to visualize
if not unordered_products_df.empty:
    # Create a bar chart using Plotly
    fig = px.bar(unordered_products_df, x='ProductName', title='Products Never Ordered')
    # Show the figure
    show_to_user(fig)
else:
    # If no unordered products, show the DataFrame to the user
    show_to_user(unordered_products_df)
```","The input code correctly implements the business analytics request by identifying products that have never been ordered and attempting to visualize this data. It uses an SQL query similar to the reference code to determine which products have never been ordered, although it fetches both ProductID and ProductName. The code then checks if there are any such products and creates a bar chart if so. The approach and logic align with the reference implementation, fulfilling the specified analytics request.",both
"Which month had the highest total sales revenue in 2023, and can you provide a bar chart to visualize the monthly sales revenue?","import pandas as pd
import plotly.express as px

# Define the SQL query to get monthly sales revenue for 2023
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * 
    (1 - [Order Details].Discount)) AS total_sales 
FROM 
    [Order Details] 
JOIN 
    orders 
ON 
    [Order Details].OrderID = orders.OrderID 
WHERE 
    YEAR(OrderDate) = 2023 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m') 
ORDER BY 
    month
""""""

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Identify the month with the highest sales
highest_sales_month = sales_data.loc[sales_data['total_sales'].idxmax()]

# Prepare a bar chart of monthly sales revenue
fig = px.bar(sales_data, x='month', y='total_sales', title='Monthly Sales Revenue for 2023')

# Display the bar chart to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY month
ORDER BY total_sales DESC
LIMIT 1
""""""

highest_month = execute_sql_query(sql_query)
highest_month_name = highest_month['month'][0]

sales_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY month
ORDER BY month
""""""

monthly_sales = execute_sql_query(sales_query)

fig = px.bar(monthly_sales, x='month', y='total_sales', title='Monthly Sales Revenue in 2023')
show_to_user(fig)
```","The provided Python code effectively answers the business question and follows the same logic as the reference implementation. It calculates the monthly sales revenue for 2023, determines the month with the highest sales revenue, and visualizes the data with a bar chart. While it uses an additional SQL query to directly get the highest sales month, this is an acceptable variation in approach and does not deviate from the task requirements.","```python
import pandas as pd
import plotly.express as px

# Utility function stub
def execute_sql_query(sql_query: str):
    # Simulation of data acquisition
    pass

def show_to_user(data):
    # Simulation of result presentation
    pass

# SQL query to fetch monthly sales revenue for 2023
sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM orders.OrderDate) AS year,
    EXTRACT(MONTH FROM orders.OrderDate) AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY 
    year, month
ORDER BY 
    month;
""""""

# Execute the SQL query
monthly_sales_df = execute_sql_query(sql_query)

# Check the DataFrame to ensure it has data
if monthly_sales_df is not None and not monthly_sales_df.empty:
    # Create a bar chart to visualize monthly sales revenue
    fig = px.bar(
        monthly_sales_df, 
        x='month', 
        y='total_sales', 
        labels={'month': 'Month', 'total_sales': 'Total Sales Revenue'},
        title='Monthly Sales Revenue in 2023'
    )

    # Display the figure
    show_to_user(fig)

    # Determine the month with the highest sales revenue
    max_sales_month = monthly_sales_df.loc[monthly_sales_df['total_sales'].idxmax()]

    # Prepare the result as a dataframe to display
    result_df = pd.DataFrame({
        'Month': [max_sales_month['month']],
        'Total_Sales': [max_sales_month['total_sales']]
    })

    # Show the month with the highest sales
    show_to_user(result_df)
else:
    print(""No data available for the specified date range."")
```","The input code correctly executes an SQL query to fetch monthly sales revenue for 2023 using a slightly different SQL syntax but achieves the same result as the reference code. It then identifies the month with the highest sales and provides a bar chart to visualize the monthly sales revenue. The code checks for the existence of data before proceeding and displays results similar to the reference implementation, fulfilling the business analytics request.",both
Which products have a high sales volume due to specific employees? Include a visualization of sales volume by employee and product.,"```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query (assuming implementation is provided)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Function implementation assumed
    pass

# Utility function to display data (assuming implementation is provided)
def show_to_user(data):
    # Function implementation assumed
    pass

# SQL query from the business request
sql_query = """"""
SELECT [Order Details].ProductID, employees.EmployeeID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY [Order Details].ProductID, employees.EmployeeID 
HAVING SUM([Order Details].Quantity) > 1000;
""""""

# Execute the SQL query and get the data
sales_data = execute_sql_query(sql_query)

# Create a visualization of sales volume by employee and product
fig = px.bar(sales_data, x='EmployeeID', y='TotalQuantity', color='ProductID',
             title='Sales Volume by Employee and Product',
             labels={'TotalQuantity': 'Total Sales Volume', 'EmployeeID': 'Employee ID', 'ProductID': 'Product ID'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.FirstName,
    e.LastName,
    p.ProductID,
    SUM(od.Quantity) AS TotalQuantity,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, p.ProductID
ORDER BY 
    TotalQuantity DESC
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='TotalQuantity', y='ProductID', color='EmployeeID', 
             title='Sales Volume by Employee and Product', 
             labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity Sold', 'EmployeeID': 'Employee'},
             category_orders={'EmployeeID': df['EmployeeID'].unique()})

show_to_user(fig)
```","The input code does not adhere to the logic of the reference implementation. The reference code specifically filters to show only products where the total quantity sold is greater than 1000 by using the HAVING clause. The input code lacks this filter and instead orders by `TotalQuantity` without filtering. This deviation means it does not answer the business request correctly. Additionally, the input code uses `FirstName` and `LastName`, which are not utilized in the reference query or visualization.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve sales data
sql_query = """"""
SELECT 
    products.ProductID, 
    employees.EmployeeID, 
    employees.FirstName, 
    employees.LastName, 
    SUM([Order Details].Quantity) AS HighVolumeSales 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    employees ON orders.EmployeeID = employees.EmployeeID 
GROUP BY 
    employees.EmployeeID, employees.FirstName, employees.LastName, products.ProductID 
ORDER BY 
    HighVolumeSales DESC;
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation, replace with actual database interaction
    # This should return a DataFrame with the result of the query
    pass

# Assume function 'execute_sql_query' has been correctly implemented 
# and it connects to the appropriate database
sales_data = execute_sql_query(sql_query)

# Create a visualization of sales volume by employee and product
fig = px.bar(sales_data, 
             x='ProductID', 
             y='HighVolumeSales', 
             color='FirstName',
             title=""Sales Volume by Employee and Product"",
             labels={'HighVolumeSales': 'Sales Volume', 'ProductID': 'Product ID'})

# Display the visualization using the utility function
def show_to_user(data):
    # Mock implementation for housing
    pass

show_to_user(fig)
```","The reference implementation focuses on products with sales volume over a threshold of 1000 by employee and product, using a HAVING clause to filter. The input implementation does not apply this threshold and includes additional employee details, focusing on general sales volume sorted in descending order without any filtering. Therefore, it does not adhere to the same logic as the reference implementation.",None
"Which employees have sales in more than three different countries, and can we visualize this distribution using a map or chart?","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT e.EmployeeID, COUNT(DISTINCT o.ShipCountry) AS Countries 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
HAVING Countries > 3;
""""""

# Function to execute the SQL query and get a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to the database, execute the query, and return the result as a DataFrame
    # Mocking a sample DataFrame for illustration purposes
    data = {
        'EmployeeID': [1, 2, 3],
        'Countries': [4, 5, 6]
    }
    return pd.DataFrame(data)

# Execute the SQL query
results_df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(results_df, x='EmployeeID', y='Countries', title='Employees with Sales in More Than Three Countries')

# Show the visualization to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(DISTINCT o.ShipCountry) AS CountryCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
HAVING COUNT(DISTINCT o.ShipCountry) > 3
""""""

employees_with_sales = execute_sql_query(sql_query)

fig = px.bar(employees_with_sales, x='FirstName', y='CountryCount', title='Employees with Sales in More than Three Countries')
show_to_user(fig)
```","The input Python code correctly identifies employees with sales in more than three different countries by using a SQL query similar to the reference implementation. It calculates the number of distinct ship countries per employee and filters those with more than three countries. The visualization is created using Plotly, similar to the reference implementation, but includes first names on the x-axis for clarity, which is an acceptable variation.","```python
import pandas as pd
import plotly.express as px

# SQL query string
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(DISTINCT o.ShipCountry) AS CountryCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
HAVING COUNT(DISTINCT o.ShipCountry) > 3;
""""""

# Execute SQL query and obtain the DataFrame
employee_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of employees
fig = px.bar(
    employee_sales_df,
    x='EmployeeID',
    y='CountryCount',
    hover_data=['FirstName', 'LastName'],
    labels={'CountryCount': 'Number of Countries'},
    title='Employees with Sales in More Than Three Different Countries'
)

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request. It uses a SQL query to retrieve employees who have sales in more than three different countries, similar to the reference code. The input code includes additional columns like 'FirstName' and 'LastName' for enhanced hover data in the visualization, which is not part of the logical requirement for correctness but adds informative detail. The execution and the visualization logic using Plotly are consistent with the reference logic.",both
"Which region experiences the most delays in shipments, and can this be shown with a regional heatmap?","```python
import plotly.express as px
import pandas as pd

# SQL query to find the region with the most delayed shipments 
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS DelayedShipments 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY ShipRegion 
ORDER BY DelayedShipments DESC;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
delayed_shipments_df = execute_sql_query(sql_query)

# Display the raw data to the user
show_to_user(delayed_shipments_df)

# Create a heatmap to visually represent the delays by region
fig = px.choropleth(delayed_shipments_df,
                    locations='ShipRegion',
                    locationmode='country names',
                    color='DelayedShipments',
                    color_continuous_scale='Reds',
                    title='Regions with Most Delayed Shipments')

# Display the heatmap to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, 
       COUNT(OrderID) AS TotalOrders,
       SUM(CASE WHEN ShippedDate > RequiredDate THEN 1 ELSE 0 END) AS DelayCount
FROM orders
GROUP BY ShipRegion
""""""

region_data = execute_sql_query(sql_query)

region_data['DelayRate'] = region_data['DelayCount'] / region_data['TotalOrders']
fig = px.choropleth(region_data, 
                     locations='ShipRegion', 
                     locationmode='USA-states', 
                     color='DelayRate',
                     scope='usa',
                     title='Shipment Delay Rate by Region',
                     color_continuous_scale=px.colors.sequential.Plasma)

show_to_user(fig)
```","The input code calculates a delay rate by dividing delayed shipments by total orders, while the reference focuses solely on total delayed shipments per region. The choropleth setup differs: the input uses 'USA-states' and displays delay rates; the reference uses 'country names' and displays counts. These differences mean the input does not follow the same logic as the reference.","```python
import pandas as pd
import plotly.express as px

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function simulates the execution of an SQL query and returns a mock DataFrame
    # In an actual environment, this would connect to a database and execute the query
    data = {
        ""Region"": [""North America"", ""Europe"", ""Asia""],
        ""LateShipments"": [150, 120, 90]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()


# SQL query from the business analytic request
sql_query = """"""
SELECT Region, COUNT(OrderID) AS LateShipments 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY Region;
""""""

# Execute the SQL query to get the data
df_late_shipments = execute_sql_query(sql_query)

# Generate a regional heatmap using Plotly
fig = px.choropleth(
    df_late_shipments, 
    locations='Region', 
    locationmode='country names',  # Assuming region names can be translated to country names for visualization
    color='LateShipments', 
    title='Regional Heatmap of Late Shipments',
    color_continuous_scale='Viridis'
)

# Display the heatmap to the user
show_to_user(fig)
```","The input code fulfills the business analytics request by retrieving data regarding shipment delays using an SQL query that groups by 'Region' and counts 'OrderID' where 'ShippedDate' is greater than 'RequiredDate'. It then creates a heatmap using Plotly to visualize the delays by region. Even though it uses different color scales ('Viridis' instead of 'Reds') and a slightly different naming for columns ('Region' vs. 'ShipRegion' and 'LateShipments' vs. 'DelayedShipments'), the logic aligns with the reference implementation.",Finetuned
Which category of products has the highest number of units sold? Include a bar chart to visualize the comparison of units sold across categories.,"```python
import plotly.express as px

def analyze_product_categories():
    # SQL query to get total units sold by category
    sql_query = """"""
    SELECT CategoryID, SUM([Order Details].Quantity) AS TotalSold
    FROM products
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
    GROUP BY CategoryID
    ORDER BY TotalSold DESC
    """"""

    # Execute the query and get the data in a pandas DataFrame
    df = execute_sql_query(sql_query)

    # Create a bar chart to visualize units sold across categories
    fig = px.bar(df, x='CategoryID', y='TotalSold', title='Units Sold by Category')
    
    # Display the bar chart using the utility function
    show_to_user(fig)

# Call the function to perform analysis and visualization
analyze_product_categories()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY TotalUnitsSold DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CategoryID', y='TotalUnitsSold', title='Total Units Sold by Product Category', labels={'TotalUnitsSold': 'Units Sold', 'CategoryID': 'Category ID'})
show_to_user(fig)
```",Both implementations perform the same task of querying a database to find the total units sold per product category and then display the results in a bar chart. The logic in both codes matches: they both execute the SQL query to aggregate quantity by CategoryID and then use Plotly to generate the visualization. The differences in variable naming and chart labeling do not affect the correctness of the analysis as they align functionally with the reference.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch category-wise units sold
sql_query = """"""
SELECT products.CategoryID, 
       SUM([Order Details].Quantity) AS units_sold 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.CategoryID 
ORDER BY units_sold DESC;
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Generate a bar chart to visualize units sold across categories
fig = px.bar(df, x='CategoryID', y='units_sold', title='Units Sold Across Categories',
             labels={'CategoryID': 'Category ID', 'units_sold': 'Units Sold'})

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code adheres to the business analytics request and follows the same logic as the reference implementation. It correctly queries the database to sum the units sold by category, groups by CategoryID, and orders the results based on total units sold. The bar chart is then created using similar parameters, and the functionality to display the chart is included. The differences, such as column names ('units_sold' vs 'TotalSold') and minor text changes, do not affect the correctness of the solution.",both
Identify products below their reorder levels and visualize the results using a bar chart to highlight the most critical items.,"
```python
import pandas as pd
import plotly.express as px

# Query to identify products below their reorder levels
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_below_reorder = execute_sql_query(sql_query)

# Create a new DataFrame for plotting
plot_data = products_below_reorder.copy()
plot_data['CriticalLevel'] = plot_data['ReorderLevel'] - plot_data['UnitsInStock']

# Create a bar chart using Plotly
fig = px.bar(
    plot_data, 
    x='ProductName', 
    y='CriticalLevel',
    title='Products Below Reorder Levels',
    labels={'CriticalLevel': 'Units Below Reorder Level'},
    hover_data=['UnitsInStock', 'ReorderLevel']
)

# Display the visualization
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""

products_below_reorder = execute_sql_query(sql_query)

fig = px.bar(products_below_reorder, 
              x='ProductName', 
              y='UnitsInStock', 
              title='Products Below Reorder Levels', 
              labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code does not calculate the critical difference (ReorderLevel - UnitsInStock) as the reference code does. Instead, it directly plots 'UnitsInStock' on the y-axis without highlighting how critical the stock level is compared to the reorder level. It also includes an extra condition in the SQL query (Discontinued = 0) which isn't present in the reference code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;""

# Function to execute SQL query and return the DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the actual SQL execution logic
    # You would typically use a library like SQLAlchemy or pyodbc
    # Here we return a dummy DataFrame for illustration
    return pd.DataFrame({
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'UnitsInStock': [10, 2, 5],
        'ReorderLevel': [15, 10, 8]
    })

# Execute the SQL query
products_below_reorder = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(
    products_below_reorder,
    x='ProductName',
    y='UnitsInStock',
    hover_data=['ReorderLevel'],
    labels={'UnitsInStock': 'Units In Stock'},
    title='Products Below Reorder Levels'
)

# Display the visualization to the user
def show_to_user(data):
    # Placeholder for actual user display logic
    print(data)

show_to_user(fig)
```","The input code does not calculate 'CriticalLevel', which indicates how critical the inventory situation is (i.e., the difference between ReorderLevel and UnitsInStock). Instead, it directly plots 'UnitsInStock', which does not highlight the urgency of reordering. The reference code focuses on displaying 'CriticalLevel', making it easier to identify critical items. Additionally, the labels and bar plot configuration do not match the intention of the business analytics request.",None
Which product category has the highest average unit price? Please include a bar chart to visualize the average unit prices across categories.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get average unit prices per category
sql_query = '''
SELECT categories.CategoryName, AVG(products.UnitPrice) AS avg_unit_price 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY categories.CategoryName 
ORDER BY avg_unit_price DESC
'''

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Bar chart to visualize the average unit prices across categories
fig = px.bar(df, x='CategoryName', y='avg_unit_price', 
             title='Average Unit Price by Product Category',
             labels={'avg_unit_price': 'Average Unit Price', 'CategoryName': 'Product Category'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CategoryName, AVG(od.UnitPrice) AS avg_unit_price
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryName
ORDER BY avg_unit_price DESC
""""""

average_prices_df = execute_sql_query(sql_query)

fig = px.bar(average_prices_df, x='CategoryName', y='avg_unit_price', title='Average Unit Prices by Category', labels={'avg_unit_price': 'Average Unit Price', 'CategoryName': 'Product Category'})
show_to_user(fig)

highest_avg_price_category = average_prices_df.iloc[0]
highest_avg_price_category
```","The input code computes the average unit price based on the 'Order Details' table instead of the 'products' table like the reference code. This could lead to different results if 'Order Details' has unit prices that vary from the ones in 'products'. Moreover, the input code returns the first row but does not particularly highlight it in the visualization.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch categories and their average unit prices
sql_query = ""SELECT CategoryID, AVG(UnitPrice) AS AvgUnitPrice FROM products GROUP BY CategoryID;""

# Execute the SQL query and get the result as a pandas DataFrame
product_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize average unit prices across categories
fig = px.bar(product_data, x='CategoryID', y='AvgUnitPrice', title='Average Unit Price by Product Category')

# Display the bar chart using the utility function
show_to_user(fig)
```","The input code groups by 'CategoryID' and does not join with the 'categories' table to get 'CategoryName'. This means it doesn't provide the category names and only visualizes by 'CategoryID', unlike the reference which correctly uses 'CategoryName'.",None
"    ""What percentage of products are currently discontinued? Please include a pie chart to visualize the proportion of discontinued versus active products.","```python
import plotly.express as px
import pandas as pd

# SQL Query to fetch data
sql_query = """"""
SELECT 
    COUNT(CASE WHEN products.Discontinued = 1 THEN 1 END) * 100.0 / COUNT(products.ProductID) AS discontinued_percentage,
    (COUNT(products.ProductID) - COUNT(CASE WHEN products.Discontinued = 1 THEN 1 END)) * 100.0 / COUNT(products.ProductID) AS active_percentage
FROM products
""""""

# Execute SQL query and get the result as a DataFrame
data = execute_sql_query(sql_query)

# Prepare data for visualization
discontinued_percentage = data.iloc[0]['discontinued_percentage']
active_percentage = data.iloc[0]['active_percentage']

# Create a DataFrame with the prepared data
plot_data = pd.DataFrame({
    'Status': ['Discontinued', 'Active'],
    'Percentage': [discontinued_percentage, active_percentage]
})

# Plot the data using a pie chart
fig = px.pie(plot_data, names='Status', values='Percentage', title='Products Status Distribution')

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count active and discontinued products
sql_query = """"""
SELECT 
    COUNT(*) AS total_products, 
    SUM(CASE WHEN Discontinued = 1 THEN 1 ELSE 0 END) AS discontinued_products 
FROM products
""""""

# Execute the SQL query and retrieve the data
data = execute_sql_query(sql_query)

# Calculate the percentage of discontinued products
total_products = data['total_products'].iloc[0]
discontinued_products = data['discontinued_products'].iloc[0]
active_products = total_products - discontinued_products

percentage_discontinued = (discontinued_products / total_products) * 100

# Prepare data for pie chart
labels = ['Active Products', 'Discontinued Products']
values = [active_products, discontinued_products]

# Create a pie chart
fig = px.pie(names=labels, values=values, title=f'Percentage of Discontinued Products: {percentage_discontinued:.2f}%')

# Show the chart
show_to_user(fig)
```","The input code correctly calculates the percentage of discontinued products compared to total products. It uses an SQL query to retrieve the total number of products and the number of discontinued products. The active product count is derived by subtracting the discontinued products from the total. The pie chart visualizes discontinued and active products, aligning with the reference implementation, whose logic divides products into discontinued and active categories and calculates percentages similarly. Despite minor differences in query and variable names, both codes ultimately serve the same purpose and result in a correct output.","
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str):
    # This is a placeholder for the functionality that executes
    # the SQL query and returns a pandas DataFrame.
    # For real usage, this function needs to be implemented.
    pass

def show_to_user(data):
    # This function displays the data or plot to the user.
    # It's expected to accept a pandas DataFrame or a Plotly figure.
    pass

# SQL query to get the count of discontinued and active products
sql_query = """"""
SELECT 
    CASE WHEN Discontinued = 1 THEN 'Discontinued' ELSE 'Active' END AS ProductStatus, 
    COUNT(*) AS Count 
FROM products 
GROUP BY ProductStatus
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a pie chart using Plotly
fig = px.pie(df, names='ProductStatus', values='Count', 
             title='Product Status Distribution')

# Display the pie chart to the user
show_to_user(fig)
","The provided code correctly calculates the percentage of discontinued versus active products and visualizes it using a pie chart. Although the SQL query approach is different from the reference implementation, it logically derives the equivalent information by grouping by 'ProductStatus' and counting the instances, which achieves the same end result. Both implementations produce a pie chart displaying the proportion of discontinued versus active products.",both
"Which customer has placed the highest number of orders? Additionally, include a bar chart showing the top five customers by the number of orders.","```python
import pandas as pd
import plotly.express as px

# Function that executes the SQL query and returns a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is supposed to execute the query and return a DataFrame
    # Replace the below line with actual execution of the SQL query
    return pd.DataFrame()

# Function to display data or visualization results
def show_to_user(data):
    # Outputs the data or visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to get all customers with the number of orders
sql_query = """"""
    SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders
    FROM orders
    GROUP BY CustomerID
    ORDER BY NumberOfOrders DESC
""""""

# Execute SQL query
customers_orders_df = execute_sql_query(sql_query)

# Get the top customer who placed the most orders
top_customer_df = customers_orders_df.head(1)
show_to_user(top_customer_df)

# Creating a bar chart for the top five customers by number of orders
top_five_customers_df = customers_orders_df.head(5)
fig = px.bar(top_five_customers_df, x='CustomerID', y='NumberOfOrders', 
             title='Top Five Customers by Number of Orders')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 5
""""""

top_customers_df = execute_sql_query(sql_query)

highest_customer_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 1
""""""
highest_customer_df = execute_sql_query(highest_customer_query)

fig = px.bar(top_customers_df, x='CustomerID', y='OrderCount', title='Top 5 Customers by Number of Orders', labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

show_to_user(highest_customer_df)
show_to_user(fig)
```","The provided input Python code correctly implements the business analytics logic of determining the customer with the highest number of orders and visualizes the top five customers by number of orders. It uses two separate SQL queries to obtain the top customer and the top five customers. The logic and results align with the reference implementation's goals, even though the sequence and structure slightly differ. Both implementations use appropriate SQL queries and Plotly to achieve the desired analyses and visualizations.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholders (assumed available in the environment)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should interact with the database and return a DataFrame
    pass

def show_to_user(data):
    # This function should handle displaying data or figures
    pass

# SQL to fetch the top five customers by the number of orders
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) as NumberOfOrders 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.CustomerID 
ORDER BY NumberOfOrders DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_customers_df = execute_sql_query(sql_query)

# Find customer with the highest number of orders
if not top_customers_df.empty:
    top_customer = top_customers_df.iloc[0]
    
    # Filtered DataFrame for displaying purpose
    top_five_customers_df = top_customers_df.head(5)

    # Plot using Plotly
    fig = px.bar(top_five_customers_df, 
                 x='CustomerID', 
                 y='NumberOfOrders', 
                 title='Top 5 Customers by Number of Orders',
                 labels={'CustomerID': 'Customer ID', 'NumberOfOrders': 'Number of Orders'})

    # Display the results
    show_to_user(top_five_customers_df)
    show_to_user(fig)
```
","The provided input code correctly addresses the business analytics request. Both the reference and input implementations query the number of orders per customer, sort them in descending order, and fetch the top records. The input code directly limits the SQL result to the top five customers, whereas the reference code retrieves all and slices them in Python. However, this approach still ensures the top customer is captured correctly. The bar chart in both versions uses Plotly to visualize the top five customers. The minor SQL differences do not affect the overall logic or outcome, so the input implementation correctly meets the request.",both
"What is the total sales generated by each employee in 2023, and can you provide a bar chart to visualize the sales data by employee?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID
""""""

def execute_sql_query(sql_query: str):
    # Placeholder for the real implementation
    # Returning a dummy DataFrame for demonstration
    return pd.DataFrame({
        'EmployeeID': [1, 2, 3],
        'total_sales': [50000, 75000, 64000]
    })

def show_to_user(data):
    # Placeholder function to handle display logic
    print(data)

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='total_sales', title='Total Sales by Employee in 2023')

# Use the utility function to show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, 
       CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
""""""

employee_sales_df = execute_sql_query(sql_query)

fig = px.bar(employee_sales_df, x='EmployeeName', y='total_sales', 
             title='Total Sales Generated by Each Employee in 2023', 
             labels={'total_sales': 'Total Sales', 'EmployeeName': 'Employee Name'})

show_to_user(fig)
```",The input Python code correctly calculates the total sales generated by each employee in 2023 and visualizes the data using a bar chart. It follows the same logic as the reference code. The additional fields for employee names do not affect the total sales calculation and enhance the visualization by providing more context.,"```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return data as DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated implementation, replace with actual SQL execution
    # For example, using SQLAlchemy or similar library
    pass

# Function to display data or visualization results
def show_to_user(data):
    # Should handle both DataFrames and Plotly figures
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to obtain total sales by employee for 2023
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and retrieve data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize total sales by employee
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Total Sales by Employee in 2023')

# Display the plot using the show_to_user function
show_to_user(fig)
```","The input Python code correctly executes an SQL query to sum the total sales by each employee for the year 2023 and generates a bar chart using Plotly. It follows the same logic as the reference implementation, even though minor differences in code structure exist, such as variable naming and specific DataFrame handling. The overall logic and steps to fulfill the business analytics request are preserved.",both
Identify the employees who have a higher salary than the average salary and visualize the distribution of salaries to highlight those employees.,"```python
import pandas as pd
import plotly.express as px

# SQL query to identify employees with higher salary than average
sql_query = """"""
SELECT EmployeeID, CONCAT(FirstName, ' ', LastName) AS EmployeeName, Salary
FROM employees
""""""

# Execute the query and store the result in a pandas DataFrame
employees_df = execute_sql_query(sql_query)

# Calculate the average salary
average_salary = employees_df['Salary'].mean()

# Filter employees with salary greater than the average salary
higher_salary_df = employees_df[employees_df['Salary'] > average_salary]

# Visualize the distribution of salaries
fig = px.histogram(employees_df, x='Salary', nbins=20, title='Salary Distribution',
                   labels={'Salary': 'Salary'},
                   color=employees_df['Salary'] > average_salary,
                   color_discrete_map={True: 'red', False: 'blue'},
                   opacity=0.7,
                   hover_data=['EmployeeName'])

# Customize the layout to highlight employees with above-average salaries
fig.update_layout(bargap=0.2, showlegend=False)

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Query to get salaries and calculate average
sql_query = """"""
SELECT Salary
FROM employees
""""""
salaries_df = execute_sql_query(sql_query)
average_salary = salaries_df['Salary'].mean()

# Step 2: Query to get employees with salary above average
sql_query_above_average = f""""""
SELECT EmployeeID, FirstName, LastName, Salary
FROM employees
WHERE Salary > {average_salary}
""""""
above_average_employees_df = execute_sql_query(sql_query_above_average)

# Step 3: Visualize salary distribution highlighting those employees
fig = px.histogram(salaries_df, x='Salary', title='Salary Distribution with Above Average Employees Highlighted')
fig.add_traces(px.histogram(above_average_employees_df, x='Salary', name='Above Average Employees', 
                             opacity=0.75).data)

show_to_user(fig)
```","The input code calculates the average salary similarly to the reference code, but it executes a second SQL query to retrieve employees with salaries above the average. This approach is technically correct, but it misses the step of explicitly concatenating first and last names like in the reference code. The larger issue is in the visualization. The input code uses two separate histograms to represent the distribution, potentially leading to unclear overlaps. The reference version uses color coding within a single histogram, which better highlights salaries above the average and aligns with the intended requirement.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get employees with a higher salary than the average salary
sql_query = """"""
SELECT e.EmployeeID, e.Salary FROM employees e 
WHERE e.Salary > (SELECT AVG(Salary) FROM employees);
""""""
employees_above_average_salary = execute_sql_query(sql_query)

# Execute query to get all employees' salaries for visualization
sql_query_all_salaries = ""SELECT EmployeeID, Salary FROM employees;""
all_salaries_df = execute_sql_query(sql_query_all_salaries)

# Visualize the distribution of salaries
fig = px.histogram(all_salaries_df, x='Salary', 
                   title='Distribution of Salaries',
                   labels={'Salary': 'Salary'},
                   opacity=0.75)

# Highlight the employees who have a higher salary than the average
highlight_df = all_salaries_df[all_salaries_df['EmployeeID'].isin(employees_above_average_salary['EmployeeID'])]
fig.add_trace(px.scatter(highlight_df, x='Salary', y=pd.Series([0]*len(highlight_df)), 
                         size=[10]*len(highlight_df)).data[0])
                         
# Customize the layout for better visibility
fig.update_traces(marker=dict(line=dict(width=1, color='DarkSlateGrey')), opacity=0.8)
fig.update_layout(bargap=0.2)

# Show the visualization to the user
show_to_user(fig)
```","The input code does not correctly adhere to the business request and reference implementation. While it identifies employees with salaries above the average and visualizes the salary distribution, it does so by using a SQL subquery to filter employees instead of calculating the average in Python. Moreover, the visualization approach for highlighting employees is different: it uses a scatter plot to overlay the highlighted employees instead of coloring the histogram bars directly, which changes the visual emphasis. Additionally, the code does not concatenate first and last names for hover data, which deviates from the reference's logic of displaying employee names in the visualization.",None
What is the total number of orders handled by each employee? Visualize the results in a bar chart for clearer comparison.,"```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user functions are defined elsewhere
def total_orders_by_employee():
    # SQL Query to get the total number of orders handled by each employee
    sql_query = """"""
    SELECT EmployeeID, COUNT(*) AS OrdersHandled
    FROM orders
    GROUP BY EmployeeID
    ORDER BY OrdersHandled DESC;
    """"""
    
    # Execute the SQL query and get the results in a pandas DataFrame
    df = execute_sql_query(sql_query)

    # Create a bar chart using Plotly
    fig = px.bar(
        df,
        x='EmployeeID',
        y='OrdersHandled',
        title='Total Number of Orders Handled by Each Employee',
        labels={'OrdersHandled': 'Total Orders'},
        template='plotly'
    )

    # Display the bar chart to the user
    show_to_user(fig)

# Assuming this function would be called in an appropriate context
total_orders_by_employee()
```","```python
import pandas as pd
import plotly.express as px

# SQL Query to count total orders handled by each employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY EmployeeID
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Create a bar chart to visualize the total number of orders handled by each employee
fig = px.bar(df_orders, x='EmployeeID', y='TotalOrders', title='Total Orders Handled by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalOrders': 'Total Orders'})

# Show the visualization to the user
show_to_user(fig)
```","The input code accurately follows the logic of the reference implementation, executing a SQL query to count orders grouped by EmployeeID and visualizing the results in a bar chart using Plotly. The minor differences in column naming ('OrdersHandled' vs 'TotalOrders') are inconsequential to the correctness of the solution, and the order clause is optional for correctness. Thus, the code fulfills the business analytics request as intended.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function behavior. In practice, this connects to a database.
    # Returns hypothetical data to simulate query execution
    return pd.DataFrame({
        'EmployeeID': [1, 2, 3],
        'NumberOfOrders': [150, 120, 100]
    })

# Show the output to the user
def show_to_user(data):
    # Simulated function behavior. In practice, it might render a DataFrame or display a visualization.
    print(data)

# Fetch the data
orders_df = execute_sql_query(sql_query)

# Create the bar chart
fig = px.bar(orders_df, x='EmployeeID', y='NumberOfOrders', 
             title='Total Number of Orders Handled by Each Employee',
             labels={'NumberOfOrders': 'Number of Orders', 'EmployeeID': 'Employee ID'})

# Show the bar chart to the user
show_to_user(fig)
```",The input code correctly executes the SQL query to aggregate the total number of orders per employee and uses the Plotly library to generate a bar chart visualizing this data. It adheres to the logic of the reference code by grouping and counting order data and displaying the results with similar labeling and ordering by the number of orders.,both
What are the names and unit prices of all products that are currently in stock? Include a bar chart to visualize the unit prices for comparison.,"```python
import plotly.express as px

# SQL query to fetch product names and unit prices for products in stock
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock > 0;""

# Execute the SQL query and store the result in a DataFrame
product_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the unit prices of products in stock
fig = px.bar(product_df, x='ProductName', y='UnitPrice', title='Unit Prices of Products in Stock', labels={'UnitPrice': 'Unit Price ($)', 'ProductName': 'Product Name'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
WHERE UnitsInStock > 0 AND Discontinued = 0
""""""

products_in_stock = execute_sql_query(sql_query)

fig = px.bar(products_in_stock, x='ProductName', y='UnitPrice', title='Unit Prices of Products in Stock')
show_to_user(fig)
```","The input code adds a condition where 'Discontinued = 0', which is not present in the reference implementation. Hence, it may exclude some products that are not necessarily out of stock, deviating from the reference logic.","```python
import plotly.express as px
import pandas as pd

# SQL query to retrieve names and unit prices of products currently in stock
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE UnitsInStock > 0;""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the unit prices
fig = px.bar(products_df, x='ProductName', y='UnitPrice', title=""Unit Prices of Products in Stock"")

# Display the bar chart
show_to_user(fig)
```","The input Python code is correct because it retrieves the same data as the reference implementation using the SQL query to get ProductName and UnitPrice for products in stock. It also uses Plotly Express to create and display a bar chart of unit prices. The differences, such as variable names and absence of custom labels, do not affect the logic or the functionality based on the given business analytics request.",Finetuned
"What is the on-time delivery rate per month, and can you provide a line chart to visualize the trends over time?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve data for on-time delivery rate per month
sql_query = """"""
SELECT 
    TO_CHAR(orders.OrderDate, 'YYYY-MM') AS Month, 
    COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY TO_CHAR(orders.OrderDate, 'YYYY-MM')
ORDER BY TO_CHAR(orders.OrderDate, 'YYYY-MM')
""""""

# Execute the SQL query using the provided utility function and get the result as a DataFrame
data = execute_sql_query(sql_query)

# Create a line chart to visualize the on-time delivery rate trends over time
fig = px.line(data, x='Month', y='OnTimeDeliveryRate', 
              title='On-Time Delivery Rate per Month',
              labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate', 'Month': 'Month'},
              markers=True)

# Display the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID) AS OnTimeDeliveryRate
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

on_time_delivery_df = execute_sql_query(sql_query)

fig = px.line(on_time_delivery_df, x='Month', y='OnTimeDeliveryRate', title='On-time Delivery Rate per Month')
show_to_user(fig)
```","The input code correctly evaluates the on-time delivery rate per month. It uses `DATE_FORMAT` for MySQL instead of `TO_CHAR`, adjusts column references accordingly, and correctly groups and orders by month. The plotting logic is equivalent, using `plotly.express` to create a line chart, similar to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', orders.OrderDate) AS Month, 
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query and get the results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is recognized as a datetime
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart using Plotly to visualize the on-time delivery rate trend over time
fig = px.line(df, x='Month', y='OnTimeDeliveryRate', title='On-Time Delivery Rate Per Month', 
              labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate', 'Month': 'Month'})

# Display the line chart to the user
show_to_user(fig)
```","Both implementations calculate the on-time delivery rate per month by dividing the number of orders shipped on or before the required date by the total number of orders for each month. The reference code uses PostgreSQL's `TO_CHAR()` function to format the date as 'YYYY-MM', while the input code uses `DATE_TRUNC('month', ...)` to group dates by month and later converts it to datetime format in pandas. This approach produces equivalent groupings. Finally, both codes use Plotly to create and display a line chart visualizing the trends over time. The logic and outcome of the input code align with the business request and the reference implementation.",both
"Which suppliers have the slowest lead times in the last year, and can this be visualized through a bar chart showing each supplier’s average lead time?","```python
import pandas as pd
import plotly.express as px

# SQL query as provided
sql_query = """"""
SELECT s.SupplierID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS avg_lead_time
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY s.SupplierID
ORDER BY avg_lead_time DESC
""""""

# Execute the query and get the data
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='SupplierID', y='avg_lead_time', 
             title='Average Lead Time by Supplier in 2022', 
             labels={'avg_lead_time': 'Average Lead Time (days)', 'SupplierID': 'Supplier ID'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_lead_time 
FROM orders 
JOIN products ON orders.OrderID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY suppliers.SupplierID 
ORDER BY average_lead_time DESC
""""""

lead_time_data = execute_sql_query(sql_query)

fig = px.bar(lead_time_data, x='CompanyName', y='average_lead_time', title='Average Supplier Lead Time in the Last Year', labels={'average_lead_time': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code potentially contains logic errors. The reference implementation uses a date range for 2022, while the input code uses a dynamic date range based on the current date without being constrained to '2022-01-01' to '2022-12-31'. Additionally, there are incorrect JOIN conditions. The input wrongly joins orders to products using OrderID instead of ProductID. These differences in logic can lead to incorrect results.","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    pass

# Function to display results (just a placeholder for this context)
def show_to_user(data):
    # Placeholder for display logic
    pass

# SQL query to get average lead time for each supplier in the last year
sql_query = """"""
SELECT 
    suppliers.SupplierID, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    suppliers ON products.SupplierID = suppliers.SupplierID 
WHERE 
    orders.OrderDate BETWEEN '2022-10-01' AND '2023-09-30' 
GROUP BY 
    suppliers.SupplierID 
ORDER BY 
    avg_lead_time ASC
""""""

# Execute the query and get results
df_suppliers = execute_sql_query(sql_query)

# Visualize using a bar chart
fig = px.bar(
    df_suppliers, 
    x='SupplierID', 
    y='avg_lead_time', 
    title='Average Lead Time for Suppliers (Last Year)',
    labels={'avg_lead_time': 'Average Lead Time (Days)', 'SupplierID': 'Supplier ID'}
)

# Show the plot using show_to_user function
show_to_user(fig)
```","The input Python code incorrectly defines the time period for the last year. The SQL query in the input code defines the date range from '2022-10-01' to '2023-09-30', whereas the request and the reference code focus on the calendar year 2022 ('2022-01-01' to '2022-12-31'). Additionally, the input code orders the result by 'avg_lead_time ASC', while the reference implementation orders by 'avg_lead_time DESC' to find suppliers with the slowest lead times.",None
"What was the average time taken to fulfill orders each month, and can this be visualized with a line chart to show trends over time?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the average fulfillment time per month
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Year, Month;
""""""

# Execute the SQL query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a new 'Year-Month' column for visualization
orders_df['Year-Month'] = orders_df.apply(lambda row: f""{int(row['Year'])}-{int(row['Month']):02d}"", axis=1)

# Sort the DataFrame by 'Year-Month'
orders_df.sort_values(by='Year-Month', inplace=True)

# Visualize using a line chart to show trends over time
fig = px.line(
    orders_df,
    x='Year-Month',
    y='AvgFulfillmentTime',
    title='Average Fulfillment Time per Month',
    labels={'AvgFulfillmentTime': 'Avg Fulfillment Time (days)'}
)

# Display the figure to the user
show_to_user(fig)```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

result_df = execute_sql_query(sql_query)

fig = px.line(result_df, x='OrderMonth', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Month')
show_to_user(fig)
```","The input Python code correctly calculates the average fulfillment time per month using similar logic as the reference implementation. It uses the DATE_FORMAT function to aggregate data by month and year, which is equivalent to using EXTRACT for year and month separately, then concatenating them. Both codes sort the data by the time period in ascending order for the visualization. The final visualization with a line chart is implemented using Plotly in both versions, effectively showing trends over time.","```python
import plotly.express as px
import pandas as pd

# Placeholder for execute_sql_query utility
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Function to interact with the database
    # Implementation will depend on database and configuration
    pass

# Placeholder for show_to_user utility
def show_to_user(data):
    # Function to display data or graph to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the average fulfillment time per month
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS order_month,
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfill_time
FROM orders
WHERE orders.ShippedDate IS NOT NULL
GROUP BY order_month
ORDER BY order_month;
""""""

# Execute SQL query and retrieve data
df = execute_sql_query(sql_query)

# Create a line chart to visualize average fulfillment time over months
fig = px.line(df, x='order_month', y='avg_fulfill_time',
              title='Average Fulfillment Time per Month',
              labels={'order_month': 'Order Month', 'avg_fulfill_time': 'Avg Fulfillment Time (days)'})

# Display the line chart
show_to_user(fig)
```","The input code correctly addresses the business analytics request by querying and calculating the average fulfillment time per month. It uses a similar logic to the reference implementation, with slight differences in SQL syntax due to database-specific functions. Both implementations group by year and month, compute the average fulfillment time, and visualize the trend using a line chart. These variations do not affect the correctness in terms of fulfilling the analytics request.",both
"  
""Calculate the total revenue generated by each product and create a bar chart to visualize the revenue distribution.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query is predefined
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Pseudo implementation; in practice, fetch from database
    pass

def show_to_user(data):
    # Pseudo implementation; in practice, this would handle different data types
    pass

# SQL query to calculate total revenue by product
sql_query = """"""
SELECT ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalRevenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY ProductName;
""""""

# Fetch the data using the utility function
revenue_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(revenue_data, 
             x='ProductName', 
             y='TotalRevenue', 
             title='Total Revenue by Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', title='Total Revenue by Product', labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product'})
show_to_user(fig)
```","The input code includes a discount factor '(1 - od.Discount)' in the revenue calculation, which is not present in the reference implementation. This results in a different logic for revenue calculation, making the input code incorrect according to the specified business analytics request and reference implementation.","
```python
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Should contain the implementation to execute the SQL query
    # and return the result as a pandas DataFrame
    pass

def show_to_user(data):
    # Should contain the implementation to display data
    # It can handle pandas DataFrame or a Plotly figure
    pass

# SQL query to get product revenue
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    p.ProductID, p.ProductName;
""""""

# Execute SQL query
df_revenue = execute_sql_query(sql_query)

# Create bar chart for revenue distribution
fig = px.bar(df_revenue, x='ProductName', y='TotalRevenue', 
             title='Total Revenue by Product',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})

# Show the plot
show_to_user(fig)
```

","The input code correctly calculates the total revenue by each product using an SQL query similar to the reference implementation. Both implementations join the 'products' and 'Order Details' tables, group by product, and sum up the product of 'Quantity' and 'UnitPrice' to calculate 'TotalRevenue'. The input code includes an additional 'ProductID' grouping which aligns with the need for unique product identifiers. It also uses Plotly to generate a bar chart and displays it using a utility function, maintaining the same logic and end goal as the reference code.",Finetuned
"What is the customer retention rate for Q2 2023, and can you provide a line graph to display retention trends over this period?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function, should connect to the database and execute the query
    # Returns a DataFrame of the query result
    pass

# Function to display graphs or data
def show_to_user(data):
    # Placeholder function to display data analysis or visualizations
    pass

# SQL Query to get retention rate for Q2 2023
sql_query = """"""
SELECT 
    (SELECT COUNT(DISTINCT orders.CustomerID) 
     FROM orders 
     WHERE orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30')::FLOAT / 
    (SELECT COUNT(DISTINCT orders.CustomerID) 
     FROM orders 
     WHERE orders.OrderDate < '2023-04-01') 
    AS retention_rate
""""""

# Execute the SQL query
retention_rate_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty and extract retention rate
if not retention_rate_df.empty:
    retention_rate = retention_rate_df.iloc[0]['retention_rate']
else:
    retention_rate = None

# Creating dummy data to illustrate the trend (for line graph)
# In a real scenario, you would pull historical data for each month in the quarter
data = {
    'Month': ['April 2023', 'May 2023', 'June 2023'],
    'RetentionRate': [0.85, 0.86, 0.87]  # Example data
}

trend_df = pd.DataFrame(data)

# Create a line graph to display retention trends over Q2 2023
fig = px.line(trend_df, x='Month', y='RetentionRate', title='Customer Retention Rate for Q2 2023')

# Use the show_to_user function to display the graph
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
WITH retained_customers AS (
    SELECT DISTINCT CustomerID
    FROM orders
    WHERE OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
),
total_customers AS (
    SELECT DISTINCT CustomerID
    FROM orders
    WHERE OrderDate < '2023-04-01'
)
SELECT 
    (SELECT COUNT(*) FROM retained_customers) * 1.0 / (SELECT COUNT(*) FROM total_customers) AS retention_rate
""""""

retention_data = execute_sql_query(sql_query)

sql_query_trends = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS month,
    COUNT(DISTINCT CustomerID) AS returning_customers
FROM orders
WHERE OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY month
ORDER BY month
""""""

retention_trends = execute_sql_query(sql_query_trends)

fig = px.line(retention_trends, x='month', y='returning_customers', title='Customer Retention Trends Q2 2023')
show_to_user(fig)

retention_data
```","The input code uses a different calculation logic for retention trends compared to the reference code. The reference code simulates a trend using fixed data, whereas the input code calculates returning customers per month without comparing to total customers from a prior period. The main retention rate calculation is similar, but it does not implement the necessary month-by-month comparison to correctly reflect a retention rate trend as per the request.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder to simulate SQL execution
    pass

def show_to_user(data):
    # Placeholder to simulate displaying data or figure
    pass

# SQL query to fetch the retention data
sql_query = """"""
SELECT
    CAST((COUNT(DISTINCT CASE WHEN o.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' THEN o.CustomerID END) * 1.0 /
    COUNT(DISTINCT CASE WHEN o.OrderDate < '2023-04-01' THEN o.CustomerID END) AS DECIMAL(10, 2)) AS Q2_2023_retention
FROM orders o
WHERE o.OrderDate BETWEEN '2023-04-01' AND '2023-06-30';
""""""

# Execute the SQL query and fetch data
retention_df = execute_sql_query(sql_query)

# Calculate trends for better visualization
dates = pd.date_range(start='2023-04-01', end='2023-06-30', freq='D')
retention_trend_df = pd.DataFrame({
    'date': dates,
    'retention_rate': [retention_df['Q2_2023_retention'].iloc[0]] * len(dates)
})

# Create a line graph using Plotly
fig = px.line(
    retention_trend_df,
    x='date',
    y='retention_rate',
    title='Customer Retention Rate Trend for Q2 2023',
    labels={'retention_rate': 'Retention Rate', 'date': 'Date'}
)

# Display the graph
show_to_user(fig)
```","The provided code calculates the retention based on customers within the Q2 period alone, instead of comparing the Q2 customers with the entire pre-Q2 customers, which is necessary for retention calculation. The reference implementation correctly calculates retention by comparing customers who placed orders in Q2 against those who had placed orders previously. Additionally, the trend data is not appropriately handled; the example code misrepresents retention rate trends by duplicating a single retention rate value for a range of dates, which does not reflect actual changes over time.",None
"Which products have never been ordered, and how can this be visualized to highlight these products?","```python
import pandas as pd
import plotly.express as px

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Replace with actual SQL execution logic
    return pd.DataFrame({
        'ProductID': [1, 2, 3],
        'ProductName': ['Product A', 'Product B', 'Product C']
    })

def show_to_user(data):
    # Placeholder function: Implement displaying logic using console or GUI
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        # Assuming data is a plotly figure
        data.show()

# SQL query to find products never ordered
sql_query = """"""
SELECT
    p.ProductID,
    p.ProductName
FROM
    products p
LEFT JOIN
    [Order Details] od ON p.ProductID = od.ProductID
WHERE
    od.OrderID IS NULL;
""""""

# Execute the SQL query
df_never_ordered = execute_sql_query(sql_query)

# Display the DataFrame to the user
show_to_user(df_never_ordered)

# Visualize the products that have never been ordered
fig = px.bar(df_never_ordered, x='ProductName', y='ProductID',
             title='Products Never Ordered',
             labels={'ProductID': 'Product ID', 'ProductName': 'Product Name'})

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL
""""""

never_ordered_products = execute_sql_query(sql_query)

# Visualization
fig = px.bar(never_ordered_products, x='ProductName', y='ProductID', title='Products That Have Never Been Ordered', labels={'ProductID': 'Product ID', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code has a logical error in the SQL query condition. The reference implementation uses 'WHERE od.OrderID IS NULL' to find products never ordered, which correctly checks if any order exists for each product. The input code uses 'WHERE od.ProductID IS NULL', which could lead to incorrect results if the ProductID is null in the 'Order Details' table. The logic for determining products never ordered is not equivalent to the reference.","```python
import plotly.express as px

# Assume execute_sql_query is a defined utility function
def execute_sql_query(sql_query: str):
    # This function would contain the details to connect to the database and execute the SQL query.
    # Here, it returns a mock dataframe assuming the query was executed successfully.
    import pandas as pd
    return pd.DataFrame({'ProductID': [101, 102, 103], 'ProductName': ['Product A', 'Product B', 'Product C']})

def show_to_user(data):
    # This function would handle displaying inputs if they are dataframes or figures.
    if hasattr(data, 'show'):
        data.show()  # If it's a Plotly figure
    else:
        print(data)  # For pandas DataFrame

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL;
""""""

# Execute the SQL query to get the results
unordered_products_df = execute_sql_query(sql_query)

# Visualize unordered products using a bar chart
fig = px.bar(unordered_products_df, x='ProductName', y='ProductID',
             title='Products Never Ordered',
             labels={'ProductName': 'Product Name', 'ProductID': 'Product ID'})

# Show the visualization to the user
show_to_user(fig)
```","The provided code fulfills the same business requirement as the reference code: identifying and visualizing products that have never been ordered. Both implementations join the 'products' table with the 'Order Details' table using a LEFT JOIN to find unmatched rows, indicating products with no orders. While the details of the SQL queries differ slightly ('od.ProductID IS NULL' vs. 'od.OrderID IS NULL'), the logic is equivalent in context as both achieve the intention to find non-ordered products. The visualizations use Plotly to create bar charts that the user can view, fulfilling the request requirements.",Finetuned
Identify customers with orders shipped within 7 days of the order date and provide a visualization of the distribution of these shipping times.,"```python
import pandas as pd
import plotly.express as px

# Given utility functions (assumed to be implemented elsewhere)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for query execution
    pass

def show_to_user(data):
    # Placeholder for showing data or plots
    pass

# SQL Query to execute
sql_query = """"""
SELECT c.CustomerID, o.OrderID, DATEDIFF(o.ShippedDate, o.OrderDate) AS ShippingTime
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE DATEDIFF(o.ShippedDate, o.OrderDate) <= 7;
""""""

# Execute SQL query and get data as pandas DataFrame
df_orders = execute_sql_query(sql_query)

# Visualizing the distribution of shipping times
fig = px.histogram(df_orders, x='ShippingTime', nbins=8, title='Distribution of Shipping Times Within 7 Days')
fig.update_xaxes(title='Shipping Time (days)')
fig.update_yaxes(title='Count of Orders')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderID, 
    CustomerID, 
    OrderDate, 
    ShippedDate, 
    DATEDIFF(ShippedDate, OrderDate) AS ShippingDays
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL 
    AND DATEDIFF(ShippedDate, OrderDate) <= 7
""""""

shipping_data = execute_sql_query(sql_query)

fig = px.histogram(shipping_data, x='ShippingDays', nbins=8, title='Distribution of Shipping Times (<= 7 Days)')
show_to_user(fig)
```","The input Python code correctly implements the intended functionality. It retrieves data on orders shipped within 7 days using a SQL query, just like the reference implementation. Both queries filter on the difference between ShippedDate and OrderDate being less than or equal to 7. The visualization logic is also similar, using a histogram to display the distribution of shipping times. Any differences in column naming ('ShippingTime' vs 'ShippingDays') or slight SQL structure variations don't affect the correctness of the logic as per the original business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to find customers with orders shipped within 7 days of order date
sql_query = """"""
SELECT CustomerID FROM orders WHERE DATEDIFF(ShippedDate, OrderDate) <= 7;
""""""

# Execute the SQL query
customer_data_df = execute_sql_query(sql_query)

# Identify the shipping times for these customers
shipping_time_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS ShippingTime
FROM orders
WHERE DATEDIFF(ShippedDate, OrderDate) <= 7;
""""""

# Execute the query to get shipping times
shipping_time_df = execute_sql_query(shipping_time_query)

# Visualize the distribution of these shipping times
fig = px.histogram(shipping_time_df, x=""ShippingTime"", title=""Distribution of Shipping Times Within 7 Days"")
show_to_user(fig)
```","The input code does not fully align with the reference implementation or the business analytics request. The input code retrieves only the CustomerID from the 'orders' table and not the CustomerID, OrderID, and ShippingTime as in the reference implementation. Additionally, two separate SQL queries are used in the input code instead of one, missing the need to join 'customers' and 'orders' to get the complete intended output. Also, the input code does not necessarily ensure that CustomerID is fetched along with shipping times needed for more comprehensive analysis. The visualization part is correctly implemented in both codes.",Base
What are the top 3 shipping addresses based on frequency of deliveries? Include a bar chart to visualize the frequency of deliveries per address.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipAddress, COUNT(*) AS DeliveryCount 
FROM orders 
GROUP BY ShipAddress 
ORDER BY DeliveryCount DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
result_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the frequency of deliveries per address
fig = px.bar(result_df, x='ShipAddress', y='DeliveryCount', title='Top 3 Shipping Addresses by Delivery Frequency')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipAddress, COUNT(OrderID) AS DeliveryCount
FROM orders
GROUP BY ShipAddress
ORDER BY DeliveryCount DESC
LIMIT 3;
""""""

top_addresses = execute_sql_query(sql_query)

fig = px.bar(top_addresses, x='ShipAddress', y='DeliveryCount', title='Top 3 Shipping Addresses by Delivery Frequency')
show_to_user(fig)
```","The input code correctly implements the logic described in the business request and matches the logic of the reference implementation. Both use a SQL query to count and group by 'ShipAddress', then sort the results by delivery count in descending order, and limit the result to the top 3 addresses. Additionally, both create a bar chart using Plotly to visualize the delivery frequency per address. The counting mechanism (`COUNT(*)` vs `COUNT(OrderID)`) achieves the same outcome as 'OrderID' is assumed to be present in every order entry, thus it correctly counts the deliveries.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration; replace with actual SQL execution logic.
    data = {
        ""ShipAddress"": [""Address 1"", ""Address 2"", ""Address 3"", ""Address 4"", ""Address 5""],
        ""Frequency"": [10, 8, 5, 3, 2]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock implementation to display data; replace with actual visualization logic if needed.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the top 3 shipping addresses
sql_query = """"""
SELECT ShipAddress, COUNT(OrderID) AS Frequency 
FROM orders 
GROUP BY ShipAddress 
ORDER BY Frequency DESC 
LIMIT 3
""""""

# Execute the SQL query and fetch results
top_addresses_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(top_addresses_df, x='ShipAddress', y='Frequency', 
             title='Top 3 Shipping Addresses by Frequency of Deliveries',
             labels={'ShipAddress': 'Shipping Address', 'Frequency': 'Number of Deliveries'})

# Display the result
show_to_user(fig)
```","The input Python code correctly implements the logic to fetch and visualize the top 3 shipping addresses based on delivery frequency. The SQL query aligns with the reference by selecting ShipAddress and counting orders grouped and sorted in descending order of frequency. The code then visualizes the result using a bar chart, similar to the reference implementation, fulfilling the business analytics request.",both
How many products from each supplier are on order? Include a bar chart to visualize the distribution.,"
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT p.SupplierID, COUNT(*) AS ProductsOnOrder 
FROM products p 
WHERE p.UnitsOnOrder > 0 
GROUP BY p.SupplierID;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of products on order by supplier
fig = px.bar(df, x='SupplierID', y='ProductsOnOrder', 
             title='Number of Products on Order by Supplier',
             labels={'SupplierID': 'Supplier ID', 'ProductsOnOrder': 'Products on Order'})

# Show the visualization to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, COUNT(p.ProductID) AS ProductsOnOrder
FROM products p
WHERE p.UnitsOnOrder > 0
GROUP BY p.SupplierID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='SupplierID', y='ProductsOnOrder', title='Products on Order per Supplier', labels={'SupplierID': 'Supplier ID', 'ProductsOnOrder': 'Number of Products On Order'})
show_to_user(fig)
```","The input Python code correctly implements the business request. It uses a SQL query to count the number of products on order for each supplier, checking for UnitsOnOrder greater than zero, and groups by SupplierID, similar to the reference implementation. The code then visualizes this data using a bar chart. Key components like executing the query, data grouping, filtering, and visualization match the logic of the reference implementation, despite slight differences in code structure and labeling.","```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = ""SELECT s.SupplierID, COUNT(p.ProductID) as OrderedProducts FROM products p JOIN suppliers s ON p.SupplierID = s.SupplierID WHERE p.UnitsOnOrder > 0 GROUP BY s.SupplierID;""

# Function to fetch data from the database
def execute_sql_query(sql_query: str):
    # This function should connect to the database, execute the query, and return a DataFrame
    # Placeholder code simulating database interaction
    # In practice, this code should contain the logic to connect to your database and fetch query results
    data = {
        'SupplierID': [1, 2, 3],
        'OrderedProducts': [10, 5, 8]
    }
    return pd.DataFrame(data)

# Fetch data using the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution
fig = px.bar(df, x='SupplierID', y='OrderedProducts', title='Number of Products on Order by Supplier', labels={'OrderedProducts': 'Ordered Products'})

# Function to display the data or figure to the user
def show_to_user(data):
    # Display data using pandas DataFrame or Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Display the bar chart
show_to_user(fig)
```","The input code correctly executes an SQL query to determine the number of products on order for each supplier, similar to the reference. It uses a join operation (though not strictly necessary since it could be simplified like the reference), applies the condition of 'UnitsOnOrder > 0', and groups by SupplierID to count products. The resultant DataFrame structure matches the expected output, and a bar chart is generated using Plotly, appropriately labeled and titled, aligning with the reference implementation.",both
"Identify the top 5 best-selling products based on order quantity, and provide a bar chart to visualize the results.","```python
import plotly.express as px

# SQL Query: This is the given query to get the top 5 best-selling products.
sql_query = """"""
SELECT ProductID, ProductName, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY ProductID, ProductName 
ORDER BY TotalQuantity DESC 
LIMIT 5;
""""""

# Execute the SQL query and store the result in a DataFrame.
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 5 best-selling products.
fig = px.bar(result_df, 
             x='ProductName', 
             y='TotalQuantity', 
             title='Top 5 Best-Selling Products',
             labels={'TotalQuantity': 'Total Quantity Sold', 'ProductName': 'Product Name'},
             color='TotalQuantity')

# Display the bar chart to the user.
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 5
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalQuantity', title='Top 5 Best-Selling Products by Order Quantity')
show_to_user(fig)
```","The provided Python code follows the same logic as the reference implementation. It performs a SQL query to select the ProductName and the sum of Quantity from the 'products' and 'Order Details' tables, grouping by ProductName, ordering by TotalQuantity in descending order, and limiting the results to 5, which matches the business analytics request. The resulting data is visualized using a bar chart with Plotly, just like the reference code.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    products.ProductName, 
    SUM([Order Details].Quantity) AS total_quantity 
FROM 
    [Order Details] 
JOIN 
    products 
ON 
    [Order Details].ProductID = products.ProductID 
GROUP BY 
    products.ProductName 
ORDER BY 
    total_quantity DESC 
LIMIT 5;
""""""

# Execute the SQL query and return a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df, 
    x='ProductName', 
    y='total_quantity', 
    title='Top 5 Best-Selling Products',
    labels={'total_quantity': 'Total Quantity', 'ProductName': 'Product Name'},
    text='total_quantity'
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to fetch the top 5 best-selling products based on order quantity. It joins 'Order Details' with 'products', groups by 'ProductName', and orders by 'total_quantity' in descending order, limiting the results to 5. The use of Plotly to create and display a bar chart is consistent with the reference implementation. The logic is equivalent to the reference code even though the SQL query in the input defines the alias for total quantity differently.",both
"Identify the least sold product and the number of units sold, and visualize the sales data to highlight the comparison among products.","```python
import plotly.express as px
import pandas as pd

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the SQL query and return a pandas DataFrame
    raise NotImplementedError(""To be implemented: execute SQL and return DataFrame"")

def show_to_user(data):
    # This function should display the given data.
    # It can be a DataFrame or a Plotly Figure.
    if isinstance(data, pd.DataFrame):
        print(data)  # Or use other methods to show data
    else:
        data.show()  # Plotly figure

# SQL query to identify the least sold product
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID 
ORDER BY TotalSold ASC;
""""""

# Execute SQL query
sales_data_df = execute_sql_query(sql_query)

# Identify the least sold product
least_sold_product_df = sales_data_df.head(1)

# Show least sold product details to the user
show_to_user(least_sold_product_df)

# Visualize sales data to highlight comparison among products
fig = px.bar(sales_data_df, x='ProductName', y='TotalSold',
             title='Product Sales Comparison',
             labels={'TotalSold': 'Units Sold', 'ProductName': 'Product'},
             template='plotly')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalUnitsSold ASC
LIMIT 1
""""""

least_sold_product = execute_sql_query(sql_query)

sql_query_sales_data = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
""""""

sales_data = execute_sql_query(sql_query_sales_data)

fig = px.bar(sales_data, x='ProductName', y='TotalUnitsSold', title='Sales Comparison Among Products', labels={'TotalUnitsSold': 'Units Sold', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code and the reference code both correctly identify the least sold product by summing the quantities and ordering in ascending order to get the least units sold. The input code also visualizes the sales data similarly with a bar chart for comparison among products. The logic aligns with the reference implementation, covering both data extraction and visualization requirements effectively.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the least sold product and its sales data
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS units_sold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY SUM(od.Quantity) ASC
LIMIT 1;
""""""

# Execute the query using the utility function provided to us
least_sold_product_df = execute_sql_query(sql_query)

# SQL query to get all products' sales data
all_products_sales_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS units_sold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName;
""""""

# Execute the query to get all products' sales
all_products_sales_df = execute_sql_query(all_products_sales_query)

# Visualizing the sales data
fig = px.bar(
    all_products_sales_df,
    x='ProductName',
    y='units_sold',
    title='Units Sold by Product',
    labels={'units_sold': 'Units Sold', 'ProductName': 'Product Name'}
)

# Highlight the least sold product
least_sold_product_name = least_sold_product_df['ProductName'].iloc[0]
least_sold_product_units = least_sold_product_df['units_sold'].iloc[0]

fig.update_traces(
    marker_color='blue'
)
# Highlight the least sold product in red
fig.add_bar(
    x=[least_sold_product_name],
    y=[least_sold_product_units],
    marker_color='red'
)

# Display the figure
show_to_user(fig)
```","The provided input code fulfills the business analytics request by correctly identifying the least sold product and visualizing the sales data for comparison among products. It uses similar logic to the reference code by executing SQL queries to get both the least sold product and all products' sales data. It then visualizes the data using Plotly, highlighting the least sold product in red, which aligns with the intended analysis despite differences in implementation details.",both
Which employee generated the most sales revenue in 2023? Include a bar chart to compare each employee's sales revenue.,"import pandas as pd
import plotly.express as px

def get_top_employee_sales():
    # Define the SQL query to fetch sales revenue by employee for 2023
    sql_query = '''
    SELECT employees.EmployeeID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    JOIN employees ON orders.EmployeeID = employees.EmployeeID 
    WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
    GROUP BY employees.EmployeeID 
    ORDER BY employee_sales DESC
    '''
    
    # Execute the SQL query and get the results in a DataFrame
    sales_data = execute_sql_query(sql_query)
    
    # Generate a bar chart for sales data
    fig = px.bar(sales_data, 
                 x='EmployeeID', 
                 y='employee_sales', 
                 title='Sales Revenue by Employee for 2023',
                 labels={'employee_sales': 'Sales Revenue', 'EmployeeID': 'Employee ID'},
                 text_auto=True)
    
    # Display the plot to user
    show_to_user(fig)

# Call the function
get_top_employee_sales()","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total sales per employee for the year 2023
sql_query = """"""
SELECT employees.EmployeeID, 
       employees.FirstName, 
       employees.LastName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
""""""

# Execute the SQL query and get the data
employee_sales = execute_sql_query(sql_query)

# Identify the employee with the highest sales
top_employee = employee_sales.loc[employee_sales['total_sales'].idxmax()]

# Create a bar chart to compare sales revenue of each employee
fig = px.bar(employee_sales, 
             x='FirstName' + ' ' + 'LastName', 
             y='total_sales', 
             title='Sales Revenue by Employee in 2023', 
             labels={'x': 'Employee', 'total_sales': 'Total Sales'},
             text='total_sales')

# Show the top employee and the bar chart
show_to_user(employee_sales)
show_to_user(fig)
```","The input code is not correct because it has several issues: 
1. The 'x' parameter for the bar chart should concatenate 'FirstName' and 'LastName' using a Pandas operation, but it's written incorrectly in 'x='FirstName' + ' ' + 'LastName','.
2. The bar chart's label for the x-axis is incorrect as it uses 'x' instead of 'FirstName' or concatenated names.
3. The function 'show_to_user(employee_sales)' seems incorrect as it should not display a DataFrame meant only to identify the top employee, which is not needed for output as per the task description.
The logic for calculating sales revenue and identifying the top employee is generally correct, but these issues mean the code doesn't fully align with the requirements or the reference implementation.","Sure, here's the Python code:

```python
import pandas as pd
import plotly.express as px

# SQL query to get sales data by employee for 2023
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC
""""""

# Get the data from the utility function
sales_data_df = execute_sql_query(sql_query)

# Display the employee with the highest sales
top_employee_df = sales_data_df.head(1)
show_to_user(top_employee_df)

# Create a bar chart to compare each employee's sales revenue
fig = px.bar(sales_data_df, 
             x='EmployeeID', 
             y='total_sales', 
             title='Employee Sales Revenue in 2023',
             labels={'total_sales': 'Total Sales Revenue'},
             template='plotly')

# Show the bar chart using the utility function
show_to_user(fig)
```

### Explanation:
1. **SQL Query**: The query fetches the total sales for each employee in 2023, calculating sales as Unit Price multiplied by Quantity after applying the discount. Results are grouped by `EmployeeID` and ordered by `total_sales` in descending order.
2. **Data Extraction**: Implements `execute_sql_query` to run the SQL and store results in a DataFrame.
3. **Top Employee Display**: Uses `pandas.DataFrame.head(1)` to select the top employee and displays it to the user.
4. **Visualization**: Utilizes Plotly's `px.bar` function to create a bar chart of total sales revenue per employee.
5. **Results Display**: Finally, shows both the DataFrame and the bar chart using the predefined utility function `show_to_user`.

Ensure that the utility functions `execute_sql_query` and `show_to_user` are implemented in your environment as described for this code to work seamlessly.","The provided code accurately implements the business request following the reference logic. Both codes execute an SQL query to fetch total sales for each employee in 2023, calculate the sales correctly using Unit Price, Quantity, and Discount, and sort the results by descending sales. The top employee is displayed, and a bar chart of sales revenue is generated. Key functions, `execute_sql_query()` and `show_to_user()`, are used similarly to extract data and present results. Minor differences, like variable names and exact chart parameters, do not affect overall correctness or logic.",Finetuned
Determine the average discount given to products per month and visualize the trends using a line chart.,"
import pandas as pd
import plotly.express as px

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented elsewhere
    pass

# Function to display result to the user
def show_to_user(data):
    # This function is assumed to be implemented elsewhere
    pass

# SQL query to fetch average discount per month
sql_query = """"""
SELECT MONTH(OrderDate) AS Month, AVG(Discount) AS AvgDiscount 
FROM [Order Details] 
GROUP BY MONTH(OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(df, x='Month', y='AvgDiscount', title='Average Discount per Month',
              labels={'AvgDiscount': 'Average Discount', 'Month': 'Month'})

# Display the line chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(od.OrderDate, '%Y-%m') AS Month, 
    AVG(od.Discount) AS AverageDiscount
FROM 
    [Order Details] od
JOIN 
    Orders o ON od.OrderID = o.OrderID
GROUP BY 
    Month
ORDER BY 
    Month
""""""

average_discount_df = execute_sql_query(sql_query)
fig = px.line(average_discount_df, x='Month', y='AverageDiscount', title='Average Discount Given to Products Per Month')
show_to_user(fig)
```","The input code uses DATE_FORMAT to group by months instead of MONTH function, which can affect the grouping if there's a difference in data storage format. It also includes a JOIN, which may introduce discrepancies if the Orders table is needed for the desired result but isn't considered in the reference. Additionally, the input orders the results by month, which isn't in the reference but is generally good practice for visualization. However, the logic might differ due to joining another table not present in the reference query.","```python
import pandas as pd
import plotly.express as px

# Define SQL query to fetch the average discount per product per month
sql_query = """"""
    SELECT
        DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
        AVG(Discount) AS AverageDiscount
    FROM
        [Order Details]
    GROUP BY
        DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query using the utility function provided
average_discount_df = execute_sql_query(sql_query)

# Generate a line chart to visualize the trend of average discount per month
fig = px.line(
    average_discount_df,
    x='Month',
    y='AverageDiscount',
    title='Average Discount Given to Products Per Month',
    labels={'AverageDiscount': 'Average Discount', 'Month': 'Month'}
)

# Display the visualization using the provided utility function
show_to_user(fig)
```","The provided Python code calculates the average discount per product per month in a 'YYYY-MM' format, while the reference implementation computes the average discount grouped by month only. This discrepancy in SQL query aggregation results in different outputs; hence, the input code does not adhere to the same logic as the reference implementation.",None
"What is the total value of current inventory for each supplier, and can this be visualized with a bar chart?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SupplierID, SUM(UnitsInStock * UnitPrice) AS InventoryValue 
FROM products 
GROUP BY SupplierID;
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='InventoryValue', title='Total Inventory Value by Supplier')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT SupplierID, SUM(UnitsInStock * UnitPrice) AS TotalInventoryValue
FROM products
GROUP BY SupplierID
""""""

inventory_data = execute_sql_query(sql_query)

fig = px.bar(inventory_data, x='SupplierID', y='TotalInventoryValue', title='Total Inventory Value by Supplier')
show_to_user(fig)
```","The input code correctly answers the business analytics request and follows the same logic as the reference implementation. It selects the total inventory value per supplier using the same SQL query logic, groups results by SupplierID, and uses Plotly to visualize the data as a bar chart. The variable names and column labels, although slightly different, do not affect the correctness of the solution.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the total value of current inventory for each supplier
sql_query = """"""
SELECT p.SupplierID, 
       SUM((p.UnitPrice * p.UnitsInStock) + (p.UnitsOnOrder * p.UnitPrice * 0.5)) AS InventoryValue 
FROM products p 
GROUP BY p.SupplierID;
""""""

# Execute the SQL query using the utility function provided
inventory_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the inventory value for each supplier
fig = px.bar(inventory_df, x='SupplierID', y='InventoryValue', 
             title='Total Inventory Value by Supplier',
             labels={'InventoryValue': 'Inventory Value', 'SupplierID': 'Supplier ID'})

# Show the bar chart using the utility function
show_to_user(fig)
```","The input code calculates the inventory value differently by including 'UnitsOnOrder' with a weight of 0.5. This deviates from the reference implementation, which only considers 'UnitsInStock' multiplied by 'UnitPrice'. This difference in logic means the input code does not accurately reflect the reference implementation's approach to computing inventory value.",Base
"List all customers who placed orders in the first quarter of 2023, and provide a visualization of order frequency by month.","```python
import pandas as pd
import plotly.express as px

# SQL query to get all customers who placed orders in Q1 2023
sql_query = """"""
SELECT DISTINCT customers.CustomerID 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31';
""""""

# Execute SQL query to get customers
customers_df = execute_sql_query(sql_query)

# Another SQL query to get order frequency by month for Q1 2023
order_frequency_query = """"""
SELECT 
    EXTRACT(MONTH FROM orders.OrderDate) AS Month, 
    COUNT(orders.OrderID) AS OrderFrequency 
FROM orders 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31' 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute SQL query to get order frequencies
order_frequency_df = execute_sql_query(order_frequency_query)

# Visualization: Order frequency by month using Plotly
fig = px.bar(order_frequency_df, x='Month', y='OrderFrequency',
             title='Order Frequency by Month for Q1 2023',
             labels={'OrderFrequency': 'Number of Orders', 'Month': 'Month (1 - Jan, 2 - Feb, 3 - Mar)'})

# Show result
show_to_user(customers_df)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query_customers = """"""
SELECT DISTINCT c.CustomerID, c.CompanyName, c.ContactName
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

customers_df = execute_sql_query(sql_query_customers)

sql_query_frequency = """"""
SELECT DATE_TRUNC('month', OrderDate) AS OrderMonth, COUNT(*) AS OrderCount
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY OrderMonth
ORDER BY OrderMonth
""""""

frequency_df = execute_sql_query(sql_query_frequency)

fig = px.line(frequency_df, x='OrderMonth', y='OrderCount', title='Order Frequency by Month (Q1 2023)', labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'})
show_to_user(fig)

show_to_user(customers_df)
```","The input code correctly retrieves all customers who placed orders in Q1 2023 by joining the customers and orders tables, ensuring the orders fall within the specified date range. Additionally, it calculates the order frequency by month using the DATE_TRUNC function, which groups data by month in the same way as the reference code. The input code opts for a line chart instead of a bar chart for visualization, but this difference in visualization type does not impact the correctness of the analysis logic. Thus, the input code adheres to the logic and requirements of the business analytics request as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Simulated utility functions:
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function mocks the execution of an SQL query and returns a DataFrame.
    # In real usage, this function would connect to a database and fetch data.
    data = {
        'CustomerID': [1, 2, 3],
        'OrderDate': ['2023-01-15', '2023-02-20', '2023-03-10']
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This function displays data or visualizations.
    # In practice, it would handle displaying to console, GUI, or web.
    print(data)

# Execute the SQL Query
sql_query = ""SELECT * FROM orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31';""
orders_df = execute_sql_query(sql_query)

# List unique CustomerIDs who placed orders
customers_df = orders_df[['CustomerID']].drop_duplicates()
show_to_user(customers_df)

# Convert OrderDate to datetime
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])

# Aggregate order frequency by month
orders_df['OrderMonth'] = orders_df['OrderDate'].dt.to_period('M')
order_frequency = orders_df.groupby('OrderMonth').size().reset_index(name='Frequency')

# Create a line plot of order frequency by month using Plotly
fig = px.line(order_frequency, x='OrderMonth', y='Frequency', title='Order Frequency by Month',
              labels={'OrderMonth': 'Month', 'Frequency': 'Number of Orders'})

# Display the figure
show_to_user(fig)
```","The input code differs from the reference implementation in a few key points: 1) The reference code explicitly extracts and groups data by month using SQL, while the input code aggregates month data using Pandas after obtaining all the order records. 2) The input code uses a line plot for visualization instead of a bar plot, which does not align with the intent of displaying discrete monthly frequencies. 3) The input code does not filter the initial customer results precisely as the reference does with DISTINCT on 'CustomerID'. These differences imply that the input does not fully adhere to the same logic specified in the reference.",Base
What is the average freight cost of all orders? Please provide a visualization to display the distribution of freight costs.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get freight costs
sql_query = ""SELECT o.Freight FROM orders o;""

# Execute the SQL query to get a DataFrame
df = execute_sql_query(sql_query)

# Calculate the average freight cost
avg_freight_cost = df['Freight'].mean()

# Print the average freight cost
print(f""Average Freight Cost: {avg_freight_cost}"")

# Create a visualization to display the distribution of freight costs
fig = px.histogram(df, x='Freight', title='Distribution of Freight Costs', nbins=30)

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Freight FROM orders""
freight_data = execute_sql_query(sql_query)

average_freight = freight_data['Freight'].mean()

fig = px.histogram(freight_data, x='Freight', title='Distribution of Freight Costs')
show_to_user(fig)

average_freight
```","The input code correctly retrieves the freight costs using an SQL query, calculates the average using the mean function, and visualizes the distribution of freight costs with a histogram. It adheres to the same logic as the reference implementation, despite minor differences in variable names and print statements.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average freight cost and fetch all freight cost data
sql_query = ""SELECT Freight FROM orders;""

# Execute the SQL query and fetch the freight cost data
orders_df = execute_sql_query(sql_query)

# Calculate the average freight cost
average_freight_cost = orders_df['Freight'].mean()

# Prepare the result as a DataFrame
average_freight_df = pd.DataFrame({'AverageFreightCost': [average_freight_cost]})

# Display the average freight cost
show_to_user(average_freight_df)

# Create a histogram to display the distribution of freight costs using Plotly
fig = px.histogram(orders_df, x='Freight', title='Distribution of Freight Costs')

# Display the histogram using the utility function
show_to_user(fig)
```","The input code accurately retrieves the freight costs using the SQL query, calculates the average freight cost, and displays it. It also correctly visualizes the distribution of freight costs with a histogram using the Plotly library. Although there are differences in printing the average cost, such as displaying the result in a DataFrame, the primary logic aligns with the reference implementation.",both
"What is the total freight cost for orders handled by each employee, and can this be visualized in a bar chart to show the comparison across employees?","
```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM(orders.Freight) AS TotalFreight 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='TotalFreight', 
             labels={'TotalFreight':'Total Freight Cost', 'EmployeeID':'Employee ID'},
             title='Total Freight Cost by Employee')

# Show the graph to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, SUM(o.Freight) AS TotalFreight
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY TotalFreight DESC
""""""

freight_data = execute_sql_query(sql_query)
fig = px.bar(freight_data, x='EmployeeName', y='TotalFreight', title='Total Freight Cost by Employee', labels={'TotalFreight': 'Total Freight Cost', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code correctly calculates the total freight cost for each employee and visualizes it in a bar chart, similar to the reference code. The input code adds an improvement by including the employee's name, allowing a more detailed visualization. Both codes group the data by EmployeeID and sum the Freight, executing the necessary SQL query to obtain the data and using Plotly to create a bar chart. The core request of showing comparative bar charts of freight costs per employee is met.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to execute the given SQL query and return a DataFrame.
    # Implement the actual database connection and query execution logic here.
    pass

def show_to_user(data):
    # This function is assumed to display the data, either as a DataFrame or a Plotly figure.
    pass

# SQL query to retrieve total freight cost by employee
sql_query = """"""
SELECT employees.EmployeeID, SUM(orders.Freight) AS TotalFreight 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to visualize the total freight cost for each employee
fig = px.bar(df, x='EmployeeID', y='TotalFreight', 
             title='Total Freight Cost by Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalFreight': 'Total Freight Cost'},
             text='TotalFreight')

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It constructs the appropriate SQL query to calculate the total freight cost per employee by joining the 'employees' and 'orders' tables on the EmployeeID and aggregating the Freight values. The code uses Plotly to create a bar chart to visualize these totals, similar to the reference implementation. Minor differences such as adding the 'text' parameter for displaying freight values on the bars do not affect the functionality or correctness of the analysis and visualization.",both
Determine the monthly trend of quantities sold for each product using appropriate data visualizations.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the monthly trend of quantities sold for each product
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month,
    p.ProductName,
    SUM(od.Quantity) AS MonthlyQuantity 
FROM 
    [Order Details] od 
JOIN 
    products p 
ON 
    od.ProductID = p.ProductID 
GROUP BY 
    DATE_TRUNC('month', OrderDate), 
    p.ProductName;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
data = execute_sql_query(sql_query)

# Convert 'Month' to datetime format for proper plotting
data['Month'] = pd.to_datetime(data['Month'])

# Create a Plotly line plot to visualize the monthly trend of quantities sold for each product
fig = px.line(
    data,
    x='Month',
    y='MonthlyQuantity',
    color='ProductName',
    title='Monthly Trend of Quantities Sold per Product',
    labels={'MonthlyQuantity': 'Quantity Sold', 'Month': 'Month'}
)

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve monthly quantities sold for each product
sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.Quantity) AS TotalQuantitySold
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, p.ProductName, Month
ORDER BY 
    Month, p.ProductID
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a line plot for the monthly trend of quantities sold for each product
fig = px.line(data, x='Month', y='TotalQuantitySold', color='ProductName', 
              title='Monthly Trend of Quantities Sold for Each Product',
              labels={'TotalQuantitySold': 'Quantity Sold', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly retrieves the monthly quantities sold for each product and creates an appropriate visualization. The SQL query accurately joins the 'products', 'Order Details', and 'orders' tables to get the necessary data and groups it by product and month. The plotly express line plot uses the data correctly to visualize the monthly trend for each product, adhering to the request's intent and logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation - replace with actual database query execution
    data = {
        'ProductID': [1, 1, 2, 2],
        'Month': [1, 2, 1, 2],
        'Quantity': [100, 150, 200, 250]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This function should display the data or visualization but is a placeholder here.
    pass

# SQL Query
sql_query = """"""
SELECT p.ProductID, MONTH(o.OrderDate) AS Month, SUM(od.Quantity) AS Quantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY p.ProductID, MONTH(o.OrderDate);
""""""

# Execute SQL query and get data
df = execute_sql_query(sql_query)

# Create a line plot to visualize the monthly trend of quantities sold for each product
fig = px.line(df, x='Month', y='Quantity', color='ProductID', 
              title='Monthly Trend of Quantities Sold for Each Product',
              labels={'Quantity':'Total Quantity Sold', 'Month':'Month', 'ProductID':'Product ID'})

# Show the plot to the user
show_to_user(fig)
```","The input code is incorrect as it differs from the reference code in several important aspects. First, the input code does not correctly convert 'Month' to the DateTime format needed for proper plotting. Second, it uses 'ProductID' for the color parameter instead of 'ProductName', which means product names are not visible in the visualization. Third, it uses a dummy implementation for 'execute_sql_query' that does not match the SQL logic or retrieve similar data structure as intended in the reference code.",Base
"How many units of each product were sold monthly, and can you provide a monthly sales trend line chart for each product?","```python
import plotly.express as px
import pandas as pd

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation
    pass

# Function to display results
def show_to_user(data):
    # Placeholder for actual implementation
    pass

# SQL query to fetch monthly product sales
sql_query = """"""
SELECT products.ProductID,
       DATE_TRUNC('month', orders.OrderDate) AS order_month, 
       SUM([Order Details].Quantity) AS units_sold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY products.ProductID, order_month
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Convert order_month to a datetime object for proper plotting
df['order_month'] = pd.to_datetime(df['order_month'])

# Generate a line chart for each product
products = df['ProductID'].unique()

for product_id in products:
    product_data = df[df['ProductID'] == product_id]
    fig = px.line(product_data, x='order_month', y='units_sold', title=f'Sales Trend for Product {product_id}', labels={'order_month': 'Month', 'units_sold': 'Units Sold'})
    show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly sales of each product
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       products.ProductID, 
       SUM([Order Details].Quantity) AS units_sold
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY month, products.ProductID
ORDER BY month, products.ProductID
""""""

monthly_sales_df = execute_sql_query(sql_query)

# Graphing the monthly sales trend for each product
fig = px.line(monthly_sales_df, 
              x='month', 
              y='units_sold', 
              color='ProductID', 
              title='Monthly Product Sales Trend',
              labels={'units_sold': 'Units Sold', 'month': 'Month', 'ProductID': 'Product ID'})

show_to_user(fig)
```","The input code uses `DATE_FORMAT` instead of `DATE_TRUNC` for date processing, indicating a difference in the SQL dialect that might not be compatible with the intended database. This discrepancy could lead to different outputs. Also, the input code creates a single line chart using `color='ProductID'`, whereas the reference implementation generates individual charts for each product. This results in a different representation of the data, which does not exactly follow the business request to provide a separate trend line chart for each product.","
```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve the required data
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM OrderDate) AS Month, 
    ProductName, 
    SUM(Quantity) AS TotalUnitsSold 
FROM 
    orderdetails od 
JOIN 
    products p ON od.ProductID = p.ProductID 
GROUP BY 
    EXTRACT(MONTH FROM OrderDate), p.ProductName;
""""""

# Execute the query and get the data
sales_data = execute_sql_query(sql_query)

# Ensure the DataFrame is sorted for plotting
sales_data = sales_data.sort_values(by='Month')

# Plotting the trend line chart for each product
fig = px.line(sales_data, x='Month', y='TotalUnitsSold', color='ProductName',
              title='Monthly Sales Trend Line Chart for Each Product',
              labels={'TotalUnitsSold': 'Total Units Sold', 'Month': 'Month'})

# Display the chart
show_to_user(fig)
```","The input code uses an incorrect approach to grouping and time manipulation compared to the reference code. It groups by 'EXTRACT(MONTH FROM OrderDate)' and 'ProductName', rather than truncating the date to monthly ('DATE_TRUNC') and grouping by product ID. This means the input code does not aggregate sales data correctly across different years, resulting in inaccurate results when months from different years are summed together. Additionally, the reference uses a unique plot per product, whereas the input plots all products together. This can mislead the analysis of trends for individual products.",None
"What is the total potential revenue from products not yet ordered, and how can it be represented visually to highlight key product categories?","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate potential revenue from products not yet ordered
sql_query = """"""
SELECT CategoryID, 
       SUM(UnitPrice * UnitsInStock) AS PotentialRevenue 
FROM products 
WHERE ProductID NOT IN (
    SELECT DISTINCT ProductID FROM [Order Details]
) 
GROUP BY CategoryID;
""""""

# Execute the SQL query and retrieve the result as a pandas DataFrame
potential_revenue_df = execute_sql_query(sql_query)

# Visualize the potential revenue by product categories
fig = px.bar(
    potential_revenue_df, 
    x='CategoryID', 
    y='PotentialRevenue', 
    title='Potential Revenue by Product Category',
    labels={'CategoryID': 'Product Category', 'PotentialRevenue': 'Potential Revenue'},
    height=400
)

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(p.UnitPrice * p.UnitsInStock) AS PotentialRevenue
FROM products p
WHERE p.UnitsOnOrder = 0 AND p.Discontinued = 0
GROUP BY p.CategoryID
""""""

potential_revenue_df = execute_sql_query(sql_query)

fig = px.bar(potential_revenue_df, x='CategoryID', y='PotentialRevenue', title='Total Potential Revenue from Products Not Yet Ordered')
show_to_user(fig)
```","The input code calculates potential revenue for products with no units on order and not discontinued, while the reference code calculates potential revenue for products that have never been ordered. The logic differs since the input does not filter out products previously ordered. Additionally, the visualization title in the input differs from the reference, potentially misleading stakeholders.","```python
import pandas as pd
import plotly.express as px

# Function placeholder to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function executes the SQL query and returns the result as a DataFrame
    pass

# Function placeholder to show results to the user
def show_to_user(data):
    # Assume this function displays data analysis or visualization results
    pass

# SQL Query
sql_query = """"""
SELECT p.CategoryID, SUM(p.UnitPrice * p.UnitsInStock) AS TotalPotentialRevenue
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL
GROUP BY p.CategoryID;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart visualization of Total Potential Revenue by CategoryID
fig = px.bar(
    df,
    x='CategoryID',
    y='TotalPotentialRevenue',
    title='Total Potential Revenue from Products Not Yet Ordered by Category',
    labels={'TotalPotentialRevenue': 'Total Potential Revenue', 'CategoryID': 'Category ID'},
    template='plotly'
)

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly calculates the total potential revenue from products not ordered by using a LEFT JOIN and filtering with IS NULL, which is equivalent to the NOT IN approach used in the reference. Both approaches group results by CategoryID and sum the potential revenue using UnitPrice and UnitsInStock. The visualization uses a bar chart to display Total Potential Revenue by CategoryID. Thus, it adheres to the specified logic and fulfills the business request.",Finetuned
Determine the top 3 countries by total supplier revenue and visualize the results using a bar chart.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get the top 3 countries by total supplier revenue
sql_query = """"""
SELECT suppliers.Country, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS CountryRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.Country 
ORDER BY CountryRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Country', y='CountryRevenue', title='Top 3 Countries by Total Supplier Revenue',
             labels={'CountryRevenue': 'Revenue', 'Country': 'Country'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total supplier revenue grouped by country
sql_query = """"""
SELECT 
    s.Country AS Country,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    s.Country
ORDER BY 
    TotalRevenue DESC
LIMIT 3;
""""""

# Execute the SQL query
top_countries_revenue = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(top_countries_revenue, x='Country', y='TotalRevenue', title='Top 3 Countries by Total Supplier Revenue')

# Display the result to the user
show_to_user(fig)
```","The input Python code correctly executes a SQL query that calculates the total supplier revenue by country using the same SQL logic as the reference implementation. It then creates a bar chart using Plotly to visualize the top 3 countries by total supplier revenue, aligning with the business request. Thus, the input code fulfills the requirements, despite minor differences in table aliases and query structure, such as the inclusion of the 'orders' table, which does not affect the outcome.","```python
import pandas as pd
import plotly.express as px

# Utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # In a real scenario, this would execute the query and return the results as a DataFrame
    pass

def show_to_user(data):
    # In a real scenario, this would display the data or visualization to the user
    pass

# SQL query to get the top 3 countries by total supplier revenue
sql_query = """"""
SELECT s.Country, 
       SUM(p.UnitPrice * o.Quantity * (1 - o.Discount)) AS TotalRevenue 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] o ON p.ProductID = o.ProductID 
GROUP BY s.Country 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the results
df_top_countries = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(df_top_countries, x='Country', y='TotalRevenue', title='Top 3 Countries by Total Supplier Revenue')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly implements the task of determining the top 3 countries by total supplier revenue and visualizing the results using a bar chart. It follows the same logic as the reference implementation by executing a SQL query that selects the top 3 countries based on 'SUM(p.UnitPrice * o.Quantity * (1 - o.Discount))', groups by country, orders by revenue, and limits to 3. The visualization also mirrors that of the reference using Plotly's bar chart functionality. Variable names are different, but they are equivalent in functionality and context.",both
Which employee has generated the highest sales revenue? Please include a bar chart ranking employees by sales revenue.,"```python
import pandas as pd
import plotly.express as px

# Assuming the utility functions are predefined based on the constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the actual implementation
    pass

def show_to_user(data):
    # This is a placeholder for the actual implementation
    pass

# SQL query to fetch sales revenue by employee
sql_query = """"""
SELECT employees.EmployeeID,
       CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
sales_df = execute_sql_query(sql_query)

# Since the query is ordered by TotalSales desc and we need a ranking,
# create a bar chart to visualize the results
fig = px.bar(sales_df, x='EmployeeName', y='TotalSales', title='Employee Sales Revenue Ranking')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, EmployeeName
ORDER BY 
    TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, 
             x='EmployeeName', 
             y='TotalSales', 
             title='Employee Sales Revenue', 
             labels={'TotalSales': 'Sales Revenue', 'EmployeeName': 'Employee'},
             text='TotalSales')

show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It constructs a SQL query that selects the employee ID, concatenated first and last name, and calculates the total sales revenue for each employee by joining the tables 'employees', 'orders', and '[Order Details]'. The query groups by employee ID and name, and orders the results in descending order of total sales. The code then creates a bar chart using Plotly Express to rank employees by sales revenue and displays it. This logic is consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulates SQL execution returning a DataFrame
    # This function should be implemented to connect to a database
    pass

# Utility function to display results to the user
def show_to_user(data):
    # Simulates displaying data or a plot
    pass

# SQL query to get sales revenue by employee
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
SUM(od.UnitPrice * od.Quantity) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query to get the results
df_sales = execute_sql_query(sql_query)

# Create a bar chart ranking employees by sales revenue
fig = px.bar(
    df_sales, 
    x=""TotalSales"", 
    y=""FirstName"", 
    text=""TotalSales"", 
    title=""Employees Ranked by Sales Revenue"",
    labels={""TotalSales"": ""Total Sales Revenue"", ""FirstName"": ""Employee""},
    orientation='h' # horizontal bar chart
)

# Show the top employee's sales revenue to user
show_to_user(df_sales.head(1))

# Show the report with the bar chart to visualize all employees
show_to_user(fig)
```","The input code does not correctly implement the business analytics request as specified. The main issue is that the input code does not account for discounts when calculating 'TotalSales', whereas the reference code does (using the formula: UnitPrice * Quantity * (1 - Discount)). Additionally, the chart in the input code ranks 'FirstName' rather than 'EmployeeName', resulting in potential ambiguity for employees with the same first name. The orientation of the chart also differs (horizontal vs. vertical), but that does not affect correctness.",Base
"What is the average order fulfillment time in days for each month, and can you visualize this with a line chart to show trends over time?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the necessary data
sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM OrderDate) AS Year, 
    EXTRACT(MONTH FROM OrderDate) AS Month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Year, Month;
""""""

# Function to execute the SQL query and get the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Here you would implement the logic to connect to your database and execute the query.
    # For example, using SQLAlchemy or a database-specific connection library.
    # Returning a mock dataframe for the purpose of this demonstration.
    return pd.DataFrame({
        'Year': [2023, 2023, 2023],
        'Month': [1, 2, 3],
        'AvgFulfillmentTime': [3.5, 4.0, 3.8]
    })

# Get the data using the utility function
df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize the trends
fig = px.line(df, x=pd.to_datetime(df[['Year', 'Month']].assign(DAY=1)), y='AvgFulfillmentTime',
              labels={'x': 'Month', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'},
              title='Average Order Fulfillment Time by Month')

# Display the plot using the utility function
def show_to_user(data):
    # This function will show data to users. Assuming Plotly figure input creates a visual display.
    data.show()

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='Month', y='AvgFulfillmentTime', 
              title='Average Order Fulfillment Time by Month', 
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})
show_to_user(fig)
```","The provided code correctly computes the average fulfillment time by month using the SQL query and visualizes it with a line chart. It uses DATE_TRUNC to aggregate data by month, similar to the reference code which uses EXTRACT for year and month. This adheres to the same logic despite differences in SQL implementation, and the visualization captures trends over time with plotly express, aligning with the business request.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = '''
SELECT 
    EXTRACT(YEAR FROM OrderDate) AS Year, 
    EXTRACT(MONTH FROM OrderDate) AS Month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM 
    orders 
GROUP BY 
    YEAR, 
    MONTH;
'''

# Execute the SQL query and get the result as a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a line chart to visualize the average fulfillment time over months
fig = px.line(
    orders_df, 
    x=pd.to_datetime(orders_df[['Year', 'Month']].assign(DAY=1)), 
    y='AvgFulfillmentTime', 
    labels={
        'x': 'Month', 
        'AvgFulfillmentTime': 'Avg Fulfillment Time (days)'
    },
    title='Average Order Fulfillment Time Over Months'
)

# Show the visualization
show_to_user(fig)
```","The input code implements the same logic as the reference code. It correctly computes the average order fulfillment time for each month using a SQL query. The extracted DataFrame is used to create a line chart with Plotly, displaying the trend over time. The only differences are cosmetic, such as slight variations in label texts and variable naming, which do not affect the overall correctness of the implementation.",both
How does the on-time delivery rate vary by region? Please include a visual representation such as a map or bar chart to enhance understanding of the variations.,"```python
import plotly.express as px
import pandas as pd

# Provided utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder. Assume this function connects to the database,
    # executes the query, and returns the result as a pandas DataFrame.
    pass

def show_to_user(data):
    # This is a placeholder. Assume this function handles displaying data
    # or visualizations to the user. For visualizations, it uses Plotly.
    pass

# SQL Query to get the on-time delivery rate by region
sql_query = """"""
SELECT ShipRegion, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID)) * 100 AS on_time_delivery_rate 
FROM orders 
GROUP BY ShipRegion;
""""""

# Execute the query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the on-time delivery rate by region
fig = px.bar(df, x='ShipRegion', y='on_time_delivery_rate', 
             title='On-Time Delivery Rate by Region',
             labels={'on_time_delivery_rate': 'On-Time Delivery Rate (%)',
                     'ShipRegion': 'Region'},
             text='on_time_delivery_rate')

show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipRegion, 
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    ShipRegion
""""""

df = execute_sql_query(sql_query)

df['OnTimeDeliveryRate'] = df['OnTimeDeliveries'] / df['TotalOrders'] * 100

fig = px.bar(df, 
             x='ShipRegion', 
             y='OnTimeDeliveryRate', 
             title='On-time Delivery Rate by Region',
             labels={'OnTimeDeliveryRate': 'On-time Delivery Rate (%)', 'ShipRegion': 'Region'},
             color='OnTimeDeliveryRate',
             color_continuous_scale=px.colors.sequential.Viridis)

show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate by region and visualizes it using a bar chart, consistent with the logic of the reference implementation. Both implementations group the data by 'ShipRegion' and calculate the on-time delivery rate as the number of on-time deliveries over the total number of orders, multiplied by 100 to get a percentage. The visual representation using Plotly's bar chart is consistent in both implementations, fulfilling the business analytics request to show how on-time delivery rates vary by region.","import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT ShipRegion, AVG(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 100 AS OnTimeRate
FROM orders
GROUP BY ShipRegion;
""""""

# Execute the SQL query using the utility function and store in a DataFrame
def execute_sql_query(sql_query: str):
    # Placeholder function for executing SQL query
    pass

# Fetch data
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the on-time delivery rate by region
fig = px.bar(data, x='ShipRegion', y='OnTimeRate', title='On-Time Delivery Rate by Region',
             labels={'OnTimeRate': 'On-Time Delivery Rate (%)', 'ShipRegion': 'Region'},
             text='OnTimeRate')

# Display the bar chart
def show_to_user(data):
    # Placeholder function for displaying data
    pass

show_to_user(fig)","Both the reference and input codes query the on-time delivery rate by region, calculating the percentage of on-time deliveries using slightly different SQL syntax but achieving the same result. The input code uses AVG with a CASE statement, and the reference code uses COUNT with a CASE. The visualization part is correctly implemented in both, using Plotly to create a bar chart displaying the on-time delivery rate by region.",both
"How does the average order value change per region, and can we visualize these differences using a bar chart?","```python
import pandas as pd
import plotly.express as px

def analyze_avg_order_value_per_region():
    # Define SQL Query
    sql_query = """"""
    SELECT c.Region, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AvgOrderValue
    FROM customers c
    JOIN orders o ON c.CustomerID = o.CustomerID
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    GROUP BY c.Region
    """"""
    
    # Execute the SQL query to get data into a pandas DataFrame
    df = execute_sql_query(sql_query)

    # Create a bar chart to visualize average order value per region
    fig = px.bar(df, x='Region', y='AvgOrderValue',
                 title='Average Order Value per Region',
                 labels={'AvgOrderValue': 'Average Order Value', 'Region': 'Region'})

    # Show the bar chart
    show_to_user(fig)

# Execute the analysis
analyze_avg_order_value_per_region()
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average order value per region
sql_query = """"""
SELECT 
    c.Region,
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.Region
""""""

# Execute the SQL query
average_order_value_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average order value per region
fig = px.bar(average_order_value_df, x='Region', y='AverageOrderValue', title='Average Order Value per Region')

# Display the visualization to the user
show_to_user(fig)
```","The input Python code is functionally equivalent to the reference implementation. Both codes execute the same SQL query to calculate the average order value per region, and they use Plotly Express to create a bar chart for visualization. The differences in variable naming do not affect the overall logic and output. Therefore, the input code meets the business analytics request effectively.","```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve the average order value per region
sql_query = """"""
SELECT region.RegionDescription AS Region, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) 
       / COUNT(DISTINCT orders.OrderID) AS AverageOrderValue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
JOIN region ON customers.Region = region.RegionID 
GROUP BY region.RegionDescription
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Region', 
             y='AverageOrderValue', 
             title='Average Order Value per Region',
             labels={'AverageOrderValue': 'Average Order Value ($)', 'Region': 'Region'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly calculates the average order value per region using SQL and visualizes it with a bar chart in Plotly. Although the SQL query structure differs slightly, the logic matches the reference code: calculating average order values and grouping by region. The visualization approach also aligns with the reference implementation.",both
"What is the total number of orders shipped on time by each employee, and can you provide a bar chart to display the results?","
```python
import pandas as pd
import plotly.express as px

# SQL query to get the total number of orders shipped on time by each employee
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OnTimeOrders 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShippedDate <= orders.RequiredDate 
GROUP BY employees.EmployeeID
""""""

# Executes the SQL query and fetch results into a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # Assume the function connects to a database, executes the query, and returns a DataFrame
    pass

# Displays data analysis or visualization results
def show_to_user(data):
    # Placeholder for display logic
    # Assume the function can display either a pandas DataFrame or a Plotly figure
    pass

# Execute the query and get results
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='OnTimeOrders', title='On-Time Orders by Employee', labels={'OnTimeOrders': 'Number of On-Time Orders', 'EmployeeID': 'Employee ID'})

# Display the bar chart
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OnTimeOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate <= o.RequiredDate
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='FirstName', y='OnTimeOrders', title='Total Orders Shipped On Time by Employee', 
              labels={'FirstName': 'Employee', 'OnTimeOrders': 'Number of On-Time Orders'})
show_to_user(fig)
```","The input code differs from the reference in the GROUP BY clause and plotting. It groups by FirstName and LastName, while the reference only groups by EmployeeID. Additionally, the bar chart in the input uses 'FirstName' for the x-axis instead of 'EmployeeID', which can lead to ambiguity if multiple employees share names. These differences affect the correctness as per the specified request.","```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT employees.EmployeeID, 
       COUNT(orders.OrderID) AS OnTimeOrders 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShippedDate <= orders.RequiredDate 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of on-time orders per employee
fig = px.bar(
    df, 
    x='EmployeeID', 
    y='OnTimeOrders', 
    title='Number of On-time Orders by Employee',
    labels={'OnTimeOrders': 'On Time Orders', 'EmployeeID': 'Employee ID'}
)

# Display the result to the user
show_to_user(fig)
```","The provided code correctly executes a SQL query to count the number of on-time orders per employee and then visualizes the result using a Plotly bar chart. The logic aligns with the reference implementation, as both codes perform the same tasks using equivalent functions and methods. Any differences are cosmetic and do not affect the outcome.",Finetuned
How much total revenue did each product category generate in 2023? Include a bar chart to visualize the revenue distribution across categories.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user utility functions are already defined

# SQL query to fetch total revenue by product category for 2023
sql_query = """"""
SELECT c.CategoryName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_revenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN categories c ON p.CategoryID = c.CategoryID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE YEAR(o.OrderDate) = 2023 
GROUP BY c.CategoryName
""""""

# Execute the SQL query and get the data into a pandas DataFrame
revenue_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue distribution across categories
fig = px.bar(
    revenue_data, 
    x='CategoryName', 
    y='total_revenue', 
    title='Total Revenue by Product Category in 2023',
    labels={'CategoryName': 'Product Category', 'total_revenue': 'Total Revenue'},
    text_auto=True
)

# Show the visualization to the user
show_to_user(fig)
```","```python
sql_query = """"""
SELECT categories.CategoryName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY categories.CategoryName
""""""

revenue_data = execute_sql_query(sql_query)

import plotly.express as px

fig = px.bar(revenue_data, x='CategoryName', y='total_revenue', title='Total Revenue by Product Category in 2023', labels={'total_revenue': 'Total Revenue', 'CategoryName': 'Product Category'})
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It executes a SQL query to calculate total revenue by product category for the year 2023 and uses Plotly to create a bar chart for visualization. Both scripts join the necessary tables, filter the orders from 2023, and group the results by category to compute total revenue, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query from the business scenario
sql_query = """"""
SELECT c.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS revenue 
FROM products p 
JOIN Categories c ON p.CategoryID = c.CategoryID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE YEAR(CURDATE()) = 2023 
GROUP BY c.CategoryID
""""""

# Execute the SQL query and fetch the resulting DataFrame
revenue_df = execute_sql_query(sql_query)

# Create a bar chart for visualizing total revenue by product category
fig = px.bar(revenue_df, x='CategoryID', y='revenue', 
             labels={'CategoryID': 'Product Category', 'revenue': 'Total Revenue'},
             title='Total Revenue by Product Category for 2023')

# Display the figure using the show_to_user utility function
show_to_user(fig)
```","The input code calculates revenue for the current year using CURDATE(), which may not be 2023. Also, it groups by CategoryID instead of CategoryName, making it less user-friendly compared to the reference code. The SQL logic is not correctly aligned with the reference implementation.",Base
Find the top 5 products with the highest sales revenue and visualize the results with a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to find the top 5 products with the highest sales revenue
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS SalesRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY SalesRevenue DESC 
LIMIT 5;
""""""

# Function to execute the SQL query and get results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function body
    # This should contain implementation for executing SQL and returning a DataFrame
    pass

# Function to display data or visualization results
def show_to_user(data):
    # Placeholder function body
    # This should contain implementation for displaying DataFrame or Plotly figure
    pass

# Execute the SQL query and get the data
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductName', y='SalesRevenue', title='Top 5 Products by Sales Revenue')

# Display the results using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS SalesRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY SalesRevenue DESC
LIMIT 5;
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='SalesRevenue', 
              title='Top 5 Products by Sales Revenue', 
              labels={'SalesRevenue': 'Sales Revenue', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code incorrectly includes a discount calculation in the SQL query that the reference implementation does not account for. The request and reference code specify finding the highest sales revenue without discounts, whereas the input code modifies the sales revenue by considering discounts.","```python
import plotly.express as px
import pandas as pd

# Business Analytic Request
def find_top_products_and_visualize():
    # Utility function to execute the SQL query
    sql_query = """"""
    SELECT products.ProductName, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * 
               (1 - [Order Details].Discount)) AS TotalRevenue 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    GROUP BY products.ProductName 
    ORDER BY TotalRevenue DESC 
    LIMIT 5;
    """"""
    
    # Execute the SQL query and get the result as a DataFrame
    df = execute_sql_query(sql_query)
    
    # Visualize the results using a bar chart
    fig = px.bar(df, 
                 x='ProductName', 
                 y='TotalRevenue', 
                 title='Top 5 Products by Sales Revenue',
                 labels={'ProductName': 'Product Name', 'TotalRevenue': 'Total Revenue'},
                 text='TotalRevenue')
    
    # Display the bar chart
    show_to_user(fig)

# Call the function to execute the entire process
find_top_products_and_visualize()
```","The input code considers discounts in calculating 'TotalRevenue', while the reference code does not. Also, the input code uses different column labels ('TotalRevenue' vs 'SalesRevenue'), which could imply a different business logic. The input code includes labels and text in the bar chart, providing additional features, but the main issue is the differing revenue calculations.",None
"Which supplier provides the maximum number of products, and can you provide a bar chart to visualize the distribution among suppliers?","
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve data
sql_query = '''
SELECT suppliers.CompanyName, COUNT(products.ProductID) AS TotalProducts 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.CompanyName 
ORDER BY TotalProducts DESC
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Prepare a bar chart for visualization
fig = px.bar(df, x='CompanyName', y='TotalProducts', 
             title='Distribution of Products Among Suppliers',
             labels={'CompanyName': 'Supplier', 'TotalProducts': 'Number of Products'})

# Show the visualization to the user
show_to_user(fig)

# Also display the top supplier with the maximum products for clarity
max_supplier = df.iloc[0:1]
show_to_user(max_supplier)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
ORDER BY ProductCount DESC
LIMIT 1
""""""

max_supplier = execute_sql_query(sql_query)

sql_query_distribution = """"""
SELECT s.CompanyName, COUNT(p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
""""""

supplier_distribution = execute_sql_query(sql_query_distribution)

fig = px.bar(supplier_distribution, x='CompanyName', y='ProductCount', title='Product Distribution Among Suppliers')
show_to_user(fig)
```","The input code correctly fulfills the business analytics request. It executes two SQL queries: one to find the supplier with the maximum number of products, and another to get the distribution of products among all suppliers. It then visualizes the distribution with a bar chart, matching the functionality of the reference implementation. Although the approach differs slightly (using two queries instead of filtering after the first query), the core logic aligns with the reference implementation.","```python
import plotly.express as px

# SQL query to get supplier product counts
sql_query = """"""
    SELECT suppliers.CompanyName, COUNT(products.ProductID) AS ProductCount 
    FROM suppliers JOIN products ON suppliers.SupplierID = products.SupplierID 
    GROUP BY suppliers.CompanyName 
    ORDER BY ProductCount DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
supplier_product_counts_df = execute_sql_query(sql_query)

# Get the supplier with the maximum number of products
max_supplier_df = supplier_product_counts_df.head(1)

# Display the supplier with maximum products
show_to_user(max_supplier_df)

# Create a bar chart to visualize product distribution among suppliers
fig = px.bar(
    supplier_product_counts_df,
    x='CompanyName',
    y='ProductCount',
    title='Product Distribution Among Suppliers',
    labels={'CompanyName': 'Supplier', 'ProductCount': 'Number of Products'},
    text='ProductCount'
)

# Enhance bar chart layout
fig.update_traces(textposition='outside')
fig.update_layout(margin=dict(l=0, r=0, t=60, b=0))

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the logic specified in the business analytics request. It executes the same SQL query to retrieve suppliers and their product counts, orders by product count to determine the maximum supplier, displays this result, and visualizes the data using a bar chart. Although there are minor differences in chart layout adjustments, the fundamental functionality matches the reference implementation.",both
"Which month has the highest on-time delivery rate, and provide a chart to visualize the on-time delivery rates by month?","```python
import pandas as pd
import plotly.express as px

# SQL query to get on-time delivery rates by month
sql_query = """"""
    SELECT EXTRACT(MONTH FROM OrderDate) AS Month, 
           (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN OrderID END) * 100.0 / COUNT(OrderID)) AS OnTimeRate 
    FROM orders 
    GROUP BY Month 
    ORDER BY Month
""""""

# Execute the SQL query to retrieve data
order_data = execute_sql_query(sql_query)

# Identify the month with the highest on-time delivery rate
highest_on_time_rate_month = order_data.iloc[order_data['OnTimeRate'].idxmax()]
show_to_user(highest_on_time_rate_month)

# Visualization of on-time delivery rates by month
fig = px.line(order_data, x='Month', y='OnTimeRate', title='On-time Delivery Rates by Month')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) AS OnTimeDeliveryRate
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

df = execute_sql_query(sql_query)

highest_on_time_month = df.loc[df['OnTimeDeliveryRate'].idxmax()]

fig = px.line(df, x='Month', y='OnTimeDeliveryRate', title='On-Time Delivery Rates by Month')
show_to_user(fig)

highest_on_time_month
```","The input code uses DATE_FORMAT(OrderDate, '%Y-%m') to group by year and month, whereas the reference code uses EXTRACT(MONTH FROM OrderDate) to group only by month. This difference in grouping granularity affects the calculation of on-time delivery rates and the identification of the month with the highest rate. Additionally, the input code divides by COUNT(OrderID) which could lead to a division by zero if there are months with no orders, an issue not addressed in the reference code.","```python
import plotly.express as px
import pandas as pd

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would execute the given SQL query and return a DataFrame
    # Implementation is assumed to be provided elsewhere
    pass

def show_to_user(data):
    # This function is assumed to display data or figures to the user
    pass

# Given SQL query
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(*)) * 100 AS OnTimeRate 
FROM orders 
GROUP BY EXTRACT(MONTH FROM OrderDate) 
ORDER BY Month;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Identify the month with the highest on-time delivery rate
highest_on_time_month = df.loc[df['OnTimeRate'].idxmax()]

# Display the month with the highest on-time delivery rate
show_to_user(highest_on_time_month)

# Create a bar chart to visualize the on-time delivery rates by month
fig = px.bar(df, x='Month', y='OnTimeRate', 
             title='On-Time Delivery Rates by Month', 
             labels={'Month': 'Month', 'OnTimeRate': 'On-Time Rate (%)'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the logic to find and visualize the month with the highest on-time delivery rate. The SQL query and logic for calculating on-time rates are equivalent to the reference code, despite a slight difference in SQL syntax (`COUNT(1)` vs `OrderID`). The method for identifying the highest rate and displaying results follows the same approach. The main difference lies in the use of a bar chart instead of a line chart for visualization, which does not affect the correctness of the logic.",Finetuned
Calculate the total sales and total discount for each product and provide a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT ProductID, 
       SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalSales, 
       SUM(UnitPrice * Quantity * Discount) AS TotalDiscount 
FROM [Order Details] 
GROUP BY ProductID;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, 
             x='ProductID', 
             y=['TotalSales', 'TotalDiscount'], 
             barmode='group', 
             title='Total Sales and Total Discount by Product',
             labels={'value': 'Amount', 'variable': 'Measure'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales, 
       SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductID', y=['TotalSales', 'TotalDiscount'], 
             title='Total Sales and Discounts per Product', 
             labels={'value': 'Amount', 'variable': 'Metric'},
             barmode='group')

show_to_user(fig)
```","The input code includes a JOIN with the orders table, which is not present in the reference code. This additional JOIN could alter the results and is unnecessary to meet the specified business analytics request.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would connect to the database and execute the given SQL query
    # For example purposes, we return a mock DataFrame
    data = {
        'ProductID': [1, 2, 3],
        'TotalSales': [2000.0, 1500.0, 500.0],
        'TotalDiscount': [200.0, 150.0, 50.0]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This function would display data in an appropriate format
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to retrieve total sales and total discount for each product
sql_query = """"""
SELECT p.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales, 
       SUM(od.Discount * od.UnitPrice * od.Quantity) AS TotalDiscount 
FROM products p 
JOIN ""Order Details"" od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Visualize the total sales and total discount using a bar chart
fig = px.bar(df, 
             x='ProductID', 
             y=['TotalSales', 'TotalDiscount'], 
             title='Total Sales and Total Discount for Each Product',
             labels={'value': 'Amount', 'variable': 'Category'},
             barmode='group')

# Display the plot
show_to_user(fig)
```","Both implementations aim to calculate total sales and total discounts per product and visualize them using a bar chart. The input code uses a SQL query with a JOIN operation, which may imply a slightly different database schema. Despite this, it computes the same metrics: TotalSales and TotalDiscount. The visualization logic with Plotly (px.bar) is consistent, utilizing the same grouping and labels. Thus, the input code adheres to the logic and spirit of the reference implementation.",Finetuned
Find the average unit price of products supplied by each supplier and include a bar chart to visualize the differences.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to obtain the desired data
sql_query = """"""
SELECT SupplierID, AVG(UnitPrice) AS AverageUnitPrice 
FROM products 
GROUP BY SupplierID;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average unit price by supplier
fig = px.bar(df, x='SupplierID', y='AverageUnitPrice', title='Average Unit Price by Supplier', 
             labels={'SupplierID': 'Supplier ID', 'AverageUnitPrice': 'Average Unit Price'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.SupplierID
""""""

average_price_df = execute_sql_query(sql_query)

fig = px.bar(average_price_df, x='SupplierID', y='AverageUnitPrice', 
             title='Average Unit Price of Products by Supplier', 
             labels={'SupplierID': 'Supplier ID', 'AverageUnitPrice': 'Average Unit Price'})

show_to_user(fig)
```","The input code correctly fulfills the business analytics request. It calculates the average unit price of products by each supplier using an SQL query and creates a bar chart using Plotly to visualize the differences, just like in the reference implementation. The logic in both implementations is identical, despite slight variations in SQL aliasing and chart title wording.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for context
    # In practice, this function would execute the SQL query against a database
    pass

# Utility function to show data or visualization to user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# Define the SQL query
sql_query = """"""
SELECT SupplierID, AVG(UnitPrice) AS AvgUnitPrice 
FROM products 
GROUP BY SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create bar chart using Plotly to visualize average unit prices
fig = px.bar(df, x='SupplierID', y='AvgUnitPrice', title='Average Unit Price by Supplier', labels={'SupplierID': 'Supplier ID', 'AvgUnitPrice': 'Average Unit Price'})

# Show the resulting bar chart to the user
show_to_user(fig)
```","The input Python code correctly calculates the average unit price per supplier using a SQL query and creates a bar chart with Plotly. The differences in variable naming ('AverageUnitPrice' vs 'AvgUnitPrice') do not affect the logic or outcome as they are consistently used within their respective contexts. Additionally, the utility functions assume the existence of a database connection, similar to the reference implementation.",both
Which region has the highest total sales? Include a bar chart to compare sales across regions.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by region
sql_query = """"""
SELECT 
    Region, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Region 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Visualize the sales data across regions using a bar chart
fig = px.bar(sales_data, x='Region', y='TotalSales', title='Total Sales by Region')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.Region, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.Region
ORDER BY 
    TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)
highest_sales_region = sales_data.iloc[0]

fig = px.bar(sales_data, x='Region', y='TotalSales', title='Total Sales by Region', labels={'TotalSales': 'Total Sales', 'Region': 'Region'})
show_to_user(fig)
```","The provided code correctly implements the query to calculate total sales by region, similar to the reference implementation. It joins the necessary tables and sums the product of unit price and quantity, considering any applied discounts, grouped by region. The code also includes a bar chart visualization to display total sales across regions. The logic aligns with the reference code, fulfilling the business analytics request.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch total sales by region
sql_query = """"""
SELECT 
    Region, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    Region 
ORDER BY 
    TotalSales DESC;
""""""

# Function to execute the SQL query and fetch the data into a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing the SQL query and returning a DataFrame
    # The implementation should connect to a database and fetch data
    pass

# Execute the SQL query
region_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales across regions using Plotly
fig = px.bar(region_sales_df, x='Region', y='TotalSales',
             title='Total Sales by Region',
             labels={'TotalSales': 'Total Sales', 'Region': 'Region'},
             text_auto=True)

# Display the bar chart to the user
def show_to_user(data):
    # Placeholder for displaying data or visualization
    # If data is a Plotly figure, it should be displayed as a graph
    pass

show_to_user(fig)
```","The provided code uses a different table ('customers') for the JOIN operation compared to the reference implementation which uses ('employees'). This discrepancy may lead to different results depending on the structure and relationship of the tables in the database. Therefore, the input code does not strictly adhere to the same logic as the reference implementation.",Base
Which shipping method tends to have the fastest fulfillment time? Include a data visualization comparing fulfillment times across different shipping methods.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AvgFulfillmentTime ASC;
""""""

# Execute the SQL query using the provided utility function
shipping_method_df = execute_sql_query(sql_query)

# Create a Plotly bar chart for comparison of fulfillment times
fig = px.bar(
    shipping_method_df,
    x='ShipVia',
    y='AvgFulfillmentTime',
    title='Average Fulfillment Time by Shipping Method',
    labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Avg Fulfillment Time (days)'},
    text_auto=True
)

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipVia
ORDER BY AvgFulfillmentTime
""""""
fulfillment_data = execute_sql_query(sql_query)

fig = px.bar(fulfillment_data, x='ShipVia', y='AvgFulfillmentTime',
             title='Average Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'})

show_to_user(fig)
```","The input code is correct because it executes a SQL query to calculate the average fulfillment time by shipping method. The query groups by the 'ShipVia' and calculates the average date difference between 'ShippedDate' and 'OrderDate', just like the reference implementation. It uses Plotly to create a bar chart with the same data and similar customization in titles and labels. Although minor differences exist, such as text display options, the core functionality and logic match the reference code.","```python
import plotly.express as px
import pandas as pd

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the actual implementation
    pass

def show_to_user(data):
    # This is a placeholder for the actual implementation
    pass

# SQL query to get fulfillment times for different shipping methods
sql_query = """"""
SELECT ShipVia, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AvgFulfillmentTime ASC;
""""""

# Execute the SQL query and get the result as a DataFrame
fulfillment_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the fulfillment times
fig = px.bar(
    fulfillment_data, 
    x='ShipVia', 
    y='AvgFulfillmentTime', 
    title='Average Fulfillment Time by Shipping Method',
    labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'},
    template='plotly'
)

# Show the figure to the user
show_to_user(fig)
```","The input Python code adheres to the same logic as the reference implementation. It executes an SQL query to calculate average fulfillment times by shipping method and uses Plotly to create a bar chart for visualization. The elements, such as SQL query structure, data retrieval, and methods for visualization, match the reference approach, fulfilling the business analytics request correctly.",both
"What is the total sales revenue generated monthly, and can you provide a line chart to visualize the trends over time?","```python
import pandas as pd
import plotly.express as px

# Function to execute an SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # The actual implementation of this function will depend on the database connection setup
    pass

# Function to display data or visualization results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        # Code to display DataFrame
        print(data)
    else:
        # Assuming data is a Plotly figure
        data.show()

# SQL query to fetch total sales revenue monthly
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY month
""""""

# Execute the SQL query to get the data
monthly_sales_data = execute_sql_query(sql_query)

# Plot the data using Plotly
fig = px.line(monthly_sales_data, x='month', y='total_sales', title='Monthly Total Sales Revenue', labels={'month': 'Month', 'total_sales': 'Total Sales Revenue'})

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY month
ORDER BY month;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='month', y='total_sales', title='Monthly Total Sales Revenue')
show_to_user(fig)
```","The input code correctly executes the given SQL query, which calculates the monthly total sales revenue using the same logic as the reference implementation. It uses the same SQL query structure, retrieves the data, and generates a line chart with Plotly to visualize trends over time. The addition of 'ORDER BY month;' ensures the output is sorted by month, which is not present in the reference code but does not affect its correctness. The function 'show_to_user' is used to display the figure, in line with the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlySales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY Month;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(data, x='Month', y='MonthlySales', title='Monthly Sales Revenue Trends')

# Display the line chart to the user
show_to_user(fig)
```",Both implementations perform the same task of calculating total monthly sales and visualizing it. They use SQL queries to sum sales revenue grouped by month and produce a line chart using Plotly. Differences in SQL syntax (DATE_TRUNC vs DATE_FORMAT) align with typical variations between SQL dialects.,both
Identify suppliers whose products have the lowest average inventory and visualize the data to compare average inventory levels across suppliers.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to get average inventory for each supplier
sql_query = """"""
SELECT SupplierID, AVG(UnitsInStock) AS AverageInventory 
FROM products 
GROUP BY SupplierID 
ORDER BY AverageInventory ASC;
""""""

# Execute the SQL query and obtain the results in a DataFrame
df = execute_sql_query(sql_query)

# Visualize the average inventory levels across suppliers
fig = px.bar(df, x='SupplierID', y='AverageInventory', 
             title='Average Inventory Levels by Supplier',
             labels={'AverageInventory': 'Average Inventory', 'SupplierID': 'Supplier ID'})

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(p.UnitsInStock) AS AvgInventory
FROM products p
WHERE p.Discontinued = 0
GROUP BY p.SupplierID
ORDER BY AvgInventory ASC
""""""

supplier_inventory_df = execute_sql_query(sql_query)

fig = px.bar(supplier_inventory_df, x='SupplierID', y='AvgInventory', 
             title='Average Inventory Levels Across Suppliers',
             labels={'SupplierID': 'Supplier ID', 'AvgInventory': 'Average Inventory'}, 
             color='AvgInventory')
show_to_user(fig)
```","The input code introduces a condition `WHERE p.Discontinued = 0` which is not present in the reference implementation. This could potentially alter the results by excluding discontinued products from the average inventory calculation, thus not adhering to the original logic.","```python
import plotly.express as px

# Utility function to execute SQL query and return DataFrame
def execute_sql_query(sql_query: str):
    # Placeholder function body
    # Replace with actual database access logic
    pass

# Utility function to display data or visualization
def show_to_user(data):
    # Placeholder function to handle data or plot display
    pass

# SQL query to retrieve supplier IDs and their average inventory levels
sql_query = """"""
SELECT suppliers.SupplierID, AVG(products.UnitsInStock) AS AvgInventory 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.SupplierID 
ORDER BY AvgInventory ASC;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Generate a bar plot to visualize the average inventory levels
fig = px.bar(data, x='SupplierID', y='AvgInventory',
             title=""Average Inventory Levels by Supplier"",
             labels={'SupplierID': 'Supplier ID', 'AvgInventory': 'Average Inventory'})

# Display the visualization to the user
show_to_user(fig)
```","The input code correctly follows the logic and achieves the same outcome as the reference implementation. It uses an SQL query to calculate the average inventory for each supplier and then visualizes this data using a bar chart. The differences, such as the use of a JOIN operation and different column aliases, do not affect the correctness of the solution as they still produce the correct result for the specified task.",Finetuned
"Which city has the largest number of employees based on their address, and can it be visualized using a bar chart to compare employee counts across all cities?","```python
import plotly.express as px

# SQL query to obtain employee counts per city
sql_query = """"""
SELECT City, COUNT(EmployeeID) AS EmployeeCount 
FROM employees 
GROUP BY City 
ORDER BY EmployeeCount DESC;
""""""

# Execute the query and obtain the DataFrame
df = execute_sql_query(sql_query)

# Determine the city with the largest number of employees
city_with_most_employees = df.iloc[0]

# Print the city with the largest number of employees
show_to_user(city_with_most_employees.to_frame().T)

# Create a bar chart visualizing employee counts across all cities
fig = px.bar(df, x='City', y='EmployeeCount', title='Employee Counts by City', labels={'EmployeeCount':'Number of Employees'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT City, COUNT(EmployeeID) AS EmployeeCount
FROM employees
GROUP BY City
ORDER BY EmployeeCount DESC
""""""

city_employee_counts = execute_sql_query(sql_query)

largest_city = city_employee_counts.iloc[0]
fig = px.bar(city_employee_counts, x='City', y='EmployeeCount', title='Employee Count by City')
show_to_user(fig)
```","The input code does not include the step to explicitly show the city with the largest number of employees using `show_to_user(largest_city.to_frame().T)`. The reference code includes this step, which makes it an essential part of the request. The visualization aspect is correct, as both show a bar chart.","```python
import pandas as pd
import plotly.express as px

# SQL query to get employee counts by city
sql_query = """"""
SELECT e.City, COUNT(*) AS EmployeeCount 
FROM employees e 
GROUP BY e.City 
ORDER BY EmployeeCount DESC
""""""

# Executing the SQL query using the utility function
employee_data = execute_sql_query(sql_query)

# Extracting the city with the largest number of employees
city_with_most_employees = employee_data.iloc[0]

# Display the city with the most employees
show_to_user(pd.DataFrame([city_with_most_employees]))

# Visualizing employee counts across all cities using a bar chart
fig = px.bar(employee_data, x='City', y='EmployeeCount', title='Employee Count by City')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code is consistent with the reference implementation. It uses a similar SQL query, correctly groups and orders the data to find employee counts by city, and sorts them in descending order. The extraction of the city with the most employees is also done correctly using the first row of the DataFrame. Both implementations utilize Plotly to create a bar chart visualizing employee counts across cities, and the chart is displayed to the user. The key logic and final outputs align with the reference code.",Finetuned
"Which orders include products that are currently out of stock, and can you provide a dashboard showing the orders and their respective product availability status?","```python
# Import necessary libraries
import pandas as pd
import plotly.express as px

# Define the SQL query to find orders with products out of stock
sql_query = """"""
SELECT DISTINCT [Order Details].OrderID, products.ProductName, products.UnitsInStock
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE products.UnitsInStock = 0;
""""""

# Execute the SQL query and obtain the DataFrame
orders_out_of_stock_df = execute_sql_query(sql_query)

# Display the dataframe using the show_to_user utility function
show_to_user(orders_out_of_stock_df)

# Add a column for better visualization
orders_out_of_stock_df['AvailabilityStatus'] = 'Out of Stock'

# Visualize using Plotly
fig = px.bar(orders_out_of_stock_df, 
             x='OrderID', 
             y='ProductName', 
             color='AvailabilityStatus', 
             title='Orders with Products Out of Stock',
             labels={'ProductName': 'Product Name'})

# Show the bar chart using the show_to_user utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get orders that include out of stock products
sql_query = """"""
SELECT od.OrderID, p.ProductName, p.UnitsInStock 
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE p.UnitsInStock = 0
""""""

# Execute the SQL query
out_of_stock_orders = execute_sql_query(sql_query)

# Prepare to visualize the data
if not out_of_stock_orders.empty:
    fig = px.bar(out_of_stock_orders, 
                 x='OrderID', 
                 y='ProductName', 
                 color='UnitsInStock', 
                 title='Orders with Out of Stock Products',
                 labels={'UnitsInStock': 'Units In Stock (Should be 0 for out of stock)'})
else:
    fig = px.bar(title='No Orders with Out of Stock Products')

# Show the result to the user
show_to_user(fig)
```","The input code does not clearly indicate the out-of-stock status in visualization. Unlike the reference code, it uses 'UnitsInStock' as the color parameter, which can cause confusion as it doesn't explicitly label the products as 'Out of Stock'. The reference implementation provides a clearer dashboard by adding an 'AvailabilityStatus' column to indicate the out-of-stock nature directly.","```python
import plotly.express as px
import pandas as pd

# SQL query to get orders with products that are out of stock
sql_query = """"""
SELECT o.OrderID, p.ProductID, p.ProductName
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
WHERE p.UnitsOnOrder < p.ReorderLevel AND p.UnitsInStock = 0;
""""""

# Execute the SQL query and get the results
orders_with_out_of_stock_products = execute_sql_query(sql_query)

# Create a dashboard using Plotly to visualize the orders and product availability
fig = px.bar(
    orders_with_out_of_stock_products,
    x='OrderID',
    y='ProductID',
    color='ProductName',
    title='Orders with Out of Stock Products',
    labels={'OrderID': 'Order ID', 'ProductID': 'Product ID'},
    text='ProductName'
)

# Enhance the dashboard with appropriate layout
fig.update_layout(xaxis_title='Order ID', yaxis_title='Count', barmode='group')

# Show the dashboard to the user
show_to_user(fig)
```","The provided code checks for a condition `p.UnitsOnOrder < p.ReorderLevel`, which is not present in the reference implementation. The reference code only checks `WHERE products.UnitsInStock = 0`, hence focusing only on stock status, not reorder status. Also, the column choices `ProductID` instead of `UnitsInStock` affect the code logic and output, diverging from the business request.",None
How many orders were shipped with each shipping method using a bar chart to visualize the results?,"```python
import plotly.express as px

# Assuming the function execute_sql_query is defined elsewhere
sql_query = ""SELECT ShipVia, COUNT(*) AS OrdersShipped FROM orders GROUP BY ShipVia;""
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipVia', y='OrdersShipped', title='Orders Shipped by Each Shipping Method')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipVia
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ShipVia', y='OrderCount', title='Orders Shipped by Shipping Method', labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input code follows the same logic as the reference implementation. It executes a SQL query that counts the number of orders per shipping method, groups the results by the 'ShipVia' column, and stores the result in a DataFrame. It then creates a bar chart using Plotly to visualize the number of orders shipped per shipping method. The difference in column naming ('OrderCount' vs. 'OrdersShipped') does not affect the correctness as the logic and outcome are consistent with the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Function to execute SQL and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation: replace with actual database interaction
    data = {
        'ShipVia': ['Air', 'Ground', 'Sea'],
        'OrderCount': [50, 150, 75]
    }
    return pd.DataFrame(data)

# Function to display the result to the user
def show_to_user(data):
    # Mock implementation: replace with actual visualization display
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query
sql_query = ""SELECT ShipVia, COUNT(*) AS OrderCount FROM orders GROUP BY ShipVia;""

# Execute the query and get the data
df_orders = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_orders, x='ShipVia', y='OrderCount', title='Orders Shipped by Shipping Method')

# Display the figure to the user
show_to_user(fig)
```","The provided Python code meets the requirements of the business analytics request. It correctly executes a SQL query to count the number of orders shipped via each method, grouping by 'ShipVia'. It uses Plotly to create a bar chart of the results. The logic corresponds with the reference implementation, as both use the same approach to fetch data and generate a visualization. The key difference, variable naming ('OrderCount' instead of 'OrdersShipped'), does not affect the correctness of the implementation.",both
"Which orders were delivered on time in 2023, and can this be shown in a visual format, such as a bar chart or timeline, to enhance understanding?","```python
import plotly.express as px

# SQL Query to fetch the required data
sql_query = """"""
SELECT orders.OrderID, orders.ShippedDate, orders.RequiredDate, orders.OrderDate 
FROM orders 
WHERE orders.ShippedDate <= orders.RequiredDate 
AND orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Fetching the data using the utility function
orders_df = execute_sql_query(sql_query)

# Creating a bar chart to visualize orders delivered on time
fig = px.bar(
    orders_df, 
    x='OrderID', 
    y='OrderDate', 
    title='Orders Delivered On Time in 2023',
    labels={'OrderDate':'Order Date', 'OrderID':'Order ID'},
    hover_data=['ShippedDate', 'RequiredDate']
)

# Display the visualization result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS month,
    COUNT(OrderID) AS on_time_orders
FROM 
    orders
WHERE 
    YEAR(OrderDate) = 2023 AND 
    ShippedDate <= RequiredDate
GROUP BY 
    month
ORDER BY 
    month;
""""""

on_time_orders_df = execute_sql_query(sql_query)

fig = px.bar(on_time_orders_df, x='month', y='on_time_orders', 
              title='On-time Deliveries in 2023',
              labels={'month': 'Month', 'on_time_orders': 'Number of On-time Deliveries'})

show_to_user(fig)
```","The input code and the reference implementation differ in both the SQL query and the visualization method. The reference code fetches individual orders delivered on time and visualizes them using 'OrderID' and 'OrderDate', whereas the input code aggregates orders by month, showing the count of on-time orders per month. These are different analyses: the former shows specific orders, and the latter shows monthly aggregates.","```python
import pandas as pd
import plotly.express as px

# Sample utility function definitions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function to match the environment constraints.
    # The actual implementation would fetch data from a database.
    # For demonstration, return a sample DataFrame
    return pd.DataFrame({
        'OrderID': [1, 2, 3],
        'ShippedDate': [""2023-02-10"", ""2023-06-15"", ""2023-09-20""]
    })

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# The SQL query to fetch data
sql_query = '''
SELECT o.OrderID, o.ShippedDate FROM orders o
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
AND o.RequiredDate = o.ShippedDate;
'''

# Executing the SQL query
orders_df = execute_sql_query(sql_query)

# Converting ShippedDate to datetime format for visualization
orders_df['ShippedDate'] = pd.to_datetime(orders_df['ShippedDate'])

# Creating a bar chart to visualize on-time deliveries by month
orders_df['Month'] = orders_df['ShippedDate'].dt.to_period('M')
on_time_deliveries_counts = orders_df.groupby('Month').size().reset_index(name='Count')

# Use plotly for visualization
fig = px.bar(on_time_deliveries_counts, x='Month', y='Count', title='On-Time Deliveries in 2023')
show_to_user(fig)
```","The input Python code produces different results due to differences in the SQL query logic and visualization method. The reference code checks if orders were delivered on or before the RequiredDate, whereas the input code requires the ShippedDate to exactly match the RequiredDate. Additionally, the reference implementation visualizes each order using 'OrderID' and 'OrderDate', while the input code groups orders by month to show the count of on-time deliveries.",None
How many orders were placed by each customer in the last year? Please include a bar chart to visualize the distribution of orders by customer.,"```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are already implemented utilities

# SQL query to retrieve the number of orders by each customer in the last year
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= DATEADD(year, -1, CURRENT_DATE)
GROUP BY CustomerID;
""""""

# Execute the SQL query and obtain the results as a pandas DataFrame
orders_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the distribution of orders by customer
fig = px.bar(orders_data, x='CustomerID', y='OrderCount', 
             title='Number of Orders Placed by Each Customer in the Last Year',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'},
             template='plotly_white')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date one year ago from today
one_year_ago = datetime.now() - timedelta(days=365)
one_year_ago_str = one_year_ago.strftime('%Y-%m-%d')

# SQL query to get order counts by customer in the last year
sql_query = f""""""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= '{one_year_ago_str}'
GROUP BY CustomerID
""""""

# Execute the SQL query
order_counts_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the order distribution by customer
fig = px.bar(order_counts_df, x='CustomerID', y='OrderCount',
             title='Number of Orders Placed by Each Customer in the Last Year',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Show the data visualization
show_to_user(fig)
```","The input code correctly calculates the number of orders placed by each customer in the last year using a similar logic to the reference implementation. Both codes execute an SQL query to filter orders from the past year using the appropriate date function or calculation. The bar chart visualizing the order distribution by customer is created using Plotly, and the visualization is displayed using the `show_to_user` function. The differences in date calculation and label naming do not affect the correctness as they achieve the same outcome in line with the business request.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Implementation should connect to a database and execute the query
    # Here, we'll simulate returning a DataFrame with mock data
    return pd.DataFrame({
        'CustomerID': [1, 2, 3],
        'OrderCount': [5, 3, 7]
    })

# Utility function to show the result to the user
def show_to_user(data):
    # Placeholder function to display data or visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the number of orders per customer in the last year
sql_query = """"""
SELECT customers.CustomerID, 
       COUNT(orders.OrderID) AS OrderCount 
FROM customers 
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY customers.CustomerID;
""""""

# Executing the SQL query
orders_df = execute_sql_query(sql_query)

# Creating a bar chart to visualize the distribution of orders by customer
fig = px.bar(orders_df, x='CustomerID', y='OrderCount', title='Number of Orders by Customer in Last Year')

# Show the bar chart
show_to_user(fig)
```","The evaluated code correctly follows the logic of the reference implementation by capturing the number of orders each customer placed in the last year and visualizing the results in a bar chart. Despite differences such as SQL dialect (DATE_SUB vs DATEADD) and a LEFT JOIN, these adjustments align with common database query practices and do not affect the correctness of the result. The placeholder SQL execution effectively simulates returning expected data, and visualization logic is appropriately implemented with Plotly.",both
What is the average unit price for products from each supplier? Include a bar chart to compare the average unit prices.,"import plotly.express as px
import pandas as pd

# SQL query to fetch average unit price for products from each supplier
sql_query = """"""
SELECT s.SupplierID, AVG(p.UnitPrice) AS AverageUnitPrice 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID;
""""""

# Execute the SQL query and return the result as a DataFrame
average_unit_price_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to compare the average unit prices
fig = px.bar(
    average_unit_price_df, 
    x='SupplierID', 
    y='AverageUnitPrice', 
    title='Average Unit Price by Supplier',
    labels={'AverageUnitPrice': 'Average Unit Price', 'SupplierID': 'Supplier ID'}
)

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.SupplierID
""""""

average_prices_df = execute_sql_query(sql_query)

fig = px.bar(average_prices_df, x='SupplierID', y='AverageUnitPrice', 
             title='Average Unit Price for Products by Supplier',
             labels={'SupplierID': 'Supplier ID', 'AverageUnitPrice': 'Average Unit Price'})

show_to_user(fig)
```","The provided and reference implementations both calculate the average unit price for products from each supplier using a SQL query and present the results in a bar chart. The key difference is that the reference implementation explicitly joins the suppliers and products tables, which can be assumed to have the same logic if the 'SupplierID' is unique to each supplier in the 'products' table, thus not affecting the correctness for this context.","```python
import pandas as pd
import plotly.express as px

# SQL query to get average unit price by supplier
sql_query = """"""
SELECT SupplierID, AVG(UnitPrice) AS AveragePrice 
FROM products 
GROUP BY SupplierID;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit prices
fig = px.bar(df, x='SupplierID', y='AveragePrice', title='Average Unit Price by Supplier')

# Display the visualization to the user
show_to_user(fig)
```","The input code fetches average unit prices directly from the 'products' table without joining with the 'suppliers' table. The reference implementation joins the 'products' table with the 'suppliers' table to ensure the correct relationship. Thus, it might miss suppliers without products, or cross-supplier products might result in incorrect data segregation.",Base
How many units of each product have been ordered so far? Include a bar chart to visualize the quantity of each product ordered.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalOrdered 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName;
""""""

# Execute the SQL query and get the result as a DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(products_df, x='ProductName', y='TotalOrdered',
             title='Quantity of Each Product Ordered',
             labels={'ProductName': 'Product Name', 'TotalOrdered': 'Total Ordered Units'},
             text='TotalOrdered')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ProductName', y='TotalQuantity', title='Total Units Ordered per Product', labels={'TotalQuantity': 'Units Ordered', 'ProductName': 'Products'})
show_to_user(fig)
```","Both implementations correctly compute the total units ordered for each product using a SQL query that joins the 'products' and 'Order Details' tables, summing the quantity. They then visualize the results with a bar chart using Plotly. The difference in column names and other minor deviations do not affect the correctness regarding the task requirements.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query and get the results in a DataFrame
sql_query = ""SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalOrdered FROM [Order Details] JOIN products ON [Order Details].ProductID = products.ProductID GROUP BY products.ProductName;""
data = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(data, x='ProductName', y='TotalOrdered', title='Total Units Ordered by Product')

# Display the figure
show_to_user(fig)
```","The input code correctly answers the business analytics request by executing a SQL query that calculates the total quantity of each product ordered, just like the reference code. It then constructs a bar chart using Plotly to visualize this information, which matches the task requirement of providing a visual representation. The logic and end results are consistent with the reference implementation, despite slight differences in query formatting and chart labeling.",both
"What is the current stock level of each product, and can we visualize this data in a bar chart for better understanding?","```python
import pandas as pd
import plotly.express as px

# SQL Query to get current stock level of each product
sql_query = ""SELECT ProductName, UnitsInStock FROM products;""

# Execute the SQL query and get the result as a DataFrame
df_stock_levels = execute_sql_query(sql_query)

# Create a bar chart using Plotly for better understanding
fig = px.bar(df_stock_levels, x='ProductName', y='UnitsInStock', 
             title='Current Stock Level of Each Product',
             labels={'UnitsInStock': 'Units In Stock', 'ProductName': 'Product Name'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitsInStock
FROM products
WHERE Discontinued = 0
""""""
stock_data = execute_sql_query(sql_query)

fig = px.bar(stock_data, x='ProductName', y='UnitsInStock', title='Current Stock Level of Each Product', labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code includes a WHERE clause that filters products based on 'Discontinued = 0'. This differs from the reference implementation, which does not include this filter. Therefore, the input code will not produce results for all products, only those not discontinued, which does not adhere to the business request or logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL to get the current stock levels
sql_query = ""SELECT ProductID, UnitsInStock FROM products;""
stock_data = execute_sql_query(sql_query)

# Visualize the current stock level using a bar chart
fig = px.bar(stock_data, x='ProductID', y='UnitsInStock', 
             title='Current Stock Levels of Products', 
             labels={'ProductID': 'Product ID', 'UnitsInStock': 'Units in Stock'})

# Show the visualization to the user
show_to_user(fig)
```",The evaluated code uses 'ProductID' instead of 'ProductName' as the x-axis in the bar chart. This deviates from the business request of displaying product names. The SQL query should include 'ProductName' for alignment with the reference implementation and business requirement.,None
"    ""Identify products that need to be reordered based on their reorder level and present the findings with a visual representation of product reorder statuses.","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulation of SQL execution; in practice, connect to a database, execute the query, and fetch results.
    # Example: return pd.read_sql(sql_query, database_connection)
    pass

# Function to display the data
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query for identifying products that need to be reordered
sql_query = ""SELECT ProductName FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query
reorder_df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not reorder_df.empty:
    # Create a bar chart for product reorder statuses
    fig = px.bar(reorder_df, x='ProductName', title='Products to Reorder', labels={'ProductName': 'Product Name', 'value': 'Count'})

    # Display the chart using the utility function
    show_to_user(fig)
else:
    # If no products need reordering, output a message
    empty_df = pd.DataFrame({'Message': ['No products need to be reordered.']})
    show_to_user(empty_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0 AND UnitsInStock <= ReorderLevel
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='UnitsInStock', 
              title='Products Needing Reorder',
              labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'},
              text='UnitsInStock')

fig.add_scatter(x=data['ProductName'], y=data['ReorderLevel'], mode='lines+markers', 
                 name='Reorder Level', line=dict(color='red', dash='dash'))

show_to_user(fig)
```","The input code retrieves additional columns (ProductID, UnitsInStock, ReorderLevel) and includes a condition to filter out discontinued products (Discontinued = 0) which is not present in the reference. It also uses a scatter plot to overlay reorder levels, a feature not included in the reference code. These differences indicate it does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the utility function placeholders based on provided constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing the SQL query. It should return a DataFrame.
    # In practice, this function would interface with a database.
    pass

def show_to_user(data):
    # Placeholder for displaying data.
    # This could print DataFrames or render Plotly figures.
    pass

# SQL Query to fetch products needing reordering
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel;
""""""

# Execute the SQL query to get the DataFrame
reorder_df = execute_sql_query(sql_query)

# Correctly create a bar plot to visually represent the product reorder statuses
fig = px.bar(
    reorder_df,
    x='ProductName',
    y='UnitsInStock',
    title='Product Reorder Statuses',
    labels={'UnitsInStock': 'Units in Stock'},
    text='UnitsInStock'
)

# Add additional marker to the reorder level
fig.add_scatter(
    x=reorder_df['ProductName'],
    y=reorder_df['ReorderLevel'],
    mode='markers',
    marker=dict(color='red', size=10),
    name='Reorder Level',
    text='Reorder Level'
)

# Add annotations
for i in range(len(reorder_df)):
    fig.add_annotation(
        x=reorder_df['ProductName'][i],
        y=reorder_df['UnitsInStock'][i],
        text=f""Reorder: {reorder_df['ReorderLevel'][i]}"",
        showarrow=True,
        arrowhead=2,
        ax=0,
        ay=-40
    )

# Display the figure using the utility function
show_to_user(fig)
```","The input code does not fully match the logic of the reference implementation. The reference code selects products with `UnitsInStock <= ReorderLevel`, whereas the input code uses `UnitsInStock < ReorderLevel`. This subtle difference can affect which products are included in the result. Additionally, the input code's visualization includes additional markers and annotations not present in the reference, which may alter interpretation.",None
"Which customer placed the most orders, and can you provide a bar chart to visualize the comparison among top customers?","
import pandas as pd
import plotly.express as px

# Given SQL query for the top customer by number of orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query
# Use the provided execute_sql_query function to fetch data from the database
df = execute_sql_query(sql_query)

# Plot the results using Plotly
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Order Count by Customer', labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Use the utility function to show the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 10
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CustomerID', y='OrderCount', 
              title='Top 10 Customers by Number of Orders', 
              labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The input code limits the result to the top 10 customers, which deviates from the reference implementation that identifies the single customer with the most orders. The business request asks for the customer with the most orders and a visualization of the comparison among top customers, but the reference code handles only the most orders without limiting the output.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch the top 5 customers by number of orders
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) as OrderCount
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID
ORDER BY OrderCount DESC
LIMIT 5;
""""""

# Execute the SQL query
df_top_customers = execute_sql_query(sql_query)

# Create a bar chart to visualize top customers by number of orders
fig = px.bar(df_top_customers, x='CustomerID', y='OrderCount', 
             title='Top Customers by Number of Orders',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code retrieves the top 5 customers by number of orders, not the single customer with the most orders, which deviates from the business analytics request. The SQL query includes a LIMIT 5 clause, leading to more than one customer being selected, and the visualization reflects this by showing a comparison among the top 5 customers instead.",None
List all products that are currently out of stock and provide a bar chart showing the count of these products by category.,"```python
import pandas as pd
import plotly.express as px


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented elsewhere
    pass


def show_to_user(data):
    # This function is assumed to be implemented elsewhere
    pass


# Define the SQL query to retrieve out of stock products along with their categories
sql_query = """"""
SELECT ProductName, CategoryName 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE UnitsInStock = 0;
""""""

# Execute the SQL query to get the required data
out_of_stock_df = execute_sql_query(sql_query)

# Check if the dataframe is not empty
if not out_of_stock_df.empty:
    # Group the products by category and count the number of out-of-stock products
    category_count = out_of_stock_df['CategoryName'].value_counts().reset_index()
    category_count.columns = ['CategoryName', 'Count']

    # Create a bar chart using Plotly
    fig = px.bar(category_count, x='CategoryName', y='Count', title='Out of Stock Products by Category', 
                 labels={'Count': 'Number of Products', 'CategoryName': 'Category'})

    # Display the bar chart
    show_to_user(fig)
else:
    # If no data is available, show a message
    empty_df = pd.DataFrame({'Message': ['No products are currently out of stock.']})
    show_to_user(empty_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, p.CategoryID, c.CategoryName
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
WHERE p.UnitsInStock = 0 AND p.Discontinued = 0
""""""

out_of_stock_products = execute_sql_query(sql_query)

if not out_of_stock_products.empty:
    count_by_category = out_of_stock_products.groupby('CategoryName').size().reset_index(name='Count')
    fig = px.bar(count_by_category, x='CategoryName', y='Count', title='Count of Out of Stock Products by Category')
    show_to_user(fig)
else:
    print(""No products are currently out of stock."")
```","The input code adds an additional filter 'p.Discontinued = 0', which is not present in the reference code. This filter excludes discontinued products, thus potentially excluding items that the reference code considers out of stock. Therefore, the input code does not fully match the logic requested in the business analytics request as interpreted by the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch all products that are currently out of stock
sql_query = ""SELECT ProductName, Category FROM products WHERE UnitsInStock = 0;""

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str):
    # Placeholder for actual implementation
    # Example: return pd.read_sql_query(sql_query, connection)
    pass

# Utility function to display data analysis result
def show_to_user(data):
    # Placeholder for actual implementation
    # Example: if isinstance(data, pd.DataFrame): print(data)
    #          else: data.show()
    pass

# Execute the query and get the data
out_of_stock_df = execute_sql_query(sql_query)

# Count products by category
category_count = out_of_stock_df['Category'].value_counts().reset_index()
category_count.columns = ['Category', 'Count']

# Create a bar chart showing the count of out-of-stock products by category
fig = px.bar(category_count, x='Category', y='Count', title='Count of Out-of-Stock Products by Category')

# Display the bar chart to the user
show_to_user(fig)
```","The input code does not include a join operation with the categories table to fetch the CategoryName as the reference code does. It uses 'Category' directly from the products table, which may not exist or be incorrect according to the database schema assumed in the reference. This means the logic does not fully match the reference implementation, which ensures CategoryName is retrieved correctly via a join.",None
"What is the average order fulfillment time by region, and can this be visualized using a bar chart for clearer comparison?","```python
import plotly.express as px

# The SQL query to get average order fulfillment time by region
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipRegion;
""""""

# Execute the SQL query using the utility function
data = execute_sql_query(sql_query)

# Create a bar chart to visualize average order fulfillment time by region
fig = px.bar(data, x='ShipRegion', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Region',
             labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'ShipRegion': 'Region'})

# Display the bar chart using the show_to_user utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipRegion
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='ShipRegion', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Region',
             labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'ShipRegion': 'Region'})

show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It executes a SQL query to compute the average order fulfillment time by region using a similar query structure. The visualization steps are also similar, as it uses Plotly Express to create a bar chart with the same axes and labels, and displays it with the `show_to_user` function. The core functionality and data processing logic align with the reference.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get the average order fulfillment time by region
sql_query = """"""
SELECT ShipRegion, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY ShipRegion;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average fulfillment time by region
fig = px.bar(df, x='ShipRegion', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Region',
             labels={'ShipRegion': 'Region', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code successfully achieves the business analytics request and adheres to the same logic as the reference implementation. Both implementations run a similar SQL query to calculate the average order fulfillment time by region and then create a bar chart using Plotly Express. The differences, such as variable naming, do not affect the correctness of the code.",both
"Which city has the highest number of returning customers, and can you provide a bar chart to visualize the comparison across cities?","import pandas as pd
import plotly.express as px

# Define the utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation to illustrate structure
    # Replace with actual database query execution
    # Example using sqlite3 or other database connectors
    import sqlite3
    connection = sqlite3.connect('your_database.db')
    df = pd.read_sql_query(sql_query, connection)
    connection.close()
    return df

def show_to_user(data):
    # Display the data or visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get returning customers per city
sql_query = """"""
SELECT 
    customers.City, 
    COUNT(DISTINCT orders.CustomerID) AS returning_customers 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
WHERE 
    orders.CustomerID IN (
        SELECT o.CustomerID 
        FROM orders o 
        WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
    ) 
    AND orders.OrderDate < '2023-01-01' 
GROUP BY 
    customers.City 
ORDER BY 
    returning_customers DESC
""""""

# Execute the query and get the data
data = execute_sql_query(sql_query)

# Ensure the DataFrame is not empty before accessing the first element
if not data.empty:
    # Find the city with the highest number of returning customers
    max_returning_customers_city = data.iloc[0]

    # Print the result
    print(f""City with the highest number of returning customers: {max_returning_customers_city['City']}"")

    # Create a bar chart for visualization
    fig = px.bar(data, x='City', y='returning_customers', 
                 title='Number of Returning Customers by City', 
                 labels={'returning_customers': 'Returning Customers', 'City': 'City'},
                 text='returning_customers')

    # Display the bar chart
    show_to_user(fig)
else:
    print(""No data available."")","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.City, COUNT(DISTINCT o.CustomerID) AS returning_customers
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
WHERE o.CustomerID IN (
    SELECT CustomerID
    FROM orders
    WHERE OrderDate < '2023-01-01'
)
GROUP BY c.City
ORDER BY returning_customers DESC
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='City', y='returning_customers', title='Returning Customers by City')
show_to_user(fig)
```","The input code does not correctly identify returning customers as per the business analytics request. The reference implementation filters orders with customers who have placed orders both before and within the specified year (2023). The input SQL query only checks if there is any order placed before 2023, which is incorrect. Additionally, the input code does not print the city with the highest number of returning customers as in the reference code.","```python
import pandas as pd
import plotly.express as px

# Function to execute a SQL query and return a DataFrame
def execute_sql_query(sql_query):
    # Placeholder for database execution logic
    # This function should connect to the database, execute the query, and return the result as a DataFrame
    # Replace with actual database connection and query execution logic
    pass

# SQL query to find the number of returning customers by city
sql_query = """"""
SELECT c.City, COUNT(DISTINCT c.CustomerID) AS ReturningCustomers 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.City 
ORDER BY ReturningCustomers DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# If you need to filter the top city later, you could use df.iloc[0] after this.

# Plotting a bar chart using Plotly
fig = px.bar(df, x='City', y='ReturningCustomers', 
             title='Number of Returning Customers by City',
             labels={'ReturningCustomers': 'Returning Customers', 'City': 'City'})

# Showing the bar chart to the user
show_to_user(fig)
```","The input code does not filter returning customers based on past orders. It simply counts distinct customers per city without considering whether these customers are returning within a specific time frame as defined in the reference code. The reference implementation specifies returning customers as ones who ordered in 2023 and had previous orders before 2023, whereas the input code lacks this conditional logic.",None
"What is the average number of days late for orders shipped past the required date, and can this be visualized with a histogram to show the distribution of lateness?","
import plotly.express as px
import pandas as pd

# SQL Query to get the days late for orders
sql_query = """"""
SELECT DATEDIFF(ShippedDate, RequiredDate) AS DaysLate 
FROM orders 
WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query using the provided utility function
orders_df = execute_sql_query(sql_query)

# Calculate average days late
avg_days_late = orders_df['DaysLate'].mean()

# Display average days late
average_days_late_df = pd.DataFrame({'AvgDaysLate': [avg_days_late]})
show_to_user(average_days_late_df)

# Create and show histogram of the distribution of days late
fig = px.histogram(orders_df, x='DaysLate', title='Distribution of Days Late for Orders')
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATEDIFF(ShippedDate, RequiredDate) AS DaysLate
FROM orders
WHERE ShippedDate > RequiredDate
""""""
df = execute_sql_query(sql_query)

average_days_late = df['DaysLate'].mean()

histogram_fig = px.histogram(df, x='DaysLate', title='Distribution of Orders Lateness', labels={'DaysLate': 'Days Late'})
show_to_user(histogram_fig)

average_days_late
```","The input code correctly calculates the average number of days late and generates a histogram of the distribution, adhering to the logic of the reference. However, it does not display the average days late to the user using the `show_to_user` function, which is a part of the requirements in the reference implementation.","
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT 
    DATE_PART('day', ShippedDate - RequiredDate) AS DaysLate 
FROM 
    orders 
WHERE 
    ShippedDate > RequiredDate;
""""""

# Execute SQL query and fetch result
orders_df = execute_sql_query(sql_query)

# Calculate the average number of days late
avg_days_late = orders_df['DaysLate'].mean()

# Display average days late to user
show_to_user(pd.DataFrame({'AvgDaysLate': [avg_days_late]}))

# Visualize the distribution with a histogram
fig = px.histogram(orders_df, x='DaysLate', title='Distribution of Days Late for Shipped Orders')

# Show the histogram to the user
show_to_user(fig)
","The input Python code correctly calculates the average number of days late using the SQL query to extract 'DaysLate', computes the mean, and visualizes the distribution with a histogram, aligning with the business request and reference implementation. The difference in SQL syntax (DATE_PART vs. DATEDIFF) is due to the database dialect, which does not affect the correctness of the logic.",Finetuned
"Which employee has generated the highest sales revenue this year, and can this be shown with a bar chart comparing all employees' sales revenues?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Display the employee with the highest sales revenue
top_employee = df.head(1)

# Show the top employee to the user
show_to_user(top_employee)

# Create a bar chart for all employees' sales revenues
fig = px.bar(df, x='EmployeeID', y='TotalSales', title='Sales Revenue by Employee for the Current Year')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE())
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)

highest_sale_employee = sales_data.iloc[0]

bar_fig = px.bar(sales_data, 
                  x='FirstName' + ' ' + 'LastName', 
                  y='TotalSales', 
                  title='Sales Revenue by Employee for the Year',
                  labels={'FirstName': 'Employee Name', 'TotalSales': 'Sales Revenue'},
                  text='TotalSales')

show_to_user(bar_fig)
```","The input code adds 'FirstName' and 'LastName' for each employee but concatenates them incorrectly when defining the x-axis in the bar chart. The use of 'x='FirstName' + ' ' + 'LastName'' will not generate column names properly since it's attempting to concatenate strings rather than selecting DataFrame columns. This results in an error since it does not concatenate values from DataFrame columns. Instead, it should pass 'x='EmployeeName'' after creating a combined column for names in the DataFrame.","
import plotly.express as px
import pandas as pd

# SQL query to retrieve all employees' sales revenues for the current year
sql_query_all_sales = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN ""Order Details"" od ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY e.EmployeeID 
ORDER BY TotalSales DESC
""""""

# Execute the SQL query to get the sales data
df_sales = execute_sql_query(sql_query_all_sales)

# Identify the employee with the highest sales revenue
top_employee = df_sales.iloc[0]  # Top employee is the first row after sorting

# Display the top employee's details
show_to_user(pd.DataFrame([top_employee]))

# Create a bar chart comparing all employees' sales revenues
fig = px.bar(df_sales, x='EmployeeID', y='TotalSales',
             title='Total Sales Revenue by Employee for the Current Year',
             labels={'TotalSales': 'Total Sales Revenue', 'EmployeeID': 'Employee ID'})

# Show the bar chart
show_to_user(fig)
","The provided code correctly implements the logic as described in the reference implementation. It queries employees' sales revenues for the current year, identifies the employee with the highest sales by selecting the top row, and displays this employee's details. It also generates a bar chart displaying all employees' sales revenues. Both implementations retrieve, process, and visualize the data in a comparable manner.",Finetuned
List all orders where the freight cost exceeded $100 and create a bar chart to visualize the frequency of these orders by date.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch orders with freight cost over $100
sql_query = ""SELECT * FROM orders WHERE Freight > 100;""

# Function to execute the SQL query and get the result as a DataFrame
orders_df = execute_sql_query(sql_query)

# Ensure the 'OrderDate' column is in datetime format for grouping
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])

# Group by date and count the number of orders per day
orders_frequency_by_date = orders_df.groupby(orders_df['OrderDate'].dt.date).size().reset_index(name='Frequency')

# Create a bar chart using Plotly
fig = px.bar(orders_frequency_by_date, x='OrderDate', y='Frequency', title='Orders with Freight Cost Over $100 by Date')

# Display the result using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT OrderDate, COUNT(OrderID) as OrderCount FROM orders WHERE Freight > 100 GROUP BY OrderDate""
orders_exceeding_freight = execute_sql_query(sql_query)

fig = px.bar(orders_exceeding_freight, x='OrderDate', y='OrderCount', title='Frequency of Orders Exceeding $100 in Freight Cost', labels={'OrderDate': 'Order Date', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input code correctly executes a SQL query that fetches orders where the freight cost exceeds $100, grouping them by 'OrderDate' and counting the frequency of orders per date. It then creates a bar chart using Plotly to visualize these frequencies. This approach aligns with the logic of the reference implementation, which also filters orders by freight cost, groups by date, counts the frequency, and visualizes the data as a bar chart.","```python
import pandas as pd
import plotly.express as px

# Utility function

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration purposes
    # Replace this with the actual implementation to execute SQL and return DataFrame
    return pd.DataFrame({'OrderID': [1, 2, 3], 'Freight': [150.0, 200.0, 120.0], 'OrderDate': ['2023-01-01', '2023-01-02', '2023-01-01']})

def show_to_user(data):
    # Mock implementation for demonstration purposes
    # Replace this with the actual implementation to display the result
    print(data)

# SQL query to get orders with freight cost over $100
sql_query = ""SELECT * FROM orders WHERE Freight > 100;""

# Execute the query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Group by OrderDate and count the frequency of orders
frequency_by_date = df.groupby('OrderDate').size().reset_index(name='OrderFrequency')

# Create a bar chart using Plotly
fig = px.bar(frequency_by_date, x='OrderDate', y='OrderFrequency', title='Frequency of Orders with Freight > $100 by Date')

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly implements the same logic as the reference. It filters orders with freight costs over $100 using an SQL query, processes the results to count frequency by date, and creates a bar chart with Plotly. Although minor differences in variable names exist, the overall logic and output align with the reference implementation.",both
Which month had the highest number of late deliveries? Please include a bar chart to visualize the monthly late deliveries.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get monthly late deliveries
sql_query = """"""
    SELECT DATE_TRUNC('month', ShippedDate) AS Month, 
           COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) AS LateDeliveries 
    FROM orders 
    GROUP BY Month 
    ORDER BY LateDeliveries DESC;
""""""

# Execute the SQL query
monthly_late_deliveries_df = execute_sql_query(sql_query)

# Determine the month with the highest number of late deliveries
highest_late_deliveries_month = monthly_late_deliveries_df.iloc[0]

# Print out the month with highest late deliveries
show_to_user(
    pd.DataFrame([highest_late_deliveries_month])
)

# Create a bar chart to visualize the monthly late deliveries
fig = px.bar(
    monthly_late_deliveries_df, 
    x='Month', 
    y='LateDeliveries', 
    title='Monthly Late Deliveries',
    labels={'LateDeliveries': 'Number of Late Deliveries', 'Month': 'Month'}
)

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    COUNT(*) AS LateDeliveries
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    LateDeliveries DESC
LIMIT 1;
""""""

late_deliveries = execute_sql_query(sql_query)

month_with_highest_late_deliveries = late_deliveries.iloc[0]['Month']

sql_query_full = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    COUNT(*) AS LateDeliveries
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month;
""""""

monthly_late_deliveries = execute_sql_query(sql_query_full)

fig = px.bar(monthly_late_deliveries, x='Month', y='LateDeliveries', 
             title='Monthly Late Deliveries', 
             labels={'LateDeliveries': 'Number of Late Deliveries', 'Month': 'Month'})
show_to_user(fig)

month_with_highest_late_deliveries
```",Both the reference and input implementations achieve the task of identifying the month with the highest late deliveries and visualizing it with a bar chart. The input code uses a SQL query to select the top month separately and another query for the full month data to plot. The logic adheres to the same intent and outcome as the reference.,"```python
import pandas as pd
import plotly.express as px

# Assume the execute_sql_query and show_to_user functions are already implemented as per constraints.

# SQL Query to retrieve monthly late deliveries
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS LateDeliveries
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
ORDER BY Month;
""""""

# Execute SQL query and get a DataFrame
df_late_deliveries = execute_sql_query(sql_query)

# Find the month with the highest number of late deliveries
max_late_deliveries = df_late_deliveries[df_late_deliveries['LateDeliveries'] == df_late_deliveries['LateDeliveries'].max()]

# Display the DataFrame with the month with the highest late deliveries
show_to_user(max_late_deliveries)

# Create a bar chart to visualize the monthly late deliveries
fig = px.bar(df_late_deliveries, x='Month', y='LateDeliveries', title='Monthly Late Deliveries', labels={'LateDeliveries': 'Number of Late Deliveries'})
show_to_user(fig)
```","The input code uses 'OrderDate' instead of 'ShippedDate' for grouping, which doesn't match the reference logic focusing on 'ShippedDate'. Additionally, it incorrectly orders results by 'Month' and doesn't select the top month based on 'LateDeliveries'.",Base
Which supplier has the highest total revenue from product sales? Please include a bar chart to visualize the revenue comparison among suppliers.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch supplier revenue data
sql_query = """"""
SELECT s.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.CompanyName 
ORDER BY TotalRevenue DESC;
""""""

# Execute the SQL query using the provided utility function
supplier_revenue_df = execute_sql_query(sql_query)

# Create a bar chart to visualize revenue comparison among suppliers
fig = px.bar(supplier_revenue_df, 
             x='CompanyName', 
             y='TotalRevenue', 
             title='Total Revenue by Supplier',
             labels={'CompanyName': 'Supplier', 'TotalRevenue': 'Total Revenue'},
             height=400)

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalRevenue DESC
""""""

supplier_revenue_df = execute_sql_query(sql_query)
top_supplier = supplier_revenue_df.iloc[0]

fig = px.bar(supplier_revenue_df, x='CompanyName', y='TotalRevenue', title='Supplier Revenue Comparison')
show_to_user(fig)

top_supplier[['CompanyName', 'TotalRevenue']]
```","The input code correctly determines the supplier with the highest total revenue by performing an SQL query similar to the reference implementation. It joins the necessary tables, calculates the revenue, and groups by the supplier's company name. The use of `SupplierID` in the input code is an additional detail but does not affect the correctness of the logic. The bar chart is created using the same approach with Plotly Express, visualizing the revenue comparison among suppliers as specified. Therefore, the input code fulfills the business analytics request as per the reference logic.","```python
import plotly.express as px
import pandas as pd

# SQL query based on the given business analytical request
sql_query = """"""
SELECT s.SupplierID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID
ORDER BY TotalRevenue DESC;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Display the supplier with the highest total revenue
highest_revenue = df.iloc[0]
show_to_user(highest_revenue.to_frame().T)

# Create a bar chart to visualize revenue comparison among suppliers
fig = px.bar(df, x='SupplierID', y='TotalRevenue', 
             title='Total Revenue by Supplier',
             labels={'TotalRevenue': 'Total Revenue', 'SupplierID': 'Supplier ID'})

# Display the bar chart
show_to_user(fig)
```","The input Python code evaluates the supplier revenue by 'SupplierID' instead of 'CompanyName'. The business request specifies identifying the supplier (implying by name) with the highest total revenue, aligning with the reference implementation. The input code correctly calculates the revenue and plots a chart, but it does not align with the request to show supplier names, as in the reference implementation.",Base
Identify the top 3 employees by total sales in 2023 and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Function to execute SQL and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation; replace with actual database call
    # Assuming this function returns a DataFrame similar to the one described
    data = {
        'EmployeeID': [1, 2, 3],
        'FirstName': ['Alice', 'Bob', 'Charlie'],
        'LastName': ['Smith', 'Brown', 'Johnson'],
        'total_sales': [150000, 120000, 100000]
    }
    return pd.DataFrame(data)

# Function to show results to the user
def show_to_user(data):
    print(data)

# SQL query provided
sql_query = """"""
    SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    JOIN employees ON orders.EmployeeID = employees.EmployeeID
    WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
    GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
    ORDER BY total_sales DESC
    LIMIT 3
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Plot the results using a bar chart
fig = px.bar(df, x='LastName', y='total_sales', text='FirstName',
             title=""Top 3 Employees by Total Sales in 2023"",
             labels={'total_sales': 'Total Sales', 'LastName': 'Employee'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, 
       employees.FirstName, 
       employees.LastName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY total_sales DESC
LIMIT 3
""""""

top_employees = execute_sql_query(sql_query)

fig = px.bar(top_employees, 
              x=top_employees['FirstName'] + ' ' + top_employees['LastName'], 
              y='total_sales', 
              title='Top 3 Employees by Total Sales in 2023', 
              labels={'x': 'Employee', 'total_sales': 'Total Sales'})

show_to_user(fig)
```","The input Python code successfully retrieves the top 3 employees by total sales in 2023 using the provided SQL query, which matches the logic of the reference code. The input code correctly generates a bar chart visualizing the results. Although there is a slight difference in how employee names are concatenated in the x-axis, the essential functionality and logic remain the same as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function: this should be replaced with actual database connection and execution logic
    # Currently returning a sample DataFrame for demonstration
    return pd.DataFrame({'EmployeeID': [1, 2, 3], 'TotalSales': [3000, 2500, 2000]})

# Function to display the data analysis or visualization results
def show_to_user(data):
    # This function will either show a DataFrame or a Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query as per the business requirement
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = 2023
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 3;
""""""

# Execute the SQL query
top_employees_df = execute_sql_query(sql_query)

# Visualize the top 3 employees by total sales
fig = px.bar(top_employees_df, x='EmployeeID', y='TotalSales', 
             title='Top 3 Employees by Total Sales in 2023',
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales'})

show_to_user(fig)
```","The input code lacks the aggregation of employee names needed for the visualization, which is present in the reference code. The input code only uses 'EmployeeID' for visualization while the reference uses 'LastName' and includes 'FirstName' as text on the bars. This affects the business request's requirement for displaying top employees with names.",Base
"Which shipper was used the most last year, and can you provide a chart to visualize the usage distribution among all shippers?","
import pandas as pd
import plotly.express as px

# Define the utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should interact with the database and return the result as a pandas DataFrame
    # For this example, we mock the returned DataFrame
    simulated_data = {
        'ShipVia': [1, 2, 3],  # Example shipper IDs
        'ShipCount': [120, 95, 60]  # Example shipment counts
    }
    return pd.DataFrame(simulated_data)

def show_to_user(data):
    # This function should display data or visualizations to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get shipment counts per shipper for the last year
sql_query_distribution = """"""
SELECT o.ShipVia, COUNT(o.OrderID) AS ShipCount 
FROM orders o 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY o.ShipVia 
ORDER BY ShipCount DESC;
""""""

# Execute the SQL query
df_shippers = execute_sql_query(sql_query_distribution)

# Get the top shipper by evaluating the first row
most_used_shipper = df_shippers.iloc[0]

# Print the most used shipper
print(""Most Used Shipper ID:"", most_used_shipper['ShipVia'])

# Visualize the distribution among all shippers
fig = px.bar(df_shippers, x='ShipVia', y='ShipCount', title='Shipper Usage Distribution')
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS UsageCount
FROM orders
WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE) - 1
GROUP BY ShipVia
ORDER BY UsageCount DESC
""""""

usage_data = execute_sql_query(sql_query)

most_used_shipper = usage_data.iloc[0]

fig = px.bar(usage_data, x='ShipVia', y='UsageCount', title='Shipper Usage Distribution Last Year', labels={'ShipVia': 'Shipper', 'UsageCount': 'Number of Orders'})
show_to_user(fig)

most_used_shipper
```","The input Python code effectively performs the same operations as the reference implementation. It correctly constructs the SQL query to retrieve shipment counts for each shipper from the previous year, executes the query, identifies the most used shipper by taking the top row, and visualizes the data using a bar chart. Thus, it adheres to the business request and the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Business analysis code
# SQL query to find the most used shipper last year
sql_query_max_used_shipper = """"""
SELECT ShipVia, COUNT(order_id) AS usage_count 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY ShipVia 
ORDER BY usage_count DESC
LIMIT 1
""""""

# Execute the SQL query
max_used_shipper_df = execute_sql_query(sql_query_max_used_shipper)

# Inform the user of the most used shipper
show_to_user(max_used_shipper_df)

# SQL query to get the complete usage distribution among all shippers
sql_query_usage_distribution = """"""
SELECT ShipVia, COUNT(order_id) AS usage_count 
FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY ShipVia
""""""

# Execute the SQL query
usage_distribution_df = execute_sql_query(sql_query_usage_distribution)

# Create a bar chart to visualize the usage distribution
fig = px.bar(usage_distribution_df, x='ShipVia', y='usage_count', 
             title='Shipper Usage Distribution for Last Year',
             labels={'ShipVia': 'Shipper', 'usage_count': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)
```","Both the reference and input implementations correctly retrieve and display the most used shipper and the distribution of shipments among all shippers. The input code correctly queries the database to get the most used shipper from last year by limiting the results to 1 after ordering by usage count. It also constructs a distribution for all shippers used last year and visualizes this data using a bar chart, which matches the logic of the reference implementation.",both
"Who are the top five customers by total ordered quantity? Additionally, provide a bar chart to visualize the ordered quantities of these top customers.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, SUM([Order Details].Quantity) AS TotalQuantity
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY customers.CustomerID
ORDER BY TotalQuantity DESC
LIMIT 5;
""""""

# Execute the SQL query
df_top_customers = execute_sql_query(sql_query)

# Display the top customers data
show_to_user(df_top_customers)

# Create a bar chart to visualize the ordered quantities of top customers
fig = px.bar(df_top_customers, x='CustomerID', y='TotalQuantity', 
             title='Top 5 Customers by Total Ordered Quantity')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, SUM(od.Quantity) AS TotalOrderedQuantity
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalOrderedQuantity DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CompanyName', y='TotalOrderedQuantity', title='Top 5 Customers by Total Ordered Quantity')
show_to_user(fig)
```","The input code correctly fulfills the business request to find the top five customers by total ordered quantity and create a bar chart to visualize the data. It uses a SQL query to aggregate the order quantities by customer and orders them in descending order, limiting the results to the top five. The code includes CompanyName in the grouping and visualization, which provides additional context but does not alter the logic to achieve the request. The generated bar chart uses the correct fields for display, consistent with the reference implementation's objectives.","```python
import pandas as pd
import plotly.express as px

# Mocked function to execute SQL and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to connect to your SQL database and execute the query
    pass

# Mocked function to show data to user
def show_to_user(data):
    # This function should handle displaying the data or figure
    pass

# SQL query for retrieving top 5 customers by ordered quantity
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].Quantity) AS total_order_quantity 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY total_order_quantity DESC 
LIMIT 5
""""""

# Execute SQL query to get data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, 
             x='CustomerID', 
             y='total_order_quantity', 
             title='Top 5 Customers by Total Ordered Quantity',
             labels={'total_order_quantity': 'Total Ordered Quantity', 
                     'CustomerID': 'Customer ID'})

# Display the figure to the user
show_to_user(fig)
```","The input code correctly replicates the functionality of the reference implementation. Both codes perform the same SQL query to determine the top five customers by total ordered quantity, execute this query to obtain the dataframe, and use Plotly to create and display a bar chart of these quantities. The SQL logic and chart creation are consistent across both implementations.",both
Compare shipping costs across different shipping companies using a bar chart or line graph.,"```python
import pandas as pd  
import plotly.express as px  

# Sample utility function for executing SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock data to simulate the SQL query result for demonstration
    data = {
        'CompanyName': ['Company A', 'Company B', 'Company C'],
        'avg_shipping_cost': [20.5, 30.75, 25.0],
    }
    return pd.DataFrame(data)

# Sample utility function for showing the result to the user
def show_to_user(data):
    # This function would display the plot if it was a Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# SQL query to get the average shipping cost by company
sql_query = """"""
SELECT shippers.CompanyName, AVG(orders.Freight) AS avg_shipping_cost 
FROM shippers 
JOIN orders ON shippers.ShipperID = orders.ShipVia 
GROUP BY shippers.CompanyName
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='avg_shipping_cost', title='Average Shipping Costs by Company')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Shippers.CompanyName, AVG(orders.Freight) AS Average_Shipping_Cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY Shippers.CompanyName
""""""

shipping_costs_df = execute_sql_query(sql_query)

fig = px.bar(shipping_costs_df, x='CompanyName', y='Average_Shipping_Cost', title='Average Shipping Costs by Company')
show_to_user(fig)
```","The input code generates a bar chart using Plotly to compare average shipping costs across companies, matching the business request. It executes a SQL query to retrieve the relevant data, creates a bar chart with the required parameters, and then shows it to the user. The logic aligns with the reference implementation despite minor differences, such as column alias naming ('Average_Shipping_Cost' in input and 'avg_shipping_cost' in reference). These differences do not affect the outcome.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch data
sql_query = """"""
SELECT 
    o.ShipVia, 
    AVG(o.Freight) AS AverageFreight 
FROM 
    orders o 
GROUP BY 
    o.ShipVia 
ORDER BY 
    AverageFreight DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize average shipping costs across different companies
fig = px.bar(df, 
             x='ShipVia', 
             y='AverageFreight', 
             title='Average Shipping Costs by Shipping Company',
             labels={'ShipVia': 'Shipping Company', 'AverageFreight': 'Average Freight Cost'},
             color='AverageFreight',
             text='AverageFreight')

# Display the bar chart
show_to_user(fig)
```","The input Python code does not correctly match the business analytics request based on the reference implementation. The input code uses 'ShipVia' from the 'orders' table directly without joining to 'shippers' to get 'CompanyName', which results in using 'ShipperID' instead of 'CompanyName'. While both code snippets create a bar chart of average shipping costs, the input code labels the x-axis with numeric 'ShipVia' values instead of company names, which does not fulfill the request to compare shipping costs across different shipping companies by name as depicted in the reference implementation.",Base
"How many units of discontinued products are still in stock, and can this be visualized using a bar chart by product category?","```python
import pandas as pd
import plotly.express as px

# SQL query to get units in stock of discontinued products by category
sql_query = """"""
SELECT CategoryName, SUM(UnitsInStock) AS TotalUnitsInStock
FROM products
JOIN categories ON products.CategoryID = categories.CategoryID
WHERE Discontinued = 1
GROUP BY CategoryName;
""""""

# Execute the query and get the result as a DataFrame
discontinued_products_df = execute_sql_query(sql_query)

# Generate a bar chart visualization using Plotly
fig = px.bar(discontinued_products_df, 
             x='CategoryName', 
             y='TotalUnitsInStock',
             title='Units in Stock of Discontinued Products by Category',
             labels={'TotalUnitsInStock':'Units in Stock', 'CategoryName':'Product Category'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(p.UnitsInStock) AS TotalUnitsInStock
FROM products p
WHERE p.Discontinued = 1
GROUP BY p.CategoryID
""""""

discontinued_products_df = execute_sql_query(sql_query)

fig = px.bar(discontinued_products_df, x='CategoryID', y='TotalUnitsInStock', title='Units of Discontinued Products by Category')
show_to_user(fig)
```","The input code uses 'CategoryID' for grouping and plotting, while the reference uses 'CategoryName'. The reference code joins with the 'categories' table to get 'CategoryName', which is crucial for the analysis. The input code fails to match this logic, as it does not join with the 'categories' table and therefore, the output does not show categories by name, impacting clarity and accuracy.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for example purposes
    # Replace this with actual database connection and query execution logic
    return pd.DataFrame({
        'ProductName': ['ProductA', 'ProductB', 'ProductC'],
        'UnitsInStock': [10, 5, 0],
        'Category': ['Category1', 'Category2', 'Category1']
    })

# Function to display data analysis or visualization results
def show_to_user(data):
    # Dummy implementation for example purposes
    # This will display a DataFrame or a Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the units in stock for discontinued products
sql_query = """"""
SELECT ProductName, SUM(UnitsInStock) AS UnitsInStock, Category
FROM products
WHERE Discontinued = 1
GROUP BY ProductName, Category;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Filter DataFrame to only include products with units in stock
df_in_stock = df[df['UnitsInStock'] > 0]

# Create a bar chart for the units in stock grouped by product category
fig = px.bar(
    df_in_stock,
    x='Category',
    y='UnitsInStock',
    color='Category',
    title='Units of Discontinued Products Still in Stock by Product Category'
)

# Display the bar chart
show_to_user(fig)
```","The input code does not aggregate the units in stock by category, as required by the business analytics request. Instead, it groups by both product name and category, hence potentially providing a different result than the reference code. The query should only aggregate by category to get the total units in stock for each category. Additionally, the reference code ensures the data is grouped solely by CategoryName, which matches the business requirement.",None
"Find the most recent order details for a specific customer and present them in an easy-to-understand visual format, such as a dashboard or chart.","```python
import pandas as pd
import plotly.express as px

# Utility function stubs (to be defined in the actual environment)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the SQL query and return a pandas DataFrame.
    pass

def show_to_user(data):
    # This function should display the data or Plotly figure to the user.
    pass

# SQL query to find the most recent order details for a specific customer
sql_query = """"""
SELECT customers.CustomerID, orders.OrderID, orders.OrderDate 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE customers.CustomerID = 'specific_customer_id' 
ORDER BY orders.OrderDate DESC LIMIT 1;
""""""

# Execute the SQL query and get the results as a pandas DataFrame
order_details_df = execute_sql_query(sql_query)

# Verify if the DataFrame is not empty
if not order_details_df.empty:
    # Visualize the most recent order in a table format using Plotly
    fig = px.scatter(order_details_df, x='OrderID', y='OrderDate', text='CustomerID', title='Most Recent Order Details')
    
    # Customize the chart for display
    fig.update_traces(textposition='top center')
    fig.update_layout(showlegend=False)
    
    # Show the result to the user
    show_to_user(fig)
else:
    # Handle the case where no data is returned
    print(""No recent orders found for the specified customer."")
```","```python
import pandas as pd
import plotly.express as px

customer_id = 'SPECIFIC_CUSTOMER_ID'

sql_query = f""""""
SELECT o.OrderID, o.OrderDate, o.ShipName, o.ShipAddress, o.ShipCity, o.ShipCountry,
       od.UnitPrice, od.Quantity, od.Discount, 
       (od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalPrice
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.CustomerID = '{customer_id}'
ORDER BY o.OrderDate DESC
LIMIT 1
""""""

recent_order = execute_sql_query(sql_query)

if not recent_order.empty:
    fig = px.bar(recent_order, x='OrderID', y='TotalPrice', 
                  title=f'Recent Order Details for Customer ID: {customer_id}',
                  labels={'TotalPrice': 'Total Price', 'OrderID': 'Order ID'})
    show_to_user(fig)
```","The input code retrieves different details compared to the reference code. It fetches order details including unit price, quantity, discount, and calculates 'TotalPrice', which is not in the reference. The visualizations also differ: the input code uses a bar chart of total price against order ID, while the reference uses a scatter plot of order date against order ID. These deviations suggest different data intentions and visual presentations.","
import pandas as pd
import plotly.express as px

# Utility functions - to be implemented based on environment specifics
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assumed to be implemented to execute an SQL query and return a DataFrame
    # This function would normally connect to the database, execute the query and fetch the results.
    pass

def show_to_user(data):
    # Assumed to be implemented to display data analysis or visualization results
    # Can handle both Pandas DataFrame and Plotly Figure
    pass

# SQL query execution
customer_id = '123'  # Replace with actual customer ID
sql_query = f""""""
SELECT OrderID, OrderDate, ShippedDate, Status 
FROM orders 
WHERE CustomerID = '{customer_id}' 
ORDER BY OrderDate DESC 
LIMIT 1;
""""""

# Fetch data as DataFrame
recent_order_df = execute_sql_query(sql_query)

# Display data as is
show_to_user(recent_order_df)

# Optionally, create a visualization using Plotly
fig = px.bar(
    recent_order_df, 
    x='OrderID', 
    y=['OrderDate', 'ShippedDate'], 
    title='Most Recent Order Details',
    labels={'value': 'Date', 'variable': 'Type'}
)

# Enhance the dashboard or chart layout
fig.update_layout(barmode='group')

# Display the figure
show_to_user(fig)
","The input code does not fully align with the business analytics request. Although it retrieves the latest order details, it includes additional fields (ShippedDate, Status) not specified in the reference code. The visualization uses a bar chart on different date fields instead of a scatter plot focusing on the latest order. Additionally, the input code lacks error handling when no recent orders are found for a specific customer, which is handled in the reference code.",None
"Find the product with the largest discrepancy between units in stock and on order, and visualize the discrepancies for all products in a bar chart.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to find the product with the largest discrepancy.
query = """"""
SELECT ProductID, ProductName, UnitsInStock, UnitsOnOrder 
FROM products
""""""
products_df = execute_sql_query(query)

# Add a new column for the discrepancy between UnitsInStock and UnitsOnOrder
products_df['Discrepancy'] = abs(products_df['UnitsInStock'] - products_df['UnitsOnOrder'])

# Find the product with the largest discrepancy
largest_discrepancy_product = products_df.loc[products_df['Discrepancy'].idxmax(), 'ProductName']
print(f""Product with the largest discrepancy: {largest_discrepancy_product}"")

# Visualize discrepancies for all products
fig = px.bar(products_df, x='ProductName', y='Discrepancy', 
             title='Discrepancies between Units In Stock and On Order for Products',
             labels={'Discrepancy': 'Discrepancy (Units In Stock - Units On Order)'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get UnitsInStock and UnitsOnOrder for all products
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, UnitsOnOrder
FROM products
WHERE Discontinued = 0
""""""
products_df = execute_sql_query(sql_query)

# Calculate discrepancies
products_df['Discrepancy'] = products_df['UnitsInStock'] - products_df['UnitsOnOrder']

# Find the product with the largest discrepancy
largest_discrepancy = products_df.loc[products_df['Discrepancy'].idxmax()]

# Visualizing discrepancies for all products
fig = px.bar(products_df, x='ProductName', y='Discrepancy',
             title='Discrepancy between Units in Stock and On Order',
             labels={'Discrepancy': 'Discrepancy', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code filters out discontinued products (`WHERE Discontinued = 0`), while the reference code does not apply this filter. This affects the dataset being analyzed, which could lead to a different product being identified as having the largest discrepancy. Additionally, the input code computes discrepancies without taking the absolute value, unlike the reference code which uses `abs()`. This impacts the calculation of discrepancies and might lead to incorrect identification of the product with the largest discrepancy.","```python
import pandas as pd
import plotly.express as px

# Suppose there's a function to execute SQL queries
def execute_sql_query(sql_query: str):
    # This function is assumed to return a DataFrame from executing the SQL query
    pass

# Execute the SQL query to fetch the product with the maximum discrepancy
sql_query_max_discrepancy = """"""
SELECT ProductID, (UnitsInStock - UnitsOnOrder) AS Discrepancy 
FROM products 
ORDER BY Discrepancy DESC 
LIMIT 1;
""""""

# Execute the query and get the highest discrepancy
max_discrepancy_df = execute_sql_query(sql_query_max_discrepancy)

# Create a DataFrame to fetch all products and their discrepancies
sql_query_all_discrepancies = """"""
SELECT ProductID, (UnitsInStock - UnitsOnOrder) AS Discrepancy 
FROM products;
""""""

# Execute the query to fetch all discrepancies
all_discrepancies_df = execute_sql_query(sql_query_all_discrepancies)

# Visualize discrepancies for all products using a bar chart
fig = px.bar(
    all_discrepancies_df,
    x='ProductID',
    y='Discrepancy',
    title='Discrepancy between Units In Stock and On Order for All Products',
    labels={'Discrepancy': 'Discrepancy'}
)

# Show the visualization
show_to_user(fig)
```","The input code calculates the discrepancy as UnitsInStock - UnitsOnOrder, rather than the absolute difference as in the reference. The reference code uses absolute differences to identify the product with the largest discrepancy and visualizes discrepancies with product names. The input code also sorts and limits directly in SQL, while the reference calculates discrepancies in Python, providing more flexibility to visualize with product names rather than IDs.",None
What are the monthly shipping costs across different shipping methods? Please include a comparison chart for better visualization.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get the required data
sql_query = """"""
SELECT EXTRACT(YEAR FROM orders.OrderDate) AS year, 
       EXTRACT(MONTH FROM orders.OrderDate) AS month, 
       orders.ShipVia, 
       AVG(orders.Freight) AS avg_shipping_cost 
FROM orders 
GROUP BY year, month, orders.ShipVia
""""""

# Execute the SQL query and return a DataFrame
df = execute_sql_query(sql_query)

# Ensure the 'year' and 'month' are integers for proper processing
df['year'] = df['year'].astype(int)
df['month'] = df['month'].astype(int)

# Create a new column with a formatted month-year string for better labels
df['month_year'] = df.apply(lambda row: f""{row['year']}-{row['month']:02}"", axis=1)

# Visualize the monthly average shipping cost across different shipping methods
fig = px.line(
    df, 
    x='month_year', 
    y='avg_shipping_cost', 
    color='ShipVia', 
    title='Monthly Shipping Costs across Different Shipping Methods',
    labels={'avg_shipping_cost': 'Average Shipping Cost', 'month_year': 'Month-Year'}
)

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly shipping costs across different shipping methods
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    shippers.CompanyName AS shipping_method,
    SUM(orders.Freight) AS total_shipping_cost
FROM 
    orders 
JOIN 
    shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY 
    month, shipping_method
ORDER BY 
    month, shipping_method
""""""

# Execute the SQL query and store the result in a DataFrame
shipping_costs_df = execute_sql_query(sql_query)

# Create a comparison chart using Plotly
fig = px.bar(shipping_costs_df, x='month', y='total_shipping_cost', color='shipping_method',
             title='Monthly Shipping Costs Across Different Shipping Methods',
             labels={'total_shipping_cost': 'Total Shipping Cost', 'month': 'Month'})

# Show the plot to the user
show_to_user(fig)
```","The provided code calculates the total shipping cost for each shipping method per month, while the reference code calculates the average shipping cost. Additionally, the reference code uses a line chart for comparison, whereas the provided code uses a bar chart.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT 
    MONTH(OrderDate) AS Month, 
    ShipVia, 
    SUM(Freight) AS TotalShippingCost 
FROM 
    orders 
GROUP BY 
    MONTH(OrderDate), ShipVia;
""""""

# Execute the SQL query through the utility function
shipping_data = execute_sql_query(sql_query)

# Create a comparison chart using Plotly
fig = px.line(
    shipping_data, 
    x='Month', 
    y='TotalShippingCost', 
    color='ShipVia', 
    title='Monthly Shipping Costs Across Different Shipping Methods',
    labels={'TotalShippingCost': 'Total Shipping Cost', 'Month': 'Month'},
    markers=True
)

# Display the chart
show_to_user(fig)
```","The input code calculates the total shipping cost per month, while the reference code calculates the average shipping cost per month. Additionally, the input code does not extract the year from the order date, which could lead to incorrect grouping across months from different years.",None
"Identify the customers with the highest order frequency in the last year, and provide a bar chart to visualize the top customers by order frequency.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are predefined utility functions

# SQL Query to identify top customers by order frequency
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderFrequency
FROM orders
WHERE OrderDate > CURRENT_DATE - INTERVAL '1 year'
GROUP BY CustomerID
ORDER BY OrderFrequency DESC
LIMIT 10;
""""""

# Execute the query and get the results in a DataFrame
customer_order_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top customers by order frequency
fig = px.bar(
    customer_order_df,
    x='CustomerID',
    y='OrderFrequency',
    title='Top Customers by Order Frequency in the Last Year',
    labels={'CustomerID': 'Customer ID', 'OrderFrequency': 'Order Frequency'},
    text='OrderFrequency'
)

# Display the figure using the show_to_user utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

end_date = datetime.now()
start_date = end_date - timedelta(days=365)

sql_query = f""""""
SELECT 
    c.CustomerID,
    c.CompanyName,
    COUNT(o.OrderID) AS OrderFrequency
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
WHERE 
    o.OrderDate BETWEEN '{start_date.strftime(""%Y-%m-%d"")}' AND '{end_date.strftime(""%Y-%m-%d"")}'
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    OrderFrequency DESC
LIMIT 10
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, 
              x='CompanyName', 
              y='OrderFrequency', 
              title='Top Customers by Order Frequency in the Last Year',
              labels={'OrderFrequency': 'Order Frequency', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The input code correctly identifies the customers with the highest order frequency in the last year. It uses the current date to define the date range and counts the number of orders per customer using a SQL query, similar to the reference implementation. Additionally, it generates a bar chart with Plotly Express to visualize the results. The main difference is that the input code displays the company name instead of the customer ID, but this adheres to the logic of identifying top customers by order frequency.","```python
import pandas as pd
import plotly.express as px

# Simulated utility function to execute SQL queries, replace with actual implementation.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for illustration purposes
    # This would normally execute the SQL query against a database and return the result as a DataFrame
    data = {
        'CustomerID': ['CUST1', 'CUST2', 'CUST3', 'CUST4'],
        'OrderFrequency': [15, 12, 10, 8]
    }
    return pd.DataFrame(data)

# Execute the SQL query to get the top customers by order frequency
sql_query = """"""
SELECT orders.CustomerID, COUNT(orders.OrderID) AS OrderFrequency
FROM orders
WHERE orders.OrderDate >= CURRENT_DATE - INTERVAL '1 YEAR'
GROUP BY orders.CustomerID
ORDER BY OrderFrequency DESC
LIMIT 10
""""""

# Fetch the data
customer_order_frequency_df = execute_sql_query(sql_query)

# Visualize with a bar chart using Plotly
fig = px.bar(
    customer_order_frequency_df,
    x='CustomerID',
    y='OrderFrequency',
    title='Top Customers by Order Frequency in the Last Year',
    labels={'OrderFrequency': 'Order Frequency', 'CustomerID': 'Customer ID'},
    text='OrderFrequency'
)

# Display the bar chart
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It selects customer IDs and their order frequencies over the last year, groups by customer, sorts by frequency, and limits the result to the top 10. The bar chart creation and display logic are consistent with the reference code, making the implementation correct relative to the business analytics request.",both
"What is the total revenue contribution from each supplier, and can we visualize the results to compare contributions effectively?","# Python Code remains unchanged

```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve data
sql_query = """"""
SELECT s.SupplierID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID;
""""""

# Function to execute the SQL query and retrieve the data
def get_data(sql_query: str) -> pd.DataFrame:
    return execute_sql_query(sql_query)

# Fetch the data
data = get_data(sql_query)

# Create a bar plot to visualize the total revenue contribution from each supplier
fig = px.bar(data, x='SupplierID', y='TotalRevenue', title='Total Revenue Contribution per Supplier')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalRevenue DESC;
""""""

supplier_revenue_df = execute_sql_query(sql_query)

fig = px.bar(supplier_revenue_df, 
             x='CompanyName', 
             y='TotalRevenue', 
             title='Total Revenue Contribution from Each Supplier',
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier'},
             text='TotalRevenue')

show_to_user(fig)
```","The input Python code adheres to the logic of the reference code by calculating the total revenue per supplier, joining the necessary tables (suppliers, products, order details), and summing up the revenue for each supplier. It includes additional features such as ordering by total revenue and using company names for visualization, which are enhancements but do not violate the logic of the reference implementation. The visualization with plotly.express is consistent with the request to compare contributions effectively.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Revenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY suppliers.CompanyName;
""""""

# Function to fetch data
def fetch_data(sql_query: str) -> pd.DataFrame:
    # Mocked data returned from an SQL query
    # Replace this with actual logic to execute the query and fetch the data.
    data = {
        'CompanyName': ['Supplier A', 'Supplier B', 'Supplier C'],
        'Revenue': [15000, 23000, 12000]
    }
    return pd.DataFrame(data)

# Fetch the data
data = fetch_data(sql_query)

# Visualization of revenue contributions by supplier
fig = px.bar(data, x='CompanyName', y='Revenue', title='Total Revenue Contribution by Supplier')

# Placeholder to show the result to the user
def show_to_user(data):
    # This function is supposed to display the Pandas DataFrame or Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        # Assuming a Plotly figure is passed
        data.show()

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly calculates the total revenue contribution from each supplier. Despite using 'CompanyName' instead of 'SupplierID', it aligns with grouping suppliers and calculating revenue, providing a similar output structure. The visualization logic remains consistent with the request to compare contributions through a bar plot. The mock implementation of `fetch_data` is appropriate for evaluation purposes.",both
Determine the average reorder level for each category and create a bar chart to visualize the differences among categories.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT c.CategoryName, AVG(p.ReorderLevel) AS AverageReorderLevel
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryName;
""""""

# Execute the SQL query and store the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize average reorder level by category
fig = px.bar(df, x='CategoryName', y='AverageReorderLevel',
             title='Average Reorder Level by Category',
             labels={'CategoryName': 'Category', 'AverageReorderLevel': 'Avg Reorder Level'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.ReorderLevel) AS AverageReorderLevel
FROM products p
GROUP BY p.CategoryID
""""""

average_reorder_levels = execute_sql_query(sql_query)

fig = px.bar(average_reorder_levels, x='CategoryID', y='AverageReorderLevel', 
             title='Average Reorder Level by Category', 
             labels={'CategoryID': 'Category ID', 'AverageReorderLevel': 'Average Reorder Level'})
show_to_user(fig)
```","The input code does not correctly fulfill the business analytics request due to the omission of joining with the categories table to get category names instead of Category IDs. The reference implementation joins the products with categories to calculate the average reorder level per category name, whereas the input code only works with Category IDs without joining, leading to incorrect labeling and missing the requirement to group by category names.","```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = ""SELECT CategoryID, AVG(ReorderLevel) AS AvgReorderLevel FROM products GROUP BY CategoryID;""

# Execute the SQL query and retrieve the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating the data retrieval, to be replaced with actual database access code
    return pd.read_sql_query(sql_query, con)

# Simulated function for executing the query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented elsewhere in the environment
    pass

# Simulated function for showing the plot
def show_to_user(data):
    # This function is assumed to be implemented elsewhere in the environment
    pass

# Getting the average reorder level data
df = execute_sql_query(sql_query)

# Creating a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='AvgReorderLevel',
             title='Average Reorder Level by Category',
             labels={'AvgReorderLevel': 'Average Reorder Level', 'CategoryID': 'Category ID'})

# Display the bar chart
show_to_user(fig)
```","The input code calculates the average reorder level based on CategoryID instead of CategoryName. It does not join the categories table to get the CategoryName, thus not fulfilling the business request correctly. The plotting also labels categories by ID instead of name, which differs from the reference implementation.",None
"What is the product performance metric for the last six months, and can it be visualized using a trend line graph or bar chart?","```python
import pandas as pd
import plotly.express as px


def get_product_performance():
    # SQL query to retrieve performance metrics for the last six months
    sql_query = """"""
    SELECT p.ProductID, SUM(od.Quantity) AS PerformanceMetric 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    WHERE od.OrderDate >= DATEADD(month, -6, CURRENT_DATE) 
    GROUP BY p.ProductID;
    """"""

    # Execute the SQL query
    df = execute_sql_query(sql_query)

    # Visualize using a bar chart for better understanding
    fig = px.bar(df, x='ProductID', y='PerformanceMetric', 
                 title=""Product Performance Metrics for Last Six Months"",
                 labels={'PerformanceMetric': 'Performance Metric', 'ProductID': 'Product ID'})
    
    # Show the visualization to the user
    show_to_user(fig)

# Run the function to get the product performance and visualize it
get_product_performance()
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the date range for the last six months
end_date = datetime.now()
start_date = end_date - timedelta(days=180)

# SQL query to retrieve product performance data
sql_query = f""""""
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_TRUNC('month', o.OrderDate) AS Month, 
    SUM(od.Quantity) AS TotalQuantitySold
FROM 
    products p
JOIN 
    ""[Order Details]"" od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate >= '{start_date.strftime('%Y-%m-%d')}' AND o.OrderDate <= '{end_date.strftime('%Y-%m-%d')}'
GROUP BY 
    p.ProductID, p.ProductName, Month
ORDER BY 
    Month, p.ProductID;
""""""

# Execute the SQL query and get the data
product_performance_df = execute_sql_query(sql_query)

# Visualize the data using a line graph
fig = px.line(product_performance_df, x='Month', y='TotalQuantitySold', color='ProductName',
              title='Product Performance Metric for the Last Six Months',
              labels={'TotalQuantitySold': 'Total Quantity Sold', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)
```","The input code differs from the reference implementation in both the SQL query and the type of visualization. The reference code calculates a performance metric based solely on ProductID and sums the quantities over the last six months, showing this in a bar chart. In contrast, the input code includes ProductName and Date truncated to months, grouping by both and showing the result as a line graph. This changes the logic and visual representation, as it implies a trend over individual months rather than an aggregated metric. Therefore, the input code does not follow the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Predefined functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # Should return a pandas DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    # Should output a pandas DataFrame or a Plotly figure
    pass

# SQL query string to fetch product performance data
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity) AS product_performance_last_6_months 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE [Order Details].OrderDate >= DATEADD(month, -6, CURRENT_DATE) 
GROUP BY products.ProductName 
ORDER BY product_performance_last_6_months DESC
""""""

# Execute the SQL query to get data
data = execute_sql_query(sql_query)

# Visualizing the data using a bar chart
fig = px.bar(data, 
             x='ProductName', 
             y='product_performance_last_6_months', 
             title='Product Performance in Last 6 Months',
             labels={'product_performance_last_6_months': 'Performance', 'ProductName': 'Product Name'},
             template='plotly_dark')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code accurately follows the logic of the reference code by performing the SQL query to calculate product performance for the last six months. It then visualizes the results using a bar chart. While the input code groups by 'ProductName' instead of 'ProductID', it still aligns with the business request of analyzing product performance and visualizing it. Both codes use similar SQL JOINs, WHERE conditions to filter the last six months, and a bar chart for visualization.",Finetuned
"What is the trend of average order value over the past year, and can it be represented with a line chart for better visualization?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS average_order_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE() 
GROUP BY month 
ORDER BY month
""""""

# Fetching the data using the utility function
data = execute_sql_query(sql_query)

# Creating a line chart using Plotly
fig = px.line(data, x='month', y='average_order_value', title='Trend of Average Order Value Over the Past Year')

# Displaying the chart
show_to_user(fig)
```","```python
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE()
GROUP BY 
    month
ORDER BY 
    month;
""""""

avg_order_value_trend = execute_sql_query(sql_query)

import plotly.express as px

fig = px.line(avg_order_value_trend, x='month', y='avg_order_value', title='Trend of Average Order Value Over the Past Year', labels={'month': 'Month', 'avg_order_value': 'Average Order Value'})
show_to_user(fig)
```","The input Python code fetches the same data using a similar SQL query, calculating average order value by month for the past year and visualizes it with a line chart. The slight variable name difference ('avg_order_value' vs 'average_order_value') and addition of labels in the plotly call do not affect the correctness as the logic and SQL operations are consistent with the reference code.","```python
import pandas as pd
import plotly.express as px

def get_average_order_value_trend():
    # SQL query to get the trend of average order value over the past year
    sql_query = """"""
    SELECT 
        MONTH(OrderDate) AS Month, 
        AVG(TotalCost) AS AverageOrderValue
    FROM (
        SELECT 
            orders.OrderDate, 
            SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalCost
        FROM 
            [Order Details] 
            JOIN orders ON [Order Details].OrderID = orders.OrderID
        WHERE 
            orders.OrderDate BETWEEN '2022-10-01' AND CURRENT_DATE
        GROUP BY 
            orders.OrderID, MONTH(orders.OrderDate)
    ) AS monthly_orders
    GROUP BY 
        MONTH(OrderDate)
    ORDER BY 
        Month;
    """"""
    
    # Execute the query to get the data
    df = execute_sql_query(sql_query)
    
    # Generate a line chart for better visualization
    fig = px.line(df, x='Month', y='AverageOrderValue', title='Average Order Value Trend Over the Past Year')
    
    # Show the line chart to the user
    show_to_user(fig)

# Call the function to execute the analysis and visualization
get_average_order_value_trend()
```","The input Python code deviates from the reference implementation in key areas: it calculates the average order value based on AVG(TotalCost) after aggregating by OrderID and month, rather than dividing the total order value by the count of distinct orders per month, which is the logic used in the reference. Additionally, it groups by the numeric month rather than using a year-month format, which could lead to incorrect grouping over a multi-year period. These differences result in a deviation from the trend representation requested.",Base
Determine the total number of orders for each product and create a bar chart to visualize the results.,"```python
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT products.ProductName, 
       COUNT(DISTINCT [Order Details].OrderID) AS TotalOrders 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalOrders', title='Total Orders for Each Product')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalOrders
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='TotalOrders', title='Total Number of Orders for Each Product')
show_to_user(fig)
```","The input code aggregates the total quantity of each product instead of distinct order counts. The reference implementation counts distinct orders per product, while the input sums the quantities sold, leading to different results.","```python
import pandas as pd
import plotly.express as px

# Utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the given SQL query and return a DataFrame
    pass

def show_to_user(data):
    # This function should display a DataFrame or Plotly figure
    pass

# SQL query to retrieve total number of orders for each product
sql_query = """"""
SELECT p.ProductID, COUNT(DISTINCT o.OrderID) AS NumberOfOrders 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY p.ProductID;
""""""

# Execute SQL query to get results in a DataFrame
df_orders_by_product = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df_orders_by_product,
    x='ProductID',
    y='NumberOfOrders',
    title='Total Number of Orders per Product',
    labels={'ProductID': 'Product ID', 'NumberOfOrders': 'Number of Orders'}
)

# Display the figure using the utility function
show_to_user(fig)
```","The input code uses 'ProductID' instead of 'ProductName' in the SQL query and the bar chart. The reference implementation groups and visualizes data by 'ProductName', which aligns with the business requirement to show total orders for each product by name. Therefore, the input code does not match the logic of the reference implementation.",None
"Which shipping company has the highest average freight cost, and can this be visualized using a bar chart showing each company's average freight cost?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve average freight costs by shipping company
sql_query = """"""
    SELECT ShipVia, AVG(Freight) AS avg_freight 
    FROM orders 
    GROUP BY ShipVia 
    ORDER BY avg_freight DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to visualize average freight costs
fig = px.bar(
    df, 
    x='ShipVia', 
    y='avg_freight', 
    title='Average Freight Cost by Shipping Company',
    labels={'ShipVia': 'Shipping Company', 'avg_freight': 'Average Freight Cost'}
)

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(Freight) AS Average_Freight
FROM orders
GROUP BY ShipVia
ORDER BY Average_Freight DESC
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipVia', y='Average_Freight', 
             title='Average Freight Cost by Shipping Company', 
             labels={'ShipVia': 'Shipping Company', 'Average_Freight': 'Average Freight Cost'})

show_to_user(fig)
```","The input code correctly retrieves the average freight costs by shipping company using a SQL query that matches the reference implementation. It orders the results by average freight in descending order, ensuring that the shipping company with the highest average is first. The code then uses Plotly to create a bar chart, with proper labels and title, similarly to the reference code. The function `show_to_user` is called to display the chart, matching the reference implementation's logic.","
import pandas as pd
import plotly.express as px

# Execute the given SQL query to get the data
sql_query = """"""
SELECT ShipVia, AVG(Freight) AS AverageFreightCost
FROM orders
GROUP BY ShipVia
ORDER BY AVG(Freight) DESC;
""""""

# Assume execute_sql_query is pre-defined
df = execute_sql_query(sql_query)

# Creating a bar chart to visualize each company's average freight cost
fig = px.bar(df, x='ShipVia', y='AverageFreightCost', title='Average Freight Cost by Shipping Company',
             labels={'ShipVia': 'Shipping Company', 'AverageFreightCost': 'Average Freight Cost'},
             color='AverageFreightCost', text_auto=True)

# Show the bar chart using the show_to_user utility
show_to_user(fig)
","The input Python code follows the same logic as the reference implementation. It correctly executes a SQL query to calculate average freight costs by shipping company and orders the results in descending order. The visualization is created using Plotly to generate a bar chart with the average freight costs per shipping company, similar to the reference. The only differences are in column naming ('AverageFreightCost' vs. 'avg_freight') and some additional visualization features like color and text annotations, which do not affect the correctness of the output as per the request.",both
"Determine the employee with the most orders shipped before the required date, and create a bar chart to visualize the number of early shipments per employee.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve employees with early shipments
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) as EarlyShipments 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.ShippedDate < o.RequiredDate 
GROUP BY e.EmployeeID, e.FirstName, e.LastName 
ORDER BY EarlyShipments DESC;
""""""

# Execute the SQL query and retrieve the data
employees_early_shipments_df = execute_sql_query(sql_query)

# Determine the employee with the most early shipments
if not employees_early_shipments_df.empty:
    top_employee = employees_early_shipments_df.iloc[0]
else:
    top_employee = pd.DataFrame(columns=['EmployeeID', 'FirstName', 'LastName', 'EarlyShipments'])

# Create a bar chart to visualize the number of early shipments per employee
fig = px.bar(
    employees_early_shipments_df,
    x='FirstName',
    y='EarlyShipments',
    title='Early Shipments per Employee',
    labels={'FirstName': 'Employee', 'EarlyShipments': 'Number of Early Shipments'},
    text='EarlyShipments'
)

# Render the bar chart using the utility function
show_to_user(fig)

# Show the employee with the most early shipments using the utility function
show_to_user(top_employee.to_frame().T)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS EarlyShipments
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate < o.RequiredDate
GROUP BY e.EmployeeID
ORDER BY EarlyShipments DESC
""""""

early_shipments_df = execute_sql_query(sql_query)
top_employee_df = early_shipments_df.head(1)

fig = px.bar(early_shipments_df, x='FirstName', y='EarlyShipments', title='Number of Early Shipments per Employee')
show_to_user(fig)

top_employee_df
```","The code being evaluated does not completely align with the reference implementation's logic. Specifically, it overlooks the concatenated display of EmployeeID, FirstName, and LastName for the top employee. Additionally, the evaluated code returns 'top_employee_df' without using the 'show_to_user' utility function as in the reference code, which may result in differing outputs based on the environment, as the reference code explicitly displays through 'show_to_user'.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return data as DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    pass

# Utility function to display results to the user
def show_to_user(data):
    # Placeholder for actual display logic
    pass

# SQL query to get the count of early shipments per employee
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS EarlyOrders
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE orders.ShippedDate < orders.RequiredDate
GROUP BY employees.EmployeeID
ORDER BY EarlyOrders DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of early shipments per employee
fig = px.bar(df, x='EmployeeID', y='EarlyOrders', title='Early Shipments per Employee')

# Show the bar chart
show_to_user(fig)

# Determine the employee with the most early shipments
top_employee = df.iloc[0]
show_to_user(top_employee)
```","The evaluated code omits the retrieval of 'FirstName' and 'LastName' in the SQL query, which are used in the reference implementation for display purposes and identifying the top employee. Additionally, it displays 'EmployeeID' instead of 'FirstName' on the bar chart's x-axis, which deviates from the reference implementation in terms of labeling. These differences affect the clarity and completeness of the output.",None
Calculate the average discount given per order and visualize the distribution of discounts across different orders.,"```python
import pandas as pd
import plotly.express as px

# Assume we have the execute_sql_query function available.
sql_query = """"""
SELECT od.Discount, od.OrderID 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID;
""""""

# Execute the SQL query to get the data
order_details_df = execute_sql_query(sql_query)

# Calculate average discount
average_discount = order_details_df['Discount'].mean()

# Prepare data for visualization
discount_distribution = order_details_df.groupby('OrderID')['Discount'].mean().reset_index()

# Visualize the distribution of discounts across different orders
fig = px.histogram(discount_distribution, x='Discount', 
                   title=f'Distribution of Discounts Across Orders (Avg Discount: {average_discount:.2f})', 
                   labels={'Discount': 'Discount Amount'},
                   nbins=20)

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.OrderID,
    od.Discount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
""""""

data = execute_sql_query(sql_query)

average_discount = data['Discount'].mean()
discount_distribution = data['Discount']

fig = px.histogram(discount_distribution, 
                   title='Distribution of Discounts Across Orders', 
                   labels={'value': 'Discount'},
                   nbins=30)

show_to_user(fig)

average_discount
```","The input code calculates the average discount correctly. However, the visualization does not group the discounts by OrderID as the reference implementation does. Instead, it creates a histogram of all discount values without calculating the mean per order, which does not adhere to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assuming utility functions `execute_sql_query` and `show_to_user` are defined elsewhere

# SQL query to calculate average discount per order
sql_query = ""SELECT Discount FROM [Order Details];""

# Execute SQL query to get the data
order_details_df = execute_sql_query(sql_query)

# Calculate the average discount
avg_discount_per_order = order_details_df['Discount'].mean()

# Display the average discount
show_to_user(pd.DataFrame({'AvgDiscountPerOrder': [avg_discount_per_order]}))

# Visualizing the distribution of discounts across different orders
fig = px.histogram(order_details_df, x='Discount', title='Distribution of Discounts Across Orders')
show_to_user(fig)
```","The input code does not adhere to the same logic as the reference code. It fails to calculate the average discount per order correctly because it doesn't group data by 'OrderID'. Instead, it calculates the mean discount over all rows, which doesn't account for order-specific averages. Additionally, it visualizes the distribution of raw discount values, not the grouped order-based averages as per the reference implementation.",None
"How many unique products have been ordered in the last year, and can you provide a chart showing the monthly trend of these unique orders?","```python
import pandas as pd
import plotly.express as px

# SQL query to extract unique products ordered each month in the last year
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM orders.OrderDate) AS OrderMonth, 
    COUNT(DISTINCT ProductID) AS UniqueProducts
FROM [Order Details] o 
JOIN orders ON o.OrderID = orders.OrderID 
WHERE EXTRACT(YEAR FROM orders.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) - 1
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute query and get results in a DataFrame
monthly_unique_products_df = execute_sql_query(sql_query)

# Create a line chart to show the monthly trend of unique product orders
fig = px.line(
    monthly_unique_products_df,
    x='OrderMonth',
    y='UniqueProducts',
    title='Monthly Trend of Unique Products Ordered Last Year',
    labels={'OrderMonth': 'Month', 'UniqueProducts': 'Unique Products'}
)

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last year
end_date = datetime.now()
start_date = end_date - timedelta(days=365)

# SQL query to retrieve unique products ordered in the last year
sql_query = f""""""
SELECT 
    DISTINCT od.ProductID, 
    DATE_TRUNC('month', o.OrderDate) AS OrderMonth
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}'
""""""

# Execute SQL query and load into DataFrame
unique_products_df = execute_sql_query(sql_query)

# Count unique products
unique_product_count = unique_products_df['ProductID'].nunique()

# Prepare monthly trend of unique products ordered
monthly_trend = unique_products_df.groupby('OrderMonth').size().reset_index(name='UniqueProductCount')

# Create a line chart for the monthly trend
fig = px.line(monthly_trend, x='OrderMonth', y='UniqueProductCount', title='Monthly Unique Product Orders')
show_to_user(fig)

unique_product_count
```","The provided code does not calculate the monthly count of unique products correctly. It uses a DISTINCT query with DATE_TRUNC to retrieve product IDs and order months but then counts the occurrence of order months using .size(), not the unique products in each month. This results in counting occurrences of records rather than the distinct products per month, deviating from the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Utility Functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation of SQL execution
    # Replace it with actual database execution logic
    pass

def show_to_user(data):
    # Mock implementation of showing data
    # Replace it with actual data display logic
    pass

# SQL query to get unique products and monthly trend
sql_query_unique_products = """"""
SELECT DISTINCT pd.ProductID, MONTH(o.OrderDate) as OrderMonth
FROM orders o
JOIN `Order Details` od ON o.OrderID = od.OrderID
JOIN products pd ON pd.ProductID = od.ProductID
WHERE o.OrderDate >= DATEADD(YEAR, -1, CURRENT_DATE);
""""""

# Execute the SQL query to get the data
df_products = execute_sql_query(sql_query_unique_products)

# Get the count of unique products
unique_products_count = df_products['ProductID'].nunique()

# Display the count of unique products to the user
show_to_user(pd.DataFrame({'UniqueProductsCount': [unique_products_count]}))

# Generate monthly trend of unique products ordered
monthly_trend = df_products.groupby('OrderMonth')['ProductID'].nunique().reset_index()
monthly_trend.columns = ['OrderMonth', 'UniqueProducts']

# Create a line chart for the monthly trend
fig = px.line(monthly_trend, x='OrderMonth', y='UniqueProducts', 
              title='Monthly Trend of Unique Products Ordered in the Last Year', 
              labels={'UniqueProducts': 'Number of Unique Products'})

# Show the trend to the user
show_to_user(fig)
```","The input code uses a different method to filter orders, using a date range (`o.OrderDate >= DATEADD(YEAR, -1, CURRENT_DATE)`) which includes orders from today going back one year. However, this does not match the reference implementation, which retrieves orders specifically from the previous calendar year (`EXTRACT(YEAR FROM orders.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) - 1`). Additionally, the input code calculates unique product counts and trends correctly, but it first extracts unique product IDs across all orders and then calculates monthly counts, which is inefficient. The reference implementation directly calculates monthly unique product counts from the SQL query.",None
"What is the total freight cost for orders shipped in the last quarter? Additionally, provide a bar chart showing freight cost by month.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define SQL query
sql_query = """"""
SELECT 
    SUM(Freight) AS TotalFreightCost, 
    DATE_TRUNC('month', ShippedDate) AS ShippingMonth 
FROM 
    orders 
WHERE 
    ShippedDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'
GROUP BY 
    ShippingMonth;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Display the freight cost by month to the user
show_to_user(result_df)

# Create a bar chart for freight cost by month
fig = px.bar(result_df, x='ShippingMonth', y='TotalFreightCost', 
             title='Freight Cost by Month in Last Quarter',
             labels={'TotalFreightCost': 'Freight Cost', 'ShippingMonth': 'Month'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the last quarter date range
today = datetime.now()
first_day_of_current_month = today.replace(day=1)
first_day_of_last_quarter = (first_day_of_current_month - pd.DateOffset(months=3)).replace(day=1)
last_day_of_last_quarter = (first_day_of_current_month - timedelta(days=1))

# SQL query to get total freight cost and freight cost by month for the last quarter
sql_query_total_freight = f""""""
SELECT SUM(Freight) AS TotalFreight
FROM orders
WHERE ShippedDate BETWEEN '{first_day_of_last_quarter.strftime('%Y-%m-%d')}' 
AND '{last_day_of_last_quarter.strftime('%Y-%m-%d')}'
""""""

sql_query_freight_by_month = f""""""
SELECT DATE_TRUNC('month', ShippedDate) AS Month, SUM(Freight) AS MonthlyFreight
FROM orders
WHERE ShippedDate BETWEEN '{first_day_of_last_quarter.strftime('%Y-%m-%d')}' 
AND '{last_day_of_last_quarter.strftime('%Y-%m-%d')}'
GROUP BY Month
ORDER BY Month
""""""

# Execute SQL queries
total_freight_df = execute_sql_query(sql_query_total_freight)
monthly_freight_df = execute_sql_query(sql_query_freight_by_month)

# Get total freight cost
total_freight_cost = total_freight_df['TotalFreight'].iloc[0]

# Create bar chart for freight cost by month
fig = px.bar(monthly_freight_df, x='Month', y='MonthlyFreight', title='Freight Cost by Month', labels={'MonthlyFreight': 'Freight Cost'})

# Display total freight cost and the bar chart
print(f'Total Freight Cost for last quarter: {total_freight_cost}')
show_to_user(fig)
```","The input code correctly calculates the total freight cost for the last quarter by determining the appropriate date range and querying the database. It separates the calculation of total freight cost and monthly freight cost into two queries, which aligns with the reference logic. Both approaches calculate the totals and create a bar chart for monthly freight costs. Although the input code uses different variable names and structures, it accomplishes the same tasks as the reference implementation.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# SQL query to get the total freight cost and freight cost by month for the last quarter
sql_query_total_freight = """"""
SELECT SUM(Freight) AS TotalFreight 
FROM orders 
WHERE ShippedDate >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months')
""""""

sql_query_monthly_freight = """"""
SELECT EXTRACT(MONTH FROM ShippedDate) AS Month, SUM(Freight) AS MonthlyFreight 
FROM orders 
WHERE ShippedDate >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months')
GROUP BY Month
ORDER BY Month
""""""

# Execute SQL query for total freight cost
total_freight_df = execute_sql_query(sql_query_total_freight)

# Execute SQL query for freight cost by month
monthly_freight_df = execute_sql_query(sql_query_monthly_freight)

# Display total freight cost
show_to_user(total_freight_df)

# Create a bar chart for freight cost by month
fig = px.bar(monthly_freight_df, x='Month', y='MonthlyFreight', title='Freight Cost by Month', labels={'MonthlyFreight': 'Freight Cost', 'Month': 'Month'})
show_to_user(fig)
```","The input code uses the wrong date logic. It queries for shipments from three months ago using 'CURRENT_DATE - INTERVAL '3 months'', which misinterprets the last quarter calculation. In contrast, the reference code correctly extracts shipments from the last quarter using 'DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months''. The input code also separates the total freight and monthly freight into two queries, but the reference uses a single query that groups data by month. Although different, this doesn't impact correctness if the logic is accurate. However, the main error remains in the date logic for the last quarter.",Base
List products with the highest total sales value and visualize the results using a bar chart.,"
import plotly.express as px
import pandas as pd


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL query execution
    pass


def show_to_user(data):
    # Placeholder for displaying data or figures
    pass

# SQL query to get the products with the highest total sales value
sql_query = """"""
SELECT ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY ProductName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the SQL query
df_sales = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_sales, x='ProductName', y='TotalSales', title='Top 5 Products by Total Sales Value')

# Display the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales value for each product
sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSalesValue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSalesValue DESC
""""""

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales value by product
fig = px.bar(sales_data, x='ProductName', y='TotalSalesValue', title='Total Sales Value by Product')

# Show the visualization to the user
show_to_user(fig)
```","The input code considers discounts in calculating 'TotalSalesValue', which is not included in the reference implementation. This results in a different calculation logic, leading to possible discrepancies in the output. Moreover, the input does not limit the results to the top 5 products as specified in the reference code.","```python
import pandas as pd
import plotly.express as px

# Sample SQL query to get products with their total sales value
sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM 
    [Order Details] od 
GROUP BY 
    od.ProductID
ORDER BY 
    TotalSales DESC;
""""""

# Execute the SQL query to get the products with highest total sales
products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the products with the highest total sales
fig = px.bar(products_df, x='ProductID', y='TotalSales', title='Products with Highest Total Sales Value')

# Display the visualization to the user
show_to_user(fig)
```","The input code does not match the reference implementation. The input code calculates total sales using 'ProductID' instead of 'ProductName' as required. It also includes a 'Discount' factor not present in the reference. Additionally, the input code does not limit the result to the top 5 products, whereas the reference explicitly limits the results to 5.",None
"How many orders were shipped after the required date, and can this be visualized with a bar chart showing late shipments by month?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of late shipments and their details
sql_query = """"""
SELECT OrderID, ShippedDate, RequiredDate
FROM orders
WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query and get the result as a DataFrame
late_shipments_df = execute_sql_query(sql_query)

# Ensure that ShippedDate is in datetime format
late_shipments_df['ShippedDate'] = pd.to_datetime(late_shipments_df['ShippedDate'])

# Calculate the total number of late shipments
total_late_shipments = late_shipments_df.shape[0]

# Extract month and year from the ShippedDate to group by month
late_shipments_df['ShippedMonth'] = late_shipments_df['ShippedDate'].dt.to_period('M')

# Group by ShippedMonth to count the number of late shipments per month
late_shipments_by_month = late_shipments_df.groupby('ShippedMonth').size().reset_index(name='LateShipments')

# Visualize the results with a bar chart using Plotly
fig = px.bar(late_shipments_by_month, x='ShippedMonth', y='LateShipments',
             title='Late Shipments by Month',
             labels={'LateShipments': 'Number of Late Shipments', 'ShippedMonth': 'Month'},
             text='LateShipments')

# Convert ShippedMonth to string for better visualization
fig.update_xaxes(type='category')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', ShippedDate) AS shipment_month, 
    COUNT(*) AS late_shipments
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    shipment_month
ORDER BY 
    shipment_month;
""""""

late_shipments_df = execute_sql_query(sql_query)

fig = px.bar(late_shipments_df, 
              x='shipment_month', 
              y='late_shipments', 
              title='Late Shipments by Month', 
              labels={'shipment_month': 'Month', 'late_shipments': 'Number of Late Shipments'})

show_to_user(fig)
```","The input code correctly calculates the number of late shipments by month and visualizes it. It uses a SQL query to group by month where the ShippedDate is greater than the RequiredDate, counting the late shipments directly. This approach is equivalent to the reference code, which extracts month information in Python after fetching the details. Both result in the same data being displayed, thus adhering to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to count orders shipped after the required date
sql_query = """"""
SELECT Orders.OrderID, Orders.ShippedDate, Orders.RequiredDate
FROM Orders
WHERE Orders.ShippedDate > Orders.RequiredDate
""""""

# Execute the query and fetch the data
late_orders_df = execute_sql_query(sql_query)

# Convert ShippedDate to datetime format and extract the month-year for analysis
late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])
late_orders_df['MonthYear'] = late_orders_df['ShippedDate'].dt.to_period('M')

# Group by MonthYear to get the count of late shipments by month
late_shipments_by_month = late_orders_df.groupby('MonthYear').size().reset_index(name='LateShipments')

# Convert MonthYear back to a string for proper plotting
late_shipments_by_month['MonthYear'] = late_shipments_by_month['MonthYear'].astype(str)

# Create a bar chart using Plotly
fig = px.bar(
    late_shipments_by_month,
    x='MonthYear',
    y='LateShipments',
    title='Late Shipments by Month',
    labels={'MonthYear': 'Month-Year', 'LateShipments': 'Number of Late Shipments'}
)

# Display the visualization
show_to_user(fig)
```","The input code accurately implements the same logic as the reference code, identifying orders shipped after the required date and counting them by month. Both codes execute a SQL query to retrieve late shipments, convert ShippedDate to a Period for monthly grouping, and use Plotly for visualization. Differences in variable names (e.g., 'MonthYear' vs. 'ShippedMonth') and text attributes are superficial and do not affect correctness.",both
"What is the monthly trend in sales quantity for each product, and can this be visualized with a line chart to enhance understanding?","```python
import pandas as pd
import plotly.express as px

# SQL query to gather necessary data
query = """"""
SELECT ProductID, EXTRACT(MONTH FROM OrderDate) AS Month, SUM(Quantity) AS MonthlySales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY ProductID, Month;
""""""

# Execute query using utility function to get a pandas DataFrame
sales_data = execute_sql_query(query)

# Create a line chart to visualize the monthly trend in sales quantity
fig = px.line(
    sales_data, 
    x='Month', 
    y='MonthlySales', 
    color='ProductID', 
    title='Monthly Sales Trend by Product',
    labels={'MonthlySales': 'Sales Quantity', 'Month': 'Month', 'ProductID': 'Product'},
    line_shape='linear'  # Line shape for a smooth trend line
)

# Display the figure using utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity) AS TotalQuantity
FROM
    products p
JOIN
    [Order Details] od ON p.ProductID = od.ProductID
JOIN
    Orders o ON od.OrderID = o.OrderID
GROUP BY
    Month, p.ProductID, p.ProductName
ORDER BY
    Month, p.ProductID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='Month', y='TotalQuantity', color='ProductName', 
              title='Monthly Trend in Sales Quantity for Each Product',
              labels={'TotalQuantity': 'Sales Quantity'})
show_to_user(fig)
```","The input code queries the data differently by using DATE_FORMAT to get year-month, which doesn't match the month extraction logic in the reference. Additionally, it includes ProductName in the grouping and color attribute, unlike the reference which uses ProductID. These differences could alter the granularity and visualization compared to the reference code.","```python
import plotly.express as px
import pandas as pd

# SQL query to get sales data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       ProductID, 
       SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY Month, ProductID 
ORDER BY Month;
""""""

# Execute the SQL query and retrieve the data
df_sales = execute_sql_query(sql_query)

# Ensure the dataframe is sorted by Month and ProductID
df_sales.sort_values(by=['Month', 'ProductID'], inplace=True)

# Create a line chart to visualize the monthly trend in sales quantity for each product
fig = px.line(df_sales, x='Month', y='TotalQuantity', color='ProductID', 
              title='Monthly Sales Quantity Trend by Product',
              labels={'TotalQuantity': 'Total Quantity', 'Month': 'Month'})

# Display the visualization to the user
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request by generating a monthly trend of sales quantity for each product. It uses a SQL query to extract the necessary data, similar to the reference implementation, by grouping sales data by month and product. Both implementations use Plotly to create a line chart, with dimensions set appropriately to visualize trends by 'Month'. The slight differences in SQL syntax (using DATE_FORMAT versus EXTRACT) and parameter names (TotalQuantity versus MonthlySales) do not affect the logic or outcome of the analysis. The input code's modifications still meet the business requirements effectively.",Finetuned
"What is the average supplier lead time for each supplier, and can you provide a bar chart to visualize these times for comparison?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgLeadTime 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID, suppliers.CompanyName;
""""""

# Execute the SQL query and store the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average lead time for each supplier
fig = px.bar(df, x='CompanyName', y='AvgLeadTime', title=""Average Supplier Lead Time by Company"",
             labels={'CompanyName': 'Supplier', 'AvgLeadTime': 'Average Lead Time (days)'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID IN (SELECT ProductID FROM [Order Details] WHERE OrderID = o.OrderID)
GROUP BY s.CompanyName
""""""

lead_time_df = execute_sql_query(sql_query)

fig = px.bar(lead_time_df, x='CompanyName', y='AvgLeadTime', title='Average Supplier Lead Time')
show_to_user(fig)
```","The input code correctly calculates the average lead time for each supplier using a SQL query, similar to the reference implementation. Both codes join the suppliers table with orders through the products and Order Details tables, using the DATEDIFF function to compute lead times. The grouping by CompanyName produces the same logical grouping as the reference implementation, and the final bar chart correctly visualizes the results.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to execute the SQL query
    # and return the result as a pandas DataFrame.
    pass

def show_to_user(data):
    # This function should be implemented to show the data or visualization to the user.
    pass

# SQL query to find average supplier lead time for each supplier
sql_query = """"""
SELECT suppliers.SupplierID, AVG(DATEDIFF(orders.RequiredDate, orders.OrderDate)) AS AvgLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly for better visualization of average lead times
fig = px.bar(
    df,
    x='SupplierID',
    y='AvgLeadTime',
    title='Average Supplier Lead Time',
    labels={'SupplierID': 'Supplier ID', 'AvgLeadTime': 'Average Lead Time (Days)'}
)

# Show the resulting bar chart to the user
show_to_user(fig)
```","The input code calculates the average lead time using `DATEDIFF(orders.RequiredDate, orders.OrderDate)` instead of `DATEDIFF(orders.ShippedDate, orders.OrderDate)`. It also uses `SupplierID` rather than `CompanyName`, which affects the clarity of the visualization. The logic differs from the reference code.",Base
How many unique customers placed orders with discounts greater than 20%? Include a bar chart showing the distribution of discounts among these customers.,"```python
import pandas as pd
import plotly.express as px

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the SQL query and return a DataFrame.
    pass  # Replace with actual implementation

def show_to_user(data):
    # This function should display the data or visualization.
    pass  # Replace with actual implementation

# SQL Query
sql_query = """"""
SELECT DISTINCT orders.CustomerID, [Order Details].Discount 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Discount > 0.2
""""""

# Execute SQL query
discount_data = execute_sql_query(sql_query)

# Count unique customers
unique_customers_count = discount_data['CustomerID'].nunique()

# Display the count of unique customers to the user
show_to_user(pd.DataFrame({'Unique Customers': [unique_customers_count]}))

# Create a bar chart for the distribution of discounts
fig = px.bar(discount_data, x='CustomerID', y='Discount', title='Discount Distribution Among Customers')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DISTINCT orders.CustomerID, [Order Details].Discount
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE [Order Details].Discount > 0.2
""""""

results = execute_sql_query(sql_query)

unique_customers_count = results['CustomerID'].nunique()

discount_distribution = results['Discount'].value_counts().reset_index()
discount_distribution.columns = ['Discount', 'Count']

fig = px.bar(discount_distribution, x='Discount', y='Count', title='Distribution of Discounts Greater Than 20%')

show_to_user(fig)
```","The evaluated code and the reference implementation differ in their approach to generating the bar chart. The reference code displays a bar chart of each customer's discount, while the input code shows the distribution of discount values. Additionally, the evaluated code does not display the count of unique customers, a key requirement.","```python
import pandas as pd
import plotly.express as px

# Mocking execute_sql_query and show_to_user for demonstration purposes.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would typically execute the SQL query and return the result as a DataFrame.
    # Return a sample DataFrame for demonstration purposes.
    data = {
        'CustomerID': ['C001', 'C002', 'C003'],
        'Discount': [0.25, 0.30, 0.22]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # In a real scenario, this function would display the data or visualization to the user.
    pass

# SQL query to get unique customers with discounts greater than 20%
sql_query = ""SELECT CustomerID, Discount FROM [Order Details] WHERE Discount > 0.20;""

# Execute the SQL query
data_df = execute_sql_query(sql_query)

# Get the count of unique customers
unique_customers_count = data_df['CustomerID'].nunique()
unique_customers_df = pd.DataFrame({'Unique Customers': [unique_customers_count]})
show_to_user(unique_customers_df)

# Create a bar chart showing the distribution of discounts
fig = px.bar(data_df, x='CustomerID', y='Discount', title='Discount Distribution Among Customers')
show_to_user(fig)
```","The input code does not join the 'Order Details' and 'orders' tables as the reference implementation does. It directly selects from 'Order Details', which might lead to incorrect results if there are important relations between the tables affecting the discount conditions. Additionally, the SQL query should ensure the same logic and context as the reference, where discounts are related to distinct customer orders.",None
Which products have the highest units on order but are still in stock? Include a bar chart visualization to represent the data.,"
import pandas as pd
import plotly.express as px

# SQL query to get products with highest units on order and still in stock
sql_query = """"""
SELECT ProductName, UnitsOnOrder 
FROM products 
WHERE UnitsOnOrder > 0 AND UnitsInStock > 0 
ORDER BY UnitsOnOrder DESC;
""""""

# Execute the query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to represent the data
fig = px.bar(df, x='ProductName', y='UnitsOnOrder', title='Products with Highest Units on Order')

# Display the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, UnitsOnOrder
FROM products
WHERE UnitsInStock > 0
ORDER BY UnitsOnOrder DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='UnitsOnOrder', 
             title='Products with Highest Units on Order but In Stock', 
             labels={'UnitsOnOrder': 'Units On Order', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It identifies products that have more than zero units in stock and orders the result by the highest units on order in descending order. This logic matches the reference implementation. Both codes create a bar chart to represent the data, and the slight difference in SQL query columns does not affect the correctness for fulfilling the analytics request.","```python
import pandas as pd
import plotly.express as px

# Business logic analysis
def get_products_with_high_units_on_order():
    # SQL query
    sql_query = ""SELECT ProductName, UnitsOnOrder FROM products WHERE UnitsOnOrder > 0 AND UnitsInStock > 0;""
    
    # Execute the SQL query and get the data
    products_df = execute_sql_query(sql_query)
    
    # Sort products by UnitsOnOrder for better visualization
    sorted_products_df = products_df.sort_values(by='UnitsOnOrder', ascending=False)
    
    # Create a bar chart
    fig = px.bar(sorted_products_df, x='ProductName', y='UnitsOnOrder',
                 title='Products with Highest Units on Order',
                 labels={'ProductName': 'Product Name', 'UnitsOnOrder': 'Units on Order'},
                 text='UnitsOnOrder')
    
    fig.update_traces(textposition='outside')
    
    # Show the plot
    show_to_user(fig)

# Execute the business logic
get_products_with_high_units_on_order()
```","The input code correctly implements the business analytics request. It retrieves products with units on order and units in stock, sorts them by units on order in descending order, and then creates a bar chart. Although the reference code directly orders in the SQL query, the input code achieves the same result by sorting in Python, which adheres to the same logic and provides the correct visualization.",both
List the employee sales on each day of a specific month and create a line chart to visualize the daily sales trends.,"
import pandas as pd
import plotly.express as px

# Define the month and year for which the sales data needs to be analyzed
month = 5    # May
year = 2023  # Year

# SQL query with placeholders for month and year
sql_query = f""""""
SELECT e.EmployeeID, o.OrderDate, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS DailySales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE MONTH(o.OrderDate) = {month}
AND YEAR(o.OrderDate) = {year}
GROUP BY e.EmployeeID, o.OrderDate;
""""""

# Execute the SQL query to get the data as a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Create a line chart to visualize daily sales trends
fig = px.line(sales_data, x='OrderDate', y='DailySales', color='EmployeeID',
              title='Daily Sales Trends by Employee',
              labels={'OrderDate': 'Date', 'DailySales': 'Sales ($)', 'EmployeeID': 'Employee ID'})

# Display the chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

month = '2023-10'
sql_query = f""""""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    o.OrderDate,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    DATE_FORMAT(o.OrderDate, '%Y-%m') = '{month}'
GROUP BY 
    e.EmployeeID, o.OrderDate
ORDER BY 
    o.OrderDate
""""""
sales_data = execute_sql_query(sql_query)

daily_sales = sales_data.groupby('OrderDate')['TotalSales'].sum().reset_index()

fig = px.line(daily_sales, x='OrderDate', y='TotalSales', title='Daily Sales Trends for October 2023')
show_to_user(fig)
```","The input code includes employee names but does not differentiate sales by employee in the line chart. The reference code visualizes sales trends by employee ID. Additionally, the input code aggregates daily sales without showing them per employee, which deviates from the business request to list and visualize employee sales daily.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch employee sales for March 2023
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
       (1 - [Order Details].Discount)) AS daily_sales, 
       DATE(orders.OrderDate) AS order_date
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE MONTH(orders.OrderDate) = 3 
AND YEAR(orders.OrderDate) = 2023 
GROUP BY employees.EmployeeID, DATE(orders.OrderDate) 
ORDER BY employees.EmployeeID, order_date;
""""""

# Execute the SQL query and store the result in a pandas DataFrame
df_sales = execute_sql_query(sql_query)

# Create a line chart to visualize daily sales trends
fig = px.line(df_sales, x='order_date', y='daily_sales',
              color='EmployeeID', title='Daily Sales Trends for March 2023')

# Display the line chart
show_to_user(fig)
```","The input code effectively answers the business question and follows the same logic as the reference implementation. Both pieces of code execute a SQL query to aggregate daily sales for each employee within a specific month and year, and then they produce a line chart to visualize these trends. The only difference is the month being analyzed: the input code analyzes March 2023, while the reference code analyzes May 2023. The SQL logic, use of pandas and Plotly Express for visualization are consistent between both implementations.",Finetuned
"Identify products whose sales volume exceeds 100 units in the past month, and visualize the results using a bar chart.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE [Order Details].OrderDate >= DATEADD(month, -1, CURRENT_TIMESTAMP) 
GROUP BY products.ProductName 
HAVING SUM([Order Details].Quantity) > 100;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Products with Sales Volume Over 100 Units in the Past Month')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve products with sales volume exceeding 100 units in the past month
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID
    FROM [Order Details] 
    WHERE OrderDate >= DATEADD(MONTH, -1, GETDATE())
)
GROUP BY p.ProductID, p.ProductName
HAVING SUM(od.Quantity) > 100
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Products with Sales Volume Exceeding 100 Units in the Last Month')
show_to_user(fig)
```","The input code correctly implements the business analytics request similarly to the reference code. Both codes perform a SQL query to determine which products have had more than 100 units sold over the past month and visualize the results using a bar chart. The main differences, such as selecting by ProductID in addition to ProductName and the specific use of the 'IN' clause for filtering OrderDates, do not affect the correctness of the output.","import plotly.express as px

# SQL query to fetch products with sales volume exceeding 100 units in the past month
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS volume
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE od.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 MONTH) AND CURDATE()
GROUP BY p.ProductName
HAVING volume > 100;
""""""

# Execute the SQL query and retrieve the results into a pandas DataFrame
df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(df, x=""ProductName"", y=""volume"", title=""Products with Sales Volume > 100 in the Past Month"")

# Display the bar chart to the user
show_to_user(fig)","The input code correctly executes the required query to find products with sales volumes exceeding 100 units in the past month. It uses a SQL query to sum the quantities from the past month and applies a 'HAVING' clause to filter results where volume is greater than 100, matching the reference logic. It then visualizes the results using a bar chart with Plotly, as specified.",both
Calculate the total revenue for each shipping country and visualize the results in a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue for each shipping country
sql_query = """"""
SELECT ShipCountry, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipCountry;
""""""

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for the function implementation that returns a pandas DataFrame
    pass

# Function to display data or visualization
def show_to_user(data):
    # Placeholder for the function implementation to display data or visualization
    pass

# Execute the SQL query to get the revenue data
revenue_df = execute_sql_query(sql_query)

# Create a bar chart for total revenue by shipping country
fig = px.bar(revenue_df, x='ShipCountry', y='TotalRevenue', title='Total Revenue by Shipping Country')

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Country, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers AS c
JOIN orders AS o ON c.CustomerID = o.CustomerID
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY c.Country
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='Country', y='TotalRevenue', title='Total Revenue by Shipping Country')
show_to_user(fig)
```","The input code calculates total revenue by 'Country' from the 'customers' table, while the reference code uses 'ShipCountry' from the 'orders' table. This causes a discrepancy in logic and results since the group by fields are different.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total revenue for each shipping country
sql_query = """"""
SELECT ShipCountry, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM orders o 
JOIN `Order Details` od ON o.OrderID = od.OrderID 
GROUP BY ShipCountry;
""""""

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution code
    # Use a library like sqlalchemy or sqlite3 to connect and execute
    pass

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total revenue by shipping country
fig = px.bar(df, x='ShipCountry', y='TotalRevenue', 
             title='Total Revenue by Shipping Country')

# Function to show the results
def show_to_user(data):
    # Placeholder for actual visualization display code
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Show the bar chart
show_to_user(fig)
```
","The input code correctly calculates the total revenue per shipping country using a SQL query. It joins orders and order details tables, computes the sum of revenue using unit price, quantity, and discount, and groups by ShipCountry, similar to the reference. It also creates a bar chart with Plotly Express, and a function 'show_to_user' is provided to display the results. Although there is a slight difference in table reference formatting ('Order Details' vs [Order Details]), it doesn't affect the logic or output. Therefore, it aligns with the specified business request and adheres to the reference logic.",Finetuned
"What is the average lead time for each supplier in delivering their products, and can this be visualized using a bar chart to compare the lead times?","```python
import pandas as pd
import plotly.express as px

# SQL query from the request
sql_query = """"""
SELECT s.SupplierID, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY s.SupplierID;
""""""

# Placeholder function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Imagine that this function connects to a database, executes the query,
    # and returns the results as a pandas DataFrame
    pass

# Function to display data or visualizations
def show_to_user(data):
    # To show visualization or data to user
    # If Plotly figure, display it
    if isinstance(data, pd.DataFrame):
        print(data)
    elif hasattr(data, 'show'):
        data.show()

# Execute the query and get the results
df = execute_sql_query(sql_query)

# Visualize the average lead time using a bar chart
fig = px.bar(df, x='SupplierID', y='AverageLeadTime', 
             title='Average Lead Time by Supplier',
             labels={'AverageLeadTime': 'Average Lead Time (Days)', 'SupplierID': 'Supplier ID'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.CompanyName
""""""

lead_time_df = execute_sql_query(sql_query)

fig = px.bar(lead_time_df, x='CompanyName', y='AverageLeadTime', title='Average Lead Time for Each Supplier', labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code calculates the average lead time for each supplier similarly to the reference code but uses 'CompanyName' instead of 'SupplierID'. This does not affect the logic or outcome since 'CompanyName' is another identifier for suppliers. The visualization is correctly implemented using a bar chart to compare lead times, matching the business request.","```python
import plotly.express as px
import pandas as pd

# SQL query
sql_query = """"""
SELECT s.SupplierID, AVG(DATEDIFF(od.OrderDate, od.ShippedDate)) AS AvgLeadTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN order_details od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID;
""""""

# Execute the SQL query and get the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function for executing the SQL query and returning a DataFrame
    # In real implementation, this would interact with a database
    return pd.DataFrame({
        'SupplierID': [1, 2, 3],
        'AvgLeadTime': [5, 7, 4]
    })

# Function to show the result to the user
def show_to_user(data):
    # Simulated function for displaying data or visualization
    # In real implementation, this would handle display output
    print(data)

# Fetch the average lead time data
avg_lead_time_df = execute_sql_query(sql_query)

# Visualize using a bar chart with Plotly
fig = px.bar(avg_lead_time_df, x='SupplierID', y='AvgLeadTime',
             title='Average Lead Time for Each Supplier',
             labels={'AvgLeadTime': 'Average Lead Time (days)',
                     'SupplierID': 'Supplier ID'})

# Display the bar chart
show_to_user(fig)
```","The input code calculates the average lead time incorrectly by using DATEDIFF(od.OrderDate, od.ShippedDate). It should be DATEDIFF(o.ShippedDate, o.OrderDate) as in the reference code, to calculate lead time from order date to shipped date. Additionally, the input code does not include the necessary JOIN with orders table to access the OrderDate and ShippedDate.",Base
"Which employee was hired most recently, and can you provide a timeline visualization of employee hire dates?","```python
import plotly.express as px
import pandas as pd

# SQL query to get the most recently hired employee
sql_query_most_recent = """"""
SELECT FirstName, LastName, HireDate 
FROM employees 
ORDER BY HireDate DESC 
LIMIT 1;
""""""

# Execute the query to find the most recently hired employee
most_recent_employee_df = execute_sql_query(sql_query_most_recent)

# Display the most recently hired employee
show_to_user(most_recent_employee_df)

# SQL query to get all employee hire dates for timeline visualization
sql_query_all_hires = """"""
SELECT FirstName, LastName, HireDate 
FROM employees 
ORDER BY HireDate;
""""""

# Execute the query to get all hire dates
all_hires_df = execute_sql_query(sql_query_all_hires)

# Create a timeline visualization of employee hire dates
fig = px.scatter(all_hires_df, x='HireDate', y='FirstName', 
                 title=""Timeline of Employee Hire Dates"",
                 labels={'FirstName': 'Employee Name', 'HireDate': 'Hire Date'},
                 hover_data=['LastName'])

# Display the timeline visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to find the most recently hired employee
most_recent_employee_query = """"""
SELECT EmployeeID, FirstName, LastName, HireDate
FROM employees
ORDER BY HireDate DESC
LIMIT 1;
""""""

most_recent_employee_df = execute_sql_query(most_recent_employee_query)

# Getting the most recent employee details
most_recent_employee = most_recent_employee_df.iloc[0]

# Query to get hire dates of all employees for visualization
hire_dates_query = """"""
SELECT FirstName, LastName, HireDate
FROM employees
ORDER BY HireDate;
""""""

hire_dates_df = execute_sql_query(hire_dates_query)

# Create a timeline visualization
fig = px.timeline(hire_dates_df, x_start=""HireDate"", x_end=""HireDate"", y=""FirstName"", 
                  title=""Employee Hire Dates Timeline"", labels={""FirstName"": ""Employee""},
                  hover_name=""LastName"", color=""HireDate"")
fig.update_traces(marker=dict(size=10))

show_to_user(fig)

most_recent_employee
```","The provided implementation uses a `px.timeline` chart, which is not appropriate for creating a timeline visualization in this context. Instead, a `px.scatter` plot is used in the reference code, accurately representing hire dates with a simpler dot plot. Additionally, the `most_recent_employee` variable is extracted but not shown to the user, whereas the reference code displays the DataFrame directly.","```python
import plotly.express as px
import pandas as pd

# SQL query to find the most recently hired employee
recent_hire_sql = """"""
SELECT employees.EmployeeID, employees.HireDate
FROM employees
ORDER BY employees.HireDate DESC
LIMIT 1
""""""

# Execute SQL query using provided utility function
recent_hire_df = execute_sql_query(recent_hire_sql)

# Display the most recently hired employee
show_to_user(recent_hire_df)

# SQL query to get all employee hire dates
all_hires_sql = """"""
SELECT employees.EmployeeID, employees.HireDate
FROM employees
ORDER BY employees.HireDate
""""""

# Execute SQL query using provided utility function
all_hires_df = execute_sql_query(all_hires_sql)

# Create a timeline visualization of employee hire dates
fig = px.line(all_hires_df, x='HireDate', y='EmployeeID', title='Timeline of Employee Hire Dates')

# Display the timeline visualization
show_to_user(fig)
```","The input code does not use the same logic as the reference implementation. The reference code queries and displays the first and last names for the most recently hired employee, while the input code only retrieves and shows the EmployeeID. Additionally, the reference implementation uses a scatter plot with 'FirstName' for the y-axis in the timeline visualization, whereas the input code uses a line plot with 'EmployeeID', which changes the nature of the visualization.",None
Determine the total quantity sold for each supplier and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL query to determine the total quantity sold for each supplier
sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.SupplierID;
""""""

# Execute the SQL query and retrieve the data
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total quantity sold for each supplier
fig = px.bar(data, x='SupplierID', y='TotalQuantity', title='Total Quantity Sold by Supplier')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.SupplierID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='SupplierID', y='TotalQuantitySold', title='Total Quantity Sold by Supplier', labels={'SupplierID': 'Supplier ID', 'TotalQuantitySold': 'Total Quantity Sold'})
show_to_user(fig)
```","The input code has the same logic as the reference implementation. It uses a similar SQL query that joins the 'products' and 'Order Details' tables to aggregate the total quantity sold for each supplier. The bar chart visualization is also correctly configured with the appropriate x and y axes and a descriptive title, just like the reference.","```python
import pandas as pd
import plotly.express as px

# Utility functions based on the given constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation of SQL execution logic
    # This function should connect to the database, execute the query, and return a DataFrame
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure): 
        data.show()

# SQL query to extract total quantities sold per supplier
sql_query = """"""
SELECT s.CompanyName, SUM(od.Quantity) AS TotalQuantitySold
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.CompanyName;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(result_df, x='CompanyName', y='TotalQuantitySold', title='Total Quantity Sold Per Supplier')

# Show the bar chart using the utility function
show_to_user(fig)
```","The input code achieves the same business goal, which is to calculate the total quantity sold for each supplier and visualize it using a bar chart. It uses a valid SQL query, correctly joining the suppliers, products, and order details tables to aggregate quantities per supplier. It also appropriately uses Plotly to visualize the data and a utility function to display the chart. The change from using SupplierID to CompanyName does not affect the correctness, as it still groups by supplier and presents the required information.",both
Identify employees who have processed orders only within a specific country and provide a chart showing the count of orders processed by each employee.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT e.EmployeeID
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
HAVING COUNT(DISTINCT o.ShipCountry) = 1
AND MAX(o.ShipCountry) = 'Specific Country';
""""""

# Execute the SQL query and get a DataFrame
employees_df = execute_sql_query(sql_query)

# Check if employees_df is not empty
if not employees_df.empty:
    # Fetch order counts for those employees
    order_count_query = f""""""
    SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
    FROM employees e
    JOIN orders o ON e.EmployeeID = o.EmployeeID
    WHERE e.EmployeeID IN ({', '.join(map(str, employees_df['EmployeeID']))})
    GROUP BY e.EmployeeID;
    """"""

    order_count_df = execute_sql_query(order_count_query)

    # Visualize the order count by each employee
    if not order_count_df.empty:
        fig = px.bar(order_count_df, x='EmployeeID', y='OrderCount', title='Order Count by Employee in Specific Country')
        show_to_user(fig)
    else:
        show_to_user(""No order counts available for the selected employees."")
else:
    show_to_user(""No employees found who processed orders only in the specific country."")
```","```python
import pandas as pd
import plotly.express as px

country = 'SpecificCountry'

sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShipCountry = '{country}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
HAVING COUNT(DISTINCT o.ShipCountry) = 1
""""""

employee_orders = execute_sql_query(sql_query)

fig = px.bar(employee_orders, x='FirstName', y='OrderCount', 
              title=f'Count of Orders Processed by Each Employee in {country}', 
              labels={'FirstName': 'Employee', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The input code gets the correct employees, but it doesn't check if they processed orders only in the specified country. The 'HAVING COUNT(DISTINCT o.ShipCountry) = 1' clause ensures each employee processed orders in one country but doesn't enforce it to be the specified country. The reference implementation includes an additional 'HAVING MAX(o.ShipCountry) = 'Specific Country'' condition to ensure this.","```python
import pandas as pd
import plotly.express as px

# Function to get the data before any processing
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Assume this connects to the database and returns a DataFrame
    pass

def show_to_user(data):
    # Placeholder function: Assume this displays data or visuals to the user
    pass

# SQL Query to identify employees who have processed orders only within a specific country
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
HAVING COUNT(DISTINCT o.ShipCountry) = 1;
""""""

# Execute the SQL query and store the result in a DataFrame
df_employees = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the count of orders processed by each employee
fig = px.bar(df_employees, x='EmployeeID', y='OrderCount', title='Count of Orders Processed by Employee')

# Show the figure to the user
show_to_user(fig)
```","The input code does not fully match the logic of the reference implementation. It identifies employees processing orders in a single country but doesn't filter for a 'Specific Country'. The reference code explicitly filters for maximum of 'ShipCountry' equal to 'Specific Country'. Additionally, it handles cases where no employees meet the criteria, which is absent in the input code.",None
Calculate the total sales revenue for each supplier for the last quarter and provide a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales revenue for each supplier for the last quarter
sql_query = """"""
SELECT SupplierID, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalRevenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE QUARTER(OrderDate) = QUARTER(CURDATE()) - 1 
GROUP BY SupplierID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # In practice, this function will utilize a connection to execute the query
    # and return a DataFrame
    pass

# For visualization or data display
def show_to_user(data):
    if isinstance(data, (pd.DataFrame, px.Figure)):
        # Assuming some display logic here
        # e.g., using something like display(data)
        pass

# Execute the query and get the DataFrame
data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data_df, x='SupplierID', y='TotalRevenue', title='Total Sales Revenue by Supplier for Last Quarter')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

last_quarter_start = pd.to_datetime(""today"").to_period(""Q"").start_time - pd.DateOffset(months=3)
last_quarter_end = last_quarter_start + pd.DateOffset(months=3) - pd.DateOffset(days=1)

sql_query = f""""""
SELECT p.SupplierID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID FROM Orders WHERE OrderDate BETWEEN '{last_quarter_start.strftime('%Y-%m-%d')}' AND '{last_quarter_end.strftime('%Y-%m-%d')}'
)
GROUP BY p.SupplierID
""""""

total_sales_revenue = execute_sql_query(sql_query)

fig = px.bar(total_sales_revenue, x='SupplierID', y='TotalRevenue', title='Total Sales Revenue by Supplier for Last Quarter')
show_to_user(fig)
```","Both the input Python code and the reference code aim to calculate the total sales revenue for each supplier for the last quarter and visualize it using a bar chart. The reference code uses the QUARTER() function to identify the previous quarter, while the input code computes the dates for the last quarter using pandas. Additionally, while the input code incorporates a discount in the revenue calculation, this does not affect the overall requirement of calculating the total sales revenue. The logic of filtering orders within a specific quarter and grouping by SupplierID remains consistent between both implementations.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would realistically interact with the database.
    # Placeholder for actual SQL execution.
    pass

# Utility function to show the result to the user
def show_to_user(data):
    # Placeholder for displaying the data
    pass

# Define SQL query
sql_query = """"""
SELECT suppliers.CompanyName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2022-10-01' AND '2022-12-31'
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(sales_data, x='CompanyName', y='total_sales', title='Total Sales Revenue per Supplier for Q4 2022')

# Show the bar chart
show_to_user(fig)
```","The input code calculates revenue using a fixed date range for Q4 2022, while the reference calculates totals for the last quarter relative to the current date using `QUARTER` and `CURDATE()`. Additionally, the input code includes a discount calculation not present in the reference. These differences mean the input does not adhere to the reference logic.",Base
"What is the average shipping cost for each shipping company, and can this be represented in a bar chart?","
```python
import plotly.express as px

# Define the SQL query to calculate the average shipping cost for each shipping company
sql_query = ""SELECT ShipVia, AVG(Freight) AS AvgShippingCost FROM orders GROUP BY ShipVia;""

# Execute the SQL query and store the result in a DataFrame
df_shipping_costs = execute_sql_query(sql_query)

# Create a bar chart using Plotly to represent the average shipping cost for each shipping company
fig = px.bar(df_shipping_costs, x='ShipVia', y='AvgShippingCost', title='Average Shipping Cost by Shipping Company')

# Display the bar chart to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(Freight) as AverageShippingCost
FROM orders
GROUP BY ShipVia
""""""
shipping_costs_df = execute_sql_query(sql_query)

fig = px.bar(shipping_costs_df, x='ShipVia', y='AverageShippingCost', 
             title='Average Shipping Cost by Shipping Company',
             labels={'ShipVia': 'Shipping Company', 'AverageShippingCost': 'Average Shipping Cost'})
show_to_user(fig)
```","The input code correctly calculates the average shipping cost for each shipping company using an SQL query similar to the reference implementation. Both implementations use the same logic: querying the database to group by 'ShipVia' and averaging 'Freight'. The bar chart visualization uses Plotly to represent these averages, matching the business analytics request. Differences in variable names and minor details like the label dictionary do not impact the correctness.","```python
import pandas as pd
import plotly.express as px

# Utility function stubs
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # placeholder for executing SQL query and returning a DataFrame
    pass

def show_to_user(data):
    # placeholder for showing results to the user, could be a DataFrame or Plotly figure
    pass

# SQL query to get average shipping costs
sql_query = ""SELECT ShipVia, AVG(Freight) AS AvgFreight FROM orders GROUP BY ShipVia;""

# Execute SQL query and fetch results as a DataFrame
df_avg_freight = execute_sql_query(sql_query)

# Create a bar chart to represent average shipping costs by shipping company
fig = px.bar(df_avg_freight, x='ShipVia', y='AvgFreight', 
             title='Average Shipping Cost by Shipping Company',
             labels={'ShipVia': 'Shipping Company', 'AvgFreight': 'Average Freight Cost'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates the average shipping cost for each shipping company, using an SQL query similar to the reference code. Both codes execute an SQL query and store the result in a DataFrame. The input code uses 'AvgFreight' instead of 'AvgShippingCost' for the average column, which is semantically equivalent. Both codes then create a bar chart with Plotly using the data, and the final chart represents the average shipping cost by shipping company. Therefore, the business request is effectively fulfilled by the input code.",both
What is the average hiring duration of employees in correlation to their sales? Please include a scatter plot to visualize this relationship.,"```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT 
    DATEDIFF(CURDATE(), e.HireDate) AS HireDuration, 
    sales.EmployeeID,
    sales.TotalSales
FROM 
    employees e 
JOIN 
    (SELECT 
        o.EmployeeID, 
        SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
     FROM 
        orders o 
     JOIN 
        `Order Details` od ON o.OrderID = od.OrderID 
     GROUP BY 
        o.EmployeeID) sales 
ON 
    e.EmployeeID = sales.EmployeeID;
""""""

# Execute the SQL query and get results as a DataFrame
df = execute_sql_query(sql_query)

# Calculate average per employee
df_avg = df.groupby('EmployeeID').agg({'HireDuration': 'mean', 'TotalSales': 'mean'}).reset_index()

# Create a scatter plot to visualize the relationship between AvgHireDuration and AvgSales
fig = px.scatter(df_avg, x='HireDuration', y='TotalSales',
                 labels={""HireDuration"": ""Average Hiring Duration (Days)"",
                         ""TotalSales"": ""Average Sales""},
                 title=""Correlation between Hiring Duration and Sales"")

# Display the scatter plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to get employee hiring duration and total sales
sql_query = """"""
SELECT
    e.EmployeeID,
    DATEDIFF(CURRENT_DATE, e.HireDate) AS HiringDuration,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM
    employees e
LEFT JOIN
    orders o ON e.EmployeeID = o.EmployeeID
LEFT JOIN
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY
    e.EmployeeID
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Calculate the average hiring duration and total sales
avg_duration_sales = data.groupby('HiringDuration')['TotalSales'].mean().reset_index()

# Scatter plot
fig = px.scatter(avg_duration_sales, x='HiringDuration', y='TotalSales', 
                 title='Average Hiring Duration vs Total Sales',
                 labels={'HiringDuration': 'Hiring Duration (days)', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code calculates the average sales per hiring duration instead of per employee. The reference code calculates averages by grouping per employee, then creating a scatter plot with employee averages. The input code groups directly by HiringDuration, losing granularity on individual employee data, and doesn't align with the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT AVG(DATEDIFF(FINISH_DATE, HIRE_DATE)) AS AVG_HIRING_DURATION,
       E.EmployeeID,
       SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS TOTAL_SALES
FROM employees E
JOIN orders O ON E.EmployeeID = O.EmployeeID
JOIN `Order Details` OD ON O.OrderID = OD.OrderID
GROUP BY E.EmployeeID;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a scatter plot to visualize the correlation between avg hiring duration and total sales
fig = px.scatter(
    df,
    x='AVG_HIRING_DURATION',
    y='TOTAL_SALES',
    title='Correlation between Average Hiring Duration and Total Sales',
    labels={
        'AVG_HIRING_DURATION': 'Average Hiring Duration (Days)',
        'TOTAL_SALES': 'Total Sales ($)'
    }
)

# Display the plot using the provided utility function
show_to_user(fig)
```
","The input code calculates the average hiring duration within the SQL query itself, using AVG(DATEDIFF(FINISH_DATE, HIRE_DATE)), which averages the duration directly across employee records. In contrast, the reference code calculates the duration for each employee using DATEDIFF in the SELECT statement and then calculates the average per employee using pandas' groupby method. The input code assumes FINISH_DATE is a known column, which might not calculate hiring duration correctly if not intended to replace CURDATE(). Additionally, it calculates total sales correctly, similar to the reference, but lacks explicit clarity on ensuring correct correlation between individual employee sales and their hiring duration when averaging in SQL. Thus, the logic differs in how hiring duration is computed and averaged.",None
"What percentage of products were shipped via each shipping method, and can you provide a pie chart to visualize the distribution?","```python
import plotly.express as px
import pandas as pd

# Mock-up function for executing SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be replaced with actual database query execution
    # Here's a simulated dataframe for demonstration purposes
    data = {
        ""ShipVia"": [1, 2, 3],
        ""shipping_method_percentage"": [40, 35, 25],
    }
    return pd.DataFrame(data)

# Mock-up function to display results to user
def show_to_user(data):
    # This function will display the data visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to calculate shipping method percentage
sql_query = '''
SELECT ShipVia, COUNT(orders.OrderID) * 100.0 / 
(SELECT COUNT(*) FROM orders) AS shipping_method_percentage 
FROM orders GROUP BY ShipVia
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a pie chart using Plotly
fig = px.pie(df, names='ShipVia', values='shipping_method_percentage', title='Shipping Method Distribution')

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    shippers.CompanyName, 
    COUNT(orders.OrderID) AS order_count 
FROM 
    orders 
JOIN 
    shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY 
    shippers.CompanyName
""""""

shipping_data = execute_sql_query(sql_query)
total_orders = shipping_data['order_count'].sum()
shipping_data['percentage'] = (shipping_data['order_count'] / total_orders) * 100

fig = px.pie(shipping_data, 
             names='CompanyName', 
             values='percentage', 
             title='Percentage of Products Shipped via Each Shipping Method')

show_to_user(fig)
```","The input code accurately calculates the percentage of products shipped via each shipping method by joining the 'orders' table with the 'shippers' table. It then computes the percentage based on the count of orders for each company, similar to the reference implementation. The visualization as a pie chart is correctly implemented using Plotly, satisfying the user's request. The difference in naming (CompanyName vs ShipVia) does not affect the correctness as it addresses the same problem context.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT ShipVia, 
       (COUNT(ProductID) * 100.0 / SUM(COUNT(ProductID)) OVER ()) AS Percentage 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipVia;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a pie chart to visualize the shipment distribution
fig = px.pie(df, names='ShipVia', values='Percentage', title='Distribution of Shipping Methods')

# Show the pie chart to the user
show_to_user(fig)
```","The input code calculates percentages based on 'ProductID' counts from a join with 'Order Details', which does not align with the reference code that calculates based on 'OrderID' counts directly from 'orders'. The logic for determining percentage distributions differs between the two.",Base
"What is the total discount value given for each order, and can you provide a bar chart to visualize the discount values across different orders?","```python
import plotly.express as px
import pandas as pd

# SQL query to get the total discount value for each order
sql_query = """"""
SELECT od.OrderID, SUM(od.Quantity * od.UnitPrice * od.Discount) AS TotalDiscount 
FROM [Order Details] od 
GROUP BY od.OrderID;
""""""

# Execute the query and load the result into a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the discount values across different orders
fig = px.bar(df, x='OrderID', y='TotalDiscount', title='Total Discount Value Per Order')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, SUM(Discount) AS TotalDiscount
FROM [Order Details]
GROUP BY OrderID
""""""
discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='OrderID', y='TotalDiscount', title='Total Discount Value by Order')
show_to_user(fig)
```","The input code incorrectly calculates the total discount. It sums the 'Discount' column directly instead of multiplying 'Quantity', 'UnitPrice', and 'Discount'. The reference implementation correctly calculates the total discount per order as 'SUM(od.Quantity * od.UnitPrice * od.Discount)'.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation
    # Replace with actual SQL query execution code using a library like `sqlite3`, `pyodbc`, etc.
    # Here we return a sample DataFrame for demonstration purposes
    return pd.DataFrame({
        'OrderID': [1, 2, 3],
        'TotalDiscount': [150.0, 120.0, 200.0]
    })

# Utility function to display data analysis results
def show_to_user(data):
    # Mock implementation for demonstrating the result display
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# SQL query to fetch total discount value for each order
sql_query = """"""
SELECT o.OrderID, 
       SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.OrderID;
""""""

# Execute the query and get the result as a DataFrame
order_discounts_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the discount values across different orders using Plotly
fig = px.bar(order_discounts_df, x='OrderID', y='TotalDiscount', title='Total Discount Value per Order')

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates the total discount for each order using a SQL query and a mocked DataFrame, similar to the reference implementation. Although it uses a JOIN clause, it matches the logic of grouping by OrderID and summing the discounts. It then visualizes the discount values with a Plotly bar chart, which is also in line with the reference implementation. Thus, it meets the business analytics request.",Finetuned
"What is the correlation between unit price and quantity ordered for each product, and can it be visualized using a scatter plot with a trend line?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the correlation between unit price and quantity ordered for each product.
sql_query = """"""
SELECT ProductID, CORR(UnitPrice, Quantity) AS PriceQuantityCorrelation
FROM [Order Details]
GROUP BY ProductID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame.
correlation_df = execute_sql_query(sql_query)

# Check if correlation_df is not empty to avoid plotting errors
if not correlation_df.empty:
    # Visualize the correlation using a scatter plot with a trend line.
    fig = px.scatter(correlation_df, 
                     x='ProductID', 
                     y='PriceQuantityCorrelation', 
                     trendline='ols', 
                     title='Correlation between Unit Price and Quantity Ordered per Product',
                     labels={'PriceQuantityCorrelation': 'Correlation Coefficient'})
    # Display the plot to the user.
    show_to_user(fig)
else:
    print('No data available to plot.')
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, od.UnitPrice, od.Quantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
""""""

data = execute_sql_query(sql_query)

correlation_data = data.groupby(['ProductID', 'ProductName']).agg({'UnitPrice': 'mean', 'Quantity': 'sum'}).reset_index()
correlation = correlation_data['UnitPrice'].corr(correlation_data['Quantity'])

fig = px.scatter(correlation_data, x='UnitPrice', y='Quantity', trendline='ols', 
                 title='Correlation between Unit Price and Quantity Ordered',
                 labels={'UnitPrice': 'Unit Price', 'Quantity': 'Quantity Ordered'})
show_to_user(fig)
```","The input code calculates a single overall correlation between average unit price and total quantity ordered, while the reference code calculates the correlation for each individual ProductID. Additionally, the input code does not plot individual product correlations as intended in the original request, which is achieved by grouping in the SQL query of the reference code.","```python
import pandas as pd
import plotly.express as px
from scipy.stats import pearsonr

# SQL query to fetch data
sql_query = '''
SELECT p.ProductID, p.ProductName, p.UnitPrice, od.Quantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID;
'''

# Execute SQL query and retrieve data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution code
    # Example:
    # return pd.read_sql_query(sql_query, connection)
    pass

# Fetch data
df = execute_sql_query(sql_query)

# Calculate correlation
def calculate_correlation(df: pd.DataFrame):
    correlations = {}
    for product_id in df['ProductID'].unique():
        product_df = df[df['ProductID'] == product_id]
        corr, _ = pearsonr(product_df['UnitPrice'], product_df['Quantity'])
        correlations[product_id] = corr
    return correlations

correlations = calculate_correlation(df)

# Convert the correlations dictionary to a DataFrame for visualization
correlation_df = pd.DataFrame(list(correlations.items()), columns=['ProductID', 'Correlation'])

# Visualize using a scatter plot with trend line
fig = px.scatter(df, x='UnitPrice', y='Quantity', color='ProductName',
                 trendline='ols', title=""Unit Price vs Quantity Ordered"")
show_to_user(fig)
```","The input code calculates correlations between UnitPrice and Quantity for each product, but it uses an incorrect DataFrame (df) for visualization. It should visualize 'correlation_df', which contains product-wise correlation results. Also, the scatter plot should display ProductID vs. Correlation, not UnitPrice vs. Quantity. The trend line should show the relationship between ProductID and their correlations, matching the reference implementation's intent.",None
What is the most common ship region for orders? Please include a bar chart to visualize the frequency of orders by region.,"```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query is already defined and usable in this environment.

# SQL query to fetch the frequency of orders by ship region
sql_query = """"""
SELECT orders.ShipRegion, COUNT(orders.OrderID) AS RegionCount 
FROM orders 
GROUP BY orders.ShipRegion 
ORDER BY RegionCount DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
region_data = execute_sql_query(sql_query)

# Display a bar chart to visualize the frequency of orders by region
fig = px.bar(region_data, x='ShipRegion', y='RegionCount', title='Frequency of Orders by Region',
             labels={'ShipRegion': 'Ship Region', 'RegionCount': 'Number of Orders'})

# Use the utility function to show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, COUNT(*) AS OrderCount
FROM orders
GROUP BY ShipRegion
ORDER BY OrderCount DESC
""""""
data = execute_sql_query(sql_query)

fig = px.bar(data, x='ShipRegion', y='OrderCount', title='Frequency of Orders by Region')
show_to_user(fig)
```","The input code correctly answers the business analytics request by querying the orders table to count the frequency of orders by ship region. It uses a similar SQL query to the reference code, grouping by 'ShipRegion' and counting the orders, then ordering by the count in descending order. The naming of the count column ('OrderCount' vs. 'RegionCount') is different but serves the same purpose. Additionally, the input code uses Plotly Express to create a bar chart visualizing the frequency of orders by region, adhering to the same logic and visualization requirements as the reference implementation. Thus, the input code is correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to get frequency of orders by region
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipRegion 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get results in a DataFrame
order_data = execute_sql_query(sql_query)

# Check if order_data is not empty
if not order_data.empty:
    # Create a bar chart to visualize the frequency of orders by region
    fig = px.bar(order_data, x='ShipRegion', y='OrderCount', 
                 title='Frequency of Orders by Region', labels={'OrderCount': 'Number of Orders'})

    # Display the bar chart
    show_to_user(fig)
else:
    # Display a message if no data is found
    show_to_user(pd.DataFrame({'Message': ['No data found']}))
```","The input code correctly follows the logic of the reference implementation. It executes a SQL query to get the frequency of orders by ship region, orders the results by count, and then uses Plotly to create a bar chart of the results. The check for an empty DataFrame and a backup message if no data is found does not affect the core logic and functionality. The input code achieves the same outcome as the reference code.",both
"What is the inventory turnover ratio for each product category in June 2023, and can this be visualized using a bar chart to compare categories?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to mimic SQL execution
    # Replace with actual database interaction code
    pass

def show_to_user(data):
    # Placeholder function to display data
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to calculate inventory turnover ratio
sql_query = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS inventory_turnover_ratio 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE DATE_FORMAT(orders.OrderDate, '%Y-%m') = '2023-06' 
GROUP BY categories.CategoryName
""""""

# Execute the SQL query and fetch the result as a DataFrame
df = execute_sql_query(sql_query)

# Check if df is not None and has data
if df is not None and not df.empty:
    # Create a bar chart using Plotly
    fig = px.bar(df, x='CategoryName', y='inventory_turnover_ratio', title='Inventory Turnover Ratio for Each Product Category in June 2023')

    # Show the bar chart to the user
    show_to_user(fig)
else:
    print(""No data available for the given query."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CategoryName, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) AS InventoryTurnoverRatio 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN categories c ON p.CategoryID = c.CategoryID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-06-01' AND '2023-06-30' 
GROUP BY c.CategoryName
""""""

inventory_turnover_data = execute_sql_query(sql_query)

fig = px.bar(inventory_turnover_data, 
             x='CategoryName', 
             y='InventoryTurnoverRatio', 
             title='Inventory Turnover Ratio by Product Category in June 2023')

show_to_user(fig)
```","The input code is functionally equivalent to the reference code. Both SQL queries calculate the inventory turnover ratio per product category for June 2023, using the same fields and aggregations. The only difference is the method used to filter for June 2023—'BETWEEN' versus 'DATE_FORMAT'—both achieving the same goal. The visualization part using Plotly is identical, creating a bar chart to compare categories. Therefore, the code correctly answers the request and adheres to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assume these utility functions are predefined
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Code to execute SQL query and return a pandas DataFrame
    pass

def show_to_user(data):
    # Code to display data or visualization
    pass

# SQL query to fetch the inventory turnover ratio
sql_query = """"""
WITH turnover_summary AS (
    SELECT 
        products.CategoryID,
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / AVG(products.UnitsInStock) AS inventory_turnover 
    FROM 
        [Order Details] 
    JOIN 
        products ON [Order Details].ProductID = products.ProductID 
    JOIN 
        orders ON [Order Details].OrderID = orders.OrderID 
    WHERE 
        EXTRACT(YEAR FROM orders.OrderDate) = 2023 
        AND EXTRACT(MONTH FROM orders.OrderDate) = 6 
    GROUP BY 
        products.CategoryID
)

SELECT 
    categories.CategoryName, 
    inventory_turnover 
FROM 
    turnover_summary 
JOIN 
    categories ON turnover_summary.CategoryID = categories.CategoryID
""""""

# Execute the SQL query and load the result into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for inventory turnover ratio by product category
fig = px.bar(df, x='CategoryName', y='inventory_turnover', 
             title='Inventory Turnover Ratio by Product Category for June 2023',
             labels={'inventory_turnover': 'Inventory Turnover Ratio'},
             color='CategoryName')

# Display the bar chart to the user
show_to_user(fig)
```","Both implementations focus on calculating the inventory turnover ratio for each product category in June 2023. The logic includes joining 'Order Details' with 'products', 'categories', and 'orders', filtering by the specified date, and grouping by category. The input code also accounts for any discounts in the calculation, which adds detail but does not deviate from the core requirement. Both codes then visualize the results using a bar chart with Plotly. The input code correctly addresses the business analytics request using a similar logic to the reference implementation.",both
"Are there any orders with zero freight costs, and if so, how many? If applicable, visualize the distribution of freight costs with a bar chart showing the count of orders for each cost category, highlighting zero freight cost.","
```python
import plotly.express as px
import pandas as pd

# Define the SQL query to find orders with zero freight costs
sql_query = ""SELECT Freight FROM orders""

# Execute the SQL query using the provided utility function
freight_data = execute_sql_query(sql_query)

# Check for zero freight costs
zero_freight_count = len(freight_data[freight_data['Freight'] == 0])

# Print the count of zero freight orders
print(""Number of orders with zero freight costs:"", zero_freight_count)

# Visualize the distribution of freight costs
freight_distribution = freight_data['Freight'].value_counts().reset_index()
freight_distribution.columns = ['FreightCost', 'OrderCount']

# Create a bar chart using Plotly
fig = px.bar(
    freight_distribution,
    x='FreightCost',
    y='OrderCount',
    title='Distribution of Freight Costs',
    labels={'FreightCost': 'Freight Cost', 'OrderCount': 'Number of Orders'},
    color=freight_distribution['FreightCost'].apply(lambda x: 'Zero' if x == 0 else 'Non-zero'),
    color_discrete_map={'Zero': 'red', 'Non-zero': 'blue'}
)

# Use the utility function to show the visual to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Freight FROM orders""
df_orders = execute_sql_query(sql_query)

zero_freight_count = (df_orders['Freight'] == 0).sum()

freight_distribution = df_orders['Freight'].value_counts().reset_index()
freight_distribution.columns = ['Freight', 'Count']
freight_distribution['Freight'] = freight_distribution['Freight'].astype(str)

fig = px.bar(freight_distribution, x='Freight', y='Count', title='Distribution of Freight Costs', 
             color='Freight', color_discrete_sequence=['gray' if f != '0' else 'red' for f in freight_distribution['Freight']])
show_to_user(fig)

zero_freight_count
```","The input Python code correctly implements the business analytics request. It queries the 'Freight' column from the 'orders' table, counts the number of orders with zero freight cost using 'sum()' on a boolean condition, and generates a bar chart of the freight cost distribution using Plotly, with zero costs highlighted in red. The logic aligns with the reference implementation, although there are minor differences in syntax and implementation details.","```python
import pandas as pd
import plotly.express as px

# SQL query to find zero freight cost orders
sql_query_zero_freight = ""SELECT OrderID FROM orders WHERE Freight = 0;""

# SQL query to get the distribution of all freight costs
sql_query_all_freight = ""SELECT Freight FROM orders;""

# Execute the SQL query to check for zero freight costs
zero_freight_orders_df = execute_sql_query(sql_query_zero_freight)

# Execute the SQL query to get distribution of all freight costs
all_freight_df = execute_sql_query(sql_query_all_freight)

# Count the number of orders with zero freight costs
count_zero_freight_orders = zero_freight_orders_df.shape[0]

# Display the count of zero freight cost orders
zero_freight_orders_df['Count'] = 1  # Optional for display purpose
show_to_user(zero_freight_orders_df[['OrderID', 'Count']])

# Create a bar chart to visualize the distribution of freight costs
freight_distribution = all_freight_df.groupby('Freight').size().reset_index(name='Count')

# Highlight zero freight cost
freight_distribution['ZeroFreight'] = freight_distribution['Freight'] == 0

fig = px.bar(
    freight_distribution,
    x='Freight',
    y='Count',
    color='ZeroFreight',
    labels={'Count': 'Number of Orders', 'Freight': 'Freight Cost'},
    title='Distribution of Freight Costs'
)

# Show the bar chart
show_to_user(fig)
```","The input code correctly identifies orders with zero freight costs and visualizes the distribution of freight costs. Both the reference and input codes query for freight data, count zero freight orders, and create a bar chart to display the distribution, highlighting zero freight costs. The logic and outcome are consistent with the reference implementation.",both
"Which employee has the highest sales in the western region, and can you provide a bar chart to visualize the sales performance of each employee in that region?","```python
import pandas as pd
import plotly.express as px

# Assuming the utility function to execute the SQL and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation; replace with database connection logic
    pass

# Assuming the utility function to display data or visualizations
def show_to_user(data):
    # Dummy implementation; replace with actual display logic
    pass

# SQL query to retrieve all employees' sales in Western region
sql_query_all_sales = """"""
SELECT 
    employees.EmployeeID, 
    employees.FirstName, 
    employees.LastName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
WHERE territories.RegionID = (SELECT RegionID FROM region WHERE RegionDescription = 'Western') 
GROUP BY employees.EmployeeID 
ORDER BY total_sales DESC
""""""

# Retrieve data for all employees in the Western region
sales_data = execute_sql_query(sql_query_all_sales)

# Ensure sales_data is not empty
if not sales_data.empty:
    # Find the employee with the highest sales
    top_employee = sales_data.iloc[0]

    # Print the employee with the highest sales
    print(f""Top Employee: {top_employee['FirstName']} {top_employee['LastName']} with Sales: {top_employee['total_sales']}"")

    # Create a bar chart to visualize sales performance
    fig = px.bar(sales_data, x='FirstName', y='total_sales', title='Sales Performance of Employees in Western Region')

    # Display the bar chart using the provided utility function
    show_to_user(fig)
else:
    print(""No sales data found for the Western region."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.ShipRegion = 'Western'
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
ORDER BY employee_sales DESC
""""""

employee_sales_df = execute_sql_query(sql_query)
highest_sales_employee = employee_sales_df.iloc[0]

bar_chart = px.bar(employee_sales_df, 
                   x='FirstName + "" "" + LastName',
                   y='employee_sales', 
                   title='Sales Performance of Employees in the Western Region',
                   labels={'FirstName + "" "" + LastName': 'Employee', 'employee_sales': 'Total Sales'})

show_to_user(bar_chart)
```","The input code's SQL query logic is incorrect because it uses 'orders.ShipRegion' instead of joining the territories to filter by the 'Western' region. The aggregate and filtering logic should be similar to the reference implementation to ensure all territories linked to the Western region are considered for sales, which is not achieved by merely checking 'orders.ShipRegion'. Additionally, the code attempts to reference concatenated strings as columns in Plotly, which will not work as the reference implementation expects individual columns for 'FirstName' and 'LastName'.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are pre-defined utility functions as specified

def get_top_employee_and_viz_sales():
    # SQL query to fetch employee sales data for the Western region
    sql_query = '''
    SELECT e.EmployeeID, 
           SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
    FROM employees e 
    JOIN orders o ON e.EmployeeID = o.EmployeeID 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    JOIN shippers s ON o.ShipVia = s.ShipperID 
    WHERE o.ShipRegion = 'Western region' 
    GROUP BY e.EmployeeID
    ORDER BY TotalSales DESC;
    '''
    
    # Execute SQL query and get data
    sales_data = execute_sql_query(sql_query)
    
    # Display the employee with the highest sales
    top_employee = sales_data.iloc[0]  # Top employee is the first row after sorting
    show_to_user(top_employee.to_frame().transpose())  # Show details of top employee

    # Create a bar chart to visualize sales performance of each employee
    fig = px.bar(sales_data, x='EmployeeID', y='TotalSales',
                 title='Sales Performance by Employee in Western Region',
                 labels={'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'},
                 text='TotalSales')

    fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
    fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')

    # Display the bar chart
    show_to_user(fig)

# Call the function to execute
get_top_employee_and_viz_sales()
```","The input code execution differs from the reference implementation in logic. The SQL query in the input code uses 'o.ShipRegion = 'Western region'', which assumes 'Western region' is a value in the ShipRegion column. In contrast, the reference code selects based on RegionDescription from a 'region' table which is correctly joined via territories. This could result in different datasets being fetched. Furthermore, the code does not join with employee names, so the top employee does not display full names, which were part of the requirement in the reference code.",None
Find the trend of order fulfillment time over the last year and visualize it with a line chart.,"```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for code testing
    # In practice, this function will execute an SQL query and return a DataFrame
    data = {
        'Month': ['2022-09', '2022-10', '2022-11', '2022-12', '2023-01', '2023-02', '2023-03', '2023-04', '2023-05', '2023-06', '2023-07', '2023-08'],
        'AvgFulfillmentTime': [5.2, 4.8, 6.1, 5.9, 5.3, 5.6, 4.9, 5.5, 5.8, 5.1, 4.7, 5.0]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock implementation for code testing
    # In practice, this function displays data analysis or visualization results
    print(data)

# SQL Query
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM 
    orders 
WHERE 
    OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m') 
ORDER BY 
    Month;
""""""

# Execute the SQL query and retrieve the results into a DataFrame
df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize the trend of order fulfillment time
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Order Fulfillment Time Trend Over the Last Year', labels={'AvgFulfillmentTime': 'Avg Fulfillment Time (Days)'})

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
WHERE 
    OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='OrderMonth', y='AvgFulfillmentTime', 
              title='Trend of Order Fulfillment Time Over the Last Year',
              labels={'OrderMonth': 'Month', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})

show_to_user(fig)
```","The input Python code adheres to the same logic as the reference implementation. Both codes execute an SQL query to calculate the average fulfillment time grouped by month over the last year, store the results in a DataFrame, and use Plotly to create a line chart for visualization. The minor differences in variable names ('OrderMonth' vs. 'Month') do not affect the logic or correctness of the code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get average fulfillment times over the last year
sql_query = """"""
SELECT
    EXTRACT(MONTH FROM OrderDate) AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM
    orders
WHERE
    OrderDate >= CURRENT_DATE - INTERVAL '1 YEAR'
GROUP BY
    EXTRACT(YEAR FROM OrderDate),
    EXTRACT(MONTH FROM OrderDate)
ORDER BY
    Month;
""""""

# Step 1: Execute the SQL query to retrieve the data
data = execute_sql_query(sql_query)

# Step 2: Visualize the trend of order fulfillment time using a line chart
fig = px.line(data, x='Month', y='AvgFulfillmentTime', title='Trend of Order Fulfillment Time Over the Last Year',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)', 'Month': 'Month'})

# Display the visualization to the user
show_to_user(fig)
```","The input code uses 'EXTRACT(MONTH FROM OrderDate)' for the Month field, causing the 'Month' to be represented only by the month part (1-12) and potentially mixing data from different years. The reference code uses 'DATE_FORMAT(OrderDate, '%Y-%m')' to include both year and month, which is correct and avoids potential aggregation issues over multiple years.",Base
Find the top 5 customers by lifetime value and create a bar chart to visualize their comparative values.,"
```python
import plotly.express as px
import pandas as pd

# Business Analytic Request Implementation

# SQL query provided
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS LifetimeValue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY LifetimeValue DESC 
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 customers by lifetime value
fig = px.bar(df, x='CustomerID', y='LifetimeValue',
             title='Top 5 Customers by Lifetime Value',
             labels={'LifetimeValue': 'Lifetime Value', 'CustomerID': 'Customer ID'})

# Display the bar chart to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    c.CustomerID,
    c.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue
FROM
    customers c
JOIN
    orders o ON c.CustomerID = o.CustomerID
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY
    c.CustomerID, c.CompanyName
ORDER BY
    LifetimeValue DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, 
              x='CompanyName', 
              y='LifetimeValue', 
              title='Top 5 Customers by Lifetime Value',
              labels={'LifetimeValue': 'Lifetime Value', 'CompanyName': 'Customer Name'})

show_to_user(fig)
```","The input code correctly implements the same logic as the reference code. It calculates the lifetime value for each customer and retrieves the top 5 customers by this metric. The primary difference is that the input code also includes 'CompanyName' in the selection and uses it for labeling in the bar chart, which is a valid enhancement and does not alter the correctness regarding the business request.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for context
    # This function would normally execute the SQL against a database and return a DataFrame.
    pass

# Utility function to display data
def show_to_user(data):
    # Dummy implementation for context
    # This function would display data analysis or visualization results to the user.
    pass

# SQL query to find the top 5 customers by lifetime value
sql_query = """"""
SELECT c.CustomerID, c.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID, c.CompanyName 
ORDER BY LifetimeValue DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 customers by lifetime value
fig = px.bar(
    top_customers_df,
    x='CompanyName',
    y='LifetimeValue',
    title=""Top 5 Customers by Lifetime Value"",
    labels={'LifetimeValue': 'Lifetime Value', 'CompanyName': 'Customer'}
)

# Display the bar chart to the user
show_to_user(fig)
```","The evaluated code correctly calculates the top 5 customers by lifetime value using a SQL query that aggregates order details. It includes both the `CustomerID` and `CompanyName` for richer information, which does not deviate from the business request. The logic for calculating lifetime value is consistent with the reference. It then visualizes the data using a bar chart with the company names on the x-axis, which is a valid adaptation of the visualization task without altering the results. Overall, the logic and outcome align with the reference implementation.",both
"Which month had the highest number of orders, and can you provide a bar chart to illustrate the monthly orders?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch order data
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EXTRACT(MONTH FROM OrderDate);
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Analyze data to find the month with the highest number of orders
highest_orders = order_data.loc[order_data['OrderCount'].idxmax()]

# Output the analysis result
show_to_user(pd.DataFrame([highest_orders]))

# Create a bar chart to illustrate the monthly orders
fig = px.bar(order_data, x='Month', y='OrderCount', title='Monthly Order Count')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS OrderMonth, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY OrderMonth
ORDER BY OrderCount DESC
LIMIT 1
""""""

highest_month = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT DATE_TRUNC('month', OrderDate) AS OrderMonth, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY OrderMonth
ORDER BY OrderMonth
""""""

monthly_orders = execute_sql_query(sql_query_all)

fig = px.bar(monthly_orders, x='OrderMonth', y='OrderCount', title='Monthly Orders', labels={'OrderMonth': 'Month', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input code accomplishes the same task as the reference code but in a slightly different way. It first fetches the month with the highest number of orders directly using a SQL query with ORDER BY and LIMIT, which is efficient. Then, it retrieves the complete monthly order data set to create the bar chart. This matches the reference code's logic of determining the month with the highest orders and displaying a bar chart of all monthly orders. Although the method is different, the outcome and logic adhere to the business task requirements.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY Month
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query
monthly_orders_df = execute_sql_query(sql_query)

# Identify the Month with the highest number of orders
max_orders_row = monthly_orders_df.iloc[0]

# Visualize the monthly orders in a bar chart using Plotly
fig = px.bar(monthly_orders_df, x='Month', y='NumberOfOrders', 
             title='Monthly Orders', labels={'NumberOfOrders': 'Number of Orders'})

# Highlight the month with the highest number of orders
fig.update_traces(marker_color=['red' if month == max_orders_row['Month'] else 'blue' 
                                for month in monthly_orders_df['Month']])

# Display the bar chart to the user
show_to_user(fig)

# Additionally, show the row with the highest number of orders
show_to_user(pd.DataFrame([max_orders_row]))","The input code uses DATE_FORMAT to group orders by year and month, producing monthly order counts with a YYYY-MM format, unlike the reference code's extraction of month only. This can lead to different grouping and results. Additionally, the input code assumes the first row of the results is the highest order count, dependent on SQL's ORDER BY. While showcasing, it highlights the maximum month differently, which is an extra feature, but acceptable. However, the grouping logic deviates significantly from the reference implementation.",Base
What percentage of customers are returning customers within the last month? Please include a pie chart to visualize the proportion of returning versus new customers.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are predefined utility functions

sql_query = """"""
SELECT 
    COUNT(DISTINCT CASE WHEN orders.OrderDate BETWEEN CURRENT_DATE - INTERVAL '1 month' AND CURRENT_DATE 
    THEN orders.CustomerID ELSE NULL END) AS ReturningCustomerCount,
    COUNT(DISTINCT CASE WHEN orders.OrderDate >= CURRENT_DATE - INTERVAL '1 month' AND orders.OrderDate < CURRENT_DATE 
    THEN orders.CustomerID ELSE NULL END) AS TotalCustomerCount
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate retention rate
returning_customer_count = df['ReturningCustomerCount'].iloc[0]
total_customer_count = df['TotalCustomerCount'].iloc[0]

new_customers_count = total_customer_count - returning_customer_count
returning_percentage = (returning_customer_count / total_customer_count) * 100
new_percentage = 100 - returning_percentage

# Create the data for visualization
data = {
    'Customer Type': ['Returning', 'New'],
    'Count': [returning_customer_count, new_customers_count],
    'Percentage': [returning_percentage, new_percentage]
}

visualization_df = pd.DataFrame(data)

# Create a pie chart using Plotly
fig = px.pie(
    visualization_df,
    names='Customer Type',
    values='Count',
    title='Proportion of Returning vs. New Customers',
    labels={'Count': 'Number of Customers'},
)

# Display the visualization
show_to_user(fig)
```","```python
from datetime import datetime, timedelta
import pandas as pd
import plotly.express as px

# Calculate the date range for the last month
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# SQL query to fetch the relevant customer and order data
sql_query = f""""""
SELECT 
    COUNT(DISTINCT orders.CustomerID) AS returning_customers
FROM orders
WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
""""""

returning_customers_df = execute_sql_query(sql_query)

sql_query_total = """"""
SELECT 
    COUNT(DISTINCT CustomerID) AS total_customers
FROM orders
WHERE OrderDate < '{start_date.strftime('%Y-%m-%d')}'
""""""

total_customers_df = execute_sql_query(sql_query_total)

returning_customers = returning_customers_df['returning_customers'].iloc[0]
total_customers = total_customers_df['total_customers'].iloc[0]

percentage_returning = (returning_customers / total_customers) * 100 if total_customers > 0 else 0

# Pie chart visualization
fig = px.pie(
    names=['Returning Customers', 'New Customers'],
    values=[returning_customers, total_customers - returning_customers],
    title='Proportion of Returning vs New Customers'
)

show_to_user(fig)

result = pd.DataFrame({
    'Metric': ['Returning Customers', 'New Customers'],
    'Percentage': [percentage_returning, 100 - percentage_returning]
})

show_to_user(result)
```","The input code calculates total customers as those who ordered before the start date of the last month, not including the current month's data, unlike the reference. The reference includes all orders in the last month for total customers. Additionally, the visualization in the input uses static labels and does not pass a DataFrame, which is inconsistent with the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation, replace with actual database query execution
    # The real implementation would connect to the database and fetch the results.
    if ""returning_customers_query"" in sql_query:
        return pd.DataFrame({'returning_customers': [0.40]})
    # This would normally execute a query and return a DataFrame.

# Execute query to find returning customers within the last month
returning_customers_query = """"""
SELECT (COUNT(DISTINCT o1.CustomerID) * 1.0 / 
        (SELECT COUNT(DISTINCT o2.CustomerID) 
         FROM orders o2 
         WHERE o2.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 MONTH) AND CURDATE())
        ) AS returning_customers 
FROM orders o1 
WHERE o1.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 MONTH) AND CURDATE()
AND o1.CustomerID IN 
    (SELECT o2.CustomerID 
     FROM orders o2 
     WHERE o2.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 MONTH));
""""""

# Execute the SQL query to get the returning customer percentage
returning_customers_df = execute_sql_query(returning_customers_query)

# Calculate the percentage of new customers
returning_percentage = returning_customers_df['returning_customers'].iloc[0]
new_percentage = 1 - returning_percentage

# Create a DataFrame for visualization
customers_data = pd.DataFrame({
    'Customer_Type': ['Returning', 'New'],
    'Percentage': [returning_percentage, new_percentage]
})

# Create a pie chart
fig = px.pie(customers_data, names='Customer_Type', values='Percentage', title='Customer Types in the Last Month')

# Show the pie chart to the user
show_to_user(fig)
```","The input code incorrectly calculates the 'returning_customers' percentage. It directly uses a fixed value (0.40) for the returning customer percentage in the mocked `execute_sql_query` function, which does not represent the correct logic as per the reference implementation. The reference code compares distinct customer counts from current and previous periods, but the input code doesn't perform this comparison correctly or retrieve actual counts, leading to incorrect calculations in practice. Furthermore, the input code incorrectly calculates 'new_percentage' as if 'returning_percentage' were a fraction whereas it should be a percentage.",None
"What is the total number of orders placed per month, and can this be visualized in a line or bar chart to show trends over time?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT TO_CHAR(o.OrderDate, 'YYYY-MM') AS Month, 
       COUNT(o.OrderID) AS NumberOfOrders 
FROM orders o 
GROUP BY TO_CHAR(o.OrderDate, 'YYYY-MM');
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Sort the DataFrame by Month to ensure proper order in visualization
orders_df = orders_df.sort_values(by='Month')

# Create a bar chart to visualize the number of orders per month
fig = px.bar(orders_df, x='Month', y='NumberOfOrders', 
             title='Total Number of Orders Placed Per Month',
             labels={'NumberOfOrders': 'Number of Orders', 'Month': 'Month'},
             text='NumberOfOrders')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

orders_per_month = execute_sql_query(sql_query)

fig = px.line(orders_per_month, x='Month', y='TotalOrders', title='Total Orders Placed Per Month')
show_to_user(fig)
```","The input Python code answers the business analytics request correctly. It calculates the total number of orders placed per month using SQL and visualizes the result using a line chart, similar to the bar chart used in the reference implementation. Both implementations group by month and count orders, ensuring they capture the trend over time, and they both sort the results by month.","```python
import plotly.express as px

# SQL query to fetch total number of orders per month
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month, 
       COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY EXTRACT(YEAR FROM OrderDate), 
         EXTRACT(MONTH FROM OrderDate)
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Data processing: Combine Year and Month for a better x-axis representation
orders_df['YearMonth'] = orders_df.apply(lambda x: f""{int(x['Year'])}-{int(x['Month']):02d}"", axis=1)

# Visualize the total number of orders per month using a line chart
fig = px.line(orders_df, x='YearMonth', y='TotalOrders', 
              labels={'YearMonth': 'Year-Month', 'TotalOrders': 'Total Orders'},
              title='Total Number of Orders Placed Per Month')

# Showing the plot to the user
show_to_user(fig)
```","Both implementations correctly retrieve the total number of orders per month from the 'orders' table. The reference code uses 'TO_CHAR' to extract the 'YYYY-MM' format of the date directly, while the input code extracts year and month separately and then combines them into a formatted string. Both outputs are functionally identical, as both result in a string representing year and month in 'YYYY-MM' format. The data is then sorted implicitly when creating the YearMonth string, which ensures correct order. The chart types differ (bar vs. line chart), but they both adequately satisfy the request to visualize trends over time.",both
What is the frequency distribution of order quantities? Please include a histogram to enhance understanding.,"```python
import plotly.express as px
import pandas as pd

# SQL Query to get the frequency distribution of order quantities
sql_query = """"""
SELECT Quantity, COUNT(*) AS Frequency
FROM [Order Details]
GROUP BY Quantity
ORDER BY Frequency DESC;
""""""

# Execute the SQL query and load the data into a DataFrame
order_data_df = execute_sql_query(sql_query)

# Display the raw data to the user
show_to_user(order_data_df)

# Create a histogram using Plotly for better visualization
fig = px.bar(order_data_df, x='Quantity', y='Frequency',
             title='Frequency Distribution of Order Quantities',
             labels={'Quantity': 'Order Quantity', 'Frequency': 'Frequency'},
             template='plotly')

# Show the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.Quantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
""""""

order_data = execute_sql_query(sql_query)

fig = px.histogram(order_data, x='Quantity', title='Frequency Distribution of Order Quantities', 
                   labels={'Quantity': 'Order Quantity'}, nbins=20)
show_to_user(fig)
```","The input code performs a straight selection of quantities and then attempts to plot a histogram, applying a binning approach directly to the data without computing the frequency distribution beforehand. The reference code, however, groups data by quantity and computes the frequency of each quantity before visualizing it using a bar chart. The two approaches are logically different since the reference code reflects exact counts and frequencies per unique quantity, while the input code uses binning, which may not represent frequencies as precisely or accurately.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT Quantity, COUNT(*) as Frequency 
FROM [Order Details] 
GROUP BY Quantity 
ORDER BY Frequency DESC;
""""""

# Execute the SQL query and get the results in a DataFrame
order_details_df = execute_sql_query(sql_query)

# Create a histogram using Plotly to visualize the frequency distribution
fig = px.histogram(order_details_df, x='Quantity', y='Frequency', 
                   title='Frequency Distribution of Order Quantities', 
                   labels={'Quantity': 'Order Quantity', 'Frequency': 'Frequency'},
                   histnorm='count',  # Change to 'probability' for frequency percentage
                   nbins=len(order_details_df))

# Show the histogram to the user
show_to_user(fig)
```","The input code uses `px.histogram` instead of `px.bar`. Although a histogram can represent frequency distribution, it traditionally bins data, which is not needed here. The use of `histnorm` and `nbins` is unnecessary for the task, as the data is already aggregated and grouped by quantity, making `px.bar` the correct choice to directly display this information.",None
"What is the most common shipping method used, and can you provide a bar chart to display the distribution of shipping methods?","```python
import pandas as pd
import plotly.express as px

# Define the provided utility function for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Example implementation of execution (mocked for this context)
    # Normally, this would connect to a database and fetch results
    data = {
        'ShipVia': ['Ground', 'Air', 'Freight'],
        'OrderCount': [120, 80, 50]
    }
    return pd.DataFrame(data)

# Define the provided utility function for displaying results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query based on the business analytic request
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipVia 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query to get the data
shipping_data = execute_sql_query(sql_query)

# Display the most common shipping method
most_common_shipping_method = shipping_data.iloc[0]
show_to_user(pd.DataFrame([most_common_shipping_method]))

# Create a bar chart to display the distribution of shipping methods
fig = px.bar(shipping_data, x='ShipVia', y='OrderCount', title='Distribution of Shipping Methods')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) as Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
""""""

shipping_methods_df = execute_sql_query(sql_query)

most_common_shipping_method = shipping_methods_df.iloc[0]

fig = px.bar(shipping_methods_df, x='ShipVia', y='Frequency', 
             title='Distribution of Shipping Methods', 
             labels={'ShipVia': 'Shipping Method', 'Frequency': 'Number of Orders'})
show_to_user(fig)
```","The input Python code fulfills the business analytics request correctly. It executes a SQL query to count and group orders by shipping method, sorts them by frequency, determines the most common method, and visualizes the distribution with a bar chart. The logic is consistent with the reference implementation, with minor differences in variable names and labels, which do not affect correctness.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the distribution of shipping methods
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS Count
FROM orders
GROUP BY ShipVia
ORDER BY Count DESC;
""""""

# Execute the SQL query and get a DataFrame
shipping_data = execute_sql_query(sql_query)

# Create a bar chart to display the distribution of shipping methods
fig = px.bar(shipping_data, x='ShipVia', y='Count', title='Distribution of Shipping Methods')

# Display the bar chart to the user
show_to_user(fig)
```",The input code does not display the most common shipping method explicitly. The reference code includes an additional step to extract and print the most common shipping method using DataFrame operations. This explicit output of the most common shipping method is missing in the input code.,Base
"What is the average shipping cost per order each month, and can you provide a line chart to visualize trends over time?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average shipping cost per order each month
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query and retrieve the results
df = execute_sql_query(sql_query)

# Create a line chart to visualize the average shipping cost per order each month
fig = px.line(df, x='Month', y='AvgShippingCost', title='Average Shipping Cost Per Order Each Month')

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    AVG(Freight) AS AverageShippingCost
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

average_shipping_cost_df = execute_sql_query(sql_query)

fig = px.line(average_shipping_cost_df, x='OrderMonth', y='AverageShippingCost', 
              title='Average Shipping Cost per Order Each Month',
              labels={'OrderMonth': 'Month', 'AverageShippingCost': 'Average Shipping Cost'})
show_to_user(fig)
```","The input Python code correctly implements the requested business analytics. It calculates the average shipping cost per order for each month by using the SQL query to group by formatted order date. The use of DATE_FORMAT and AVG functions matches the logic of the reference implementation. A line chart is created using Plotly Express to visualize the trends, which aligns with the reference code's intent. The ordering of the results is explicitly added in the input code, which ensures the correct sequence for plotting.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       AVG(orders.Freight) AS average_shipping_cost 
FROM orders 
GROUP BY month;
""""""

# Execute the SQL query using utility function
df = execute_sql_query(sql_query)

# Generate the line chart using Plotly
fig = px.line(df, x='month', y='average_shipping_cost', 
              title='Average Shipping Cost Per Order Each Month',
              labels={'month': 'Month', 'average_shipping_cost': 'Avg. Shipping Cost'},
              markers=True)

# Display the line chart
show_to_user(fig)
```","The input code correctly addresses the business analytics request by calculating the average shipping cost per order each month using a SQL query, similarly to the reference. The SQL queries both perform the necessary aggregation to calculate the average and group by month. The input code uses `DATE_FORMAT` instead of `DATE_TRUNC`, which is suitable for the specific SQL dialect in use. Additionally, the input code generates a line chart using Plotly, similar to the reference. The inclusion of markers is an enhancement that does not violate the request.",both
Identify the product with the highest inventory turnover ratio and present the findings with a comparative bar chart of inventory turnover ratios for all products.,"```python
import pandas as pd
import plotly.express as px

# Mock execute_sql_query function (Replace this with the actual function that executes your SQL query)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Implement database query execution and return DataFrame
    return pd.DataFrame({
        'ProductID': [1, 2, 3],  # Example Product IDs
        'InventoryTurnoverRatio': [2.5, 3.7, 1.9]  # Example Ratios
    })

# Mock show_to_user function (Replace this with the actual function to display data or visualization)
def show_to_user(data):
    # Placeholder function: Implement logic to display DataFrame or Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)  # For demonstration purposes, replace this with actual display logic
    else:
        data.show()  # For Plotly figures

# SQL query to fetch inventory turnover ratios
sql_query = """"""
    SELECT p.ProductID, 
           (SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0)) AS InventoryTurnoverRatio 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    GROUP BY p.ProductID 
    ORDER BY InventoryTurnoverRatio DESC;
""""""

# Execute the SQL query to get the inventory turnover data
df = execute_sql_query(sql_query)

# Identify the product with the highest inventory turnover ratio
highest_turnover_product = df.iloc[0]

# Display the product with the highest inventory turnover ratio
print(f""Product with the highest inventory turnover ratio: ProductID {highest_turnover_product['ProductID']} with a ratio of {highest_turnover_product['InventoryTurnoverRatio']}"")

# Create a comparative bar chart for inventory turnover ratios
fig = px.bar(df, x='ProductID', y='InventoryTurnoverRatio', title='Inventory Turnover Ratios for Products', labels={'ProductID': 'Product ID', 'InventoryTurnoverRatio': 'Turnover Ratio'})

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice) AS CostOfGoodsSold, 
       AVG(p.UnitsInStock) AS AverageInventory
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

product_data = execute_sql_query(sql_query)
product_data['InventoryTurnoverRatio'] = product_data['CostOfGoodsSold'] / product_data['AverageInventory']

highest_turnover_product = product_data.loc[product_data['InventoryTurnoverRatio'].idxmax()]

fig = px.bar(product_data, x='ProductName', y='InventoryTurnoverRatio', 
             title='Inventory Turnover Ratios for All Products',
             labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'ProductName': 'Product Name'})

show_to_user(fig)

highest_turnover_product[['ProductName', 'InventoryTurnoverRatio']]
```","The input Python code correctly implements the business analytics request. It calculates the inventory turnover ratio for each product, identifies the product with the highest ratio, and displays a bar chart of turnover ratios. The logic matches the reference implementation as it computes the ratio using the formula CostOfGoodsSold / AverageInventory for each product, selects the maximum rate, and displays the results in a bar chart. The inclusion of product names makes the chart more informative, which is an acceptable enhancement.","```python
import pandas as pd
import plotly.express as px

# Predefined utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution code
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    pass

# Business Analysis Code
sql_query = """"""
SELECT 
    p.ProductID, 
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio 
FROM 
    products p 
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY 
    p.ProductID
ORDER BY 
    InventoryTurnoverRatio DESC;
""""""

inventory_data = execute_sql_query(sql_query)

# Assuming the first row is the product with the highest inventory turnover ratio
print(inventory_data)

# Visualizing a bar chart of inventory turnover ratios for all products
fig = px.bar(inventory_data, 
             x='ProductID', 
             y='InventoryTurnoverRatio', 
             title='Inventory Turnover Ratios for All Products',
             labels={'ProductID': 'Product ID', 'InventoryTurnoverRatio': 'Inventory Turnover Ratio'})

# Display the plot
show_to_user(fig)
```","The input code correctly implements the business analytics request. It retrieves inventory turnover ratios for each product using an SQL query similar to the reference code, identifies the product with the highest ratio (implicitly by ordering the results), and visualizes the data with a bar chart. The key logic of calculating and displaying inventory turnover ratios is adhered to, making the input implementation align with the reference implementation.",both
"What is the trend of total sales revenue over the quarters, and can this be visualized with a line chart to show changes over time?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('quarter', o.OrderDate) AS Quarter, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN ""Order Details"" od ON o.OrderID = od.OrderID 
GROUP BY Quarter 
ORDER BY Quarter;
""""""

# Fetch the data using the utility function
sales_data = execute_sql_query(sql_query)

# Visualize the trend of total sales revenue over the quarters using a line chart
fig = px.line(sales_data, x='Quarter', y='TotalSales', title='Quarterly Total Sales Revenue Trend')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Quarter,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Quarter
ORDER BY 
    Quarter
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='Quarter', y='TotalSales', title='Total Sales Revenue Over Quarters')
show_to_user(fig)
```","The input code uses DATE_FORMAT with '%Y-%m' which formats dates to year-month, not quarters. This deviates from the reference code, which uses DATE_TRUNC('quarter') to aggregate by quarters. Therefore, the input code does not precisely answer the query as the reference.","```python
import pandas as pd
import plotly.express as px

# SQL query to get revenue by quarter
sql_query = """"""
SELECT YEAR(orders.OrderDate) AS Year, 
       QUARTER(orders.OrderDate) AS Quarter, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] 
ON orders.OrderID = [Order Details].OrderID 
GROUP BY YEAR(orders.OrderDate), QUARTER(orders.OrderDate) 
ORDER BY Year, Quarter;
""""""

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation of the function. Replace with actual database connection code.
    # Return a sample DataFrame similar to expected output from the SQL query
    # Assuming the output from SQL query execution as a DataFrame.
    data = {
        'Year': [2023, 2023, 2023, 2023],
        'Quarter': [1, 2, 3, 4],
        'TotalRevenue': [10000, 15000, 20000, 25000]
    }
    return pd.DataFrame(data)

# Order of quarters as strings for better plotting
quarters = ['Q1', 'Q2', 'Q3', 'Q4']

# Execute SQL Query
df = execute_sql_query(sql_query)

# Create line chart to visualize the trend of total sales revenue over quarters
fig = px.line(df, x='Quarter', y='TotalRevenue', title='Trend of Total Sales Revenue Over Quarters',
              labels={'TotalRevenue': 'Total Revenue', 'Quarter': 'Quarter'},
              markers=True)

# Display the figure to the user
show_to_user(fig)
```","The input code calculates 'TotalRevenue' by splitting 'Year' and 'Quarter', which could lead to plotting issues due to separate x-axis handling. The reference code combines these into a singular 'Quarter', ensuring a continuous x-axis. Additionally, the reference implementation uses 'DATE_TRUNC' for quarter extraction instead of 'YEAR' and 'QUARTER' functions, aligning better to a singular time series. Moreover, the labels in the input code are added but this detail isn't present in the reference code, although it doesn't necessarily affect functionality.",None
"Compute the total inventory value grouped by supplier, and create a bar chart to visualize the results.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT SupplierID, SUM(UnitPrice * UnitsInStock) as InventoryValue 
FROM products 
GROUP BY SupplierID;
""""""

# Fetch data using the execute_sql_query utility function
inventory_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total inventory value by supplier
fig = px.bar(inventory_data, x='SupplierID', y='InventoryValue', title='Total Inventory Value by Supplier')

# Display the chart using the show_to_user utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, 
       SUM(p.UnitsInStock * p.UnitPrice) AS TotalInventoryValue
FROM products p
GROUP BY p.SupplierID
""""""

inventory_value_df = execute_sql_query(sql_query)

fig = px.bar(inventory_value_df, 
             x='SupplierID', 
             y='TotalInventoryValue', 
             title='Total Inventory Value by Supplier',
             labels={'SupplierID': 'Supplier ID', 'TotalInventoryValue': 'Total Inventory Value'})
show_to_user(fig)
```","The input code correctly calculates the total inventory value grouped by supplier using a similar SQL query as the reference. Both implementations select SupplierID and compute the total inventory value by multiplying UnitPrice by UnitsInStock and summing it. Furthermore, a bar chart is created using Plotly in both cases, displaying 'SupplierID' on the x-axis and the computed inventory value on the y-axis. The input also includes label customization for clarity, which doesn't affect the correctness. Thus, the input code adheres to the specified request and the reference logic.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM(products.UnitPrice * products.UnitsInStock) AS TotalInventory 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total inventory value by supplier
fig = px.bar(df, x='CompanyName', y='TotalInventory', title='Total Inventory Value by Supplier')

# Display the bar chart using the provided utility function
show_to_user(fig)
```","The input code correctly computes the total inventory value grouped by supplier, similar to the reference code. The input differs by joining the 'suppliers' table and using 'CompanyName' instead of 'SupplierID' for grouping, which still answers the business request correctly. The visualization also matches the requirement of creating a bar chart of inventory values by supplier, fulfilling the analytics request.",both
"Identify customers who have never received a discount, and display the results in a chart to visualize the proportion of such customers within the overall customer base.","# Corrected code
import plotly.express as px
import pandas as pd

# Define the SQL query to identify customers who have never received a discount
sql_query = '''
SELECT CustomerID FROM customers 
WHERE NOT EXISTS (
    SELECT 1 FROM orders o 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    WHERE customers.CustomerID = o.CustomerID AND od.Discount > 0
);
'''

# Execute the SQL query and retrieve results in a pandas DataFrame
customers_without_discount_df = execute_sql_query(sql_query)

# Execute an SQL query to find the total number of customers
total_customers_query = 'SELECT CustomerID FROM customers;'
total_customers_df = execute_sql_query(total_customers_query)

# Calculate proportions
num_customers_without_discount = len(customers_without_discount_df)
num_total_customers = len(total_customers_df)
proportion_without_discount = (num_customers_without_discount / num_total_customers) * 100
proportion_with_discount = 100 - proportion_without_discount

# Create a DataFrame for visualization purposes
visualization_df = {
    'Category': ['Without Discount', 'With Discount'],
    'Proportion': [proportion_without_discount, proportion_with_discount]
}

# Convert to pandas DataFrame
visualization_df = pd.DataFrame(visualization_df)

# Generate the plot using Plotly
fig = px.pie(visualization_df, names='Category', values='Proportion', 
             title='Proportion of Customers Without Discounts')

# Display the plot
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID,
    c.CompanyName,
    COUNT(od.Discount) AS DiscountCount
FROM 
    customers c
LEFT JOIN 
    orders o ON c.CustomerID = o.CustomerID
LEFT JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
HAVING 
    COUNT(od.Discount) = 0
""""""

customers_no_discount = execute_sql_query(sql_query)
total_customers = execute_sql_query(""SELECT COUNT(*) AS TotalCustomers FROM customers"")

proportion_no_discount = len(customers_no_discount) / total_customers.iloc[0]['TotalCustomers']

data = {
    'Type': ['No Discount', 'With Discount'],
    'Proportion': [proportion_no_discount, 1 - proportion_no_discount]
}

proportion_df = pd.DataFrame(data)

fig = px.pie(proportion_df, values='Proportion', names='Type', title='Proportion of Customers with No Discount')
show_to_user(fig)
```","The input Python code uses a SQL query to identify customers who have not received a discount and calculates the proportion of such customers compared to the total customer base. It creates a pie chart to visualize these proportions. Both the reference and input codes achieve the same objective of identifying customers with no discounts and visualizing their proportion. The differences in approach, such as the use of HAVING with COUNT in the input code vs. NOT EXISTS in the reference code, still result in the same logical outcome, thus meeting the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query from business analytic request
sql_query = """"""
SELECT c.CustomerID 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
LEFT JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
HAVING SUM(CASE WHEN od.Discount > 0 THEN 1 ELSE 0 END) = 0;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
customers_no_discount_df = execute_sql_query(sql_query)

# Execute another SQL query to get total number of customers
total_customers_query = ""SELECT COUNT(*) AS TotalCustomers FROM customers;""
total_customers_df = execute_sql_query(total_customers_query)

# Calculate the proportion of customers with no discount
proportion_no_discount = len(customers_no_discount_df) / total_customers_df['TotalCustomers'].iloc[0]

# Create a DataFrame for visualization
proportion_df = pd.DataFrame({
    'Type': ['No Discount', 'With Discount'],
    'Proportion': [proportion_no_discount, 1 - proportion_no_discount]
})

# Create a pie chart using Plotly
fig = px.pie(proportion_df, names='Type', values='Proportion', title='Customer Proportion by Discount Status')
display(fig)
```","The input Python code correctly identifies customers who have never received a discount using a SQL query, grouping by customer and ensuring the sum of discounts is zero. It retrieves the total number of customers using another SQL query. The code then calculates the proportion of customers without a discount, creates a DataFrame, and visualizes this data using a pie chart in Plotly. Although the approach and SQL syntax differ, the logic aligns with the reference implementation.",both
"What are the top 5 products by sales revenue, which suppliers provide them, and can we visualize this with a bar chart to enhance understanding?","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the top 5 products by sales revenue with their suppliers
sql_query = """"""
SELECT od.ProductID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue, 
       p.SupplierID 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY od.ProductID, p.SupplierID 
ORDER BY TotalRevenue DESC LIMIT 5;
""""""

# Helper functions (simulated as placeholders)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing the SQL query. In a real implementation, 
    # this would connect to a database and return a pandas DataFrame.
    # For now, we simulate with a mock DataFrame for the example.
    data = {'ProductID': [1, 2, 3, 4, 5],
            'TotalRevenue': [5000, 4000, 3000, 2000, 1000],
            'SupplierID': [101, 102, 103, 104, 105]}
    return pd.DataFrame(data)

def show_to_user(data):
    # Placeholder for data visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query and store the results in a pandas DataFrame
df_results = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 products by sales revenue
fig = px.bar(df_results, x='ProductID', y='TotalRevenue', color='SupplierID',
             title='Top 5 Products by Sales Revenue', labels={'TotalRevenue': 'Sales Revenue', 'ProductID': 'Product ID'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductName,
    s.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    suppliers s ON p.SupplierID = s.SupplierID
GROUP BY 
    p.ProductName, s.CompanyName
ORDER BY 
    TotalRevenue DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, 
             x='ProductName', 
             y='TotalRevenue', 
             color='CompanyName', 
             title='Top 5 Products by Sales Revenue',
             labels={'TotalRevenue': 'Sales Revenue', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code retrieves product names and supplier names, whereas the reference uses ProductID and SupplierID. Additionally, the SQL joins to suppliers in the input code, which differs from the reference. This could result in different products being selected or displayed. The request asked for coherence with the reference logic, which the input doesn't strictly follow.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch top 5 products by sales revenue along with their suppliers
sql_query = """"""
SELECT products.ProductID, 
       products.ProductName, 
       products.SupplierID, 
       suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY products.ProductID, products.ProductName, products.SupplierID, suppliers.CompanyName 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(df, 
             x='ProductName', 
             y='TotalRevenue', 
             color='CompanyName',
             title='Top 5 Products by Sales Revenue with Suppliers',
             labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'},
             text='TotalRevenue')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly analyzes and visualizes the top 5 products by sales revenue. It uses an SQL query to join products with suppliers and calculates the total revenue, similar to the reference implementation logic. The visualization is a bar chart with products displayed by their names and suppliers, providing the necessary insights.",Finetuned
"Which customer generated the highest revenue in the last year, and can you provide a bar chart showing the top 5 customers by revenue?","
import pandas as pd
import plotly.express as px

# Define the SQL queries
sql_query_total_revenue = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) - 1 
GROUP BY customers.CustomerID 
ORDER BY TotalRevenue DESC;
""""""

# Execute the SQL query to find total revenue for all customers
df_revenue = execute_sql_query(sql_query_total_revenue)

# Identify the customer who generated the highest revenue
top_customer = df_revenue.iloc[0]
top_customer_id = top_customer['CustomerID']
top_customer_revenue = top_customer['TotalRevenue']

# Display the top customer
print(f""Customer {top_customer_id} generated the highest revenue: ${top_customer_revenue:.2f}"")

# Extract the top 5 customers for visualization
df_top_5_customers = df_revenue.head(5)

# Create a bar chart using Plotly
fig = px.bar(df_top_5_customers, 
             x='CustomerID', 
             y='TotalRevenue', 
             title='Top 5 Customers by Revenue in the Last Year',
             labels={'TotalRevenue': 'Total Revenue', 'CustomerID': 'Customer ID'})

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalRevenue DESC
LIMIT 5;
""""""

top_customers_df = execute_sql_query(sql_query)

highest_revenue_customer = top_customers_df.iloc[0]
print(f""Customer with highest revenue: {highest_revenue_customer['CompanyName']}"")

fig = px.bar(top_customers_df, x='CompanyName', y='TotalRevenue', title='Top 5 Customers by Revenue')
show_to_user(fig)
```","The input code retrieves data for orders in the last 12 months (using CURDATE() and INTERVAL 1 YEAR), instead of specifically targeting the last calendar year as in the reference implementation. The date filtering logic should ensure orders from exactly the previous year, not just the last 12 months. Additionally, the input code uses LIMIT 5 in the SQL query, which effectively handles selection for visualization purposes, but it does not match the SQL ordering criteria and extraction steps from the reference solution where the highest revenue customer is individually identified.","```python
import pandas as pd
import plotly.express as px

# Placeholder for utility function to execute SQL query.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation would connect to a database, execute the query, and return results as a DataFrame.
    pass

# Placeholder for utility function to display data or visualization results.
def show_to_user(data):
    # Implementation would display data analysis or visualization.
    pass

# SQL queries to execute
top_customer_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS CustomerRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY c.CustomerID 
ORDER BY CustomerRevenue DESC 
LIMIT 1
""""""

top_5_customers_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS CustomerRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY c.CustomerID 
ORDER BY CustomerRevenue DESC 
LIMIT 5
""""""

# Execute the queries
top_customer_df = execute_sql_query(top_customer_query)
top_5_customers_df = execute_sql_query(top_5_customers_query)

# Display the customer with the highest revenue
show_to_user(top_customer_df)

# Visualization: Bar chart for the top 5 customers
fig = px.bar(
    top_5_customers_df,
    x='CustomerID',
    y='CustomerRevenue',
    title='Top 5 Customers by Revenue in 2022',
    labels={'CustomerID': 'Customer ID', 'CustomerRevenue': 'Revenue'},
    text='CustomerRevenue'
)

# Show the plot using the utility function
show_to_user(fig)
```","The input code correctly identifies which customer generated the highest revenue in 2022 and provides a bar chart of the top 5 customers by revenue. It uses SQL queries to aggregate and sort the revenue data, similar to the reference. The difference in date handling and query splitting does not affect the logic since the business request specifies the year as 2022. Both codes display the results using the same charting library, Plotly, which satisfies the business analytics request.",Finetuned
What is the average customer rating per order (assuming ratings are stored)? Please include a bar chart to visualize the average ratings for better comparison across different orders.,"```python
import plotly.express as px

# Construct the SQL query
sql_query = """"""
SELECT OrderID, AVG(Rating) AS AvgRating 
FROM RatingsTable 
GROUP BY OrderID
""""""

# Execute the SQL query and get the data as a pandas DataFrame
ratings_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average ratings per order
fig = px.bar(ratings_df, x='OrderID', y='AvgRating', title='Average Customer Rating per Order')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.OrderID,
    AVG(r.rating) AS AverageRating
FROM 
    orders o
JOIN 
    ratings r ON o.OrderID = r.OrderID
GROUP BY 
    o.OrderID
""""""

average_ratings_df = execute_sql_query(sql_query)

fig = px.bar(average_ratings_df, x='OrderID', y='AverageRating', title='Average Customer Rating per Order')
show_to_user(fig)
```","The evaluated code achieves the same goal as the reference implementation. It correctly selects the average rating per OrderID and visualizes the result using a bar chart in Plotly. The difference in SQL query syntax, such as table aliasing and join usage, does not affect correctness given that ratings are appropriately aggregated and grouped by OrderID. Both implementations correctly display the average customer ratings per order.","```python
import pandas as pd
import plotly.express as px

# Placeholder function for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for returning expected DataFrame format
    # The actual implementation would connect to your data source.
    data = {
        ""OrderID"": [1, 2, 3, 4, 5],
        ""AvgCustomerRating"": [4.5, 4.0, 4.8, 3.5, 5.0]
    }
    return pd.DataFrame(data)

# Placeholder function for showing results to the user
def show_to_user(data):
    # Here we would display the results or a visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get average customer rating per order
sql_query = ""SELECT OrderID, AVG(CustomerRating) AS AvgCustomerRating FROM OrderRatings GROUP BY OrderID;""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly for the average customer ratings
fig = px.bar(df, x='OrderID', y='AvgCustomerRating', title='Average Customer Rating Per Order',
             labels={'AvgCustomerRating': 'Average Rating', 'OrderID': 'Order ID'})

# Show the visualization to the user
show_to_user(fig)
```","The provided code fulfills the business analytics request to calculate the average customer rating per order and visualizes the data using a bar chart. The logic corresponds to the reference implementation: it calculates the average rating per OrderID and visualizes it using Plotly. Differences in the exact SQL queries and naming (e.g., AvgCustomerRating vs AvgRating) do not affect the correctness as they achieve the same result.",both
"What percentage of products are currently discontinued, and can you provide a pie chart to illustrate the proportion of discontinued versus active products?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the necessary data
sql_query = """"""
SELECT
    (COUNT(CASE WHEN Discontinued = 1 THEN ProductID END) * 1.0 / COUNT(ProductID) * 100) 
    AS PercentageDiscontinued
FROM products;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Calculate the percentage of active products
percentage_discontinued = df['PercentageDiscontinued'].iloc[0]
percentage_active = 100 - percentage_discontinued

# Create a DataFrame for visualization
visualization_data = pd.DataFrame({
    'Status': ['Discontinued', 'Active'],
    'Percentage': [percentage_discontinued, percentage_active]
})

# Generate a pie chart using Plotly
fig = px.pie(visualization_data, 
             names='Status', 
             values='Percentage', 
             title='Proportion of Discontinued vs Active Products')

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Discontinued, COUNT(*) AS ProductCount FROM products GROUP BY Discontinued""
products_status = execute_sql_query(sql_query)

total_products = products_status['ProductCount'].sum()
discontinued_products = products_status[products_status['Discontinued'] == 1]['ProductCount'].values[0]
active_products = products_status[products_status['Discontinued'] == 0]['ProductCount'].values[0]

discontinued_percentage = (discontinued_products / total_products) * 100

fig = px.pie(products_status, names='Discontinued', values='ProductCount', 
             title='Proportion of Discontinued vs Active Products',
             labels={'Discontinued': 'Discontinuation Status'},
             hole=0.3)

show_to_user(fig)

discontinued_percentage
```","The provided Python code fulfills the business analytics request of determining the percentage of discontinued products and visualizing it as a pie chart. It queries the data to find discontinued and active products, calculates the discontinued percentage, and generates a pie chart with the same logic as the reference implementation. Although the code structure differs slightly, the logic and final output are consistent with the reference code.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function for executing the SQL query and returning the result as a DataFrame.
    # You should replace this with actual implementation to connect and run query on your database.
    # This is just a placeholder, the actual implementation would be done according to your database connection setup.
    pass

def show_to_user(data):
    # Mock function for displaying data analysis or visualization results.
    # Implementation should handle displaying DataFrame or Plotly figure.
    pass

# SQL query to get the percentage of discontinued products and the status count
sql_query = """"""
SELECT
    (SUM(CASE WHEN p.Discontinued = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(p.ProductID)) AS discontinued_percentage,
    SUM(CASE WHEN p.Discontinued = 1 THEN 1 ELSE 0 END) AS discontinued_count,
    (COUNT(p.ProductID) - SUM(CASE WHEN p.Discontinued = 1 THEN 1 ELSE 0 END)) AS active_count
FROM products p;
""""""

# Execute the SQL Query
df = execute_sql_query(sql_query)

# Prepare data for plotting
data_to_plot = {
    'Product Status': ['Discontinued', 'Active'],
    'Count': [df.loc[0, 'discontinued_count'], df.loc[0, 'active_count']]
}

df_plot = pd.DataFrame(data_to_plot)

# Create pie chart using Plotly
fig = px.pie(df_plot, names='Product Status', values='Count', 
             title='Proportion of Discontinued vs Active Products')

# Show pie chart to the user
show_to_user(fig)
```","The provided input code calculates the count of discontinued and active products instead of the percentage for the pie chart. The query retrieves counts but does not directly use the discontinued percentage for visualization. The reference code visualizes proportions using percentages calculated for each status, aligning with the requested task.",Base
What percentage of orders were delivered on time in June 2023? Please include a bar chart to compare on-time delivery rates by week.,"{'python': '```python\nimport pandas as pd\nimport plotly.express as px\n\n# Utility function to execute SQL query\ndef execute_sql_query(sql_query: str) -> pd.DataFrame:\n    # This is a placeholder for the actual implementation which would\n    # interface with a database and return a pandas DataFrame.\n    pass\n\n# Utility function to display data or visualizations\ndef show_to_user(data):\n    if isinstance(data, pd.DataFrame):\n        print(data)\n    elif hasattr(data, \'show\'):\n        data.show()\n    else:\n        raise ValueError(""Unsupported data type for display."")\n\n# SQL query to calculate overall on-time delivery rate for June 2023\noverall_query = """"""\nSELECT \n    COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 100.0 /\n    COUNT(orders.OrderID) AS on_time_delivery_rate\nFROM orders \nWHERE orders.OrderDate BETWEEN \'2023-06-01\' AND \'2023-06-30\'\n""""""\n\n# SQL query to calculate on-time delivery rate by week for June 2023\nweekly_query = """"""\nSELECT \n    EXTRACT(WEEK FROM orders.OrderDate) AS week_number,\n    COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 100.0 /\n    COUNT(orders.OrderID) AS on_time_delivery_rate\nFROM orders \nWHERE orders.OrderDate BETWEEN \'2023-06-01\' AND \'2023-06-30\'\nGROUP BY EXTRACT(WEEK FROM orders.OrderDate)\nORDER BY week_number\n""""""\n\n# Execute the SQL queries\noverall_df = execute_sql_query(overall_query)\nweekly_df = execute_sql_query(weekly_query)\n\n# Display overall on-time delivery rate\nshow_to_user(overall_df)\n\n# Create a bar chart for weekly on-time delivery rates\nfig = px.bar(\n    weekly_df,\n    x=\'week_number\',\n    y=\'on_time_delivery_rate\',\n    title=\'Weekly On-Time Delivery Rates for June 2023\',\n    labels={\'week_number\': \'Week\', \'on_time_delivery_rate\': \'On-Time Delivery Rate (%)\'}\n)\n\n# Display the bar chart\nshow_to_user(fig)\n```'}","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    WEEK(OrderDate) AS week_number, 
    COUNT(OrderID) AS total_orders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS on_time_orders
FROM 
    orders
WHERE 
    OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
GROUP BY 
    week_number
""""""

result_df = execute_sql_query(sql_query)

result_df['on_time_percentage'] = (result_df['on_time_orders'] / result_df['total_orders']) * 100

overall_on_time_percentage = result_df['on_time_percentage'].mean()

fig = px.bar(result_df, 
              x='week_number', 
              y='on_time_percentage', 
              title='On-Time Delivery Rate by Week in June 2023',
              labels={'on_time_percentage': 'On-Time Delivery Percentage'})
              
show_to_user(fig)

overall_on_time_percentage
```","The provided code correctly calculates the percentage of on-time deliveries for June 2023 and visualizes the data with a bar chart by week. It captures the same logic as the reference implementation by calculating the on-time delivery rate for each week and overall. The aggregation and conditional logic align with the requirement to compare the shipped date against the required date for each order. Furthermore, the result is displayed using a bar chart, consistent with the request.","```python
import pandas as pd
import plotly.express as px

# Utility function: This function will execute a given SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation of this function
    # In practice, this should connect to a database and execute the query
    # Return a dummy DataFrame for demonstration
    if ""EXTRACT(YEAR FROM OrderDate) = 2023 AND EXTRACT(MONTH FROM OrderDate) = 6"" in sql_query:
        data = {'OrderID': [1, 2, 3], 'ShippedDate': pd.to_datetime(['2023-06-01', '2023-06-08', '2023-06-15']),
                'RequiredDate': pd.to_datetime(['2023-06-01', '2023-06-08', '2023-06-17'])}
        return pd.DataFrame(data)
    return pd.DataFrame()


# Utility function: This function will display a DataFrame or Plotly figure
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to calculate on-time delivery rate
sql_query_rate = """"""
SELECT COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN orders.OrderID END) * 1.0 / COUNT(orders.OrderID) AS OnTimeDeliveryRate
FROM orders
WHERE EXTRACT(YEAR FROM orders.OrderDate) = 2023
AND EXTRACT(MONTH FROM orders.OrderDate) = 6
""""""

# SQL Query to get weekly data
sql_query_weekly = """"""
SELECT EXTRACT(ISOYEAR FROM orders.OrderDate) AS Year,
       EXTRACT(WEEK FROM orders.OrderDate) AS Week,
       COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN orders.OrderID END) * 1.0 / COUNT(orders.OrderID) AS OnTimeDeliveryRate
FROM orders
WHERE EXTRACT(YEAR FROM orders.OrderDate) = 2023
AND EXTRACT(MONTH FROM orders.OrderDate) = 6
GROUP BY Year, Week
ORDER BY Year, Week
""""""

# Execute SQL query for the overall rate and show the result
df_rate = execute_sql_query(sql_query_rate)
show_to_user(df_rate)

# Execute SQL query to get on-time delivery rates by week
df_weekly = execute_sql_query(sql_query_weekly)

# Create a bar chart for weekly on-time delivery rates
fig = px.bar(df_weekly, x='Week', y='OnTimeDeliveryRate', 
             labels={'OnTimeDeliveryRate': 'On-Time Delivery (%)', 'Week': 'Week'},
             title='On-Time Delivery Rates by Week in June 2023')
show_to_user(fig)
```","The input code evaluates the on-time delivery rate based on orders with a dummy dataset instead of a database query, which may not reflect the actual computation logic or data. The use of .show() for figures is consistent, but the mock dataset is too simplistic, potentially omitting correct interpretation of the SQL logic. Additionally, the provided dataset will not produce any weekly computations, leading to misleading or incorrect visualization results. Therefore, the code does not adhere to the expected logic based on the reference implementation.",Base
What is the most common discount given on products? Provide a bar chart to display the frequency of each discount amount.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are defined elsewhere

# SQL query to get the discount data and their frequency
sql_query = """"""
SELECT 
    [Order Details].Discount, 
    COUNT(*) AS count 
FROM 
    [Order Details] 
GROUP BY 
    [Order Details].Discount 
""""""

# Execute the query and get the results in a DataFrame
discount_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    discount_data, 
    x='Discount', 
    y='count', 
    title='Frequency of Each Discount Amount',
    labels={'count': 'Frequency'},
    template='plotly'
)

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

query = """"""
SELECT Discount, COUNT(*) AS discount_count
FROM [Order Details]
GROUP BY Discount
ORDER BY discount_count DESC
""""""

discounts_df = execute_sql_query(query)

fig = px.bar(discounts_df, x='Discount', y='discount_count', title='Frequency of Each Discount Amount', labels={'Discount': 'Discount Amount', 'discount_count': 'Frequency'})
show_to_user(fig)
```","The input code correctly implements the business analytics request. Both the reference and input codes execute a SQL query to retrieve discount data, count the occurrences of each discount, and then use Plotly to create a bar chart displaying the frequency count of each discount. The order in which the SQL output is presented (sorted by frequency) does not affect the correctness of displaying the data in a bar chart. Therefore, the logic is preserved and meets the business request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT Discount, COUNT(*) AS Frequency
FROM [Order Details]
GROUP BY Discount
ORDER BY Frequency DESC
""""""

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='Discount', y='Frequency', title='Frequency of Discount Amounts')

# Display the bar chart
show_to_user(fig)
```","Both the reference and input implementation correctly perform the task of querying the discount data, grouping by the 'Discount' column, and providing the frequency of each discount via a COUNT operation. They both create a bar chart with Plotly to display the frequency of discounts using similar logic and display the result with a designated function. The order by clause in the input does not affect the correctness since it just orders the result by frequency for display purposes.",both
"Which customers have placed orders totaling more than $10,000? Additionally, create a bar chart to visualize the total order amounts for these customers.","```python
import plotly.express as px
import pandas as pd

# Given SQL query
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSpent 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
HAVING TotalSpent > 10000;
""""""

# Execute the given SQL query using the utility function
customer_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total order amounts for these customers
fig = px.bar(customer_data, x='CustomerID', y='TotalSpent', title='Customers with Total Order Amounts > $10,000')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalAmount
FROM customers AS c
JOIN orders AS o ON c.CustomerID = o.CustomerID
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
HAVING SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) > 10000
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='CompanyName', y='TotalAmount', title='Customers with Orders Totaling More Than $10,000', labels={'TotalAmount':'Total Order Amount', 'CompanyName':'Customer'})
show_to_user(fig)
```","Both code implementations correctly address the business request of identifying customers with total orders exceeding $10,000 and visualizing this data with a bar chart. The input code uses a different approach by including 'CompanyName' in the SQL query and in the visualization but maintains the core logic. The sum calculation and filtering criteria are consistent with the reference implementation. Thus, it satisfies the business analytics request accurately.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, CompanyName, total_order_amount
FROM customers
JOIN (
    SELECT CustomerID, SUM(UnitPrice * Quantity * (1 - Discount)) AS total_order_amount
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    GROUP BY CustomerID
) AS customer_orders
ON customers.CustomerID = customer_orders.CustomerID
WHERE total_order_amount > 10000;
""""""

# Execute the SQL query using the provided utility function
customer_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    customer_data,
    x='CompanyName',
    y='total_order_amount',
    title='Total Order Amounts for Customers over $10,000',
    labels={'total_order_amount': 'Total Order Amount ($)', 'CompanyName': 'Customer Name'}
)

# Display the bar chart using the provided utility function
show_to_user(fig)
```","Both the input code and the reference code are executing an SQL query to find customers whose total order amounts exceed $10,000, and both create a bar chart to visualize this data. The query logic in both implementations calculates total order amounts by summing up the products of UnitPrice, Quantity, and (1 - Discount) and applies the condition to filter totals greater than $10,000. The input code includes an additional column 'CompanyName' for label clarity in the chart, but this does not alter the core analytics request. The visualization step in both cases uses Plotly to display a bar chart of the resulting data. Thus, the input code adheres to the logic of the reference implementation.",both
How does the shipping cost vary by region? Include a data visualization that illustrates the differences across regions.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT ShipRegion, AVG(Freight) AS AvgShippingCost 
FROM orders 
GROUP BY ShipRegion;
""""""

# Execute the SQL query and get the results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Check the DataFrame
print(df.head())

# Create a bar chart to visualize the average shipping cost by region
fig = px.bar(df, x='ShipRegion', y='AvgShippingCost', 
             title='Average Shipping Cost by Region',
             labels={'ShipRegion': 'Region', 'AvgShippingCost': 'Average Shipping Cost ($)'},
             color='ShipRegion')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, AVG(Freight) AS Average_Shipping_Cost
FROM orders
GROUP BY ShipRegion
""""""
shipping_cost_by_region = execute_sql_query(sql_query)

fig = px.bar(shipping_cost_by_region, x='ShipRegion', y='Average_Shipping_Cost', 
             title='Average Shipping Cost by Region', labels={'Average_Shipping_Cost': 'Average Shipping Cost', 'ShipRegion': 'Region'})
show_to_user(fig)
```","The input code correctly performs the task as outlined in the business analytics request and is consistent with the reference implementation. It executes an SQL query to compute the average shipping cost by region using 'AVG(Freight)' and groups the results by 'ShipRegion'. It then visualizes these results as a bar chart using Plotly Express. The differences, such as variable naming and label details, do not affect the overall logic or correctness of the code.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT ShipRegion, AVG(Freight) AS AvgFreight
FROM orders
GROUP BY ShipRegion;
""""""

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Create a bar plot to visualize the average shipping cost by region
fig = px.bar(df, x='ShipRegion', y='AvgFreight', 
             title='Average Shipping Cost by Region',
             labels={'ShipRegion': 'Region', 'AvgFreight': 'Average Freight'},
             text_auto=True)

# Show the plot to the user
show_to_user(fig)
```","The input code calculates the average shipping cost by region using SQL, similar to the reference code. While it names the average cost column as 'AvgFreight' instead of 'AvgShippingCost', it follows the same logic. Both pieces of code use Plotly to create a bar chart, with slight differences in label names and features like 'text_auto'. These differences do not affect the correctness or intent of the code.",both
"Which product has the highest sales volume this quarter, and can you provide a bar chart to visualize the sales volumes of all products?","```python
import pandas as pd
import plotly.express as px

# SQL query to get sales volume of all products
sql_query = """"""
SELECT products.ProductID, SUM([Order Details].Quantity) AS sales_volume 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE QUARTER(orders.OrderDate) = QUARTER(CURDATE()) 
AND YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY products.ProductID
ORDER BY sales_volume DESC
""""""

# Execute SQL query and get the data as a DataFrame
sales_data = execute_sql_query(sql_query)

# Determine the product with the highest sales volume
if not sales_data.empty:
    top_product = sales_data.iloc[0]
    # Print the product with the highest sales volume
    print(f""Product with the highest sales volume: {top_product['ProductID']} with {top_product['sales_volume']} units."")
else:
    print(""No sales data available for this quarter."")

# Create bar chart for the sales volumes of all products
fig = px.bar(sales_data, x='ProductID', y='sales_volume', title='Sales Volume of Products This Quarter')

# Show bar chart to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the current quarter's date range
start_date = '2023-07-01'
end_date = '2023-09-30'

# SQL query to get product sales volume for the current quarter
sql_query = f""""""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS sales_volume
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '{start_date}' AND '{end_date}'
GROUP BY products.ProductID, products.ProductName
ORDER BY sales_volume DESC
""""""

# Execute the SQL query and retrieve the data
sales_data = execute_sql_query(sql_query)

# Get the product with the highest sales volume
highest_sales_product = sales_data.iloc[0]

# Create a bar chart to visualize the sales volumes of all products
fig = px.bar(sales_data, x='ProductName', y='sales_volume', title='Sales Volumes of Products This Quarter', labels={'sales_volume': 'Sales Volume', 'ProductName': 'Product Name'})

# Show the results to the user
show_to_user(fig)

# Output the product with the highest sales volume
highest_sales_product
```","The input Python code correctly implements the logic required by the business analytics request. Both the provided code and the reference code aim to identify the product with the highest sales volume in the current quarter and create a bar chart to visualize the sales volumes for all products. Despite differences in the SQL query syntax—such as using hard-coded date ranges versus dynamic date functions—the input code correctly calculates and outputs the highest sales volume product. The visualization is also constructed properly with Plotly, and the result is made available to the user, adhering to the reference implementation's intent.","```python
import pandas as pd
import plotly.express as px

# SQL query to get sales volumes for all products in the current quarter
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS SalesVolume 
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE od.OrderID IN (
    SELECT OrderID 
    FROM orders 
    WHERE QUARTER(OrderDate) = QUARTER(CURDATE())
    AND YEAR(OrderDate) = YEAR(CURDATE())
)
GROUP BY p.ProductID, p.ProductName 
ORDER BY SalesVolume DESC
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Identify the product with highest sales volume
top_product = sales_data.iloc[0]

# Output the top product
show_to_user(pd.DataFrame([top_product]))

# Create a bar chart for sales volumes of all products
fig = px.bar(sales_data, x='ProductName', y='SalesVolume', title='Sales Volumes of Products This Quarter')

# Display the bar chart
show_to_user(fig)
```","The provided implementation and the reference code both achieve the same business objective: determining the product with the highest sales volume this quarter and visualizing the sales volumes of all products. The differences in their SQL query structure do not affect the correctness. Both codes use CURDATE() to filter current quarter sales and garner sales volume by summing quantities from 'Order Details'. Both implementations generate a bar chart, and the differences in displaying the top product's name do not impact the overall correctness. The input implementation is deemed functionally equivalent to the reference.",both
"What is the total discount amount applied by each employee, and can this be visualized in a bar chart?","import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are pre-defined utility functions
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].Discount * [Order Details].UnitPrice * [Order Details].Quantity) AS TotalDiscount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query and get the results as a pandas DataFrame
discount_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total discount applied by each employee
fig = px.bar(discount_data, 
             x='EmployeeID', 
             y='TotalDiscount', 
             title='Total Discount Amount by Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalDiscount': 'Total Discount Amount'},
             text_auto=True)

# Display the plot using the show_to_user function
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscount
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID
ORDER BY 
    TotalDiscount DESC
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='EmployeeName', y='TotalDiscount', title='Total Discounts Applied by Each Employee')
show_to_user(fig)
```","The input Python code achieves the same business analytics goal as the reference code. It calculates the total discount amount applied by each employee using a SQL query and visualizes it with a bar chart. The key difference is that the input code includes the employee's name in the output, not just the EmployeeID, and orders the results by 'TotalDiscount' in descending order, which adds context and a sort order but doesn't alter the core logic of the calculation. Both codes calculate the discounts correctly and use Plotly to create a bar chart for visualization.","```python
import pandas as pd
import plotly.express as px

# Placeholder for execute_sql_query utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is expected to execute the given SQL query and return a pandas DataFrame
    pass

def show_to_user(data):
    # This function is expected to display pandas DataFrame or Plotly visualization
    pass

# SQL query to calculate the total discount amount applied by each employee
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Executing the SQL query
df_discounts = execute_sql_query(sql_query)

# Creating a bar chart using Plotly
fig = px.bar(df_discounts, x='EmployeeID', y='TotalDiscount',
             title='Total Discount Amount by Employee',
             labels={'TotalDiscount': 'Total Discount', 'EmployeeID': 'Employee ID'})

# Displaying the bar chart using the utility function
show_to_user(fig)
```","The provided Python code accurately follows the given business analytics request and the logic of the reference implementation. Both codes execute SQL queries to calculate the total discount amount applied by each employee and then use Plotly to visualize these amounts in a bar chart. The logic of multiplying UnitPrice, Quantity, and Discount in the SQL statement is consistent between both codes. The display function, 'show_to_user', is used identically in both implementations for visualization.",both
Calculate the sales growth percentage for each employee from the previous month and create a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to calculate sales growth percentage
sql_query = """"""
SELECT 
    e.EmployeeID, 
    ((SUM(CASE WHEN MONTH(o.OrderDate) = 6 THEN [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) ELSE 0 END) - 
    SUM(CASE WHEN MONTH(o.OrderDate) = 5 THEN [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) ELSE 0 END)) / 
    NULLIF(SUM(CASE WHEN MONTH(o.OrderDate) = 5 THEN [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) ELSE 0 END), 0)) * 100 AS GrowthPercentage 
FROM 
    employees e 
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID 
JOIN 
    [Order Details] ON o.OrderID = [Order Details].OrderID 
GROUP BY 
    e.EmployeeID;
""""""

# Function to execute the SQL query
def execute_sql_query(query: str) -> pd.DataFrame:
    # This function is assumed to execute the query and return the result as a DataFrame
    # This is a mock implementation for demonstration purposes
    # Replace with actual database query execution code
    data = {
        'EmployeeID': [1, 2, 3],
        'GrowthPercentage': [10.5, 15.2, -5.4]
    }
    return pd.DataFrame(data)

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize sales growth percentage
fig = px.bar(df, x='EmployeeID', y='GrowthPercentage', title='Sales Growth Percentage by Employee', labels={'GrowthPercentage': 'Growth (%)'})

# Function to display data or plots
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total sales for each employee for the last two months
sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    SUM(CASE WHEN o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END) AS CurrentMonthSales,
    SUM(CASE WHEN o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 2 MONTH) AND o.OrderDate < DATE_SUB(CURDATE(), INTERVAL 1 MONTH) THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END) AS PreviousMonthSales
FROM 
    employees AS e
JOIN 
    orders AS o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] AS od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 2 MONTH)
GROUP BY 
    e.EmployeeID
""""""

# Execute SQL query
sales_data = execute_sql_query(sql_query)

# Calculate sales growth percentage
sales_data['GrowthPercentage'] = ((sales_data['CurrentMonthSales'] - sales_data['PreviousMonthSales']) / sales_data['PreviousMonthSales'].replace(0, pd.NA)) * 100

# Create bar chart
fig = px.bar(sales_data, x='FirstName', y='GrowthPercentage', title='Sales Growth Percentage by Employee', labels={'FirstName': 'Employee', 'GrowthPercentage': 'Growth Percentage (%)'})

# Show result to user
show_to_user(fig)
```","The provided code uses date functions like DATE_SUB and CURDATE(), which assume a MySQL-like environment. The reference code specifies precise months (May and June) using the MONTH() function. The provided code doesn't ensure it captures data for specific months but rather relative months from the current date, possibly leading to inconsistent periods if not run at the same timing as the reference code. Additionally, the calculation for growth should replace division by zero, but uses pandas NA, differing from the SQL's NULLIF strategy. Also, it uses 'FirstName' for x-axis, which might not be unique, unlike 'EmployeeID'.","import pandas as pd
import plotly.express as px

# Define the SQL query to get the sales data
sql_query = """"""
SELECT employees.EmployeeID, 
       MONTH(orders.OrderDate) AS Month, 
       YEAR(orders.OrderDate) AS Year, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as total_sales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, YEAR(orders.OrderDate), MONTH(orders.OrderDate) 
ORDER BY employees.EmployeeID, Year, Month;
""""""

# Execute the SQL query to get the data
data_df = execute_sql_query(sql_query)

# Pivot the dataframe to have months as columns
pivot_df = data_df.pivot_table(
    index='EmployeeID', 
    columns=['Year', 'Month'], 
    values='total_sales'
)

# Calculate the sales growth percentage
pivot_df['Growth %'] = (
    (pivot_df[pivot_df.columns[-1]] - pivot_df[pivot_df.columns[-2]]) /
    pivot_df[pivot_df.columns[-2]]
) * 100

# Prepare the data for visualization
growth_df = pivot_df[['Growth %']].reset_index()

# Visualize the growth percentage using a bar chart
fig = px.bar(
    growth_df, 
    x='EmployeeID', 
    y='Growth %', 
    title='Sales Growth Percentage by Employee',
    labels={'Growth %': 'Growth (%)'},
    text='Growth %'
)

# Display the figure to the user
show_to_user(fig)
","The input code provides the same final output as the reference implementation by correctly calculating the sales growth percentage for each employee. It first retrieves sales data per employee by month, pivots the data to get the relevant sales figures, calculates the growth percentage between the two most recent months, and finally visualizes the result using a bar chart. Although the method of obtaining and processing data slightly differs, the logic and outcome align with the reference implementation.",Finetuned
What is the total sales revenue generated by each supplier? Include a visualization such as a bar chart to compare the revenues.,"```python
import pandas as pd
import plotly.express as px

# Sample implementation of the utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function - replace with actual database query execution
    # Example: return pd.read_sql(sql_query, connection)
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query as given in the request
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID, suppliers.CompanyName;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='CompanyName', y='TotalSales', title='Total Sales Revenue by Supplier', labels={'TotalSales': 'Total Sales Revenue', 'CompanyName': 'Supplier'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
""""""

revenue_df = execute_sql_query(sql_query)

fig = px.bar(revenue_df, x='CompanyName', y='TotalRevenue', title='Total Sales Revenue by Supplier', labels={'TotalRevenue':'Total Revenue', 'CompanyName':'Supplier'})
show_to_user(fig)
```","The input Python code is correct as it achieves the same objective as the reference implementation. Both implementations execute a SQL query to calculate the total sales revenue by supplier, including a join between the suppliers, products, and order details tables. The difference in table aliases and formatting does not affect the logic or outcome. Additionally, both implementations create a bar chart using Plotly Express to visualize the total sales revenue by supplier. Therefore, the input code adheres to the same logic and produces the same result as the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue generated by each supplier
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalRevenue 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query and get the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate database interaction
    # This should be replaced with actual database execution code
    pass

# Fetching data
data = execute_sql_query(sql_query)

# Creating a bar chart using Plotly to visualize total sales revenue by supplier
fig = px.bar(data, x='CompanyName', y='TotalRevenue',
             title='Total Sales Revenue by Supplier',
             labels={'TotalRevenue': 'Total Revenue'},
             text='TotalRevenue')
# Display the bar chart
show_to_user(fig)
```","Both the provided code and the reference implementation fulfill the requirement to calculate total sales revenue by supplier. They both join the necessary tables and group by 'CompanyName' to calculate and display 'TotalSales' or 'TotalRevenue'. Although the order of joins and the inclusion of the 'orders' table differ, it does not affect the result since the calculation is the same. The use of 'CompanyName' for grouping ensures suppliers are uniquely aggregated, and the visualization using Plotly is consistent with the goal of comparing revenues by supplier.",both
"How do discount rates impact the average order value, and can this be visualized with a scatter plot or line chart?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = '''
SELECT AVG(([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))) AS avg_order_value,
       [Order Details].Discount
FROM [Order Details]
GROUP BY [Order Details].Discount
'''

# Function to execute SQL query and return results
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This should connect to your database and execute the query, returning a DataFrame
    # Here is a placeholder for the actual implementation
    pass

# Fetching data
data = execute_sql_query(sql_query)

# Visualizing the data using a scatter plot
fig = px.scatter(data, x='Discount', y='avg_order_value', title='Impact of Discount Rates on Average Order Value',
                 labels={'Discount': 'Discount Rate', 'avg_order_value': 'Average Order Value'})

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / 
    COUNT(DISTINCT orders.OrderID) AS avg_order_value,
    AVG([Order Details].Discount) AS avg_discount
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY 
    [Order Details].Discount
""""""

data = execute_sql_query(sql_query)

fig = px.scatter(data, x='avg_discount', y='avg_order_value', 
                 title='Impact of Discount Rates on Average Order Value',
                 labels={'avg_discount': 'Average Discount', 'avg_order_value': 'Average Order Value'})
show_to_user(fig)
```","The input code calculates 'avg_order_value' differently by dividing the total discounted order value by the count of distinct OrderIDs, which does not match the reference code's method of averaging values grouped by discount rate. It also aggregates 'avg_discount' instead of using 'Discount' as intended in the GROUP BY clause.","```python
import pandas as pd
import plotly.express as px

# Execute SQL query to get the data
sql_query = """"""
    SELECT AVG(([Order Details].UnitPrice * [Order Details].Quantity) * (1 - [Order Details].Discount)) AS AverageOrderValue,
           AVG([Order Details].Discount) AS AverageDiscount
    FROM [Order Details]
    GROUP BY [Order Details].Discount;
""""""

# Function to execute the SQL query, returning a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the actual database interaction
    # For the purpose of this example, it returns a mock DataFrame
    return pd.DataFrame({
        'AverageOrderValue': [100, 95, 90, 85, 80],
        'AverageDiscount': [0, 0.05, 0.1, 0.15, 0.2]
    })
  
# Fetch data
df = execute_sql_query(sql_query)

# Plot using Plotly
fig = px.scatter(df, x='AverageDiscount', y='AverageOrderValue',
                 title='Impact of Discount Rates on Average Order Value',
                 labels={'AverageDiscount': 'Discount Rate', 'AverageOrderValue': 'Average Order Value'},
                 trendline='lowess')

# Show plot using the utility function
def show_to_user(data):
    # Data can be either a Plotly figure or Pandas DataFrame
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

show_to_user(fig)
```","The input code does not correctly implement the business analytics request. The SQL query in the input code calculates 'AverageDiscount' as the average of all discount rates, but the requirement is to group by each specific discount rate to calculate the average order value for each distinct discount. This mismatch causes discrepancies in how results are aggregated and visualized. Additionally, the trendline 'lowess' is added, which is not in the reference. The plot should directly reflect the relation between discount rates and average order values, as specified in the reference code.",None
"What is the maximum, minimum, and average shipping cost for orders shipped within Europe? Please include a bar chart or box plot to visualize the distribution of these costs.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query is a predefined function
# and show_to_user is a predefined function

# SQL Query to get shipping costs for orders shipped within Europe
sql_query = """"""
SELECT Freight, ShipCountry 
FROM orders 
WHERE ShipCountry IN ('France', 'Germany', 'Italy');
""""""

# Execute SQL query to get the data
df = execute_sql_query(sql_query)

# Calculate maximum, minimum, and average freight costs
max_cost = df['Freight'].max()
min_cost = df['Freight'].min()
avg_cost = df['Freight'].mean()

# Create a bar chart to display the max, min, and average values
summary_df = pd.DataFrame({
    'Statistic': ['Max', 'Min', 'Average'],
    'Value': [max_cost, min_cost, avg_cost]
})

fig = px.bar(summary_df, x='Statistic', y='Value', title='Shipping Cost Statistics for Europe')

# Show the bar chart
show_to_user(fig)

# Create a box plot to visualize distribution
fig_box = px.box(df, y='Freight', title='Distribution of Shipping Costs for Europe')

# Show the box plot
show_to_user(fig_box)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Freight 
FROM orders 
WHERE ShipCountry IN ('France', 'Germany', 'Italy', 'Spain', 'United Kingdom', 'Netherlands', 'Belgium', 'Sweden', 'Austria', 'Denmark', 'Finland', 'Ireland', 'Norway', 'Poland', 'Portugal', 'Czech Republic', 'Hungary', 'Greece', 'Slovakia', 'Romania', 'Bulgaria', 'Croatia', 'Slovenia', 'Lithuania', 'Latvia', 'Estonia')
""""""

shipping_costs = execute_sql_query(sql_query)

max_cost = shipping_costs['Freight'].max()
min_cost = shipping_costs['Freight'].min()
avg_cost = shipping_costs['Freight'].mean()

summary_df = pd.DataFrame({
    'Metric': ['Maximum Shipping Cost', 'Minimum Shipping Cost', 'Average Shipping Cost'],
    'Value': [max_cost, min_cost, avg_cost]
})

fig = px.bar(summary_df, x='Metric', y='Value', title='Shipping Cost Analysis for Europe')

show_to_user(fig)
```","The input code includes additional European countries not present in the reference implementation, which could result in different shipping cost statistics. Also, the input code doesn't include the box plot visualization of the distribution of shipping costs as requested.","
```python
import plotly.express as px

# SQL query to fetch the required data
sql_query = '''
SELECT MAX(Freight) AS MaxFreight, 
       MIN(Freight) AS MinFreight, 
       AVG(Freight) AS AvgFreight 
FROM orders 
WHERE ShipCountry IN ('France', 'Germany', 'UK');  # add other European countries as needed
'''

# Execute SQL query and get results
df = execute_sql_query(sql_query)

# Validate dataframe
if df.empty:
    show_to_user(""No data available for shipping within Europe."")
else:
    # Generate the bar chart for maximum, minimum, and average shipping costs
    fig = px.bar(df, 
                 x=['MaxFreight', 'MinFreight', 'AvgFreight'], 
                 y=df.iloc[0], 
                 labels={'x': 'Shipping Cost Type', 'y': 'Value'},
                 title='Shipping Cost Statistics for Orders within Europe')

    # Display the figure
    show_to_user(fig)
```","The input code directly fetches the max, min, and average values from the SQL query. This deviates from the logic in the reference implementation, which fetches all records and then calculates these statistics in Python. Additionally, the input code also includes the UK, which is not part of the logic in the reference implementation. It also lacks a box plot to show the distribution of shipping costs.",None
List the top 5 products with the highest inventory levels and provide a bar chart to visualize the inventory levels of these products.,"```python
import pandas as pd
import plotly.express as px

# Define and execute the SQL query
sql_query = ""SELECT ProductName, UnitsInStock FROM products ORDER BY UnitsInStock DESC LIMIT 5;""
top_products_df = execute_sql_query(sql_query)

# Create the bar chart using Plotly
fig = px.bar(top_products_df, x='ProductName', y='UnitsInStock',
             title='Top 5 Products with Highest Inventory Levels',
             labels={'UnitsInStock': 'Inventory Level', 'ProductName': 'Product Name'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products
ORDER BY UnitsInStock DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='UnitsInStock', title='Top 5 Products by Inventory Levels', labels={'UnitsInStock': 'Units in Stock', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The provided code correctly addresses the business analytics request to list the top 5 products with the highest inventory levels and visualize these levels in a bar chart. Both the input code and the reference implementation execute a SQL query to select the top 5 products sorted by UnitsInStock in descending order. The input code uses Plotly to create a bar chart with the same axes and labels as the reference. The differences, such as the inclusion of ProductID in the selection in the input code, do not affect the correctness with respect to the analytical question posed. Therefore, the input code adheres to the logic of the reference and fulfills the requirements.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, p.UnitsInStock 
FROM products p 
ORDER BY p.UnitsInStock DESC 
LIMIT 5;
""""""

# Execute the SQL query to get the data
inventory_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 products by inventory levels
fig = px.bar(
    inventory_data, 
    x='ProductName', 
    y='UnitsInStock', 
    title='Top 5 Products by Inventory Levels',
    labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units in Stock'}
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly executes an SQL query to select the top 5 products with the highest inventory levels, ordered by UnitsInStock in descending order, matching the logic of the reference code. It uses Plotly to create a bar chart to visualize these products and displays it using show_to_user. Differences in variable names and labels do not affect the result or logic.",both
Identify employees with a salary above the average and who have generated above-average sales. Include a visualization to compare their salaries and sales performance against averages.,"```python
import pandas as pd
import plotly.express as px

# Given utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function - actual implementation would execute the query and return DataFrame
    pass

def show_to_user(data):
    # Simulated function - actual implementation would display data/visualizations
    pass

# SQL query to identify employees with a salary above the average and above-average sales
query = """"""
WITH AvgSalary AS (
    SELECT AVG(Salary) AS AvgSal FROM employees
), 
AvgSales AS (
    SELECT AVG(TotalSales) AS AvgEmpSales 
    FROM (
        SELECT e.EmployeeID, 
               SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
        FROM employees e 
        JOIN orders o ON e.EmployeeID = o.EmployeeID 
        JOIN [Order Details] od ON o.OrderID = od.OrderID 
        GROUP BY e.EmployeeID
    ) Sub
) 
SELECT e.EmployeeID, e.FirstName, e.LastName, e.Salary, s.EmpSales
FROM employees e 
JOIN AvgSalary a ON e.Salary > a.AvgSal 
JOIN (
    SELECT e2.EmployeeID, 
           SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS EmpSales
    FROM employees e2 
    JOIN orders o2 ON e2.EmployeeID = o2.EmployeeID 
    JOIN [Order Details] od ON o2.OrderID = od.OrderID 
    GROUP BY e2.EmployeeID
) s ON e.EmployeeID = s.EmployeeID 
JOIN AvgSales av ON s.EmpSales > av.AvgEmpSales;
""""""

# Execute the SQL query
employee_df = execute_sql_query(query)

# Calculate averages for visualization
avg_salary = employee_df['Salary'].mean()  # This should be computed from database ideally
avg_sales = employee_df['EmpSales'].mean()  # This as well should come from database ideally

# Prepare data for visualization
employee_df['Above Avg Salary'] = employee_df['Salary'] > avg_salary
employee_df['Above Avg Sales'] = employee_df['EmpSales'] > avg_sales

# Create a scatter plot to compare salaries and sales performance
fig = px.scatter(employee_df, x='Salary', y='EmpSales', color='Above Avg Salary',
                 hover_data=['FirstName', 'LastName'],
                 title=""Employees with Above Average Salary and Sales"",
                 labels={'Salary': 'Employee Salary', 'EmpSales': 'Employee Sales'})

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve employee salaries and their total sales
sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    e.Salary,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
LEFT JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
LEFT JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName, e.Salary
""""""

# Execute the SQL query
employee_data = execute_sql_query(sql_query)

# Calculate average salary and sales
average_salary = employee_data['Salary'].mean()
average_sales = employee_data['TotalSales'].mean()

# Filter employees with above-average salary and sales
above_average_employees = employee_data[
    (employee_data['Salary'] > average_salary) & 
    (employee_data['TotalSales'] > average_sales)
]

# Create a bar chart for visualization
fig = px.bar(above_average_employees, 
             x='LastName', 
             y=['Salary', 'TotalSales'], 
             title='Employees with Above Average Salary and Sales',
             labels={'value':'Amount', 'LastName':'Employee'},
             barmode='group')

# Show the result
show_to_user(fig)
```","The input code calculates average salary and sales using data in memory after retrieving all employees, whereas the reference code calculates averages using SQL subqueries. This difference in methodology could lead to different results especially when the data is large. Additionally, the visualization used is a bar chart comparing LastName against Salary and Sales, which does not provide a clear comparison of above-average employees as required.","```python
import pandas as pd
import plotly.express as px

# Utility Functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function to execute SQL query and return a DataFrame
    pass

def show_to_user(data):
    # Simulated function to display data or visualization
    pass

# SQL Query
sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    e.Salary, 
    total_sales.TotalSales 
FROM 
    employees e 
JOIN 
    (SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
     FROM employees e 
     JOIN orders o ON e.EmployeeID = o.EmployeeID 
     JOIN [Order Details] od ON o.OrderID = od.OrderID 
     GROUP BY e.EmployeeID) AS total_sales 
ON e.EmployeeID = total_sales.EmployeeID 
WHERE 
    e.Salary > (SELECT AVG(Salary) FROM employees) 
    AND total_sales.TotalSales > 
    (SELECT AVG(TotalSales) 
     FROM (SELECT SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
           FROM employees e 
           JOIN orders o ON e.EmployeeID = o.EmployeeID 
           JOIN [Order Details] od ON o.OrderID = od.OrderID 
           GROUP BY e.EmployeeID) AS subquery);
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Visualization
fig = px.bar(df, 
             x='FirstName', 
             y=['Salary', 'TotalSales'], 
             title='Employees with Above Average Salary and Sales',
             labels={'value':'Amount', 'variable':'Type'},
             barmode='group')

# Show the visualization
show_to_user(fig)
```",The input code correctly implements the logic to find employees with above-average salaries and sales using a SQL query similar to the reference. The difference in visualization (bar chart vs. scatter plot) does not affect the correctness as it compares the same data: salaries and sales against the averages. Both codes execute the central business requirement accurately.,Finetuned
How many different customers placed orders in January 2022? Please include a bar chart showing the number of orders placed by each customer.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # Placeholder implementation: Replace with actual SQL execution
    # This function should return a pandas DataFrame as per the environment constraints
    pass

def show_to_user(data):
    # Placeholder implementation: Replace with actual display logic
    pass

# SQL query to fetch the number of different customers who placed orders in January 2022
sql_query_distinct_customers = """"""
SELECT CustomerID 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-01-31'
""""""

# Execute the query and get the data in a pandas DataFrame
customer_orders_df = execute_sql_query(sql_query_distinct_customers)

# Count the number of unique customers
unique_customers_count = len(customer_orders_df['CustomerID'].unique())

# Generate a bar chart showing the number of orders placed by each customer
orders_count_by_customer = customer_orders_df['CustomerID'].value_counts().reset_index()
orders_count_by_customer.columns = ['CustomerID', 'OrderCount']

# Create the bar chart using Plotly
fig = px.bar(orders_count_by_customer, x='CustomerID', y='OrderCount', 
             title='Number of Orders Placed by Each Customer in January 2022')

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) as OrderCount
FROM orders
WHERE OrderDate >= '2022-01-01' AND OrderDate < '2022-02-01'
GROUP BY CustomerID
""""""

result_df = execute_sql_query(sql_query)

num_customers = result_df['CustomerID'].nunique()

fig = px.bar(result_df, x='CustomerID', y='OrderCount', title='Number of Orders by Customer in January 2022')
show_to_user(fig)

num_customers
```","The input code correctly answers the business analytics request by determining the number of unique customers and generating a bar chart for the number of orders by each customer in January 2022. It follows the same logic as the reference, addressing the same query constraints and utilizing Plotly for visualization.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) AS NumberOfOrders
FROM orders o
WHERE MONTH(o.OrderDate) = 1 AND YEAR(o.OrderDate) = 2022
GROUP BY o.CustomerID;
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should use a database connection to execute the given query
    # and return the results as a pandas DataFrame.
    # Placeholder for actual implementation
    pass

# Get the data using the utility function
customer_orders_df = execute_sql_query(sql_query)

# Show how many different customers placed orders
num_customers = customer_orders_df['CustomerID'].nunique()

# Create a bar chart showing the number of orders placed by each customer
fig = px.bar(
    customer_orders_df,
    x='CustomerID',
    y='NumberOfOrders',
    title='Number of Orders Placed by Each Customer in January 2022',
    labels={'CustomerID': 'Customer ID', 'NumberOfOrders': 'Number of Orders'},
)

# Display the number of different customers and the bar chart
def show_to_user(data):
    # This function should handle displaying data or figures to the user.
    # Placeholder for actual implementation
    pass

show_to_user(num_customers)
show_to_user(fig)","The input code correctly addresses the business analytics request. It uses an SQL query to retrieve customer order data for January 2022 and calculates the number of unique customers who placed orders. It also generates a bar chart showing the number of orders placed by each customer. This aligns with the reference implementation in terms of logic and output, fulfilling the requirements of the task.",both
Find products with below-average unit prices and create a bar chart to visualize the distribution of these prices.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find products with below-average unit prices
sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE UnitPrice < (SELECT AVG(UnitPrice) FROM products);
""""""

# Execute the SQL query to get a DataFrame with below-average unit price products
product_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of these prices
fig = px.bar(product_data, x='ProductName', y='UnitPrice', title='Below-Average Unit Prices')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Fetch product data
query = ""SELECT ProductID, ProductName, UnitPrice FROM products""
products_df = execute_sql_query(query)

# Step 2: Calculate the average unit price
average_unit_price = products_df['UnitPrice'].mean()

# Step 3: Filter products with below-average unit prices
below_average_products = products_df[products_df['UnitPrice'] < average_unit_price]

# Step 4: Create a bar chart to visualize the distribution of these prices
fig = px.bar(below_average_products, x='ProductName', y='UnitPrice', title='Products with Below-Average Unit Prices')
show_to_user(fig)
```","The given input Python code correctly implements the logic of finding products with below-average unit prices. It fetches product data, calculates the average unit price, filters for products below this average, and creates a bar chart similar to the reference implementation. The approach aligns with the specified business analytics request.","```python
import plotly.express as px
import pandas as pd

# SQL Query to retrieve products with below-average unit prices
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice 
FROM products 
WHERE UnitPrice < (SELECT AVG(UnitPrice) FROM products);
""""""

# Execute the SQL query using the utility function and get results in a DataFrame
below_average_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of below-average unit prices
fig = px.bar(
    below_average_products_df, 
    x='ProductID', 
    y='UnitPrice', 
    title='Products with Below-Average Unit Prices',
    labels={'UnitPrice': 'Unit Price', 'ProductID': 'Product ID'}
)

# Show the bar chart to the user
show_to_user(fig)
```",The input code differs from the reference by using 'ProductID' instead of 'ProductName' on the x-axis of the bar chart. This does not follow the request to visualize using product names as in the reference code.,Base
Determine the most frequently ordered product and represent the results using a bar chart.,"```python
import plotly.express as px
import pandas as pd

def main():
    # Define the SQL query
    sql_query = """"""
    SELECT ProductID, COUNT(ProductID) AS OrderFrequency 
    FROM [Order Details] 
    GROUP BY ProductID 
    ORDER BY OrderFrequency DESC 
    LIMIT 1;
    """"""

    # Execute the SQL query and get the result as a DataFrame
    result_df = execute_sql_query(sql_query)
    
    # Ensure data is received correctly
    if result_df.empty:
        print(""No data returned from the query."")
        return

    # Create the bar chart using Plotly
    fig = px.bar(result_df, x='ProductID', y='OrderFrequency', title='Most Frequently Ordered Product')
    
    # Show the plot to the user
    show_to_user(fig)

# Execute the main function
main()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) as TotalQuantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

most_frequent_product = execute_sql_query(sql_query)

fig = px.bar(most_frequent_product, x='ProductID', y='TotalQuantity', title='Most Frequently Ordered Product')
show_to_user(fig)
```","The input code is incorrect because it calculates the most frequently ordered product based on 'TotalQuantity' (sum of quantities ordered), rather than 'OrderFrequency' (count of orders). It uses a different logic than the reference implementation which uses COUNT to determine the frequency.","```python
# Import necessary libraries
import pandas as pd
import plotly.express as px

# Utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # For demonstration purposes, this function is stubbed
    # In reality, it should execute the given SQL query and return a DataFrame
    pass

def show_to_user(data):
    # This function should display the given data
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query
sql_query = """"""
SELECT ProductID 
FROM (
    SELECT ProductID, SUM(Quantity) AS TotalOrdered 
    FROM [Order Details] 
    GROUP BY ProductID 
) AS Temp 
ORDER BY TotalOrdered DESC 
LIMIT 1;
""""""

# Execute the query and get data
df = execute_sql_query(sql_query)

# Visualization
fig = px.bar(df, x='ProductID', y='TotalOrdered', title='Most Frequently Ordered Product')

# Show the result to the user
show_to_user(fig)
```","The input code calculates the most frequently ordered product based on the 'TotalOrdered' quantity, which is incorrect. The business request and reference implementation are based on counting the number of times a product is ordered, not the total quantity ordered. Additionally, the column 'TotalOrdered' doesn't match the reference's 'OrderFrequency' in the bar chart.",None
Identify the products with the highest discount rate and visualize the results with a bar chart.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, MAX(od.Discount) AS MaxDiscount 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY MaxDiscount DESC
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Ensure the DataFrame is not empty
if not result_df.empty:
    # Create a bar chart using Plotly
    fig = px.bar(result_df, x='ProductID', y='MaxDiscount', title='Products with Highest Discount Rate')
    
    # Show the plot to the user
    show_to_user(fig)
else:
    print(""No data available to display."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * od.Discount) / SUM(od.Quantity * od.UnitPrice) AS DiscountRate
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
HAVING SUM(od.Quantity * od.UnitPrice) > 0
ORDER BY DiscountRate DESC
LIMIT 10
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductName', y='DiscountRate', title='Top Products by Discount Rate')
show_to_user(fig)
```","The input code calculates the 'DiscountRate' as a weighted average discount, whereas the reference code identifies products with the highest 'MaxDiscount' based on individual order details. The logic for determining the discount is different; hence the input code does not meet the request according to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve products with the highest discount rate
sql_query = """"""
SELECT p.ProductName, MAX(od.Discount) AS MaxDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY MaxDiscount DESC
LIMIT 5;
""""""

# Execute the SQL query and store the result in a DataFrame
products_df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(products_df, x='ProductName', y='MaxDiscount', 
             title='Top 5 Products with Highest Discount Rates',
             labels={'ProductName': 'Product Name', 'MaxDiscount': 'Maximum Discount'})

# Display the visualization to the user
show_to_user(fig)
```","Both the input and reference codes aim to identify products with the highest discount rate and visualize the results using a bar chart. While the input code includes product names and limits the output to the top 5 products, this aligns with the business request that wants to highlight products with significant discounts. The logic of using SQL to calculate the maximum discount per product and visualizing via a bar chart is consistent. Thus, the input code correctly adheres to the business request and the logic of the reference code.",Finetuned
"What is the total value of products currently in stock, and can this be visualized by product category to enhance understanding?","```python
import pandas as pd
import plotly.express as px

# Define the SQL queries to retrieve total stock value and stock value by category
total_stock_value_query = """"""
    SELECT SUM(UnitPrice * UnitsInStock) AS TotalStockValue FROM products;
""""""

stock_value_by_category_query = """"""
    SELECT CategoryName, SUM(UnitPrice * UnitsInStock) AS StockValue
    FROM products
    JOIN categories ON products.CategoryID = categories.CategoryID
    GROUP BY CategoryName;
""""""

# Execute the SQL queries
total_stock_value_df = execute_sql_query(total_stock_value_query)
stock_value_by_category_df = execute_sql_query(stock_value_by_category_query)

# Visualize stock value by product category
fig = px.bar(stock_value_by_category_df, x='CategoryName', y='StockValue', title='Stock Value by Product Category')
show_to_user(fig)

# Show the total stock value
show_to_user(total_stock_value_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID,
    SUM(p.UnitPrice * p.UnitsInStock) AS TotalValue
FROM 
    products p
WHERE 
    p.Discontinued = 0
GROUP BY 
    p.CategoryID
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='CategoryID', y='TotalValue', title='Total Value of Products in Stock by Category', labels={'CategoryID': 'Category ID', 'TotalValue': 'Total Value'})
show_to_user(fig)
```","The evaluated code does not match the reference implementation. Firstly, it does not calculate the total stock value, only the value by category. Secondly, it filters out discontinued products which is not specified in the reference. Also, it groups by CategoryID instead of joining with categories to show CategoryName. This leads to different visualization behavior.","```python
import pandas as pd
import plotly.express as px

# Function that simulates executing an SQL query and returning a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: Replace with actual database interaction
    if 'SELECT ProductCategory, SUM(UnitsInStock * UnitPrice) AS ValueByCategory' in sql_query:
        data = {
            'ProductCategory': ['Electronics', 'Clothing', 'Home'],
            'ValueByCategory': [12000.00, 8500.00, 9500.00]
        }
        return pd.DataFrame(data)
    return pd.DataFrame()

# Function that simulates displaying data or graphs
def show_to_user(data):
    # Placeholder function: Replace with actual displaying logic
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the total value of products currently in stock by product category
sql_query = """"""
SELECT ProductCategory, SUM(UnitsInStock * UnitPrice) AS ValueByCategory
FROM products
GROUP BY ProductCategory;
""""""

# Execute the query and get the data
df = execute_sql_query(sql_query)

# Visualize the total value of products in stock by product category using Plotly
fig = px.bar(df, x='ProductCategory', y='ValueByCategory', title='Total Value of Products in Stock by Category')

# Show the visualization
show_to_user(fig)
```","The input code only calculates the value of products grouped by category and visualizes them but does not compute or display the total stock value across all categories. The reference code contains a distinct query specifically for computing the total stock value, which is missing in the input code.",None
What is the average fulfillment time for orders shipped by each method? Please include a comparative bar chart to visualize the differences in average times across shipping methods.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query using the utility function
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average fulfillment time by shipping method
fig = px.bar(orders_df, x='ShipVia', y='AverageFulfillmentTime', 
             title='Average Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AverageFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Display the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipVia, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    ShipVia
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.bar(fulfillment_data, x='ShipVia', y='AvgFulfillmentTime', 
             title='Average Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})

show_to_user(fig)
```","The input Python code correctly calculates the average fulfillment time for orders shipped by each method using a SQL query that is equivalent to the reference implementation. It also includes a bar chart for visualization, which adheres to the logic required by the business analytics request. The addition of 'WHERE ShippedDate IS NOT NULL' is a reasonable check to ensure only completed orders are considered, which does not alter the correctness regarding the original requirement.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch average fulfillment times by shipping method
sql_query = """"""
SELECT ShipVia, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Generate a comparative bar chart using Plotly
fig = px.bar(df, x='ShipVia', y='AvgFulfillmentTime', title='Average Fulfillment Time by Shipping Method')

# Display the chart to the user
show_to_user(fig)
```","The input Python code is correct and adheres to the specified business analytics request. Both the input code and the reference code execute the same SQL query to calculate the average fulfillment time grouped by shipping method. The input code uses 'AvgFulfillmentTime' as the column label instead of 'AverageFulfillmentTime', which is a minor difference that does not affect the correctness. Additionally, both codes generate a bar chart using Plotly to visualize the results and use a function to display the chart. Therefore, the input code correctly answers the business question and follows the same logic as the reference implementation.",both
Find the distribution of employee sales across different regions and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL query from business analytic request
sql_query = """"""
SELECT e.EmployeeID, o.ShipRegion, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, o.ShipRegion;
""""""

# Execute the query and retrieve the data as a DataFrame
data = execute_sql_query(sql_query)

# Group the data by ShipRegion and calculate total sales
region_sales = data.groupby('ShipRegion')['TotalSales'].sum().reset_index()

# Create a bar chart for sales distribution across regions
fig = px.bar(region_sales, x='ShipRegion', y='TotalSales', 
             title='Sales Distribution Across Regions',
             labels={'TotalSales': 'Total Sales', 'ShipRegion': 'Region'})

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.Region,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.Region
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='Region', y='TotalSales', title='Distribution of Employee Sales Across Regions')
show_to_user(fig)
```","The input code uses 'e.Region' instead of 'o.ShipRegion' in the SQL query. The task is to find sales distribution by shipping region, not employee region. Therefore, it does not adhere to the same logic as the reference implementation.","```python
import plotly.express as px

# SQL query to fetch the distribution of customer sales across different regions.
sql_query = """"""
SELECT e.Region, SUM(oi.UnitPrice * oi.Quantity * (1 - oi.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] oi ON o.OrderID = oi.OrderID
GROUP BY e.Region;
""""""

# Execute the SQL query to get the data.
sales_data = execute_sql_query(sql_query)

# Create a bar chart visualization using Plotly.
fig = px.bar(sales_data, x='Region', y='TotalSales', title='Distribution of Employee Sales by Region')

# Display the visualization to the user.
show_to_user(fig)
```","The input Python code aggregates sales by 'Region' from the employees table, while the reference code aggregates by 'ShipRegion' from the orders table, which is where sales are actually shipped to. This discrepancy means they are not logically equivalent, as 'Region' pertains to employee locations, not sales destinations.",None
Compare the sales performance of all products per quarter using a data visualization.,"```python
import plotly.express as px
import pandas as pd

# SQL Query to get the data needed for analysis
sql_query = """"""
SELECT 
    p.ProductName, 
    DATE_TRUNC('quarter', o.OrderDate) AS Quarter, 
    SUM(od.Quantity) AS TotalSales 
FROM 
    products p 
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID 
JOIN 
    orders o ON o.OrderID = od.OrderID 
GROUP BY 
    p.ProductName, Quarter;
""""""

# Function to execute the SQL query and return a Pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented already.
    pass

# Function to display the final visualization to the user
def show_to_user(data):
    # This function is assumed to be implemented already.
    pass

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Ensure that the 'Quarter' column is treated as a datetime type for plotting
sales_data['Quarter'] = pd.to_datetime(sales_data['Quarter'])

# Plot the sales performance per product per quarter
fig = px.line(sales_data, x='Quarter', y='TotalSales', color='ProductName',
              title='Sales Performance of Products Per Quarter',
              labels={'TotalSales': 'Total Sales', 'Quarter': 'Quarter', 'ProductName': 'Product'})

# Display the generated plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductName,
    DATE_TRUNC('quarter', o.OrderDate) AS Quarter,
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate IS NOT NULL
GROUP BY 
    p.ProductName, Quarter
ORDER BY 
    Quarter, TotalSales DESC;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='Quarter', y='TotalSales', color='ProductName', title='Quarterly Sales Performance of Products')
show_to_user(fig)
```","The input Python code achieves the same objective as the reference code by generating a line plot of product sales performance per quarter using Plotly. It follows the same logic by aggregating sales data per product per quarter. The input code includes an additional SQL filter to avoid NULL order dates, though this does not affect the overall correctness in terms of data visualization. Additionally, it orders the results, which does not affect the final visualization because the organization of lines in the plot will remain based on plotting function defaults. Therefore, the code meets the requirements of the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT EXTRACT(YEAR FROM o.OrderDate) AS Year, 
       EXTRACT(QUARTER FROM o.OrderDate) AS Quarter, 
       p.ProductID, 
       SUM(od.Quantity) AS TotalQuantity 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY 
    Year, 
    Quarter, 
    p.ProductID
ORDER BY 
    Year, 
    Quarter;
""""""

# Execute the SQL query using the utility function
df_sales_performance = execute_sql_query(sql_query)

# Data visualization using Plotly
fig = px.line(
    df_sales_performance,
    x='Quarter',
    y='TotalQuantity',
    color='ProductID',
    line_group='ProductID',
    markers=True,
    title='Quarterly Sales Performance of All Products',
    labels={'TotalQuantity': 'Total Quantity Sold', 'Quarter': 'Year-Quarter'}
)

# Show the result using the utility function
show_to_user(fig)
```","The input code uses EXTRACT to separate Year and Quarter, but does not combine them to create a true 'Year-Quarter' datetime format for plotting. It plots 'Quarter' directly, which is numeric, likely leading to incorrect chronological sorting. The reference implementation correctly uses DATE_TRUNC to aggregate and convert 'OrderDate' into a proper datetime format representing the start of each quarter. Additionally, the input code uses 'ProductID' instead of 'ProductName' for visualization, which deviates from the expected business request.",Base
"Find orders that were shipped after the required date and provide their details, including a visualization showing the distribution of shipping delays.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT * FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query and retrieve the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Ensure date columns are in datetime format
orders_df['ShippedDate'] = pd.to_datetime(orders_df['ShippedDate'])
orders_df['RequiredDate'] = pd.to_datetime(orders_df['RequiredDate'])

# Calculate the shipping delay in days
orders_df['ShippingDelay'] = (orders_df['ShippedDate'] - orders_df['RequiredDate']).dt.days

# Display the orders that were shipped after the required date
show_to_user(orders_df)

# Create a histogram to visualize the distribution of shipping delays
fig = px.histogram(orders_df, x='ShippingDelay', nbins=20, title='Distribution of Shipping Delays')

# Show the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, CustomerID, EmployeeID, OrderDate, RequiredDate, ShippedDate, ShipVia, Freight, 
       ShipName, ShipAddress, ShipCity, ShipRegion, ShipPostalCode, ShipCountry,
       DATEDIFF(ShippedDate, RequiredDate) AS ShippingDelay
FROM orders
WHERE ShippedDate > RequiredDate
""""""

delayed_orders = execute_sql_query(sql_query)

shipping_delay_count = delayed_orders['ShippingDelay'].value_counts().reset_index()
shipping_delay_count.columns = ['Delay', 'Count']

fig = px.bar(shipping_delay_count, x='Delay', y='Count', title='Distribution of Shipping Delays',
             labels={'Delay': 'Days Delayed', 'Count': 'Number of Orders'})

show_to_user(delayed_orders)
show_to_user(fig)
```","The input code correctly identifies orders shipped after the required date using a SQL query, similar to the reference implementation. Although the input code calculates the shipping delay in the SQL query, as opposed to using Pandas as in the reference, the logic and outcome are the same. Both codes create a visualization of shipping delays, with the input code using a bar chart and the reference using a histogram. Despite the difference in visualization type, the main task of showing the distribution of shipping delays is accomplished. Therefore, the input code adheres to the specified business analytics request and logic of the reference code.","```python
import pandas as pd
import plotly.express as px

def find_and_visualize_late_orders():
    # Define the SQL query
    sql_query = """"""
    SELECT OrderID, ShippedDate, RequiredDate 
    FROM orders 
    WHERE ShippedDate > RequiredDate;
    """"""
    
    # Execute the SQL query
    late_orders_df = execute_sql_query(sql_query)
    
    # Calculate shipping delays
    late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])
    late_orders_df['RequiredDate'] = pd.to_datetime(late_orders_df['RequiredDate'])
    late_orders_df['Delay'] = (late_orders_df['ShippedDate'] - late_orders_df['RequiredDate']).dt.days
    
    # Visualize the distribution of shipping delays
    fig = px.histogram(
        late_orders_df, 
        x='Delay', 
        title='Distribution of Shipping Delays', 
        labels={'Delay': 'Days Late'},
        nbins=20
    )
    
    # Show the DataFrame and the plot
    show_to_user(late_orders_df)
    show_to_user(fig)

# Execute the function
find_and_visualize_late_orders()
```","The input Python code correctly implements the business analytics request. It executes a SQL query to retrieve orders shipped after their required dates and processes the data similarly to the reference implementation. The code calculates shipping delays, visualizes the distribution of these delays using a histogram, and presents the results through a function call. All key steps such as querying, date conversion, delay calculation, and visualizations are consistent with the reference code.",both
"What is the average order fulfillment time for each shipping method, and can this be represented visually using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get average order fulfillment time for each shipping method
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS average_fulfillment_time
FROM orders
GROUP BY ShipVia;
""""""

# Execute the SQL query using the utility function execute_sql_query
df = execute_sql_query(sql_query)

# Create a bar chart to represent the average fulfillment time by shipping method
fig = px.bar(df, x='ShipVia', y='average_fulfillment_time',
             title='Average Order Fulfillment Time by Shipping Method',
             labels={'ShipVia': 'Shipping Method',
                     'average_fulfillment_time': 'Average Fulfillment Time (days)'})

# Display the chart using the utility function show_to_user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName AS shipping_method,
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

avg_fulfillment_time_df = execute_sql_query(sql_query)

fig = px.bar(avg_fulfillment_time_df, x='shipping_method', y='avg_fulfillment_time',
              title='Average Order Fulfillment Time by Shipping Method',
              labels={'avg_fulfillment_time': 'Average Fulfillment Time (Days)', 
                      'shipping_method': 'Shipping Method'})

show_to_user(fig)
```","The provided code is correct. It queries the average order fulfillment time for each shipping method by joining the 'orders' and 'shippers' tables and grouping by shipping method. The logic is consistent with the reference implementation, and the bar chart is created using Plotly to represent the results. The differences in variable names ('shipping_method' vs. 'ShipVia' and 'avg_fulfillment_time' vs. 'average_fulfillment_time') do not affect the correctness as they are simply naming variations.","```python
import pandas as pd
import plotly.express as px

def main():
    # SQL query to fetch data
    sql_query = """"""
    SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
    FROM orders 
    GROUP BY ShipVia;
    """"""
    
    # Execute the SQL query and get the data as a DataFrame
    df = execute_sql_query(sql_query)
    
    # Generate a bar chart using Plotly
    fig = px.bar(df, x='ShipVia', y='AvgFulfillmentTime', 
                 title='Average Order Fulfillment Time by Shipping Method',
                 labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'})
    
    # Show the bar chart to the user
    show_to_user(fig)

# Main function to execute the analysis
if __name__ == ""__main__"":
    main()
```","The input Python code executes the same SQL query as the reference code to calculate the average fulfillment time for each shipping method. It then uses Plotly to create a bar chart with the same specified titles and labels. Both implementations use a utility function to execute the SQL and display the chart. The logic matches the reference implementation, satisfying the business analytics request.",both
"What is the total sales revenue for the current year, and how can a line graph of monthly sales trends enhance the understanding of this data?","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue for the current year
sql_query = """"""
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    YEAR(orders.OrderDate) = YEAR(CURRENT_DATE)
""""""

# Execute the SQL query
total_sales_df = execute_sql_query(sql_query)

# Display the total sales revenue
show_to_user(total_sales_df)

# SQL query to get monthly sales trends for the current year
monthly_sales_query = """"""
SELECT 
    MONTH(orders.OrderDate) AS month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS monthly_sales 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY 
    MONTH(orders.OrderDate) 
ORDER BY 
    MONTH(orders.OrderDate)
""""""

# Execute the SQL query for monthly sales trend
monthly_sales_df = execute_sql_query(monthly_sales_query)

# Create a line graph for monthly sales trends
fig = px.line(monthly_sales_df, x='month', y='monthly_sales', title='Monthly Sales Trends for the Current Year')

# Display the line graph to enhance understanding
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales revenue for the current year
total_sales_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query and get total sales
total_sales_df = execute_sql_query(total_sales_query)
total_sales = total_sales_df['total_sales'].values[0]

# SQL query to get monthly sales trends for the current year
monthly_sales_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS monthly_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY month
ORDER BY month
""""""

# Execute the SQL query and get monthly sales data
monthly_sales_df = execute_sql_query(monthly_sales_query)

# Create a line graph for monthly sales trends
fig = px.line(monthly_sales_df, x='month', y='monthly_sales', title='Monthly Sales Trends for 2023')
show_to_user(fig)
```","The input code queries sales data using a fixed date range for 2023, which will not dynamically update for the current year, while the reference code uses a flexible function (CURRENT_DATE). This means the input code will not work correctly beyond 2023.","```python
import pandas as pd
import plotly.express as px

# Sample SQL query for execution
sql_query = """"""
SELECT 
    MONTH(OrderDate) as OrderMonth, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as MonthlySales
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    YEAR(OrderDate) = YEAR(CURDATE())
GROUP BY 
    MONTH(OrderDate)
ORDER BY 
    OrderMonth
""""""

# Function to calculate total sales revenue for the current year
def calculate_sales():
    # Execute SQL query and fetch data
    sales_data = execute_sql_query(sql_query)
    
    # Calculate total sales revenue for the current year
    total_sales_revenue = sales_data['MonthlySales'].sum()
    
    # Output total sales revenue
    print(""Total Sales Revenue for Current Year: "", total_sales_revenue)
    
    # Plot line graph of monthly sales trends
    fig = px.line(sales_data, x='OrderMonth', y='MonthlySales', title='Monthly Sales Trends for Current Year')
    
    # Show figure to user
    show_to_user(fig)

# Run the function to perform the calculations and visualization
calculate_sales()
```","The input code computes the total sales revenue by summing up monthly sales data obtained from the trend SQL query, rather than executing a separate query for the total sales revenue as done in the reference code. The reference implementation first computes total sales directly using a single query for total sales in the current year. This distinction in method means the calculations could be different, especially if there are factors not accounted for by monthly aggregation alone. Thus, the logic of the input code differs from the reference.",None
How many customers have ordered more than 10 times? Please include a bar chart to visualize the distribution of customers by the number of orders.,"```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user functions are predefined based on the environment constraints.

def get_customers_with_more_than_10_orders():
    sql_query = """"""
        SELECT customers.CustomerID, COUNT(orders.OrderID) as order_count 
        FROM customers 
        JOIN orders ON customers.CustomerID = orders.CustomerID 
        GROUP BY customers.CustomerID 
        HAVING COUNT(orders.OrderID) > 10
    """"""
    
    # Execute the SQL query to get customers with more than 10 orders
    result_df = execute_sql_query(sql_query)
    return result_df

def visualize_order_distribution(data):
    # Count how many customers fall into each order count category
    order_distribution = data['order_count'].value_counts().reset_index()
    order_distribution.columns = ['order_count', 'customer_count']

    # Create a bar chart using Plotly
    fig = px.bar(order_distribution, 
                 x='order_count', 
                 y='customer_count', 
                 title='Distribution of Customers by Number of Orders',
                 labels={'order_count': 'Number of Orders', 'customer_count': 'Number of Customers'},
                 text='customer_count')
    fig.update_traces(textposition='outside')

    # Show the plot
    show_to_user(fig)

def main():
    customers_orders_df = get_customers_with_more_than_10_orders()
    
    # Show the number of customers who ordered more than 10 times
    num_customers = len(customers_orders_df)
    print(f""Number of customers with more than 10 orders: {num_customers}"")
    
    # Visualize the distribution of order frequencies
    visualize_order_distribution(customers_orders_df)

# Run the main function
main()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10
""""""

customers_with_more_than_10_orders = execute_sql_query(sql_query)

order_distribution_query = """"""
SELECT COUNT(CustomerID) AS CustomerCount, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
""""""

order_distribution = execute_sql_query(order_distribution_query)

fig = px.bar(order_distribution, x='OrderCount', y='CustomerCount', labels={'OrderCount': 'Number of Orders', 'CustomerCount': 'Number of Customers'}, title='Distribution of Customers by Number of Orders')
show_to_user(customers_with_more_than_10_orders)
show_to_user(fig)
```","The provided code does not match the business analytics request in terms of logic. The first SQL query correctly identifies customers with more than 10 orders, but the approach to visualize the distribution is flawed. The second SQL query attempts to count customers without filtering them by having more than 10 orders. The bar chart visualization also uses incorrect data as it plots based on unresolved order distribution data, not filtered by the condition of more than 10 orders. The reference code correctly filters and visualizes the customers who have specifically ordered more than 10 times.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch customer order data
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10;
""""""

# Fetch the data using the provided utility function
customer_orders_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(
    customer_orders_df,
    x=""CustomerID"",
    y=""OrderCount"",
    title=""Distribution of Customers by Number of Orders"",
    labels={""CustomerID"": ""Customer ID"", ""OrderCount"": ""Number of Orders""}
)

# Use the provided utility function to display the visualization
show_to_user(fig)

# Optionally, display the filtered DataFrame as well
show_to_user(customer_orders_df)
```","The input code retrieves customers who have ordered more than 10 times correctly and visualizes it with a bar chart. However, it uses 'CustomerID' on the x-axis and 'OrderCount' on the y-axis, showing individual customer order counts instead of the distribution of customers by order count, as requested. The reference implementation groups customers by 'order_count' for the visualization, showing how many customers fall into each order count category, which matches the business request more closely.",None
"What is the total sales revenue generated by each product, and how can it be visualized to show comparisons between products?","
import plotly.express as px


def execute_sql_query(sql_query: str):
    # This is a mock function. Implement your database fetching logic here.
    import pandas as pd
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'TotalRevenue': [10000, 15000, 12000]
    }
    return pd.DataFrame(data)


def show_to_user(data):
    # This mock function would either display a DataFrame or a Plotly figure.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()


# SQL Query from user input
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar plot to compare product sales revenue
fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Total Sales Revenue by Product')

# Show the plot to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""
total_sales_revenue = execute_sql_query(sql_query)

fig = px.bar(total_sales_revenue, x='ProductName', y='TotalRevenue', title='Total Sales Revenue by Product', labels={'TotalRevenue': 'Total Revenue', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code calculates 'TotalRevenue' differently by including a discount factor (1 - od.Discount). The business requirement is to match the logic of the reference implementation, which calculates total revenue without considering any discount. Thus, the input code does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
GROUP BY ProductID
""""""

# Executing the SQL query to get the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing SQL query and returning DataFrame
    # Actual implementation needed in the real environment
    pass

# Placeholder function for displaying data
def show_to_user(data):
    # Placeholder for displaying pandas DataFrame or Plotly visualization
    pass

# Retrieve the data
sales_data = execute_sql_query(sql_query)

# Visualize the total sales revenue by product
fig = px.bar(sales_data, x='ProductID', y='TotalSales', 
             title='Total Sales Revenue by Product',
             labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales Revenue'},
             color='TotalSales')

# Show the figure
show_to_user(fig)
```","The input code uses a different SQL query that operates on 'ProductID' instead of 'ProductName', and it also considers 'Discount' in the revenue calculation, which is not included in the reference logic. Additionally, the labeling and grouping in the visualization are inconsistent with the reference implementation. Therefore, it does not adhere to the same logic as the reference code.",None
"What is the total sales value generated by each employee in the last month, and can this be represented in a bar chart?","
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
AND o.OrderDate < CURDATE() 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute the SQL query and get the results as a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='FirstName', y='TotalSales', title='Total Sales by Employee in the Last Month', 
             labels={'TotalSales': 'Total Sales Value', 'FirstName': 'Employee Name'})

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

last_month = datetime.now() - timedelta(days=30)
last_month_start = last_month.replace(day=1)
last_month_end = (last_month_start + pd.DateOffset(months=1)) - pd.DateOffset(days=1)

sql_query = f""""""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '{last_month_start.strftime('%Y-%m-%d')}' AND '{last_month_end.strftime('%Y-%m-%d')}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='EmployeeName', y='TotalSales', 
             title='Total Sales by Employee in the Last Month',
             labels={'TotalSales': 'Total Sales ($)', 'EmployeeName': 'Employee'},
             text='TotalSales')

show_to_user(fig)
```","The input code filters the data using the actual start and end dates of the previous month, while the reference uses a 30-day range from the current date. This logic difference could result in different results depending on the execution date. The bar chart is correctly implemented in both cases.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the total sales by each employee in the last month
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    SUM([(od.UnitPrice * (1 - od.Discount)) * od.Quantity]) AS TotalSales 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
JOIN 
    [Order Details] od ON orders.OrderID = od.OrderID 
WHERE 
    DATE_ORDERED > DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
GROUP BY 
    employees.EmployeeID;
""""""

# Execute the SQL query and store the result in a DataFrame
sales_data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data_df, x='EmployeeID', y='TotalSales', 
             title='Total Sales by Employee in the Last Month',
             labels={'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'})

# Display the bar chart to the user
show_to_user(fig)
```","The provided code has a few issues compared to the reference implementation: 1) It uses DATE_ORDERED, which is not the same as the reference's OrderDate, potentially causing inconsistency. 2) It lacks FirstName and LastName columns, impacting the completeness of the output. 3) The date filter logic in WHERE does not check if the date is less than the current date, possibly leading to incorrect time frames.",None
Calculate the average order size in terms of total items and visualize the distribution of order sizes using a histogram.,"```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the total items per order
sql_query = """"""
SELECT OrderID, SUM(Quantity) AS TotalItems
FROM [Order Details]
GROUP BY OrderID
""""""

# Execute the SQL query and load the result into a DataFrame
order_sizes_df = execute_sql_query(sql_query)

# Calculate the average order size
average_order_size = order_sizes_df['TotalItems'].mean()

# Show the average order size to the user
average_order_size_df = pd.DataFrame({'AverageOrderSize': [average_order_size]})
show_to_user(average_order_size_df)

# Visualize the distribution of order sizes using a histogram
fig = px.histogram(order_sizes_df, x='TotalItems', title='Distribution of Order Sizes', nbins=20)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total items per order
sql_query = """"""
SELECT o.OrderID, SUM(od.Quantity) AS TotalItems
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.OrderID
""""""

# Execute the SQL query and retrieve the data
order_data = execute_sql_query(sql_query)

# Calculate the average order size
average_order_size = order_data['TotalItems'].mean()

# Visualize the distribution of order sizes using a histogram
fig = px.histogram(order_data, x='TotalItems', title='Distribution of Order Sizes', labels={'TotalItems': 'Total Items per Order'})
show_to_user(fig)

average_order_size
```","The input Python code calculates the average order size similarly to the reference, executing an SQL query that sums quantities by OrderID and computes the mean of the 'TotalItems' column. It also visualizes the distribution with a histogram using plotly.express. Although there's a slight difference in how results are shown to the user, it doesn't affect the correctness of the logic or the fulfillment of the request.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the average order size
sql_query_avg_order_size = """"""
SELECT o.OrderID, SUM(od.Quantity) AS TotalItems
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.OrderID;
""""""

# Execute SQL query to retrieve order sizes
order_sizes_df = execute_sql_query(sql_query_avg_order_size)

# Calculate the average order size
average_order_size = order_sizes_df['TotalItems'].mean()

# Display the average order size
average_df = pd.DataFrame({'AverageOrderSize': [average_order_size]})
show_to_user(average_df)

# Visualize the distribution of order sizes using a histogram
fig = px.histogram(order_sizes_df, x='TotalItems', title='Distribution of Order Sizes')
show_to_user(fig)
```","The input code correctly calculates the average order size and visualizes the distribution of order sizes using a histogram, which is consistent with the business analytics request and logic of the reference implementation. The SQL query in the input code retrieves the same necessary data as the reference code. While there is a minor difference in table joining in the SQL query, the logic remains equivalent. Both the average calculation and the visualization are performed correctly.",both
Find employees whose most common shipment destination is outside their country of residence and visualize the destinations on a world map.,"```python
import plotly.express as px
import pandas as pd


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mockup function to represent SQL execution
    # Replace this with actual database connection logic
    pass

def show_to_user(data):
    # Mockup function to represent data display
    pass

# Define the SQL Query
sql_query = """"""
SELECT e.FirstName, e.LastName, most_common.ShipCountry
FROM (
    SELECT o.EmployeeID, o.ShipCountry, COUNT(*) as cnt,
    RANK() OVER (PARTITION BY o.EmployeeID ORDER BY COUNT(*) DESC) as rnk
    FROM orders o
    GROUP BY o.EmployeeID, o.ShipCountry
) as most_common
JOIN employees e ON e.EmployeeID = most_common.EmployeeID
WHERE most_common.rnk = 1 AND most_common.ShipCountry <> e.Country;
""""""

# Execute the SQL query
employee_destinations_df = execute_sql_query(sql_query)

# Check if the DataFrame is empty
if not employee_destinations_df.empty:
    # Create the world map visualization
    fig = px.scatter_geo(
        employee_destinations_df,
        locations=""ShipCountry"",
        locationmode='country names',
        hover_name=employee_destinations_df.apply(
            lambda row: f""{row['FirstName']} {row['LastName']}"", axis=1),
        title=""Employees with Most Common Shipment Destinations Outside Their Country""
    )
    
    # Show the visualization
    show_to_user(fig)
else:
    print(""No employees with shipment destinations outside their country found."")
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find employees whose most common shipment destination is outside their country of residence
sql_query = """"""
WITH Shipments AS (
    SELECT 
        o.EmployeeID,
        o.ShipCountry,
        e.Country AS EmployeeCountry,
        COUNT(*) AS ShipmentCount
    FROM orders o
    JOIN employees e ON o.EmployeeID = e.EmployeeID
    GROUP BY o.EmployeeID, o.ShipCountry, e.Country
),
MostCommonDestinations AS (
    SELECT 
        EmployeeID,
        ShipCountry,
        ShipmentCount,
        ROW_NUMBER() OVER (PARTITION BY EmployeeID ORDER BY ShipmentCount DESC) AS rn
    FROM Shipments
)
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    e.Country AS EmployeeCountry,
    mcd.ShipCountry
FROM employees e
JOIN MostCommonDestinations mcd ON e.EmployeeID = mcd.EmployeeID
WHERE mcd.rn = 1 AND mcd.ShipCountry != e.Country
""""""

# Execute the SQL query and get the data
results_df = execute_sql_query(sql_query)

# Visualize the shipping destinations on a world map
fig = px.scatter_geo(results_df, 
                     location_mode=""country names"",
                     locations=""ShipCountry"", 
                     hover_name=results_df[""FirstName""] + ' ' + results_df[""LastName""],
                     title=""Employees with Most Common Shipment Destination Outside Their Country"",
                     projection=""natural earth"")

show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. Both use SQL to find employees whose most common shipment destinations are outside their country of residence. The input code uses Common Table Expressions (CTEs) with ROW_NUMBER() for finding the most common destination per employee, which is logically equivalent to using RANK() as in the reference. Both codes ensure the employee's shipment country is different from their country of residence. Finally, both codes utilize Plotly to visualize these destinations on a world map.","
import pandas as pd
import plotly.express as px

# Sample utility function implementations (for demonstration)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # Should return a DataFrame based on the executed query
    data = {
        'EmployeeID': [1, 2],
        'MostCommonDestination': ['France', 'Germany'],
        'Country': ['USA', 'Canada']
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)  # or use a more complex display logic
    else:
        data.show()

# SQL query from the business analytic request
sql_query = """"""
SELECT e.EmployeeID, m.MostCommonDestination
FROM employees e
JOIN (
    SELECT o.ShipCountry AS MostCommonDestination, e.EmployeeID
    FROM employees e
    JOIN orders o ON e.EmployeeID = o.EmployeeID
    GROUP BY e.EmployeeID, o.ShipCountry
    ORDER BY COUNT(*) DESC
) m
ON e.EmployeeID = m.EmployeeID
WHERE m.MostCommonDestination != e.Country;
""""""

# Execute the SQL query and load it into a DataFrame
df_employees = execute_sql_query(sql_query)

# Check the resulting DataFrame
show_to_user(df_employees)

# Visualize the most common destinations on a world map
# Assuming 'Country' is in the DataFrame and used for filtering later

fig = px.choropleth(
    df_employees,
    locations=""MostCommonDestination"",
    locationmode='country names',
    scope=""world"",
    color_discrete_sequence=[""blue""]
)

show_to_user(fig)

","The evaluated code doesn't correctly implement the logic of ranking destinations by frequency per employee. It bypasses the ranking and filtering process, potentially leading to incorrect or duplicate entries. Additionally, the visualization uses `px.choropleth`, which is not appropriate here since the data isn’t continuous. The reference code correctly uses `px.scatter_geo` with hover details.",Base
What is the total freight cost per region? Include a bar chart to visualize the costs for each region.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the total freight cost per region
sql_query = """"""
SELECT ShipRegion, SUM(Freight) AS TotalFreightCost 
FROM orders 
GROUP BY ShipRegion;
""""""

# Execute the query and store the result in a DataFrame
freight_cost_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(freight_cost_df, x='ShipRegion', y='TotalFreightCost', 
             title='Total Freight Cost per Region',
             labels={'ShipRegion': 'Region', 'TotalFreightCost': 'Total Freight Cost'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipRegion
""""""
freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipRegion', y='TotalFreight', title='Total Freight Cost per Region', labels={'TotalFreight': 'Total Freight Cost', 'ShipRegion': 'Region'})
show_to_user(fig)
```","The evaluated code correctly calculates the total freight per region using a SQL query that sums the 'Freight' for each 'ShipRegion' and groups by 'ShipRegion'. The result is stored in a DataFrame, similar to the reference implementation. In both implementations, a bar chart is created using Plotly to visualize the costs per region with appropriate labels and titles. The logic and intended outcome of the reference implementation are maintained.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total freight cost per region
sql_query = """"""
SELECT ShipRegion AS “Region”, SUM(Freight) AS “Total Freight Cost” FROM orders GROUP BY ShipRegion;
""""""

# Execute the SQL query and fetch the results into a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total freight cost per region
fig = px.bar(df, x='Region', y='Total Freight Cost', title='Total Freight Cost per Region')

# Display the bar chart to the user
show_to_user(fig)
```","The input code uses non-standard quotation marks (“ and ”) for column aliases in the SQL query. This is likely to cause a syntax error, as standard SQL requires either single quotes ('') or double quotes (""""). Other than that, the logic aligns with the reference code, but syntactical issues must be resolved for correctness.",Base
"Identify employees with no sales in the last month, and provide a visual representation of sales activity over the last month.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to identify employees with no sales in the last month.
sql_query = """"""
SELECT e.EmployeeID 
FROM employees e 
LEFT JOIN orders o 
ON e.EmployeeID = o.EmployeeID 
AND o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' 
AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE) 
WHERE o.OrderID IS NULL;
""""""

# Execute the SQL query and get the result as a pandas DataFrame.
employees_no_sales_df = execute_sql_query(sql_query)

# Display the list of employees with no sales in the last month.
show_to_user(employees_no_sales_df)

# Define another SQL query to get sales activity over the last month.
sales_activity_query = """"""
SELECT o.EmployeeID, COUNT(o.OrderID) as SalesCount, DATE_TRUNC('day', o.OrderDate) as SaleDate
FROM orders o 
WHERE o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE)
GROUP BY o.EmployeeID, SaleDate
ORDER BY SaleDate;
""""""

# Execute the SQL query and get the sales activity data as a pandas DataFrame.
sales_activity_df = execute_sql_query(sales_activity_query)

# Create a line plot using Plotly to visualize sales activity over the last month.
fig = px.line(sales_activity_df, x='SaleDate', y='SalesCount', 
              color='EmployeeID', 
              title='Sales Activity Over the Last Month',
              labels={'SaleDate': 'Date', 'SalesCount': 'Number of Sales'})

# Display the plot to the user.
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the date range for the last month
last_month_start = pd.to_datetime(""now"").normalize() - pd.DateOffset(months=1)
last_month_end = pd.to_datetime(""now"").normalize()

# Query to find employees with no sales in the last month
no_sales_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName
FROM employees e
LEFT JOIN (
    SELECT o.EmployeeID
    FROM orders o
    WHERE o.OrderDate BETWEEN '{last_month_start.strftime('%Y-%m-%d')}' AND '{last_month_end.strftime('%Y-%m-%d')}'
) sales ON e.EmployeeID = sales.EmployeeID
WHERE sales.EmployeeID IS NULL;
""""""

no_sales_df = execute_sql_query(no_sales_query)

# Query to get sales activity over the last month
sales_activity_query = f""""""
SELECT o.OrderDate, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '{last_month_start.strftime('%Y-%m-%d')}' AND '{last_month_end.strftime('%Y-%m-%d')}'
GROUP BY o.OrderDate
ORDER BY o.OrderDate;
""""""

sales_activity_df = execute_sql_query(sales_activity_query)

# Create a line plot for sales activity
fig = px.line(sales_activity_df, x='OrderDate', y='TotalSales', title='Sales Activity Over the Last Month')
show_to_user(no_sales_df)
show_to_user(fig)
```","The evaluated code differs from the reference implementation in several key areas. Firstly, it replaces the use of date truncation to calculate the last month with a Python date manipulation approach. However, it incorrectly sets the end date to include the current day rather than the end of the last month. Secondly, the query for employees with no sales retrieves additional employee details (FirstName, LastName), which the reference does not, although this does not affect correctness. Finally, the sales activity query calculates 'TotalSales' using order details, whereas the reference code focuses on a simple count of orders per employee per day. This gives a different metric and visual perspective, hence altering the problem approach.","```python
import pandas as pd
import plotly.express as px

# SQL query to identify employees with no sales in the last month
sql_query_no_sales_last_month = """"""
SELECT employees.EmployeeID
FROM employees 
LEFT JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE MONTH(orders.OrderDate) = MONTH(CURDATE() - INTERVAL 1 MONTH) 
AND orders.OrderDate IS NULL;
""""""

# Execute SQL query to get employees with no sales last month
employees_no_sales = execute_sql_query(sql_query_no_sales_last_month)

# SQL query to get all sales activity over the last month
sql_query_sales_activity = """"""
SELECT employees.EmployeeID, orders.OrderDate
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
WHERE MONTH(orders.OrderDate) = MONTH(CURDATE() - INTERVAL 1 MONTH);
""""""

# Execute SQL query to get sales activity data
sales_activity_df = execute_sql_query(sql_query_sales_activity)

# Visualize sales activity using a line graph
if not sales_activity_df.empty:
    sales_activity_df['OrderDate'] = pd.to_datetime(sales_activity_df['OrderDate'])
    sales_activity_df = sales_activity_df.sort_values('OrderDate')
    
    fig = px.line(sales_activity_df, 
                  x='OrderDate', 
                  y='EmployeeID',
                  title='Sales Activity Over the Last Month')
    show_to_user(fig)
else:
    show_to_user(""No sales activity data was found for the last month."")

# Display employees with no sales in the last month
show_to_user(employees_no_sales)
```","The input code has issues with the SQL queries. First, the query for employees with no sales checks for NULL in OrderDate instead of checking if no corresponding OrderID exists. The logic for checking sales activity is incorrect as it does not group and count sales by EmployeeID and SaleDate as in the reference implementation. The visualization uses EmployeeID on the y-axis instead of SalesCount.",None
"How much freight cost did we incur last month, and can you provide a bar chart comparing daily freight costs throughout the month?","```python
import pandas as pd
import plotly.express as px

# SQL query to get daily freight costs for last month
sql_query_daily_freight = """"""
SELECT 
    CAST(o.OrderDate AS DATE) AS OrderDate, 
    SUM(o.Freight) AS DailyFreight 
FROM 
    orders o 
WHERE 
    o.OrderDate >= DATEADD(MONTH, DATEDIFF(MONTH, 0, CURRENT_DATE) - 1, 0) 
    AND o.OrderDate < DATEADD(MONTH, DATEDIFF(MONTH, 0, CURRENT_DATE), 0)
GROUP BY 
    CAST(o.OrderDate AS DATE)
""""""

# Execute the SQL query and get the DataFrame
daily_freight_df = execute_sql_query(sql_query_daily_freight)

# Generate the bar chart using Plotly
fig = px.bar(
    daily_freight_df, 
    x='OrderDate', 
    y='DailyFreight',
    title='Daily Freight Costs for Last Month',
    labels={'OrderDate': 'Order Date', 'DailyFreight': 'Freight Cost ($)'}
)

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to get total freight cost and daily freight costs
sql_total_freight = f""""""
SELECT SUM(Freight) AS TotalFreight
FROM orders
WHERE OrderDate BETWEEN '{first_day_last_month}' AND '{last_day_last_month}'
""""""

sql_daily_freight = f""""""
SELECT OrderDate, SUM(Freight) AS DailyFreight
FROM orders
WHERE OrderDate BETWEEN '{first_day_last_month}' AND '{last_day_last_month}'
GROUP BY OrderDate
ORDER BY OrderDate
""""""

# Execute SQL queries
total_freight_df = execute_sql_query(sql_total_freight)
daily_freight_df = execute_sql_query(sql_daily_freight)

# Extract total freight cost
total_freight = total_freight_df['TotalFreight'].iloc[0]

# Create bar chart for daily freight costs
fig = px.bar(daily_freight_df, x='OrderDate', y='DailyFreight', title='Daily Freight Costs for Last Month')
show_to_user(fig)

total_freight
```","The input code and the reference code achieve the same business objective. Both pieces of code calculate the daily freight costs for the last month by executing a SQL query and then generate a bar chart to visualize these costs using Plotly Express. Although the input code also retrieves the total freight cost separately, which is not present in the reference code, this additional step does not affect the correctness of the solution since it provides the required daily comparison. The date calculations for last month are accurate and result in the same date range as the reference code.","```python
import pandas as pd
import plotly.express as px

# Execute SQL query to retrieve freight costs for the last month.
sql_query = """"""
SELECT 
    DATE(OrderDate) as OrderDate, 
    SUM(Freight) AS DailyFreightCost 
FROM orders 
WHERE MONTH(OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) 
GROUP BY DATE(OrderDate);
""""""

# Function to execute the SQL query and get the data.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function body (placeholder)
    pass

# Execute the SQL query
freight_cost_df = execute_sql_query(sql_query)

# Create a bar chart to visualize daily freight costs.
fig = px.bar(freight_cost_df, x='OrderDate', y='DailyFreightCost', 
             title='Daily Freight Costs for Last Month', 
             labels={'OrderDate': 'Date', 'DailyFreightCost': 'Freight Cost'})

# Show the figure to the user
show_to_user(fig)
```","Both implementations correctly retrieve the daily freight costs for the previous month and generate a bar chart for visualization. The difference in SQL syntax (using DATE and INTERVAL vs. DATEADD and CURRENT_DATE) is just a matter of SQL dialect preference (e.g., MySQL vs. SQL Server). The logic in both is equivalent, as they filter the same date range and group the data correctly. The bar chart creation steps with Plotly are also analogous, differing only slightly in label names, which do not affect correctness.",both
Find the average shipping time for orders and visualize the distribution of shipping times.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find average shipping time
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS ShippingTime
FROM orders
WHERE ShippedDate IS NOT NULL
""""""

# Execute the SQL query using the utility function
orders_df = execute_sql_query(sql_query)

# Calculate the average shipping time
avg_shipping_time = orders_df['ShippingTime'].mean()

# Visualize the distribution of shipping times
fig = px.histogram(orders_df, x='ShippingTime', 
                   title='Distribution of Shipping Times',
                   labels={'ShippingTime': 'Shipping Time (Days)'})

# Display the visualization
show_to_user(fig)

# Display the average shipping time
avg_shipping_df = pd.DataFrame({'AvgShippingTime': [avg_shipping_time]})
show_to_user(avg_shipping_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATEDIFF(ShippedDate, OrderDate) AS ShippingTime
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
""""""

shipping_times_df = execute_sql_query(sql_query)

average_shipping_time = shipping_times_df['ShippingTime'].mean()

fig = px.histogram(shipping_times_df, x='ShippingTime', title='Distribution of Shipping Times', 
                   labels={'ShippingTime': 'Shipping Time (Days)'})
show_to_user(fig)

average_shipping_time
```","The evaluated code is correct in logic and correctly visualizes the shipping time distribution. However, it fails to display the average shipping time in a DataFrame format using 'show_to_user', and instead returns the computed value as the final output.","```python
import pandas as pd
import plotly.express as px

# Assuming the execute_sql_query and show_to_user functions are predefined
# and available for use according to the given constraints.

# SQL query to get the average shipping time
sql_query = """"""
SELECT 
    DATEDIFF(orders.ShippedDate, orders.OrderDate) AS shipping_time 
FROM 
    orders 
WHERE 
    orders.ShippedDate IS NOT NULL
""""""

# Execute SQL query and get the result in a pandas DataFrame
df_shipping_times = execute_sql_query(sql_query)

# Calculate the average shipping time
avg_shipping_time = df_shipping_times['shipping_time'].mean()

# Print the result to the user
show_to_user(pd.DataFrame({'Average Shipping Time': [avg_shipping_time]}))

# Visualize the distribution of shipping times using Plotly
fig = px.histogram(df_shipping_times, x='shipping_time', title='Distribution of Shipping Times')
show_to_user(fig)
```","The provided code correctly implements the requirements: it calculates the average shipping time and visualizes the distribution of shipping times. It uses the same logic as the reference code, employing a SQL query to compute shipping times, calculating the average, and using Plotly for visualization. Both codes also display the average shipping time and the histogram to the user. The naming and structure differences, such as variable names, do not affect the correctness of the logic.",Finetuned
"Which suppliers provide products that are currently reordered the most, and can this information be represented using a bar chart showing reorder frequencies by supplier?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch supplier reorder information
sql_query = """"""
SELECT SupplierID, SUM(UnitsOnOrder) AS TotalUnitsOnOrder 
FROM products 
WHERE UnitsOnOrder > 0 
GROUP BY SupplierID 
ORDER BY TotalUnitsOnOrder DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize reorder frequencies by supplier
fig = px.bar(data, x='SupplierID', y='TotalUnitsOnOrder', 
             title='Reorder Frequencies by Supplier',
             labels={'TotalUnitsOnOrder': 'Total Units On Order', 'SupplierID': 'Supplier ID'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, COUNT(od.Quantity) AS ReorderFrequency
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.UnitsOnOrder > 0
GROUP BY p.SupplierID
ORDER BY ReorderFrequency DESC;
""""""

supplier_reorder_freq = execute_sql_query(sql_query)

fig = px.bar(supplier_reorder_freq, x='SupplierID', y='ReorderFrequency', title='Reorder Frequencies by Supplier', labels={'ReorderFrequency': 'Reorder Frequency', 'SupplierID': 'Supplier ID'})
show_to_user(fig)
```","The input code and reference implementation have different logic for determining reorder frequencies. The reference code sums 'UnitsOnOrder' for each supplier, while the input code counts occurrences of product reorder in '[Order Details]' joined by 'ProductID'. This results in different metrics: total units on order vs. count of order details. Hence, they do not adhere to the same logic.","```python
import plotly.express as px
import pandas as pd

# SQL query to get reorder frequencies by supplier
sql_query = """"""
SELECT suppliers.CompanyName, COUNT(products.ReorderLevel) AS ReorderCount
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
WHERE products.ReorderLevel = products.UnitsOnOrder
GROUP BY suppliers.CompanyName
ORDER BY ReorderCount DESC;
""""""

# Function to execute the SQL query and return the data as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for demonstration
    data = {
        'CompanyName': ['Supplier A', 'Supplier B', 'Supplier C'],
        'ReorderCount': [10, 20, 30]
    }
    return pd.DataFrame(data)

# Execute the query and collect the results into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize reorder frequencies by supplier
fig = px.bar(df, x='CompanyName', y='ReorderCount', 
             title='Reorder Frequencies by Supplier',
             labels={'CompanyName': 'Supplier', 'ReorderCount': 'Reorder Frequency'},
             text='ReorderCount')

# Use the utility function to display the figure
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

show_to_user(fig)
```","The input code calculates 'ReorderCount' by counting the occurrences where 'ReorderLevel' equals 'UnitsOnOrder', whereas the reference code sums 'UnitsOnOrder' for orders where 'UnitsOnOrder' is greater than zero. The logic for what constitutes a reorder is different between the two implementations. Additionally, the input code groups by 'suppliers.CompanyName' while the reference groups by 'SupplierID'. These differences suggest the input code doesn't fully align with the reference implementation's logic.",None
Determine the product with the lowest unit price that is not discontinued and create a bar chart to visualize the unit prices of the top five lowest-priced active products.,"import plotly.express as px
import pandas as pd


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function to simulate database interaction
    # Replace with actual database query execution code
    return pd.DataFrame({
        'ProductName': ['Product A', 'Product B', 'Product C', 'Product D', 'Product E'],
        'UnitPrice': [5.00, 6.00, 7.00, 8.00, 9.00]
    })


def show_to_user(data):
    # Mock function to simulate showing data
    # Replace with actual code to render data or visualization
    print(data)


# SQL query to get the top five lowest-priced active products
sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE Discontinued = 0 
ORDER BY UnitPrice ASC 
LIMIT 5;
""""""

# Execute SQL query
products_df = execute_sql_query(sql_query)

# Plot the bar chart
fig = px.bar(products_df, 
             x='ProductName', 
             y='UnitPrice', 
             title='Top Five Lowest-Priced Active Products',
             labels={'UnitPrice': 'Unit Price', 'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE Discontinued = 0 
ORDER BY UnitPrice 
LIMIT 5
""""""

top_lowest_priced_products = execute_sql_query(sql_query)

fig = px.bar(top_lowest_priced_products, x='ProductName', y='UnitPrice', title='Top 5 Lowest-Priced Active Products')
show_to_user(fig)
```","The provided input Python code executes the same logic as the reference implementation. Both codes perform an SQL query to select products that are not discontinued, order them by 'UnitPrice' in ascending order, and limit the results to the top five. The results are then visualized using a bar chart with the same configurations. The SQL queries and plotting functionalities are consistent across both implementations.","
import pandas as pd
import plotly.express as px

# Assume these utility functions are defined in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution function
    pass

def show_to_user(data):
    # Placeholder for displaying data or plots
    pass

# Step 1: SQL query to get the active products with their unit prices
sql_query = ""SELECT [Product ID], UnitPrice FROM products WHERE Discontinued = 0 ORDER BY UnitPrice ASC;""
active_products_df = execute_sql_query(sql_query)

# Step 2: Determine the product with the lowest unit price
lowest_price_product = active_products_df.iloc[0]
# Note: In real usage, replace print with actual visualization or logging
print(f""Product with lowest unit price: {lowest_price_product['Product ID']}, Price: {lowest_price_product['UnitPrice']}"")

# Step 3: Select the top five lowest-priced active products
top_five_active_products = active_products_df.head(5)

# Step 4: Create a bar chart for visualization
fig = px.bar(top_five_active_products, x='Product ID', y='UnitPrice', title='Top 5 Lowest-Priced Active Products',
             labels={'Product ID': 'Product ID', 'UnitPrice': 'Unit Price ($)'})

# Step 5: Display the bar chart
show_to_user(fig)
","The provided code differs from the reference implementation in critical ways that affect its correctness. Firstly, the reference code queries for 'ProductName' whereas the input code queries for 'Product ID'. This affects the determination of the product with the lowest unit price, as identifying a product by ID instead of by name deviates from the business analytics request. Additionally, the reference code plots the unit prices by 'ProductName', which is not possible in the input code because it uses 'Product ID'. This discrepancy in identifiers means the input code will not create the correct visualization as described in the business analytics request. Therefore, the input code does not conform to the logic and output specified by the reference implementation and thus, is not correct.",Base
"Which categories have the highest total sales, and can you provide a bar chart to illustrate this?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT CategoryID, SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSales
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY CategoryID
ORDER BY TotalSales DESC;
""""""

# Function to execute the SQL query and return results as a DataFrame
df = execute_sql_query(sql_query)

# Plotting the results using Plotly
fig = px.bar(df, x='CategoryID', y='TotalSales', title='Total Sales by Category', labels={'CategoryID': 'Category ID', 'TotalSales': 'Total Sales'})

# Displaying the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
ORDER BY TotalSales DESC
LIMIT 10
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Total Sales by Category', labels={'CategoryID': 'Category ID', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code adds a 'LIMIT 10' clause, which restricts the results to the top 10 categories only. The reference implementation does not have this limitation, implying that it returns all categories sorted by TotalSales. Therefore, the input code does not fully adhere to the logic of the reference implementation since it potentially alters the output.","```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user are predefined as specified

# Define SQL query
sql_query = """"""
SELECT 
    categories.CategoryName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    [Order Details] 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    categories ON products.CategoryID = categories.CategoryID 
GROUP BY 
    categories.CategoryName 
ORDER BY 
    TotalSales DESC;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='CategoryName', y='TotalSales', title='Total Sales by Category')

# Display the bar chart
show_to_user(fig)
```","The input code includes a discount factor in its SQL query ('(1 - [Order Details].Discount)') when calculating 'TotalSales', which is not present in the reference implementation. This changes the logic, as the reference code computes total sales without considering discounts. Additionally, the input code uses 'CategoryName' instead of 'CategoryID' for grouping and labeling, leading to a different presentation in the chart.",None
"Which product has the highest total sales, and can this be represented in a bar chart for clarity?","```python
import plotly.express as px

# SQL query to fetch the product with the highest total sales.
sql_query = """"""
SELECT [Order Details].ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS ProductSales 
FROM [Order Details] 
GROUP BY [Order Details].ProductID 
ORDER BY ProductSales DESC 
LIMIT 1;
""""""

# Execute the SQL query and get the result in a pandas DataFrame.
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the product with the highest total sales.
fig = px.bar(
    sales_data, 
    x='ProductID', 
    y='ProductSales', 
    title='Product with Highest Total Sales',
    labels={'ProductID': 'Product ID', 'ProductSales': 'Total Sales'}
)

# Show the result to the user.
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY od.ProductID
ORDER BY TotalSales DESC
LIMIT 1
""""""

top_product_sales = execute_sql_query(sql_query)

product_id = top_product_sales['ProductID'].values[0]

sql_query_details = f""""""
SELECT od.ProductID,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.ProductID = {product_id}
GROUP BY od.ProductID
""""""

sales_data = execute_sql_query(sql_query_details)

fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Total Sales of the Top Product')
show_to_user(fig)
```","The input Python code correctly identifies the product with the highest total sales using a SQL query similar to the reference code. It then uses Plotly to create a bar chart to visualize this information. The logic of summing the product sales and fetching the details for the given product ID matches the intent of the reference implementation, even with slight differences in the approach and query structure.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the product with the highest total sales
sql_query = """"""
SELECT ol.ProductID, SUM(ol.UnitPrice * ol.Quantity * (1 - ol.Discount)) AS TotalSales
FROM [Order Details] ol
GROUP BY ol.ProductID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

# Execute the SQL query to get the data
product_sales_df = execute_sql_query(sql_query)

# Visualize the result in a bar chart using Plotly
fig = px.bar(product_sales_df, 
             x='ProductID', 
             y='TotalSales', 
             title='Product with Highest Total Sales',
             labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales'},
             text='TotalSales')

# Display the visualization to the user
show_to_user(fig)
```",The input Python code correctly implements the business analytics request using the same logic as the reference implementation. It queries for the product with the highest total sales and visualizes the result using a bar chart with Plotly. Differences in variable naming (TotalSales vs. ProductSales) do not affect the correctness of the logic or outcome. The addition of the 'text' parameter in the Plotly bar chart is an enhancement that does not alter the core functionality.,both
"What is the total number of orders shipped last month, and can you provide a bar chart showing the number of orders shipped per week?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query for the total number of shipped orders last month
sql_query_total_orders = """"""
SELECT COUNT(orders.OrderID) AS Shipped_Orders 
FROM orders 
WHERE MONTH(orders.ShippedDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(orders.ShippedDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
""""""

# Function to execute an SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would contain the logic to interface with a database using SQL
    # For the purpose of this example, we'll assume the function returns a DataFrame
    pass

# Execute the SQL query to get total shipped orders last month
df_total_orders = execute_sql_query(sql_query_total_orders)

# Display the total number of shipped orders
show_to_user(df_total_orders)

# Define the SQL query to get the number of orders shipped per week last month
sql_query_orders_per_week = """"""
SELECT WEEK(orders.ShippedDate, 1) AS Week_Number, COUNT(orders.OrderID) AS Orders_Per_Week
FROM orders 
WHERE MONTH(orders.ShippedDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(orders.ShippedDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH)
GROUP BY WEEK(orders.ShippedDate, 1);
""""""

# Execute the SQL query to get orders per week
df_orders_per_week = execute_sql_query(sql_query_orders_per_week)

# Create and display a bar chart using Plotly
fig = px.bar(df_orders_per_week, x='Week_Number', y='Orders_Per_Week', 
             title='Number of Orders Shipped Per Week Last Month')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the total number of orders shipped last month
sql_total_orders = """"""
SELECT COUNT(*) as total_orders
FROM orders
WHERE ShippedDate >= DATE_FORMAT(NOW() - INTERVAL 1 MONTH, '%Y-%m-01') 
AND ShippedDate < DATE_FORMAT(NOW(), '%Y-%m-01')
""""""

# Execute the SQL query and retrieve the result
total_orders_df = execute_sql_query(sql_total_orders)
total_orders = total_orders_df['total_orders'].iloc[0]

# Define the SQL query to get the number of orders shipped per week last month
sql_weekly_orders = """"""
SELECT YEAR(ShippedDate) as year, WEEK(ShippedDate) as week, COUNT(*) as order_count
FROM orders
WHERE ShippedDate >= DATE_FORMAT(NOW() - INTERVAL 1 MONTH, '%Y-%m-01') 
AND ShippedDate < DATE_FORMAT(NOW(), '%Y-%m-01')
GROUP BY year, week
ORDER BY year, week
""""""

# Execute the SQL query and retrieve the result
weekly_orders_df = execute_sql_query(sql_weekly_orders)

# Create a bar chart for the number of orders shipped per week
fig = px.bar(weekly_orders_df, x='week', y='order_count',
             title='Number of Orders Shipped Per Week Last Month',
             labels={'week': 'Week', 'order_count': 'Number of Orders'},
             text='order_count')

# Show the total orders to the user
print(f'Total number of orders shipped last month: {total_orders}')

# Show the bar chart to the user
show_to_user(fig)
```","The input code is logically consistent with the reference implementation. Both codes execute SQL queries to obtain the total number of shipped orders for the previous month and the number of orders shipped per week. The input code correctly uses the SQL functions to filter last month's data and groups by week for the per-week analysis. Additionally, it uses Plotly for visualization, which matches the logic in the reference. Minor differences in the SQL syntax (e.g., using DATE_FORMAT and different GROUP BY syntax) are functionally equivalent to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total number of orders shipped last month
sql_query_total_orders = """"""
SELECT COUNT(o.OrderID) AS TotalOrders 
FROM orders o 
WHERE MONTH(o.ShippedDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(o.ShippedDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH);
""""""

# SQL query to get the number of orders shipped per week last month
sql_query_orders_per_week = """"""
SELECT DATE_TRUNC('week', o.ShippedDate) AS Week, COUNT(o.OrderID) AS NumOrders 
FROM orders o 
WHERE MONTH(o.ShippedDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(o.ShippedDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH)
GROUP BY Week 
ORDER BY Week;
""""""

# Function to execute the SQL query and return results as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # e.g., using SQLAlchemy or sqlite3 to connect and execute
    pass

# Retrieve the total number of orders
total_orders_df = execute_sql_query(sql_query_total_orders)

# Display the total number of orders
show_to_user(total_orders_df)

# Retrieve data for orders shipped per week
orders_per_week_df = execute_sql_query(sql_query_orders_per_week)

# Create a bar chart using Plotly
fig = px.bar(
    orders_per_week_df,
    x='Week',
    y='NumOrders',
    title='Number of Orders Shipped Per Week Last Month',
    labels={'NumOrders': 'Number of Orders'}
)

# Display the bar chart
show_to_user(fig)
```","The input code uses 'DATE_TRUNC('week', o.ShippedDate)' which might not produce the 'Week_Number' directly if the SQL dialect is expecting a different format (e.g., MySQL, which uses 'WEEK()'). The logic for grouping by week differs from the reference implementation, which uses 'WEEK(orders.ShippedDate, 1)'. Depending on the SQL database's handling of dates, the results could differ.",Base
"Which supplier is used the least for orders based on total sales, and can this be visualized through a bar chart?","import pandas as pd
import plotly.express as px

# Retrieve data using the provided SQL query
sql_query = """"""
SELECT suppliers.SupplierID, CompanyName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * 
(1 - [Order Details].Discount)) AS TotalSales 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, CompanyName 
ORDER BY TotalSales ASC 
LIMIT 1;
""""""
# Function placeholder to execute SQL query
def execute_sql_query(sql_query: str):
    # This function would run the SQL query and return a DataFrame.
    # Placeholder implementation
    return pd.DataFrame({
        ""SupplierID"": [1],
        ""CompanyName"": [""Example Supplier""],
        ""TotalSales"": [100.0]
    })

# Execute the SQL query and get the result
least_used_supplier_df = execute_sql_query(sql_query)

# Visualize the least used supplier with a bar chart
fig = px.bar(
    least_used_supplier_df, 
    x='CompanyName', 
    y='TotalSales', 
    title='Least Used Supplier by Total Sales',
    labels={'TotalSales': 'Total Sales'},
    text='TotalSales'
)

# Ensure text is displayed on the bar
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')

# Display the bar chart
def show_to_user(data):
    # This function displays the data visualization or DataFrame
    data.show()

show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalSales ASC
LIMIT 1
""""""

least_used_supplier = execute_sql_query(sql_query)

sales_data = execute_sql_query(""""""
SELECT s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.CompanyName
"""""")

fig = px.bar(sales_data, x='CompanyName', y='TotalSales', title='Total Sales by Supplier')
show_to_user(fig)
```","The input code does not directly visualize the least used supplier based on total sales. Instead, it plots all suppliers' total sales, which is not what the business request asked for. The reference code specifically queries the least used supplier and plots only that data, while the input code generates a plot for total sales of all suppliers. Additionally, the visualization should focus on the least used supplier, which the input code does not correctly implement.","```python
import plotly.express as px
import pandas as pd

# Execute the specified SQL query to get the supplier sales data
sql_query = """"""
SELECT orders.SupplierID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY orders.SupplierID 
ORDER BY total_sales ASC
LIMIT 1
""""""

# Retrieve the data using the utility function
supplier_sales_df = execute_sql_query(sql_query)

# Check if the resulting DataFrame is not empty
if not supplier_sales_df.empty:
    # Create a bar chart using Plotly to visualize the data
    fig = px.bar(supplier_sales_df, x='SupplierID', y='total_sales', title='Least Used Supplier by Total Sales', labels={
                 'SupplierID': 'Supplier ID', 'total_sales': 'Total Sales'})

    # Display the figure using the show_to_user utility function
    show_to_user(fig)
else:
    # Handle the case where no data is returned
    show_to_user(""No data available for the specified query."")
```","The input code does not correctly answer the request. The SQL query in the input code differs from the reference code's SQL query by not joining the 'suppliers' and 'products' tables, which is necessary to retrieve the 'CompanyName' of the supplier used the least. The input code only groups by 'SupplierID', which may not correspond to the correct supplier without those joins. Additionally, the input visualization uses 'SupplierID' instead of 'CompanyName' for the x-axis, which doesn't align with the business request.",None
What is the average discount given on orders for each supplier and how can this be visualized using a bar chart?,"```python
import plotly.express as px
import pandas as pd

# Business Analytic Request  
def analyze_and_visualize_average_discount():
    # Define SQL Query to get average discount per supplier
    sql_query = """"""
    SELECT suppliers.CompanyName, AVG([Order Details].Discount) AS AvgDiscount
    FROM suppliers
    JOIN products ON suppliers.SupplierID = products.SupplierID
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
    GROUP BY suppliers.CompanyName;
    """"""
    
    # Execute the SQL query using provided utility function
    data = execute_sql_query(sql_query)
    
    # Check if data is retrieved  
    if data.empty:
        raise ValueError(""No data found for the query."")
    
    # Create a bar chart using Plotly
    fig = px.bar(data, x='CompanyName', y='AvgDiscount', 
                 title='Average Discount Given by Suppliers', 
                 labels={'CompanyName': 'Supplier', 'AvgDiscount': 'Average Discount'},
                 template='plotly')

    # Display the visualization
    show_to_user(fig)

# Call the function to analyze and visualize
analyze_and_visualize_average_discount()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(od.Discount) AS AverageDiscount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.CompanyName
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='CompanyName', y='AverageDiscount', 
             title='Average Discount Given on Orders by Supplier',
             labels={'AverageDiscount': 'Average Discount', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The provided input code accurately performs the same logic as the reference code by calculating the average discount each supplier offers on their orders. It executes a similar SQL query, retrieving and calculating the average discounts correctly. The visualization with Plotly Express and bar chart labeling is consistent with the reference implementation. The method involves joining suppliers with products and order details, grouping by supplier name to compute the average discount just as in the reference.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT s.CompanyName, AVG(od.Discount) AS AvgDiscount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.CompanyName;
""""""

# Execute the SQL query and get the data
def execute_sql_query(sql_query: str):
    # Dummy function; actual implementation will connect to database
    # Replace this with code to query your database
    return pd.DataFrame({
        'CompanyName': ['Supplier A', 'Supplier B', 'Supplier C'],
        'AvgDiscount': [0.1, 0.15, 0.05]
    })

# Retrieve the data
data = execute_sql_query(sql_query)

# Visualize using a bar chart
fig = px.bar(data, x='CompanyName', y='AvgDiscount', title='Average Discount by Supplier')

# Display the figure
def show_to_user(data):
    # Dummy function; replace with proper display logic
    print(""Displaying data or visualization"")

show_to_user(fig)
```","The provided code correctly queries average discounts per supplier and visualizes the data using a bar chart, following the same business logic as the reference implementation. Though variable names differ slightly, both codes perform the same SQL join and aggregation operations, and both use Plotly for visualization. The use of dummy data and display functions is acceptable for this evaluation context.",both
Find the total sales revenue for each supplier and create a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a mocked function for demonstration purposes
    # In practice, this function would execute the SQL and return the result as a DataFrame
    pass


def show_to_user(data):
    # This is a mocked function for demonstration purposes
    # In practice, this would display data analysis or visualize the results
    pass

# SQL Query: Find total sales revenue for each supplier
sql_query = """"""
SELECT s.SupplierID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='SupplierID', y='TotalSales', 
             title='Total Sales Revenue per Supplier', 
             labels={'TotalSales': 'Total Sales Revenue', 'SupplierID': 'Supplier ID'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    s.SupplierID,
    s.CompanyName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    s.SupplierID, s.CompanyName
""""""

supplier_sales = execute_sql_query(sql_query)

fig = px.bar(supplier_sales, x='CompanyName', y='TotalRevenue', 
             title='Total Sales Revenue by Supplier', 
             labels={'TotalRevenue': 'Total Sales Revenue', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly calculates the total sales revenue for each supplier by joining the relevant tables and using the aggregation function SUM on the sales expression. It also extends the grouping to include CompanyName, which provides more detailed labeling for the bar chart. The visualization is created using Plotly to show the total sales revenue by supplier, matching the intention of the reference implementation. The primary logic of aggregating sales by supplier is consistent with the reference.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the total sales revenue for each supplier
sql_query = '''
SELECT 
    p.SupplierID,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales 
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID 
GROUP BY 
    p.SupplierID;
'''

# Execute the SQL query
df_sales = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales revenue for each supplier
fig = px.bar(
    df_sales, 
    x='SupplierID', 
    y='TotalSales', 
    title='Total Sales Revenue by Supplier',
    labels={'SupplierID': 'Supplier ID', 'TotalSales': 'Total Sales Revenue'}
)

# Display the results to the user
show_to_user(fig)
```","The input Python code correctly answers the business analytics request by calculating the total sales revenue for each supplier. It uses a SQL query to sum the product of UnitPrice, Quantity, and applied Discount, similar to the reference implementation. Then, it visualizes this data using a bar chart with Plotly, which aligns with the reference logic. The differences, such as the order of joined tables and minor syntax variations, do not affect the functional outcome.",both
Calculate total sales per month and provide a line graph to visualize the trends.,"```python
import plotly.express as px
import pandas as pd

# SQL query to calculate total sales per month
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM orders.OrderDate) AS OrderMonth, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] 
    ON orders.OrderID = [Order Details].OrderID 
GROUP BY EXTRACT(MONTH FROM orders.OrderDate);
""""""

# Execute the query and get the data
sales_data = execute_sql_query(sql_query)

# Create a line graph using Plotly
fig = px.line(sales_data, x='OrderMonth', y='TotalSales', title='Total Sales Per Month')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    month
ORDER BY 
    month;
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.line(total_sales_df, x='month', y='total_sales', title='Total Sales per Month', labels={'total_sales': 'Total Sales', 'month': 'Month'})
show_to_user(fig)
```","Both implementations perform the same task: calculate total sales per month and visualize the trend with a line graph. Differences in SQL syntax (e.g., 'EXTRACT(MONTH FROM ...)' vs. 'DATE_FORMAT(...)') are due to variations between SQL dialects but achieve the same grouping logic. Both use Plotly for visualization and correctly identify 'month' and 'total_sales' as axes. Thus, the input code adheres to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Provided utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to fetch total sales per month
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders 
JOIN 
    [Order Details] 
ON 
    orders.OrderID = [Order Details].OrderID 
GROUP BY 
    DATE_FORMAT(orders.OrderDate, '%Y-%m');
""""""

# Execute SQL query and store result in DataFrame
sales_data = execute_sql_query(sql_query)

# Create a line graph to visualize total sales per month
fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales Per Month')

# Display the line graph using the show_to_user utility function
show_to_user(fig)
```","The input code uses DATE_FORMAT to group by year and month, which is different from the EXTRACT(MONTH FROM...) used in the reference, which groups by month only. This results in a different level of aggregation. Also, the input code outputs 'Month' in a different format ('%Y-%m'), while the reference uses only the month number.",Base
"How many customers are there in each region, and can this be represented with a bar chart for clearer insights?","```python
import plotly.express as px

# SQL query to find the number of customers per region
sql_query = """"""
SELECT c.Region, COUNT(c.CustomerID) AS CustomerCount
FROM customers c
GROUP BY c.Region;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Region', y='CustomerCount', title='Number of Customers per Region')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Region, COUNT(CustomerID) AS CustomerCount
FROM customers
GROUP BY Region
""""""

customer_counts = execute_sql_query(sql_query)

fig = px.bar(customer_counts, x='Region', y='CustomerCount', title='Customer Count by Region')
show_to_user(fig)
```","The input code performs the same logical operations as the reference implementation. It queries the number of customers per region using SQL, executs the query to receive a DataFrame, and creates a bar chart with Plotly. The variable names and minor syntax differences do not affect the correctness of the code as they adhere to the request and match the reference code's logic.","```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate SQL execution
    # Assume this function connects to the database and returns a DataFrame
    pass

# Utility function to show data analysis or visualization results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        # Simulate displaying the Plotly figure
        print(""Plotly figure displayed"")

# SQL query to get the count of customers in each region
sql_query = """"""
SELECT Region, COUNT(CustomerID) AS CustomerCount 
FROM customers 
GROUP BY Region;
""""""

# Execute the query and get the results in a DataFrame
customer_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(customer_data, x='Region', y='CustomerCount', title='Number of Customers per Region')

# Display the bar chart
show_to_user(fig)
```","The input Python code accurately performs the task specified in the business analytics request. It uses a SQL query to count the number of customers in each region, which aligns with the reference implementation. A bar chart is then created using Plotly to visualize the results. The only differences are minor, such as variable names and placeholder functions; however, the logic and outcomes are the same as the reference code.",both
"What is the average discount given on orders per month, and can you provide a line chart to visualize the trends over time?","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query and retrieve the results into a DataFrame
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, AVG(Discount) AS AvgDiscount 
FROM `Order Details` od 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""
df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize the average discount given on orders per month
fig = px.line(df, x='Month', y='AvgDiscount', title='Average Discount per Month', 
              labels={'AvgDiscount': 'Average Discount', 'Month': 'Month'})

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    AVG(Discount) AS AverageDiscount
FROM 
    `orders` o
JOIN 
    `[Order Details]` od ON o.OrderID = od.OrderID
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.line(average_discount_df, x='OrderMonth', y='AverageDiscount', title='Average Discount Given on Orders per Month', markers=True)
show_to_user(fig)
```","The evaluated code correctly calculates the average discount per month using the DATE_FORMAT function to group by month and year, similar to the reference code. It performs a join between the 'orders' and 'Order Details' tables on OrderID, which is consistent with the reference. The line chart created uses Plotly to visualize the trend over time, with appropriate labels and titles. The minor difference in SQL syntax, such as table names and column aliases, does not affect the correctness of the logic. Therefore, the input code is deemed correct.","
```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    AVG([Order Details].Discount) AS AvgDiscount 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY 
    Month;
""""""

# Execute the SQL query and get the result in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would typically connect to a database, execute the query,
    # and return the result as a pandas DataFrame.
    pass  # Replace with actual implementation

# Fetch the data
data_df = execute_sql_query(sql_query)

# Visualizing the trends over time using a Line chart
fig = px.line(data_df, x='Month', y='AvgDiscount', title='Average Discount per Month')

# Display the figure
def show_to_user(data):
    # This function displays the data.
    # It can handle both DataFrames and Plotly figures.
    pass  # Replace with actual implementation

show_to_user(fig)
```
","The input code correctly executes the request to find the average discount per month and visualize it. Both codes use SQL to compute the average discount per month, use similar SQL structures for grouping and averaging, and employ Plotly to create a line chart for visualization. The only significant difference is the SQL dialect (DATE_FORMAT vs DATE_TRUNC) which is not relevant for correctness. Therefore, the logic and the result are equivalent.",both
Which supplier has the highest number of unique products? Include a bar chart to visualize the number of unique products per supplier.,"import pandas as pd
import plotly.express as px

# Define the SQL query to find the number of unique products per supplier
sql_query = """"""
SELECT s.CompanyName, COUNT(DISTINCT p.ProductID) AS UniqueProducts 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.CompanyName 
ORDER BY UniqueProducts DESC;
""""""

# Execute the SQL query
supplier_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the unique products per supplier
fig = px.bar(supplier_data, x='CompanyName', y='UniqueProducts', 
             title='Unique Products per Supplier', 
             labels={'CompanyName': 'Supplier', 'UniqueProducts': 'Number of Unique Products'})

# Show the visualization
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, COUNT(DISTINCT p.ProductID) AS UniqueProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID
ORDER BY UniqueProductCount DESC
LIMIT 1
""""""

result = execute_sql_query(sql_query)
highest_supplier = result.iloc[0]

sql_query_all = """"""
SELECT s.CompanyName, COUNT(DISTINCT p.ProductID) AS UniqueProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID
""""""

all_suppliers = execute_sql_query(sql_query_all)

fig = px.bar(all_suppliers, x='CompanyName', y='UniqueProductCount', title='Number of Unique Products per Supplier')
show_to_user(fig)

highest_supplier
```","The input code correctly retrieves the supplier with the highest number of unique products and creates a bar chart to visualize the data, but it does not adhere to the same logic as the reference implementation. Specifically, the grouping in the input code is done by 'SupplierID', while the reference code groups by 'CompanyName'. This change in grouping could yield unexpected results if multiple suppliers have the same name. Hence, despite achieving the business objective, it is not logically aligned with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of unique products per supplier
sql_query = """"""
SELECT s.SupplierID, COUNT(DISTINCT p.ProductID) AS UniqueProductCount 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID 
ORDER BY UniqueProductCount DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
supplier_products_df = execute_sql_query(sql_query)

# Find the supplier with the highest number of unique products
top_supplier = supplier_products_df.iloc[0]

# Create a bar chart to visualize the number of unique products per supplier
fig = px.bar(supplier_products_df, 
             x='SupplierID', 
             y='UniqueProductCount', 
             title='Number of Unique Products per Supplier',
             labels={'UniqueProductCount': 'Number of Unique Products', 'SupplierID': 'Supplier ID'})

# Show the visualization to the user
show_to_user(fig)

# Optionally, show the top supplier information
top_supplier_df = pd.DataFrame([{'SupplierID': top_supplier['SupplierID'], 'UniqueProductCount': top_supplier['UniqueProductCount']}])
show_to_user(top_supplier_df)
```","The input code retrieves and visualizes the suppliers by SupplierID instead of CompanyName as requested. The task requires identification by CompanyName to meet the business analytics request's intention. While the logic for counting unique products is consistent with the reference, the key identification for suppliers is incorrect.",None
"Which employee handles the most orders shipped late, and provide a bar chart visualization of the number of late shipments per employee?","import plotly.express as px
import pandas as pd

# SQL query to find the number of late shipments per employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS LateOrders 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY EmployeeID 
ORDER BY LateOrders DESC;
""""""

# Function to execute the SQL query and get the result as a DataFrame
late_orders_df = execute_sql_query(sql_query)

# Finding the EmployeeID with the most late orders
most_late_employee = late_orders_df.iloc[0]

# Display data for the employee with the most late orders
show_to_user(pd.DataFrame([most_late_employee]))

# Bar chart visualization of late shipments per employee
fig = px.bar(late_orders_df, x='EmployeeID', y='LateOrders', 
             title='Number of Late Shipments per Employee',
             labels={'LateOrders': 'Late Shipments', 'EmployeeID': 'Employee ID'})

# Show the bar chart
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS LateShipments
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY EmployeeID
ORDER BY LateShipments DESC
LIMIT 1
""""""

most_late_employee = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT EmployeeID, COUNT(OrderID) AS LateShipments
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY EmployeeID
""""""

late_shipments_per_employee = execute_sql_query(sql_query_all)

fig = px.bar(late_shipments_per_employee, x='EmployeeID', y='LateShipments', 
             title='Number of Late Shipments per Employee', 
             labels={'EmployeeID': 'Employee ID', 'LateShipments': 'Late Shipments'})

show_to_user(fig)
```","The input code correctly executes a SQL query to find the employee who handles the most late shipments by ordering the results by LateShipments and limiting the result to 1, which corresponds to the reference implementation's first row retrieval. It also correctly executes a separate SQL query to get the late shipments per employee for the bar chart visualization, which aligns with the reference implementation. The visualization and the logic follow the same business request, meeting the requirements.","```python
import pandas as pd
import plotly.express as px

# SQL query to get late shipments per employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS LateShipments 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY EmployeeID;
""""""

# Execute the SQL query
late_shipments_df = execute_sql_query(sql_query)

# Find the employee with the most late shipments
most_late_shipments_employee = late_shipments_df.loc[late_shipments_df['LateShipments'].idxmax()]

# Print the employee with the most late shipments
show_to_user(pd.DataFrame([most_late_shipments_employee]).rename(columns={0: 'EmployeeID', 1: 'LateShipments'}))

# Create a bar chart visualization using Plotly
fig = px.bar(
    late_shipments_df,
    x='EmployeeID',
    y='LateShipments',
    title='Number of Late Shipments per Employee'
)

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the requested analysis. It executes an SQL query to count late shipments per employee, determines the employee with the most late shipments, and creates a bar chart of late shipments per employee. The logic aligns with the reference implementation, as both codes use similar SQL queries and plotting techniques, despite minor differences such as variable names.",both
"Which country has the highest number of orders, and can you provide a bar chart to visualize the number of orders by country?","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are pre-defined functions as per the given constraints

# SQL Query to get the number of orders by country
sql_query = '''
SELECT ShipCountry, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY ShipCountry 
ORDER BY TotalOrders DESC
'''

# Execute the SQL query and get the result as a DataFrame
orders_df = execute_sql_query(sql_query)

# Get the country with the highest number of orders
if not orders_df.empty:
    top_country = orders_df.iloc[0]['ShipCountry']
    top_count = orders_df.iloc[0]['TotalOrders']
    
    # Display the top country and number of orders
    result_df = pd.DataFrame({'ShipCountry': [top_country], 'TotalOrders': [top_count]})
    show_to_user(result_df)

    # Create a bar chart to visualize the number of orders by country
    fig = px.bar(orders_df, x='ShipCountry', y='TotalOrders', title='Number of Orders by Country')
    show_to_user(fig)
else:
    show_to_user(""No data available"")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCountry
ORDER BY OrderCount DESC
LIMIT 1
""""""
highest_country_order = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT ShipCountry, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCountry
""""""
orders_by_country = execute_sql_query(sql_query_all)

fig = px.bar(orders_by_country, x='ShipCountry', y='OrderCount', title='Number of Orders by Country')
show_to_user(fig)
```","The input code only returns the country with the highest number of orders using LIMIT 1, which is insufficient to display it directly to the user as required. It does not explicitly display the top country and order count like the reference code does. Additionally, the input code assumes that the querying logic of LIMIT 1 is equivalent to fetching the top row from a descending ordered result, which may not address the scenario completely if there's a need to handle the empty result set. The graph is correctly created, but the specific task of explicitly displaying the top country is not fulfilled in the input code.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are pre-defined utility functions.

# SQL Query to get the number of orders by country
sql_query = """"""
SELECT ShipCountry, COUNT(OrderID) as NumOrders 
FROM orders 
GROUP BY ShipCountry 
ORDER BY NumOrders DESC;
""""""

# Execute the SQL query and get the results as a DataFrame
orders_by_country_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders by country
fig = px.bar(orders_by_country_df, x='ShipCountry', y='NumOrders', 
             title='Number of Orders by Country',
             labels={'ShipCountry': 'Country', 'NumOrders': 'Number of Orders'},
             text='NumOrders')

# Display the chart to the user
show_to_user(fig)
```","The input code is missing the step to identify and display the country with the highest number of orders. It only creates and displays the bar chart, whereas the reference code also selects and shows the top country with its order count.",None
"What are the top 5 cities where suppliers are located, and can you provide a bar chart to visualize these results?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.City, COUNT(*) AS SupplierCount
FROM suppliers
GROUP BY suppliers.City
ORDER BY SupplierCount DESC
LIMIT 5;
""""""

# Execute the query and fetch results
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='City', y='SupplierCount', title='Top 5 Cities by Supplier Count')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 5 cities where suppliers are located
sql_query = """"""
SELECT City, COUNT(*) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
LIMIT 5
""""""

# Execute the SQL query
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the results
fig = px.bar(top_cities_df, x='City', y='SupplierCount', title='Top 5 Cities by Number of Suppliers', labels={'SupplierCount': 'Number of Suppliers', 'City': 'City'})
show_to_user(fig)
```","The input code correctly follows the business request and aligns with the logic in the reference implementation. Both scripts execute a SQL query to find the top 5 cities with the highest supplier counts and visualize the results using a bar chart created with Plotly. The SQL queries and subsequent data visualization steps match in terms of logic, even if minor details like chart labels differ slightly.","
import pandas as pd
import plotly.express as px

# Utility functions based on the environment constraints.
def execute_sql_query(sql_query: str):
    # Simulated function to execute SQL and return DataFrame
    # Replace this with actual SQL execution logic
    return pd.DataFrame({
        'City': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'],
        'SupplierCount': [150, 120, 110, 100, 95]
    })

def show_to_user(data):
    # Simulated function to display data
    # It would display a DataFrame or Plotly figure in the actual implementation
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query
sql_query = '''
    SELECT City, COUNT(DISTINCT SupplierID) AS SupplierCount 
    FROM suppliers 
    GROUP BY City 
    ORDER BY SupplierCount DESC 
    LIMIT 5;
'''

# Execute SQL query
top_cities_df = execute_sql_query(sql_query)

# Visualization
fig = px.bar(top_cities_df, x='City', y='SupplierCount', title='Top 5 Cities by Supplier Count')

# Show the results
show_to_user(fig)
","The input Python code correctly executes a SQL query to fetch the top 5 cities with the highest supplier count, similar to the reference implementation. The code uses Plotly's bar chart for visualization and a simulated method to display the results. Although it uses 'COUNT(DISTINCT SupplierID)' instead of 'COUNT(*),' the context does not indicate that this would change the intended outcome. Therefore, the logic aligns with the reference implementation.",both
Identify products with the highest average discount and represent the findings using a bar chart for better comparison.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch products with their average discount
sql_query = """"""
SELECT products.ProductID, AVG([Order Details].Discount) AS AverageDiscount
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductID
ORDER BY AverageDiscount DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume some implementation that executes the query and returns a DataFrame
    pass

# Fetching data using the execute_sql_query function
df = execute_sql_query(sql_query)

# Fix: Ensure df is limited to highest average discount
df = df.head(1)

# Visualize results using a bar chart
fig = px.bar(df, x='ProductID', y='AverageDiscount', 
             title='Products with Highest Average Discount', 
             labels={'ProductID': 'Product ID', 'AverageDiscount': 'Average Discount'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, AVG(od.Discount) AS AverageDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY AverageDiscount DESC
LIMIT 10;
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='ProductName', y='AverageDiscount', title='Top Products by Average Discount')
show_to_user(fig)
```","The input code retrieves the top 10 products by average discount and uses 'ProductName' instead of 'ProductID' for the bar chart, which differs from the reference implementation that focuses on only the product with the highest average discount using 'ProductID'.","```python
import pandas as pd
import plotly.express as px

# Assuming the execute_sql_query and show_to_user are predefined

# SQL query to fetch the necessary data
sql_query = """"""
SELECT products.ProductID, AVG([Order Details].Discount) AS avg_discount 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID 
ORDER BY avg_discount DESC
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for better comparison
fig = px.bar(df, x='ProductID', y='avg_discount', 
             title='Products with Highest Average Discount',
             labels={'avg_discount':'Average Discount', 'ProductID':'Product ID'})

# Display the bar chart
show_to_user(fig)
```","The input code does not limit the DataFrame to the product with the highest average discount. Unlike the reference code, it does not include 'df = df.head(1)', which ensures only the top product is visualized. Without this, the bar chart will show all products, not adhering to the specific request for displaying only the highest average discount.",None
Analyze the correlation between product price and the number of orders received and include a scatter plot to visualize the relationship.,"import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user functions are already defined as per the constraints

# SQL query for retrieving the required data
sql_query = """"""
SELECT P.ProductName, P.UnitPrice, COUNT(OD.OrderID) AS OrderCount
FROM [Order Details] OD
JOIN products P ON OD.ProductID = P.ProductID
GROUP BY P.ProductID, P.ProductName, P.UnitPrice
ORDER BY OrderCount DESC;
""""""

# Execute the query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Calculate the correlation coefficient between UnitPrice and OrderCount
correlation_coefficient = df['UnitPrice'].corr(df['OrderCount'])

# Create a scatter plot to visualize the relationship between UnitPrice and OrderCount
fig = px.scatter(df, x='UnitPrice', y='OrderCount', text='ProductName',
                 title=f'Scatter Plot of Product Price vs. Number of Orders (Correlation: {correlation_coefficient:.2f})',
                 labels={'UnitPrice': 'Product Price', 'OrderCount': 'Number of Orders'},
                 hover_data={'ProductName': True, 'UnitPrice': ':.2f', 'OrderCount': ':d'})

# Show the scatter plot to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.UnitPrice, 
    SUM(od.Quantity) AS TotalOrders
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.UnitPrice
""""""

data = execute_sql_query(sql_query)

correlation = data.corr().iloc[0, 1]

fig = px.scatter(data, x='UnitPrice', y='TotalOrders', 
                 title=f'Correlation between Product Price and Number of Orders: {correlation:.2f}',
                 labels={'UnitPrice': 'Unit Price', 'TotalOrders': 'Total Orders'})
show_to_user(fig)
```","The input code calculates the total quantity of products ordered for each price (using `SUM(od.Quantity) AS TotalOrders`) instead of the count of orders per product. The reference code calculates `COUNT(OD.OrderID)` for the OrderCount, which reflects the actual number of orders instead of total quantities ordered. Additionally, the input code calculates correlation using these totals and not based on counts as required by the business analytics request.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function for execution
    # This should contain actual code to execute the SQL and return as a DataFrame
    pass

def show_to_user(data):
    # Mock function to show plot or DataFrame
    pass

# SQL Query to get the correlation data
sql_query = """"""
SELECT correlation(n, o) AS correlation_value
FROM (
    SELECT p.UnitPrice AS n, COUNT(o.OrderID) AS o
    FROM products p
    JOIN [Order Details] od ON p.ProductID = od.ProductID
    JOIN orders o ON o.OrderID = od.OrderID
    GROUP BY p.UnitPrice
) AS subquery;
""""""

# Execute query to get correlation value
correlation_df = execute_sql_query(sql_query)

# Display correlation value
show_to_user(correlation_df)

# SQL Query to get data for scatter plot
sql_query_for_plot = """"""
SELECT p.UnitPrice AS price, COUNT(o.OrderID) AS order_count
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON o.OrderID = od.OrderID
GROUP BY p.UnitPrice;
""""""

# Execute query to get data for plotting
plot_data_df = execute_sql_query(sql_query_for_plot)

# Create scatter plot using Plotly
fig = px.scatter(plot_data_df, x='price', y='order_count',
                 title='Scatter Plot of Product Price vs Number of Orders',
                 labels={'price': 'Product Price', 'order_count': 'Number of Orders'},
                 trendline='ols')  # Adding a trendline for better analysis

# Display scatter plot
show_to_user(fig)
```","The evaluated code does not compute the correlation coefficient in the same way as the reference implementation. While it does use SQL to attempt direct calculation, this approach is not standard in SQL and assumes the presence of a 'correlation' function, which may not exist. The reference implementation correctly calculates correlation using pandas' 'corr' method after retrieving the data. Additionally, the evaluated code attempts to calculate correlation using a non-standard nested query structure and does not return a valid format for direct display. The scatter plot portion is mostly correct but does not include product names as text on the plot, as the reference does.",None
Which employees handled the most customer orders? Please include a bar chart to visualize the comparison of order counts per employee.,"```python
import plotly.express as px
import pandas as pd

# SQL Query to execute
sql_query = """"""
SELECT o.EmployeeID, COUNT(o.OrderID) AS OrdersHandled
FROM orders o
GROUP BY o.EmployeeID
ORDER BY OrdersHandled DESC;
""""""

# Execute the SQL query and return the results as a DataFrame
orders_df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the comparison of order counts per employee
fig = px.bar(orders_df, x='EmployeeID', y='OrdersHandled',
             title='Orders Handled by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'OrdersHandled': 'Number of Orders Handled'},
             text='OrdersHandled')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""
orders_count = execute_sql_query(sql_query)

fig = px.bar(orders_count, x='EmployeeID', y='OrderCount', title='Order Counts per Employee')
show_to_user(fig)
```","The input Python code correctly implements the requested task. It selects EmployeeID and counts the number of orders they handled, grouping by EmployeeID and ordering by the count in descending order. The resulting DataFrame is then visualized with a bar chart, displaying OrderCount per EmployeeID, which matches the reference implementation's logic and end goal.","```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the SQL query and return the results as a pandas DataFrame
    # For this example, it's assumed that the function is already implemented
    pass

# Utility function to show results to the user
def show_to_user(data):
    # This function should display data to the user
    # It accepts a pandas DataFrame or a Plotly figure
    pass

# SQL query to get the employee order counts
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    COUNT(orders.OrderID) AS OrderCount 
FROM 
    employees 
JOIN 
    orders 
ON 
    employees.EmployeeID = orders.EmployeeID 
GROUP BY 
    employees.EmployeeID 
ORDER BY 
    OrderCount DESC
""""""

# Execute the SQL query and get the result as a DataFrame
df_order_counts = execute_sql_query(sql_query)

# Visualize using Plotly to create a bar chart
fig = px.bar(df_order_counts, x='EmployeeID', y='OrderCount', 
             title='Number of Orders Handled by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Order Count'},
             text='OrderCount',
             template='plotly')

# Display the plot using the utility function
show_to_user(fig)
```","The input code aligns with the reference logic by querying the employee order counts using a SQL SELECT statement, joining the employees and orders tables, grouping by EmployeeID, and ordering the results in descending order by order count. It also uses Plotly to generate a bar chart with the desired labels and titles, and the bar chart is displayed. The input code achieves the same result as the reference implementation, albeit with a slightly different SQL query due to the join usage, which is correct and valid in this context.",both
"Which products are on order but currently discontinued, and can you visualize the quantities of these products on a bar chart?","```python
import plotly.express as px

# SQL query to find products on order but discontinued
sql_query = """"""
SELECT ProductID, ProductName, UnitsOnOrder 
FROM products 
WHERE Discontinued = 1 AND UnitsOnOrder > 0;
""""""

# Execute the SQL query
product_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities of discontinued products on order
fig = px.bar(
    product_data, 
    x='ProductName', 
    y='UnitsOnOrder',
    title='Quantities of Discontinued Products on Order',
    labels={'ProductName': 'Product Name', 'UnitsOnOrder': 'Units On Order'},
    text='UnitsOnOrder'
)

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, od.Quantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 1 AND od.Quantity > 0
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='ProductName', y='Quantity', title='Quantities of Discontinued Products on Order')
show_to_user(fig)
```","The input code is incorrect because it uses the 'Order Details' table to find the 'Quantity' of products on order. However, the reference code directly uses the 'UnitsOnOrder' field from the 'products' table, which likely represents items currently on order, not historically. The logic and data source differ from the reference implementation.","
import plotly.express as px
import pandas as pd

# Assume the following utility functions are predefined:
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function
    pass

def show_to_user(data):
    # This is a placeholder function
    pass

# SQL query to get the products that are on order and discontinued
sql_query = """"""
SELECT ProductName, UnitsOnOrder 
FROM products 
WHERE Discontinued = 1 AND UnitsOnOrder > 0;
""""""

# Execute the SQL query using the utility function provided
discontinued_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities of discontinued products on order
fig = px.bar(
    discontinued_products_df,
    x='ProductName',
    y='UnitsOnOrder',
    title='Quantities of Discontinued Products on Order',
    labels={'ProductName': 'Product Name', 'UnitsOnOrder': 'Units On Order'}
)

# Use the utility function to display the figure to the user
show_to_user(fig)
","The input Python code correctly executes the SQL query to retrieve products that are discontinued and currently on order, excluding units with zero quantity, by specifying 'WHERE Discontinued = 1 AND UnitsOnOrder > 0'. It then creates a bar chart using Plotly Express to visualize these products, setting 'ProductName' on the x-axis and 'UnitsOnOrder' on the y-axis. This approach aligns with the intent and logic of the reference implementation, given the same conditions and similar visualization methodology.",Finetuned
"How many unique products does each supplier offer, and can you provide a bar chart to visualize the distribution across suppliers?","```python
import plotly.express as px
import pandas as pd

# SQL query
sql_query = """"""
SELECT p.SupplierID, COUNT(DISTINCT p.ProductID) AS UniqueProducts 
FROM products p 
GROUP BY p.SupplierID;
""""""

# Assuming execute_sql_query is already defined
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='UniqueProducts', title='Unique Products per Supplier')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(DISTINCT p.ProductID) AS UniqueProducts
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.CompanyName
""""""

supplier_products = execute_sql_query(sql_query)

fig = px.bar(supplier_products, x='CompanyName', y='UniqueProducts', title='Unique Products per Supplier', labels={'UniqueProducts': 'Number of Unique Products', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly computes the number of unique products for each supplier by joining 'suppliers' and 'products' tables and grouping by 'SupplierID' and 'CompanyName'. It then visualizes the data using a bar chart with 'CompanyName' on the x-axis and 'UniqueProducts' on the y-axis. While it includes an additional 'CompanyName' column compared to the reference, it maintains the same logic and fulfills the business analytics request by showing the unique product count per supplier along with a bar chart.","```python
import plotly.express as px

# SQL query to fetch the unique count of products per supplier
sql_query = """"""
SELECT SupplierID, COUNT(DISTINCT ProductID) AS UniqueProductCount 
FROM products 
GROUP BY SupplierID;
""""""

# Execute the SQL query and get the results as a pandas DataFrame
supplier_product_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of unique products across suppliers
fig = px.bar(supplier_product_data, x='SupplierID', y='UniqueProductCount', 
             title='Unique Products Offered by Each Supplier', 
             labels={'SupplierID': 'Supplier ID', 'UniqueProductCount': 'Unique Product Count'})

# Display the plot using the utility function
show_to_user(fig)
```","The input Python code adheres to the same logic as the reference implementation. Both queries correctly count the number of unique products per supplier using a similar SQL query, and both use Plotly to create a bar chart to visualize this data. The only differences are in naming conventions and additional labeling options in the input code, which do not affect the correctness of addressing the business analytics request.",both
"What is the on-time delivery rate each month, and can you provide a line chart to visualize the trends over time?","```python
import pandas as pd
import plotly.express as px

# Assume the utility functions are defined externally
def execute_sql_query(sql_query: str):
    # This function is assumed to be implemented elsewhere
    pass

def show_to_user(data):
    # This function is assumed to be implemented elsewhere
    pass

# SQL query to fetch on-time delivery rate per month
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the query and store the result in a DataFrame
order_data = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(order_data, x='Month', y='OnTimeDeliveryRate', 
              title='On-Time Delivery Rate Per Month',
              labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate', 'Month': 'Month'})

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

df = execute_sql_query(sql_query)

df['OnTimeDeliveryRate'] = df['OnTimeDeliveries'] / df['TotalOrders'] * 100

fig = px.line(df, x='Month', y='OnTimeDeliveryRate', title='On-Time Delivery Rate Each Month', labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'Month': 'Month'})
show_to_user(fig)
```","The input Python code correctly calculates the on-time delivery rate per month using similar logic to the reference code. While the syntax differs (using DATE_FORMAT vs. DATE_TRUNC), the logic of calculating the on-time delivery rate as the ratio of on-time deliveries to total orders is consistent. Both implementations create a line chart using Plotly to visualize the trends over time and display it to the user.","
import pandas as pd
import plotly.express as px

# Placeholder for the execute_sql_query utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    pass

# Placeholder for the show_to_user utility function
def show_to_user(data):
    pass

# SQL Query to get on-time delivery rate each month
sql_query = """"""
SELECT 
    DATE_FORMAT(b.OrderDate, '%Y-%m') AS Month, 
    COUNT(b.OrderID) FILTER (WHERE b.ShippedDate <= b.RequiredDate) * 100.0 / COUNT(b.OrderID) AS OnTimeDeliveryRate 
FROM 
    orders b 
GROUP BY 
    DATE_FORMAT(b.OrderDate, '%Y-%m');
""""""

# Execute the query and get the result as a DataFrame
data_df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize the on-time delivery rate trends
fig = px.line(data_df, x='Month', y='OnTimeDeliveryRate', title='On-Time Delivery Rate Per Month',
              labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'Month': 'Month'})

# Show the resulting visualization to the user
show_to_user(fig)
","The input code uses a different SQL syntax for calculating the on-time delivery rate, specifically using `FILTER` with `COUNT`, which may not be supported in all SQL databases. Additionally, the input code uses `DATE_FORMAT`, while the reference code uses `DATE_TRUNC`. The reference code orders the results by month, which is omitted in the input code, and the calculation scales percentages by 100, which wasn't specified in the task. These differences affect the logic and correctness.",Base
Which suppliers are located in the same city? Include a map visualization to display the locations of these suppliers.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get suppliers located in the same city
sql_query = """"""
SELECT City, STRING_AGG(DISTINCT SupplierID, ', ') AS SupplierIDs 
FROM suppliers 
GROUP BY City 
HAVING COUNT(DISTINCT SupplierID) > 1;
""""""
suppliers_df = execute_sql_query(sql_query)

# Display the data to the user for verification
show_to_user(suppliers_df)

# Assuming there is a supplementary table or data with lat-long for each city
# Example: city_coordinates such as city_coordinates = pd.DataFrame({'City': ..., 'Latitude': ..., 'Longitude': ...})
city_coordinates = pd.DataFrame({
    'City': ['City1', 'City2', 'City3'],
    'Latitude': [34.0522, 40.7128, 37.7749],
    'Longitude': [-118.2437, -74.0060, -122.4194]
})

# Merge supplier data with city coordinates
merged_df = pd.merge(suppliers_df, city_coordinates, on='City', how='inner')

# Create map visualization using Plotly
fig = px.scatter_mapbox(
    merged_df,
    lat='Latitude',
    lon='Longitude',
    hover_name='City',
    hover_data={'SupplierIDs': True},
    mapbox_style='carto-positron',
    zoom=3,
    title='Suppliers Located in the Same City'
)

# Show the map to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CompanyName, City
FROM suppliers
GROUP BY City, CompanyName
HAVING COUNT(*) > 1
""""""

suppliers_df = execute_sql_query(sql_query)

if not suppliers_df.empty:
    locations_query = """"""
    SELECT CompanyName, City, Address
    FROM suppliers
    WHERE City IN (SELECT City FROM suppliers GROUP BY City HAVING COUNT(*) > 1)
    """"""
    locations_df = execute_sql_query(locations_query)

    fig = px.scatter_mapbox(locations_df, 
                             lat=locations_df['Address'].str.split(',').str[-1].astype(float), 
                             lon=locations_df['Address'].str.split(',').str[0].astype(float),
                             hover_name='CompanyName',
                             mapbox_style='carto-positron',
                             zoom=5)
    show_to_user(fig)
```","The input code does not align with the business request and reference implementation. It incorrectly uses latitude and longitude from addresses, not centralized city data, leading to potential errors in visualization. Also, the aggregation logic deviates from the reference by improperly grouping and filtering suppliers. The input's map visualization lacks proper hover details specified in the reference code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT s1.SupplierID, s2.SupplierID, s1.City 
FROM suppliers s1 
JOIN suppliers s2 
ON s1.City = s2.City AND s1.SupplierID != s2.SupplierID;
""""""

# Execute the SQL query
df_suppliers = execute_sql_query(sql_query)

# Group by city to find pairs of suppliers
df_pairs = df_suppliers.groupby('City').agg(list).reset_index()

# Flatten the pairs for mapping
df_flat_pairs = df_pairs.explode('SupplierID')

# Get unique city coordinates for plotting
unique_locations = df_flat_pairs[['City', 'SupplierID']].drop_duplicates()

# Mock data for coordinates, in practice this should come from your data
# Assuming each city location has the same dummy longitude and latitude
unique_locations['lon'] = 0  # Placeholder for longitude
unique_locations['lat'] = 0  # Placeholder for latitude

# Correct the mocked coordinates to plot real locations, typically using geocoding
# You should replace the 0s with real coordinates using a mapping tool

# Create a map visualization
fig = px.scatter_mapbox(
    unique_locations,
    lat='lat',
    lon='lon',
    hover_name='SupplierID',
    size_max=10,
    zoom=3
)

# Display the map
show_to_user(fig)
```","The input code queries for each pair of suppliers in the same city but differs from the reference logic. The reference counts distinct suppliers per city and identifies cities with multiple suppliers. The input code focuses on pairwise combinations, not aligning with the reference logic. Moreover, it uses placeholder coordinates for plotting, not integrating real geospatial data like the reference.",None
"Which employees are responsible for the majority of orders in a specific territory, and can this be represented using a bar chart to visualize employee performance?","
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function is implemented to connect to a database, execute the given SQL query, 
    # and return the results as a pandas DataFrame.
    pass

def show_to_user(data):
    # Assume this function is implemented to display a DataFrame or Plotly figure.
    pass

# SQL query to find the employees responsible for the majority of orders in a specific territory
sql_query = """"""
SELECT employees.EmployeeID, CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
       COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShipRegion = 'SpecificTerritory' 
GROUP BY employees.EmployeeID, EmployeeName 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get the results in a DataFrame
results_df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
if not results_df.empty:
    fig = px.bar(results_df, x='EmployeeName', y='OrderCount', title='Top Employee Performance in Specific Territory')
    show_to_user(fig)
else:
    print(""No data found for the specified territory."")
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = 'Specific Territory'  -- replace with the actual territory
GROUP BY e.EmployeeID, EmployeeName
ORDER BY TotalSales DESC
""""""

employee_sales_df = execute_sql_query(sql_query)

fig = px.bar(employee_sales_df, x='EmployeeName', y='TotalSales', 
             title='Employee Performance in Specific Territory', 
             labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code calculates 'TotalSales' using order details, unlike the reference code which counts 'OrderCount'. Additionally, the input code filters by 'e.Region' while the reference filters by 'orders.ShipRegion'. These discrepancies mean it does not adhere to the same logic.","```python
import plotly.express as px
import pandas as pd

# Placeholder function for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Example implementation, replace with actual database interaction code
    # This is a mock. Replace it with actual implementation to fetch data from the database.
    mock_data = {
        'EmployeeID': [1, 2, 3],
        'TerritoryID': ['A', 'B', 'C'],
        'OrderCount': [150, 120, 100]
    }
    return pd.DataFrame(mock_data)

# Placeholder function for displaying result
def show_to_user(data):
    # Display the data or visualization to the user
    # Placeholder for actual display logic
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, o.TerritoryID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.TerritoryID = 'specified_territory' 
GROUP BY e.EmployeeID 
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate a bar chart to visualize employee performance
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Employee Performance in Territory',
             labels={'OrderCount': 'Number of Orders', 'EmployeeID': 'Employee ID'})

# Show the visualization to the user
show_to_user(fig)
```","The provided input code differs from the reference code in a few significant ways. Firstly, the input code lacks the employee names ('FirstName', 'LastName') in the result set, which are included in the reference query for more informative visualization. This is important as the business request asks for a visualization of employee performance in a specific territory. Secondly, the placeholder data in the mock `execute_sql_query` function includes 'TerritoryID' instead of 'EmployeeName', and this inconsistency with the reference holds the analysis incorrect. Finally, the input code uses 'specified_territory' instead of 'SpecificTerritory' as in the reference query, potentially leading to mismatched results. Therefore, the logic does not fully match the reference implementation or satisfy the business request correctly.",None
"Which supplier has the most delayed shipments, and can this be represented through a bar chart showing the number of delays per supplier?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve delays per supplier
sql_query = """"""
SELECT 
    suppliers.CompanyName, 
    COUNT(*) AS DelayCount
FROM 
    suppliers 
JOIN 
    products ON suppliers.SupplierID = products.SupplierID 
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.ShippedDate > orders.RequiredDate 
GROUP BY 
    suppliers.CompanyName
ORDER BY 
    DelayCount DESC
""""""

# Execute the SQL query using the provided utility function
df_delays = execute_sql_query(sql_query)

# Create a bar chart to show the number of delays per supplier
fig = px.bar(df_delays, x='CompanyName', y='DelayCount', title='Number of Delayed Shipments per Supplier', labels={'CompanyName': 'Supplier', 'DelayCount': 'Number of Delays'})

# Display the bar chart using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(o.OrderID) AS DelayedShipments
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID = o.OrderID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY s.SupplierID, s.CompanyName
ORDER BY DelayedShipments DESC
""""""

delayed_shipments_df = execute_sql_query(sql_query)

fig = px.bar(delayed_shipments_df, x='CompanyName', y='DelayedShipments', title='Number of Delayed Shipments per Supplier')
show_to_user(fig)
```","The input code incorrectly joins the 'products' and 'orders' tables. It should join 'products' to '[Order Details]' first, and then '[Order Details]' to 'orders'. Additionally, the join condition for 'orders' and 'products' incorrectly uses 'OrderID' instead of the 'ProductID' used in 'Order Details'.","
import pandas as pd
import plotly.express as px

# Define the SQL query to get the delayed shipments for each supplier.
sql_query = """"""
    SELECT 
        suppliers.CompanyName, 
        COUNT(orders.OrderID) AS DelayedShipments 
    FROM 
        suppliers 
    JOIN 
        products ON suppliers.SupplierID = products.SupplierID 
    JOIN 
        order_details ON products.ProductID = order_details.ProductID 
    JOIN
        orders ON orders.OrderID = order_details.OrderID 
    WHERE 
        orders.ShippedDate > orders.RequiredDate 
    GROUP BY 
        suppliers.CompanyName 
    ORDER BY 
        DelayedShipments DESC;
""""""

# Execute the SQL query using the utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function body: Replace with actual database connection and execution logic
    pass

# Fetching the data from the database
suppliers_delayed_shipments = execute_sql_query(sql_query)

# Visualize the results using a bar chart with Plotly
fig = px.bar(
    suppliers_delayed_shipments,
    x='CompanyName',
    y='DelayedShipments',
    title='Number of Delayed Shipments per Supplier',
    labels={'CompanyName': 'Supplier', 'DelayedShipments': 'Delayed Shipments'},
    color='DelayedShipments',
    template='plotly_dark'
)

# Display the figure
def show_to_user(data):
    # Stub function to illustrate use
    if isinstance(data, pd.DataFrame):
        print(data)  # Just for illustration; in practice, you'd show the DataFrame
    elif hasattr(data, 'show'):
        data.show()  # Plotly figure object

show_to_user(fig)
","The input Python code follows the same logic as the reference implementation. It correctly retrieves the number of delayed shipments per supplier using a SQL query that joins the necessary tables and applies the condition for delayed shipments. It groups by 'CompanyName' and orders the results by the count of delays, which matches the reference logic. The code also visualizes this data using Plotly to create a bar chart, similar to the reference implementation, fulfilling the business analytics request.",Finetuned
How many unique products has each employee sold? Include a bar chart to visualize the results by employee.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT E.EmployeeID, COUNT(DISTINCT OD.ProductID) AS UniqueProducts
FROM employees E
JOIN orders O ON E.EmployeeID = O.EmployeeID
JOIN [Order Details] OD ON O.OrderID = OD.OrderID
GROUP BY E.EmployeeID;
'''

# Execute the SQL query and get a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mocked function - to be replaced with actual implementation
    # For demonstration, replace with connection.execute(sql_query).fetchall()
    pass

# Retrieve the data
df = execute_sql_query(sql_query)

# Check if df is not None
if df is not None and not df.empty:
    # Create a bar chart using Plotly
    fig = px.bar(df, x='EmployeeID', y='UniqueProducts',
                 title='Number of Unique Products Sold by Each Employee',
                 labels={'UniqueProducts': 'Unique Products', 'EmployeeID': 'Employee ID'})

    # Show the plot
    show_to_user(fig)
else:
    print(""No data available to display."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName, 
    COUNT(DISTINCT od.ProductID) AS UniqueProducts
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName
""""""

employee_products = execute_sql_query(sql_query)

fig = px.bar(employee_products, 
              x='FirstName', 
              y='UniqueProducts', 
              title='Unique Products Sold by Each Employee', 
              labels={'UniqueProducts': 'Number of Unique Products', 
                      'FirstName': 'Employee First Name'})

show_to_user(fig)
```","The input code groups by FirstName and LastName in addition to EmployeeID, which might result in multiple entries for employees with the same first/last names, unlike the reference code. The visualization uses 'FirstName' instead of 'EmployeeID' for the x-axis, which differs from the requested logic of grouping solely by employee identifiers.","```python
import plotly.express as px

# SQL Query to execute
sql_query = """"""
SELECT e.EmployeeID, COUNT(DISTINCT od.ProductID) AS UniqueProductsSold
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
""""""

# Execute the SQL query
employee_unique_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    employee_unique_products_df, 
    x='EmployeeID', 
    y='UniqueProductsSold', 
    title='Unique Products Sold by Each Employee',
    labels={'UniqueProductsSold': 'Unique Products Sold', 'EmployeeID': 'Employee ID'}
)

# Show the bar chart to the user
show_to_user(fig)
```",The provided input code correctly implements the business analytics request. It executes an SQL query that matches the logic of the reference implementation by selecting the EmployeeID and counting the distinct ProductID sold by each employee. Both codes create a bar chart using Plotly to visualize the results by employee. The difference in column naming (UniqueProducts vs. UniqueProductsSold) does not affect the correctness of the logic.,Finetuned
"What is the total discount given on all orders, and can you provide a bar chart showing the total discount by month?","```python
import pandas as pd
import plotly.express as px

# SQL query to get total discounts and discount by each order with date
sql_query = """"""
SELECT 
    SUM(UnitPrice * Quantity * Discount) AS MonthlyDiscount,
    CONVERT(VARCHAR,YEAR(OrderDate)) + '-' + CONVERT(VARCHAR,MONTH(OrderDate)) AS OrderMonth
FROM 
    [Order Details] od
JOIN 
    Orders o ON od.OrderID = o.OrderID
GROUP BY 
    YEAR(OrderDate), MONTH(OrderDate)
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

df['OrderMonth'] = pd.to_datetime(df['OrderMonth'], format='%Y-%m')

# Calculate the total discount
total_discount = df['MonthlyDiscount'].sum()

# Display the total discount
show_to_user(pd.DataFrame({'TotalDiscount': [total_discount]}))

# Create a bar chart to display the discount by month
fig = px.bar(
    df, 
    x='OrderMonth', 
    y='MonthlyDiscount', 
    labels={'MonthlyDiscount': 'Total Discount', 'OrderMonth': 'Month'},
    title='Total Discount by Month'
)

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS OrderMonth,
    SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

discount_data = execute_sql_query(sql_query)

total_discount = discount_data['TotalDiscount'].sum()
print(f""Total Discount Given on All Orders: {total_discount}"")

fig = px.bar(discount_data, x='OrderMonth', y='TotalDiscount', title='Total Discount by Month')
show_to_user(fig)
```","The input code fulfills the business analytics request by calculating the total discount given on all orders and generating a bar chart showing the discount by month. It uses SQL to sum up the discounts on a per-month basis, which matches the logic of the reference code. Both implementations compute the total discount and display a monthly breakdown using a bar chart. Although there are differences in SQL syntax due to potential database dialect differences (e.g., use of DATE_TRUNC vs. CONVERT), the core functionality and logic are aligned with the reference implementation.","
```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the total discount per order
sql_query_total_discount = """"""
SELECT SUM(od.Quantity * od.UnitPrice * od.Discount) AS TotalDiscount FROM [Order Details] od;
""""""

# Execute the query to get the total discount
df_total_discount = execute_sql_query(sql_query_total_discount)

# SQL query to calculate the total discount by month
sql_query_monthly_discount = """"""
SELECT 
    YEAR(o.OrderDate) AS Year, 
    MONTH(o.OrderDate) AS Month,
    SUM(od.Quantity * od.UnitPrice * od.Discount) AS MonthlyDiscount 
FROM [Order Details] od
JOIN Orders o ON od.OrderID = o.OrderID
GROUP BY YEAR(o.OrderDate), MONTH(o.OrderDate)
ORDER BY Year, Month;
""""""

# Execute the query to get the monthly discount data
df_monthly_discount = execute_sql_query(sql_query_monthly_discount)

# Create a bar chart showing the total discount by month
fig = px.bar(
    df_monthly_discount, 
    x=['Year', 'Month'], 
    y='MonthlyDiscount', 
    title='Total Discount by Month',
    labels={'MonthlyDiscount': 'Total Discount', 'Month': 'Month', 'Year': 'Year'}
)

# Display the figure
show_to_user(fig)
```
","The input code does not correctly calculate and display the total discount across all orders. Although it appropriately calculates and plots the monthly discounts, it separately queries only the total discount but does not display or utilize this total in the same manner as the reference implementation. The reference code combines and displays the overall total discount and then creates a bar chart by month, whereas the input only plots the monthly data.",Base
"What are the top 5 countries generating the most revenue from orders, and can this be visualized using a bar chart to enhance understanding?","```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT customers.Country, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.Country 
ORDER BY total_revenue DESC 
LIMIT 5
""""""

# Execute SQL query
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 countries by revenue
fig = px.bar(data, x='Country', y='total_revenue', title='Top 5 Countries by Revenue', labels={'total_revenue': 'Total Revenue'})

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT orders.ShipCountry, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY orders.ShipCountry
ORDER BY total_sales DESC
LIMIT 5
""""""

top_countries = execute_sql_query(sql_query)

fig = px.bar(top_countries, 
              x='ShipCountry', 
              y='total_sales', 
              title='Top 5 Countries by Revenue', 
              labels={'ShipCountry': 'Country', 'total_sales': 'Total Revenue'})
show_to_user(fig)
```","The input code uses 'ShipCountry' instead of 'Country' from the 'customers' table. This changes the context from customers' countries to shipment countries and does not follow the same business logic as the reference implementation, which summarizes revenue by customers' countries.","```python
import plotly.express as px

# SQL query to fetch the top 5 countries generating the most revenue
sql_query = """"""
SELECT ShipCountry, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipCountry 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query and store the result in a DataFrame
countries_revenue_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 countries by revenue
fig = px.bar(
    countries_revenue_df, 
    x='ShipCountry', 
    y='TotalRevenue', 
    title='Top 5 Countries by Revenue from Orders',
    labels={'ShipCountry': 'Country', 'TotalRevenue': 'Total Revenue'},
    template='plotly'
)

# Display the bar chart to enhance understanding
show_to_user(fig)
```","The input code retrieves revenue based on 'ShipCountry' rather than 'customers.Country' as in the reference code. These fields might not be equivalent depending on the dataset's architecture. Additionally, the input does not join the 'customers' table, which may lead to different results. The logic in the SQL queries is not consistent with regard to join conditions and grouping.",None
How many orders were shipped by each shipping method? Please include a bar chart to visualize the distribution of orders across the different shipping methods.,"
```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS NumOrders 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipVia', y='NumOrders', title='Number of Orders Shipped by Each Method')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY ShipVia
""""""

# Execute the SQL query to get the data
shipping_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of orders across different shipping methods
fig = px.bar(shipping_data, x='ShipVia', y='OrderCount', 
             title='Distribution of Orders by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code includes a WHERE clause (""WHERE ShippedDate IS NOT NULL"") which filters out any orders that do not have a ShippedDate. The reference implementation does not have this filter, and thus considers all orders regardless of their ShippedDate status. This difference in logic leads to potentially different results. Therefore, the input code does not strictly adhere to the specified business analytics request as demonstrated in the reference implementation.","```python
import plotly.express as px

# SQL query to get the count of orders shipped by each shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount FROM orders GROUP BY ShipVia;
""""""

# Execute the SQL query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of orders across different shipping methods
fig = px.bar(orders_df, x='ShipVia', y='OrderCount', title='Distribution of Orders by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'})

# Display the bar chart to the user
show_to_user(fig)
```",The input code correctly addresses the business analytics request by querying the number of orders for each shipping method and visualizing it with a bar chart. The SQL query and the visualization setup are logically aligned with the reference implementation. The slight difference in variable names ('OrderCount' instead of 'NumOrders') does not affect the correctness as the logic and outcome remain the same.,Finetuned
"What is the effect of discount on product sales, and can a line graph be used to illustrate the relationship between discount percentage and sales volume?","```python
import plotly.express as px

# Assuming execute_sql_query and show_to_user are predefined utility functions.

# SQL query to execute
sql_query = """"""
SELECT Discount, SUM(Quantity) AS TotalSales 
FROM [Order Details] 
GROUP BY Discount 
ORDER BY Discount DESC;
""""""

# Execute the SQL query and obtain results in a DataFrame
df_sales = execute_sql_query(sql_query)

# Generate a line graph to illustrate the relationship between Discount and TotalSales
fig = px.line(df_sales, x='Discount', y='TotalSales', title='Effect of Discount on Product Sales', 
              labels={'Discount': 'Discount Percentage', 'TotalSales': 'Sales Volume'})

# Display the graph
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.Discount, 
    SUM(od.Quantity) AS SalesVolume 
FROM 
    [Order Details] od 
GROUP BY 
    od.Discount
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='Discount', y='SalesVolume', title='Effect of Discount on Product Sales')
show_to_user(fig)
```","Both the input and reference code perform similar operations: they execute a SQL query to group data by Discount, summing the Quantity as SalesVolume or TotalSales, and visualize the result with a line graph using Plotly. The input code does not specify ordering by Discount, but this does not affect correctness concerning illustrating the relationship. Thus, the input code adheres to the logic correctly for the intended analysis.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to the database and execute the given SQL query
    # For the purpose of this code snippet, it assumes a DataFrame is returned.
    pass

# Utility function to display data or visualization
def show_to_user(data):
    # This function should display the provided data or figure.
    pass

# SQL Query to fetch discount and sales data
sql_query = """"""
SELECT p.ProductName, AVG(od.Discount) * 100 AS DiscountPercentage, SUM(od.Quantity) AS TotalSalesVolume
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY DiscountPercentage;
""""""

# Execute the SQL query and get the result as a DataFrame
data_df = execute_sql_query(sql_query)

# Check if the data DataFrame is not empty
if not data_df.empty:
    # Create a line graph using Plotly
    fig = px.line(data_df, x='DiscountPercentage', y='TotalSalesVolume', 
                  title='Effect of Discount on Product Sales',
                  labels={'DiscountPercentage': 'Discount (%)', 'TotalSalesVolume': 'Total Sales Volume'},
                  markers=True)

    # Show the line graph to the user
    show_to_user(fig)
else:
    # Handle the case where no data is returned
    show_to_user(""No data available to show."")
```","The input code calculates the average discount per product and plots it against total sales volume, while the reference implementation calculates the total sales per discount level irrespective of product, and orders by discount. The logic differs as the input focuses on product-specific average discounts, not addressing the overall effect of discount levels on sales volume.",Base
"Which shipping method has the best on-time delivery rate, and how can this be shown through a comparative chart of on-time delivery rates for each method?","```python
import pandas as pd
import plotly.express as px

# Define given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Sample implementation for demonstration purposes
    # Connect to the database and execute the SQL query
    # return pd.read_sql_query(sql_query, database_connection)
    pass

def show_to_user(data):
    # Display data or Plotly figures
    # In real usage, it would handle actual data or figures
    print(data)

# SQL query from the business analytic request
sql_query = """"""
SELECT ShipVia, 100.0 * COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) AS OnTimeRate 
FROM orders 
GROUP BY ShipVia 
ORDER BY OnTimeRate DESC;
""""""

# Execute the SQL query and store the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a comparative chart for on-time delivery rates
fig = px.bar(df, x='ShipVia', y='OnTimeRate', title='On-Time Delivery Rate by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'OnTimeRate': 'On-Time Delivery Rate (%)'},
             hover_data={'OnTimeRate': ':.2f'})

# Show the comparative chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, 
       COUNT(OrderID) AS TotalOrders,
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeDeliveries,
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID)) * 100 AS OnTimeDeliveryRate
FROM orders
GROUP BY ShipVia
""""""

delivery_data = execute_sql_query(sql_query)

fig = px.bar(delivery_data, 
              x='ShipVia', 
              y='OnTimeDeliveryRate', 
              title='On-time Delivery Rate by Shipping Method',
              labels={'OnTimeDeliveryRate': 'On-time Delivery Rate (%)', 'ShipVia': 'Shipping Method'})

show_to_user(fig)
```","Both implementations correctly calculate the on-time delivery rate for each shipping method using the given SQL query logic. The input code calculates the on-time rate by explicitly listing the total orders and on-time deliveries, while the reference calculates it directly using a single SQL expression. Both result in the same comparative chart for on-time delivery rates per shipping method using Plotly, fulfilling the business analytics request.","
import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # The logic to interact with database and return DataFrame should be implemented here
    pass

# Function to show data analysis or visualization results to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch on-time delivery rates for each shipping method
sql_query = """"""
SELECT 
    ShipVia, 
    COUNT(OrderID) AS TotalOrders, 
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries, 
    CAST(SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS FLOAT) / COUNT(OrderID) * 100 AS OnTimeRate 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Create a comparative chart of on-time delivery rates
fig = px.bar(
    df,
    x='ShipVia',
    y='OnTimeRate',
    title='Comparative On-Time Delivery Rates by Shipping Method',
    labels={'ShipVia': 'Shipping Method', 'OnTimeRate': 'On-Time Delivery Rate (%)'},
    text='OnTimeRate'
)

# Display the chart
show_to_user(fig)
","The input code correctly addresses the business request by calculating each shipping method's on-time delivery rate using SQL and visualizing it with a bar chart. It computes the on-time delivery rate effectively by counting total orders and on-time deliveries, which aligns with the calculations in the reference code. Both implementations query the necessary data and illustrate the results in a comparative chart, maintaining the intended logic of comparing on-time delivery performance.",both
Which region has the highest total sales? Please include a bar chart to visualize the sales distribution across regions.,"```python
import plotly.express as px
import pandas as pd

# Assume execute_sql_query and show_to_user are defined as per constraints.

# SQL query to get total sales by region
sql_query = '''
SELECT Region, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Region 
ORDER BY TotalSales DESC;
'''

# Execute the SQL query and get the result as a DataFrame
sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales distribution across regions
fig = px.bar(sales_df, x='Region', y='TotalSales', title='Total Sales by Region', labels={'TotalSales': 'Total Sales', 'Region': 'Region'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
ORDER BY TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)

highest_region = sales_data.iloc[0]
fig = px.bar(sales_data, x='Region', y='TotalSales', title='Sales Distribution Across Regions')
show_to_user(fig)

highest_region
```","The input code correctly executes a SQL query to calculate total sales by region, similar to the reference implementation. It uses the same logic to calculate the total sales by multiplying unit price, quantity, and applying the discount. The results are ordered by total sales in descending order. A bar chart is created using Plotly to visualize the sales distribution across regions, and it is displayed to the user with 'show_to_user', fulfilling the business request. The addition of extracting 'highest_region' does not affect the correctness, as the task is primarily to visualize the sales distribution.","import pandas as pd
import plotly.express as px

# SQL query to get total sales by region
sql_query = """"""
    SELECT 
        customers.Region, 
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
    FROM 
        customers 
    JOIN 
        orders ON customers.CustomerID = orders.CustomerID 
    JOIN 
        [Order Details] ON orders.OrderID = [Order Details].OrderID 
    GROUP BY 
        customers.Region 
    ORDER BY 
        TotalSales DESC
""""""

# Execute the SQL query and store the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize sales distribution across regions
fig = px.bar(sales_data, x='Region', y='TotalSales', title='Total Sales by Region', labels={'TotalSales': 'Total Sales'})
  
# Display the bar chart
show_to_user(fig)","The provided input code performs the same operations as the reference implementation. It selects the same fields using an identical SQL query to calculate total sales by region, executes the query to get a DataFrame, creates a similar bar chart to visualize the data, and displays the chart. Differences, such as formatting or variable names, do not affect the logic or output. Therefore, the code meets the business analytics request and is correct.",both
"What is the correlation between order value and shipping delay, and can a scatter plot be used to illustrate this relationship?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
correlation_query = '''
SELECT 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) 
    AS OrderValue,
    DATEDIFF(day, orders.OrderDate, orders.ShippedDate) AS ShippingDelay
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY orders.OrderID;
'''

# Execute the SQL query to get data for correlation and scatter plot
order_data = execute_sql_query(correlation_query)

# Calculate correlation using pandas
correlation = order_data['OrderValue'].corr(order_data['ShippingDelay'])

# Display the correlation result to the user
show_to_user(pd.DataFrame({'OrderValueShippingDelayCorrelation': [correlation]}))

# Create a scatter plot using Plotly
fig = px.scatter(order_data, x='OrderValue', y='ShippingDelay', 
                 title='Scatter Plot of Order Value vs Shipping Delay',
                 labels={'OrderValue': 'Order Value', 'ShippingDelay': 'Shipping Delay (days)'})

# Show the scatter plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue,
    DATEDIFF(o.ShippedDate, o.OrderDate) AS ShippingDelay
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.OrderID
""""""

data = execute_sql_query(sql_query)

correlation = data['OrderValue'].corr(data['ShippingDelay'])

fig = px.scatter(data, x='OrderValue', y='ShippingDelay', title=f'Correlation: {correlation:.2f}', labels={'OrderValue': 'Order Value', 'ShippingDelay': 'Shipping Delay (days)'})
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It calculates the order value and shipping delay using a SQL query, computes the correlation between them using pandas, and then creates a scatter plot with Plotly. The correlation calculation and visualization are aligned with the reference code's purpose, despite some minor differences in plot title formatting.","
```python
import pandas as pd
import plotly.express as px

# SQL query to get correlation data
sql_query = """"""
    SELECT 
        o.OrderID, 
        SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS order_value, 
        DATEDIFF(o.ShippedDate, o.RequiredDate) AS shipping_delay 
    FROM 
        orders o 
        JOIN [Order Details] od ON o.OrderID = od.OrderID 
    GROUP BY 
        o.OrderID
""""""

# Execute the SQL query and fetch the data into a DataFrame
df = execute_sql_query(sql_query)

# Calculate the correlation
correlation = df['order_value'].corr(df['shipping_delay'])

# Display correlation result
show_to_user(pd.DataFrame({""correlation"": [correlation]}))

# Generate scatter plot to illustrate the relationship
fig = px.scatter(df, x='order_value', y='shipping_delay', 
                 labels={'order_value': 'Order Value', 'shipping_delay': 'Shipping Delay'},
                 title='Scatter plot of Order Value vs Shipping Delay')

# Show the plot to the user
show_to_user(fig)
```
","The input code calculates 'shipping_delay' as the difference between the 'ShippedDate' and 'RequiredDate', whereas the reference code calculates it as the difference between 'OrderDate' and 'ShippedDate'. These are different measures of delay, leading to potentially different correlation outcomes. While both codes plot a scatter plot and calculate correlation, the logic used in obtaining the shipping delay differs from the reference.",Base
Which city received the highest number of shipments? Please include a bar chart to compare the number of shipments across all cities.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve the number of shipments per city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) as NumberOfShipments 
FROM orders 
GROUP BY ShipCity;
""""""

# Execute the SQL query and store the result in a pandas DataFrame
shipments_data = execute_sql_query(sql_query)

# Sort the DataFrame to identify the city with the highest number of shipments
sorted_shipments_data = shipments_data.sort_values(by='NumberOfShipments', ascending=False)

# Plot a bar chart comparing the number of shipments across all cities
fig = px.bar(sorted_shipments_data, x='ShipCity', y='NumberOfShipments',
             title='Number of Shipments by City',
             labels={'ShipCity': 'City', 'NumberOfShipments': 'Shipments'})

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipCity
ORDER BY ShipmentCount DESC
""""""

shipment_data = execute_sql_query(sql_query)

highest_shipment_city = shipment_data.iloc[0]

fig = px.bar(shipment_data, x='ShipCity', y='ShipmentCount', title=""Number of Shipments by City"")
show_to_user(fig)

highest_shipment_city
```","The input Python code correctly answers the business analytics request. It retrieves the shipment data per city, sorts the data to find the city with the highest shipment count, and creates a bar chart using Plotly Express to compare shipments across all cities. The logic and intended outcome align with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the shipment counts for all cities
sql_query = """"""
SELECT ShipCity, COUNT(ShipCity) AS Shipments
FROM orders
GROUP BY ShipCity
ORDER BY Shipments DESC;
""""""

# Execute the SQL query to get the data
shipment_data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of shipments per city
fig = px.bar(shipment_data_df, x='ShipCity', y='Shipments',
             title='Number of Shipments by City',
             labels={'ShipCity':'City', 'Shipments':'Number of Shipments'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request by retrieving and sorting the shipment counts per city. The SQL query counts shipments grouped by 'ShipCity' and orders the results in descending order, which aligns with the reference implementation's logic of sorting cities by the number of shipments. The use of 'execute_sql_query' to get the data and 'px.bar' to plot the data is consistent with the reference. Therefore, the provided code adheres to the logic required for the task.",both
List employees who have been hired in the last 5 years and provide a bar chart of hiring trends by year.,"
import pandas as pd
import plotly.express as px

# SQL query to fetch employees hired in the last 5 years
sql_query = """"""
SELECT EmployeeID, FirstName, LastName, YEAR(HireDate) as HireYear FROM employees 
WHERE HireDate >= DATE_SUB(CURDATE(), INTERVAL 5 YEAR);
""""""

# Execute the SQL query and store the result in a DataFrame
df_employees = execute_sql_query(sql_query)

# Count the number of hires per year
hiring_trends = df_employees['HireYear'].value_counts().reset_index()
hiring_trends.columns = ['Year', 'Hires']
hiring_trends = hiring_trends.sort_values(by='Year')

# Create a bar chart using plotly
fig = px.bar(hiring_trends, x='Year', y='Hires', title='Hiring Trends in the Last 5 Years')

# Display the result
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate date 5 years ago from today
five_years_ago = datetime.now() - timedelta(days=5*365)

# SQL query to list employees hired in the last 5 years
sql_query_employees = f""""""
SELECT EmployeeID, FirstName, LastName, HireDate 
FROM employees 
WHERE HireDate >= '{five_years_ago.strftime('%Y-%m-%d')}';
""""""

employees_df = execute_sql_query(sql_query_employees)

# SQL query to get hiring trends by year
sql_query_hiring_trends = """"""
SELECT YEAR(HireDate) AS HireYear, COUNT(*) AS HireCount 
FROM employees 
GROUP BY HireYear 
ORDER BY HireYear;
""""""

hiring_trends_df = execute_sql_query(sql_query_hiring_trends)

# Creating the bar chart for hiring trends
fig = px.bar(hiring_trends_df, x='HireYear', y='HireCount', title='Hiring Trends by Year')
show_to_user(employees_df)
show_to_user(fig)
```","The input code does not directly reflect the reference implementation nor fully align with the business analytics request. The input code correctly lists employees hired in the last 5 years using a calculated date, aligning with the request. However, it uses a separate SQL query to fetch the hiring trends over all years, not limited to the last 5 years, which differs from the logic of the reference implementation. Additionally, the input code shows the employee list, which isn't part of the reference implementation.","
import pandas as pd
import plotly.express as px
from datetime import datetime

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    pass

# Utility function to show results to user
def show_to_user(data):
    # Placeholder for actual display logic
    pass

# SQL query to fetch employees hired in the last 5 years
sql_query = """"""
    SELECT EmployeeID, FirstName, LastName, HireDate
    FROM employees
    WHERE HireDate > DATEADD(YEAR, -5, CURRENT_DATE);
""""""

# Execute SQL query to get data
employees_df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not employees_df.empty:
    # Convert the 'HireDate' column to datetime
    employees_df['HireDate'] = pd.to_datetime(employees_df['HireDate'])

    # Extract the year from 'HireDate'
    employees_df['HireYear'] = employees_df['HireDate'].dt.year

    # Group by the extracted year and count the number of hires
    hiring_trends_df = employees_df.groupby('HireYear').size().reset_index(name='HireCount')

    # Create a bar chart using Plotly
    fig = px.bar(hiring_trends_df, x='HireYear', y='HireCount', 
                 title='Hiring Trends by Year',
                 labels={'HireYear': 'Year', 'HireCount': 'Number of Hires'})

    # Display the bar chart
    show_to_user(fig)
else:
    # Display a message if no data is available
    show_to_user('No employees hired in the last 5 years.')
","The input Python code correctly implements the business analytics request. It fetches employees hired in the last 5 years and provides a bar chart of hiring trends by year. The use of `DATEADD` function in the SQL query, conversion of 'HireDate' to datetime, extraction of year, and grouping operations are consistent with the reference implementation. Although the SQL function for date manipulation differs, it serves the same purpose. The input code also appropriately handles empty data scenarios.",Finetuned
"Which products are often paired together in orders, and can a visualization like a heat map or network graph be used to illustrate these pairings?","```python
import pandas as pd
import plotly.graph_objects as go

# Define the SQL query to find product pairings
sql_query = """"""
SELECT od1.ProductID, od2.ProductID, COUNT(*) AS PairCount
FROM [Order Details] od1
JOIN [Order Details] od2
ON od1.OrderID = od2.OrderID AND od1.ProductID < od2.ProductID
GROUP BY od1.ProductID, od2.ProductID
ORDER BY PairCount DESC
LIMIT 5;
""""""

# Execute the SQL query to retrieve data
pairing_data = execute_sql_query(sql_query)

# Prepare data for visualization
fig = go.Figure(data=go.Heatmap(
    z=pairing_data['PairCount'],
    x=pairing_data['ProductID'],
    y=pairing_data['ProductID'],
    colorscale='Viridis'
))

# Add title and labels
fig.update_layout(
    title='Top Product Pairings',
    xaxis_title='Product ID 1',
    yaxis_title='Product ID 2'
)

# Visualize the heat map using the custom show function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from itertools import combinations

# Step 1: Fetch order details data
sql_query = """"""
SELECT od.OrderID, od.ProductID
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
""""""
order_details_df = execute_sql_query(sql_query)

# Step 2: Find product pairings in each order
pairings = order_details_df.groupby('OrderID')['ProductID'].apply(lambda x: list(combinations(x, 2)))

# Step 3: Count pairings
pairings_list = [pair for sublist in pairings for pair in sublist]
pairings_df = pd.DataFrame(pairings_list, columns=['ProductA', 'ProductB'])
pairing_counts = pairings_df.value_counts().reset_index(name='Count')

# Step 4: Create a heatmap
heatmap_df = pairing_counts.pivot('ProductA', 'ProductB', 'Count').fillna(0)

# Step 5: Visualize with heat map
fig = px.imshow(heatmap_df, 
                labels=dict(x=""Product B"", y=""Product A"", color=""Count""), 
                x=heatmap_df.columns,
                y=heatmap_df.index,
                color_continuous_scale='Blues')

show_to_user(fig)
```","The input code correctly addresses the business analytics request by identifying products that are often paired together, similar to the reference implementation. Both implementations utilize SQL queries to get order details and find product pairings. The input code uses the itertools.combinations function to generate product pairs for each order and counts their occurrences, aligning with the logic of the reference solution. Furthermore, it creates a heatmap using Plotly Express to visualize the pairings, which is an appropriate method to illustrate these relationships as requested. The differences, such as using a different plotting library and slight variations in code, do not affect the correctness or logic of the solution.","```python
import pandas as pd
import plotly.express as px
import plotly.figure_factory as ff

# Define SQL query from business analytic request
sql_query = """"""
    SELECT od1.ProductID, od2.ProductID, COUNT(*) AS PairCount
    FROM [Order Details] od1
    JOIN [Order Details] od2
    ON od1.OrderID = od2.OrderID AND od1.ProductID <> od2.ProductID
    GROUP BY od1.ProductID, od2.ProductID;
""""""

# Function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the query and return the results as a DataFrame
    pass

def show_to_user(data):
    # This function should display the data analysis or visualization result
    pass

# Execute the SQL query to get product pairings
df_pairs = execute_sql_query(sql_query)

# Convert DataFrame to a pivot format for better visualization
df_pivot = df_pairs.pivot(index='ProductID', columns='ProductID', values='PairCount').fillna(0)

# Create a heatmap using Plotly
fig = ff.create_annotated_heatmap(
    z=df_pivot.values,
    x=df_pivot.columns.tolist(),
    y=df_pivot.index.tolist(),
    colorscale='Viridis'
)

# Update heatmap layout
fig.update_layout(
    title='Product Pairings Frequency',
    xaxis_title='Product ID',
    yaxis_title='Product ID',
)

# Show the heatmap to the user
show_to_user(fig)
```","The key difference in the SQL queries is the condition for the JOIN. The reference code uses 'od1.ProductID < od2.ProductID' to avoid duplicate and self-pairings, whereas the input code uses 'od1.ProductID <> od2.ProductID' which doesn't prevent the same product appearing as both pairs in reverse. Moreover, the input code doesn't apply the limit to the number of pairings returned, which might be needed based on the description in the reference code where only the top 5 are retained. Visualization differences are minimal and should not affect logic adherence.",Base
Identify employees who have been with the company for over 10 years and visualize the distribution of their years of service.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing SQL query
    # Simulate with mock DataFrame for the purpose of demonstration
    data = {
        'EmployeeID': [1, 2, 3, 4],
        'FirstName': ['John', 'Jane', 'Doe', 'Smith'],
        'LastName': ['Doe', 'Doe', 'Smith', 'Brown'],
        'HireDate': ['2012-01-10', '2008-05-15', '2005-07-20', '2010-11-30']
    }
    df = pd.DataFrame(data)
    df['HireDate'] = pd.to_datetime(df['HireDate'])
    return df

def show_to_user(data):
    # Placeholder to show data or plot
    print(data)

# Execute SQL query to get employees with over 10 years of service
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName FROM employees e 
WHERE DATEDIFF(CURRENT_DATE, e.HireDate) > 3650;
""""""
employees_df = execute_sql_query(sql_query)

# Calculate years of service
employees_df['YearsOfService'] = (pd.Timestamp.now() - employees_df['HireDate']).dt.days / 365.25

# Filter employees with over 10 years of service
employees_over_10_years = employees_df[employees_df['YearsOfService'] > 10]

# Visualize the distribution of years of service
fig = px.histogram(employees_over_10_years, x='YearsOfService', 
                   title='Distribution of Years of Service for Employees with Over 10 Years',
                   labels={'YearsOfService': 'Years of Service'},
                   nbins=10)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

sql_query = """"""
SELECT 
    EmployeeID,
    FirstName,
    LastName,
    DATEDIFF(CURDATE(), HireDate) / 365 AS YearsOfService
FROM 
    employees
WHERE 
    DATEDIFF(CURDATE(), HireDate) / 365 > 10
""""""

employees_data = execute_sql_query(sql_query)

fig = px.histogram(employees_data, x='YearsOfService', title='Distribution of Years of Service for Employees with Over 10 Years', 
                   labels={'YearsOfService': 'Years of Service'})
show_to_user(fig)
```","The input code incorrectly assumes the implementation of 'execute_sql_query' returns 'YearsOfService' directly from the SQL, without recalculating it in Python. The reference implementation recalculates 'YearsOfService' using current date and hire date after fetching all data, while the input code directly relies on the SQL calculation, assuming that the function returns all necessary fields and a correct 'YearsOfService'. This discrepancy affects validity depending on how 'execute_sql_query' functions in reality.","```python
import pandas as pd
import plotly.express as px

# Assume the following utility functions are already defined in your environment
def execute_sql_query(sql_query: str):
    # Logic to execute the SQL query and return a DataFrame
    pass

def show_to_user(data):
    # Logic to display the data or visualization
    pass

# SQL Query to fetch employees who have been with the company for over 10 years
sql_query = """"""
SELECT e.EmployeeID, e.HireDate, 
       DATEDIFF(CURRENT_DATE, e.HireDate)/365.25 as YearsAtCompany 
FROM employees e 
WHERE DATEDIFF(CURRENT_DATE, e.HireDate)/365.25 > 10;
""""""

# Execute the query and get the data as a DataFrame
df = execute_sql_query(sql_query)

# Visualize the distribution of years of service of employees who have been with the company for over 10 years
fig = px.histogram(df, x='YearsAtCompany', nbins=20, title='Distribution of Years of Service')

# Display the results
show_to_user(fig)
```","Both implementations aim to identify employees with over 10 years of service and visualize the distribution of their years at the company. The reference code calculates years of service using a separate calculation on the DataFrame, filtering those over 10 years before creating the histogram. The input code uses a SQL query to calculate years and filter directly in the database, then visualizes the results. While the approaches differ, they achieve the same outcome by focusing on employees with more than 10 years of service and visualizing the same metric.",Finetuned
"Which city has the highest number of shipments, and can you provide a bar chart to visualize the shipment counts across different cities?","```python
import pandas as pd
import plotly.express as px

# SQL query to get shipment counts across different cities
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount 
FROM orders 
GROUP BY ShipCity 
""""""

# Execute the SQL query using the provided utility function
shipment_data = execute_sql_query(sql_query)

# Find the city with the highest number of shipments
# This part is corrected to align with displaying a DataFrame directly
top_city = shipment_data.nlargest(1, 'ShipmentCount')

# Display the city with the highest shipments
show_to_user(top_city)

# Create a bar chart for shipment counts across different cities
fig = px.bar(shipment_data, x='ShipCity', y='ShipmentCount', title='Shipment Counts by City')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipCity
ORDER BY ShipmentCount DESC
""""""

shipment_data = execute_sql_query(sql_query)

highest_shipment_city = shipment_data.iloc[0]

fig = px.bar(shipment_data, x='ShipCity', y='ShipmentCount', title='Shipment Counts Across Different Cities')
show_to_user(fig)

highest_shipment_city
```","The input code correctly executes the SQL query to get shipment counts across different cities and sorts the results in descending order by shipment count to identify the city with the highest shipments. It retrieves the city with the highest number of shipments using `iloc[0]`, which is equivalent to using `nlargest(1, 'ShipmentCount')` in terms of finding the top city. A bar chart is created and displayed using Plotly, similar to the reference implementation. Both codes effectively satisfy the business analytics request and follow similar logic, despite differences in specific methods used to find the top city.","
```python
import plotly.express as px
import pandas as pd

# SQL query to fetch shipment counts per city
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentsCount FROM orders GROUP BY ShipCity ORDER BY ShipmentsCount DESC;
""""""

# Execute the SQL query and obtain the results in a DataFrame
df_shipments = execute_sql_query(sql_query)

# Find the city with the highest number of shipments
top_city = df_shipments.head(1)

# Display the city with the highest number of shipments
show_to_user(top_city)

# Create a bar chart to visualize shipment counts across different cities
fig_bar_chart = px.bar(df_shipments, x='ShipCity', y='ShipmentsCount', title='Shipment Counts by City')

# Show the bar chart using the provided utility function
show_to_user(fig_bar_chart)
```
","The input code correctly performs the required tasks similar to the reference code. It uses an SQL query to fetch shipment counts per city, sorts them in descending order, and retrieves the city with the highest shipment count using `head(1)`, which is equivalent to `nlargest(1, 'ShipmentCount')`. The bar chart is also correctly created and displayed. Both implementations meet the business analytics request.",both
"What is the highest discount given to a single product, and can you provide a visualization of the distribution of discounts for context?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the highest discount on a single product
sql_query_max_discount = '''
SELECT ProductName, [Order Details].Discount 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].Discount = (SELECT MAX(Discount) FROM [Order Details]) 
LIMIT 1;
'''

# SQL query to get all discounts for visualization
sql_query_all_discounts = '''
SELECT [Order Details].Discount 
FROM [Order Details];
'''

# Execute the queries
max_discount_df = execute_sql_query(sql_query_max_discount)
all_discounts_df = execute_sql_query(sql_query_all_discounts)

# Display the maximum discount information
show_to_user(max_discount_df)

# Visualize the distribution of discounts
fig = px.histogram(all_discounts_df, x=""Discount"", title=""Distribution of Discounts"", nbins=50)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve discount data
query = """"""
SELECT Discount
FROM [Order Details]
""""""
discounts_df = execute_sql_query(query)

# Step 2: Find the highest discount
highest_discount = discounts_df['Discount'].max()

# Step 3: Create a visualization for the distribution of discounts
fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts', nbins=30)

# Step 4: Show the results
show_to_user(pd.DataFrame({'Highest Discount': [highest_discount]}))
show_to_user(fig)
```","The input code does not retrieve and display the product name associated with the highest discount, unlike the reference code. It only computes the maximum discount and displays it without the associated product details.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch all discounts for analysis
sql_query_all_discounts = ""SELECT Discount FROM [Order Details];""

# Execute the SQL query to get all discounts data
all_discounts_df = execute_sql_query(sql_query_all_discounts)

# Calculate the maximum discount
max_discount_df = all_discounts_df.nlargest(1, 'Discount')
show_to_user(max_discount_df)

# Visualize the distribution of discounts
fig = px.histogram(all_discounts_df, x='Discount', title='Distribution of Discounts')
show_to_user(fig)
```","The input code does not ensure the maximum discount returned is associated with the correct product, unlike the reference code. The input code only retrieves discounts, while the reference code joins with the products table to provide product-specific context for the highest discount.",None
"How many orders did each employee process last quarter, and can we visualize this data in a bar chart to compare their performance easily?","
import pandas as pd
import plotly.express as px

# Example SQL query function (to be provided in the actual environment)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function will execute the given SQL query and return a pandas DataFrame.
    # Placeholder for actual query execution logic
    pass  

# Example function to display data (to be provided in the actual environment)
def show_to_user(data):
    # This function will show the data to the user.
    # Placeholder for actual display logic
    pass

# SQL query to get the number of orders each employee processed last quarter
sql_query = """"""
SELECT e.EmployeeID, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH) AND CURRENT_DATE
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create the bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Number of Orders Processed by Each Employee Last Quarter', labels={'OrderCount': 'Number of Orders', 'EmployeeID': 'Employee ID'})

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the first and last date of last quarter
today = datetime.now()
first_day_of_quarter = ((today.month - 1) // 3) * 3 + 1
last_quarter_start = datetime(today.year, first_day_of_quarter - 3, 1)
last_quarter_end = (last_quarter_start + timedelta(days=89)).replace(day=1) - timedelta(days=1)

# SQL query to get order counts by employee for the last quarter
sql_query = f""""""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{last_quarter_start.date()}' AND '{last_quarter_end.date()}'
GROUP BY e.EmployeeID
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query
employee_orders = execute_sql_query(sql_query)

# Visualize the data
fig = px.bar(employee_orders, x='EmployeeName', y='OrderCount', title='Orders Processed by Employee Last Quarter',
             labels={'OrderCount': 'Number of Orders', 'EmployeeName': 'Employee'}, color='OrderCount', 
             text='OrderCount')
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(yaxis=dict(title='Number of Orders'), xaxis=dict(title='Employee'), showlegend=False)

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly calculates the start and end dates of the last quarter and executes a SQL query to obtain the number of orders each employee processed. It includes the employee's full name and sorts the results by order count in descending order, which does not affect the correctness. The visualization is made using Plotly with enhancements for clarity. Both codes adhere to the same logic of retrieving and displaying the order counts by employee for the last quarter.","```python
import pandas as pd
import plotly.express as px

# Assuming the utility function execute_sql_query is defined as:
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation for executing the SQL and returning a DataFrame.
    # A placeholder for actual database interaction logic.
    pass

def show_to_user(data):
    # Assuming this function displays a DataFrame or Plotly figure.
    pass

# Define the SQL query based on the business request
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
WHERE OrderDate BETWEEN '2023-07-01' AND '2023-09-30' 
GROUP BY EmployeeID;
""""""

# Execute the SQL query to get the data
orders_data = execute_sql_query(sql_query)

# Check the result of the query
print(orders_data)

# Create a bar chart to visualize the number of orders processed by each employee
fig = px.bar(orders_data, x='EmployeeID', y='NumberOfOrders',
             title='Number of Orders Processed by Each Employee Last Quarter',
             labels={'NumberOfOrders':'Number of Orders', 'EmployeeID':'Employee ID'})

# Display the figure using the utility function
show_to_user(fig)
```","The given code uses specific dates ('2023-07-01' to '2023-09-30') for the last quarter, which may not be dynamic. The reference code correctly uses CURRENT_DATE and calculates the time dynamically. Additionally, the input code doesn't include an employee-join to ensure orders are linked to employees in the SQL query.",Base
How many orders are pending shipment as of today? Can you include a bar chart showing the number of pending shipments over the past week?,"```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Given function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should interact with a database and return a DataFrame
    pass

# Given function to display results
def show_to_user(data):
    # This function should handle displaying data or figures
    pass

# SQL query to find the total number of pending shipments as of today
query_today = """"""
SELECT COUNT(OrderID) AS PendingOrders 
FROM orders 
WHERE ShippedDate IS NULL;
""""""

# Execute SQL query to get the number of pending orders today
pending_orders_today_df = execute_sql_query(query_today)
show_to_user(pending_orders_today_df)

# SQL query to get the number of pending shipments over the past week
query_past_week = """"""
SELECT CAST(OrderDate AS DATE) AS OrderDate, COUNT(OrderID) AS PendingOrders
FROM orders
WHERE ShippedDate IS NULL AND OrderDate >= CURDATE() - INTERVAL 7 DAY
GROUP BY CAST(OrderDate AS DATE);
""""""

# Execute SQL query to get pending shipments data for the past week
pending_orders_week_df = execute_sql_query(query_past_week)

# Create a bar chart to display the number of pending shipments over the past week
fig = px.bar(pending_orders_week_df, x='OrderDate', y='PendingOrders', 
             title='Pending Shipments Over the Past Week',
             labels={'PendingOrders': 'Number of Pending Shipments', 'OrderDate': 'Order Date'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Get today's date
today = datetime.now().date()

# SQL query to get the number of pending shipments
sql_query_pending = """"""
SELECT COUNT(OrderID) AS PendingShipments
FROM orders
WHERE ShippedDate IS NULL
""""""
pending_shipments_df = execute_sql_query(sql_query_pending)

# Get the start of the week (7 days ago)
start_date = today - timedelta(days=7)

# SQL query to get the number of pending shipments for the past week
sql_query_weekly = f""""""
SELECT DATE(OrderDate) AS OrderDate, COUNT(OrderID) AS PendingCount
FROM orders
WHERE ShippedDate IS NULL AND OrderDate >= '{start_date}'
GROUP BY DATE(OrderDate)
ORDER BY OrderDate
""""""
weekly_pending_df = execute_sql_query(sql_query_weekly)

# Create a bar chart
fig = px.bar(weekly_pending_df, x='OrderDate', y='PendingCount', title='Pending Shipments Over the Past Week')

# Show results to the user
show_to_user(pending_shipments_df)
show_to_user(fig)
```","The input code correctly calculates the number of pending shipments today and visualizes pending shipments over the past week. It queries for pending shipments today using a simple SQL COUNT with 'ShippedDate IS NULL', similar to the reference. It also queries pending shipments over the past week by filtering on 'OrderDate >= start_date' and grouping by date, which aligns with the logic in the reference. Both implementations use a bar chart to visualize weekly pending shipments and utilize functions to execute SQL queries and display results. Overall, the logic and outcome align with the reference implementation.","```python
import pandas as pd
import matplotlib.pyplot as plt

# Utility function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would interface with your SQL database and return the results as a DataFrame
    # Placeholder function body (implement the actual database connection and query execution)
    pass

# Utility function to display results
def show_to_user(data):
    # This function would handle the display of data
    pass

# SQL Query to get the count of pending shipments
sql_query_count = ""SELECT COUNT(OrderID) FROM orders WHERE ShippedDate IS NULL;""
pending_shipments_df = execute_sql_query(sql_query_count)

# Display the number of pending shipments
show_to_user(pending_shipments_df)

# SQL Query to get pending shipments over the past week
sql_query_week = """"""
SELECT 
    OrderDate, 
    COUNT(OrderID) as PendingOrders 
FROM 
    orders 
WHERE 
    ShippedDate IS NULL 
    AND OrderDate >= CURDATE() - INTERVAL 7 DAY 
GROUP BY 
    OrderDate;
""""""

pending_shipments_week_df = execute_sql_query(sql_query_week)

# Create a bar chart for pending shipments over the past week
plt.figure(figsize=(10, 6))
plt.bar(
    pending_shipments_week_df['OrderDate'], 
    pending_shipments_week_df['PendingOrders'], 
    color='skyblue'
)
plt.title('Pending Shipments Over the Past Week')
plt.xlabel('Order Date')
plt.ylabel('Number of Pending Orders')
plt.xticks(rotation=45)
plt.tight_layout()

# Show the bar chart to the user
show_to_user(plt)
```","The provided code does not correctly answer the business analytics request. There are a few issues: (1) The input code uses 'OrderDate' directly in the output, while the reference code uses 'CAST(OrderDate AS DATE)'. This may lead to discrepancies if 'OrderDate' includes time. (2) The input code uses matplotlib for visualization, which is acceptable, but the result is passed as 'plt' directly to the show_to_user(), which likely does not display the plot as intended. It should display 'plt.show()' or deliver the figure object. (3) Variable names differ slightly (e.g., 'PendingOrders'). While not an error, consistent naming improves clarity. The input code needs modifications to fully match the logic and operational intent of the reference implementation.",Base
Determine the impact of discontinued products on total inventory and create a data visualization to illustrate the changes over time.,"```python
import pandas as pd
import plotly.express as px

def analyze_discontinued_products():
    # Define SQL query to get sum of UnitsInStock for discontinued products over time
    sql_query = """"""
    SELECT Date, SUM(UnitsInStock) as TotalDiscontinuedStock
    FROM products
    WHERE Discontinued = 1
    GROUP BY Date
    ORDER BY Date;
    """"""
    
    # Execute the SQL query to get the data as a DataFrame
    discontinued_data = execute_sql_query(sql_query)
    
    # Create a line plot to visualize the changes in discontinued products' inventory over time
    fig = px.line(
        discontinued_data,
        x='Date',
        y='TotalDiscontinuedStock',
        title='Impact of Discontinued Products on Total Inventory Over Time',
        labels={'TotalDiscontinuedStock': 'Total Units in Stock', 'Date': 'Date'}
    )
    
    # Display the visualization to the user
    show_to_user(fig)

# Call the function to execute the analysis
analyze_discontinued_products()```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve inventory data before and after discontinuation
sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(CASE WHEN p.Discontinued = 1 THEN od.Quantity ELSE 0 END) AS Discontinued_Products_Sold,
    SUM(CASE WHEN p.Discontinued = 0 THEN od.Quantity ELSE 0 END) AS Active_Products_Sold,
    SUM(p.UnitsInStock) AS Total_Units_In_Stock
FROM 
    ""Order Details"" od
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

data = execute_sql_query(sql_query)

# Create visualization
fig = px.line(data, x='Month', y=['Discontinued_Products_Sold', 'Active_Products_Sold', 'Total_Units_In_Stock'],
              title='Impact of Discontinued Products on Total Inventory Over Time',
              labels={'value': 'Quantity', 'variable': 'Product Status'})
show_to_user(fig)
```","The input code is not addressing the business analytics request correctly. The primary task is to evaluate the impact of discontinued products on total inventory by calculating the units in stock over time. The reference code does this using a SQL query that groups data by date and sums the 'UnitsInStock' for discontinued products specifically. However, the input code is calculating and plotting the quantity of sold products (both discontinued and active) and total stock over time without isolating the units in stock for discontinued products. This differs from the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Business Analytic Query to be executed
sql_query = """"""
SELECT 
    YEAR(OrderDate) AS Year,
    SUM(UnitPrice * Quantity) AS TotalSales,
    SUM(ProductInventory) AS TotalInventoryImpact
FROM 
    MDDX.dbo.OrderDetails od 
JOIN 
    MDDX.dbo.Products p ON od.ProductID = p.ProductID
WHERE 
    p.Discontinued = 1
GROUP BY 
    YEAR(OrderDate);
""""""

# Execute the SQL query and get the result set as a DataFrame
data = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not data.empty:
    # Create data visualization using Plotly
    fig = px.line(
        data, 
        x='Year', 
        y=['TotalSales', 'TotalInventoryImpact'], 
        labels={'value':'Amount', 'variable':'Metric'},
        title='Impact of Discontinued Products on Total Inventory and Sales Over Time'
    )
    
    # Show the visualization to the user
    show_to_user(fig)
else:
    # Notify the user that the data is not available or empty
    show_to_user('No data available for discontinued products impact analysis.')
```","The provided input code differs from the reference implementation in the following ways: 1) It aggregates data by year and sums 'TotalSales' and 'TotalInventoryImpact', whereas the reference focuses solely on 'UnitsInStock' over time for discontinued products. 2) The input code uses a JOIN with 'OrderDetails', which alters the scope from inventory to sales, not requested in the analytics task. 3) It visualizes both sales and inventory impact together, unlike the reference, which only analyzes and visualizes discontinued stock over time.",None
"  
""Calculate the total order quantity for each product over the past year and present the results using a bar chart.","```python
import pandas as pd
import plotly.express as px

# SQL Query to calculate the total order quantity for each product over the past year
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS AnnualOrderQuantity 
FROM [Order Details] 
WHERE EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) - 1 
GROUP BY ProductID;
""""""

# Execute the SQL query and get the data into a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation placeholder: This should connect to your database and execute the query
    pass


def show_to_user(data):
    # Implementation placeholder: This should display DataFrame or Plotly figure
    pass

# Fetch data from the database
order_data = execute_sql_query(sql_query)

# Generate bar chart using Plotly
fig = px.bar(order_data, x='ProductID', y='AnnualOrderQuantity', 
             title='Total Order Quantity for Each Product Over the Past Year',
             labels={'AnnualOrderQuantity': 'Total Quantity', 'ProductID': 'Product ID'})

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the past year
end_date = datetime.now()
start_date = end_date - timedelta(days=365)

# SQL query to fetch total order quantity for each product over the past year
sql_query = f""""""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (
    SELECT OrderID
    FROM Orders
    WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
)
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ProductName', y='TotalQuantity', title='Total Order Quantity for Each Product Over the Past Year', labels={'TotalQuantity': 'Total Quantity', 'ProductName': 'Product Name'})

# Show the result to the user
show_to_user(fig)
```","The evaluated code calculates the order totals within the exact last 365 days rather than for the complete last calendar year, as the reference code does. It also includes 'ProductName' and sorts the results, which are not in the reference implementation. Thus, it doesn't strictly adhere to the specified logic of the reference code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE od.OrderDate >= DATEADD(year, -1, CURRENT_DATE)
GROUP BY p.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Total Order Quantity for Each Product Over the Past Year')

# Display the bar chart to the user
show_to_user(fig)
```","The input code filters orders from the current date minus one year, rather than specifically targeting the previous calendar year as the reference code does. This means it could include orders from the current year if run anytime except January 1st. Additionally, it uses 'ProductName' instead of 'ProductID', which may not directly match the intended logic outlined in the reference implementation.",None
How many different shipping methods have been used to ship orders? Include a bar chart to visualize the frequency of each shipping method.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch all shipping methods
sql_query = ""SELECT ShipVia FROM orders;""

# Execute the SQL query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Count the frequency of each shipping method
shipping_methods_count = orders_df['ShipVia'].value_counts().reset_index()
shipping_methods_count.columns = ['ShippingMethod', 'Frequency']

# Create a bar chart using Plotly
fig = px.bar(shipping_methods_count, x='ShippingMethod', y='Frequency',
             title='Frequency of Each Shipping Method',
             labels={'ShippingMethod': 'Shipping Method', 'Frequency': 'Frequency'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT ShipVia, COUNT(*) AS Frequency FROM orders GROUP BY ShipVia""
shipping_methods_df = execute_sql_query(sql_query)

fig = px.bar(shipping_methods_df, x='ShipVia', y='Frequency', title='Frequency of Shipping Methods')
show_to_user(fig)
```","The input code correctly queries and counts the frequency of each shipping method using SQL, similar to the reference. It then uses Plotly to create a bar chart, meeting the business request of visualizing the frequencies of shipping methods.","```python
import plotly.express as px
import pandas as pd

# Execute the SQL query to get the shipping methods and their counts
shipping_methods_query = """"""
SELECT ShipVia, COUNT(*) AS num_orders
FROM orders
GROUP BY ShipVia
ORDER BY num_orders DESC;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation, you should replace this with actual SQL execution logic
    # Example: pd.read_sql_query(sql_query, your_database_connection)
    pass

# Execute the query to get the data
shipping_methods_df = execute_sql_query(shipping_methods_query)

# Create a bar chart to visualize the frequency of each shipping method
fig = px.bar(shipping_methods_df, x='ShipVia', y='num_orders', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'num_orders': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly determines the number of different shipping methods and their frequencies by using a SQL query that groups and counts orders by 'ShipVia'. It creates a bar chart showing the frequencies, similar to the reference implementation. The only difference is the use of SQL aggregation instead of Python's value_counts, but both achieve the same result.",both
"What is the monthly growth rate of returning customers over the last year, and can you provide a line chart to visualize the trend?","
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for executing the SQL query
    # Replace with actual implementation as needed
    return pd.DataFrame()

def show_to_user(data):
    # Placeholder function for displaying the data or visualization
    # Replace with actual implementation if needed
    pass

# SQL query to get the monthly growth of returning customers
sql_query = """"""
WITH monthly_customers_2022 AS (
    SELECT DATE_TRUNC('month', OrderDate) as month, CustomerID
    FROM orders
    WHERE YEAR(OrderDate) = 2022
),
monthly_customers_2021 AS (
    SELECT DATE_TRUNC('month', OrderDate) as month, CustomerID
    FROM orders
    WHERE YEAR(OrderDate) = 2021
)
SELECT 
    mc2022.month,
    ((COUNT(mc2022.CustomerID) - 
      COUNT(mc2021.CustomerID)) /
     NULLIF(COUNT(mc2021.CustomerID), 0)) * 100 
    AS monthly_growth
FROM 
    monthly_customers_2022 mc2022
LEFT JOIN 
    monthly_customers_2021 mc2021
ON 
    mc2022.CustomerID = mc2021.CustomerID
    AND mc2022.month = mc2021.month
GROUP BY 
    mc2022.month
ORDER BY 
    mc2022.month;
""""""

# Execute the query and get the result as a DataFrame
growth_df = execute_sql_query(sql_query)

# Generate a line chart for the monthly growth trend
fig = px.line(growth_df, x='month', y='monthly_growth', title='Monthly Growth Rate of Returning Customers in 2022')

# Display the plot
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the monthly count of returning customers
sql_query = """"""
WITH monthly_returning_customers AS (
    SELECT
        DATE_TRUNC('month', orders.OrderDate) AS month,
        COUNT(DISTINCT orders.CustomerID) AS returning_customers
    FROM orders
    WHERE orders.CustomerID IN (
        SELECT DISTINCT CustomerID
        FROM orders
        WHERE OrderDate < NOW() - INTERVAL '1 year'
    )
    AND orders.OrderDate >= NOW() - INTERVAL '1 year'
    GROUP BY month
)
SELECT month, returning_customers,
       LAG(returning_customers) OVER (ORDER BY month) AS previous_month
FROM monthly_returning_customers
ORDER BY month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Calculate monthly growth rate
data['growth_rate'] = (data['returning_customers'] - data['previous_month']) / data['previous_month'] * 100
data = data.dropna()  # Drop any rows with NaN values (the first month will have NaN)

# Create the line chart
fig = px.line(data, x='month', y='growth_rate', title='Monthly Growth Rate of Returning Customers',
              labels={'month': 'Month', 'growth_rate': 'Growth Rate (%)'})

# Show the figure to the user
show_to_user(fig)
```","The reference implementation compares customer counts between 2022 and 2021 to calculate growth rate, while the input code calculates growth based on the count of returning customers month over month for the last year using LAG. These approaches differ fundamentally. The input code does not align with the reference's intent of comparing returning customers year-over-year by month.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM OrderDate) AS month, 
    COUNT(DISTINCT CustomerID) AS returning_customers 
FROM 
    orders 
WHERE 
    EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) - 1 
    AND 
    CustomerID IN (
        SELECT 
            DISTINCT CustomerID 
        FROM 
            orders 
        WHERE 
            OrderDate < DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '1 year'
    ) 
GROUP BY month 
ORDER BY month;
""""""

# Execute the SQL query to get the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assuming function is implemented elsewhere to execute and return DataFrame
    pass

# Analyze the data
def analyze_data():
    df = execute_sql_query(sql_query)
    
    # Calculate the monthly growth rate
    df['monthly_growth_rate'] = df['returning_customers'].pct_change() * 100
    
    # Visualize the trend using a line chart
    fig = px.line(df, x='month', y='monthly_growth_rate', title='Monthly Growth Rate of Returning Customers')
    
    # Show the visualization to the user
    def show_to_user(data):
        # Assuming function is implemented elsewhere to display
        pass

    show_to_user(fig)

analyze_data()
```","The input code calculates the growth rate using the percentage change method, comparing each month with the previous month, while the reference implementation calculates the growth by comparing the same month of consecutive years. Additionally, the SQL in the input selects customers who returned for the first time, not matching the logic of the reference code.",None
Find out the average discount given for each customer and visualize the results with a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT 
    customers.CustomerID, 
    AVG([Order Details].Discount) AS AverageDiscount 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CustomerID', y='AverageDiscount', title='Average Discount per Customer')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the average discount for each customer
sql_query = """"""
SELECT 
    customers.CustomerID,
    customers.CompanyName,
    AVG([Order Details].Discount) AS AverageDiscount
FROM 
    customers
JOIN 
    orders ON customers.CustomerID = orders.CustomerID
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    customers.CustomerID, customers.CompanyName
""""""

# Execute the SQL query
average_discount_df = execute_sql_query(sql_query)

# Visualize the results with a bar chart
fig = px.bar(average_discount_df, 
             x='CompanyName', 
             y='AverageDiscount', 
             title='Average Discount Given for Each Customer', 
             labels={'AverageDiscount': 'Average Discount', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The input code correctly computes the average discount per customer and visualizes it with a bar chart, adhering to the business request. It extends the reference implementation by including 'CompanyName' for more informative labeling, but the primary logic of computing the average discount for each customer remains consistent with the reference.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user functions are already defined

# SQL query to find the average discount given for each customer
sql_query = """"""
SELECT c.CustomerID, AVG(od.Discount) AS AverageDiscount
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average discount per customer
fig = px.bar(df, x='CustomerID', y='AverageDiscount', 
             title='Average Discount per Customer',
             labels={'CustomerID': 'Customer ID', 'AverageDiscount': 'Average Discount'},
             template='plotly')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code accurately follows the logic of the reference code. It executes the SQL query to compute the average discount per customer with correct JOIN operations and grouping, similar to the reference code. Additionally, it uses Plotly to create a bar chart with the average discounts as required. Differences in variable naming or additional parameters in the plot (such as labels or template) do not alter the core functionality, which matches the reference implementation.",both
Find the total sales for each employee in a specific region and create a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# Assuming the function execute_sql_query and show_to_user are already defined as part of the environment.
# Execute the SQL query for a specific region
def analyze_sales_by_employee(region):
    sql_query = f""""""
    SELECT employees.EmployeeID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
    FROM employees 
    JOIN orders ON employees.EmployeeID = orders.EmployeeID 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    WHERE orders.ShipRegion = '{region}' 
    GROUP BY employees.EmployeeID;
    """"""
    
    # Get the data as a DataFrame
    sales_data_df = execute_sql_query(sql_query)
    
    # Create a bar chart using Plotly
    fig = px.bar(sales_data_df, x='EmployeeID', y='TotalSales', 
                 title=f'Total Sales by Employee in {region}', 
                 labels={'TotalSales': 'Total Sales ($)', 'EmployeeID': 'Employee ID'})
    
    # Display the plot
    show_to_user(fig)

# Example usage:
# analyze_sales_by_employee(""North America"")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE e.Region = 'SpecificRegion'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

total_sales_df = execute_sql_query(sql_query)

fig = px.bar(total_sales_df, x='FirstName', y='TotalSales', text='TotalSales', title='Total Sales by Employee in Specific Region')
show_to_user(fig)
```","The input code incorrectly uses the employee's 'Region' instead of the order's 'ShipRegion' to filter by region, which doesn't match the business request or reference logic. It also includes first and last name in the grouping, which isn't requested in the business analytics. The bar chart uses 'FirstName' instead of 'EmployeeID' for the x-axis, diverging from the reference implementation that uses 'EmployeeID'.","```python
import plotly.express as px
import pandas as pd

# SQL query as provided
sql_query = """"""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.ShipRegion = 'specific_region' 
GROUP BY e.EmployeeID
""""""

# Execute the SQL query and get the results in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales',
             title='Total Sales by Employee in Specific Region',
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales'},
             template='plotly')

# Display the bar chart
show_to_user(fig)
```","The input code uses a hardcoded string 'specific_region' instead of allowing the region to be dynamically specified by a function parameter like in the reference code. This makes it inflexible and incorrect as per the business request, which specifies finding sales for an employee in a specific (but dynamic) region.",None
Which supplier supplies the most number of different products? Include a bar chart to visualize the number of different products supplied by each supplier.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve supplier data
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(DISTINCT p.ProductID) AS NumberOfProducts 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
GROUP BY s.SupplierID 
ORDER BY NumberOfProducts DESC;
""""""

# Utility function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution code
    # e.g., using a connection to a database to execute the query and fetch results as a DataFrame
    pass

# Fetch data using the execute_sql_query utility function
supplier_data = execute_sql_query(sql_query)

# Use Plotly to create a bar chart
fig = px.bar(
    supplier_data, 
    x='CompanyName', 
    y='NumberOfProducts', 
    title='Number of Different Products Supplied by Each Supplier',
    labels={'NumberOfProducts': 'Number of Products', 'CompanyName': 'Supplier'},
    height=400
)

# Display the result using the show_to_user utility function
def show_to_user(data):
    # Placeholder for displaying data or visualization
    # This function would utilize Plotly's show mechanism to render graphs
    pass

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of different products supplied by each supplier
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY ProductCount DESC
""""""

# Execute SQL query
supplier_product_counts = execute_sql_query(sql_query)

# Visualization: Bar chart of suppliers and their product counts
fig = px.bar(supplier_product_counts, x='CompanyName', y='ProductCount',
             title='Number of Different Products Supplied by Each Supplier',
             labels={'CompanyName': 'Supplier', 'ProductCount': 'Number of Products'},
             text='ProductCount')
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(yaxis_title='Number of Products', xaxis_title='Suppliers')

# Show visualization
show_to_user(fig)
```","The input code uses COUNT(p.ProductID) instead of COUNT(DISTINCT p.ProductID), which does not give the count of different products. The reference code uses COUNT(DISTINCT p.ProductID) to correctly count different products by each supplier. This logic difference impacts the business question accuracy.","```python
import plotly.express as px
import pandas as pd

# SQL query to execute
sql_query = """"""
SELECT 
    s.CompanyName, 
    COUNT(DISTINCT p.ProductID) AS ProductCount 
FROM 
    products p 
JOIN 
    suppliers s 
ON 
    p.SupplierID = s.SupplierID 
GROUP BY 
    s.CompanyName;
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of different products supplied by each supplier
fig = px.bar(df, x='CompanyName', y='ProductCount', title='Number of Different Products Supplied by Each Supplier')

# Show the bar chart to the user
show_to_user(fig)
```","Both implementations correctly answer the business analytics request. They execute a SQL query that counts distinct products for each supplier, grouped by supplier name. Both code snippets use Plotly to visualize this data in a bar chart. The query logic matches, and the visualization goals align with the request, even though there are minor differences in the SQL query attributes and implementation details.",Finetuned
Find the employee with the longest tenure at the company and create a bar chart showing the tenure of all employees for comparison.,"```python
import pandas as pd
import plotly.express as px

# Sample SQL query to get employee tenures
sql_query = """"""
SELECT FirstName, LastName, DATEDIFF(NOW(), HireDate) AS Tenure FROM employees;
""""""

# Execute SQL query and obtain the DataFrame
employee_df = execute_sql_query(sql_query)

# Sort the DataFrame by tenure to determine the employee with the longest tenure
employee_df = employee_df.sort_values(by='Tenure', ascending=False)

# Get the employee with the longest tenure
longest_tenure_employee = employee_df.iloc[0]

# Create a bar chart for the tenure of all employees
fig = px.bar(employee_df, x='FirstName', y='Tenure', text='Tenure', title='Employee Tenure Comparison')
fig.update_traces(texttemplate='%{text}', textposition='outside')

# Display the results using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to retrieve employee tenure
sql_query = """"""
SELECT EmployeeID, FirstName, LastName, DATEDIFF(CURDATE(), HireDate) AS Tenure
FROM employees
ORDER BY Tenure DESC
""""""

# Execute SQL query
tenure_df = execute_sql_query(sql_query)

# Find the employee with the longest tenure
longest_tenure_employee = tenure_df.iloc[0]

# Bar chart to show tenure of all employees
fig = px.bar(tenure_df, x='EmployeeID', y='Tenure', 
             title='Tenure of All Employees', 
             labels={'EmployeeID': 'Employee ID', 'Tenure': 'Tenure (days)'})

# Display the results
show_to_user(fig)

longest_tenure_employee
```","The input code retrieves employee tenure in days and orders them by tenure, similar to the reference code. It identifies the employee with the longest tenure by selecting the first row after sorting. It also uses Plotly to create a bar chart showing the tenure of all employees. Although the chart is slightly different in styling and x-labels, the logic and outcome align with the reference. Therefore, the input code is considered correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to find all employees' start dates
sql_query_all_employees = """"""
SELECT EmployeeID, HireDate FROM employees;
""""""

# Execute the SQL query to retrieve all records
employees_df = execute_sql_query(sql_query_all_employees)

# Calculate tenure in years for each employee
employees_df['HireDate'] = pd.to_datetime(employees_df['HireDate'])
current_date = pd.to_datetime('today')
employees_df['TenureYears'] = (current_date - employees_df['HireDate']).dt.days // 365

# Find the employee with the longest tenure
longest_tenure_employee = employees_df.loc[employees_df['TenureYears'].idxmax()]

# Output the employee with the longest tenure
show_to_user(longest_tenure_employee)

# Create a bar chart of tenure for all employees
fig = px.bar(employees_df, x='EmployeeID', y='TenureYears', 
             title='Employee Tenure Comparison',
             labels={'TenureYears': 'Years of Tenure', 'EmployeeID': 'Employee ID'})

# Show bar chart to the user
show_to_user(fig)
```","The input code calculates tenure in years using integer division by 365, which can introduce inaccuracies since it doesn't account for exact annual conversion. The reference correctly uses DATEDIFF, yielding precise day differences. Additionally, the input uses 'EmployeeID' for bar chart labels, differing from 'FirstName' in the reference, impacting clarity. Despite showing tenure, the logic doesn't exactly match due to these points.",Base
What is the total freight cost by region with a visual representation such as a bar chart or map to enhance understanding?,"```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for database query execution
    # Replace with actual implementation
    pass

def show_to_user(data):
    # Placeholder function to display data or visualization
    # Replace with actual implementation
    pass

# SQL query to fetch the total freight cost by region
sql_query = '''
SELECT o.ShipRegion, SUM(o.Freight) AS TotalFreight
FROM orders o
GROUP BY o.ShipRegion;
'''

# Execute SQL query and get the data in a DataFrame
freight_data = execute_sql_query(sql_query)

# Create a bar chart for total freight cost by region
fig = px.bar(freight_data, x='ShipRegion', y='TotalFreight', title='Total Freight Cost by Region')

# Show the plot using the custom show_to_user function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, SUM(o.Freight) AS TotalFreight
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.Region
""""""

freight_by_region = execute_sql_query(sql_query)

fig = px.bar(freight_by_region, x='Region', y='TotalFreight',
             title='Total Freight Cost by Region',
             labels={'TotalFreight': 'Total Freight Cost', 'Region': 'Region'})

show_to_user(fig)
```","The input code uses a different SQL query compared to the reference. It queries freight costs by joining customers and orders tables on CustomerID and groups by Region from the customers table, whereas the reference code directly groups by ShipRegion from the orders table. This mismatch in logic could lead to different results, especially if the values or names of ShipRegion and Region differ. Additionally, it requires both tables to have consistent data regarding regions, which is an assumption not verified by the reference code.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: in practice, this should execute the SQL query and return the results as a DataFrame
    pass

def show_to_user(data):
    # Placeholder function: in practice, this shows the data or visualizations to the user
    pass

# SQL query to execute
sql_query = """"""
SELECT ShipRegion, SUM(Freight) AS TotalFreight FROM orders GROUP BY ShipRegion;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total freight cost by region
fig = px.bar(df, x='ShipRegion', y='TotalFreight', title='Total Freight Cost by Region')

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly implements the business analytics request, matching the logic of the reference implementation. It executes the SQL query to obtain total freight cost by region, uses Plotly Express to create a bar chart, and displays it using the 'show_to_user' function. The structure and logic align with the reference code.",Finetuned
What is the average unit price of products supplied by each supplier? Please include a bar chart to visualize the average unit price per supplier.,"```python
import plotly.express as px
import pandas as pd

# SQL query as provided
sql_query = """"""
SELECT SupplierID, AVG(UnitPrice) AS AveragePrice 
FROM products 
GROUP BY SupplierID;
""""""

# Execute the SQL query using the utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database execution
    # Replace with actual implementation
    # Example: return pd.read_sql(sql_query, connection)
    pass

# Replace the pass statement with actual query execution in real environment
df = execute_sql_query(sql_query)

# Error handling if dataframe is empty
if df is None or df.empty:
    raise ValueError(""Dataframe is empty. Please check the SQL execution."")

# Create a bar chart using Plotly
fig = px.bar(df, x='SupplierID', y='AveragePrice',
             title='Average Unit Price per Supplier',
             labels={'SupplierID': 'Supplier ID', 'AveragePrice': 'Average Unit Price'})

# Display the figure using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT SupplierID, AVG(UnitPrice) AS AverageUnitPrice
FROM products
GROUP BY SupplierID
""""""
average_unit_price_df = execute_sql_query(sql_query)

fig = px.bar(average_unit_price_df, x='SupplierID', y='AverageUnitPrice', 
             title='Average Unit Price per Supplier', labels={'AverageUnitPrice': 'Average Unit Price', 'SupplierID': 'Supplier ID'})
show_to_user(fig)
```","The input Python code correctly executes a SQL query that calculates the average unit price of products by supplier, similar to the reference implementation. It also properly handles the display of results using a Plotly bar chart, which matches the required business analytics request. Both codes use the same logic and elements such as data retrieval, figure creation, and display, ensuring the query's output structure is accurately represented in the visualization. Therefore, the input code adheres to the specified logic and requirements.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to retrieve data
sql_query = ""SELECT SupplierID, AVG(UnitPrice) AS AvgUnitPrice FROM products GROUP BY SupplierID;""
products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit price per supplier
fig = px.bar(products_df, x='SupplierID', y='AvgUnitPrice', title='Average Unit Price per Supplier')

# Display the bar chart using the provided utility function
show_to_user(fig)
```","The input code correctly follows the same logic as the reference implementation. It executes an SQL query to calculate the average unit price of products for each supplier, groups the results by SupplierID, and creates a bar chart to visualize the average price per supplier. The column name for the average price is 'AvgUnitPrice', which corresponds correctly to the query and visualization. Both implementations utilize Plotly Express for visualization and assume a utility function to execute the SQL query and display the chart. Despite slight differences in column naming conventions, the structure and logic remain equivalent.",both
"Which suppliers have received the most customer orders, and can you provide a bar chart to visualize the comparison?","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT s.CompanyName, COUNT(DISTINCT o.OrderID) AS NumberOfOrders
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.CompanyName
ORDER BY NumberOfOrders DESC;
""""""

# Simulate execute_sql_query function
def execute_sql_query(sql_query: str):
    # This function should connect to the database, execute the query, and return a DataFrame.
    # Here we simulate with an empty DataFrame for illustration purposes.
    # Replace with actual implementation.
    return pd.DataFrame({
        'CompanyName': ['Supplier A', 'Supplier B', 'Supplier C'],
        'NumberOfOrders': [150, 120, 90]
    })

# Simulate show_to_user function
def show_to_user(data):
    # This function would typically display data or plot visualization.
    # Placeholder for demonstration purposes.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the comparison
fig = px.bar(df, x='CompanyName', y='NumberOfOrders', title='Supplier Orders Comparison',
             labels={'CompanyName': 'Supplier', 'NumberOfOrders': 'Number of Orders'})

# Display the visualization to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(o.OrderID) AS OrderCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY OrderCount DESC
""""""

supplier_orders = execute_sql_query(sql_query)

fig = px.bar(supplier_orders, x='CompanyName', y='OrderCount',
             title='Supplier Order Counts',
             labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Supplier'},
             text='OrderCount')
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(yaxis_title='Number of Orders', xaxis_title='Supplier')
show_to_user(fig)
```","The evaluated code correctly follows the logic of the reference code. Both versions execute a SQL query to count the number of orders per supplier, though the evaluated code includes SupplierID in both SELECT and GROUP BY clauses. The differences in SQL do not affect correctness as they both derive the intended results (order count per supplier and company name). Both implementations use Plotly to create a bar chart with the same key elements, ensuring the same visualization. Therefore, the evaluated code correctly aligns with the reference code's logic and purpose.","```python
import plotly.express as px

# Query to execute
sql_query = """"""
SELECT ProductID, COUNT(DISTINCT SupplierID) AS NumberOfSuppliers 
FROM products 
GROUP BY ProductID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
def execute_sql_query(sql_query: str):
    import pandas as pd
    # perform database connection and query execution logic here
    # Placeholder implementation - replace with actual logic
    mock_data = {
        ""ProductID"": [1, 2, 3],
        ""NumberOfSuppliers"": [5, 3, 8]
    }
    return pd.DataFrame(mock_data)

data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ProductID', y='NumberOfSuppliers', 
             title='Number of Suppliers per Product',
             labels={'ProductID': 'Product ID', 'NumberOfSuppliers': 'Number of Suppliers'})

# Display the visualization
def show_to_user(data):
    import plotly.io as pio
    pio.show(data)

show_to_user(fig)
```","The input Python code does not address the business analytics request. The query in the input code counts distinct suppliers for each product instead of counting orders per supplier. Consequently, the bar chart created is for 'Number of Suppliers per Product' rather than 'Supplier Orders Comparison'. This differs from the reference implementation, which ranks suppliers by the number of customer orders they received.",Base
"What is the total number of units on order for each product category, and can this be represented in a bar chart for easier comparison?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to execute
sql_query = '''
SELECT categories.CategoryID, SUM(products.UnitsOnOrder) AS TotalUnitsOnOrder
FROM products
JOIN categories ON products.CategoryID = categories.CategoryID
GROUP BY categories.CategoryID;
'''

# Execute the SQL query using the utility function to obtain a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to represent the total units on order by product category
fig = px.bar(df, x='CategoryID', y='TotalUnitsOnOrder', title='Total Units on Order by Product Category')

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = '''
SELECT p.CategoryID, SUM(p.UnitsOnOrder) AS TotalUnitsOnOrder
FROM products p
GROUP BY p.CategoryID
'''

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CategoryID', y='TotalUnitsOnOrder', title='Total Units on Order by Product Category', labels={'CategoryID':'Product Category', 'TotalUnitsOnOrder':'Total Units On Order'})
show_to_user(fig)
```","The input code correctly answers the analytics request by calculating the sum of UnitsOnOrder for each CategoryID and visualizes this using a bar chart. Although the SQL query in the input code omits the JOIN with the categories table, it still groups by CategoryID, which is sufficient for the requested analysis if the products table already contains the necessary CategoryID information. The visualization logic matches the requirement for a bar chart display as in the reference.","import pandas as pd
import plotly.express as px

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function: In a real scenario, this would execute the SQL query and return a DataFrame.
    pass

def show_to_user(data):
    # Mock function: In a real scenario, this would display the data or Plotly figure.
    pass

# Business Analyst Request
sql_query = """"""
SELECT p.CategoryID, SUM(p.UnitsOnOrder) AS TotalUnitsOnOrder
FROM products p
GROUP BY p.CategoryID;
""""""

# Execute SQL Query to get the data
data_df = execute_sql_query(sql_query)

# Visualize data as a bar chart
fig = px.bar(data_df, x='CategoryID', y='TotalUnitsOnOrder', title='Total Units on Order by Product Category')

# Show the bar chart to the user
show_to_user(fig)","The input implementation generates the total units on order by category, but it does not join the categories table. This means it might miss categories information that might be needed. The reference implementation joins the products with categories, ensuring each product's CategoryID is tied with a valid category. Without the join, the input code may not align with the intent if there are discrepancies between products and categories data.",Base
"What is the total quantity ordered for each product supplied by a supplier, and can you provide a bar chart to visualize these quantities?","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are already defined

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, s.CompanyName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY p.ProductName, s.CompanyName;
""""""

# Execute the SQL query and retrieve the data as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total quantity ordered for each product
fig = px.bar(
    df,
    x='ProductName',
    y='TotalQuantity',
    color='CompanyName',
    title='Total Quantity Ordered for Each Product by Supplier',
    labels={'TotalQuantity': 'Total Quantity', 'ProductName': 'Product Name'},
    barmode='group'
)

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, s.CompanyName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY p.ProductName, s.CompanyName
ORDER BY s.CompanyName, p.ProductName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='TotalQuantity', color='CompanyName', 
             title='Total Quantity Ordered for Each Product by Supplier',
             labels={'TotalQuantity': 'Quantity Ordered', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input Python code performs the same logic as the reference implementation. It executes a similar SQL query to calculate the total quantity ordered for each product by supplier; the only difference is the order of joins, which does not affect the logic. It uses Plotly to create a bar chart with appropriate settings, and the use of labels is consistent with the business analytics request. Therefore, the input code correctly adheres to the requirements.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total quantity ordered for each product supplied by a supplier.
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY p.ProductName
""""""

# Execute the SQL query to retrieve the product quantities.
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total quantity ordered for each product.
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Total Quantity Ordered for Each Product', 
             labels={'ProductName': 'Product Name', 'TotalQuantity': 'Total Quantity'})

# Display the bar chart to the user.
show_to_user(fig)
```","The provided code does not include the supplier's company name in the output, which is required by the business analytics request and is included in the reference implementation. The reference code groups by both ProductName and CompanyName, ensuring that quantities are calculated per product per supplier, while the input code only groups by ProductName.",Base
Find the customer with the highest single order value and create a bar chart to visualize the top five order values.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL queries
top_five_orders_query = '''
SELECT o.CustomerID, od.OrderID, (od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
ORDER BY OrderValue DESC 
LIMIT 5;
'''

# Execute SQL query
top_five_orders_df = execute_sql_query(top_five_orders_query)

# Extract the customer with the highest order value
highest_order_customer = top_five_orders_df.iloc[0]

# Create a bar chart for the top five order values
fig = px.bar(top_five_orders_df, x='OrderID', y='OrderValue', 
             labels={'OrderID': 'Order ID', 'OrderValue': 'Order Value'},
             title='Top Five Order Values')

# Show the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderValue DESC
LIMIT 5
""""""

top_orders_df = execute_sql_query(sql_query)

# Find customer with the highest single order value
highest_order_customer = top_orders_df.iloc[0]

# Bar chart for top five order values
fig = px.bar(top_orders_df, x='CompanyName', y='OrderValue', title='Top 5 Order Values', labels={'OrderValue':'Order Value', 'CompanyName':'Company Name'})
show_to_user(fig)

highest_order_customer
```","The input code groups by CustomerID and CompanyName to get the total order value for each customer, not individual order values. The reference code calculates each order's value and then limits to the top five individual order values. Therefore, the input code does not fulfill the requirement to find the customer with the highest single order value.","```python
import pandas as pd
import plotly.express as px

# Define SQL queries
single_order_value_query = """"""
SELECT OrderID, customers.CompanyName, MAX(order_value) AS single_order_value
FROM (
    SELECT OrderID, 
           customers.CompanyName, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS order_value
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    JOIN customers ON orders.CustomerID = customers.CustomerID
    GROUP BY OrderID, customers.CompanyName
) AS OrderValues
ORDER BY single_order_value DESC
LIMIT 1
""""""

top_five_order_values_query = """"""
SELECT customers.CompanyName, SUM(order_value) AS order_value
FROM (
    SELECT OrderID, customers.CompanyName, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS order_value
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    JOIN customers ON orders.CustomerID = customers.CustomerID
    GROUP BY OrderID, customers.CompanyName
) AS OrderValues
GROUP BY customers.CompanyName
ORDER BY order_value DESC
LIMIT 5
""""""

# Execute SQL queries
highest_order_value_df = execute_sql_query(single_order_value_query)
top_five_order_values_df = execute_sql_query(top_five_order_values_query)

# Visualize top five order values
fig = px.bar(top_five_order_values_df, x='CompanyName', y='order_value',
             title='Top Five Order Values',
             labels={'CompanyName': 'Customer', 'order_value': 'Order Value'},
             template='plotly_dark')

# Show results to user
show_to_user(highest_order_value_df)
show_to_user(fig)
```","The input code uses a different approach compared to the reference code. Instead of focusing on individual order values, it computes aggregated values per customer, which results in getting the highest aggregated order value by customer rather than the specific highest individual order value. This violates the requirement of identifying the maximum single order value. Additionally, the visualization uses customer companies instead of order IDs for the top five order visualization, deviating from the task description which requests a focus on single orders rather than customer aggregates.",None
"What is the monthly product performance for each product, and can you provide a line chart or bar graph to visualize these trends?","```python
import plotly.express as px

# Assume the utility functions are defined elsewhere and available in the environment
# execute_sql_query(sql_query: str) -> pd.DataFrame
# show_to_user(data) -> None

# SQL query provided by the user
sql_query = """"""
SELECT 
    products.ProductName, 
    EXTRACT(MONTH FROM orders.OrderDate) AS Month, 
    SUM([Order Details].Quantity) AS MonthlyPerformance 
FROM 
    products 
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY 
    products.ProductName, EXTRACT(MONTH FROM orders.OrderDate);
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Convert numeric 'Month' to month names for better readability
df['Month'] = df['Month'].apply(lambda x: {1: ""January"", 2: ""February"", 3: ""March"", 4: ""April"", 5: ""May"", 
                                            6: ""June"", 7: ""July"", 8: ""August"", 9: ""September"", 
                                            10: ""October"", 11: ""November"", 12: ""December""}.get(x))

# Visualize using Plotly
fig = px.line(df, x='Month', y='MonthlyPerformance', color='ProductName',
              title='Monthly Product Performance',
              labels={'MonthlyPerformance': 'Quantity Sold'},
              category_orders={""Month"": [""January"", ""February"", ""March"", ""April"", ""May"", ""June"", 
                                         ""July"", ""August"", ""September"", ""October"", ""November"", ""December""]})

# Use show_to_user() to display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity) AS TotalSold
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, Month
ORDER BY 
    Month, p.ProductID
""""""

product_performance_df = execute_sql_query(sql_query)

fig = px.line(product_performance_df, x='Month', y='TotalSold', color='ProductName', title='Monthly Product Performance')
show_to_user(fig)
```","The input code differs in key aspects from the reference code. It groups data by year and month ('%Y-%m'), not just by month. This affects how data is aggregated over time. Additionally, it uses different SQL logic (DATE_FORMAT vs. EXTRACT), potentially altering the grouping outcomes. The reference code specifically extracts month information, while the input handles it as 'Year-Month' which could lead to a different aggregation logic and visualization by month names is missing. Also, there is no conversion from month numbers to names or ordering of months in the input, which affects the readability and analysis of trends across months.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the monthly product performance
sql_query = """"""
SELECT P.ProductID, 
       YEAR(O.OrderDate) AS Year, 
       MONTH(O.OrderDate) AS Month, 
       SUM(OD.Quantity) AS MonthlyPerformance 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
JOIN orders O ON OD.OrderID = O.OrderID 
GROUP BY P.ProductID, YEAR(O.OrderDate), MONTH(O.OrderDate);
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation - Replace with actual database interaction code
    # Example dataframe returned, replace with actual query execution result
    data = {
        'ProductID': [1, 1, 1, 2, 2, 2],
        'Year': [2023, 2023, 2023, 2023, 2023, 2023],
        'Month': [1, 2, 3, 1, 2, 3],
        'MonthlyPerformance': [150, 200, 300, 100, 150, 250]
    }
    return pd.DataFrame(data)

# Fetch the data
monthly_performance_df = execute_sql_query(sql_query)

# Visualize the trends using a line chart
fig = px.line(
    monthly_performance_df, 
    x='Month', 
    y='MonthlyPerformance', 
    color='ProductID', 
    title='Monthly Product Performance',
    labels={'MonthlyPerformance': 'Performance', 'Month': 'Month'},
    markers=True
)

# Show the visualization
def show_to_user(data):
    # Mock implementation - In a real scenario, this would display the DataFrame or Fig
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Show the line chart to the user
show_to_user(fig)
```","The input code does not fully align with the reference implementation in terms of logic and expected results. Firstly, the reference code extracts the product name and only groups by product name and month, which keeps the data more readable and directly aligned with user expectations, while the input code uses 'ProductID'. This means the input solution does not map 'ProductID' to 'ProductName'. Secondly, the input code includes 'Year' in the GROUP BY clause, which is not part of the reference implementation - this might split monthly data across different years when it should aggregate across all available years. Lastly, there is no conversion from numeric month values to month names in the input code, which reduces readability in the visualization.",None
"How many unique products are ordered each month, and can this be visualized in a line chart to show trends over time?","```python
import pandas as pd
import plotly.express as px

# SQL query to extract monthly unique product orders
sql_query = """"""
SELECT TO_CHAR(OrderDate, 'YYYY-MM') AS Month, 
       COUNT(DISTINCT ProductID) AS UniqueProducts 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY TO_CHAR(OrderDate, 'YYYY-MM')
""""""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is sorted properly by converting it to datetime
df['Month'] = pd.to_datetime(df['Month'], format='%Y-%m')

# Sort the DataFrame by 'Month' for a chronological line chart
df = df.sort_values('Month')

# Create a line chart to visualize the trend of unique products ordered each month
fig = px.line(df, x='Month', y='UniqueProducts', title='Unique Products Ordered Each Month')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count unique products ordered each month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(DISTINCT ProductID) AS UniqueProducts
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query and retrieve the data
unique_products_df = execute_sql_query(sql_query)

# Create a line chart to visualize the trends over time
fig = px.line(unique_products_df, x='Month', y='UniqueProducts', title='Unique Products Ordered Each Month', labels={'UniqueProducts': 'Unique Products', 'Month': 'Month'})
show_to_user(fig)
```","Both implementations correctly perform the task of calculating the number of unique products ordered each month and visualizing it in a line chart. The main differences lie in the SQL syntax used—`TO_CHAR` in the reference code and `DATE_FORMAT` in the input code—which are functionally equivalent for formatting dates as months in SQL. Additionally, both codes ensure proper order through sorting and produce a similar line chart using Plotly Express. Consequently, the input code adheres to the same logic as the reference implementation.","```python
import plotly.express as px

# Mock function definitions for the environment constraints.
def execute_sql_query(sql_query: str) -> 'DataFrame':
    # Realistic implementation would query a database and return the result as a DataFrame
    import pandas as pd
    data = {
        'Month': ['2023-01', '2023-02', '2023-03'],
        'Quantity': [100, 150, 120]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock display function, in practice would handle data accordingly
    if isinstance(data, str):
        print(data)
    else:
        print(data.to_string())  # Placeholder for displaying DataFrame or Plotly figure

# SQL query provided in the request.
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       COUNT(DISTINCT OrderDetails.ProductID) AS UniqueProducts 
FROM orders 
JOIN OrderDetails ON orders.OrderID = OrderDetails.OrderID 
GROUP BY Month;
""""""

# Retrieve data using the SQL query.
monthly_unique_products_df = execute_sql_query(sql_query)

# Create Line Chart using Plotly.
fig = px.line(
    monthly_unique_products_df,
    x='Month',
    y='Quantity',
    title='Unique Products Ordered Each Month',
    labels={'Quantity': 'Unique Products', 'Month': 'Month'},
    markers=True
)

# Show the figure to the user.
show_to_user(fig)
```","The input code incorrectly processes the data. The SQL query and data processing aim to count unique products, but the resulting DataFrame contains a 'Quantity' column instead of 'UniqueProducts'. Additionally, the line chart plots 'Quantity' instead of 'UniqueProducts'. To align with the business request, the code should count unique products per month using 'UniqueProducts' in the data and plot this count over time.",Base
"How many orders have a shipping cost above $50? Additionally, create a bar chart showing the distribution of orders by cost ranges above $50.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation to execute SQL and return DataFrame
    pass

# Utility function to show data or visualization to the user
def show_to_user(data):
    # Implementation to display data or visualization
    pass

# SQL query to count orders with a shipping cost greater than $50
sql_query_count = ""SELECT COUNT(*) AS high_freight_orders FROM orders WHERE Freight > 50""
result_count_df = execute_sql_query(sql_query_count)

# Display the count of high freight orders
show_to_user(result_count_df)

# SQL query to get orders with Freight cost over $50
sql_query_distribution = """"""
SELECT 
    CASE
        WHEN Freight <= 60 THEN '51-60'
        WHEN Freight <= 70 THEN '61-70'
        WHEN Freight <= 80 THEN '71-80'
        WHEN Freight <= 90 THEN '81-90'
        WHEN Freight <= 100 THEN '91-100'
        ELSE '101+'
    END AS Freight_Range,
    COUNT(*) AS Order_Count
FROM orders 
WHERE Freight > 50 
GROUP BY Freight_Range
""""""

# Execute the query and get the distribution data
distribution_df = execute_sql_query(sql_query_distribution)

# Create a bar chart using Plotly
fig = px.bar(distribution_df, x='Freight_Range', y='Order_Count', title='Order Distribution by Freight Cost Range')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Freight 
FROM orders 
WHERE Freight > 50
""""""
orders_above_50 = execute_sql_query(sql_query)

count_orders_above_50 = orders_above_50.shape[0]

cost_ranges = pd.cut(orders_above_50['Freight'], bins=[50, 75, 100, 150, 200, float('inf')], right=True)
cost_distribution = cost_ranges.value_counts().reset_index()
cost_distribution.columns = ['Cost Range', 'Number of Orders']

fig = px.bar(cost_distribution, x='Cost Range', y='Number of Orders', title='Distribution of Orders by Shipping Cost Ranges Above $50')
show_to_user(fig)
```","The input code does not correctly calculate the number of orders above $50. In the reference implementation, the number of such orders is directly counted using SQL. In the input code, the count is derived from the shape of the DataFrame resulting from a SELECT query. Also, the cost range bins in the reference implementation are different from those in the input code, which affects the distribution chart logic.","import pandas as pd
import plotly.express as px


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # Simulate returning a DataFrame for demonstration purposes
    data = {
        ""CountAbove50"": [30],
        ""OrderID"": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
    }
    return pd.DataFrame(data)


def show_to_user(data):
    # Placeholder for displaying logic
    print(data)


# SQL query to count distinct orders with shipping cost above $50
sql_query_count = ""SELECT COUNT(DISTINCT OrderID) AS CountAbove50 FROM orders WHERE Freight > 50;""
orders_df = execute_sql_query(sql_query_count)

# Show the count of orders
show_to_user(orders_df)

# Create a bar chart for the distribution of orders by cost ranges above $50
sql_query_distribution = """"""
SELECT OrderID, ROUND(Freight / 10) * 10 AS CostRange
FROM orders
WHERE Freight > 50;
""""""
distribution_df = execute_sql_query(sql_query_distribution)

# Group by CostRange and count orders
cost_range_df = distribution_df.groupby('CostRange').size().reset_index(name='OrderCount')

# Create bar chart using Plotly
fig = px.bar(cost_range_df, x='CostRange', y='OrderCount', title='Distribution of Orders by Cost Ranges Above $50')

# Show the bar chart using the utility function
show_to_user(fig)
","The input code does not fully adhere to the logic of the reference implementation. The input counts distinct order IDs, which may differ from the reference if orders have unique constraints. Additionally, the cost range calculation in the input uses ROUND which generates ranges like 60, 70, etc., potentially grouping differently than the specified ranges like 51-60, 61-70 in the reference. These discrepancies in logic could lead to different results.",None
"Is there a trend in shipping delays over the past year, and can this be shown through a line graph to illustrate the trend?","```python
import pandas as pd
import plotly.express as px

# SQL query for retrieving shipping delay data
sql_query = '''
SELECT DATE_TRUNC('month', OrderDate) AS month, 
       (COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) * 1.0 / COUNT(*)) * 100 AS delay_rate 
FROM orders 
WHERE OrderDate >= DATEADD(YEAR, -1, CURRENT_DATE) 
GROUP BY DATE_TRUNC('month', OrderDate);
'''

# Execute the SQL query and retrieve the data as a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a line graph using Plotly to visualize the trend of shipping delays
fig = px.line(data, x='month', y='delay_rate', title='Trend in Shipping Delays Over the Past Year',
              labels={'delay_rate': 'Delay Rate (%)', 'month': 'Month'})

# Show the line graph to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS Avg_Fulfillment_Time
FROM 
    orders
WHERE 
    ShippedDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='Month', y='Avg_Fulfillment_Time', title='Trend in Shipping Delays Over the Past Year', labels={'Avg_Fulfillment_Time': 'Average Fulfillment Time (days)', 'Month': 'Month'})
show_to_user(fig)
```","The input code measures the average fulfillment time each month, rather than the delay rate as in the reference. The reference code calculates the percentage of orders delayed beyond the required date, while the input code calculates the average number of days from order to shipment without considering delays relative to a required date.","```python
import pandas as pd
import plotly.express as px

# Hypothetical function to execute SQL and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This will typically contain the logic to connect to a database and fetch data
    pass

# Hypothetical function to show data to user
def show_to_user(data):
    # This will typically handle displaying the DataFrame or Plotly figure
    pass

# SQL query to fetch data for on-time delivery over the last year
sql_query = """"""
SELECT 
    MONTH(orders.OrderDate) AS month, 
    COUNT(orders.OrderID) AS total_orders, 
    COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN orders.OrderID END) AS on_time_orders, 
    COUNT(orders.OrderID) - COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN orders.OrderID END) AS delayed_orders
FROM 
    orders 
WHERE 
    YEAR(orders.OrderDate) = YEAR(CURDATE())
GROUP BY 
    MONTH(orders.OrderDate)
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Compute the trend line of delayed shipments
df['delayed_percentage'] = df['delayed_orders'] / df['total_orders'] * 100

# Create a line graph to visualize the trend
fig = px.line(
    df,
    x='month',
    y='delayed_percentage',
    title='Trend of Shipping Delays Over the Past Year',
    labels={'month': 'Month', 'delayed_percentage': '% of Orders Delayed'}
)

# Show the figure to the user
show_to_user(fig)
```","The input code calculates delays for the current year using YEAR(CURDATE()) and groups by month number, while the reference uses DATE_TRUNC for a rolling past year comparison. The logic for delay calculation and time period differs.",None
"What is the average order fulfillment time over the past year, and can it be visualized with a monthly trend line chart?","```python
import pandas as pd
import plotly.express as px

# Assume utility functions are pre-defined:
# execute_sql_query and show_to_user

# SQL query to get monthly average fulfillment time over the past year
sql_query = """"""
SELECT
    DATE_TRUNC('month', OrderDate) AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM
    orders
WHERE
    OrderDate >= CURRENT_DATE - INTERVAL '1 year'
GROUP BY
    Month
ORDER BY
    Month;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Visualize the data with a monthly trend line chart
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Monthly Average Order Fulfillment Time Over the Past Year')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average order fulfillment time per month over the past year
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
WHERE 
    OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
fulfillment_data = execute_sql_query(sql_query)

# Generate the line chart to visualize the average order fulfillment time by month
fig = px.line(fulfillment_data, x='Month', y='AvgFulfillmentTime', 
              title='Average Order Fulfillment Time Over the Past Year',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly calculates the average order fulfillment time over the past year and visualizes it with a monthly trend line chart. It uses DATE_FORMAT instead of DATE_TRUNC, but achieves the same result. The SQL logic, execution, and visualization steps match the reference implementation, even though minor syntactical differences exist.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Assume the utility functions are already defined as per the constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mockup function assuming it executes the SQL and returns a DataFrame
    # Placeholder for the actual SQL execution logic
    pass

def show_to_user(data):
    # Mockup function assuming it displays the data or visualization
    if isinstance(data, pd.DataFrame):
        print(data.head())
    else:
        data.show()

# SQL query to get average fulfillment time and monthly trend
sql_query = '''
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    DATEDIFF(orders.ShippedDate, orders.OrderDate) AS fulfillment_time
FROM orders
WHERE orders.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE()
'''

# Execute SQL query
orders_df = execute_sql_query(sql_query)

# Calculate monthly average fulfillment time
monthly_avg = orders_df.groupby('month')['fulfillment_time'].mean().reset_index()
monthly_avg.columns = ['month', 'avg_fulfillment_time']

# Create a line chart for the trend
fig = px.line(monthly_avg, x='month', y='avg_fulfillment_time',
              title='Average Order Fulfillment Time Over the Past Year',
              labels={'avg_fulfillment_time': 'Avg Fulfillment Time (days)'})

# Show the figure
show_to_user(fig)
```","The input code does not correctly follow the logic of the reference implementation. The reference code calculates the average fulfillment time by aggregating the data directly in the SQL query, while the input code retrieves detailed data and then incorrectly attempts to calculate the average by grouping in Python. Moreover, the input code uses `DATE_FORMAT` instead of `DATE_TRUNC` and selects fulfillment time for each order without averaging them in SQL, differing from the grouping and aggregation in the reference code.",Base
"What is the total quantity sold for each product category, and can this be represented in a bar chart for clearer insight?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total quantity sold for each product category
sql_query = """"""
SELECT categories.CategoryName, SUM([Order Details].Quantity) AS total_quantity_sold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
GROUP BY categories.CategoryName
""""""

# Execute the SQL query and obtain the results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize total quantity sold by product category
fig = px.bar(
    df,
    x='CategoryName',
    y='total_quantity_sold',
    title='Total Quantity Sold by Product Category',
    labels={'CategoryName':'Product Category', 'total_quantity_sold':'Total Quantity Sold'}
)

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CategoryName, SUM(od.Quantity) AS total_quantity_sold
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryName
""""""

data = execute_sql_query(sql_query)
fig = px.bar(data, x='CategoryName', y='total_quantity_sold', title='Total Quantity Sold by Product Category')
show_to_user(fig)
```","The provided code is correct. It executes a SQL query to retrieve the total quantity sold for each product category, using the same logic as the reference code. Both implementations use a SQL query to join the tables and sum the quantities, group by category, and then visualize the results using Plotly. The naming conventions and structure are slightly different, but they do not affect the overall functionality.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) as TotalQuantity 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
GROUP BY p.CategoryID;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='TotalQuantity', 
             title='Total Quantity Sold per Product Category', 
             labels={'CategoryID': 'Product Category', 'TotalQuantity': 'Total Quantity Sold'})

# Display the bar chart
show_to_user(fig)
```","The input code produces a result but does not match the business logic as specified, which requires the total quantity sold for each product category by name. It only groups by 'CategoryID' without joining to the 'categories' table to retrieve the 'CategoryName'. The reference code correctly joins the 'categories' table and groups by 'CategoryName', which is essential for clearer insight and matches the business request. Additionally, the axis label 'CategoryID' is less informative than 'CategoryName'.",Base
"Find the average salary of employees who have generated over $50,000 in sales and present the distribution of these salaries using a histogram.","```python
import pandas as pd
import plotly.express as px

# Assuming the utility function execute_sql_query is defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to mimic actual SQL execution
    # In practice, this should be connected to an actual database
    pass

def show_to_user(data):
    # Placeholder function to simulate showing data or figures
    # In practice, this would display dataframes or figures appropriately
    print(data)

# SQL Query to find the average salary of employees with over $50,000 in sales
sql_query = """"""
SELECT e.EmployeeID, e.Salary
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.Salary
HAVING SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) > 50000;
""""""

# Execute the query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Calculate the average salary
average_salary = df['Salary'].mean()

# Show the average salary to the user
show_to_user(pd.DataFrame({'Average Salary': [average_salary]}))

# Create a histogram of the salaries
fig = px.histogram(df, x='Salary', title='Distribution of Salaries for Employees with Sales > $50,000')

# Show the histogram using Plotly
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.Salary
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
HAVING SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) > 50000
""""""

salaries_df = execute_sql_query(sql_query)
average_salary = salaries_df['Salary'].mean()

fig = px.histogram(salaries_df, x='Salary', title='Salary Distribution of Employees with Sales Over $50,000')
show_to_user(fig)

average_salary
```","The input code correctly gathers and analyzes the data to find the average salary of employees with sales over $50,000 and presents the salary distribution using a histogram. The logic adheres to the reference code: both aggregate sales, filter employees based on the threshold, and calculate the average salary. The structure of the SQL query and the subsequent operations are consistent with the reference implementation. The minor differences do not affect correctness.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT AVG(e.Salary) AS AverageSalary
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
HAVING SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) > 50000;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Since we need to visualize the distribution, we need to fetch individual salaries
individual_salaries_query = """"""
SELECT e.Salary
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID 
HAVING SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) > 50000;
""""""

# Execute the query to get individual salaries
salary_df = execute_sql_query(individual_salaries_query)

# Generate the histogram using Plotly
fig = px.histogram(salary_df, x='Salary', title='Distribution of Salaries',
                   labels={'Salary': 'Salary'},
                   nbins=20)

# Display the histogram
show_to_user(fig)
```","The input code effectively answers the business analytics request and follows the same logic as the reference implementation. Both codes compute the average salary of employees who have generated over $50,000 in sales by filtering the employees based on their sales performance. The initial SQL in the input code calculates the average salary directly, while the reference implementation calculates it using DataFrame operations after fetching the data. For the histogram, the input code executes an additional query to fetch individual salaries to visualize the distribution. Both approaches compute and display the same histogram, satisfying the requirement to present the salary distribution. Thus, the input code is correct.",both
"Which customers have placed orders more than five times, and can this be visualized in a bar chart?","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT customers.CustomerID, COUNT(orders.OrderID) AS OrderCount 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
GROUP BY customers.CustomerID 
HAVING COUNT(orders.OrderID) > 5
""""""

# Execute the SQL query using the utility function
customers_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(customers_orders_df, x='CustomerID', y='OrderCount',
             title='Customers with More Than Five Orders',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'})

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName, COUNT(orders.OrderID) AS OrderCount
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID, customers.CompanyName
HAVING COUNT(orders.OrderID) > 5
""""""

customer_orders = execute_sql_query(sql_query)

fig = px.bar(customer_orders, x='CompanyName', y='OrderCount', title='Customers with More Than Five Orders', labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer Company Name'})
show_to_user(fig)
```","The input Python code correctly identifies customers who have placed more than five orders by executing a SQL query. It groups by CustomerID and also includes CompanyName, which is an acceptable additional detail that doesn't affect the logic of the request. The visualization using Plotly is consistent with the reference code, albeit using CompanyName on the x-axis instead of CustomerID. The core requirements of counting orders per customer and visualizing those with more than five orders are fulfilled.","To complete the task, we will execute the SQL query provided to identify customers who have placed orders more than five times. We will then visualize the results in a bar chart using Python.

### 1. Import Necessary Libraries
We need to import the necessary libraries for database interaction and data visualization.
```python
import pandas as pd
import plotly.express as px
```

### 2. SQL Query Execution
We will use the provided SQL query to fetch the necessary data.
```python
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 5;
""""""

# Execute the SQL query and get the result as a DataFrame
df_customers = execute_sql_query(sql_query)
```

### 3. Visualize the Results
Using Plotly for visualization, we will create a bar chart to visualize the customer order counts.
```python
fig = px.bar(df_customers, x='CustomerID', y='OrderCount',
             title='Customers with More Than Five Orders',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'})

# Display the figure using the utility function
show_to_user(fig)
```

### Final Combined Code
Here is the full code combining all the steps required to fulfill the business request.
```python
import pandas as pd
import plotly.express as px

# SQL query to find customers with more than five orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 5;
""""""

# Execute the SQL query and get the result as a DataFrame
df_customers = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(df_customers, x='CustomerID', y='OrderCount',
             title='Customers with More Than Five Orders',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'})

# Display the figure
show_to_user(fig)
```","The input code does not join the 'customers' table with the 'orders' table as in the reference implementation. Therefore, it may miss customers with no orders and might include CustomerIDs not present in the 'customers' table, potentially leading to incorrect results.",Base
Rank customers by the number of orders they have placed and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are predefined utility functions

# Define the SQL query
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY CustomerID 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query to get the results
customer_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(customer_orders_df, x='CustomerID', y='NumberOfOrders',
             title='Customer Ranking by Number of Orders',
             labels={'CustomerID': 'Customer ID', 'NumberOfOrders': 'Number of Orders'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count the number of orders per customer
sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS OrderCount
FROM customers AS c
LEFT JOIN orders AS o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderCount DESC
""""""

# Execute the SQL query
customer_orders = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(customer_orders, x='CompanyName', y='OrderCount', 
             title='Customer Order Count', 
             labels={'CompanyName': 'Customer', 'OrderCount': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)
```","Both implementations aim to rank customers by the number of orders placed and visualize this data in a bar chart. The input code performs a slight variation by also considering the 'CompanyName' alongside 'CustomerID' in its query, using LEFT JOIN to include all customers, even those with zero orders. The business question is still addressed because the chart reflects the number of orders per customer. The use of 'CompanyName' in the axis label does not deviate from the primary objective of ranking customers by orders, aligning with the reference logic.","import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str):
    # This function would typically connect to a database to execute the SQL query
    # For illustration, it returns a sample DataFrame
    data = {
        'CustomerID': ['C1', 'C2', 'C3', 'C4', 'C5'],
        'NumOrders': [10, 8, 6, 4, 2]
    }
    return pd.DataFrame(data)

# Function to display data or visualization
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query from the business analytic request
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) AS NumOrders
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID
ORDER BY NumOrders DESC;
""""""

# Execute the SQL query to get the data
orders_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_data, x='CustomerID', y='NumOrders', title='Number of Orders by Customer')

# Display the bar chart
show_to_user(fig)
","The provided code and reference implementation differ in their SQL queries. The reference query retrieves data directly by grouping and counting orders on the 'orders' table. In contrast, the input code joins 'customers' and 'orders' tables; however, the 'execute_sql_query' function does not actually execute this query, it returns a hardcoded DataFrame instead. Both codes produce similar outputs because of this hardcoded DataFrame, but the logic and source are different. Therefore, it does not fully adhere to the same logic as the reference implementation.",Base
Calculate the average time between order and shipment and provide a visualization of the distribution of these times.,"
```python
import pandas as pd
import plotly.express as px

# SQL query to get the OrderDate and ShippedDate needed for analysis
sql_query = """"""
SELECT o.OrderDate, o.ShippedDate 
FROM orders o 
WHERE o.ShippedDate IS NOT NULL
""""""

# Execute the SQL query using the utility function
orders_df = execute_sql_query(sql_query)

# Calculate the shipping time in days between order and shipment
orders_df['ShippingTime'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days

# Calculate the average shipping time
average_shipping_time = orders_df['ShippingTime'].mean()

# Visualize the distribution of shipping times
fig = px.histogram(orders_df, x='ShippingTime', title='Distribution of Shipping Times',
                   labels={'ShippingTime': 'Shipping Time (days)'},
                   nbins=20)

# Display the visualization using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderID,
    DATEDIFF(ShippedDate, OrderDate) AS DeliveryTime
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
""""""

delivery_times = execute_sql_query(sql_query)

average_delivery_time = delivery_times['DeliveryTime'].mean()

fig = px.histogram(delivery_times, x='DeliveryTime', title='Distribution of Delivery Times',
                   labels={'DeliveryTime':'Days from Order to Shipment'}, 
                   histnorm='probability')
show_to_user(fig)

average_delivery_time
```","The input code calculates the average time between order and shipment correctly using the DATEDIFF function, analogous to the subtraction of dates in the reference code. It also visualizes the distribution similarly with a histogram. Minor differences like the use of 'probability' normalization do not affect the overall correctness with respect to the business request.","```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the given SQL query using the utility function
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS DeliveryTime, CustomerID 
FROM orders 
WHERE ShippedDate IS NOT NULL;
""""""

# Fetch the data
df = execute_sql_query(sql_query)

# Step 2: Calculate the average time between order and shipment
average_delivery_time = df['DeliveryTime'].mean()

# Step 3: Display the average delivery time to the user
average_df = pd.DataFrame({'Average Delivery Time': [average_delivery_time]})
show_to_user(average_df)

# Step 4: Create a visualization of the distribution of delivery times
fig = px.histogram(df, x='DeliveryTime', title='Distribution of Delivery Times')

# Display the histogram to the user
show_to_user(fig)
```","Both implementations calculate the average time between order and shipment and plot a histogram to visualize the distribution. The reference code calculates the 'ShippingTime' in days by subtracting the 'OrderDate' from the 'ShippedDate', and the provided code directly computes this using the SQL DATEDIFF. Both methods effectively achieve the same result. The visualization created in both implementations provides a histogram of the time differences, which fulfills the business analytics request.",both
What percentage of orders were delivered on time each month? Please include a monthly trend line chart to visualize the data.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are defined elsewhere
def calculate_on_time_delivery():
    # SQL query to fetch on-time delivery rates per month
    sql_query = """"""
    SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
           ROUND(100.0 * SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) 
                 / COUNT(OrderID), 2) AS OnTimeDeliveryRate 
    FROM orders 
    GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
    """"""
    
    # Execute the query and get the result as a DataFrame
    df = execute_sql_query(sql_query)
    
    # Create a line chart using Plotly
    fig = px.line(df, x='Month', y='OnTimeDeliveryRate', 
                  title='Monthly On-Time Delivery Rate',
                  labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'},
                  markers=True)

    # Display the plot to the user
    show_to_user(fig)

# Call the function to execute the workflow
calculate_on_time_delivery()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

data = execute_sql_query(sql_query)

data['OnTimePercentage'] = (data['OnTimeDeliveries'] / data['TotalOrders']) * 100

fig = px.line(data, x='Month', y='OnTimePercentage', title='On-time Delivery Rate Percentage Each Month',
              labels={'OnTimePercentage': 'On-time Delivery Percentage', 'Month': 'Month'})
show_to_user(fig)
```","The input code correctly calculates the percentage of on-time deliveries each month by dividing the count of on-time deliveries by the total number of orders and multiplying by 100. It then uses Plotly to create a trend line chart, displaying the monthly on-time delivery percentage. Although the syntax differs from the reference implementation, the logic and final outcome are equivalent, fulfilling the business analytics request.","
import pandas as pd
import plotly.express as px

# SQL query to find the on-time delivery rate per month
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY OrderMonth;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Ensure the OrderMonth is treated as a datetime for the x-axis
df['OrderMonth'] = pd.to_datetime(df['OrderMonth'])

# Sort the DataFrame by OrderMonth
df = df.sort_values('OrderMonth')

# Create a line chart using Plotly to visualize on-time delivery trends
fig = px.line(df, x='OrderMonth', y='OnTimeDeliveryRate', 
              title='Monthly On-Time Delivery Rate',
              labels={'OrderMonth': 'Order Month', 'OnTimeDeliveryRate': 'On-Time Delivery Rate'},
              markers=True)

# Display the line chart to the user
show_to_user(fig)
","The input code calculates the on-time delivery rate but does not multiply the result by 100. Consequently, it doesn't convert the rate to a percentage as the reference code does. Furthermore, the reference code rounds the percentage to two decimal places using `ROUND(100.0 * SUM(...) / COUNT(OrderID), 2)`, which is not implemented in the input code. Thus, the logic doesn't fully align with the reference implementation.",Base
What is the Total Sales revenue for the last month? Please include a line chart showing daily sales for the month.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get daily sales for the last month
sql_query = """"""
SELECT 
    o.OrderDate, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS DailySales 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    YEAR(o.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) 
    AND MONTH(o.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
GROUP BY 
    o.OrderDate
ORDER BY 
    o.OrderDate
""""""

# Execute the query using the utility function to get the data as a DataFrame
sales_data = execute_sql_query(sql_query)

# Calculate the total sales revenue for the last month
total_sales_last_month = sales_data['DailySales'].sum()

# Create a line chart showing daily sales for the last month
fig = px.line(sales_data, x='OrderDate', y='DailySales', title='Daily Sales for Last Month')

# Display the line chart
show_to_user(fig)

# If needed, display the total sales amount
show_to_user(pd.DataFrame({'TotalSalesLastMonth': [total_sales_last_month]}))
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Get the last month's start and end date
end_date = datetime.now().replace(day=1) - timedelta(days=1)
start_date = end_date.replace(day=1)

# SQL query to get total sales for last month and daily sales
sql_query = f""""""
SELECT 
    DATE(o.OrderDate) as OrderDate,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as DailySales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= '{start_date.date()}' AND o.OrderDate <= '{end_date.date()}'
GROUP BY 
    DATE(o.OrderDate)
ORDER BY 
    DATE(o.OrderDate)
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Calculate total sales for last month
total_sales = sales_data['DailySales'].sum()

# Create line chart for daily sales
fig = px.line(sales_data, x='OrderDate', y='DailySales', title='Daily Sales for Last Month')

# Show total sales and the chart to the user
show_to_user(pd.DataFrame({'Total Sales Last Month': [total_sales]}))
show_to_user(fig)
```","The provided code correctly calculates the total sales for the last month using an SQL query that aligns with the logic of the reference implementation. Both codes retrieve daily sales data by joining orders and order details, summing the sales, and grouping by order date. The conditions for filtering data for the last month are equivalent, using date manipulation to ensure the correct range. The code also creates a line chart with daily sales, similar to the reference. Thus, it fulfills the business analytics request accurately.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch daily sales and total sales for the previous month
sql_query = """"""
SELECT 
    orders.OrderDate, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS DailySales,
    SUM(SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount))) OVER() AS TotalSales
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
    AND orders.OrderDate < CURDATE()
GROUP BY 
    orders.OrderDate;
""""""

# Execute the SQL query using the utility function
sales_data = execute_sql_query(sql_query)

# Calculate the total sales from the result
total_sales = sales_data['TotalSales'].iloc[0]

# Create a line chart for daily sales
fig = px.line(sales_data, x='OrderDate', y='DailySales', title='Daily Sales for Last Month')

# Display the total sales and the line chart
show_to_user(pd.DataFrame({'TotalSales': [total_sales]}))
show_to_user(fig)
```","The input code logic differs from the reference implementation. It uses a different SQL date filter, comparing OrderDate to a month interval from the current date (DATE_SUB(CURDATE(), INTERVAL 1 MONTH)), instead of extracting the exact year and month based on the reference (YEAR(o.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) AND MONTH(o.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH)). This could lead to discrepancies if the current date is not at the start of the month. Additionally, the input code aggregates total sales using a window function in SQL, which is not necessary since it is computed again as 'total_sales = sales_data['TotalSales'].iloc[0]' after data retrieval. Therefore, the SQL filter logic and total sales retrieval do not fully align with the reference implementation.",Base
What is the distribution of orders across different shipping companies? Please include a bar chart to visually represent the distribution.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user utility functions are defined elsewhere in the environment

# SQL query to get the order distribution by shipping company
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipVia 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get the results in a DataFrame
order_distribution_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the distribution of orders
fig = px.bar(order_distribution_df, x='ShipVia', y='OrderCount', 
             title='Order Distribution Across Shipping Companies',
             labels={'ShipVia': 'Shipping Company', 'OrderCount': 'Number of Orders'})

# Display the plot using the show_to_user function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipVia
ORDER BY OrderCount DESC
""""""

orders_distribution = execute_sql_query(sql_query)

fig = px.bar(orders_distribution, x='ShipVia', y='OrderCount', 
             title='Distribution of Orders Across Different Shipping Companies',
             labels={'ShipVia': 'Shipping Company', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The provided Python code fulfills the business analytics request by querying the database to retrieve the order distribution across different shipping companies. The query groups the data by the 'ShipVia' column, counts the number of 'OrderID', orders the results, and displays them in a descending order, matching the logic of the reference implementation. It then creates a bar chart using Plotly to visually represent the distribution and displays it using the show_to_user function. Despite minor differences in variable names and the chart title, the code's logic is consistent with the reference.","```python
import plotly.express as px

# SQL query to fetch the distribution of orders across different shipping companies
sql_query = """"""
SELECT shippers.CompanyName, COUNT(orders.OrderID) AS TotalOrders
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName;
""""""

# Execute the SQL query and obtain the results in a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to show the distribution of orders across shipping companies
fig = px.bar(orders_df, x='CompanyName', y='TotalOrders',
             title='Distribution of Orders by Shipping Company',
             labels={'CompanyName': 'Shipping Company', 'TotalOrders': 'Total Orders'})

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request by calculating the distribution of orders across different shipping companies and providing a visual representation with a bar chart. Although it uses a slightly different approach by joining the 'shippers' table to get the company name, it effectively achieves the same result as the reference code. Both implementations group the orders by shipping entity and count the number of orders, displaying the information in a bar chart using Plotly.",both
"How many orders did each employee handle last year, and can this be visualized in a bar chart for better comparison?","```python
import pandas as pd
import plotly.express as px

# Sample function to execute SQL query, to be implemented based on specific requirements
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation to connect to database and return query result as pandas DataFrame
    pass

# Sample function to display data or graphs
def show_to_user(data):
    # Implementation to handle displaying a pandas DataFrame or Plotly figure
    pass

# SQL query to fetch the data
sql_query = '''
SELECT 
    employees.EmployeeID, 
    CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
    COUNT(orders.OrderID) AS OrderCount 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
WHERE 
    YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) - 1 
GROUP BY 
    employees.EmployeeID, CONCAT(employees.FirstName, ' ', employees.LastName);
'''

# Execute SQL query and fetch data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeName', y='OrderCount', title='Orders Handled by Each Employee Last Year')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to count orders handled by each employee in the last year
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) - 1
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY OrderCount DESC
""""""

# Execute the SQL query and retrieve the data
employee_orders = execute_sql_query(sql_query)

# Create a bar chart to visualize the order counts per employee
fig = px.bar(employee_orders, x='LastName', y='OrderCount', 
             title='Number of Orders Handled by Each Employee Last Year',
             labels={'LastName': 'Employee', 'OrderCount': 'Order Count'},
             text='OrderCount')

fig.update_traces(texttemplate='%{text}', textposition='outside')
fig.update_layout(yaxis=dict(title='Order Count'), xaxis=dict(title='Employee'))
show_to_user(fig)
```","The input code provides a correct implementation of the business analytics request. It uses a SQL query to count orders handled by each employee last year, similar to the logic in the reference code. Both codes correctly join the employees and orders table, filter by the previous year's orders, and group the data by employee. They both utilize Plotly to create a bar chart for visualization. Differences such as the use of 'LEFT JOIN' and ordering the results by 'OrderCount' do not affect the correctness of the output. Thus, the input code addresses the request accurately.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, COUNT(*) AS OrdersHandled 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY employees.EmployeeID;
""""""

# Execute the query and get the data
orders_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders handled by each employee
fig = px.bar(orders_data, x='EmployeeID', y='OrdersHandled', title='Orders Handled by Each Employee Last Year', labels={'OrdersHandled': 'Number of Orders', 'EmployeeID': 'Employee ID'})

# Display the visualization
show_to_user(fig)
```","The input code correctly queries the number of orders handled by each employee last year, but it does not concatenate the employee's first and last name, which is part of the reference implementation for visualization purposes. Additionally, the input code uses a different column name ('OrdersHandled' instead of 'OrderCount'), which is acceptable. However, omitting the concatenation of names may lead to unclear visualization, especially if Employee IDs are less descriptive or unique.",Base
"What day of the week do most shipments occur, and can a bar chart be used to visualize the distribution of shipments across the week?","```python
import plotly.express as px
import pandas as pd

# SQL query modified to retrieve weekly distribution instead of just the most frequent day
sql_query = """"""
SELECT 
    TO_CHAR(ShippedDate, 'Day') AS Weekday, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
GROUP BY 
    TO_CHAR(ShippedDate, 'Day') 
ORDER BY 
    TO_CHAR(ShippedDate, 'Day')
""""""

# Execute the SQL query and retrieve the data
shipment_data = execute_sql_query(sql_query)

# Ensure correct order of weekdays
weekday_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
shipment_data['Weekday'] = pd.Categorical(shipment_data['Weekday'].str.strip(), categories=weekday_order, ordered=True)
shipment_data = shipment_data.sort_values(by='Weekday')

# Create a bar chart to visualize the distribution of shipments
fig = px.bar(shipment_data, x='Weekday', y='OrderCount', title='Distribution of Shipments Across the Week')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DAYOFWEEK(ShippedDate) AS DayOfWeek, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY DayOfWeek
ORDER BY DayOfWeek;
""""""

df_shipments = execute_sql_query(sql_query)

day_names = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
df_shipments['DayOfWeek'] = df_shipments['DayOfWeek'].apply(lambda x: day_names[x - 1])
df_shipments = df_shipments.set_index('DayOfWeek').reindex(day_names)

fig = px.bar(df_shipments, x=df_shipments.index, y='ShipmentCount', title='Shipping Distribution by Day of the Week',
             labels={'ShipmentCount': 'Number of Shipments', 'DayOfWeek': 'Day of the Week'})

show_to_user(fig)
```","Both code implementations aim to find the distribution of shipments across each day of the week and visualize it. The reference code uses TO_CHAR with day names for grouping, while the evaluated code uses DAYOFWEEK to get numeric day indices and converts them to day names. Both implementations effectively order the days from Monday to Sunday, ensuring correct visualization of shipment distribution with a bar chart. Therefore, the logic and result of both codes are aligned.","```python
import pandas as pd
import plotly.express as px

# Utility function placeholder
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function will execute the SQL query and return a DataFrame
    # Implemented elsewhere
    pass

# Utility function placeholder
def show_to_user(data):
    # This function displays the data or visualizations
    # Implemented elsewhere
    pass

# SQL query as provided
sql_query = """"""
SELECT DAYOFWEEK(OrderDate) AS DayOfWeek, COUNT(*) AS Shipments
FROM orders
GROUP BY DAYOFWEEK(OrderDate)
ORDER BY Shipments DESC;
""""""

# Execute the SQL query and get the data
df_shipments = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df_shipments,
    x='DayOfWeek',
    y='Shipments',
    title='Distribution of Shipments by Day of the Week',
    labels={'DayOfWeek': 'Day of the Week', 'Shipments': 'Number of Shipments'}
)

# Render the bar chart
show_to_user(fig)
```","The input code differs in logic and output from the reference code. The input code uses `DAYOFWEEK` on `OrderDate`, whereas the reference uses `TO_CHAR` on `ShippedDate`. The reference ensures correct ordering of days, while the input orders by shipment count. Therefore, although both codes aim to display a bar chart of shipments by day, the SQL logic and sorting differ, leading to potentially different results.",Base
What is the total sales generated by each employee for the current month? Include a bar chart to visualize the sales per employee.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by each employee for the current month
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    MONTH(orders.OrderDate) = MONTH(CURRENT_DATE) AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY 
    employees.EmployeeID, employees.FirstName, employees.LastName;
""""""

# Execute the SQL query to get data into a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    sales_data, 
    x='EmployeeName', 
    y='TotalSales', 
    title='Total Sales by Each Employee for the Current Month', 
    labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee Name'}
)

# Display the bar chart
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

current_month = datetime.now().strftime('%Y-%m')
sql_query = f""""""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    DATE_FORMAT(o.OrderDate, '%Y-%m') = '{current_month}'
GROUP BY 
    e.EmployeeID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='EmployeeName', y='TotalSales', title='Total Sales by Employee for the Current Month')
show_to_user(fig)
```","The input code correctly performs the task as described in the business analytics request and follows the same logic as the reference implementation. Both codes retrieve total sales by each employee for the current month, use appropriate SQL logic, and create a bar chart using Plotly. Differences in syntax and column labels do not affect correctness.","```python
import pandas as pd
import plotly.express as px

# SQL query for fetching the total sales generated by each employee for the current month
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE) 
AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='EmployeeID', y='total_sales', title='Total Sales by Employee for Current Month')

# Display the bar chart
show_to_user(fig)
```","The input Python code does not include the employee's name, which is part of the business analytics request and the reference implementation. It only returns the EmployeeID, not the concatenation of FirstName and LastName. Additionally, the chart labels in the reference include EmployeeName and TotalSales, while the input labels are EmployeeID and total_sales, thus not fully aligning with the reference request.",Base
Find the total sales by supplier in a specific month and present the results using a bar chart for comparison.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL query with a placeholder for the specific month
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE DATE_FORMAT(orders.OrderDate, '%Y-%m') = '2023-09' -- replace with the desired month
GROUP BY suppliers.CompanyName
""""""

# Execute the SQL query and store the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='CompanyName', y='TotalSales', title='Total Sales by Supplier for the Specific Month')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

month = '2023-01'  # Specify the month you want to analyze

sql_query = f""""""
SELECT s.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE DATE_FORMAT(o.OrderDate, '%Y-%m') = '{month}'
GROUP BY s.CompanyName
ORDER BY TotalSales DESC;
""""""

result_df = execute_sql_query(sql_query)
fig = px.bar(result_df, x='CompanyName', y='TotalSales', title='Total Sales by Supplier for January 2023', labels={'TotalSales': 'Total Sales', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly implements the same logic as the reference code to find total sales by supplier for a specific month, even though the month differs ('2023-01' vs '2023-09'). Both codes join the same tables, calculate total sales, group by supplier, and present results using a Plotly bar chart. The input also includes an 'ORDER BY TotalSales DESC' clause, which adds sorting by total sales, but it does not affect correctness or logic.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # This should connect to the database, execute the query and return the results as a DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch total sales by supplier for July 2023
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE MONTH(orders.OrderDate) = 7 AND YEAR(orders.OrderDate) = 2023
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Validate the result
if sales_data is not None and not sales_data.empty:
    # Visualize the data using a bar chart
    fig = px.bar(sales_data, x='CompanyName', y='TotalSales',
                 title='Total Sales by Supplier in July 2023',
                 labels={'TotalSales': 'Total Sales', 'CompanyName': 'Supplier'})
    show_to_user(fig)
else:
    # Handle the case where no data is available
    print(""No sales data available for July 2023."")
```","The input code correctly implements the required logic to calculate total sales by supplier for a specified month. It follows the logic of the reference code, including joining tables, filtering by month and year, and grouping by supplier. The visualization part also aligns with the reference by using Plotly to create a bar chart. Although the date filtering is done using `MONTH()` and `YEAR()` instead of `DATE_FORMAT()`, this approach is valid and equivalent for the task. Thus, the input code is correct.",both
"How does the average employee salary compare between different regions, and can we use a bar chart to visualize the differences?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average salary by region
sql_query = """"""
SELECT Region, AVG(Salary) AS AvgSalary FROM employees GROUP BY Region;
""""""

# Execute the SQL query and get a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average salary by region
fig = px.bar(df, x='Region', y='AvgSalary', title='Average Salary by Region')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate average salary by region
sql_query = """"""
SELECT Region, AVG(Salary) AS AverageSalary
FROM employees
GROUP BY Region
""""""
# Execute the SQL query and get the data
salary_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average employee salary by region
fig = px.bar(salary_data, x='Region', y='AverageSalary', title='Average Employee Salary by Region')
show_to_user(fig)
```","The input code correctly calculates the average salary by region and visualizes it using a bar chart, following the same logic as the reference implementation. Although the alias for the average salary column is different ('AverageSalary' vs 'AvgSalary'), this does not affect the correctness of the code. Both codes execute a SQL query to obtain the necessary data, create a bar chart using Plotly, and display it to the user.","```python
import pandas as pd
import plotly.express as px

def get_average_salary_per_region():
    # SQL Query to get average salary per region
    sql_query = """"""
    SELECT Region, AVG(Salary) AS AvgSalary
    FROM employees
    GROUP BY Region;
    """"""
    
    # Execute SQL query and get the data
    df = execute_sql_query(sql_query)
    
    return df

def visualize_salary_comparison(df):
    # Create a bar chart using Plotly
    fig = px.bar(df, x='Region', y='AvgSalary',
                 title='Average Employee Salary by Region',
                 labels={'AvgSalary': 'Average Salary'})
    
    # Show the bar chart to the user
    show_to_user(fig)

# Main execution
salary_data = get_average_salary_per_region()
visualize_salary_comparison(salary_data)
```","The input code correctly answers the business analytics request by executing the same SQL query to obtain the 'Region' and 'AvgSalary' data. It then creates and displays a Plotly bar chart to visualize the average salary by region. The logic and the final output match the reference implementation, fulfilling the request's requirements.",both
"What is the total quantity of products ordered in the last year, and can you provide a trend line to illustrate the changes over each month?","
import pandas as pd
import plotly.express as px

def get_monthly_product_trends():
    sql_query = """"""
    SELECT 
        DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth, 
        SUM(od.Quantity) AS TotalQuantityOrdered 
    FROM orders o 
    JOIN `Order Details` od ON o.OrderID = od.OrderID 
    WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
    GROUP BY OrderMonth 
    ORDER BY OrderMonth;
    """"""

    # Execute SQL query to get the data
    df = execute_sql_query(sql_query)

    # Create a trend line
    fig = px.line(df, x='OrderMonth', y='TotalQuantityOrdered', 
                  title='Monthly Product Order Trends for the Past Year')

    # Show the trend line to the user
    show_to_user(fig)

# Call the function
get_monthly_product_trends()
","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the date range for the last year
end_date = datetime.now()
start_date = end_date - timedelta(days=365)

# SQL query to get total quantity of products ordered grouped by month
sql_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].Quantity) AS TotalQuantity
FROM 
    orders
INNER JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a trend line visualization
fig = px.line(data, x='Month', y='TotalQuantity', title='Total Quantity of Products Ordered in Last Year')
show_to_user(fig)
```","The input code accurately replicates the logic of the reference implementation. Both snippets calculate the total product quantities ordered each month for the past year, group by month, and create a trend line for visualization. The SQL query in the input code correctly filters by the last year using datetime and timedelta, groups, and orders by month. It uses equivalent functions for the trend line creation and display, aligning with the requirements of the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch monthly data for the last year
sql_query = """"""
SELECT
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS month,
    SUM(od.Quantity) AS total_quantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY month
ORDER BY month;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mocked function for example purposes
    # Replace with actual implementation connecting to your database
    data = {
        'month': [ '2022-10', '2022-11', '2022-12', '2023-01', 
                   '2023-02', '2023-03', '2023-04', '2023-05', 
                   '2023-06', '2023-07', '2023-08', '2023-09'],
        'total_quantity': [1200, 1300, 1150, 1250, 1350, 1100, 1450, 1550, 1600, 1500, 1650, 1700]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Mocked function for example purposes
    # Replace with actual implementation to show data to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        print('Plot shown')

# Execute the query and get the data
monthly_data_df = execute_sql_query(sql_query)

# Create a trend line using Plotly
fig = px.line(monthly_data_df, x='month', y='total_quantity', 
              title='Monthly Trend of Total Quantity Ordered in the Last Year',
              labels={'total_quantity': 'Total Quantity', 'month': 'Month'})

# Display the trend line
show_to_user(fig)
```","The provided code is correct as it follows the same logic as the reference implementation. It calculates the total quantity of products ordered over each month for the last year and uses Plotly to create a trend line. The differences in table reference syntax (square brackets vs backticks) and column aliases do not affect the functionality. Both codes execute an identical SQL query, process the data in a DataFrame, and generate the required trend line with similar titles and labels.",both
How many orders were shipped on or before the required date each month? Include a line chart to visualize the monthly order counts.,"```python
import plotly.express as px
import pandas as pd

# Assume the execute_sql_query and show_to_user functions are defined elsewhere in the environment.

# SQL Query
sql_query = """"""
SELECT TO_CHAR(ShippedDate, 'YYYY-MM') AS Month, COUNT(OrderID) AS OnTimeOrders 
FROM orders 
WHERE ShippedDate <= RequiredDate 
GROUP BY TO_CHAR(ShippedDate, 'YYYY-MM');
""""""

# Execute the SQL query to get the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(df, x='Month', y='OnTimeOrders', title='On-Time Orders Per Month')

# Display the chart using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', RequiredDate) AS month,
    COUNT(OrderID) AS order_count
FROM 
    orders
WHERE 
    ShippedDate <= RequiredDate
GROUP BY 
    month
ORDER BY 
    month;
""""""

monthly_orders = execute_sql_query(sql_query)

fig = px.line(monthly_orders, x='month', y='order_count', title='Monthly Orders Shipped On or Before Required Date')
show_to_user(fig)
```","Both implementations retrieve the count of orders shipped on or before the required date, grouped by month. The reference code uses 'TO_CHAR' for date formatting, while the input code uses 'DATE_TRUNC', but both achieve similar results in terms of grouping by month. The line chart visualization is also consistent with the request.","```python
import plotly.express as px

# Assuming the utility functions are already defined:
# execute_query(sql_query: str): Executes the given SQL query and returns a pandas DataFrame.
# show_to_user(data): Displays the data or visualization to the user.

# SQL query to fetch on-time shipments grouped by month
sql_query = """"""
SELECT DATE_FORMAT(ShippedDate, '%Y-%m') AS Month, COUNT(*) AS OnTimeOrders 
FROM orders 
WHERE ShippedDate <= RequiredDate 
GROUP BY DATE_FORMAT(ShippedDate, '%Y-%m')
""""""

# Execute the SQL query to get the data
monthly_on_time_orders_df = execute_query(sql_query)

# Create a line chart using Plotly
fig = px.line(
    monthly_on_time_orders_df,
    x='Month',
    y='OnTimeOrders',
    title='Monthly Orders Shipped on or Before Required Date',
    labels={'OnTimeOrders': 'Number of On-Time Orders'}
)

# Display the line chart to the user
show_to_user(fig)
```","Both implementations execute a SQL query to count orders shipped on or before the required date, grouped by month, and create a line chart using Plotly to visualize the data. The difference in SQL syntax reflects the database systems (Oracle vs MySQL), but the logic is consistent. Therefore, the input code effectively answers the business analytics request.",both
List the top 5 products by revenue and provide a bar chart to visualize their performance.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get the top 5 products by revenue
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the data into a pandas DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 5 products by revenue
fig = px.bar(data, x='ProductID', y='TotalRevenue', title='Top 5 Products by Revenue')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    Revenue DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='Revenue', title='Top 5 Products by Revenue')
show_to_user(fig)
```","The input code correctly computes the top 5 products by revenue using a SQL query and visualizes it as a bar chart. The logic matches the reference implementation, including the computation of revenue and the presentation of results. The JOIN with the 'orders' table does not affect the correctness, as long as it does not alter the integrity of the 'Order Details'.","```python
import plotly.express as px
import pandas as pd

# Predefined utility function for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual execution logic
    pass

# Predefined utility function for displaying output
def show_to_user(data):
    # Placeholder for actual display logic
    pass

# Define SQL query
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Revenue 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID 
ORDER BY Revenue DESC 
LIMIT 5;
""""""

# Execute the SQL query and obtain results in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 products by revenue
fig = px.bar(top_products_df, x='ProductID', y='Revenue', title='Top 5 Products by Revenue')

# Display the figure to the user
show_to_user(fig)
```","The evaluated code follows the same logic as the reference implementation. It performs an SQL query to sum the revenue by multiplying unit price, quantity, and discount, grouped by ProductID, and orders by revenue in descending order to get the top 5 products. It then uses Plotly to create a bar chart to visualize this data. The difference in SQL structure does not affect the outcome and the visualization logic remains consistent.",both
What is the current total inventory value? Include a bar chart to visualize inventory value by category.,"```python
import pandas as pd
import plotly.express as px


def get_current_total_inventory_value():
    # SQL query to get the total inventory value by category
    sql_query = """"""
    SELECT CategoryID, SUM(UnitPrice * UnitsInStock) AS InventoryValue
    FROM products
    GROUP BY CategoryID;
    """"""
    
    # Execute the SQL query
    inventory_df = execute_sql_query(sql_query)
    
    # Calculate the current total inventory value
    total_inventory_value = inventory_df['InventoryValue'].sum()
    
    # Display the total inventory value
    show_to_user(pd.DataFrame({'TotalInventoryValue': [total_inventory_value]}))
    
    # Create a bar chart to visualize inventory value by category
    fig = px.bar(inventory_df, x='CategoryID', y='InventoryValue', 
                 title='Inventory Value by Category', labels={'CategoryID': 'Category ID', 'InventoryValue': 'Inventory Value'})
    
    # Show the bar chart
    show_to_user(fig)

get_current_total_inventory_value()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, 
       SUM(p.UnitPrice * p.UnitsInStock) AS TotalInventoryValue
FROM products p
WHERE p.Discontinued = 0
GROUP BY p.CategoryID
""""""

inventory_value_df = execute_sql_query(sql_query)

total_inventory_value = inventory_value_df['TotalInventoryValue'].sum()

fig = px.bar(inventory_value_df, 
             x='CategoryID', 
             y='TotalInventoryValue',
             title='Inventory Value by Category',
             labels={'CategoryID': 'Category ID', 'TotalInventoryValue': 'Total Inventory Value'})

show_to_user(fig)

total_inventory_value
```","The input code calculates the inventory value with a condition to exclude discontinued products (WHERE p.Discontinued = 0), which is not present in the reference code. This subtle difference may affect the total inventory value, and therefore, it doesn't adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function will be defined elsewhere to connect to the database and execute the query
    pass

# Function to show results to the user
def show_to_user(data):
    # This function will be defined elsewhere to handle display, e.g., using Plotly or printing a DataFrame
    pass

# SQL query to get current total inventory value
total_inventory_value_query = ""SELECT SUM(UnitPrice * UnitsInStock) AS InventoryValue FROM products;""
# Execute the SQL query to get the total inventory value
total_inventory_value_df = execute_sql_query(total_inventory_value_query)

# Show the total inventory value to the user
show_to_user(total_inventory_value_df)

# SQL query to get inventory value by category
inventory_by_category_query = """"""
SELECT CategoryID, SUM(UnitPrice * UnitsInStock) AS CategoryInventoryValue 
FROM products 
GROUP BY CategoryID;
""""""

# Execute the SQL query to get inventory value by category
inventory_by_category_df = execute_sql_query(inventory_by_category_query)

# Create a bar chart using Plotly to visualize inventory value by category
fig = px.bar(inventory_by_category_df, x='CategoryID', y='CategoryInventoryValue',
             title='Inventory Value by Category',
             labels={'CategoryID': 'Category ID', 'CategoryInventoryValue': 'Category Inventory Value'})

# Show the bar chart to the user
show_to_user(fig)
```","The provided code fulfills the business analytics request by calculating the current total inventory value and visualizing the inventory value by category using a bar chart. It adheres to the same logic as the reference implementation: first, it calculates the total inventory value using a SQL query, then obtains the inventory value grouped by category, and finally visualizes it using Plotly. The key difference is a slight variation in query structure, but it is functionally equivalent to the reference.",Finetuned
"What is the distribution of employee salaries by region, and can this be illustrated with a histogram or boxplot for better clarity?","```python
import plotly.express as px
import pandas as pd

# SQL Query to fetch necessary data
sql_query = ""SELECT employees.Region, employees.Salary FROM employees;""

# Execute SQL query and store in DataFrame
data = execute_sql_query(sql_query)

# Generate a boxplot to show the distribution of employee salaries by region using Plotly
fig = px.box(data, x=""Region"", y=""Salary"", title=""Distribution of Employee Salaries by Region"")

# Display the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Region, Salary
FROM employees
""""""

employee_data = execute_sql_query(sql_query)

fig_box = px.box(employee_data, x='Region', y='Salary', title='Employee Salary Distribution by Region')
show_to_user(fig_box)

fig_hist = px.histogram(employee_data, x='Salary', color='Region', title='Employee Salary Histogram by Region', barmode='overlay')
show_to_user(fig_hist)
```","The input code correctly addresses the business analytics request. It performs the necessary SQL query to obtain the 'Region' and 'Salary' data from the 'employees' table, which matches the reference. The code then creates a boxplot using Plotly to illustrate the distribution of employee salaries by region, fulfilling the core requirement. Furthermore, it provides an additional histogram visualization, enhancing clarity by offering another perspective on salary distribution. Thus, it adheres to the same logic as the reference implementation while adding valuable insights.","```python
import pandas as pd
import plotly.express as px

# Main function to execute the analysis and visualization
def main():
    # SQL query to get the distribution of employee salaries by region
    sql_query = """"""
    SELECT e.Region, e.Salary FROM employees e;
    """"""
    
    # Fetching the data from the database using the predefined utility function
    df = execute_sql_query(sql_query)

    # Creating a box plot to visualize the distribution of employee salaries by region
    fig = px.box(df, x='Region', y='Salary', title='Distribution of Employee Salaries by Region', points='all', color='Region')
    
    # Display the plot to the user
    show_to_user(fig)

# Execute the main function
if __name__ == ""__main__"":
    main()
```","The input Python code correctly implements the business analytics request by generating a boxplot to visualize the distribution of employee salaries by region. It uses a SQL query to extract the necessary data and Plotly Express to create the plot, similar to the reference code. The additional parameters `points='all'` and `color='Region'` in the input code provide further granularity and visual distinction, enhancing clarity without deviating from the logic or purpose of the analysis.",both
Find all employees who ship to more than three different countries and create a bar chart showing the number of countries each employee ships to.,"
import pandas as pd
import plotly.express as px

# Utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for executing an SQL query
    # In practice, this function would connect to a database and execute the query
    # For demo purposes, returning a sample DataFrame with similar structure
    data = {'EmployeeID': [1, 2, 3], 'ShipCountry': ['USA', 'Canada', 'Germany']}
    return pd.DataFrame(data)

# Example data showing more than three countries shipped by employees
# Normally this should be the result from the execute_sql_query function

# SQL query from the business request
sql_query = '''
SELECT e.EmployeeID 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
HAVING COUNT(DISTINCT o.ShipCountry) > 3;
'''

# Mock DataFrame simulating expected SQL result from the query
# Replace this with df = execute_sql_query(sql_query) in actual execution
df = pd.DataFrame({
    'EmployeeID': [101, 102, 103, 104],
    'NumCountries': [5, 4, 7, 6]
})

# Create a bar chart to show the number of countries each employee ships to
fig = px.bar(df, x='EmployeeID', y='NumCountries', 
             labels={'EmployeeID': 'Employee ID', 'NumCountries': 'Number of Countries'},
             title='Number of Countries Each Employee Ships To')

# Use utility function to display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(DISTINCT o.ShipCountry) AS CountryCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
HAVING COUNT(DISTINCT o.ShipCountry) > 3
""""""

employee_country_counts = execute_sql_query(sql_query)

fig = px.bar(employee_country_counts, x='FirstName', y='CountryCount', color='LastName',
             title='Employees Shipping to More Than Three Countries',
             labels={'CountryCount': 'Number of Countries Shipped To', 'FirstName': 'Employee First Name'})
show_to_user(fig)
```","The input code includes 'FirstName' and 'LastName' and uses them in the bar chart, which deviates from the reference implementation focusing solely on 'EmployeeID' and 'NumCountries'. Additionally, the input code adds 'color' parameter based on 'LastName', which could alter the visualization compared to the reference bar chart that only uses 'EmployeeID'. Therefore, the input does not adhere strictly to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT e.EmployeeID, COUNT(DISTINCT o.ShipCountry) AS CountriesCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID 
HAVING CountriesCount > 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(df, x='EmployeeID', y='CountriesCount', title='Number of Countries Each Employee Ships To')

# Display the result
show_to_user(fig)
```","The input code correctly executes a SQL query to retrieve employees who ship to more than three countries and creates a bar chart to visualize the number of countries each employee ships to. The logic aligns with the reference implementation by grouping employees, counting distinct shipping countries, and using a HAVING clause for filtering. The only difference is the naming of the count column 'CountriesCount', which does not affect the correctness regarding the business analytics request.",Finetuned
Which employee has the highest total sales? Please include a bar chart comparing total sales by employee.,"```python
import pandas as pd
import plotly.express as px

def find_top_sales_employee_and_visualize():
    # SQL query to retrieve total sales by employee
    sql_query = """"""
    SELECT employees.EmployeeID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
    FROM employees 
    JOIN orders ON employees.EmployeeID = orders.EmployeeID 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    GROUP BY employees.EmployeeID 
    ORDER BY TotalSales DESC;
    """"""

    # Execute SQL query and get the total sales by employee
    sales_data_df = execute_sql_query(sql_query)

    # Display a bar chart comparing total sales by employee
    fig = px.bar(sales_data_df, x='EmployeeID', y='TotalSales', title='Total Sales by Employee')
    
    # Show the figure using the utility function
    show_to_user(fig)

    # Retrieve and return the employee with the highest total sales
    top_sales_employee = sales_data_df.iloc[0]
    return top_sales_employee

# Run the function and store the result
top_sales_employee = find_top_sales_employee_and_visualize()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 1;
""""""

highest_sales_employee = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

total_sales_by_employee = execute_sql_query(sql_query_all)

fig = px.bar(total_sales_by_employee, x='EmployeeName', y='TotalSales', 
             title='Total Sales by Employee', labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code correctly addresses the business request. It calculates the total sales by each employee using SQL queries, returning the highest sales employee and visualizing the total sales by employee with a bar chart. Although the reference implementation restricts its query result to return only the top employee, the input code follows a two-step approach by retrieving all sales data for visualization and separately identifying the top employee. This approach adheres to the same logic and successfully fulfills the requirements, thus making the code functionally equivalent and correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales by employee.
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY TotalSales DESC
""""""

# Execute the SQL query.
sales_data_df = execute_sql_query(sql_query)

# Retrieve the employee with the highest total sales.
highest_sales_df = sales_data_df.head(1)

# Display the employee with the highest total sales.
show_to_user(highest_sales_df)

# Create a bar chart comparing total sales by employee.
fig = px.bar(
    sales_data_df, 
    x='EmployeeName', 
    y='TotalSales', 
    title='Total Sales by Employee',
    labels={'TotalSales': 'Total Sales', 'EmployeeName': 'Employee Name'},
    text='TotalSales'
)

# Display the bar chart.
show_to_user(fig)
```","The input code correctly answers the business analytics request by identifying the employee with the highest total sales and displaying a bar chart to compare total sales by employee. It adheres to the same logic as the reference implementation. Both implementations execute a SQL query to retrieve total sales by employee and display a bar chart. The minor difference is that the input code includes employee names in the bar chart, which is an enhancement but still in line with the request.",both
Which country has the highest number of customers? Include a bar chart to visualize the number of customers by country.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the number of customers by country
query = """"""
SELECT Country, COUNT(*) AS NumCustomers 
FROM customers 
GROUP BY Country 
ORDER BY NumCustomers DESC;
""""""
customer_data = execute_sql_query(query)

# Identify the country with the highest number of customers
highest_country = customer_data.iloc[0]

# Visualize the number of customers by country using a bar chart
fig = px.bar(customer_data, x='Country', y='NumCustomers',
             title='Number of Customers by Country',
             labels={'NumCustomers': 'Number of Customers'})

# Display the visualization
show_to_user(fig)

# Output the country with the highest number of customers
result_df = pd.DataFrame([highest_country])
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Country, COUNT(CustomerID) AS NumberOfCustomers
FROM customers
GROUP BY Country
ORDER BY NumberOfCustomers DESC
LIMIT 1
""""""

# Execute SQL query to get the country with the highest number of customers
highest_country = execute_sql_query(sql_query)

# Execute SQL query to get the number of customers by country for visualization
sql_query_all = """"""
SELECT Country, COUNT(CustomerID) AS NumberOfCustomers
FROM customers
GROUP BY Country
ORDER BY NumberOfCustomers DESC
""""""

customer_counts = execute_sql_query(sql_query_all)

# Create a bar chart for the number of customers by country
fig = px.bar(customer_counts, x='Country', y='NumberOfCustomers', title='Number of Customers by Country')

show_to_user(fig)
```","The provided code correctly implements the business analytics request. It uses a SQL query to determine the country with the highest number of customers and retrieves data to visualize the customer distribution by country with a bar chart. The code separates the queries for determining the top country and obtaining all customer counts by country, which aligns with the reference implementation's objectives. The use of COUNT(CustomerID) and ordering by NumberOfCustomers is consistent with the functionality in the reference code.","```python
import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT Country, COUNT(CustomerID) AS CustomerCount
FROM customers
GROUP BY Country 
ORDER BY CustomerCount DESC;
""""""

# Execute SQL query and retrieve data
data = execute_sql_query(sql_query)

# Generate bar chart to visualize the number of customers by country
fig = px.bar(data, x='Country', y='CustomerCount', 
             title='Number of Customers by Country',
             labels={'CustomerCount': 'Number of Customers', 'Country': 'Country'},
             template='plotly_dark')

# Display the bar chart
show_to_user(fig)
```","The input Python code is missing the step to identify and display the country with the highest number of customers. The reference code does this by selecting the first country from the result and displaying it. The bar chart creation and visualization parts are correct, but the requirement to output the specific country with the most customers is not met in the input code.",Base
"What is the revenue contribution of each supplier, and can this be visualized using a pie chart or bar graph?","
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are defined elsewhere

# SQL query to fetch supplier revenue data
sql_query = """"""
SELECT SupplierID, SUM(od.Quantity * od.UnitPrice) AS SupplierRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY SupplierID;
""""""

# Execute the SQL query and get the result as a DataFrame
supplier_revenue_df = execute_sql_query(sql_query)

# Visualize the supplier revenue contribution as a pie chart
fig = px.pie(
    supplier_revenue_df, 
    names='SupplierID', 
    values='SupplierRevenue', 
    title='Revenue Contribution by Supplier'
)

# Display the figure to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.SupplierID, 
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS Revenue
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.SupplierID
""""""
revenue_df = execute_sql_query(sql_query)

fig = px.pie(revenue_df, values='Revenue', names='SupplierID', title='Revenue Contribution by Supplier')
show_to_user(fig)
```",The input code calculates revenue differently by including discounts in the calculation (`Quantity * UnitPrice * (1 - Discount)`) compared to the reference implementation (`Quantity * UnitPrice`). This difference in logic affects the meaning of 'SupplierRevenue' as per the business analytics request.,"```python
import plotly.express as px

# SQL query to fetch revenue contribution of each supplier
sql_query = """"""
SELECT s.SupplierID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY s.SupplierID;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df_revenue = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize revenue contribution by supplier
fig = px.bar(
    df_revenue, 
    x='SupplierID', 
    y='Revenue', 
    title='Revenue Contribution by Supplier', 
    labels={'Revenue': 'Revenue', 'SupplierID': 'Supplier ID'}
)

# Display the bar chart
show_to_user(fig)
```","The input code includes the calculation of revenue with discounts, whereas the reference implementation calculates the revenue without discounts. This results in different logic, which means the input code is not an exact match for the logic of the reference implementation. Additionally, the input code uses a bar chart instead of a pie chart, although the visualization type itself is less critical to the correctness.",None
What has been the month-over-month growth in the number of orders? Please include a line chart to visualize the trend.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the ordered count per month
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month, 
       COUNT(*) AS OrderCount 
FROM orders 
GROUP BY Year, Month 
ORDER BY Year, Month;
""""""

# Execute the SQL query and load the data into a pandas DataFrame
order_data = execute_sql_query(sql_query)

# Calculate month-over-month growth
order_data['OrderCountLastMonth'] = order_data['OrderCount'].shift(1)
order_data['MoM_Growth'] = ((order_data['OrderCount'] - order_data['OrderCountLastMonth']) / 
                            order_data['OrderCountLastMonth']) * 100

# Fill NaN values with 0 for MoM Growth for the first month
order_data['MoM_Growth'].fillna(0, inplace=True)

# Create a line chart to visualize the trend
fig = px.line(order_data, x=pd.to_datetime(order_data[['Year', 'Month']].assign(DAY=1)), 
              y='MoM_Growth', 
              title='Month-over-Month Growth in Number of Orders',
              labels={'x': 'Date', 'MoM_Growth': 'MoM Growth (%)'})

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

orders_data = execute_sql_query(sql_query)

orders_data['MonthOverMonthGrowth'] = orders_data['OrderCount'].pct_change() * 100

fig = px.line(orders_data, x='OrderMonth', y='MonthOverMonthGrowth', 
              title='Month-over-Month Growth in Number of Orders', 
              labels={'MonthOverMonthGrowth': 'Growth (%)'})

show_to_user(fig)
```","The input code effectively answers the business question with the same logic as the reference implementation. It calculates the month-over-month growth of orders using the percentage change function and visualizes this trend with a line chart using Plotly. Although there are differences in SQL query syntax and slight variations in implementation, the core functionality and result align with the reference code.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a mock function simulating SQL query execution
    # In a real scenario, this would connect to a database and return a DataFrame
    # Placeholder DataFrame for demonstration
    data = {
        ""Month"": [""2023-01"", ""2023-02"", ""2023-03""],
        ""MonthOverMonthGrowth"": [10, 15, -5]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get month-over-month growth in orders
sql_query = """"""
SELECT
    DATE_FORMAT(ORDER_DATE, '%Y-%m') AS Month,
    ((COUNT(ORDER_ID) - LAG(COUNT(ORDER_ID)) OVER (ORDER BY DATE_FORMAT(ORDER_DATE, '%Y-%m'))) / NULLIF(LAG(COUNT(ORDER_ID)) OVER (ORDER BY DATE_FORMAT(ORDER_DATE, '%Y-%m'), 0)) * 100 AS MonthOverMonthGrowth
FROM
    orders
GROUP BY
    DATE_FORMAT(ORDER_DATE, '%Y-%m')
ORDER BY
    Month ASC;
""""""

# Execute the SQL query to get the DataFrame
df_growth = execute_sql_query(sql_query)

# Display the DataFrame
show_to_user(df_growth)

# Create a line chart to visualize the monthly growth trend
fig = px.line(df_growth, x='Month', y='MonthOverMonthGrowth', title='Month-over-Month Growth in Number of Orders')

# Display the line chart
show_to_user(fig)
```","The input code contains a SQL syntax error in the calculation of 'MonthOverMonthGrowth'. It incorrectly uses 'NULLIF' with only one argument. Additionally, the SQL logic for calculating the month-over-month growth involves using the LAG function, which should adjust for correct syntax and functional logic. The mock implementation of 'execute_sql_query' merely returns mock data and does not attempt such calculations. The line chart plotting is correct under the assumption that 'df_growth' contains valid data, but due to the incorrect logic in SQL, the underlying data may not reflect the desired calculation.",Base
"What is the total freight cost incurred in the past quarter, and how can it be represented visually to show cost trends over the months?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) as month,
    SUM(Freight) as total_freight 
FROM orders 
WHERE OrderDate BETWEEN DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months' AND DATE_TRUNC('quarter', CURRENT_DATE)
GROUP BY month
ORDER BY month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the data using Plotly
fig = px.line(df, x='month', y='total_freight', title='Freight Cost Trend Over the Past Quarter', 
              labels={'total_freight': 'Total Freight Cost', 'month': 'Month'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the start and end dates for the last quarter
today = datetime.today()
first_day_of_month = today.replace(day=1)
if today.month <= 3:
    last_quarter_start = first_day_of_month.replace(month=1) - timedelta(days=1)
else:
    last_quarter_start = (first_day_of_month - pd.DateOffset(months=3)).replace(day=1)
last_quarter_end = (last_quarter_start + pd.DateOffset(months=3)).replace(day=1) - timedelta(days=1)

# SQL query to get total freight cost and monthly costs
sql_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(Freight) AS TotalFreight
FROM 
    orders
WHERE 
    OrderDate BETWEEN '{last_quarter_start.date()}'
    AND '{last_quarter_end.date()}'
GROUP BY 
    Month
ORDER BY 
    Month
""""""

# Execute SQL query
freight_data = execute_sql_query(sql_query)

# Calculate total freight cost
total_freight_cost = freight_data['TotalFreight'].sum()

# Plotting the freight cost trends
fig = px.line(freight_data, x='Month', y='TotalFreight', title='Freight Cost Trends Over Last Quarter', labels={'TotalFreight': 'Total Freight Cost'})
show_to_user(fig)

total_freight_cost
```","The input code adheres to the same logic as the reference code. It calculates the total freight cost over the past quarter and visualizes the monthly trend accurately. Both codes use SQL to aggregate freight costs by month for the last quarter and utilize Plotly for visualization. Differences in SQL functions (e.g., DATE_FORMAT vs DATE_TRUNC) are due to SQL dialects, but they achieve the same grouping and aggregation outcome. The logic and outcome are aligned with the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to retrieve freight cost for the past quarter
sql_query = """"""
    SELECT SUM(Freight) AS TotalFreightCost, DATE_FORMAT(OrderDate, '%Y-%m') AS Month
    FROM orders
    WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)
    GROUP BY Month
    ORDER BY Month;
""""""

# Execute SQL query and get the result in a DataFrame
data = execute_sql_query(sql_query)

# Correct sum calculation for each month instead of total sum
monthly_sum_query = """"""
    SELECT SUM(Freight) AS TotalFreightCost, DATE_FORMAT(OrderDate, '%Y-%m') AS Month
    FROM orders
    WHERE OrderDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)
    GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
    ORDER BY Month;
""""""

# Execute revised SQL query for monthly total freight costs
monthly_data = execute_sql_query(monthly_sum_query)

# Create a line plot to show freight cost trends over the past quarter
fig = px.line(monthly_data, x='Month', y='TotalFreightCost', 
              title='Freight Cost Trends Over the Past Quarter', 
              labels={'TotalFreightCost': 'Total Freight Cost', 'Month': 'Month'})

# Display the plot to the user
show_to_user(fig)
```","The input code correctly calculates the total freight cost for each month over the past quarter, grouping by month and ordering the results. The input and reference implementation both create a line plot to visualize freight cost trends over the period. Despite some differences in the SQL dialect (e.g., DATE_FORMAT vs. DATE_TRUNC and DATE_SUB vs. INTERVAL), the logic aligns with the request and the reference implementation, achieving the same business objective.",both
"How many products are currently out of stock, and can we visualize this data using a bar graph segmented by product categories or types?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve out-of-stock products data segmented by categories
sql_query = """"""
SELECT
    categories.CategoryName,
    COUNT(products.ProductID) AS out_of_stock_products
FROM
    products
JOIN
    categories ON products.CategoryID = categories.CategoryID
WHERE
    products.UnitsInStock = 0
GROUP BY
    categories.CategoryName
""""""

# Executes the SQL query and retrieves the data
out_of_stock_data = execute_sql_query(sql_query)

# Create a bar graph to visualize the out-of-stock products by category
fig = px.bar(out_of_stock_data, 
             x='CategoryName', 
             y='out_of_stock_products', 
             title='Out-of-Stock Products by Category', 
             labels={'out_of_stock_products': 'Number of Out-of-Stock Products', 'CategoryName': 'Product Category'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, COUNT(p.ProductID) AS out_of_stock
FROM products p
WHERE p.UnitsInStock = 0
GROUP BY p.CategoryID
""""""

out_of_stock_df = execute_sql_query(sql_query)

fig = px.bar(out_of_stock_df, x='CategoryID', y='out_of_stock', 
             title='Products Out of Stock by Category',
             labels={'CategoryID': 'Product Category', 'out_of_stock': 'Products Out of Stock'})

show_to_user(fig)
```","The input code does not join the 'products' table with the 'categories' table and therefore does not use the 'CategoryName' to segment the data, unlike the reference implementation. It groups by 'CategoryID' instead, which might not accurately label the x-axis with category names as requested.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get products out of stock with categories
sql_query = """"""
SELECT CategoryName, COUNT(*) as OutOfStockCount
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
WHERE UnitsInStock = 0
GROUP BY CategoryName;
""""""

# Execute the SQL query and get the result as a DataFrame
out_of_stock_df = execute_sql_query(sql_query)

# Visualize the out-of-stock products by category using a bar graph
fig = px.bar(
    out_of_stock_df,
    x='CategoryName',
    y='OutOfStockCount',
    title='Products Out of Stock by Category',
    labels={'CategoryName': 'Category', 'OutOfStockCount': 'Number of Out of Stock Products'}
)

# Show the plot to the user
show_to_user(fig)
```","The input code accurately calculates the number of out-of-stock products and visualizes them segmented by category. The SQL query logic matches the reference by selecting products with zero stock and grouping by category to count them. The visualization uses Plotly to create a bar chart with appropriate labels and titles, consistent with the reference implementation. Although variable names differ, the essential logic of both codes is the same, so the input code is deemed correct.",Finetuned
"What is the most common customer region, and can you provide a visual representation of the distribution across regions?","```python
import pandas as pd
import plotly.express as px

# Utility function to execute an SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the logic to connect to a database and execute the query.
    # It returns a pandas DataFrame. The implementation depends on your database specifics.
    pass

# Utility function to display data or visualization results
def show_to_user(data):
    # This function displays the data. If it's a DataFrame or a Plotly fig, it handles it accordingly.
    pass

# SQL query to get the regions and their customer counts
sql_query = """"""
SELECT Region, COUNT(CustomerID) AS NumberOfCustomers 
FROM customers 
GROUP BY Region 
ORDER BY NumberOfCustomers DESC;
""""""

# Execute the query and get the data
region_data = execute_sql_query(sql_query)

# Display the data to find the most common customer region
most_common_region = region_data.iloc[0]  # Get the first entry as it is the most common
show_to_user(pd.DataFrame([most_common_region]))

# Visualization of the distribution across regions
fig = px.bar(region_data, x='Region', y='NumberOfCustomers', title='Customer Distribution by Region')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Region, COUNT(*) AS CustomerCount 
FROM customers 
GROUP BY Region 
ORDER BY CustomerCount DESC 
LIMIT 1
""""""

most_common_region = execute_sql_query(sql_query)

sql_query_distribution = """"""
SELECT Region, COUNT(*) AS CustomerCount 
FROM customers 
GROUP BY Region
""""""

distribution_data = execute_sql_query(sql_query_distribution)

fig = px.bar(distribution_data, x='Region', y='CustomerCount', title='Customer Distribution Across Regions')
show_to_user(fig)
```","The provided code correctly identifies the most common customer region by executing a SQL query that orders the regions by customer count and limits the result to the top entry, which matches the logic of obtaining the most common region. Additionally, it executes a separate query to fetch the distribution across all regions and then visualizes it using a bar chart, similar to the reference code's approach. Although it uses two separate SQL queries instead of computing the most common region within the fetched dataframe, the approach still adheres to the overall objective and logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get the region distribution
sql_query = """"""
SELECT Region, COUNT(DISTINCT CustomerID) AS CustomerCount
FROM customers
GROUP BY Region
ORDER BY CustomerCount DESC;
""""""

# Execute the SQL query and get the data
df = execute_sql_query(sql_query)

# Identify the most common customer region
most_common_region = df.iloc[0]

# Create a bar chart for the customer distribution across regions
fig = px.bar(df, x='Region', y='CustomerCount', title='Customer Distribution Across Regions')

# Display the figure and the most common region
show_to_user(fig)
show_to_user(pd.DataFrame([most_common_region]).rename(index={0: 'Most Common Region'}))
```","The input code correctly implements the request and follows the same logic as the reference code. Both versions execute an SQL query to count customers by region, sort the results to identify the most common region, and use Plotly to create a bar chart visualizing the customer distribution across regions. The main difference is the use of COUNT(DISTINCT CustomerID) in the input code, which is more precise if there are potential duplicate CustomerIDs. Both versions display the bar chart and the most common region.",both
"What are the top 5 products in terms of revenue generated, and can we visualize this with a bar chart?","```python
import plotly.express as px

# SQL query to get top 5 products by revenue
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY Revenue DESC 
LIMIT 5;
""""""

# Execute SQL query and get results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for visualizing top 5 products by revenue
fig = px.bar(df, x='ProductID', y='Revenue', title='Top 5 Products by Revenue')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalRevenue DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductID', y='TotalRevenue', 
             title='Top 5 Products by Revenue', 
             labels={'ProductID': 'Product ID', 'TotalRevenue': 'Revenue'})
show_to_user(fig)
```","The evaluated and reference implementations both aim to identify the top 5 products by revenue. Both SQL queries correctly calculate revenue using the formula: UnitPrice * Quantity * (1 - Discount). The 'LIMIT 5' clause ensures only the top 5 are considered, ordered by revenue in descending order. Although the input code includes an unnecessary JOIN with the 'orders' table, it does not affect the revenue calculation or ranking, assuming necessary joins don't alter data incorrectly. The visualizations use Plotly to create similar bar charts, differing only in label names, which is a minor difference. Thus, the input code is consistent with the reference logic and satisfies the business requirement.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT P.ProductID, SUM(OD.Quantity * OD.UnitPrice) AS Revenue 
FROM products P 
JOIN [Order Details] OD ON P.ProductID = OD.ProductID 
GROUP BY P.ProductID 
ORDER BY Revenue DESC 
LIMIT 5;
""""""

# Execute the SQL query and get the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate SQL execution
    # This should be replaced with the actual implementation
    pass

data = execute_sql_query(sql_query)

# Create a bar chart visualization using Plotly
fig = px.bar(data, x='ProductID', y='Revenue', title='Top 5 Products by Revenue')

# Show the visualization to the user
show_to_user(fig)
```","The input code does not account for discounts in the revenue calculation, which is essential to adhere to the reference logic. The reference implements this with `(1 - od.Discount)`. Without this, the revenue values in the input code may not accurately reflect the true revenue figures considering discounts, thus incorrect as per the reference logic.",Base
Find the highest freight charges for each country and visualize the results using a bar chart.,"
import pandas as pd
import plotly.express as px

# SQL query to find the highest freight charges for each country
sql_query = """"""
SELECT ShipCountry, MAX(Freight) AS MaxFreight FROM orders GROUP BY ShipCountry;
""""""

# Step 1: Execute the SQL query
df = execute_sql_query(sql_query)

# Step 2: Create a bar chart to visualize the results
fig = px.bar(df, x='ShipCountry', y='MaxFreight', title='Highest Freight Charges by Country',
             labels={'ShipCountry': 'Country', 'MaxFreight': 'Max Freight'})

# Step 3: Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Country, MAX(o.Freight) AS Highest_Freight
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.Country
""""""

highest_freight_df = execute_sql_query(sql_query)

fig = px.bar(highest_freight_df, x='Country', y='Highest_Freight', 
             title='Highest Freight Charges by Country', 
             labels={'Highest_Freight': 'Highest Freight Charges', 'Country': 'Country'})

show_to_user(fig)
```",The input code uses a different source for obtaining the data. It joins 'customers' and 'orders' tables instead of just querying the 'orders' table. This can lead to different results if there are discrepancies in the 'customers' table's 'Country' attribute or missing data. The logic and data sources do not match the reference code.,"```python
import plotly.express as px

# Step 1: Define the SQL query
sql_query = """"""
SELECT ShipCountry, MAX(Freight) AS MaxFreight 
FROM orders 
GROUP BY ShipCountry;
""""""

# Step 2: Execute the SQL query and get the results as a DataFrame
orders_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart using Plotly
fig = px.bar(orders_df, x='ShipCountry', y='MaxFreight', 
             title='Highest Freight Charges by Country', 
             labels={'ShipCountry': 'Country', 'MaxFreight': 'Max Freight'})

# Step 4: Display the figure
show_to_user(fig)
```",The input code correctly executes the SQL query to get the highest freight charges per country and then visualizes the results using a bar chart with Plotly. It follows the same logic as the reference implementation and adheres to the business requirements.,Finetuned
What is the most common city among customers with the highest lifetime value? Please include a bar chart to visualize the distribution of these customers by city.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the city with the most common customers with the highest lifetime value
sql_query = '''
SELECT customers.City 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.City 
ORDER BY SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) DESC 
LIMIT 1
'''

# Execute the SQL query to get the desired data
df_top_city = execute_sql_query(sql_query)

# Check if data is returned
if not df_top_city.empty:
    top_city = df_top_city['City'].iloc[0]

    # SQL query to get distribution of all customers by city
    sql_query_distribution = f'''
    SELECT customers.City, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) as LifetimeValue 
    FROM customers 
    JOIN orders ON customers.CustomerID = orders.CustomerID 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    GROUP BY customers.City
    ORDER BY LifetimeValue DESC
    '''

    df_city_distribution = execute_sql_query(sql_query_distribution)

    # Visualization
    fig = px.bar(df_city_distribution, x='City', y='LifetimeValue', title='Distribution of Customers by City')
    show_to_user(fig)
else:
    print(""No data returned from the query."")
```","```python
sql_query = """"""
SELECT customers.City, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS lifetime_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN customers ON orders.CustomerID = customers.CustomerID
GROUP BY customers.City
ORDER BY lifetime_value DESC
LIMIT 10
""""""

lifetime_value_df = execute_sql_query(sql_query)

most_common_city = lifetime_value_df['City'].value_counts().idxmax()
city_distribution = lifetime_value_df.groupby('City')['lifetime_value'].sum().reset_index()

import plotly.express as px

fig = px.bar(city_distribution, x='City', y='lifetime_value', title='Customer Lifetime Value by City')
show_to_user(fig)
```","The provided code incorrectly calculates the most common city. It limits the query to the top 10 cities by lifetime value rather than finding the city with the highest lifetime value. Additionally, it uses value_counts() to find the most common city without considering lifetime value calculations. The reference implementation finds the city with the highest total lifetime value and visualizes the distribution accurately. Therefore, the provided code does not adhere to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve customer cities with the highest lifetime value
sql_query = """"""
SELECT City, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalLifetimeValue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY City 
ORDER BY TotalLifetimeValue DESC;
""""""

# Execute the SQL query using the utility function and obtain the results
df = execute_sql_query(sql_query)

# Identify the most common city among customers with the highest lifetime value
# Assuming the top N cities will provide a broader view 

# Create a bar chart to visualize the distribution of customers by city
fig = px.bar(df, x='City', y='TotalLifetimeValue', 
             title='Distribution of Customers by City with Highest Lifetime Value')

# Display the bar chart to the user
show_to_user(fig)
```","The input code generates a bar chart for the overall lifetime value distribution by city, rather than identifying and highlighting the most common city with the highest lifetime value. The code does not separate or emphasize the top city. Unlike the reference implementation, it doesn't derive the single city with the highest total lifetime value and present that specifically. Instead, it presents a general distribution for multiple cities without further analysis.",None
"Which supplier provides the most expensive products on average, and can we visualize this using a bar chart to compare the average product prices across different suppliers?","```python
import plotly.express as px
import pandas as pd

# SQL Query to find average product prices by suppliers
sql_query = """"""
SELECT suppliers.CompanyName, AVG(products.UnitPrice) AS AvgPrice
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
GROUP BY suppliers.CompanyName
ORDER BY AvgPrice DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
product_prices_df = execute_sql_query(sql_query)

# Visualize the average product prices using a bar chart
fig = px.bar(product_prices_df, x='CompanyName', y='AvgPrice',
             title='Average Product Prices by Supplier',
             labels={'CompanyName': 'Supplier', 'AvgPrice': 'Average Price'},
             text='AvgPrice')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, AVG(p.UnitPrice) AS AveragePrice
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY AveragePrice DESC
""""""

supplier_avg_prices = execute_sql_query(sql_query)

fig = px.bar(supplier_avg_prices, x='CompanyName', y='AveragePrice', 
             title='Average Product Prices by Supplier', 
             labels={'CompanyName': 'Supplier', 'AveragePrice': 'Average Price'})
show_to_user(fig)
```","The input code correctly calculates the average product prices for each supplier, similar to the reference implementation, and uses Plotly to create a bar chart for visualization. The logic and SQL query are aligned, and the visualization is conducted using the same library, making the solution correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to find the average product price by supplier
sql_query = """"""
SELECT s.CompanyName, AVG(p.UnitPrice) AS AvgPrice
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
ORDER BY AvgPrice DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df_suppliers = execute_sql_query(sql_query)

# Create a bar chart to visualize the average product prices across different suppliers
fig = px.bar(df_suppliers, x='CompanyName', y='AvgPrice',
             title='Average Product Prices by Supplier',
             labels={'CompanyName': 'Supplier', 'AvgPrice': 'Average Price'},
             text_auto=True)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly follows the same logic as the reference implementation: it calculates the average product prices for each supplier using a SQL query, creates a bar chart using Plotly to display these averages, and uses similar parameters for visualization. The variable names and slight differences in function parameter usage (e.g., text='AvgPrice' vs. text_auto=True) still achieve the same end result as required by the business analytics request.",both
"How many orders were shipped late (after the required date), and can this be visualized with a bar chart showing late shipments by month?","
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are available in the environment

# SQL query to get late orders with shipment dates
sql_query = """"""
SELECT 
    OrderID, 
    ShippedDate, 
    RequiredDate 
FROM 
    orders 
WHERE 
    ShippedDate > RequiredDate;
""""""

# Executing the SQL query and storing the result in a DataFrame
late_orders_df = execute_sql_query(sql_query)

# Converting date columns to datetime format
late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])
late_orders_df['RequiredDate'] = pd.to_datetime(late_orders_df['RequiredDate'])

# Extracting month and year for visualization
late_orders_df['MonthYear'] = late_orders_df['ShippedDate'].dt.to_period('M')

# Counting late shipments by MonthYear
late_orders_by_month = late_orders_df.groupby('MonthYear').size().reset_index(name='LateOrders')

# Creating a bar chart using Plotly
fig = px.bar(late_orders_by_month, x='MonthYear', y='LateOrders', title='Late Shipments by Month')

# Displaying the bar chart using the provided utility function
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', ShippedDate) AS shipment_month,
    COUNT(*) AS late_shipments
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    shipment_month
ORDER BY 
    shipment_month;
""""""

late_shipments_df = execute_sql_query(sql_query)

fig = px.bar(late_shipments_df, x='shipment_month', y='late_shipments', 
             title='Late Shipments by Month', labels={'shipment_month': 'Month', 'late_shipments': 'Number of Late Shipments'})

show_to_user(fig)
```","The input code correctly counts the number of late shipments per month by using SQL to group by the month and extracts the number of late orders using COUNT(*). It orders the results by month and then visualizes the data with a Plotly bar chart, similar to the reference implementation. The logic aligns with the reference, achieving the same analytical goal of counting and visualizing late shipments by month.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of late shipments by month
sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.ShippedDate) AS Month,
    COUNT(*) AS LateShipments
FROM orders 
WHERE orders.ShippedDate > orders.RequiredDate 
GROUP BY Month
ORDER BY Month;
""""""

# Execute the SQL query and return a pandas DataFrame
late_shipments_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to show late shipments by month
fig = px.bar(
    late_shipments_df, 
    x='Month', 
    y='LateShipments', 
    title='Late Shipments by Month',
    labels={'LateShipments': 'Number of Late Orders', 'Month': 'Month'}
)

# Show the chart to the user
show_to_user(fig)
```","The input code correctly calculates the number of late shipments using a SQL query that groups by month and counts the orders shipped late. This matches the logic of the reference implementation, which also assesses late shipments by comparing shipment dates to required dates and groups the results by month. The use of DATE_TRUNC in the input code is equivalent to extracting the month and year via the to_period('M') method in the reference. Both codes utilize Plotly to create a bar chart, satisfying the visualization requirement.",both
"What is the fastest average shipping method based on fulfillment time, and can you visualize the average times for each method using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Assuming the utility function execute_sql_query is given
# It executes an SQL query and returns a pandas DataFrame

def get_fastest_shipping_method():
    # SQL query to get the average fulfillment time for each shipping method
    sql_query = """"""
    SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
    FROM orders
    GROUP BY ShipVia
    ORDER BY AvgFulfillmentTime ASC
    """"""
    
    # Execute the query and store the result in a DataFrame
    df = execute_sql_query(sql_query)
    
    # Determine the fastest shipping method
    fastest_method = df.iloc[0]['ShipVia']
    
    # Create a bar chart to visualize the average fulfillment times
    fig = px.bar(df, x='ShipVia', y='AvgFulfillmentTime', title='Average Fulfillment Time by Shipping Method')
    
    # Display the bar chart
    show_to_user(fig)
    
    return fastest_method

# Call the function and get the fastest shipping method
fastest_shipping_method = get_fastest_shipping_method()
print(f""The fastest average shipping method is: {fastest_shipping_method}"")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipVia
ORDER BY AvgFulfillmentTime ASC
""""""

shipping_data = execute_sql_query(sql_query)

fastest_method = shipping_data.iloc[0]

fig = px.bar(shipping_data, x='ShipVia', y='AvgFulfillmentTime', 
             title='Average Fulfillment Time by Shipping Method', 
             labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})

show_to_user(fig)
```","The input code does not return or print the fastest shipping method, unlike the reference code. While it generates the average fulfillment times and visualizes them correctly, it lacks the functionality to identify and communicate the fastest method, which is a key requirement from the business analytics request.","```python
import plotly.express as px

# SQL query to get the average fulfillment times for each shipping method
sql_query = """"""
SELECT ShipVia, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY ShipVia 
ORDER BY AvgFulfillmentTime ASC;
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Generate a bar chart visualizing the average fulfillment times for each shipping method
fig = px.bar(
    df,
    x='ShipVia',
    y='AvgFulfillmentTime',
    title='Average Fulfillment Time by Shipping Method',
    labels={'ShipVia': 'Shipping Method', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'},
    text='AvgFulfillmentTime'
)

# Display the resulting bar chart
show_to_user(fig)

# Example if information about the fastest method is needed
fastest_method = df.iloc[0]
show_to_user(f""Fastest shipping method is {fastest_method['ShipVia']} with an average time of {fastest_method['AvgFulfillmentTime']} days."")
```","The input code correctly executes an SQL query similar to the reference code, which calculates the average fulfillment time for each shipping method, and visualizes the results using a Plotly bar chart. It also identifies the fastest shipping method. While the implementation details slightly differ in the use of labels and text in the visualization, the core logic and outcomes align with the reference implementation.",Finetuned
"What is the most common shipping method for orders with late deliveries, and can you provide a visual representation of these methods?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the relevant data
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS LateCount 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY ShipVia 
ORDER BY LateCount DESC;
""""""

# Execute the SQL query
late_deliveries_df = execute_sql_query(sql_query)

# Display the data
show_to_user(late_deliveries_df)

# Visualize the most common shipping method for late deliveries
fig = px.bar(late_deliveries_df, x='ShipVia', y='LateCount', title='Late Deliveries by Shipping Method')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) AS LateDeliveries
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY ShipVia
ORDER BY LateDeliveries DESC
LIMIT 1;
""""""

most_common_shipping_method = execute_sql_query(sql_query)

sql_query_full = """"""
SELECT ShipVia, COUNT(*) AS LateDeliveries
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY ShipVia;
""""""

late_deliveries = execute_sql_query(sql_query_full)

fig = px.bar(late_deliveries, x='ShipVia', y='LateDeliveries', title='Late Deliveries by Shipping Method', labels={'ShipVia':'Shipping Method', 'LateDeliveries':'Count of Late Deliveries'})
show_to_user(fig)
```","The provided Python code meets the business analytics request by correctly identifying the most common shipping method for late deliveries. It executes a SQL query to find the shipping method with the highest number of late deliveries using 'LIMIT 1', and separately retrieves all shipping methods for visualization. Although it splits the logic across two queries (one for the most common method and one for visualization), the overall logic matches the reference implementation which does not limit the number of results but relies on ordering to determine the most common ship method visually. The visualization is correctly implemented as a bar chart using Plotly, satisfying both the question and logic requirements.","```python
import pandas as pd
import plotly.express as px

# Execute SQL query to get the most common shipping method for late deliveries
sql_query = """"""
SELECT ShipVia, COUNT(*) AS LateCount 
FROM orders 
WHERE SHIPED_DATE > RequiredDate 
GROUP BY ShipVia 
ORDER BY LateCount DESC;
""""""

# Utility function to execute the query and return the data as a pandas DataFrame
late_deliveries_df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the distribution of shipping methods for late deliveries
fig = px.bar(
    late_deliveries_df,
    x='ShipVia',
    y='LateCount',
    title='Most Common Shipping Methods for Late Deliveries',
    labels={'ShipVia': 'Shipping Method', 'LateCount': 'Number of Late Deliveries'}
)

# Show the visualization to the user
show_to_user(fig)
```",The input code has a typographical error in the SQL query: 'SHIPED_DATE' should be 'ShippedDate'. This typo would likely cause the query to fail or return incorrect results since it does not match the column name in the reference code.,Base
What is the total number of discontinued products? Please include a bar chart showing the number of discontinued products by category.,"```python
import plotly.express as px

# SQL query to get total number of discontinued products
sql_query_total = """"""
SELECT COUNT(ProductID) AS DiscontinuedProducts 
FROM products 
WHERE Discontinued = TRUE;
""""""

# SQL query to get the number of discontinued products by category
sql_query_by_category = """"""
SELECT Category, COUNT(ProductID) AS DiscontinuedProducts 
FROM products 
WHERE Discontinued = TRUE 
GROUP BY Category;
""""""

# Execute the SQL queries
total_discontinued_df = execute_sql_query(sql_query_total)
discontinued_by_category_df = execute_sql_query(sql_query_by_category)

# Display the total number of discontinued products
show_to_user(total_discontinued_df)

# Plot a bar chart of discontinued products by category using Plotly
fig = px.bar(
    discontinued_by_category_df,
    x='Category',
    y='DiscontinuedProducts',
    title='Discontinued Products by Category',
    labels={'DiscontinuedProducts': 'Number of Discontinued Products'}
)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(*) AS TotalDiscontinued,
    CategoryID
FROM 
    products
WHERE 
    Discontinued = 1
GROUP BY 
    CategoryID
""""""

discontinued_data = execute_sql_query(sql_query)

total_discontinued = discontinued_data['TotalDiscontinued'].sum()

fig = px.bar(discontinued_data, x='CategoryID', y='TotalDiscontinued', 
             title='Number of Discontinued Products by Category', 
             labels={'TotalDiscontinued': 'Number of Discontinued Products', 'CategoryID': 'Category ID'})

show_to_user(fig)

total_discontinued
```","The input code incorrectly groups by CategoryID instead of Category and uses the numeric value 1 for 'Discontinued = TRUE'. It also calculates 'total_discontinued' by summing the grouped results, which may not equal the count of all discontinued products because the reference implementation directly counts them without grouping. Additionally, it assumes that executing the query might return separate results for both 'TotalDiscontinued' and 'CategoryID', which is inconsistent with the reference logic that requires two separate queries.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the total number of discontinued products by category
sql_query = """"""
SELECT Category, COUNT(*) AS NumberOfDiscontinuedProducts
FROM products
WHERE Discontinued = 1
GROUP BY Category;
""""""

# Function to execute the SQL query and return the results as a pandas DataFrame
df = execute_sql_query(sql_query)

# Bar chart to visualize the number of discontinued products by category
fig = px.bar(df, x='Category', y='NumberOfDiscontinuedProducts', 
             title='Number of Discontinued Products by Category',
             labels={'NumberOfDiscontinuedProducts': 'Number of Discontinued Products'})

# Display the bar chart using the utility function
show_to_user(fig)
```","The input code only queries for the number of discontinued products by category, not the total count of all discontinued products. The reference code executes two queries: one for the total count of discontinued products and another for the count by category. Additionally, the input code assumes 'Discontinued = 1', which should be equivalent to 'Discontinued = TRUE', but this should be verified for consistency based on the database schema. Lastly, the input code does not include any function or line to display the total number of discontinued products as is done in the reference code.",None
"What is the average discount provided on products in order history, and can you illustrate the discounts across different product categories using a bar chart?","```python
import plotly.express as px

# SQL query to fetch the average discount
average_discount_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""

# SQL query to fetch discounts by product category
discount_by_category_query = """"""
SELECT CategoryName AS Category, AVG(Discount) AS AverageDiscount 
FROM [Order Details] od 
JOIN Products p ON od.ProductID = p.ProductID 
JOIN Categories c ON p.CategoryID = c.CategoryID 
GROUP BY CategoryName;
""""""

# Execute SQL queries
average_discount_df = execute_sql_query(average_discount_query)
discount_by_category_df = execute_sql_query(discount_by_category_query)

# Print the average discount
show_to_user(average_discount_df)

# Create a bar chart for average discount by product category
fig = px.bar(discount_by_category_df, x='Category', y='AverageDiscount',
             title='Average Discount by Product Category',
             labels={'AverageDiscount': 'Average Discount', 'Category': 'Product Category'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve discount data along with product category
sql_query = """"""
SELECT p.CategoryID, od.Discount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
""""""

# Execute the SQL query and retrieve the data
data = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = data['Discount'].mean()

# Group by category and calculate average discount per category
category_discount = data.groupby('CategoryID')['Discount'].mean().reset_index()

# Create a bar chart to illustrate the discounts across different product categories
fig = px.bar(category_discount, x='CategoryID', y='Discount', title='Average Discount by Product Category',
             labels={'CategoryID': 'Product Category ID', 'Discount': 'Average Discount'})

# Show the results
show_to_user(fig)
```","The input code calculates average discounts without considering product categories, only using CategoryID. It misses joining with the Categories table to properly group by CategoryName, which is present in the reference implementation. This affects the correctness of the reported categories in the bar chart.","```python
import pandas as pd
import plotly.express as px

# Given SQL query for average discount
sql_query_avg_discount = ""SELECT AVG(Discount) FROM [Order Details];""

# Another SQL query to get discounts by product category
sql_query_discount_by_category = """"""
SELECT p.Category, od.Discount
FROM [Order Details] od 
JOIN Products p ON od.ProductID = p.ProductID;
""""""

# Execute the SQL query to get average discount
average_discount_df = execute_sql_query(sql_query_avg_discount)

# Display the average discount
show_to_user(average_discount_df)

# Execute the query to get discount data by category
discount_by_category_df = execute_sql_query(sql_query_discount_by_category)

# Calculate the average discount per category
avg_discount_per_category_df = discount_by_category_df.groupby('Category').mean().reset_index()

# Create a bar chart using Plotly to visualize discounts by category
fig = px.bar(avg_discount_per_category_df, x='Category', y='Discount', title='Average Discount by Product Category')

# Display the bar chart
show_to_user(fig)
```","Both implementations aim to calculate the average discount and visualize it across different product categories. The main logic aligns: executing a query for the overall average discount and another for discount by category, followed by aggregation and plotting. Even though the input code calculates the average per category with pandas after fetching, the result mirrors the reference, fulfilling the business analytics request correctly.",Finetuned
List the most frequently ordered products and visualize the results using a bar chart.,"
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT od.ProductID, p.ProductName, COUNT(od.OrderID) AS OrderCount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY od.ProductID, p.ProductName
ORDER BY OrderCount DESC
LIMIT 5;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate the bar chart using Plotly
fig = px.bar(df, x='ProductName', y='OrderCount', title='Top 5 Most Frequently Ordered Products')

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 10;
""""""

# Execute the SQL query and retrieve the data
top_products_df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(top_products_df, x='ProductName', y='TotalQuantity', title='Most Frequently Ordered Products', labels={'TotalQuantity': 'Total Quantity Ordered'})
show_to_user(fig)
```","The input code counts the total quantity of products ordered, not the number of orders for each product. The business request and reference implementation focus on the frequency of orders per product, not the quantity ordered. Additionally, the input code visualizes the top 10 products, while the reference limits to the top 5 products.","```python
import plotly.express as px

# SQL query to find the most frequently ordered products
sql_query = """"""
SELECT ProductID, COUNT(*) AS OrderFrequency 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY OrderFrequency DESC;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the most frequently ordered products
fig = px.bar(data, x='ProductID', y='OrderFrequency', title='Most Frequently Ordered Products')

# Display the bar chart
show_to_user(fig)
```","The input code is not entirely correct because it only selects the ProductID and doesn't join with the 'products' table to fetch the ProductName, which is important for accurately recognizing products. Additionally, it doesn't limit the output to the top 5 most frequently ordered products, unlike the reference code.",None
What are the top selling products and which employees are associated with these sales? Include a data visualization to display this information clearly.,"```python
import pandas as pd
import plotly.express as px

# Assume these utility functions are pre-defined and available:
# execute_sql_query(sql_query: str) -> pd.DataFrame
# show_to_user(data)

def top_selling_products_with_employees():
    # SQL query to fetch top selling products and associated employees
    sql_query = '''
    SELECT [Order Details].ProductID, 
           SUM([Order Details].Quantity) AS TotalQuantity, 
           employees.EmployeeID 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    JOIN employees ON orders.EmployeeID = employees.EmployeeID 
    GROUP BY [Order Details].ProductID, employees.EmployeeID 
    ORDER BY TotalQuantity DESC 
    LIMIT 5;
    '''
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Create a plotly bar chart to visualize the top selling products and their associated employees
    fig = px.bar(df, 
                 x='ProductID', 
                 y='TotalQuantity', 
                 color='EmployeeID',
                 title='Top Selling Products and Associated Employees',
                 labels={'TotalQuantity': 'Total Quantity Sold', 'ProductID': 'Product ID', 'EmployeeID': 'Employee ID'})
    
    # Display the chart to the user
    show_to_user(fig)

# Call the function
top_selling_products_with_employees()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
LIMIT 10;
""""""

top_selling_employees = execute_sql_query(sql_query)

fig = px.bar(top_selling_employees, 
              x='TotalSales', 
              y=top_selling_employees.index, 
              orientation='h', 
              title='Top Selling Employees', 
              labels={'TotalSales': 'Total Sales', 
                      'index': 'Employees'},
              text='TotalSales')

show_to_user(fig)
```","The input code evaluates top-selling employees based on sales revenue, while the reference code focuses on top-selling products based on quantity, including associated employees. Additionally, it visualizes employees' total sales rather than products and employees.","```python
import pandas as pd
import plotly.express as px

# Constants
TOP_N = 10

# Assuming the utility function execute_sql_query exists
sql_query = f""""""
SELECT 
    products.ProductName, 
    employees.FirstName, 
    employees.LastName, 
    SUM([Order Details].Quantity) AS total_quantity 
FROM 
    [Order Details] 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    employees ON orders.EmployeeID = employees.EmployeeID 
GROUP BY 
    products.ProductID, employees.EmployeeID
ORDER BY 
    total_quantity DESC 
LIMIT {TOP_N}
""""""

# Execute the query and get the data
data = execute_sql_query(sql_query)

# Visualize the top selling products with associated employees
fig = px.bar(data, 
             x='ProductName', 
             y='total_quantity', 
             color='total_quantity', 
             hover_data=['FirstName', 'LastName'],
             title='Top Selling Products and Associated Employees',
             labels={'ProductName': 'Product Name', 'total_quantity': 'Total Quantity'},
             text='total_quantity')

fig.update_layout(xaxis_title='Product Name', yaxis_title='Total Quantity')
fig.update_traces(textposition='outside')

# Show the visualization to the user
show_to_user(fig)
```","The input code and reference implementation differ in key aspects. The input code fetches `ProductName` and employee details (`FirstName`, `LastName`), while the reference uses `ProductID` and `EmployeeID`. Additionally, the input code visualizes with `ProductName` and colors by `total_quantity`, whereas the reference uses `ProductID` and colors by `EmployeeID`. Moreover, the input code limits by 10 instead of 5. These differences mean they do not adhere to the same logic or query objectives.",None
What is the total freight cost incurred each month? Can you provide a line chart showing the monthly trends?,"```python
import pandas as pd
import plotly.express as px

# Assume the function execute_sql_query is defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation
    pass

def show_to_user(data):
    # Placeholder for actual implementation
    pass

# SQL query to get the total freight cost per month
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month, 
       SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY Year, Month;
""""""

# Execute the SQL query and return the result as a DataFrame
df = execute_sql_query(sql_query)

# Convert Year and Month to a single date column for better plotting
df['Year'] = df['Year'].astype(int)
df['Month'] = df['Month'].astype(int)
df['Date'] = pd.to_datetime(df[['Year', 'Month']].assign(DAY=1))

# Sort the DataFrame based on the Date
df.sort_values(by='Date', inplace=True)

# Create a line chart using Plotly
fig = px.line(df, x='Date', y='TotalFreight', title='Monthly Freight Cost Trend', labels={'TotalFreight': 'Total Freight Cost', 'Date': 'Month'})

# Display the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(Freight) AS Total_Freight_Cost
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

freight_data = execute_sql_query(sql_query)

fig = px.line(freight_data, x='Month', y='Total_Freight_Cost', title='Monthly Freight Cost Trends', labels={'Total_Freight_Cost': 'Total Freight Cost', 'Month': 'Month'})
show_to_user(fig)
```","The input code and reference code both address the requirement to calculate the total freight cost per month and display it in a line chart. Despite syntactical differences, such as using `DATE_FORMAT` in the input code and `EXTRACT` in the reference code, both approaches correctly aggregate the freight costs by month. The input code also orders the results by month, ensuring the line chart correctly trends over time, and effectively uses Plotly to display the chart, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total freight cost incurred each month
sql_query = '''
SELECT DATE_FORMAT(OrderDate, '%Y-%m') as OrderMonth, 
       SUM(orders.Freight) as TotalFreight
FROM orders 
GROUP BY OrderMonth;
'''

# Function to execute the SQL query and get the data
data = execute_sql_query(sql_query)

# Convert 'OrderMonth' to datetime format for better plotting
data['OrderMonth'] = pd.to_datetime(data['OrderMonth'], format='%Y-%m')

# Generate a line chart using Plotly to show the monthly freight cost trends
fig = px.line(data, x='OrderMonth', y='TotalFreight', title='Monthly Freight Cost Trends')

# Show the figure to the user
show_to_user(fig)
```","The provided input code is correct as it successfully fulfills the business analytics request by calculating the total freight cost incurred each month and produces a line chart showing the monthly trends, adhering to the same logic as the reference implementation. Both codes aggregate the freight costs by month and year, convert this to a datetime format, and plot the data over time using Plotly, which meets the requirements.",both
How many orders have a shipping delay longer than 5 days? Please include a bar chart showing the distribution of delays.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for the purpose of this example.
    # In practice, this will execute the SQL query and return a DataFrame.
    data = {
        ""OrderID"": [1, 2, 3, 4, 5],
        ""ShippedDate"": [""2023-10-01"", ""2023-10-06"", ""2023-10-10"", ""2023-10-15"", ""2023-10-20""],
        ""OrderDate"": [""2023-09-25"", ""2023-09-30"", ""2023-10-02"", ""2023-10-09"", ""2023-10-12""]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Dummy implementation for displaying data
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to determine number of long delays
sql_query = """"""
SELECT COUNT(OrderID) AS LongDelays 
FROM orders 
WHERE DATEDIFF(ShippedDate, OrderDate) > 5;
""""""

# Simulate execution of the SQL query
orders_df = execute_sql_query(sql_query)

# Calculate the delays
orders_df['ShippedDate'] = pd.to_datetime(orders_df['ShippedDate'])
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])
orders_df['Delay'] = (orders_df['ShippedDate'] - orders_df['OrderDate']).dt.days

# Filter orders with delay longer than 5 days
long_delay_orders = orders_df[orders_df['Delay'] > 5]

# Count number of long delays
long_delays_count = long_delay_orders.shape[0]

# Create a bar chart with Plotly
fig = px.bar(x=orders_df['OrderID'], y=orders_df['Delay'], labels={'x': 'Order ID', 'y': 'Delay (days)'},
             title='Distribution of Shipping Delays')

# Display the data and chart to the user
show_to_user(long_delay_orders[['OrderID', 'Delay']])
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderID,
    DATEDIFF(ShippedDate, OrderDate) AS Delay
FROM 
    orders
WHERE 
    DATEDIFF(ShippedDate, OrderDate) > 5
""""""

delayed_orders_df = execute_sql_query(sql_query)

count_delayed_orders = delayed_orders_df.shape[0]

delay_distribution = pd.DataFrame(delayed_orders_df['Delay'].value_counts()).reset_index()
delay_distribution.columns = ['Delay', 'Count']

fig = px.bar(delay_distribution, x='Delay', y='Count', title='Distribution of Shipping Delays Greater than 5 Days', labels={'Delay': 'Delay (Days)', 'Count': 'Number of Orders'})
show_to_user(fig)
```","The input code correctly calculates the number of orders with a shipping delay longer than 5 days by filtering them directly in the SQL query. It also creates a distribution of these delays using a bar chart, similar to the reference implementation. Although the methods used vary slightly, the logic aligns with the reference implementation and meets the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Assuming the utility function execute_sql_query and show_to_user are already implemented

# SQL query to get orders with a shipping delay longer than 5 days
sql_query = """"""
SELECT 
    DATEDIFF(ShippedDate, RequiredDate) AS DelayDays 
FROM 
    orders 
WHERE 
    DATEDIFF(ShippedDate, RequiredDate) > 5;
""""""

# Execute the SQL query and get the result in a DataFrame
delayed_orders_df = execute_sql_query(sql_query)

# Count the number of delayed orders
delayed_orders_count = len(delayed_orders_df)

# Print the count to the user
show_to_user(pd.DataFrame({'DelayedOrders': [delayed_orders_count]}))

# Create a bar chart to show the distribution of delays
delay_distribution = delayed_orders_df['DelayDays'].value_counts().reset_index()
delay_distribution.columns = ['DelayDays', 'OrderCount']

# Use Plotly for creating a bar chart
fig = px.bar(
    delay_distribution,
    x='DelayDays',
    y='OrderCount',
    title='Distribution of Shipping Delays Greater Than 5 Days',
    labels={'DelayDays': 'Delay in Days', 'OrderCount': 'Number of Orders'}
)

# Show the plot using the utility function
show_to_user(fig)
```","The input code is using `RequiredDate` instead of `OrderDate` for calculating delays. It assumes a different column than the reference code, leading to potentially different results. The delay calculation logic should match the logic of the reference code, which uses 'OrderDate'.",Base
"What is the on-time delivery rate for each shipping method, and can it be represented with a bar chart for better comparison?","
import pandas as pd
import plotly.express as px

# SQL query to fetch the on-time delivery rate for each shipping method
sql_query = """"""
SELECT ShipVia, 
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN OrderID END) * 100.0 / COUNT(OrderID) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipVia;
""""""

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to execute the provided SQL query
    # and return the results in a pandas DataFrame.
    pass

# Function to display data or visualization to user
def show_to_user(data):
    # This function should be implemented to accept either a pandas DataFrame
    # or Plotly figure and handle displaying the data or figure accordingly.
    pass

# Execute SQL query and retrieve results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipVia', y='OnTimeDeliveryRate', 
             title='On-Time Delivery Rate by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'})

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipVia,
    COUNT(OrderID) AS TotalOrders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    ShipVia
""""""

delivery_data = execute_sql_query(sql_query)
delivery_data['OnTimeDeliveryRate'] = delivery_data['OnTimeDeliveries'] / delivery_data['TotalOrders'] * 100

fig = px.bar(delivery_data, x='ShipVia', y='OnTimeDeliveryRate', title='On-Time Delivery Rate by Shipping Method', 
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'ShipVia': 'Shipping Method'})
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate for each shipping method and generates a bar chart for visualization. The logic used in both the reference and input implementations to determine the on-time delivery rate is the same, despite using different syntaxes for the SQL query. Both implementations calculate the percentage of orders shipped on time based on the required date, which answers the business analytics request accurately.","```python
import pandas as pd
import plotly.express as px

# Presumed utility functions based on constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would be implemented elsewhere to execute SQL and return a DataFrame
    pass

def show_to_user(data):
    # This function would be implemented to display DataFrames or Plotly figures
    pass

# SQL query to fetch the data
sql_query = """"""
SELECT 
    ShipVia, 
    SUM(CASE WHEN DATEDIFF(ShippedDate, RequiredDate) <= 0 THEN 1 ELSE 0 END) / COUNT(OrderID) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the query and fetch the data
delivery_data = execute_sql_query(sql_query)

# Create a bar chart for on-time delivery rates by shipping method
fig = px.bar(delivery_data, x='ShipVia', y='OnTimeDeliveryRate', title='On-Time Delivery Rate by Shipping Method')

# Show the bar chart to the user
show_to_user(fig)
```","The provided Python code computes the on-time delivery rate using the same logical approach as the reference implementation. Both use SQL queries to calculate on-time delivery rates by checking if shipped dates are on or before required dates, and both create a bar chart using Plotly to visualize the results. Minor differences in syntax, such as the usage of `DATEDIFF` and how the rate is calculated, do not alter the core logic or outcomes.",both
What are the total units ordered for products with stock less than 10? Please include a bar chart to display the units ordered per product.,"```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT p.ProductID, SUM(od.Quantity) AS TotalUnitsOrdered 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE p.UnitsInStock < 10 
GROUP BY p.ProductID;
""""""

# Execute the SQL query
# Assuming execute_sql_query is already properly defined in your environment
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ProductID', y='TotalUnitsOrdered', title='Total Units Ordered for Products with Stock < 10')

# Show the plot to the user - show_to_user is the utility provided
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.UnitsInStock < 10
GROUP BY p.ProductID, p.ProductName
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ProductName', y='TotalUnitsOrdered', title='Total Units Ordered for Products with Stock Less Than 10')
show_to_user(fig)
```","The input code is correct as it adheres to the business analytics request and follows the same logic as the reference implementation. Both codes query the database to find total units ordered for products with stock less than 10. The input code adds the 'ProductName' in the SQL SELECT statement and group by clause, which provides additional information without altering the correctness of the logic. The bar chart is created for 'TotalUnitsOrdered' per product, aligned with the business request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) as TotalUnitsOrdered 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE p.UnitsInStock < 10 
GROUP BY od.ProductID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalUnitsOrdered', title='Total Units Ordered for Products with Stock Less Than 10')

# Display the result to the user
show_to_user(fig)
```","The provided code correctly implements the logic as described in the business analytics request. It executes an SQL query that selects products with stock less than 10 and calculates the total units ordered for these products. The SQL query logic is equivalent to the reference implementation, though the JOIN order and the column selected for grouping differ slightly, they produce the same result. Additionally, a bar chart is created and displayed using Plotly as requested.",both
Identify the top 3 cities with the highest total revenue and present the results using a bar chart.,"```python
import plotly.express as px
import pandas as pd

# SQL query to fetch top 3 cities with the highest total revenue
sql_query = """"""
SELECT ShipCity, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipCity 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipCity', y='TotalRevenue', title='Top 3 Cities by Total Revenue')

# Display the bar chart using the utility function provided
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.City, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers AS c
JOIN orders AS o ON c.CustomerID = o.CustomerID
JOIN [Order Details] AS od ON o.OrderID = od.OrderID
GROUP BY c.City
ORDER BY TotalRevenue DESC
LIMIT 3;
""""""

top_cities_revenue = execute_sql_query(sql_query)

fig = px.bar(top_cities_revenue, x='City', y='TotalRevenue', title='Top 3 Cities with Highest Total Revenue')
show_to_user(fig)
```","Both implementations aim to identify the top 3 cities with the highest total revenue and present the results in a bar chart. The primary difference lies in the choice of tables and joins; however, the logic remains consistent. Both SQL queries perform a summation of revenue calculated from orders and order details, group by city, and order by total revenue in descending order with a limit of 3. Execution and plotting are handled similarly, thus fulfilling the business requirement accurately.","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query and obtain the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to the database, execute the query, and return a DataFrame
    # Placeholder for actual implementation
    pass

# Function to display data or visualization result
def show_to_user(data):
    # This function should handle the display of DataFrame or Plotly figures
    # Placeholder for actual implementation
    pass

# SQL query to retrieve the top 3 cities by total revenue
sql_query = """"""
SELECT ShipCity, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipCity 
ORDER BY TotalRevenue DESC 
LIMIT 3;
""""""

# Execute the query and get the results in a DataFrame
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_cities_df, x='ShipCity', y='TotalRevenue', title='Top 3 Cities by Total Revenue')

# Display the bar chart to the user
show_to_user(fig)
```","The input code uses a different SQL query that introduces an unnecessary join with the 'customers' table. This difference could potentially impact the results if there are multiple or missing entries in the join, leading to discrepancies in computing total revenue by city.",Base
How many orders were shipped after the required date? Please include a bar chart showing the number of late shipments by month.,"import pandas as pd
import plotly.express as px

# Define the SQL query based on the business requirement
sql_query = """"""
SELECT ShippedDate, RequiredDate
FROM orders
WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query and get the result as a DataFrame
late_shipments_df = execute_sql_query(sql_query)

# Convert date columns to datetime
late_shipments_df['ShippedDate'] = pd.to_datetime(late_shipments_df['ShippedDate'])
late_shipments_df['RequiredDate'] = pd.to_datetime(late_shipments_df['RequiredDate'])

# Add a 'Month' column for grouping
late_shipments_df['Month'] = late_shipments_df['ShippedDate'].dt.to_period('M')

# Group by Month and count the number of late shipments
late_shipments_by_month = late_shipments_df.groupby('Month').size().reset_index(name='LateShipmentsCount')

# Create a bar chart of late shipments by month
fig = px.bar(late_shipments_by_month, x='Month', y='LateShipmentsCount',
             title='Number of Late Shipments by Month',
             labels={'LateShipmentsCount': 'Number of Late Shipments', 'Month': 'Month'})

# Show the plot to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', ShippedDate) AS shipment_month,
    COUNT(*) AS late_shipments
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    shipment_month
ORDER BY 
    shipment_month;
""""""

late_shipments_df = execute_sql_query(sql_query)

late_shipments_count = late_shipments_df['late_shipments'].sum()
fig = px.bar(late_shipments_df, x='shipment_month', y='late_shipments', title='Number of Late Shipments by Month')

show_to_user(late_shipments_count)
show_to_user(fig)
```","The input Python code calculates the number of late shipments and groups them by month using SQL. It then generates a bar chart showing late shipments by month. This matches the logic and intent of the reference implementation, achieving the same analysis using SQL pre-processing, instead of Pandas. Both approaches generate the same intended output and visualization for the business request.","
import pandas as pd
import plotly.express as px

# SQL query to count late orders
sql_query = """"""
SELECT OrderID, ShippedDate FROM orders WHERE ShippedDate > RequiredDate;
""""""

# Execute the query and get the DataFrame
late_orders_df = execute_sql_query(sql_query)

# Convert 'ShippedDate' to datetime and extract the month-year for grouping
late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])
late_orders_df['MonthYear'] = late_orders_df['ShippedDate'].dt.to_period('M')

# Group by MonthYear and count the number of late orders
monthly_late_orders = late_orders_df.groupby('MonthYear').size().reset_index(name='LateOrders')

# Create a bar chart using Plotly
fig = px.bar(monthly_late_orders, x='MonthYear', y='LateOrders', title='Number of Late Shipments by Month')

# Show the bar chart
show_to_user(fig)
","The provided code correctly answers the business analytics request by selecting orders where the ShippedDate is greater than the RequiredDate. It groups the results by month and counts the occurrences. It then creates a bar chart showing the number of late shipments by month, similar to the reference implementation. The difference in variable names (e.g., 'MonthYear' instead of 'Month') doesn't affect the overall logic and outcome.",both
Identify the earliest and latest order dates for each customer and visualize the results using a timeline chart.,"
```python
import pandas as pd
import plotly.express as px

# Define the SQL query
query = """"""
SELECT CustomerID, MIN(OrderDate) AS FirstOrder, MAX(OrderDate) AS LastOrder 
FROM orders 
GROUP BY CustomerID;
""""""

# Execute the SQL query to retrieve data
customer_orders_df = execute_sql_query(query)

# Convert the date columns to datetime format
customer_orders_df['FirstOrder'] = pd.to_datetime(customer_orders_df['FirstOrder'])
customer_orders_df['LastOrder'] = pd.to_datetime(customer_orders_df['LastOrder'])

# Create a timeline chart for visualization
fig = px.timeline(customer_orders_df, 
                  x_start=""FirstOrder"", 
                  x_end=""LastOrder"", 
                  y=""CustomerID"", 
                  title=""Order Timeline for Each Customer"",
                  labels={""FirstOrder"": ""First Order Date"", ""LastOrder"": ""Last Order Date""})

# Display the timeline chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    o.CustomerID,
    MIN(o.OrderDate) AS EarliestOrderDate,
    MAX(o.OrderDate) AS LatestOrderDate
FROM
    orders o
GROUP BY
    o.CustomerID
""""""

customer_orders = execute_sql_query(sql_query)

fig = px.timeline(customer_orders, 
                  x_start='EarliestOrderDate', 
                  x_end='LatestOrderDate', 
                  y='CustomerID', 
                  title='Earliest and Latest Order Dates per Customer')
show_to_user(fig)
```","The input code accurately replicates the functionality and logic of the reference code. It performs the same tasks of retrieving the earliest and latest order dates for each customer using SQL, and it visualizes the results using a timeline chart in Plotly. Although variable names differ slightly ('EarliestOrderDate' vs. 'FirstOrder', 'LatestOrderDate' vs. 'LastOrder'), the logic remains consistent with the business request and reference implementation.","```python
import pandas as pd
import plotly.express as px


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Example implementation for data retrieval
    # In practice, this would execute the SQL against a database and return results in a DataFrame
    pass

def show_to_user(data):
    # Example implementation for showing data or visualization
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()


# SQL Query to get the earliest and latest order date for each customer
sql_query = """"""
SELECT CustomerID, 
       MIN(OrderDate) AS EarliestOrderDate, 
       MAX(OrderDate) AS LatestOrderDate 
FROM orders 
GROUP BY CustomerID;
""""""

# Execute the query and get data
customer_order_data = execute_sql_query(sql_query)

# Convert OrderDate columns to datetime format for visualization
customer_order_data['EarliestOrderDate'] = pd.to_datetime(customer_order_data['EarliestOrderDate'])
customer_order_data['LatestOrderDate'] = pd.to_datetime(customer_order_data['LatestOrderDate'])

# Create a timeline chart using Plotly
# For visualization purposes, melting the DataFrame to have a single 'OrderDate' column
df_melted = customer_order_data.melt(id_vars='CustomerID', 
                                     value_vars=['EarliestOrderDate', 'LatestOrderDate'], 
                                     var_name='OrderType', 
                                     value_name='OrderDate')

# Sort values for timeline plotting
df_melted.sort_values(by=['CustomerID', 'OrderDate'], inplace=True)

# Plot the timeline
fig = px.line(
    df_melted, 
    x='OrderDate', 
    y='CustomerID', 
    color='OrderType', 
    title='Customer Order Timeline'
)

# Show the plot
show_to_user(fig)
```","The input code does not adhere to the same logic as the reference implementation. The reference code uses `px.timeline` to create a timeline chart, which correctly visualizes the start and end dates per customer in a bar-like timeline format. The input code uses `px.line`, which plots lines between order dates and does not effectively represent a timeline of orders as requested. Additionally, the `melt` operation in the input code is not required and complicates the visualization.",Base
"What is the most ordered product category this year, and can you provide a bar chart to illustrate the results?","```python
import pandas as pd
import plotly.express as px

# Define your SQL query to get the most ordered product category
sql_query = """"""
SELECT categories.CategoryID, categories.CategoryName, 
       SUM([Order Details].Quantity) AS TotalOrdered 
FROM categories 
INNER JOIN products ON categories.CategoryID = products.CategoryID 
INNER JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY categories.CategoryID, categories.CategoryName 
ORDER BY TotalOrdered DESC;
""""""

# Use the utility function to execute the SQL query
df = execute_sql_query(sql_query)

# Extract the most ordered product category
most_ordered_category = df.iloc[0]

# Print the most ordered category details
print(f""The most ordered product category is {most_ordered_category['CategoryName']} ""
      f""with {most_ordered_category['TotalOrdered']} items ordered."")

# Plot a bar chart using Plotly
fig = px.bar(df, x='CategoryName', y='TotalOrdered',
             title='Most Ordered Product Categories This Year',
             labels={'TotalOrdered': 'Total Ordered', 'CategoryName': 'Category Name'})

# Show the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the current year
current_year = pd.Timestamp.now().year

# SQL query to get the most ordered product category this year
sql_query = f""""""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE YEAR(od.OrderID) = {current_year}
GROUP BY p.CategoryID
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

# Execute the SQL query and store the result in a DataFrame
most_ordered_category = execute_sql_query(sql_query)

# SQL query to get all categories with their total quantities for bar chart
sql_query_all_categories = f""""""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE YEAR(od.OrderID) = {current_year}
GROUP BY p.CategoryID
""""""

# Execute the SQL query and store the result in a DataFrame
all_categories = execute_sql_query(sql_query_all_categories)

# Create a bar chart to illustrate the total quantities of all categories
fig = px.bar(all_categories, x='CategoryID', y='TotalQuantity', title='Total Ordered Quantity by Category for {current_year}')
show_to_user(fig)
```","The input code fails to correctly answer the business analytics request. It does not retrieve the product category names and uses `CategoryID` instead of `CategoryName` in both the SQL queries and the chart. Furthermore, it filters orders based on `OrderID` which is likely a mistake; orders should be filtered by an appropriate date field, such as `OrderDate`, to represent the current year. Also, the input code only retrieves the most ordered product category by `CategoryID` without connecting it to category names or ensuring full alignment with the reference logic.","```python
import pandas as pd
import plotly.express as px

# Assuming the existence of the execute_sql_query function as defined by the environment constraints.

sql_query = """"""
SELECT categories.CategoryName,
       SUM([Order Details].Quantity) AS total_quantity_ordered
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY categories.CategoryName
ORDER BY total_quantity_ordered DESC
LIMIT 1
""""""

# Execute the SQL query
wildcard_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    wildcard_df,
    x='CategoryName',
    y='total_quantity_ordered',
    title='Most Ordered Product Category This Year',
    labels={'total_quantity_ordered': 'Total Quantity Ordered', 'CategoryName': 'Product Category'},
)

# Display the bar chart
show_to_user(fig)
```","The input code filters results based on the current year using a WHERE clause checking the order date, which is missing in the reference implementation. Additionally, the input code limits the result to the top 1 category with the LIMIT 1 clause, while the reference code doesn't limit the results. Therefore, the input code logic does not fully match the reference implementation.",None
Assess the impact of discounts on product performance and include a data visualization to illustrate trends and correlations.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation for executing SQL query
    # In a real scenario, this would interface with a database connection
    data = {
        ""ProductID"": [1, 2, 3, 4, 5],
        ""DiscountEffect"": [0.8, 0.9, 0.75, 0.85, 0.95]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to retrieve discount effect on products
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].Quantity * (1 - [Order Details].Discount)) / 
       SUM([Order Details].Quantity) AS DiscountEffect 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID;
""""""

# Execute the SQL query to get the results
df = execute_sql_query(sql_query)

# Generate a line plot to visualize the impact of discounts on product performance
fig = px.line(df, x=""ProductID"", y=""DiscountEffect"", title=""Impact of Discounts on Product Performance"")

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve product performance and discounts
sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity) AS TotalQuantity,
    SUM(od.Quantity * od.UnitPrice) AS TotalSales,
    AVG(p.UnitsInStock) AS AverageStock,
    AVG(od.Discount) AS AverageDiscount
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

product_performance_df = execute_sql_query(sql_query)

# Data visualization
fig = px.scatter(product_performance_df, 
                 x='AverageDiscount', 
                 y='TotalSales', 
                 size='TotalQuantity', 
                 color='ProductName', 
                 title='Impact of Discounts on Product Performance',
                 labels={'AverageDiscount': 'Average Discount', 'TotalSales': 'Total Sales'},
                 hover_name='ProductName')

show_to_user(fig)
```","The input Python code deviates from the reference implementation by calculating different metrics. The reference code computes a 'DiscountEffect' as the weighted average of discounts while the input code computes 'TotalSales', 'AverageStock', 'AverageDiscount', and 'TotalQuantity'. Additionally, the visualization in the reference is a line plot of 'DiscountEffect' against 'ProductID', whereas the input utilizes a scatter plot of 'TotalSales' against 'AverageDiscount', colored by 'ProductName'. These differences result in the input code not fulfilling the specific business request as outlined in the reference.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user utilities are already defined.

# SQL query to get the required data
sql_query = '''
SELECT p.ProductID, p.ProductName, p.Category, 
SUM(od.UnitPrice * od.Quantity) AS TotalRevenueImpact, 
SUM((od.UnitPrice - od.UnitPrice * od.Discount) * od.Quantity) AS RevenueWithoutDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductID, p.ProductName, p.Category
'''

# Execute the query and get a DataFrame
df = execute_sql_query(sql_query)

# Calculate additional metrics
df['DiscountImpact'] = df['TotalRevenueImpact'] - df['RevenueWithoutDiscount']

# Create a correlation heatmap for visualizing the relationship between metrics
correlation_matrix = df[['TotalRevenueImpact', 'RevenueWithoutDiscount', 'DiscountImpact']].corr()
fig = px.imshow(correlation_matrix, text_auto=True, color_continuous_scale='Blues', title=""Correlation Matrix"")

# Display the correlation heatmap
show_to_user(fig)

# Create a bar chart to display Discount Impact by Product
fig_discount_impact = px.bar(df, x='ProductName', y='DiscountImpact', title='Discount Impact by Product',
                             labels={'DiscountImpact': 'Discount Impact ($)', 'ProductName': 'Product Name'},
                             color='Category')

# Display the bar chart
show_to_user(fig_discount_impact)
```","The input code does not adhere to the same logic as the reference implementation. The reference code calculates a 'DiscountEffect' as a ratio, while the input code calculates 'DiscountImpact' as a difference. Additionally, the reference focuses on a line plot of discount effects per product, whereas the input creates a correlation heatmap and a bar chart. Hence, the method of assessing the impact of discounts and the type of visualization differ significantly.",None
"Find the products with the highest and lowest Unit Prices and their associated stock levels, and visualize the results with a bar chart.","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT ProductName, UnitsInStock FROM products 
WHERE UnitPrice = (SELECT MAX(UnitPrice) FROM products) 
UNION 
SELECT ProductName, UnitsInStock FROM products 
WHERE UnitPrice = (SELECT MIN(UnitPrice) FROM products);
""""""

# Function to execute the SQL query and return the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Example implementation (needs a real connection in practice)
    import sqlite3
    conn = sqlite3.connect('database.db')  # Connection to your database
    df = pd.read_sql_query(sql_query, conn)
    conn.close()
    return df

# Function to display data analysis or visualization results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Visualize results with a bar chart using Plotly
fig = px.bar(products_df, x='ProductName', y='UnitsInStock',
             title='Products with Highest and Lowest Unit Prices and Stock Levels',
             labels={'UnitsInStock':'Stock Levels', 'ProductName':'Product Name'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitPrice, UnitsInStock
FROM products
WHERE Discontinued = 0
ORDER BY UnitPrice ASC
LIMIT 1
UNION ALL
SELECT ProductID, ProductName, UnitPrice, UnitsInStock
FROM products
WHERE Discontinued = 0
ORDER BY UnitPrice DESC
LIMIT 1
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ProductName', y=['UnitPrice', 'UnitsInStock'], 
              title='Products with Highest and Lowest Unit Prices',
              labels={'value': 'Value', 'variable': 'Metric'},
              barmode='group')

show_to_user(fig)
```","The input code does not accurately implement the business analytics request. The reference implementation specifically selects products with the exact highest and lowest Unit Prices, using subqueries to find these max and min prices. The input code instead retrieves the lowest and highest priced products by using ORDER BY with LIMIT 1, which does not guarantee correct results if there are ties in the prices. Additionally, the input code attempts to visualize both 'UnitPrice' and 'UnitsInStock' in the same plot, whereas the reference focuses on 'UnitsInStock' as the y-axis measurement. Therefore, the logic and the output differ from the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL queries
max_price_query = ""SELECT ProductName, UnitPrice, UnitsInStock FROM products ORDER BY UnitPrice DESC LIMIT 1;""
min_price_query = ""SELECT ProductName, UnitPrice, UnitsInStock FROM products ORDER BY UnitPrice ASC LIMIT 1;""

# Execute the SQL queries
max_price_df = execute_sql_query(max_price_query)
min_price_df = execute_sql_query(min_price_query)

# Combine the results into a single DataFrame
combined_df = pd.concat([max_price_df, min_price_df], ignore_index=True)

# Create a bar chart using Plotly
fig = px.bar(
    combined_df,
    x='ProductName',
    y='UnitPrice',
    text='UnitsInStock',
    title='Products with Highest and Lowest Unit Prices',
    labels={'UnitPrice': 'Unit Price ($)', 'ProductName': 'Product Name'},
    template='plotly'
)

# Update the text properties for better visibility
fig.update_traces(textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')

# Display the figure
show_to_user(fig)
```","The input code fetches products with the highest and lowest Unit Prices but plots UnitPrice instead of UnitsInStock on the bar chart. The business request specifies visualizing stock levels, aligning with the reference code that uses `UnitsInStock` as the y-axis. Additionally, notation for title and labels in the visualization is different, indicating a deviation from the requested data presentation.",None
"Which countries have the highest number of orders in the last year, and can this be represented with a bar chart to enhance understanding?","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch data
sql_query = """"""
SELECT ShipCountry, COUNT(*) AS OrderCount 
FROM orders 
WHERE EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) - 1 
GROUP BY ShipCountry 
ORDER BY OrderCount DESC;
""""""

# Execute SQL query and get the result as a pandas DataFrame
order_data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to enhance understanding
fig = px.bar(order_data_df, 
             x='ShipCountry', 
             y='OrderCount', 
             title='Number of Orders by Country in the Last Year',
             labels={'OrderCount': 'Number of Orders', 'ShipCountry': 'Country'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, COUNT(OrderID) as OrderCount
FROM orders
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY ShipCountry
ORDER BY OrderCount DESC
""""""

order_data = execute_sql_query(sql_query)

fig = px.bar(order_data, x='ShipCountry', y='OrderCount', title='Number of Orders by Country in the Last Year', labels={'OrderCount': 'Number of Orders', 'ShipCountry': 'Country'})
show_to_user(fig)
```","The provided code uses 'DATE_SUB(CURDATE(), INTERVAL 1 YEAR)' which includes orders from the last 365 days instead of just the previous calendar year. The reference implementation uses 'EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) - 1', which correctly filters orders from the entire previous calendar year.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch countries with the highest number of orders in the last year
sql_query = """"""
    SELECT ShipCountry, COUNT(OrderID) AS OrderCount 
    FROM orders 
    WHERE OrderDate >= DATEADD(year, -1, GETDATE()) 
    GROUP BY ShipCountry 
    ORDER BY OrderCount DESC;
""""""

# Function to fetch data using the utility function
order_data = execute_sql_query(sql_query)

# Creating a bar chart using Plotly
fig = px.bar(order_data, x='ShipCountry', y='OrderCount', 
             title='Number of Orders by Country in the Last Year',
             labels={'OrderCount': 'Number of Orders', 'ShipCountry': 'Country'})

# Displaying the bar chart using the utility function
show_to_user(fig)
```","The input code uses an incorrect SQL date filtering function. The reference implementation uses EXTRACT function for exact year filtering while input code uses DATEADD and GETDATE functions which do not precisely capture the entire last year as EXTRACT does. This may lead to incorrect data being fetched and thus, the logic does not match the reference implementation correctly.",None
"What is the customer retention rate for the last quarter, and can you provide a trend line to visualize changes over the months?","
import pandas as pd
import plotly.express as px

# Define SQL query to calculate customer retention rate over the last quarter
customer_retention_query = """"""
SELECT 
    (SELECT COUNT(DISTINCT orders.CustomerID) 
     FROM orders 
     WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-12-31') / 
    (SELECT COUNT(DISTINCT orders.CustomerID) 
     FROM orders 
     WHERE orders.OrderDate < '2023-10-01') 
     AS customer_retention_rate
""""""

# Execute the query and obtain the retention rate
retention_rate_df = execute_sql_query(customer_retention_query)

# Display the retention rate to the user
show_to_user(retention_rate_df)

# Define SQL query to fetch monthly data for the trend line
trend_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS month,
    COUNT(DISTINCT orders.CustomerID) AS retained_customers
FROM 
    orders
WHERE 
    orders.OrderDate BETWEEN '2023-07-01' AND '2023-12-31'
GROUP BY 
    month
ORDER BY 
    month
""""""

# Execute the query and obtain monthly customer retention data
trend_df = execute_sql_query(trend_query)

# Calculate retention rate over months
trend_df['retention_rate'] = trend_df['retained_customers'] / trend_df['retained_customers'].iloc[0]

# Create a line plot for the trend in customer retention rate
fig = px.line(trend_df, x='month', y='retention_rate', title='Customer Retention Rate Trend Over Months')

# Display the trend line to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# Define the last quarter date range
start_date = '2023-07-01'
end_date = '2023-09-30'

# Query to calculate customer retention rate for the last quarter
retention_query = f""""""
SELECT 
    (COUNT(DISTINCT o1.CustomerID) / COUNT(DISTINCT o2.CustomerID)) AS retention_rate
FROM 
    orders o1 
JOIN 
    orders o2 ON o1.CustomerID = o2.CustomerID 
WHERE 
    o1.OrderDate BETWEEN '{start_date}' AND '{end_date}' 
    AND o2.OrderDate < '{start_date}'
""""""

# Execute the SQL query to get the retention rate
retention_rate_df = execute_sql_query(retention_query)

# Query to get monthly retention data for trend visualization
trend_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    COUNT(DISTINCT CustomerID) AS returning_customers
FROM 
    orders
WHERE 
    CustomerID IN (SELECT CustomerID FROM orders WHERE OrderDate < '2023-07-01')
    AND OrderDate >= '2023-07-01'
GROUP BY 
    month
ORDER BY 
    month
""""""

# Execute the SQL query to get trend data
trend_df = execute_sql_query(trend_query)

# Create a trend line figure
fig = px.line(trend_df, x='month', y='returning_customers', title='Customer Retention Trend', labels={'month':'Month', 'returning_customers':'Returning Customers'})

# Show the retention rate and trend line
show_to_user(retention_rate_df)
show_to_user(fig)
```","The input code calculates the retention differently than the reference code. The reference computes retention as customers in the last quarter vs. before, while the input uses overlapping date logic in a JOIN. Additionally, the trend calculation in the input focuses on 'returning' customers previously active before the last two quarters, rather than calculating the retention rate over months as the reference does. This results in a different basis and values for both retention and trend calculations.","```python
import pandas as pd
import plotly.express as px

# Utility Functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    pass

def show_to_user(data):
    # Placeholder for displaying data/visualizations
    pass

# SQL Queries
sql_query_retention_rate = """"""
    SELECT (COUNT(DISTINCT orders.CustomerID) * 1.0 / (
        SELECT COUNT(DISTINCT CustomerID) 
        FROM orders 
        WHERE OrderDate BETWEEN '<start_of_last_quarter>' AND '<end_of_last_quarter>'
    )) AS retention_rate 
    FROM orders 
    WHERE OrderDate BETWEEN '<start_of_last_quarter>' AND '<end_of_last_quarter>';
""""""

# Execute the SQL Query
retention_rate_df = execute_sql_query(sql_query_retention_rate)

# Display the Retention Rate
show_to_user(retention_rate_df)

# Trend Analysis SQL Query
sql_query_trend = """"""
    SELECT DATE_TRUNC('month', OrderDate) AS Month,
           COUNT(DISTINCT CustomerID) AS active_customers
    FROM orders
    WHERE OrderDate BETWEEN '<start_of_quarter>' AND '<end_of_quarter>'
    GROUP BY Month
    ORDER BY Month;
""""""

# Execute the Trend Analysis SQL Query
trend_df = execute_sql_query(sql_query_trend)

# Visualization with Plotly
fig = px.line(trend_df, x='Month', y='active_customers',
              title='Customer Retention Trend Over the Last Quarter',
              labels={'active_customers': 'Active Customers', 'Month': 'Month'})

# Show the trend line
show_to_user(fig)
```
","The input code uses placeholders ('<start_of_last_quarter>', '<end_of_last_quarter>') within the SQL queries and doesn’t calculate the retention rate correctly as per the reference implementation. The reference implementation correctly calculates the last quarter's retention rate and compares it with the previous period to form a rate. Furthermore, the trend analysis in the input code shows 'active_customers' rather than calculating a retention rate over the months, which also doesn't align with the reference.",None
Which region has the most sales by employees? Include a bar chart to visualize the sales distribution across regions.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function that should be implemented to run the SQL query and return a DataFrame
    pass

def show_to_user(data):
    # Placeholder function that displays data analysis or visualization results
    pass

# SQL query to get sales by region
sql_query = """"""
SELECT 
    o.ShipRegion, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS RegionSales 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
JOIN 
    employees e ON o.EmployeeID = e.EmployeeID 
GROUP BY 
    o.ShipRegion 
ORDER BY 
    RegionSales DESC;
""""""

# Execute the SQL query
region_sales_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales distribution across regions
fig = px.bar(region_sales_df, x='ShipRegion', y='RegionSales', title='Sales by Region', labels={'RegionSales': 'Total Sales', 'ShipRegion': 'Region'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.Region, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.Region
ORDER BY TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='Region', y='TotalSales', title='Sales Distribution Across Regions', labels={'TotalSales': 'Total Sales', 'Region': 'Region'})
show_to_user(fig)
```","The input Python code fulfills the business analytics request by querying sales data grouped by employee regions and visualizes it via a bar chart. Although it uses a different approach to obtain regions by joining through employees directly, it results in the same logic and output structure as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Function to create and display the requested analysis
def analyze_sales_by_region():
    # Custom SQL query
    sql_query = """"""
    SELECT region.RegionDescription, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    JOIN employees ON orders.EmployeeID = employees.EmployeeID
    JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID
    JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID
    JOIN region ON territories.RegionID = region.RegionID
    GROUP BY region.RegionDescription
    ORDER BY total_sales DESC
    """"""

    # Execute the SQL query using the utility function
    sales_data = execute_sql_query(sql_query)
    
    # Create a bar chart to visualize sales distribution across regions
    fig = px.bar(sales_data, x='RegionDescription', y='total_sales', 
                 title='Total Sales by Region',
                 labels={'RegionDescription': 'Region', 'total_sales': 'Total Sales'},
                 text='total_sales')
    
    # Show the chart to the user
    show_to_user(fig)

# Call the function to perform the analysis and visualization
analyze_sales_by_region()
```","The input code uses a different method to determine the regions, involving more joins with the 'employeeTerritories', 'territories', and 'region' tables. This deviates from the reference implementation's reliance on the 'ShipRegion' column from the 'orders' table directly, affecting how regions are defined. Consequently, the logic and data source for regions are not consistent with the reference code.",Base
"What is the total freight cost for all orders shipped to Germany, and can we visualize this with a bar chart showing monthly freight costs?","
import pandas as pd
import plotly.express as px

# SQL query to get the total freight costs for orders shipped to Germany
sql_query = """"""
SELECT 
    OrderDate, 
    Freight 
FROM 
    orders 
WHERE 
    ShipCountry = 'Germany';
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Convert OrderDate to datetime and extract month-year for grouping
df['OrderDate'] = pd.to_datetime(df['OrderDate'])
df['MonthYear'] = df['OrderDate'].dt.to_period('M')

# Group by month-year and sum the freight costs
monthly_freight_costs = df.groupby('MonthYear')['Freight'].sum().reset_index()

# Convert Period to string for plotting
monthly_freight_costs['MonthYear'] = monthly_freight_costs['MonthYear'].astype(str)

# Create a bar chart for monthly freight costs
fig = px.bar(monthly_freight_costs, x='MonthYear', y='Freight', 
             title='Monthly Freight Costs for Orders Shipped to Germany',
             labels={'Freight': 'Freight Cost', 'MonthYear': 'Month-Year'})

# Show the visualization to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# SQL query to get total freight costs for orders shipped to Germany grouped by month
sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.ShippedDate) AS month,
    SUM(o.Freight) AS total_freight
FROM 
    orders o
JOIN 
    customers c ON o.CustomerID = c.CustomerID
WHERE 
    c.Country = 'Germany'
GROUP BY 
    month
ORDER BY 
    month;
""""""

# Execute the SQL query
freight_data = execute_sql_query(sql_query)

# Create a bar chart for visualizing monthly freight costs
fig = px.bar(freight_data, x='month', y='total_freight', 
             title='Monthly Freight Costs for Orders Shipped to Germany',
             labels={'month': 'Month', 'total_freight': 'Total Freight Cost'})

# Show the result to the user
show_to_user(fig)
```","Both the reference and input code aim to calculate the total freight for shipments to Germany and visualize them by month. The input code uses SQL to group by month using the DATE_TRUNC function and sums the freight directly in the query. The reference code performs a similar task but groups and sums the data after fetching it into a DataFrame. Although the methods differ, the logic and final output are the same. Hence, the input code is correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly freight costs for orders shipped to Germany
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM ShippedDate) AS Month, 
    EXTRACT(YEAR FROM ShippedDate) AS Year, 
    SUM(Freight) AS MonthlyFreight 
FROM 
    orders 
WHERE 
    ShipCountry = 'Germany' 
GROUP BY 
    Year, Month 
ORDER BY 
    Year, Month;
""""""

# Execute the SQL query
freight_data = execute_sql_query(sql_query)

# Convert Year and Month into a single DateTime column for better plotting
freight_data['Date'] = pd.to_datetime(freight_data[['Year', 'Month']].assign(DAY=1))

# Create a bar chart for monthly freight costs
fig = px.bar(freight_data, x='Date', y='MonthlyFreight', 
             title='Monthly Freight Costs for Orders Shipped to Germany',
             labels={'MonthlyFreight': 'Freight Cost', 'Date': 'Month'},
             text='MonthlyFreight')

# Show the result to the user
show_to_user(fig)
```","The input Python code correctly addresses the business request. It executes an SQL query to get the freight costs for orders shipped to Germany aggregated by month and year and then creates a bar chart to visualize these monthly freight costs. The approach differs slightly from the reference implementation, mainly in how the date is handled, but it achieves the same output by grouping the data effectively and plotting it properly. Both versions use a similar SQL approach to filter and aggregate the data and employ Plotly Express for visualization, meeting the business requirement.",both
"What is the average order fulfillment time (in days) per month, and can this be visualized in a line chart to show trends over time?","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is treated as a datetime object
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart to visualize the average order fulfillment time per month
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Average Order Fulfillment Time per Month')

# Display the visualization
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
GROUP BY 
    OrderMonth
ORDER BY 
    OrderMonth;
""""""

average_fulfillment_time_df = execute_sql_query(sql_query)

fig = px.line(average_fulfillment_time_df, x='OrderMonth', y='AvgFulfillmentTime', 
              title='Average Order Fulfillment Time per Month (in Days)',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'OrderMonth': 'Month'})

show_to_user(fig)
```","The provided Python code correctly answers the business analytics request by calculating the average order fulfillment time per month and visualizing it in a line chart. It uses a similar SQL query structure, grouping by month and calculating the average fulfillment time using DATEDIFF. The plotting with Plotly Express is correctly set up to display the average fulfillment time per month, and although some variable names and label customizations differ, the logic and overall outcome align with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assuming the SQL query is executed and the result is returned as a pandas DataFrame
sql_query = """"""
SELECT EXTRACT(YEAR FROM orders.OrderDate) AS Year, 
       EXTRACT(MONTH FROM orders.OrderDate) AS Month, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgFulfillmentTime 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY Year, Month
""""""

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation for executing the SQL query and returning a DataFrame
    # Placeholder: This should be implemented to connect to the database
    pass

# Utility function to display the data or visualization
def show_to_user(data):
    # Implementation to display DataFrame or Plotly figure
    # Placeholder: This should be implemented to reject the output
    pass

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure DataFrame has the expected DateTime column
df['Date'] = pd.to_datetime(df[['Year', 'Month']].assign(DAY=1))

# Create a line chart to visualize the average fulfillment time per month
fig = px.line(df.sort_values('Date'),
              x='Date', 
              y='AvgFulfillmentTime', 
              title='Average Order Fulfillment Time Per Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'},
              markers=True)

# Show the figure using the utility function
show_to_user(fig)
```","The input code correctly calculates the average order fulfillment time by month, using a similar logic to the reference implementation. While the SQL syntax and query execution differ slightly (e.g., extracting Year and Month separately, then combining them to a Date), the overall logic of grouping by month and calculating averages is maintained. Additionally, the input code constructs a line chart to visualize the trend over time, aligning with the business analytics request.",both
"Which regions have the highest average order quantities, and can you provide a bar chart to visualize the results?","
import plotly.express as px

# Define the SQL query as specified
sql_query = """"""
SELECT ShipRegion, AVG([Order Details].Quantity) AS AvgQuantity
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ShipRegion
ORDER BY AvgQuantity DESC;
""""""

# Execute the SQL query to get a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average quantities by region
fig = px.bar(df, x='ShipRegion', y='AvgQuantity', 
             title='Average Order Quantities by Region', 
             labels={'ShipRegion': 'Region', 'AvgQuantity': 'Average Quantity'})

# Show the bar chart using the provided utility function
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, AVG(od.Quantity) AS AvgOrderQuantity
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
ORDER BY AvgOrderQuantity DESC;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='Region', y='AvgOrderQuantity', title='Average Order Quantities by Region', labels={'AvgOrderQuantity': 'Average Order Quantity', 'Region': 'Region'})
show_to_user(fig)
```","The input Python code is functionally equivalent to the reference implementation. It calculates the average order quantity by region using SQL, followed by the creation of a bar chart with Plotly. Both implementations use SQL JOIN operations on orders and order details tables, aggregate by region, and order the results by average quantity. The differences in SQL table aliases and column naming do not affect the correctness of the logic or the final output. The visualization is also created correctly using Plotly and displayed with a utility function, as in the reference.","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT customers.Region, AVG([Order Details].Quantity) AS AvgQuantity 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.Region 
ORDER BY AvgQuantity DESC;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(data, x='Region', y='AvgQuantity', title='Average Order Quantity by Region')

# Display the bar chart to the user
show_to_user(fig)
```","The input code evaluates the average order quantities by region using SQL, similar to the reference code. Although the tables 'customers' and the join conditions differ slightly, the logic to calculate 'AvgQuantity' grouped by the region is consistent. Both implementations sort the results by average quantity and use Plotly to create a bar chart, ensuring correct visualization of the requested analysis.",both
"Which customers have had all their orders delivered on time? Also, provide a visual representation of these customers categorized by their order frequency.","```python
import pandas as pd
import plotly.express as px

# Assuming the existence of the execute_sql_query function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation here
    pass

# SQL Query to fetch customers with all orders delivered on time
sql_query = """"""
SELECT CustomerID 
FROM orders 
GROUP BY CustomerID 
HAVING COUNT(OrderID) = COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END);
""""""

# Execute the SQL query and get the result as a DataFrame
on_time_customers_df = execute_sql_query(sql_query)

# For visualization, we first need to get the order frequency of these customers
order_frequency_query = """"""
SELECT CustomerID, COUNT(OrderID) as OrderFrequency
FROM orders
WHERE CustomerID IN (
    SELECT CustomerID 
    FROM orders 
    GROUP BY CustomerID 
    HAVING COUNT(OrderID) = COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END)
)
GROUP BY CustomerID
""""""

# Execute the query to get order frequencies
order_frequency_df = execute_sql_query(order_frequency_query)

# Create a bar plot to visualize customers by their order frequency
fig = px.bar(order_frequency_df, x='CustomerID', y='OrderFrequency', title='Order Frequency of Customers with All On-time Deliveries')

# Display the bar plot using show_to_user function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find customers with all their orders delivered on time
sql_query = """"""
SELECT CustomerID
FROM orders
GROUP BY CustomerID
HAVING SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) = COUNT(OrderID)
""""""
on_time_customers = execute_sql_query(sql_query)

# SQL query to count order frequency for those customers
customer_ids = ""', '"".join(on_time_customers['CustomerID'].tolist())
sql_query_frequency = f""""""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE CustomerID IN ('{customer_ids}')
GROUP BY CustomerID
""""""
order_frequency = execute_sql_query(sql_query_frequency)

# Visual representation of customers categorized by their order frequency
fig = px.bar(order_frequency, x='CustomerID', y='OrderCount', title='Customers with All Orders Delivered On Time',
             labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

show_to_user(fig)
```","The input code correctly identifies customers who have had all their orders delivered on time by comparing the count of all their orders against the sum of orders where shipments were on or before the required date. This aligns with the logic in the reference code. Additionally, the code computes order frequencies for these customers and visualizes them using a bar chart, which matches the intent and functionality of the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch customers with all orders delivered on time
sql_query = """"""
SELECT CustomerID 
FROM orders 
GROUP BY CustomerID 
HAVING COUNT(CASE WHEN ShippedDate <= RequiredDate THEN OrderID END) = COUNT(OrderID);
""""""

# Execute the SQL query
customers_on_time_df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not customers_on_time_df.empty:
    # Fetch customer order frequency details
    order_frequency_query = """"""
    SELECT CustomerID, COUNT(OrderID) as OrderFrequency
    FROM orders
    WHERE CustomerID IN (SELECT CustomerID 
                         FROM orders 
                         GROUP BY CustomerID 
                         HAVING COUNT(CASE WHEN ShippedDate <= RequiredDate THEN OrderID END) = COUNT(OrderID))
    GROUP BY CustomerID;
    """"""

    # Execute the query
    order_frequency_df = execute_sql_query(order_frequency_query)

    # Create a bar chart visualizing the customers by order frequency
    fig = px.bar(order_frequency_df, x='CustomerID', y='OrderFrequency', 
                 title='Customers with All Orders Delivered on Time by Order Frequency',
                 labels={'CustomerID': 'Customer ID', 'OrderFrequency': 'Order Frequency'})

    # Display the figure to the user
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({""Message"": [""No customers found with all orders delivered on time.""]}))
```","The input code correctly identifies customers whose all orders have been delivered on time by comparing the count of total orders with the count of orders delivered on time. Both implementations use the same logic in their SQL queries. The subsequent queries for order frequencies are identical, and the visualization step is similar, categorizing customers by order frequency using a bar chart. The input code adds a check for when no customers are found, which does not deviate from the requested business logic.",both
Determine if any product category consistently exceeds its reorder levels and provide a visualization to illustrate trends over time.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get data about categories exceeding reorder levels
data_df = execute_sql_query(
    """"""
    SELECT CategoryID, COUNT(*) AS ExceedCount 
    FROM products 
    WHERE UnitsInStock > ReorderLevel 
    GROUP BY CategoryID 
    HAVING COUNT(*) > 0;
    """"""
)

# Check if 'Date' column exists in the data for trend analysis
if 'Date' not in data_df.columns:
    raise ValueError(""The dataset must include a 'Date' column to analyze trends over time."")

# Adjust the query to capture data over time if possible (not done here due to assumptions)

# Generate a Plotly line chart for visualization
fig = px.line(data_df, x='Date', y='ExceedCount', color='CategoryID',
              title='Trends of Categories Exceeding Reorder Levels Over Time')

# Display the visualization
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID,
    MONTH(o.OrderDate) AS Month,
    YEAR(o.OrderDate) AS Year,
    SUM(od.Quantity) AS TotalOrdered,
    SUM(p.UnitsInStock) AS TotalStock,
    SUM(p.ReorderLevel) AS TotalReorderLevel
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.CategoryID, MONTH(o.OrderDate), YEAR(o.OrderDate)
HAVING 
    SUM(p.UnitsInStock) < SUM(p.ReorderLevel)
ORDER BY 
    Year, Month
""""""

data = execute_sql_query(sql_query)

if not data.empty:
    summary = data.groupby(['Year', 'Month', 'CategoryID']).agg({'TotalOrdered': 'sum', 'TotalStock': 'sum', 'TotalReorderLevel': 'sum'}).reset_index()
    fig = px.line(summary, x='Month', y='TotalStock', color='CategoryID', 
                  title='Stock Levels vs Reorder Levels Over Time', 
                  labels={'TotalStock': 'Total Stock', 'Month': 'Month'})
    show_to_user(fig)
```","The input code's SQL query calculates the SUM of UnitsInStock and ReorderLevel over months and years, using HAVING SUM(UnitsInStock) < SUM(ReorderLevel). However, it should focus on individual instances where UnitsInStock > ReorderLevel as in the reference code. Additionally, it groups and plots TotalStock over time, which doesn't align with the request to plot counts of instances exceeding reorder levels. The reference implementation directly checks if UnitsInStock exceeds ReorderLevel per product without aggregation over time in the SQL query.","```python
import pandas as pd
import plotly.express as px

# Assume utility function definitions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function to simulate SQL execution
    pass

def show_to_user(data):
    # Dummy function to display data or figure
    pass

# SQL query to get products with consistent 'UnitsInStock' greater than 'ReorderLevel'
sql_query = """"""
SELECT ProductCategory, OrderMonth, COUNT(*) as OverThresholdCount 
FROM (
    SELECT ProductCategory, STRFTIME('%Y-%m', OrderDate) AS OrderMonth
    FROM products
    WHERE UnitsInStock > ReorderLevel
) AS Subquery 
GROUP BY ProductCategory, OrderMonth;
""""""

# Execute the SQL query to get the DataFrame
df = execute_sql_query(sql_query)

# Ensure data is sorted by ProductCategory and OrderMonth for proper visualization
df = df.sort_values(by=['ProductCategory', 'OrderMonth'])

# Create a line plot to visualize trends over time
fig = px.line(
    df,
    x='OrderMonth',
    y='OverThresholdCount',
    color='ProductCategory',
    title='Trends of Product Categories Exceeding Reorder Levels Over Time',
    labels={'OrderMonth': 'Order Month', 'OverThresholdCount': 'Count of Instances'}
)

# Display the plot to the user
show_to_user(fig)
```","The input code and the reference code differ in the way they determine if a product category consistently exceeds reorder levels. The reference code groups data by CategoryID and counts instances where the stock exceeds reorder levels, whereas the input code checks each product category by OrderMonth. Additionally, the input code assumes the presence of OrderDate to compute OrderMonth but doesn't check for its existence, unlike the reference code which checks for a 'Date' column. The logic and approach to data aggregation is not consistent with the reference implementation.",None
"Which product generated the highest total sales revenue, and can you provide a bar chart to visualize the comparison among all products?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales for each product
sql_query = """"""
SELECT [Order Details].ProductID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
GROUP BY [Order Details].ProductID 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Determine the product with the highest total sales revenue
highest_sales_product = sales_data.iloc[0]

# Prepare bar chart to visualize total sales revenue comparison among all products
fig = px.bar(sales_data, x='ProductID', y='TotalSales', 
             title='Total Sales Revenue by Product', 
             labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales Revenue'})

# Use the utility function to display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)

highest_sales_product = sales_data.iloc[0]

fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Total Sales Revenue by Product')
show_to_user(fig)
```","The input code correctly calculates the total sales revenue for each product by using a SUM aggregation over UnitPrice, Quantity, and Discount from the Order Details table, grouped by ProductID. The SQL query structure matches the reference implementation logic. Although an additional JOIN clause is present, it does not affect the results since the reference implementation does not require specific filtering or additional columns from the orders table. The code correctly ranks products based on total sales in descending order and uses Plotly Express to generate a bar chart that visualizes the total sales revenue, aligning with the business analytics request.","```python
import plotly.graph_objs as go

# SQL query to fetch product sales data in descending order
sql_query = """"""
SELECT ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSalesRevenue
FROM [Order Details] od
GROUP BY ProductID
ORDER BY TotalSalesRevenue DESC;
""""""

# Function to execute the SQL query and fetch the results
sales_data_df = execute_sql_query(sql_query)

# Extract the product with the highest total sales revenue
highest_revenue_product = sales_data_df.head(1)

# Create a bar chart to visualize the total sales revenue of all products
fig = go.Figure(
    data=[
        go.Bar(x=sales_data_df['ProductID'], y=sales_data_df['TotalSalesRevenue'])
    ],
    layout=go.Layout(
        title='Total Sales Revenue by Product',
        xaxis_title='Product ID',
        yaxis_title='Total Sales Revenue'
    )
)

# Display the bar chart using the utility function
show_to_user(fig)
```","The input Python code accurately executes the SQL query to calculate total sales revenue for each product in descending order, similar to the reference code. It identifies the product with the highest sales and uses Plotly to visualize the data with a bar chart. Though it uses a different module within Plotly, the logic and outcome remain consistent with the business analytics request and the reference implementation.",both
What is the highest freight cost recorded in the database? Please include a visualization showing freight cost distribution.,"```python
import pandas as pd
import plotly.express as px

# Define SQL query to get the highest freight cost
sql_query_max_freight = ""SELECT MAX(Freight) AS max_freight FROM orders;""

# Execute the SQL query and store the returned DataFrame
max_freight_df = execute_sql_query(sql_query_max_freight)

# Display the highest freight cost to the user
show_to_user(max_freight_df)

# Define SQL query to get all freight costs
sql_query_all_freight = ""SELECT Freight FROM orders;""

# Execute the SQL query and store the returned DataFrame
freight_df = execute_sql_query(sql_query_all_freight)

# Visualize the freight cost distribution
fig = px.histogram(freight_df, x='Freight', title='Freight Cost Distribution')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the highest freight cost and freight cost distribution
sql_query = """"""
SELECT Freight
FROM orders
""""""
freight_data = execute_sql_query(sql_query)

# Highest freight cost
highest_freight_cost = freight_data['Freight'].max()

# Visualization of freight cost distribution
fig = px.histogram(freight_data, x='Freight', title='Freight Cost Distribution')
show_to_user(fig)

highest_freight_cost
```","The input code retrieves all freight costs from the database and calculates the maximum using the Pandas `max()` function. This approach achieves the same goal as the reference code which uses an SQL query to get the maximum directly. Both implementations correctly calculate the highest freight cost. Additionally, both codes use Plotly to visualize the distribution of freight costs, matching the logic of the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the maximum freight cost
sql_query_max_freight = ""SELECT MAX(Freight) AS Max_Freight FROM orders;""
max_freight_df = execute_sql_query(sql_query_max_freight)

# SQL query to retrieve all freight costs for distribution analysis
sql_query_freight_distribution = ""SELECT Freight FROM orders;""
freight_df = execute_sql_query(sql_query_freight_distribution)

# Visualization of freight cost distribution using Plotly
fig = px.histogram(freight_df, x='Freight', title='Freight Cost Distribution', labels={'Freight':'Freight Cost'}, nbins=50)

# Display the maximum freight cost and the distribution plot
show_to_user(max_freight_df)
show_to_user(fig)
```","The input code correctly follows the same logic as the reference implementation. It retrieves the maximum freight cost and all freight costs for visualization, using SQL queries that essentially match those in the reference code. The visualization of freight cost distribution is also handled similarly, with the addition of setting a label and number of bins, which doesn't deviate from the request. Thus, the code answers the business question accurately and adheres to the reference implementation's logic.",both
"What is the total discount given on all orders, and can you provide a visual representation of discount distribution across different order categories or time periods?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query_total_discount = '''
SELECT 
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM 
    [Order Details] od;
'''

sql_query_discount_distribution = '''
SELECT 
    od.OrderID, 
    (od.UnitPrice * od.Quantity * od.Discount) AS Discount,
    o.OrderDate,
    c.CategoryName
FROM 
    [Order Details] od
JOIN 
    Orders o ON od.OrderID = o.OrderID
JOIN
    [Order Details Extended] et ON od.OrderID = et.OrderID AND od.ProductID = et.ProductID
JOIN
    Categories c ON et.CategoryID = c.CategoryID;
'''

# Execute the SQL query to get the total discount
discount_df = execute_sql_query(sql_query_total_discount)

# Display the total discount to the user
show_to_user(discount_df)

# Execute the SQL query to get the discount distribution data
distribution_df = execute_sql_query(sql_query_discount_distribution)

# Create visualization for discount distribution by order categories
fig_category = px.box(distribution_df, 
                      x=""CategoryName"", 
                      y=""Discount"", 
                      title=""Discount Distribution by Order Categories"")

# Show category distribution fig
show_to_user(fig_category)

# Create visualization for discount distribution over time
fig_time = px.box(distribution_df, 
                  x=""OrderDate"", 
                  y=""Discount"", 
                  title=""Discount Distribution over Time"")

# Show time distribution fig
show_to_user(fig_time)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total discount and order details
sql_query = """"""
SELECT 
    orders.OrderDate,
    SUM([Order Details].Discount * [Order Details].Quantity) AS TotalDiscount,
    products.CategoryID
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN 
    products ON [Order Details].ProductID = products.ProductID
GROUP BY 
    orders.OrderDate, products.CategoryID
""""""
discount_data = execute_sql_query(sql_query)

total_discount = discount_data['TotalDiscount'].sum()

# Visual representation: Total Discount by Date and Category
fig = px.bar(discount_data, 
             x='OrderDate', 
             y='TotalDiscount', 
             color='CategoryID', 
             title='Total Discount Distribution Across Order Categories and Time Periods',
             labels={'TotalDiscount': 'Total Discount', 'OrderDate': 'Order Date'})
show_to_user(fig)
```","The evaluated code incorrectly calculates the total discount. It groups by both OrderDate and CategoryID, using SUM([Order Details].Discount * [Order Details].Quantity) for individual rows, failing to account for UnitPrice in the discount calculation. The reference implementation correctly uses the formula UnitPrice * Quantity * Discount to calculate the total discount per order detail. Moreover, the plot divides the data by OrderDate and CategoryID, but misses separating category information which is done in the reference using joins with 'Categories'. The evaluated code thus deviates from the intended calculation and grouping logic provided in the reference.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total discount
sql_query_total_discount = """"""
SELECT SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM [Order Details] od;
""""""

# Execute the SQL query to get the total discount
total_discount_df = execute_sql_query(sql_query_total_discount)

# Display total discount to user
show_to_user(total_discount_df)

# SQL query to get order discount details for visualization
sql_query_discount_distribution = """"""
SELECT 
    o.Category AS OrderCategory, 
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS CategoryDiscount, 
    DATE_PART('month', o.OrderDate) AS OrderMonth
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.Category, OrderMonth
ORDER BY 
    OrderMonth;
""""""

# Execute the SQL query for distribution data
discount_distribution_df = execute_sql_query(sql_query_discount_distribution)

# Create a line plot for discount distribution over months across categories
fig = px.line(
    discount_distribution_df,
    x='OrderMonth',
    y='CategoryDiscount',
    color='OrderCategory',
    labels={
        'OrderMonth': 'Month',
        'CategoryDiscount': 'Discount Amount',
        'OrderCategory': 'Order Category'
    },
    title='Discount Distribution Across Order Categories by Month'
)

# Display the visualization to the user
show_to_user(fig)
```","The input code does not adhere to the same logic as the reference code. The reference code calculates a distribution of discounts over time and by category using a detailed order item table, and visualizes this data using box plots. The input code, on the other hand, performs aggregations by months and categories using a line plot, which is not the same analytical approach. Additionally, it uses a different method for extracting categories and dates, which could lead to inconsistencies with the reference's intended logic.",None
"Which region has the lowest on-time delivery rate this quarter, and can you provide a comparative bar chart to illustrate the rates across all regions?","```python
import pandas as pd
import plotly.express as px

# SQL query to get on-time delivery rates for all regions
sql_query = """"""
SELECT ShipRegion, COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID) AS OnTimeRate
FROM orders
WHERE OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE)
GROUP BY ShipRegion
""""""

# Execute the SQL query and fetch the data into a DataFrame
regions_df = execute_sql_query(sql_query)

# Find the region with the lowest on-time delivery rate
lowest_on_time_region = regions_df.nsmallest(1, 'OnTimeRate')

# Create a comparative bar chart for on-time delivery rates across all regions
fig = px.bar(regions_df, x='ShipRegion', y='OnTimeRate', 
             title='On-Time Delivery Rates by Region for the Current Quarter',
             labels={'OnTimeRate': 'On-Time Delivery Rate (%)', 'ShipRegion': 'Region'})

# Display the comparative bar chart
show_to_user(fig)

# Also, display the region with the lowest on-time rate to the user
show_to_user(lowest_on_time_region)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipRegion,
       COUNT(OrderID) AS TotalOrders,
       SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries,
       (SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) * 1.0 / COUNT(OrderID)) AS OnTimeDeliveryRate
FROM orders
WHERE OrderDate >= DATE_FORMAT(NOW() - INTERVAL DAYOFMONTH(NOW()) - 1 DAY, '%Y-%m-01') 
      AND OrderDate < DATE_FORMAT(NOW() + INTERVAL 1 MONTH, '%Y-%m-01')
GROUP BY ShipRegion
ORDER BY OnTimeDeliveryRate;
""""""

result_df = execute_sql_query(sql_query)

lowest_on_time_region = result_df.iloc[0]

fig = px.bar(result_df, 
              x='ShipRegion', 
              y='OnTimeDeliveryRate', 
              title='On-time Delivery Rates by Region',
              labels={'OnTimeDeliveryRate': 'On-time Delivery Rate', 'ShipRegion': 'Region'})
show_to_user(fig)

lowest_on_time_region
```","The input Python code deviates from the reference implementation in its method of determining the current quarter. The reference code uses `DATE_TRUNC('quarter', CURRENT_DATE)` to ensure it selects data from the current quarter, whereas the input code calculates the start of the month and adjusts it to potentially get the current month. Additionally, the reference implementation correctly calculates the on-time delivery rate simply using a single expression without separate aggregation functions like `SUM` for `OnTimeDeliveries`. These differences could lead to different data being fetched and, as a result, incorrect analysis. Moreover, the input code ends by only showing the lowest region in the standard output, whereas the reference code uses a function to display it, which may be necessary in a specific system or environment.","```python
import pandas as pd
import plotly.express as px

# SQL query to get on-time delivery rates per region
sql_query = """"""
SELECT ShipRegion AS region,
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID) AS on_time_rate
FROM orders
WHERE OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE) AND OrderDate < CURRENT_DATE
GROUP BY ShipRegion
ORDER BY on_time_rate ASC
""""""

# Executing the SQL query
df = execute_sql_query(sql_query)

# Finding the region with the lowest on-time delivery rate
lowest_on_time_region = df.iloc[0]
show_to_user(lowest_on_time_region)

# Creating a comparative bar chart for on-time delivery rates across all regions
fig = px.bar(df, x='region', y='on_time_rate', 
             title='On-Time Delivery Rates by Region for Current Quarter',
             labels={'on_time_rate': 'On-Time Delivery Rate', 'region': 'Region'},
             text='on_time_rate')

# Show the bar chart to the user
show_to_user(fig)
```","The input code uses a condition 'WHERE OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE) AND OrderDate < CURRENT_DATE' which is unnecessary and potentially incorrect. The reference code correctly truncates the date to start of the quarter alone. Moreover, the order of querying (`ORDER BY on_time_rate ASC`) is an unnecessary step for solving the original task.",None
Which customers have placed the most orders with a discount? Include a bar chart ranking the customers by the number of discounted orders.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT o.CustomerID, COUNT(DISTINCT o.OrderID) AS DiscountedOrders 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE od.Discount > 0 
GROUP BY o.CustomerID 
ORDER BY DiscountedOrders DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
discounted_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize discounted orders by customer
fig = px.bar(discounted_orders_df, 
             x='CustomerID', 
             y='DiscountedOrders', 
             title='Customers with the Most Discounted Orders', 
             labels={'DiscountedOrders': 'Number of Discounted Orders'},
             text_auto=True)

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.CustomerID, COUNT(o.OrderID) AS DiscountedOrders
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount > 0
GROUP BY o.CustomerID
ORDER BY DiscountedOrders DESC
""""""

discounted_orders_df = execute_sql_query(sql_query)

fig = px.bar(discounted_orders_df, x='CustomerID', y='DiscountedOrders', 
             title='Customers with Most Discounted Orders', 
             labels={'DiscountedOrders': 'Number of Discounted Orders', 'CustomerID': 'Customer ID'})

show_to_user(fig)
```","The input code incorrectly uses `COUNT(o.OrderID)` instead of `COUNT(DISTINCT o.OrderID)`. This means it counts every order line with a discount separately, rather than distinct orders. The reference code correctly uses `COUNT(DISTINCT o.OrderID)` to count unique orders with discounts. Everything else in the input matches the logic of the reference code.","```python
import pandas as pd
import plotly.express as px

# Assuming the utility functions are already implemented
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for the sake of completeness
    # This would be replaced with actual database connection and execution logic
    data = {
        'CustomerID': [1, 2, 3],
        'DiscountedOrders': [10, 8, 5]
    }
    return pd.DataFrame.from_dict(data)

def show_to_user(data):
    # Dummy implementation for the sake of completeness
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query
sql_query = """"""
SELECT o.CustomerID, COUNT(DISTINCT o.OrderID) AS DiscountedOrders
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0
GROUP BY o.CustomerID
ORDER BY DiscountedOrders DESC;
""""""

# Execute the SQL query to get data
discounted_order_data = execute_sql_query(sql_query)

# Create a bar chart visualization
fig = px.bar(
    discounted_order_data,
    x='CustomerID',
    y='DiscountedOrders',
    title='Top Customers by Discounted Orders',
    labels={'CustomerID': 'Customer ID', 'DiscountedOrders': 'Number of Discounted Orders'}
)

# Show the visualization
show_to_user(fig)
```","The input Python code has the same logical structure and functionality as the reference implementation. It uses an SQL query to retrieve the number of discounted orders per customer, groups and orders the results correctly, and creates a similar bar chart to visualize the data. Although the utility functions are placeholders in the input Python code, the essential SQL query and chart logic match the reference implementation. Therefore, it correctly fulfills the business analytics request.",Finetuned
"Calculate the total sales grouped by country and month, and visualize the results using a bar chart.","import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCountry, 
       TO_CHAR(OrderDate, 'YYYY-MM') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipCountry, TO_CHAR(OrderDate, 'YYYY-MM')
""""""

# Execute the SQL query and fetch the results in a DataFrame
df = execute_sql_query(sql_query)

# Create the bar chart using Plotly
fig = px.bar(df, x='Month', y='TotalSales', color='ShipCountry', barmode='group',
             title='Total Sales by Country and Month',
             labels={'TotalSales': 'Total Sales', 'Month': 'Month', 'ShipCountry': 'Country'})

# Show the resulting bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipCountry,
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    ShipCountry, OrderMonth
ORDER BY 
    OrderMonth, ShipCountry
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='OrderMonth', y='TotalSales', color='ShipCountry', 
             title='Total Sales Grouped by Country and Month',
             labels={'OrderMonth': 'Month', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code correctly calculates the total sales grouped by country and month. It uses DATE_FORMAT in the SQL query to achieve similar functionality to TO_CHAR, ensuring month-year formatting. The bar chart visualization logic using Plotly Express is consistent with the business analytics request, displaying total sales by month and country with appropriate labels and titles.","```python
import pandas as pd
import plotly.express as px

# SQL Query from the business request
sql_query = """"""
SELECT
    countries.CountryName,
    EXTRACT(MONTH FROM orders.OrderDate) AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM
    orders
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
JOIN
    customers.CustomersRegion ON customers.RegionID = region.RegionID
JOIN
    countries ON region.CountryID = countries.CountryID
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY
    countries.CountryName, Month
""""""

# Fetching data using the utility function
df = execute_sql_query(sql_query)

# Convert the Month column to a string for better x-axis labeling
df['Month'] = df['Month'].astype(str)

# Create a bar chart using Plotly
fig = px.bar(df, x='Month', y='TotalSales', color='CountryName', title='Total Sales by Country and Month',
             labels={'TotalSales': 'Total Sales', 'Month': 'Month'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code does not match the logic of the reference implementation. Specifically, there are differences in the SQL query. The input code extracts the month using EXTRACT function, potentially yielding only the month number, whereas the reference uses TO_CHAR to format as 'YYYY-MM'. The join conditions differ as well; the input code includes joins with a 'CustomersRegion' table and 'countries' table, which aren't in the reference. These discrepancies mean the input may not produce the same results as the reference implementation.",Base
Which customers have placed orders with a shipping cost exceeding $100? Include a bar chart to visualize the number of such orders per customer.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute SQL query and return the result as a DataFrame
    pass

def show_to_user(data):
    # Placeholder function to display data or visualization
    pass

# SQL Query to find customers with orders having a shipping cost greater than $100
sql_query = """"""
SELECT DISTINCT customers.CustomerID, CompanyName, orders.OrderID 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.Freight > 100;
""""""

# Execute the SQL query
customers_with_high_freight = execute_sql_query(sql_query)

# Prepare data for visualization: count orders per customer with freight > $100
order_count_per_customer = customers_with_high_freight['CustomerID'].value_counts().reset_index()
order_count_per_customer.columns = ['CustomerID', 'OrderCount']

# Create a bar chart to visualize the number of such orders per customer
fig = px.bar(order_count_per_customer, x='CustomerID', y='OrderCount',
             title='Number of Orders with Freight > $100 per Customer',
             labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
WHERE o.Freight > 100
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderCount DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CompanyName', y='OrderCount', title='Number of Orders with Shipping Cost Exceeding $100 per Customer', labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer'})
show_to_user(fig)
```","Both implementations correctly identify customers who have placed orders with shipping costs exceeding $100. The reference code fetches distinct CustomerID and orders, then counts orders in Python. The input code efficiently counts orders using SQL with GROUP BY, achieving the same result. Both codes visualize the order count per customer using a bar chart. Thus, the input logic aligns with the reference implementation.","
```python
import pandas as pd
import plotly.express as px

# Assume this function executes the SQL and returns a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation, replace with actual database call
    pass

# Placeholder for show_to_user function, which handles displaying data
def show_to_user(data):
    # Placeholder implementation
    pass

# SQL query to find customers with orders that have a shipping cost exceeding $100
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS CountOfOrders 
FROM orders 
WHERE Freight > 100 
GROUP BY CustomerID;
""""""

# Execute the SQL query and get the results as a pandas DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per customer
fig = px.bar(orders_df, x='CustomerID', y='CountOfOrders',
             title='Number of Orders with Shipping Cost > $100 per Customer',
             labels={'CountOfOrders': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Display the bar chart using the show_to_user function
show_to_user(fig)
```","The input code does not fully match the logic of the reference implementation. In particular, the input code does not join the customers and orders tables to include customer information such as CompanyName, which means it lacks customer details. Additionally, the SQL in the input code counts orders directly without ensuring distinct customer order combinations from a join, which violates part of the reference logic.",Base
"Calculate the total revenue generated from orders, including discounts, and create a line chart showing revenue trends over time.","```python
import pandas as pd
import plotly.express as px

# Assuming the utility functions are already defined

# SQL query to calculate total revenue over time
sql_query = """"""
SELECT o.OrderDate, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN Orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderDate
ORDER BY o.OrderDate;
""""""

# Execute SQL query
revenue_df = execute_sql_query(sql_query)

# Create line chart to show revenue trends over time
fig = px.line(revenue_df, x='OrderDate', y='TotalRevenue', title='Revenue Trends Over Time')

# Display the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.line(revenue_data, x='Month', y='TotalRevenue', title='Revenue Trends Over Time')
show_to_user(fig)
```","The input code aggregates revenue on a monthly basis using DATE_FORMAT(o.OrderDate, '%Y-%m') as the month, while the reference code calculates revenue daily, using the exact OrderDate. This changes the granularity of the data and thus the trend displayed, making them not equivalent.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = '''
SELECT
    o.OrderDate,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM
    orders o
JOIN
    ""Order Details"" od ON o.OrderID = od.OrderID
GROUP BY
    o.OrderDate
ORDER BY
    o.OrderDate;
'''

# Execute the SQL query and get the data
order_data = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize revenue trends over time
fig = px.line(order_data, x='OrderDate', y='TotalRevenue', 
              title='Revenue Trends Over Time', 
              labels={'OrderDate': 'Order Date', 'TotalRevenue': 'Total Revenue'})

# Display the chart
show_to_user(fig)
```","The provided implementation correctly computes the total revenue by multiplying the quantity and unit price, adjusted for discounts. It uses a SQL query that matches the reference logic, joining 'Order Details' with 'Orders' and aggregating by 'OrderDate'. The line chart creation and display approaches are also consistent with the reference implementation using Plotly. The differences in table and field naming conventions (such as case sensitivity) do not affect the underlying logic. Therefore, the code is deemed correct.",Finetuned
"
""Which product has the highest total sales in terms of revenue, and can this be visualized with a bar chart showing each product's total revenue?","```python
import pandas as pd
import plotly.express as px

# Assume 'execute_sql_query' and 'show_to_user' are available as per the constraints.

# SQL query to fetch product sales data
sql_query = """"""
SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS ProductSales
FROM [Order Details] od
GROUP BY od.ProductID
ORDER BY ProductSales DESC
""""""

# Fetching data using the provided utility function
product_sales_df = execute_sql_query(sql_query)

# Displaying the product with the highest sales
if not product_sales_df.empty:
    top_product = product_sales_df.iloc[0]
    print(f""The product with the highest total sales (Revenue): ProductID = {top_product['ProductID']}, Sales = {top_product['ProductSales']}"")
else:
    print(""No sales data available."")

# Creating a bar chart to visualize each product's total revenue
fig = px.bar(product_sales_df, x='ProductID', y='ProductSales', title='Total Revenue by Product')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    pd.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
JOIN 
    products pd ON od.ProductID = pd.ProductID
GROUP BY 
    pd.ProductID
ORDER BY 
    TotalRevenue DESC
LIMIT 1;
""""""

highest_sales_product = execute_sql_query(sql_query)

total_revenue_query = """"""
SELECT 
    pd.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
JOIN 
    products pd ON od.ProductID = pd.ProductID
GROUP BY 
    pd.ProductID
""""""

total_revenue_df = execute_sql_query(total_revenue_query)

fig = px.bar(total_revenue_df, x='ProductID', y='TotalRevenue', 
             title='Total Revenue by Product', 
             labels={'TotalRevenue': 'Total Revenue', 'ProductID': 'Product ID'})
show_to_user(fig)
```","The input Python code fulfills the business analytics request by finding and displaying the product with the highest total sales in terms of revenue. It executes a SQL query to find the product with the highest revenue and another query to get total revenue for each product for visualization. Although it fetches the top product's data separately, it effectively provides the required information using SQL commands and visualizes it with a bar chart, similar to the reference implementation. The logic of calculating total sales and visualizing the data is consistent with the reference code.","```python
import pandas as pd
import plotly.express as px

def highest_revenue_product():
    # Define SQL query to fetch product sales data
    sql_query = """"""
    SELECT p.ProductID, p.ProductName, SUM(od.UnitPrice * od.Quantity) AS TotalRevenue
    FROM products p
    JOIN ""Order Details"" od ON p.ProductID = od.ProductID
    GROUP BY p.ProductID, p.ProductName
    ORDER BY TotalRevenue DESC;
    """"""
    
    # Fetch the data as a DataFrame
    df = execute_sql_query(sql_query)

    # Extract the product with the highest revenue
    max_revenue_product = df.iloc[0]

    # Print the product with the highest revenue
    show_to_user(pd.DataFrame([max_revenue_product]))

    # Visualize each product's total revenue with a bar chart
    fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

    # Show the bar chart to the user
    show_to_user(fig)

# Execute the function
highest_revenue_product()
```","The input code does not correctly replicate the logic of the reference implementation. The reference code calculates total sales by considering discounts using the formula 'SUM(UnitPrice * Quantity * (1 - Discount))', whereas the input code omits the discount factor, using 'SUM(UnitPrice * Quantity)' instead. This results in different revenue calculations.",Base
"List all discontinued products and their stock levels, and provide a bar chart of stock levels for each product.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database execution logic
    pass

def show_to_user(data):
    # Placeholder for displaying data
    pass

# SQL query to fetch discontinued products and their stock levels
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE Discontinued = 1;""

# Execute the SQL query and get the result as a pandas DataFrame
discontinued_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
if discontinued_products_df is not None and not discontinued_products_df.empty:
    fig = px.bar(discontinued_products_df, x=""ProductName"", y=""UnitsInStock"",
                 title=""Stock Levels of Discontinued Products"",
                 labels={""ProductName"": ""Product Name"", ""UnitsInStock"": ""Stock Levels""})

    # Show the bar chart to the user
    show_to_user(fig)
else:
    show_to_user(""No discontinued products found or data not loaded correctly."")
```","```python
import pandas as pd
import plotly.express as px

# Query to get discontinued products and their stock levels
sql_query = """"""
SELECT ProductName, UnitsInStock 
FROM products 
WHERE Discontinued = 1
""""""
discontinued_products = execute_sql_query(sql_query)

# Create a bar chart of stock levels for discontinued products
fig = px.bar(discontinued_products, 
             x='ProductName', 
             y='UnitsInStock', 
             title='Stock Levels of Discontinued Products', 
             labels={'UnitsInStock': 'Stock Level', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The provided code correctly implements the request to list all discontinued products and their stock levels using the SQL query. It then creates a bar chart using Plotly, similar to the reference implementation. Both implementations handle the visualization task and display the information correctly, although the error-checking logic for empty DataFrames is missing in the input code. The main logic remains intact, fulfilling the specified requirement.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock
FROM products 
WHERE Discontinued = 1;
""""""

# Execute the SQL query
discontinued_products_df = execute_sql_query(sql_query)

# Generate a bar chart for stock levels
fig = px.bar(discontinued_products_df, x='ProductName', y='UnitsInStock', 
             title='Stock Levels of Discontinued Products', 
             labels={'UnitsInStock': 'Stock Level', 'ProductName': 'Product Name'})

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It fetches discontinued products and their stock levels using a SQL query. Although the input code retrieves 'ProductID' along with 'ProductName' and 'UnitsInStock', it does not affect the result as 'ProductID' is not used further. The bar chart is generated using Plotly with appropriate labels for 'ProductName' and 'UnitsInStock', and the chart is displayed similar to the reference code. The check for an empty DataFrame in the reference code is not included, but it does not specifically affect the task's completion as the result will be handled by Plotly. Therefore, the input code satisfies the business analytics request.",both
"Which five products contribute the most to the total sales of each employee, and how can this be illustrated using a bar chart for better comparison?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, od.ProductID, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS ProductSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, od.ProductID;
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Sort and filter to get the top 5 products by sales for each employee
top_products_df = df.groupby('EmployeeID').apply(lambda x: x.nlargest(5, 'ProductSales')).reset_index(drop=True)

# Visualize with Plotly
fig = px.bar(
    top_products_df, 
    x='ProductID', 
    y='ProductSales', 
    color='EmployeeID', 
    title=""Top 5 Products by Sales for Each Employee"",
    labels={'ProductSales': 'Sales', 'ProductID': 'Product ID'},
    barmode='group'
)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName, od.ProductID
""""""

data = execute_sql_query(sql_query)

top_products = data.loc[data.groupby('EmployeeID')['TotalSales'].nlargest(5).reset_index(level=0, drop=True).index]

fig = px.bar(top_products, 
              x='ProductID',
              y='TotalSales', 
              color='EmployeeID', 
              title='Top 5 Products Contributing to Sales by Employee',
              labels={'TotalSales': 'Total Sales', 'ProductID': 'Product ID'})
show_to_user(fig)
```","The input code correctly executes the business analytics request following the logic of the reference implementation. Both codes calculate sales per product per employee using SQL, group by employee ID and product ID, and filter the top 5 products per employee by sales. They both use Plotly to create a grouped bar chart. The minor differences, such as additional selection of the employee's name in SQL, do not affect the primary objective. The approach of filtering using pandas is equivalent in logic to the reference code.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the top five products contributing to each employee's sales
sql_query = """"""
	SELECT employees.FirstName, employees.LastName, 
	       products.ProductName, 
	       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
               (1 - [Order Details].Discount)) AS product_sales 
	FROM employees 
	JOIN orders ON employees.EmployeeID = orders.EmployeeID 
	JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
	JOIN products ON [Order Details].ProductID = products.ProductID 
	GROUP BY employees.FirstName, employees.LastName, products.ProductName 
	ORDER BY product_sales DESC 
	LIMIT 5
""""""

# Execute the SQL query and get the results in a pandas DataFrame
sales_data_df = execute_sql_query(sql_query)

# Filter out the top 5 products for each employee using groupby and head
top_products_per_employee = sales_data_df.groupby(['FirstName', 'LastName']).apply(
    lambda x: x.nlargest(5, 'product_sales')
).reset_index(drop=True)

# Create a bar chart using Plotly
fig = px.bar(
    top_products_per_employee,
    x='ProductName',
    y='product_sales',
    color='FirstName',
    title='Top 5 Products by Sales for Each Employee',
    labels={'product_sales': 'Product Sales', 'ProductName': 'Product Name'},
    text='product_sales'
)

# Improve the aesthetics
fig.update_layout(barmode='stack', xaxis_title='Product', yaxis_title='Sales Contribution')
fig.update_traces(textposition='outside')

# Display the bar chart
show_to_user(fig)
```","The given implementation and the reference solve the problem differently. The input code attempts to use a LIMIT clause in the SQL query to select the top 5 products globally across all employees, which is incorrect. The reference code retrieves all products for each employee and then finds the top 5 products per employee using Python. Additionally, the input code uses 'FirstName' and 'LastName' for grouping, whereas the reference uses 'EmployeeID'. The input visualization includes sales as text on the bar chart, uses 'stack' for barmode, and references 'ProductName', while the reference code groups by 'ProductID' and sets barmode to 'group'. Thus, the input does not adhere to the reference logic.",Base
How many unique products were sold in the last year? Can you provide a bar chart showing the number of unique products sold by month?,"
```python
import pandas as pd
import plotly.express as px

# Function to execute SQL queries and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to execute a SQL query and return a DataFrame
    pass

# Function to display data or visualization to the user
def show_to_user(data):
    # Placeholder function for displaying data or figures
    pass

# SQL query to get the number of unique products sold by month
sql_query = """"""
SELECT 
    MONTH(o.OrderDate) AS OrderMonth, 
    COUNT(DISTINCT od.ProductID) AS UniqueProductsSold
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query and obtain a DataFrame
df_unique_products_sold = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_unique_products_sold, 
             x='OrderMonth', 
             y='UniqueProductsSold', 
             labels={'OrderMonth': 'Month', 'UniqueProductsSold': 'Unique Products Sold'},
             title='Number of Unique Products Sold by Month in the Last Year')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get unique products sold by month for the last year
sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    COUNT(DISTINCT od.ProductID) AS UniqueProducts
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
monthly_unique_products = execute_sql_query(sql_query)

# Create a bar chart
fig = px.bar(monthly_unique_products, 
             x='Month', 
             y='UniqueProducts', 
             title='Number of Unique Products Sold by Month (Last Year)',
             labels={'UniqueProducts': 'Unique Products Sold', 'Month': 'Month'})

# Show the bar chart to the user
show_to_user(fig)
```","Both the input and reference code achieve the same goal: determining the number of unique products sold by month over the past year. They use SQL queries to group by month, count distinct ProductIDs, and order by month. The input code uses 'DATE_FORMAT' to format the date, while the reference code uses 'MONTH' function; both approaches ensure that sales are grouped by calendar month and year. The final visualizations, created using Plotly, present the data correctly with appropriate labels.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of unique products sold by month in the last year
sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
    COUNT(DISTINCT ProductID) AS unique_products_sold 
FROM 
    `Order Details` 
JOIN 
    orders ON `Order Details`.OrderID = orders.OrderID 
WHERE 
    orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY 
    month
ORDER BY
    month;
""""""

# Execute the SQL query
df_unique_products_per_month = execute_sql_query(sql_query)

# Create a bar chart of unique products sold by month
fig = px.bar(
    df_unique_products_per_month, 
    x='month', 
    y='unique_products_sold', 
    title='Unique Products Sold by Month in the Last Year',
    labels={'month': 'Month', 'unique_products_sold': 'Unique Products Sold'}
)

# Display the figure
show_to_user(fig)
```","The input Python code correctly implements the business analytics request and adheres to the logic of the reference implementation. Both snippets: (1) execute a SQL query to select the number of unique products sold by month in the last year and (2) generate a bar chart depicting the results. The primary difference lies in the SQL syntax: the input code uses `DATE_FORMAT` to create month strings, whereas the reference code uses `MONTH` to extract numerical month values. Both achieve the desired outcome of grouping sales data by month. The visualization is effectively identical, fulfilling the business request.",both
"Which shipping company has the highest on-time delivery rate, and could you provide a bar chart comparing their on-time delivery rates?","```python
import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = '''
SELECT shippers.CompanyName, 
       CAST(COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) AS FLOAT) 
       / COUNT(orders.OrderID) AS on_time_delivery_rate 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.ShipperID 
GROUP BY shippers.CompanyName 
ORDER BY on_time_delivery_rate DESC
'''

# Execute the SQL query to retrieve the data
data_frame = execute_sql_query(sql_query)

# Identify the shipping company with the highest on-time delivery rate
top_shipper = data_frame.iloc[0]

# Print the company with the highest on-time delivery rate
print(f""The shipping company with the highest on-time delivery rate is: {top_shipper['CompanyName']}"")

# Create a bar chart to compare on-time delivery rates
fig = px.bar(data_frame, x='CompanyName', y='on_time_delivery_rate',
             title='On-Time Delivery Rates by Shipping Company',
             labels={'on_time_delivery_rate': 'On-Time Delivery Rate', 'CompanyName': 'Shipping Company'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName, 
       COUNT(orders.OrderID) AS total_orders,
       COUNT(orders.OrderID) FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) AS on_time_orders
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

delivery_data = execute_sql_query(sql_query)
delivery_data['on_time_delivery_rate'] = delivery_data['on_time_orders'] / delivery_data['total_orders']

highest_on_time_delivery = delivery_data.loc[delivery_data['on_time_delivery_rate'].idxmax()]

fig = px.bar(delivery_data, 
             x='CompanyName', 
             y='on_time_delivery_rate', 
             title='On-time Delivery Rate by Shipping Company',
             labels={'on_time_delivery_rate': 'On-time Delivery Rate'})
show_to_user(fig)
```","The input code accurately addresses the business analytics request. It correctly calculates the on-time delivery rate by dividing the count of on-time orders by the total number of orders for each shipping company. The logic matches the reference implementation, which uses a similar calculation within the SQL query. Both implementations target the retrieval and comparison of on-time delivery rates, and they provide the output through a bar chart, as required. Additionally, the input code identifies the company with the highest on-time delivery rate, similar to the reference implementation, and uses appropriate methods to visualize the data.","```python
import pandas as pd
import plotly.express as px

def execute_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for function that executes SQL query and returns result as DataFrame
    # Implement the actual SQL execution logic as per the database connectivity requirements.
    pass

def show_to_user(data):
    # Placeholder function to display data or visualization to the user
    # For the purpose of this task, it will print the data or show the plot
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get on-time delivery rates
sql_query = """"""
SELECT shippers.CompanyName, 
       (COUNT(orders.OrderID) 
        FILTER (WHERE orders.ShippedDate <= orders.RequiredDate) * 100.0 / COUNT(orders.OrderID)) 
       AS on_time_delivery_rate 
FROM orders 
JOIN shippers ON orders.ShipVia = shippers.SupplierID 
GROUP BY shippers.CompanyName 
ORDER BY on_time_delivery_rate DESC
""""""

# Execute the query to get the data
df = execute_query(sql_query)

# Display the DataFrame
show_to_user(df)

# Create a bar chart using the obtained DataFrame
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate', title='On-Time Delivery Rates by Shipping Company')

# Display the bar chart
show_to_user(fig)
```","The evaluated code has an error in the SQL query. It uses 'orders.ShipVia = shippers.SupplierID', which is likely incorrect and should be 'orders.ShipVia = shippers.ShipperID' to match the reference implementation. Additionally, the implementation of the on-time delivery rate uses the SQL FILTER clause, which is a different approach than the reference's CASE WHEN, but that's acceptable. However, the incorrect join condition leads to incorrect logic.",Base
How many orders were delivered on time each month? Please include a line chart to visualize the trends over time.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of on-time orders per month
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       COUNT(*) AS OnTimeOrders 
FROM orders 
WHERE orders.ShippedDate <= orders.RequiredDate 
GROUP BY DATE_FORMAT(orders.OrderDate, '%Y-%m')
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a line chart to visualize the trend of on-time orders over time
fig = px.line(df, x='Month', y='OnTimeOrders', title='On-Time Orders Per Month', labels={'OnTimeOrders': 'On-Time Orders', 'Month': 'Month'})

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS OnTimeDeliveries
FROM 
    orders
WHERE 
    ShippedDate <= RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

on_time_deliveries_df = execute_sql_query(sql_query)

fig = px.line(on_time_deliveries_df, x='Month', y='OnTimeDeliveries', title='Monthly On-time Deliveries')
show_to_user(fig)
```","The input Python code is correct because it achieves the same end goal as the reference implementation. Both codes execute a SQL query to count the number of orders delivered on time per month by comparing 'ShippedDate' to 'RequiredDate'. Both codes use DATE_FORMAT to extract the month and count the number of on-time deliveries, grouped and ordered by month. While the column names and order by clause slightly differ, they do not affect the overall logic and output. The line chart is also created similarly using Plotly Express, with the same logic to display the trend of on-time deliveries.","```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query for on-time orders
sql_query = """"""
SELECT EXTRACT(YEAR FROM ShipDate) AS Year,
       EXTRACT(MONTH FROM ShipDate) AS Month,
       COUNT(OrderID) AS OnTimeOrders
FROM orders
WHERE ShippedDate <= RequiredDate
GROUP BY EXTRACT(YEAR FROM ShipDate), EXTRACT(MONTH FROM ShipDate)
ORDER BY Year, Month;
""""""

# Step 2: Execute the SQL query and get results in a DataFrame
orders_df = execute_sql_query(sql_query)

# Step 3: Create a line chart using Plotly to visualize trends over time
fig = px.line(
    orders_df,
    x=orders_df.index,
    y='OnTimeOrders',
    title='On-Time Orders Delivered Each Month',
    labels={'index': 'Year-Month', 'OnTimeOrders': 'On-Time Orders'},
    markers=True
)

# Step 4: Display the line chart to the user
show_to_user(fig)
```","The input code doesn't correctly implement the x-axis for the chart. It uses the DataFrame index as the x-axis, which may not correspond to 'Year-Month'. Instead, it should create a 'Year-Month' column for the x-axis. The reference code constructs 'Month' using DATE_FORMAT(orders.OrderDate, '%Y-%m'), and the input should similarly create a properly formatted 'Year-Month' string for accurate visualization.",Base
Find the product with the highest discount applied in the last month and create a bar chart to visualize the top five products with the highest discounts.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the top five products with the highest discounts in the last month
sql_query_top_five = """"""
SELECT 
    products.ProductName, 
    [Order Details].Discount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
ORDER BY [Order Details].Discount DESC 
LIMIT 5;
""""""

# Function to execute SQL queries and return the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating the execution of the SQL query and returning a mock DataFrame
    # In a real scenario, replace this with actual database interaction
    return pd.DataFrame({
        'ProductName': [""Product A"", ""Product B"", ""Product C"", ""Product D"", ""Product E""],
        'Discount': [0.50, 0.45, 0.40, 0.35, 0.30]
    })

# Execute the SQL query to get the product data
top_five_products_df = execute_sql_query(sql_query_top_five)

# Create a bar chart to visualize the top five products with the highest discounts
fig = px.bar(
    top_five_products_df,
    x='ProductName',
    y='Discount',
    title='Top Five Products with the Highest Discounts in the Last Month'
)

# Function to display data analysis or visualization results
def show_to_user(data):
    # If data is a plotly figure, show the plot
    if isinstance(data, px.Figure):
        data.show()
    # Otherwise, print the DataFrame
    else:
        print(data)

# Visualize the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the date range for the last month
end_date = datetime.now()
start_date = end_date - timedelta(days=30)

# SQL query to find products with discounts in the last month
sql_query = f""""""
SELECT p.ProductID, p.ProductName, od.Discount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.Discount > 0
AND od.OrderID IN (
    SELECT OrderID
    FROM [Order Details]
    WHERE OrderDate >= '{start_date.strftime('%Y-%m-%d')}' 
    AND OrderDate <= '{end_date.strftime('%Y-%m-%d')}'
)
ORDER BY od.Discount DESC
LIMIT 5
""""""

# Execute the SQL query and retrieve data
top_discounts_df = execute_sql_query(sql_query)

# Create bar chart for top 5 products with the highest discounts
fig = px.bar(top_discounts_df, x='ProductName', y='Discount', title='Top 5 Products with Highest Discounts',
             labels={'Discount': 'Discount Amount', 'ProductName': 'Product Name'})

show_to_user(fig)
```","Both implementations aim to retrieve the top five products with the highest discounts in the last month and visualize them using a bar chart. The reference code constructs a query with an implicit date filter using 'DATE_SUB(CURDATE(), INTERVAL 1 MONTH)', while the code to evaluate explicitly defines the date range using 'datetime'. It also includes an additional condition to ensure non-zero discounts. Both codes retrieve the top five products sorted by discount and use Plotly for visualization in a similar manner, satisfying the business analytics request and logical structure of the reference implementation.","
```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query
sql_query = """"""
SELECT products.ProductName, MAX([Order Details].Discount) as MaxDiscount
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE MONTH(orders.OrderDate) = MONTH(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH))
AND YEAR(orders.OrderDate) = YEAR(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH))
GROUP BY products.ProductName
ORDER BY MaxDiscount DESC
LIMIT 5;
""""""

# Step 2: Execute the SQL query and load results into a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function to run the SQL query and return a DataFrame
    # In practice, this function would interact with a database
    pass

df = execute_sql_query(sql_query)

# Step 3: Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='MaxDiscount', title='Top 5 Products with Highest Discounts in Last Month')

# Step 4: Display the bar chart
def show_to_user(data):
    # Simulated function to display output to the user
    # Can handle both DataFrames and Plotly figures
    pass

show_to_user(fig)
```
","The input code does not correctly implement the logic of finding the products with the highest discounts in the last month. The primary issue is that the reference implementation focuses on filtering orders from the last month and sorting the discounts, whereas the input code uses a GROUP BY clause with MAX, which alters the original logic. Additionally, the correct handling of the 'OrderDate' filter is missing, as the code does not execute the SQL query, making the discount data incomplete for visualization.",Base
Find the top three suppliers with the fastest delivery times and visualize the delivery times using a bar chart.,"```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AverageLeadTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.CompanyName 
ORDER BY AverageLeadTime ASC 
LIMIT 3;
""""""

# Execute the SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assuming there is an implementation that connects to a database and executes the query
    # This will return a DataFrame
    pass

# Function to display data to the user
def show_to_user(data):
    # Assuming there is an implementation that handles either DataFrame or Plotly figure
    pass

# Retrieve data using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='AverageLeadTime', 
             title='Top 3 Suppliers with Fastest Delivery Times',
             labels={'AverageLeadTime': 'Average Delivery Time (Days)', 'CompanyName': 'Supplier'})

# Display the figure using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgDeliveryTime
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY AvgDeliveryTime ASC
LIMIT 3;
""""""

top_suppliers_df = execute_sql_query(sql_query)

fig = px.bar(top_suppliers_df, x='CompanyName', y='AvgDeliveryTime', 
              title='Top 3 Suppliers with Fastest Delivery Times',
              labels={'AvgDeliveryTime': 'Average Delivery Time (Days)', 'CompanyName': 'Supplier Name'})
show_to_user(fig)
```","The input code correctly implements the requirement to find the top three suppliers with the fastest delivery times and visualize the results in a bar chart. It follows the same logic as the reference implementation, including joining the necessary tables, calculating the average delivery time, ordering the results, and limiting the output to three suppliers. The column names, although slightly different ('AvgDeliveryTime' vs. 'AverageLeadTime'), serve the same purpose. Finally, it visualizes the data using a Plotly bar chart with appropriate labels and title, and outputs the visualization through a utility function.","```python
import plotly.express as px
import pandas as pd

# SQL query to find the top three suppliers with the fastest delivery times
sql_query = """"""
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgDeliveryTime 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
GROUP BY suppliers.CompanyName 
ORDER BY AvgDeliveryTime ASC 
LIMIT 3;
""""""

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the logic to connect to the database, execute the query, and return the result
    pass

# Function to display data or visualization results
def show_to_user(data):
    # This function should handle the display of data or charts
    pass

# Executing the SQL query
df = execute_sql_query(sql_query)

# Creating a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='AvgDeliveryTime',
             title='Top 3 Suppliers with Fastest Delivery Times',
             labels={'AvgDeliveryTime': 'Average Delivery Time (Days)'})

# Displaying the figure to the user
show_to_user(fig)
```","The input code correctly matches the business request and logic of the reference implementation. Both versions execute the same SQL query, aiming to select the top three suppliers with the fastest average delivery times. The differences in column naming ('AvgDeliveryTime' vs. 'AverageLeadTime') are cosmetic and do not affect the logic of the code. Furthermore, both codes utilize Plotly to create a bar chart representing the data, with equivalent settings for titles and labels. Thus, the input implementation fulfills the request accurately.",both
"Which countries have suppliers who also have fax numbers listed, and can this information be visualized on a map for better insight?","```python
import plotly.express as px

# Business logic
def get_countries_with_fax_suppliers():
    sql_query = ""SELECT DISTINCT Country FROM suppliers WHERE Fax IS NOT NULL;""
    
    # Execute the SQL query
    countries_df = execute_sql_query(sql_query)
    
    # Visualizing countries on a map
    if not countries_df.empty and ""Country"" in countries_df.columns:
        fig = px.choropleth(countries_df,
                            locations='Country',
                            locationmode='country names',
                            color_discrete_sequence=[""blue""],
                            title=""Countries with Suppliers Having Fax Numbers"")
        show_to_user(fig)
    else:
        show_to_user(countries_df)

# Run the function
get_countries_with_fax_suppliers()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Country, COUNT(SupplierID) AS SupplierCount
FROM suppliers
WHERE Fax IS NOT NULL
GROUP BY Country
""""""

supplier_data = execute_sql_query(sql_query)

fig = px.choropleth(supplier_data,
                    locations='Country',
                    locationmode='country names',
                    color='SupplierCount',
                    title='Suppliers with Fax Numbers by Country',
                    color_continuous_scale=px.colors.sequential.Plasma)

show_to_user(fig)
```","The input code deviates from the business request and reference implementation by including a 'COUNT(SupplierID)' and grouping by country, which doesn't match the logic of simply listing distinct countries with suppliers having fax numbers. Additionally, the visualization uses a different color representation with potentially different insight, focusing on supplier count rather than just presence.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DISTINCT Country FROM suppliers WHERE Fax IS NOT NULL;
""""""

# Execute the SQL query using the execute_sql_query utility function
df_suppliers_with_fax = execute_sql_query(sql_query)

# Check if the 'Country' column is present in the DataFrame
if 'Country' not in df_suppliers_with_fax.columns or df_suppliers_with_fax.empty:
    show_to_user(""No data available for visualization."")
else:
    # Create a map visualization using Plotly
    fig = px.scatter_geo(
        df_suppliers_with_fax,
        locations=""Country"",
        title=""Countries with Suppliers Who Have Fax Numbers""
    )

    # Display the map using the show_to_user utility function
    show_to_user(fig)
```","The provided Python code correctly follows the logic of the reference implementation to find and visualize countries with suppliers having fax numbers. It uses an SQL query to fetch distinct countries from the suppliers where fax numbers are not null. The code then checks if the DataFrame has countries data and uses Plotly to create a geographical scatter plot for visualization, which is an acceptable alternative to the choropleth map used in the reference. Therefore, it satisfies the business analytics request.",Finetuned
"Which city has the most suppliers located in it, and can this be represented in a bar chart to show the distribution of suppliers across cities?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT s.City, COUNT(s.SupplierID) AS SupplierCount 
FROM suppliers s 
GROUP BY s.City 
ORDER BY SupplierCount DESC;
""""""

# Fetch the data using the utility function
suppliers_data = execute_sql_query(sql_query)

# Find the city with the most suppliers
if not suppliers_data.empty:
    top_city = suppliers_data.iloc[0]
    # Print the city with the most suppliers
    print(f""The city with the most suppliers is {top_city['City']} with {top_city['SupplierCount']} suppliers."")
else:
    print(""No suppliers found."")

# Create a bar chart using Plotly
fig = px.bar(
    suppliers_data, 
    x='City', 
    y='SupplierCount', 
    title='Distribution of Suppliers Across Cities',
    labels={'City': 'City', 'SupplierCount': 'Number of Suppliers'}
)

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count suppliers by city
sql_query = """"""
SELECT City, COUNT(SupplierID) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
""""""

# Execute the SQL query
suppliers_by_city = execute_sql_query(sql_query)

# Find the city with the most suppliers
most_suppliers_city = suppliers_by_city.iloc[0]

# Create a bar chart for the distribution of suppliers across cities
fig = px.bar(suppliers_by_city, x='City', y='SupplierCount', title='Distribution of Suppliers Across Cities', labels={'SupplierCount': 'Number of Suppliers'})
show_to_user(fig)
```","The input code correctly executes a SQL query to count the number of suppliers grouped by city, orders them descending by supplier count, and captures the result in a DataFrame. It identifies and stores the city with the most suppliers using the first row of the DataFrame. Then, it uses Plotly to create and display a bar chart showing the distribution of suppliers across cities. The logic, data transformation, and visualization steps closely match the reference implementation, fulfilling the business request effectively.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of suppliers per city
sql_query = """"""
SELECT City, COUNT(*) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
""""""

# Execute the SQL query and get a pandas DataFrame
supplier_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to show the distribution of suppliers across cities
fig = px.bar(supplier_data, x='City', y='SupplierCount', title='Distribution of Suppliers Across Cities')

# Display the bar chart
show_to_user(fig)

# Output the city with the most suppliers
most_suppliers_city = supplier_data.iloc[0]
show_to_user(pd.DataFrame([most_suppliers_city]).rename(columns={'City': 'City with Most Suppliers', 'SupplierCount': 'Number of Suppliers'}, index=[0]))
```","The input code correctly executes the SQL query to get the count of suppliers per city and orders the results by the supplier count in descending order, matching the reference implementation. It uses Plotly to create a bar chart displaying the distribution of suppliers across cities. Moreover, it identifies the city with the most suppliers by selecting the first row of the sorted DataFrame. Although the method of displaying the city with the most suppliers is different (using a DataFrame and `show_to_user`), it effectively communicates the intended result. Thus, the input code adheres to the logic of the reference implementation.",both
"Which orders took longer than the required date to be shipped? Additionally, provide a bar chart showing the number of delayed orders by shipping delay duration.","```python
import pandas as pd
import plotly.express as px

# SQL query to find orders with delays
sql_query = ""SELECT OrderID, ShippedDate, RequiredDate FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query using the utility function
delayed_orders_df = execute_sql_query(sql_query)

# Convert ShippedDate and RequiredDate to datetime
# Ensure the datetime conversion to handle any potential data type issues
delayed_orders_df['ShippedDate'] = pd.to_datetime(delayed_orders_df['ShippedDate'])
delayed_orders_df['RequiredDate'] = pd.to_datetime(delayed_orders_df['RequiredDate'])

# Add a new column to calculate the shipping delay duration
delayed_orders_df['DelayDuration'] = (delayed_orders_df['ShippedDate'] - delayed_orders_df['RequiredDate']).dt.days

# Group by DelayDuration and count the number of orders
delay_counts = delayed_orders_df.groupby('DelayDuration').size().reset_index(name='OrderCount')

# Create a bar chart using Plotly
fig = px.bar(delay_counts, x='DelayDuration', y='OrderCount', title='Number of Delayed Orders by Shipping Delay Duration')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderID, 
    DATEDIFF(ShippedDate, RequiredDate) AS ShippingDelay
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
""""""

delayed_orders = execute_sql_query(sql_query)

if delayed_orders.empty:
    show_to_user(""No delayed orders found."")
else:
    delay_counts = delayed_orders['ShippingDelay'].value_counts().reset_index()
    delay_counts.columns = ['ShippingDelay', 'OrderCount']

    fig = px.bar(delay_counts, 
                 x='ShippingDelay', 
                 y='OrderCount', 
                 title='Number of Delayed Orders by Shipping Delay Duration',
                 labels={'ShippingDelay': 'Shipping Delay (days)', 'OrderCount': 'Number of Orders'})
    
    show_to_user(fig)
```","The input code correctly identifies orders with shipping delays by using the SQL DATEDIFF function to calculate the delay directly in the query. It proceeds to count the frequency of each delay duration and visualizes it using a bar chart. Both implementations achieve the same goal of identifying delayed orders and plotting delay frequencies, ensuring adherence to the business analytics request.","
import pandas as pd
import plotly.express as px

# SQL query to fetch orders that were shipped later than their required date
sql_query = """"""
SELECT OrderID, 
       DATEDIFF(ShippedDate, RequiredDate) AS Delay 
FROM orders 
WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query
delayed_orders_df = execute_sql_query(sql_query)

# Display the delayed orders data
show_to_user(delayed_orders_df)

# Create a bar chart to visualize the number of delayed orders by shipping delay duration
delay_distribution_df = delayed_orders_df['Delay'].value_counts().reset_index()
delay_distribution_df.columns = ['Delay', 'Count']

# Create a bar chart using Plotly
fig = px.bar(delay_distribution_df, x='Delay', y='Count',
             title='Number of Delayed Orders by Shipping Delay Duration', 
             labels={'Delay': 'Shipping Delay (days)', 'Count': 'Number of Delayed Orders'})

# Show the bar chart to the user
show_to_user(fig)
","The input code correctly retrieves orders that were shipped later than their required date by using a SQL query similar to the reference implementation. It calculates the delay in shipping and uses this information to group by the delay duration, counting the number of orders for each delay duration. It then creates a bar chart to visualize this data, adhering to the same logic as the reference implementation. Despite different coding syntaxes and data processing steps between the input and reference implementations, the end logic and outcome are congruent.",both
Which orders had the largest discount applied? Include a bar chart to visualize the top orders with the largest discounts.,"```python
import plotly.express as px
import pandas as pd

# Given SQL query
sql_query = """"""
SELECT od.OrderID, od.Discount 
FROM [Order Details] od 
WHERE od.Discount = (SELECT MAX(Discount) FROM [Order Details]) 
ORDER BY od.OrderID;
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# No need to sort the DataFrame since the SQL query already retrieves the max discount

# Create a bar chart to visualize the orders with the largest discounts
fig = px.bar(df, x='OrderID', y='Discount', title='Orders with Largest Discount')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to get the orders with the largest discounts
sql_query = """"""
SELECT o.OrderID, SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.OrderID
ORDER BY TotalDiscount DESC
LIMIT 10
""""""
top_discount_orders = execute_sql_query(sql_query)

# Create a bar chart to visualize the top orders with the largest discounts
fig = px.bar(top_discount_orders, x='OrderID', y='TotalDiscount', 
             title='Top Orders with Largest Discounts', 
             labels={'TotalDiscount': 'Total Discount', 'OrderID': 'Order ID'})

show_to_user(fig)
```","The reference code finds orders with the maximum discount value for individual order details, while the input code calculates the total discount for each order by summing the product of discount and quantity, then identifies the top 10 orders with the highest total discounts. These approaches address different aspects of the discount question: per-order detail maximum versus aggregated total discount, leading to discrepancies between the input and reference implementations.","```python
import plotly.express as px
import pandas as pd

# Assume the function execute_sql_query is already defined as per the environment constraints
# and fetches data from the MDDX data warehouse.

# SQL query to fetch orders with the largest discounts
sql_query = """"""
SELECT o.OrderID, od.Discount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount = (SELECT MAX(Discount) FROM [Order Details])
ORDER BY o.OrderID;
""""""

# Execute the SQL query and get the data
data = execute_sql_query(sql_query)

# Sort the data by Discount to find the top orders
top_orders = data.sort_values(by='Discount', ascending=False)

# Plot a bar chart using Plotly for better visualization
fig = px.bar(
    top_orders,
    x='OrderID',
    y='Discount',
    title='Top Orders with Largest Discounts',
    labels={'OrderID': 'Order ID', 'Discount': 'Discount'}
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly implements the requested logic despite some differences from the reference code. It selects orders with the maximum discount and sorts them, which aligns with the purpose of identifying and displaying top orders with the largest discounts. Any difference, such as additional join clauses, does not affect the correctness regarding the task. The visualization part is consistent with the reference, fulfilling the business analytics request.",Finetuned
Determine the customer satisfaction score based on average order frequency and visualize the results using a bar chart or line graph.,"```python
import pandas as pd
import plotly.express as px

# Assume these utility functions are provided in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would contain code to connect to a database and execute the given SQL query.
    # For this example, it's assumed to return a pandas DataFrame.
    pass

def show_to_user(data):
    # This function displays data or visuals to the user.
    # It accepts a pandas DataFrame or a Plotly figure.
    pass

# The SQL query to execute
sql_query = """"""
SELECT customers.CustomerID, 
       COUNT(orders.OrderID)/DATEDIFF(MAX(orders.OrderDate), MIN(orders.OrderDate)) AS OrderFrequency 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
GROUP BY customers.CustomerID 
ORDER BY OrderFrequency DESC;
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the order frequency
fig = px.bar(df, x='CustomerID', y='OrderFrequency', title='Customer Order Frequency')

# Display the bar chart result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the average order frequency per customer
sql_query = """"""
SELECT 
    customers.CustomerID,
    customers.CompanyName,
    COUNT(orders.OrderID) AS OrderFrequency
FROM 
    customers
LEFT JOIN 
    orders ON customers.CustomerID = orders.CustomerID
GROUP BY 
    customers.CustomerID, customers.CompanyName
""""""

# Execute the SQL query and store the result in a DataFrame
customer_order_frequency = execute_sql_query(sql_query)

# Calculate the average order frequency
average_order_frequency = customer_order_frequency['OrderFrequency'].mean()

# Map customer satisfaction scores based on average order frequency
customer_order_frequency['SatisfactionScore'] = pd.cut(customer_order_frequency['OrderFrequency'], 
                                                         bins=[-1, 0, 3, 5, float('inf')],
                                                         labels=[1, 2, 3, 4])

# Visualize the results using a bar chart
fig = px.bar(customer_order_frequency, 
             x='CompanyName', 
             y='SatisfactionScore', 
             title='Customer Satisfaction Score by Average Order Frequency', 
             labels={'SatisfactionScore': 'Satisfaction Score', 'CompanyName': 'Company Name'})

show_to_user(fig)
```","The input code does not adhere to the logic of the reference implementation. The reference code calculates customer order frequency based on a specific logic: the number of orders divided by the date range of those orders for each customer. The input code uses only a simple count of orders without considering the time range, which changes the metric entirely. Additionally, the input code maps these counts to a satisfaction score using arbitrary thresholds, which is unrelated to the reference logic. Visualization also differs: the input uses satisfaction scores grouped by company names, while the reference focuses on order frequency per customer ID.","
import pandas as pd
import plotly.express as px

# Define SQL Query
sql_query = """"""
SELECT customers.CustomerID, 
       AVG(months_difference) AS CustomerSatisfactionScore 
FROM (
    SELECT CustomerID, 
           EXTRACT(YEAR FROM OrderDate) * 12 + EXTRACT(MONTH FROM OrderDate) AS month_number 
    FROM orders
) AS order_months 
JOIN (
    SELECT DISTINCT CustomerID, 
           LEAD(month_number) OVER (PARTITION BY CustomerID ORDER BY month_number) - month_number AS months_difference 
    FROM (
        SELECT CustomerID, 
               EXTRACT(YEAR FROM OrderDate) * 12 + EXTRACT(MONTH FROM OrderDate) AS month_number 
        FROM orders
    ) AS monthly_orders
) AS customer_frequencies ON order_months.CustomerID = customer_frequencies.CustomerID 
GROUP BY customers.CustomerID
""""""

# Execute SQL query
# This assumes the utility function `execute_sql_query` is correctly defined
customer_satisfaction_df = execute_sql_query(sql_query)

# Visualize results using a bar chart
fig = px.bar(customer_satisfaction_df, 
             x=""CustomerID"", 
             y=""CustomerSatisfactionScore"", 
             title=""Customer Satisfaction Score by Customer ID"",
             labels={""CustomerID"": ""Customer ID"", ""CustomerSatisfactionScore"": ""Satisfaction Score""})

# Show the visualization to the user
show_to_user(fig)

","The input code calculates customer satisfaction using the average difference in months between consecutive orders, which is different from the reference code's logic of calculating average order frequency (orders/time period). Thus, the logic does not adhere to the business request as the reference code does.",None
"How many orders did each employee handle in the last quarter, and can you provide a bar chart to visualize the distribution?","```python
import plotly.express as px
import pandas as pd

# SQL Query to fetch data
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'
AND o.OrderDate < DATE_TRUNC('quarter', CURRENT_DATE)
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df, 
    x='FirstName', 
    y='OrderCount',
    hover_data=['LastName', 'OrderCount'],
    labels={'OrderCount': 'Number of Orders'},
    title='Number of Orders Handled by Each Employee in the Last Quarter'
)

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the start and end dates for the last quarter
today = datetime.now()
quarter = (today.month - 1) // 3
start_month = quarter * 3 + 1
end_month = start_month + 2
start_date = datetime(today.year, start_month, 1)
end_date = datetime(today.year, end_month + 1, 1) - timedelta(days=1)

# SQL query to retrieve order counts by employee for the last quarter
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}'
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

# Execute the SQL query
employee_orders = execute_sql_query(sql_query)

# Create a bar chart to visualize the order distribution
fig = px.bar(employee_orders, x='LastName', y='OrderCount', 
              title='Order Distribution by Employee for Last Quarter',
              labels={'LastName': 'Employee Last Name', 'OrderCount': 'Number of Orders'})

# Show the result to user
show_to_user(fig)
```","The input code incorrectly calculates the end date of the last quarter. It uses the end of the month instead of the start of the next quarter. The reference uses DATE_TRUNC to ensure the right period. Also, it uses LEFT JOIN which may include employees with zero orders, differing from the INNER JOIN in reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query provided in the business analytic request
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE QUARTER(orders.OrderDate) = QUARTER(NOW()) - 1 
AND YEAR(orders.OrderDate) = YEAR(NOW()) 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of orders handled by each employee
fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Orders Handled by Each Employee in Last Quarter')

# Display the bar chart using the utility function
show_to_user(fig)
```","The input code uses QUARTER(NOW()) which checks the current quarter but does not account for year transitions correctly. It also does not include employee names, making the visualization less informative. The reference implementation correctly spans the last quarter using DATE_TRUNC with interval subtraction and includes employee names in the output.",None
"Which suppliers have provided products that are no longer in stock, and can this be visualized in a chart to show the number of out-of-stock products per supplier?","```python
import pandas as pd
import plotly.express as px

# SQL query to find suppliers with products out of stock
sql_query = ""SELECT SupplierID, UnitsInStock FROM products WHERE UnitsInStock = 0;""

# Execute the SQL query using the utility function provided
out_of_stock_df = execute_sql_query(sql_query)

# Count the number of out-of-stock products per supplier
out_of_stock_count = out_of_stock_df['SupplierID'].value_counts().reset_index()
out_of_stock_count.columns = ['SupplierID', 'OutOfStockCount']

# Create a bar chart to visualize the data
fig = px.bar(out_of_stock_count, x='SupplierID', y='OutOfStockCount',
             title='Number of Out-of-Stock Products per Supplier',
             labels={'SupplierID': 'Supplier ID', 'OutOfStockCount': 'Out-of-Stock Count'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, COUNT(*) AS OutOfStockProducts
FROM products p
WHERE p.UnitsInStock = 0
GROUP BY p.SupplierID
""""""

out_of_stock_data = execute_sql_query(sql_query)

fig = px.bar(out_of_stock_data, x='SupplierID', y='OutOfStockProducts', title='Number of Out-of-Stock Products per Supplier')
show_to_user(fig)
```","The input Python code correctly implements the logic as specified in the business analytics request and aligns with the reference implementation. Both codes retrieve the count of out-of-stock products per supplier and generate a bar chart to visualize the data. The input code uses a SQL `GROUP BY` clause to directly get the count per supplier, which is an efficient approach and equivalent to the `value_counts()` operation in the reference code.","To fulfill the business request of identifying suppliers who have provided products that are no longer in stock and visualizing the number of out-of-stock products per supplier, we’ll follow these steps:

1. Execute the SQL query to gather the data.
2. Process the data using Python to prepare for visualization.
3. Create a bar chart to represent the number of out-of-stock products per supplier.

Here’s the complete implementation:

```python
import pandas as pd
import plotly.express as px

# Given SQL query to execute
sql_query = """"""
SELECT suppliers.CompanyName, COUNT(products.ProductID) AS OutOfStockCount
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
WHERE products.UnitsInStock = 0
GROUP BY suppliers.CompanyName;
""""""

# Step 1: Execute the SQL query
out_of_stock_df = execute_sql_query(sql_query)

# Step 2: Visualize using Plotly
fig = px.bar(out_of_stock_df, x='CompanyName', y='OutOfStockCount',
             title='Number of Out-of-Stock Products per Supplier',
             labels={'CompanyName': 'Supplier', 'OutOfStockCount': 'Out-of-Stock Products'})

# Display the visualization
show_to_user(fig)
```

### Explanation of the Code
- The SQL query is executed using the `execute_sql_query` utility function.
- The result is a DataFrame containing supplier names and the count of out-of-stock products.
- A bar chart is generated using Plotly's `px.bar` function.
- Finally, the bar chart is displayed to the user via the `show_to_user` function.

### Additional Considerations
- Ensure that the required libraries (pandas, plotly) are installed in your Python environment.
- Adjust the SQL execution context if there are any constraints or connection requirements.

This approach meets the requirement efficiently while providing a clear visual representation of the out-of-stock situation per supplier.","The input code retrieves suppliers by their company name and counts the number of out-of-stock products per supplier, whereas the reference implementation evaluates out-of-stock products based on SupplierID only. Therefore, the grouping and output are different. Although both fulfill the business request, the logic diverges from the reference implementation.",Base
"Which region generates the most revenue, and can you provide a visualization to illustrate the revenue distribution across regions?","```python
import pandas as pd
import plotly.express as px

# Utility Functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to execute the SQL query and return a DataFrame
    pass

def show_to_user(data):
    # This function is assumed to handle the display of DataFrame or Plotly figure
    pass

# SQL Query
sql_query = """"""
SELECT ShipRegion, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Revenue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ShipRegion
ORDER BY Revenue DESC
""""""

# Execute SQL Query
revenue_data = execute_sql_query(sql_query)

# Find the region with the most revenue
if not revenue_data.empty:
    top_region = revenue_data.iloc[0]
else:
    top_region = None

# Visualization of revenue distribution across regions
fig = px.bar(revenue_data, x='ShipRegion', y='Revenue', title='Revenue Distribution Across Regions')

# Show both the top region result and the visualization
show_to_user(revenue_data)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
ORDER BY Revenue DESC
""""""

revenue_by_region = execute_sql_query(sql_query)

# Visualization
fig = px.bar(revenue_by_region, x='Region', y='Revenue', title='Revenue Distribution Across Regions')
show_to_user(fig)
```","The input code generates revenue by joining `customers` with `orders` based on `CustomerID`, then joining `[Order Details]` using `OrderID`. It groups by `c.Region`. However, the reference code groups by `ShipRegion` directly from `orders`. If `ShipRegion` and `c.Region` refer to different columns, the two implementations could yield different results. Also, the input code doesn’t identify the top region or show the data table explicitly as done in the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total revenue by region
sql_query = """"""
SELECT 
    Region, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS RegionRevenue 
FROM 
    customers c 
JOIN 
    orders o ON c.CustomerID = o.CustomerID 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY 
    Region 
ORDER BY 
    RegionRevenue DESC;
""""""

# Execute the SQL query and get the data
result_df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(result_df, x='Region', y='RegionRevenue',
             title='Revenue Distribution Across Regions',
             labels={'RegionRevenue': 'Total Revenue', 'Region': 'Region'})

# Display the revenue distribution chart
show_to_user(fig)

# Display the region with the most revenue
top_region_df = result_df.head(1)
show_to_user(top_region_df)
```","The input code queries using 'Region' from the 'customers' table, whereas the reference uses 'ShipRegion' from the 'orders' table. This can lead to differences if 'Region' and 'ShipRegion' don't match. Additionally, the input code first displays the plot and then displays the top region separately, while the reference handles them together. Although not crucial, these differences may result in different logic outcomes.",None
Find the order with the maximum freight cost and create a visualization comparing freight costs across different orders.,"```python
import pandas as pd
import plotly.express as px

# Use the provided utility function to execute the SQL query
sql_query_max_freight = ""SELECT OrderID, Freight FROM orders ORDER BY Freight DESC LIMIT 1;""
max_freight_df = execute_sql_query(sql_query_max_freight)

# Extract the OrderID with the maximum freight cost
max_freight_order_id = max_freight_df.iloc[0]['OrderID']
max_freight_cost = max_freight_df.iloc[0]['Freight']

# Use the provided utility function to execute a query for all orders' freight costs
sql_query_all_freight = ""SELECT OrderID, Freight FROM orders;""
all_freight_df = execute_sql_query(sql_query_all_freight)

# Create a visualization comparing freight costs across different orders
fig = px.bar(all_freight_df, x='OrderID', y='Freight', title='Freight Costs Across Different Orders')

# Highlight the order with the maximum freight cost
fig.add_scatter(x=[max_freight_order_id], y=[max_freight_cost], mode='markers', marker=dict(color='red', size=10), name='Max Freight Cost')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Retrieve order data
sql_query = ""SELECT OrderID, Freight FROM orders""
orders_df = execute_sql_query(sql_query)

# Find the order with the maximum freight cost
max_freight_order = orders_df.loc[orders_df['Freight'].idxmax()]

# Create a visualization comparing freight costs across different orders
fig = px.bar(orders_df, x='OrderID', y='Freight', title='Freight Costs Across Orders', 
             labels={'OrderID': 'Order ID', 'Freight': 'Freight Cost'})
show_to_user(fig)

# Display the order with the maximum freight cost to the user
show_to_user(pd.DataFrame([max_freight_order]))
```","The input code does not follow the same logic as the reference implementation in terms of visualization. While both codes correctly identify the order with the maximum freight, the input code lacks the visual highlight of the maximum freight order in the bar chart. The reference code includes an additional scatter point to highlight the maximum freight cost, which the input code omits.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to find the order with the maximum freight cost.
sql_query_max_freight = """"""
SELECT OrderID, Freight FROM orders ORDER BY Freight DESC LIMIT 1;
""""""

# Execute the query to get the order with the maximum freight cost.
max_freight_df = execute_sql_query(sql_query_max_freight)

# Define another SQL query to get all orders with their freight costs for visualization.
sql_query_all_freight = ""SELECT OrderID, Freight FROM orders;""

# Execute the query to get all order freight data.
all_freight_df = execute_sql_query(sql_query_all_freight)

# Create a visualization comparing freight costs across different orders.
fig = px.bar(all_freight_df, x='OrderID', y='Freight', title='Freight Costs Across Orders')

# Display the maximum freight order and the visualization.
show_to_user(max_freight_df)
show_to_user(fig)
```","The input code does not highlight the order with the maximum freight cost on the visualization. The reference implementation uses `add_scatter` to mark the maximum freight cost, which is missing in the input code, making it incomplete regarding the specified request.",None
Find the top 5 products based on total quantity sold and create a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user have been defined as per environment constraints

# SQL query to get top 5 products by total quantity sold
sql_query = """"""
SELECT ProductName, SUM([Order Details].Quantity) AS TotalQuantitySold
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY ProductName
ORDER BY TotalQuantitySold DESC
LIMIT 5;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductName', y='TotalQuantitySold',
             title='Top 5 Products by Total Quantity Sold',
             labels={'ProductName': 'Product Name', 'TotalQuantitySold': 'Total Quantity Sold'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantitySold
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantitySold DESC
LIMIT 5
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalQuantitySold', title='Top 5 Products by Total Quantity Sold', labels={'TotalQuantitySold': 'Total Quantity Sold', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. Both implementations execute a SQL query to retrieve and sum the total quantity of products sold, group by product name, and limit the results to the top 5 products. The input code also composes the bar chart using Plotly with the same conditions. The key difference is the inclusion of 'ProductID' in the GROUP BY clause of the input, which does not affect the primary result since 'ProductName' ensures correct aggregation for this context.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY products.ProductName
ORDER BY TotalQuantity DESC
LIMIT 5;
""""""

# Execute SQL query to get the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Function to connect to the database and execute the query
    # Placeholder implementation; replace with actual database interaction
    pass

# Function to display the results to the user
def show_to_user(data):
    # Placeholder implementation for displaying data
    pass

# Fetching the data using the execute_sql_query function
top_products_df = execute_sql_query(sql_query)

# Creating a bar chart using Plotly for visualization
fig = px.bar(top_products_df, x='ProductName', y='TotalQuantity', title='Top 5 Products by Quantity Sold')

# Display the bar chart
show_to_user(fig)
```","The provided code accomplishes the same task as the reference implementation. It correctly executes an SQL query to retrieve the top 5 products based on the total quantity sold, groups and orders them appropriately, and uses Plotly to create a bar chart. The structure of the SQL query is the same, with minor differences in alias naming, which do not affect the correctness. The final visualization using Plotly and the function to show the chart (show_to_user) are also correctly implemented.",both
What is the current stock status of products by category? Include a visualization such as a bar chart to represent stock levels across different categories.,"```python
import pandas as pd
import plotly.express as px

# Dummy function placeholders for the existing utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating SQL execution and returning a DataFrame
    # In a real environment, this would interact with a database
    data = {
        'CategoryID': [1, 1, 2, 2, 3, 3],
        'ProductID': [101, 102, 201, 202, 301, 302],
        'ProductName': ['Product A', 'Product B', 'Product C', 'Product D', 'Product E', 'Product F'],
        'UnitsInStock': [50, 20, 70, 30, 90, 40]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # In a real application, this would display data to the user
    pass

# SQL query provided in the request
sql_query = ""SELECT p.CategoryID, p.ProductID, p.ProductName, p.UnitsInStock FROM products p ORDER BY p.CategoryID;""

# Execute the SQL query and get the resultant DataFrame
df_products = execute_sql_query(sql_query)

# Aggregate stock levels by category
category_stock_status = df_products.groupby('CategoryID').sum().reset_index()

# Create a bar chart using Plotly
fig = px.bar(category_stock_status, x='CategoryID', y='UnitsInStock', 
             labels={'UnitsInStock': 'Units in Stock', 'CategoryID': 'Category ID'},
             title='Current Stock Status by Category')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(p.UnitsInStock) AS TotalUnitsInStock
FROM products p
WHERE p.Discontinued = 0
GROUP BY p.CategoryID
""""""
stock_data = execute_sql_query(sql_query)

fig = px.bar(stock_data, x='CategoryID', y='TotalUnitsInStock', 
             title='Current Stock Status of Products by Category',
             labels={'CategoryID': 'Category ID', 'TotalUnitsInStock': 'Total Units In Stock'})
show_to_user(fig)
```","The input code does not fully align with the reference implementation for several reasons: 1. The input code includes a condition 'WHERE p.Discontinued = 0', which filters out discontinued products, while the reference code does not apply such a filter. 2. The input code directly aggregates the units in stock using the SQL query, while the reference implementation first retrieves all products and then performs grouping and summation using pandas. These differences suggest the input code alters the logic and data scope compared to the reference implementation.","import pandas as pd
import plotly.express as px

# SQL query to retrieve the current stock status of products by category
sql_query = """"""
SELECT CategoryID, CategoryName, SUM(UnitsInStock) AS TotalStock 
FROM products 
JOIN categories ON products.CategoryID = categories.CategoryID 
GROUP BY CategoryID, CategoryName;
""""""

# Execute the SQL query and store the result in a DataFrame
df_stock_by_category = execute_sql_query(sql_query)

# Create a bar chart to visualize the stock levels across different categories
fig = px.bar(
    df_stock_by_category, 
    x='CategoryName', 
    y='TotalStock', 
    title='Stock Levels by Category',
    labels={'CategoryName': 'Category', 'TotalStock': 'Total Units In Stock'}
)

# Display the bar chart to the user
show_to_user(fig)
","The input Python code correctly answers the business analytics request by summarizing and visualizing stock levels by category. The main difference is the inclusion of the category name in the input code, which improves the chart's readability. Both versions group and aggregate stock by category and visualize the results using a bar chart, adhering to the overall logic of the reference implementation.",Finetuned
Identify and visualize orders with more than five products that received a discount.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT OrderID, COUNT(ProductID) AS ProductCount
FROM [Order Details] 
WHERE Discount > 0 
GROUP BY OrderID 
HAVING COUNT(ProductID) > 5;
""""""

# Execute the SQL query and get the data as a pandas DataFrame
orders_with_discounts = execute_sql_query(sql_query)

# Visualize the results
if not orders_with_discounts.empty:
    fig = px.bar(orders_with_discounts, x='OrderID', y='ProductCount', orientation='v',
                 title='Orders with More Than Five Products and a Discount',
                 labels={'OrderID': 'Order ID', 'ProductCount': 'Number of Products'})
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Message': ['No such orders found.']}))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.OrderID, SUM(od.Quantity) AS TotalProducts, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0
GROUP BY o.OrderID
HAVING SUM(od.Quantity) > 5
""""""

orders_with_discount = execute_sql_query(sql_query)

fig = px.bar(orders_with_discount, x='OrderID', y='TotalProducts', title='Orders with More Than Five Products Receiving a Discount')
show_to_user(fig)
```","The input Python code deviates from the reference implementation in key ways. The reference code calculates the number of distinct products per order having a discount, while the input code sums the product quantities per order. Thus, it answers a different question about total quantities rather than counting product instances.","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query and return the data as a DataFrame
def execute_sql_query(sql_query: str):
    # Mock implementation for the purpose of this code
    # This function should be implemented to execute the SQL and return a DataFrame
    data = {
        'OrderID': [1, 2, 3],
        'Quantity': [10, 15, 8],
        'Discount': [0.1, 0.05, 0.15]
    }
    return pd.DataFrame(data)


# Function to show data to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to find orders with more than five products that received a discount
sql_query = '''
SELECT OrderID, SUM(Quantity) AS TotalQuantity FROM ""Order Details""
WHERE Discount > 0 GROUP BY OrderID HAVING SUM(Quantity) > 5;
'''

# Execute the SQL query
orders = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(orders, x='OrderID', y='TotalQuantity', title='Orders with More Than 5 Products and Discount')
show_to_user(fig)
```","The input code is not following the same logic as the reference implementation. The input code sums the 'Quantity' for orders where a discount is applied, but it does not correctly count distinct 'ProductID's per 'OrderID'. The reference checks for more than five unique products, not just a total quantity exceeding five. Therefore, the input code does not meet the business analytics request.",None
What is the distribution of order quantities? Include a histogram or bar chart to visualize the distribution.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the distribution of order quantities
sql_query = """"""
SELECT Quantity, COUNT(*) AS Frequency 
FROM [Order Details] 
GROUP BY Quantity 
ORDER BY Frequency DESC;
""""""

# Execute the SQL query and get the results as a DataFrame
order_quantity_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of order quantities
fig = px.bar(order_quantity_df, x='Quantity', y='Frequency', 
             title='Distribution of Order Quantities', 
             labels={'Quantity': 'Order Quantity', 'Frequency': 'Frequency'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.Quantity
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
""""""

order_quantities = execute_sql_query(sql_query)

fig = px.histogram(order_quantities, x='Quantity', title='Distribution of Order Quantities', nbins=30)
show_to_user(fig)
```","The input code generates a histogram of order quantities directly from the 'Order Details' table, whereas the reference code uses a SQL query to count the frequency of each quantity and creates a bar chart. The input lacks the frequency aggregation that the business request specifies, hence deviates from the reference logic.","```python
import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = ""SELECT Quantity, COUNT(*) as Count FROM [Order Details] GROUP BY Quantity ORDER BY Count DESC;""

# Execute the SQL query to fetch the data
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of order quantities
fig = px.bar(df, x='Quantity', y='Count', title='Distribution of Order Quantities', labels={'Quantity': 'Order Quantity', 'Count': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request and adheres to the same logic as the reference implementation. It executes a SQL query to count the frequency of each order quantity, grouping by quantity and ordering the results by frequency (or count in the input code). It then uses Plotly Express to generate a bar chart to visualize the distribution, similar to the reference implementation. The different variable names for frequency ('Count' vs 'Frequency') do not affect the logic or outcome of the code.",Finetuned
Find the average freight cost for orders shipped to each country and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str):
    # Mock function for executing SQL query, returning a DataFrame
    # In real usage, implement the connection and fetching logic
    data = {
        'ShipCountry': ['USA', 'Germany', 'Canada'],
        'AverageFreight': [80.0, 95.5, 67.3]
    }
    return pd.DataFrame(data)

# Execute the given SQL query
sql_query = ""SELECT ShipCountry, AVG(Freight) AS AverageFreight FROM orders GROUP BY ShipCountry;""
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipCountry', y='AverageFreight', title='Average Freight Cost by Country')

# Function to show the result to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Country, AVG(o.Freight) AS AverageFreight
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
GROUP BY c.Country
""""""

average_freight_df = execute_sql_query(sql_query)

fig = px.bar(average_freight_df, x='Country', y='AverageFreight', title='Average Freight Cost by Country')
show_to_user(fig)
```","The input code differs from the reference code in terms of the SQL query logic. The input code joins the 'orders' and 'customers' tables using the 'CustomerID', whereas the reference code selects directly from the 'orders' table and groups by 'ShipCountry'. This discrepancy can lead to different average freight calculations if the data model uses different country fields in 'orders' and 'customers' tables.","```python
import plotly.express as px
import pandas as pd

# SQL query to find the average freight cost for orders shipped to each country
sql_query = """"""
SELECT ShipCountry, AVG(Freight) AS AverageFreight FROM orders GROUP BY ShipCountry;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Visualizing the results using a bar chart
fig = px.bar(df, x='ShipCountry', y='AverageFreight', title='Average Freight Cost by Country')

# Display the visualization
show_to_user(fig)
```","The input Python code correctly follows the same logic as the reference implementation. Both codes execute the same SQL query to calculate the average freight by country and utilize Plotly Express to create and display a bar chart of the results. The core functionality of querying the database and visualizing using Plotly is consistent across both implementations. Although helper functions like 'execute_sql_query' and 'show_to_user' are assumed to be defined elsewhere, they operate similarly in both implementations, supporting the task's goal effectively.",Finetuned
Which region has the lowest average order value? Include a bar chart to visualize the average order value by region.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch average order value by region
sql_query = """"""
SELECT o.ShipRegion, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.ShipRegion 
ORDER BY AvgOrderValue ASC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Display the region with the lowest average order value
lowest_avg_order_value_region = df.iloc[0]
show_to_user(lowest_avg_order_value_region)

# Create a bar chart to visualize the average order value by region
fig = px.bar(df, x='ShipRegion', y='AvgOrderValue', title='Average Order Value by Region')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipRegion, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    ShipRegion
ORDER BY 
    AverageOrderValue ASC
""""""

average_order_values = execute_sql_query(sql_query)

lowest_avg_order_value_region = average_order_values.iloc[0]

fig = px.bar(average_order_values, x='ShipRegion', y='AverageOrderValue', 
             title='Average Order Value by Region', 
             labels={'AverageOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})

show_to_user(fig)
```","The input code correctly executes a query that calculates the average order value by region, sorting the results in ascending order. It retrieves the region with the lowest average order value and visualizes the results with a bar chart, consistent with the specified business analytics request and logical steps in the reference code. Any differences in variable names or function parameters do not affect correctness.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT o.ShipRegion, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.ShipRegion 
ORDER BY AvgOrderValue ASC;
'''

# Fetch the data using the execute_sql_query utility function
df = execute_sql_query(sql_query)

# Generate a bar chart to visualize average order value by region
fig = px.bar(df, x='ShipRegion', y='AvgOrderValue', title='Average Order Value by Region', labels={'AvgOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})

# Display the visualization using the show_to_user utility function
show_to_user(fig)
```","The input code generates a bar chart but does not identify or display the region with the lowest average order value as the reference code does. The task requires both finding the lowest average order value and visualizing it, but the input code only satisfies the visualization part.",Base
"Which products need to be reordered based on their reorder level, and can we visualize this with a bar chart showing current stock levels against reorder levels?","import pandas as pd
import plotly.express as px

# Define SQL query to fetch necessary data
sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock <= ReorderLevel AND Discontinued = 0;
""""""

# Execute the SQL query
product_data_df = execute_sql_query(sql_query)

# If there are products to reorder, create a bar chart
if not product_data_df.empty:
    fig = px.bar(
        product_data_df,
        x='ProductName',
        y=['UnitsInStock', 'ReorderLevel'],
        title='Current Stock Levels vs Reorder Levels',
        labels={'value': 'Quantity', 'variable': 'Level'},
        barmode='group'
    )
    
    # Display the bar chart
    show_to_user(fig)
else:
    # Display message if no products need reordering
    show_to_user(pd.DataFrame({'Message': ['No products need reordering']}))","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE Discontinued = 0
AND UnitsInStock <= ReorderLevel;
""""""

reorder_products = execute_sql_query(sql_query)

fig = px.bar(reorder_products, 
             x='ProductName', 
             y=['UnitsInStock', 'ReorderLevel'], 
             barmode='group', 
             title='Current Stock Levels vs. Reorder Levels',
             labels={'value': 'Quantity', 'variable': 'Stock Type'})

show_to_user(fig)
```","The input code and the reference implementation both correctly identify products needing reorder by comparing UnitsInStock to ReorderLevel while ensuring products are not discontinued. Both implementations visualize these products using a bar chart to compare current stock levels against reorder levels. The essential logic and outcome are equivalent, fulfilling the business analytics request.","
import pandas as pd
import plotly.express as px

# SQL query to fetch products needing reorder
sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel
""""""

# Execute the SQL query using the utility function
products_df = execute_sql_query(sql_query)

# Visualization: Bar chart with current stock levels against reorder levels
fig = px.bar(
    products_df,
    x='ProductName',
    y=['UnitsInStock', 'ReorderLevel'],
    title='Current Stock Levels vs Reorder Levels',
    labels={'value': 'Units', 'variable': 'Stock'},
)

# Display the bar chart using the provided utility function
show_to_user(fig)
","The input code does not match the reference implementation because it does not check if the product is 'Discontinued = 0' in the SQL query. This is necessary to ensure that discontinued products are not considered for reorder. Additionally, the input code does not handle the case where no products need reordering by displaying a message. The bar chart configuration is slightly different, though it primarily affects labels.",Base
List the customers who have never received a discount on their orders and include a bar chart showing the number of orders for those customers.,"```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function for executing SQL and returning a DataFrame
    pass

def show_to_user(data):
    # This is a placeholder function for displaying data to the user
    pass

# SQL query to find customers who have never received a discount
sql_query = """"""
SELECT DISTINCT CustomerID 
FROM customers 
WHERE CustomerID NOT IN (
    SELECT DISTINCT CustomerID 
    FROM orders 
    JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
    WHERE Discount > 0
);
""""""

# Execute the SQL query
customers_no_discount_df = execute_sql_query(sql_query)

# SQL query to get the count of orders for customers with no discount
orders_count_sql_query = """"""
SELECT CustomerID, COUNT(OrderID) as OrderCount 
FROM orders 
WHERE CustomerID IN (
    SELECT DISTINCT CustomerID 
    FROM customers 
    WHERE CustomerID NOT IN (
        SELECT DISTINCT CustomerID 
        FROM orders 
        JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
        WHERE Discount > 0
    )
) 
GROUP BY CustomerID;
""""""

# Execute the SQL query to get order counts
orders_count_df = execute_sql_query(orders_count_sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_count_df, x='CustomerID', y='OrderCount', title='Number of Orders for Customers with No Discounts')

# Display the result
show_to_user(customers_no_discount_df)  # Display the list of customers
show_to_user(fig)  # Display the bar chart
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS NumberOfOrders
FROM customers c
LEFT JOIN orders o ON c.CustomerID = o.CustomerID
LEFT JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
HAVING SUM(od.Discount) = 0
""""""

customers_no_discount = execute_sql_query(sql_query)

fig = px.bar(customers_no_discount, 
              x='CompanyName', 
              y='NumberOfOrders', 
              title='Number of Orders for Customers with No Discounts',
              labels={'CompanyName': 'Customer', 'NumberOfOrders': 'Number of Orders'})

show_to_user(fig)
```","The input Python code's logic differs from the reference implementation. It incorrectly uses a LEFT JOIN and checks the sum of discounts to be zero, which could include customers who have received discounts but net to zero across orders. The reference code specifically queries for customers who have never had any instances of discounts, using a subquery to exclude such customers.","```python
import pandas as pd
import plotly.express as px

# SQL query to find customers with no discounts
sql_query = """"""
SELECT c.CustomerID 
FROM customers c 
LEFT JOIN orders o ON c.CustomerID = o.CustomerID 
LEFT JOIN (
    SELECT OrderID 
    FROM [Order Details] 
    WHERE Discount > 0
) od ON o.OrderID = od.OrderID 
WHERE od.OrderID IS NULL;
""""""

# Execute the SQL query
customers_no_discount = execute_sql_query(sql_query)

# Count the number of orders for each customer who has never received a discount
orders_count = (
    customers_no_discount['CustomerID']
    .value_counts()
    .reset_index()
    .rename(columns={'index': 'CustomerID', 'CustomerID': 'OrderCount'})
)

# Create a bar chart using Plotly
fig = px.bar(orders_count, x='CustomerID', y='OrderCount',
             title='Number of Orders for Customers with No Discounts',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code incorrectly calculates the number of orders for each customer who never received a discount. It uses 'value_counts' directly on the results of the first query without actually querying the orders table to get accurate order counts. The reference implementation uses a nested query to get distinct customers with no discounts and then counts orders for those customers, which maintains the SQL database relations. The input code instead relies on counting CustomerIDs without checking actual order counts from the orders table.",None
Determine the month with the highest number of orders shipped and provide a bar chart to visualize the monthly order volumes.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly order counts
sql_query = """"""
SELECT MONTH(ShippedDate) AS ShipMonth, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE ShippedDate IS NOT NULL 
GROUP BY ShipMonth 
ORDER BY ShipMonth;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Find the month with the highest number of orders shipped
max_orders_month = orders_df.loc[orders_df['OrderCount'].idxmax()]

# Create a bar chart to visualize monthly order volumes
fig = px.bar(orders_df, x='ShipMonth', y='OrderCount', 
             title=""Monthly Order Volumes"",
             labels={'ShipMonth': 'Month', 'OrderCount': 'Number of Orders'},
             text='OrderCount')

# Show the bar chart to the user
show_to_user(fig)

# Print the month with the highest order count
show_to_user(pd.DataFrame([max_orders_month]))
```","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch monthly order counts
sql_query = """"""
SELECT DATE_FORMAT(ShippedDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY Month
ORDER BY Month
""""""

# Execute the SQL query
monthly_orders = execute_sql_query(sql_query)

# Determine the month with the highest number of orders
highest_month = monthly_orders.loc[monthly_orders['OrderCount'].idxmax()]

# Create a bar chart for monthly order volumes
fig = px.bar(monthly_orders, x='Month', y='OrderCount', title='Monthly Order Volumes', 
             labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})

# Display the chart to the user
show_to_user(fig)
```","The input code calculates monthly order volumes using a year-month format (`'%Y-%m'`), which includes the year, whereas the reference implementation only considers the month (`MONTH(ShippedDate)`). Including the year changes the aggregation logic, leading to potentially different monthly groupings and results. Therefore, the logic is not the same, resulting in different outcomes for the month with the highest number of orders.","```python
import plotly.express as px
import pandas as pd

# Execute the SQL query to retrieve monthly order data
sql_query = """"""
SELECT DATE_TRUNC('month', o.OrderDate) AS Month, 
       COUNT(o.OrderID) AS OrderVolume 
FROM orders o 
WHERE o.ShippedDate IS NOT NULL 
GROUP BY Month 
ORDER BY Month;
""""""
# Function to execute the SQL query
monthly_orders_df = execute_sql_query(sql_query)

# Find the month with the highest number of shipped orders
max_orders_df = monthly_orders_df.loc[monthly_orders_df['OrderVolume'].idxmax()]

# Output the month with the highest number of shipped orders
show_to_user(max_orders_df)

# Create a bar chart of monthly order volumes
fig = px.bar(monthly_orders_df, x='Month', y='OrderVolume', 
             title='Monthly Order Volumes', labels={'OrderVolume': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)

```","The input code correctly retrieves monthly order data for shipped orders using a SQL query and accurately computes the month with the highest number of orders. It visualizes the data using a bar chart with the correctly labeled axes, similar to the reference code. Despite differences in SQL syntax (DATE_TRUNC vs. MONTH) and variable names, the logic aligns with the reference code's intent.",Finetuned
"What is the average discount given per order each month, and can this be visualized with a line chart showing trends over time?","
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       AVG([Order Details].Discount) AS average_discount 
FROM [Order Details] 
JOIN orders ON orders.OrderID = [Order Details].OrderID 
GROUP BY month;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Convert month to datetime for better plotting
# Ensure the column 'month' is a string to convert it into datetime format
df['month'] = pd.to_datetime(df['month'], format='%Y-%m')

# Visualize the average discount per order each month using a line chart
fig = px.line(df, x='month', y='average_discount', title='Average Discount Per Order Each Month')

# Show the line chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    AVG([Order Details].Discount) AS AverageDiscount
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

discount_data = execute_sql_query(sql_query)

fig = px.line(discount_data, x='Month', y='AverageDiscount', title='Average Discount per Order Each Month')
show_to_user(fig)
```","The input code closely follows the logic of the reference implementation. It uses a SQL query to calculate the monthly average discount by grouping by month and averages the discounts properly. The resulting data is visualized using Plotly Express to create a line chart, showing trends over time. The necessary transformations for date formatting are effectively handled, assuming 'execute_sql_query' retrieves the results as expected. The presence of ORDER BY does not affect correctness. Thus, both the question and logic are addressed adequately.","```python
import pandas as pd
import plotly.express as px

# SQL query to compute the average discount given per order each month
sql_query = """"""
SELECT TO_CHAR(OrderDate, 'YYYY-MM') AS OrderMonth, AVG(Discount) AS AvgDiscount 
FROM [Order Details] 
INNER JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY OrderMonth;
""""""

# Execute the SQL query and return the result as a DataFrame
df = execute_sql_query(sql_query)

# Convert the 'OrderMonth' column to datetime for proper sorting
df['OrderMonth'] = pd.to_datetime(df['OrderMonth'], format='%Y-%m')

# Create a line chart to visualize the average discount trends over time
fig = px.line(df, x='OrderMonth', y='AvgDiscount', title='Average Discount per Order Each Month',
              labels={'OrderMonth': 'Month', 'AvgDiscount': 'Average Discount'},
              template='plotly_white')

# Display the line chart to the user
show_to_user(fig)
```","The input code correctly follows the same logic as the reference implementation. It executes a SQL query to calculate the average discount per order each month, grouping the results by month. It then converts the month column to a datetime format for proper sorting in the line chart. Finally, it uses Plotly Express to create a line chart to visualize the average discount trends over time. Although there are minor differences such as SQL syntax (using TO_CHAR vs DATE_FORMAT) and column naming, the logic and output are consistent with the reference implementation.",both
"What is the total number of products ordered each month? Additionally, can you provide a line chart to visualize the monthly totals?","import plotly.express as px
import pandas as pd


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for executing the SQL query
    # Returns a pandas DataFrame
    pass


def show_to_user(data):
    # Placeholder function to display data or visualization
    pass

# SQL query to retrieve monthly total ordered products
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Quantity) AS TotalProducts 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query and retrieve the data into a DataFrame
monthly_totals_df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(monthly_totals_df, x='Month', y='TotalProducts', title='Total Products Ordered Each Month')

# Display the line chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(Quantity) AS TotalProductsOrdered
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

monthly_totals = execute_sql_query(sql_query)

fig = px.line(monthly_totals, x='Month', y='TotalProductsOrdered', title='Total Products Ordered Each Month', labels={'TotalProductsOrdered': 'Total Products Ordered', 'Month': 'Month'})
show_to_user(fig)
```","The input Python code achieves the same purpose as the reference implementation. It executes a SQL query to calculate the total number of products ordered each month, groups results by month, and then uses Plotly to create a line chart for visualization. The variable names and SQL specifics are slightly different (e.g., alias names like 'TotalProductsOrdered'), but the logic and the outcome match the reference implementation. Both codes use the same grouping by month and sum of quantities.","```python
import pandas as pd
import plotly.express as px

# Query to get the total number of products ordered each month
query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
SUM(Quantity) AS TotalProductsOrdered 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY DATE_TRUNC('month', OrderDate);
""""""

# Execute the query using the provided utility function
monthly_totals_df = execute_sql_query(query)

# Convert the 'Month' to datetime for accurate plotting
monthly_totals_df['Month'] = pd.to_datetime(monthly_totals_df['Month'])

# Create a line chart to visualize the monthly totals using Plotly
fig = px.line(monthly_totals_df, x='Month', y='TotalProductsOrdered', 
              title='Total Products Ordered Each Month',
              labels={'TotalProductsOrdered': 'Total Products Ordered'}, 
              markers=True)

# Display the figure to the user
show_to_user(fig)
```","The input code correctly computes the monthly total of products ordered using an SQL query similar to the reference code. Both codes aggregate quantities based on monthly order dates, albeit using different SQL functions (DATE_TRUNC vs. DATE_FORMAT), which serve the same purpose in different SQL dialects. Both implementations use Plotly to generate a line chart, with the input code adding markers and labels for clarity. The logic and outcome match the business request and reference implementation.",both
"What is the average freight cost for shipped orders, and can you provide a visualization to depict the distribution of these costs?","import plotly.express as px
import pandas as pd

# Define the SQL query to fetch shipped orders
sql_query = """"""
SELECT Freight FROM orders WHERE ShippedDate IS NOT NULL;
""""""

# Execute the SQL query using the utility function and get the data in a DataFrame
df = execute_sql_query(sql_query)

# Calculate the average freight cost
avg_freight = df['Freight'].mean()
avg_df = pd.DataFrame({'AvgFreight': [avg_freight]})

# Display the average freight cost to the user
show_to_user(avg_df)

# Create a histogram to visualize the distribution of freight costs
fig = px.histogram(df, x='Freight', title='Distribution of Freight Costs')

# Show the visualization to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Freight
FROM orders
WHERE ShippedDate IS NOT NULL
""""""

freight_data = execute_sql_query(sql_query)
average_freight = freight_data['Freight'].mean()

fig = px.histogram(freight_data, x='Freight', title='Distribution of Freight Costs')
show_to_user(fig)

average_freight
```","The input code correctly calculates the average freight cost and visualizes the distribution, but it does not display the average freight to the user as required. The reference code creates and displays a DataFrame with the average freight, which the input code lacks.","```python
import plotly.express as px
import pandas as pd

# Function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str):
    # Stub function for example; implement SQL execution logic here
    # This should return a pandas DataFrame
    pass

# Function to send data or visualizations to the user
def show_to_user(data):
    # Stub function for example; implement user display logic here
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch the average freight cost for shipped orders
sql_query = """"""
SELECT Freight FROM orders WHERE ShippedDate IS NOT NULL
""""""

# Execute the query and get the DataFrame
orders_df = execute_sql_query(sql_query)

# Calculate the average freight cost
average_freight_cost = orders_df['Freight'].mean()

# Output the average freight cost
average_df = pd.DataFrame({'AverageFreightCost': [average_freight_cost]})
show_to_user(average_df)

# Create a distribution plot of freight costs
fig = px.histogram(orders_df, x='Freight', title='Distribution of Freight Costs for Shipped Orders')

# Show the visualization
show_to_user(fig)
```","The input code correctly follows the same logic as the reference implementation. It executes an SQL query to retrieve 'Freight' for shipped orders, calculates the average freight cost, and creates a histogram to visualize the distribution of freight costs. Both implementations follow identical logical steps and make use of appropriate libraries and functions to accomplish the task.",Finetuned
Which product has the highest sales volume this month? Please include a bar chart to visualize the sales volumes of different products.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL query for fetching sales volume data
sql_query = """"""
SELECT p.ProductID, SUM(od.Quantity) as TotalQuantity
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE EXTRACT(MONTH FROM CURRENT_DATE) = EXTRACT(MONTH FROM od.OrderDate) 
GROUP BY p.ProductID 
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query and fetch the results into a DataFrame
products_df = execute_sql_query(sql_query)

# Identify the product with the highest sales volume
if not products_df.empty:
    top_product = products_df.iloc[0]

# Visualize the sales volumes of different products using a bar chart
fig = px.bar(products_df, x='ProductID', y='TotalQuantity', 
             title='Sales Volume of Different Products This Month',
             labels={'ProductID': 'Product ID', 'TotalQuantity': 'Sales Volume'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the current month
current_month = pd.Timestamp.now().to_period('M')

# SQL query to get sales volume for products in the current month
sql_query = f""""""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS SalesVolume
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE DATE_FORMAT(od.OrderDate, '%Y-%m') = '{current_month}'
GROUP BY p.ProductID, p.ProductName
ORDER BY SalesVolume DESC
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Find the product with the highest sales volume
highest_sales_product = sales_data.iloc[0]

# Create a bar chart for visualizing sales volumes
fig = px.bar(sales_data, x='ProductName', y='SalesVolume', title='Sales Volumes of Products This Month', labels={'SalesVolume':'Sales Volume', 'ProductName':'Product Name'})
show_to_user(fig)
```","The input code correctly addresses the business analytics request by calculating the sales volume for each product for the current month and displaying the results in a bar chart. It adheres to the logic of the reference code by joining the product and order details tables, grouping by product, ordering by sales volume, and using Plotly to create a bar chart. Although it includes the 'ProductName' in the query and chart, this does not affect the correctness of meeting the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
            SELECT products.ProductID, SUM([Order Details].Quantity) AS total_sales
            FROM [Order Details]
            JOIN products ON [Order Details].ProductID = products.ProductID
            JOIN orders ON [Order Details].OrderID = orders.OrderID
            WHERE MONTH(orders.OrderDate) = MONTH(CURDATE()) AND YEAR(orders.OrderDate) = YEAR(CURDATE())
            GROUP BY products.ProductID
            ORDER BY total_sales DESC;
            """"""

# Execute the query and get the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart for the sales volumes
fig = px.bar(sales_data, x='ProductID', y='total_sales', title='Sales Volume by Product for Current Month')

# Show the result
show_to_user(fig)
```","Both implementations correctly determine which product has the highest sales volume for the current month and visualize the sales using a bar chart. They use different SQL functions to get the current month (EXTRACT vs MONTH), but this does not affect the correctness of the logic. Both query the products and order details tables, summing quantities for the current month, grouping by product, and ordering by sales. The bar chart implementations are equivalent in functionality.",both
"What is the total discount given for each product, and can you provide a bar chart to illustrate these discounts?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT od.ProductID, 
       SUM(od.Quantity * od.UnitPrice * od.Discount) AS TotalDiscountGiven 
FROM [Order Details] od 
GROUP BY od.ProductID;
""""""

# Execute the SQL query
product_discounts_df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the total discounts
fig = px.bar(product_discounts_df, 
             x='ProductID', 
             y='TotalDiscountGiven', 
             title='Total Discount Given for Each Product', 
             labels={'TotalDiscountGiven': 'Total Discount Given', 'ProductID': 'Product ID'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    [Order Details].ProductID, 
    SUM([Order Details].Discount) AS TotalDiscount 
FROM 
    [Order Details] 
GROUP BY 
    [Order Details].ProductID
""""""

discounts_df = execute_sql_query(sql_query)

fig = px.bar(discouts_df, x='ProductID', y='TotalDiscount', title='Total Discount per Product',
             labels={'TotalDiscount': 'Total Discount', 'ProductID': 'Product ID'})

show_to_user(fig)
```","The test code calculates the total discount by summing the 'Discount' column directly, which does not account for the quantity and unit price multipliers. The reference code correctly calculates total discount by multiplying quantity, unit price, and discount rate for each product. The chart visualization part is otherwise similar.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would connect to a database, execute the given SQL query,
    # and return the results as a pandas DataFrame. For now, a placeholder:
    pass

# SQL query to calculate the total discount per product
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * Discount) AS TotalDiscount FROM [Order Details] GROUP BY ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the execution succeeded
if df is not None and not df.empty:
    # Create a bar chart for the total discount for each product
    fig = px.bar(df, x='ProductID', y='TotalDiscount', title='Total Discount by Product')
    
    # Function to show data to user
    def show_to_user(data):
        if isinstance(data, pd.DataFrame):
            print(data)
        elif isinstance(data, px.Figure):
            data.show()

    # Display the bar chart
    show_to_user(fig)
else:
    print(""No data retrieved from the query."")
```","The input code closely follows the logic of the reference implementation. Both scripts execute an SQL query to calculate the total discount per product by summing the product of Quantity, UnitPrice, and Discount, grouping by ProductID. After obtaining the data, both codes use Plotly Express to create a bar chart illustrating the total discounts with ProductID on the x-axis and the calculated TotalDiscount values on the y-axis. The methods for displaying the chart differ slightly in implementation, but both achieve the same functional outcome. Thus, the input code is correct with respect to the task description and the reference implementation.",Finetuned
What is the total quantity of products sold by each employee? Please include a bar chart to visualize the sales quantities per employee.,"import pandas as pd
import plotly.express as px

# SQL query to fetch the total quantity of products sold by each employee
query = """"""
SELECT e.EmployeeID, SUM(od.Quantity) AS TotalQuantity
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(query)

# Create a bar chart using Plotly to visualize the sales quantities per employee
fig = px.bar(df, x='EmployeeID', y='TotalQuantity', title='Total Quantity of Products Sold by Each Employee')

# Display the bar chart to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    SUM(od.Quantity) AS TotalQuantity
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='EmployeeID', y='TotalQuantity', text='TotalQuantity', 
             title='Total Quantity of Products Sold by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalQuantity': 'Quantity Sold'})
show_to_user(fig)
```",The input code correctly computes the total quantity of products sold by each employee and visualizes it with a bar chart. It includes additional employee details (FirstName and LastName) but this does not affect the calculation of TotalQuantity. The logic aligns with the reference implementation despite the extra columns in the GROUP BY clause.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the total quantity of products sold by each employee
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].Quantity) AS TotalQuantity
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize sales quantities per employee
fig = px.bar(df, x='EmployeeID', y='TotalQuantity', title='Total Products Sold by Each Employee')

# Display the figure using the show_to_user utility function
show_to_user(fig)
```","The input code is functionally equivalent to the reference code. Both have the same SQL query structure to calculate the total product quantities sold by each employee by joining the same tables. The DataFrame and Plotly bar chart generation are also correctly implemented and identical in logic. Therefore, the code is correct.",both
Which products have a unit price greater than $50? Please include a bar chart to visualize the count of these products by category.,"```python
import plotly.express as px

# SQL query to fetch products with a unit price greater than $50
sql_query = ""SELECT ProductName, CategoryName FROM products WHERE UnitPrice > 50;""

# Execute the SQL query and get the result as a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Count the number of products by category
product_count_by_category = products_df.groupby('CategoryName').size().reset_index(name='Count')

# Create a bar chart using Plotly to visualize the count of products by category
fig = px.bar(product_count_by_category, x='CategoryName', y='Count', title='Count of Products with Unit Price > $50 by Category')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, p.ProductName, p.UnitPrice 
FROM products p 
WHERE p.UnitPrice > 50
""""""

products_above_50 = execute_sql_query(sql_query)

category_count = products_above_50['CategoryID'].value_counts().reset_index()
category_count.columns = ['CategoryID', 'Count']

fig = px.bar(category_count, x='CategoryID', y='Count', title='Count of Products with Unit Price > $50 by Category')
show_to_user(fig)
```","The input code retrieves 'CategoryID' instead of 'CategoryName.' This might affect readability or interpretation of the chart since 'CategoryName' is more informative for presentation. Both implementations correctly filter products with a UnitPrice greater than $50 and visualize the counts. However, if 'CategoryID' is used with no corresponding category names, it deviates from the business request to display categories by name.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = ""SELECT ProductID, CategoryName FROM products WHERE UnitPrice > 50;""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df_products = execute_sql_query(sql_query)

# Count the products by category
category_counts = df_products['CategoryName'].value_counts().reset_index()
category_counts.columns = ['CategoryName', 'Count']

# Create a bar chart to visualize the count of products by category
fig = px.bar(category_counts, x='CategoryName', y='Count',
             labels={'CategoryName': 'Category', 'Count': 'Number of Products'},
             title='Number of Products with Unit Price Greater than $50 by Category')

# Display the bar chart
show_to_user(fig)
```","The input Python code effectively fulfills the business analytics request similar to the reference implementation. Both the input and reference code query products with a unit price greater than $50 and visualize the count by category using a bar chart. The key differences, such as using 'ProductID' instead of 'ProductName' and employing 'value_counts' instead of 'groupby', do not affect the correctness as both methods accurately calculate and display the desired information.",Finetuned
Identify the product with the lowest performance in terms of sales in October 2023 and include a visual comparison of product sales.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented already
    pass

def show_to_user(data):
    # This function is assumed to be implemented already
    pass

# SQL query provided from the business request
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS product_performance 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-10-31' 
GROUP BY products.ProductName 
ORDER BY product_performance ASC;
""""""

# Execute the SQL query to obtain the sales performance data
sales_data = execute_sql_query(sql_query)

# Identify the product with the lowest sales performance
lowest_performance_product = sales_data.nsmallest(1, 'product_performance')

# Display the lowest performance product
show_to_user(lowest_performance_product)

# Visual comparison of product sales for October 2023
fig = px.bar(sales_data, x='ProductName', y='product_performance',
             title='Product Sales Performance in October 2023',
             labels={'product_performance': 'Quantity Sold'},
             template='plotly')

# Show the visual comparison
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS product_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-10-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY product_sales ASC
LIMIT 1
""""""

lowest_sales_product = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS product_sales
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-10-01' AND '2023-10-31'
GROUP BY products.ProductID, products.ProductName
ORDER BY product_sales ASC
""""""

all_sales_data = execute_sql_query(sql_query_all)

fig = px.bar(all_sales_data, x='ProductName', y='product_sales', title='Product Sales Comparison in October 2023')
show_to_user(fig)
```","The input code retrieves the product with the lowest sales for October 2023 using an SQL query with a LIMIT 1 clause, which is equivalent to using nsmallest(1). It also fetches all product sales data for visualization. The logic and operations match the reference implementation, making the code correct despite slight differences in approach.","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query and get data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is a placeholder for actual SQL execution
    # Assume it returns a pandas DataFrame based on the provided SQL query
    return pd.read_sql(sql_query, connection)

# Function to show results to the user
def show_to_user(data):
    # This function would display data if a DataFrame is passed
    # It would handle visualizations if a Plotly figure is passed
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to fetch all products' sales for comparison
sql_query = """"""
SELECT P.ProductName, SUM(OD.Quantity) as TotalSales 
FROM products P 
JOIN [Order Details] OD ON P.ProductID = OD.ProductID
JOIN orders O ON OD.OrderID = O.OrderID
WHERE O.OrderDate BETWEEN '2023-10-01' AND '2023-10-31'
GROUP BY P.ProductName
""""""

# Execute SQL query to get product sales data
product_sales_df = execute_sql_query(sql_query)

# Identify the product with the lowest performance in terms of sales
lowest_performance_product = product_sales_df.loc[product_sales_df['TotalSales'].idxmin()]

# Show the product with the lowest performance
show_to_user(lowest_performance_product.to_frame().T)

# Create a visual comparison of product sales
fig = px.bar(product_sales_df, x='ProductName', y='TotalSales',
             title='Product Sales Comparison - October 2023',
             labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'},
             template='plotly')

# Display the visual comparison
show_to_user(fig)
```","The input Python code correctly executes the required task in accordance with the business analytics request and follows the logic of the reference implementation. It retrieves sales data for October 2023 using a SQL query, identifies the product with the lowest sales performance using `idxmin()`, and presents both a textual and visual comparison using Plotly. These steps match the reference code's objectives, even though slight differences in SQL syntax and method names exist.",both
"**""Which city had the highest number of orders shipped to, and can we visualize this with a bar chart to compare the number of orders across different cities?""**","```python
import pandas as pd
import plotly.express as px

# SQL query to get city with highest number of orders shipped
sql_query = """"""
SELECT orders.ShipCity, COUNT(orders.OrderID) AS NumOrders
FROM orders
GROUP BY orders.ShipCity
ORDER BY NumOrders DESC;
""""""

# Executing the SQL query using the utility function
df = execute_sql_query(sql_query)

# Identifying the city with the highest number of orders
highest_orders_city = df.iloc[0]
print(f""The city with the highest number of orders is: {highest_orders_city['ShipCity']} with {highest_orders_city['NumOrders']} orders."")

# Visualizing the number of orders across different cities using a bar chart
fig = px.bar(df, x='ShipCity', y='NumOrders', title='Number of Orders Shipped to Each City', labels={'NumOrders': 'Number of Orders', 'ShipCity': 'City'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipCity
ORDER BY OrderCount DESC
""""""
orders_by_city = execute_sql_query(sql_query)

highest_city = orders_by_city.iloc[0]
fig = px.bar(orders_by_city, x='ShipCity', y='OrderCount', title='Number of Orders Shipped to Each City', labels={'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input Python code correctly executes an SQL query to count orders by city, orders them in descending order, and selects the first city with the highest orders. It visualizes the data with a bar chart using Plotly Express. The logic used to find and display the city with the highest orders matches the reference implementation, fulfilling the business request.","```python
import pandas as pd
import plotly.express as px

# Business analayst's request
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY TotalOrders DESC;
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Find the city with the highest number of orders
highest_orders_city = df_orders.iloc[0]['ShipCity']
highest_orders_count = df_orders.iloc[0]['TotalOrders']

# Display the city with the highest number of orders
show_to_user(pd.DataFrame({
    ""City"": [highest_orders_city],
    ""TotalOrders"": [highest_orders_count]
}))

# Visualize the number of orders across different cities using a bar chart
fig = px.bar(df_orders, x='ShipCity', y='TotalOrders', 
             title='Number of Orders Shipped to Each City',
             labels={'ShipCity': 'City', 'TotalOrders': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)
```","The input code executes the same logic as the reference implementation. It retrieves the number of orders shipped to each city, sorts them to find the city with the highest number of orders, and creates a bar chart to visualize the data. Despite slight differences in variable naming and formatting, it achieves the same outcome and fulfills the business analytics request.",both
"How many customers placed more than five orders last year, and can this be represented in a bar chart showing the number of customers per order count category?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of customers who placed more than five orders last year
sql_query = """"""
SELECT 
    customers.CustomerID,
    COUNT(orders.OrderID) AS order_count
FROM 
    orders 
JOIN 
    customers ON orders.CustomerID = customers.CustomerID 
WHERE 
    YEAR(orders.OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY 
    customers.CustomerID 
HAVING 
    COUNT(orders.OrderID) > 5;
""""""

# Execute the SQL query and store the result in a DataFrame
customers_df = execute_sql_query(sql_query)

# Calculate the number of customers per order count category
order_counts = customers_df['order_count'].value_counts().reset_index()
order_counts.columns = ['order_count', 'customer_count']

# Create a bar chart to represent the number of customers per order count category
fig = px.bar(order_counts, x='order_count', y='customer_count',
             title='Number of Customers by Order Count',
             labels={'order_count': 'Order Count', 'customer_count': 'Number of Customers'})

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count orders per customer for last year
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) as OrderCount 
FROM orders 
WHERE OrderDate BETWEEN '2022-01-01' AND '2022-12-31' 
GROUP BY CustomerID
HAVING COUNT(OrderID) > 5
""""""

# Execute the SQL query
customer_orders = execute_sql_query(sql_query)

# Count how many customers fall into each order count category
order_counts = customer_orders['OrderCount'].value_counts().reset_index()
order_counts.columns = ['OrderCount', 'CustomerCount']

# Create a bar chart
fig = px.bar(order_counts, x='OrderCount', y='CustomerCount', title='Number of Customers per Order Count Category', 
             labels={'OrderCount': 'Order Count', 'CustomerCount': 'Number of Customers'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly counts customers who placed more than five orders last year and represents this data in a bar chart. It queries customers with more than five orders, groups, and counts the results like the reference does. The main difference is the method of filtering dates: the reference uses YEAR with CURDATE(), and the input uses a BETWEEN statement for specific dates ('2022-01-01' to '2022-12-31'). As long as the target year does not change, the logic remains consistent, making the code correct.","```python
import pandas as pd
import plotly.express as px

# Placeholder utility functions (to be defined elsewhere in the actual code)
def execute_sql_query(sql_query: str):
    # This function should connect to the database, execute the query, and return a DataFrame.
    pass

def show_to_user(data):
    # This function should display the data or Plotly figure to the user.
    pass

# SQL query to count distinct customers who placed more than five orders last year
sql_query = """"""
SELECT OrderCounts.CustomerID, COUNT(OrderCounts.OrderID) AS NumberOfOrders
FROM (
    SELECT c.CustomerID, o.OrderID
    FROM customers c
    JOIN orders o ON c.CustomerID = o.CustomerID
    WHERE YEAR(o.OrderDate) = YEAR(CURDATE()) - 1
) AS OrderCounts
GROUP BY OrderCounts.CustomerID
HAVING COUNT(OrderCounts.OrderID) > 5
""""""

# Execute SQL query and get results
df = execute_sql_query(sql_query)

# Create a new DataFrame to categorize customers based on order count
customers_order_count_df = df.groupby('NumberOfOrders').size().reset_index(name='NumberOfCustomers')

# Create a bar chart using Plotly
fig = px.bar(customers_order_count_df, x='NumberOfOrders', y='NumberOfCustomers',
             title='Customers Per Order Count Category',
             labels={'NumberOfOrders': 'Order Count', 'NumberOfCustomers': 'Number of Customers'})

# Display the plot
show_to_user(fig)
```","The input code correctly implements the business request by running a SQL query that counts customers with more than five orders in the previous year, organizes the results in a DataFrame, and displays the data in a bar chart. The logic aligns with the reference code, despite some differences in variable names and structure. Therefore, it meets the intent of the business request.",both
"What is the total quantity of products sold per category, and can it be visualized in a bar chart for better understanding?","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT products.CategoryID, SUM([Order Details].Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.CategoryID
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total quantity of products sold per category
fig = px.bar(df, x='CategoryID', y='TotalQuantity', title='Total Quantity of Products Sold per Category')

# Display the figure using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CategoryID', y='TotalQuantity', title='Total Quantity of Products Sold per Category', labels={'TotalQuantity': 'Total Quantity', 'CategoryID': 'Category ID'})
show_to_user(fig)
```",The input Python code correctly implements the business analytics request by calculating the total quantity of products sold per category and visualizing it as a bar chart. Both the reference and input codes execute an SQL query to aggregate the total quantities by category and create a Plotly bar chart for visualization. The differences in SQL aliasing and labels in the chart parameters do not affect the correctness of the logic or the output.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT UnitPrice, Quantity, CategoryID 
FROM [Order Details] 
JOIN [products] ON [Order Details].ProductID = [products].ProductID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the total quantity of products sold per category
total_quantity_per_category = df.groupby('CategoryID')['Quantity'].sum().reset_index()

# Visualize the total quantity per category in a bar chart
fig = px.bar(total_quantity_per_category, x='CategoryID', y='Quantity', title='Total Quantity per Category')

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates the total quantity of products sold per category by performing a join between 'Order Details' and 'products' tables. It then groups the data by 'CategoryID' and sums the 'Quantity', similar to the reference. Both codes create and display a bar chart using Plotly, achieving the same business requirement.",both
"How many orders include products from multiple suppliers, and can this be visualized using a pie chart or bar graph to show the distribution of order counts?","```python
import pandas as pd
import plotly.express as px

# SQL query to count the number of orders with products from multiple suppliers
sql_query = """"""
SELECT OrderID, COUNT(DISTINCT SupplierID) AS SupplierCount 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY OrderID
""""""

# Execute the SQL query to get the data
order_supplier_df = execute_sql_query(sql_query)

# Filter orders with more than one supplier
multi_supplier_orders_df = order_supplier_df[order_supplier_df['SupplierCount'] > 1]

# Count of orders with products from multiple suppliers
multi_supplier_order_count = len(multi_supplier_orders_df)

# Visualization: Pie chart showing the distribution of order counts
distribution_df = pd.DataFrame({
    'Order Type': ['Multiple Suppliers', 'Single Supplier'],
    'Count': [multi_supplier_order_count, len(order_supplier_df) - multi_supplier_order_count]
})

fig = px.pie(distribution_df, names='Order Type', values='Count', 
             title='Distribution of Order Counts by Supplier Variety')

# Display the pie chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.OrderID, COUNT(DISTINCT p.SupplierID) AS SupplierCount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
GROUP BY o.OrderID
HAVING COUNT(DISTINCT p.SupplierID) > 1
""""""

multi_supplier_orders = execute_sql_query(sql_query)
order_counts = multi_supplier_orders['SupplierCount'].value_counts().reset_index()
order_counts.columns = ['SupplierCount', 'OrderCount']

fig = px.pie(order_counts, values='OrderCount', names='SupplierCount', title='Distribution of Orders with Multiple Suppliers')
show_to_user(fig)
```","The input code deviates from the reference code by filtering directly in the SQL query using 'HAVING COUNT(DISTINCT p.SupplierID) > 1', which effectively returns only orders with products from multiple suppliers. However, it misses counting the total order set including single-supplier orders, which is needed to create a distribution (for comparison) as done in the reference code. Also, 'SupplierCount' is inaccurately labeled in the pie chart; it represents the number of orders with multiple suppliers, not the number of suppliers.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch orders with products from multiple suppliers
sql_query = '''
SELECT o.OrderID 
FROM orders o 
JOIN ""Order Details"" od ON o.OrderID = od.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY o.OrderID 
HAVING COUNT(DISTINCT p.SupplierID) > 1; 
'''

# Function to execute the SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating query execution for demonstration purposes.
    # This should be replaced with actual database execution logic.
    # For example: return pd.read_sql_query(sql_query, database_connection)
    return pd.DataFrame({'OrderID': [1, 2, 3]})  # Mock data

# Execute the SQL query to find orders with products from multiple suppliers
df_orders = execute_sql_query(sql_query)

# Count the number of such orders
order_count = len(df_orders)

# Prepare a summary DataFrame for visualization
summary_df = pd.DataFrame({'OrderType': ['Multi-supplier Orders', 'Other'], 'Count': [order_count, 0]})

# Visualize the data using a pie chart
fig = px.pie(
    summary_df, 
    values='Count', 
    names='OrderType', 
    title='Distribution of Order Counts'
)

# Display the visualization
def show_to_user(data):
    data.show()

show_to_user(fig)
```","The input code does not accurately reflect the logic of the reference implementation. The reference code distinguishes between multi-supplier and single-supplier orders and visualizes the distribution of both. However, the input code only calculates and visualizes orders that come from multiple suppliers without considering single-supplier orders, making the visualization incomplete as per the specified request.",None
"What is the percentage of returning customers in Q1 2023, and can this be visualized in a pie chart to compare with new customers?","
```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # Mock function: this would normally execute the query and return a DataFrame.
    # Replacing with sample data for demonstration purposes.
    if ""retention_rate"" in sql_query:
        return pd.DataFrame({'retention_rate': [0.65]})  # Example retention rate
    return pd.DataFrame()

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Queries
query_total_customers_q1_2023 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) as total_customers
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
""""""

query_returning_customers_q1_2023 = """"""
SELECT COUNT(DISTINCT orders.CustomerID) as returning_customers
FROM orders
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
AND orders.CustomerID IN (
    SELECT CustomerID FROM orders WHERE orders.OrderDate < '2023-01-01'
)
""""""

# Execute queries
total_customers_df = execute_sql_query(query_total_customers_q1_2023)
returning_customers_df = execute_sql_query(query_returning_customers_q1_2023)

# Calculate numbers
total_customers = total_customers_df['total_customers'].iloc[0]
returning_customers = returning_customers_df['returning_customers'].iloc[0]
new_customers = total_customers - returning_customers

# Calculate percentages
percentage_returning = (returning_customers / total_customers) * 100
percentage_new = 100 - percentage_returning

# Create DataFrame for visualization
customer_data = pd.DataFrame({
    'Type': ['Returning Customers', 'New Customers'],
    'Percentage': [percentage_returning, percentage_new]
})

# Generate Pie Chart
fig = px.pie(customer_data, names='Type', values='Percentage', title='Customer Distribution in Q1 2023')

# Show visualization
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

# Retrieve the customer data for Q1 2023
query_new_customers = """"""
SELECT COUNT(DISTINCT CustomerID) AS new_customers
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
AND CustomerID NOT IN (
    SELECT CustomerID FROM orders WHERE OrderDate < '2023-01-01'
)
""""""

query_returning_customers = """"""
SELECT COUNT(DISTINCT CustomerID) AS returning_customers
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
AND CustomerID IN (
    SELECT CustomerID FROM orders WHERE OrderDate < '2023-01-01'
)
""""""

new_customers_df = execute_sql_query(query_new_customers)
returning_customers_df = execute_sql_query(query_returning_customers)

new_customers = new_customers_df['new_customers'].values[0]
returning_customers = returning_customers_df['returning_customers'].values[0]

total_customers = new_customers + returning_customers
percentage_returning = (returning_customers / total_customers) * 100

# Prepare data for visualization
customers_data = {
    'Customer Type': ['New Customers', 'Returning Customers'],
    'Count': [new_customers, returning_customers]
}

customers_df = pd.DataFrame(customers_data)

# Create pie chart
fig = px.pie(customers_df, values='Count', names='Customer Type', title='Customer Types in Q1 2023')
show_to_user(fig)
```","The input code correctly calculates the percentage of returning customers in Q1 2023 and visualizes this in a pie chart. It follows the same logic as the reference implementation by executing queries to find new and returning customers, calculating their counts, and then using these to determine the total and percentages. The difference in querying approach (separate queries for new and returning customers) does not affect the logic or correctness of the solution. The final visualization also accurately reflects the comparison of the customer groups.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the percentage of returning customers
sql_query_returning = """"""
SELECT
    (COUNT(DISTINCT o.CustomerID) FILTER (
        WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
        AND o.CustomerID IN (
            SELECT DISTINCT CustomerID FROM orders WHERE OrderDate < '2023-01-01'
        )
    ))::FLOAT / NULLIF(COUNT(DISTINCT o.CustomerID) FILTER (
        WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
    )) AS returning_percentage
FROM orders o;
""""""

# SQL query to count new customers
sql_query_new = """"""
SELECT
    (COUNT(DISTINCT o.CustomerID) FILTER (
        WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-03-31'
        AND o.CustomerID NOT IN (
            SELECT DISTINCT CustomerID FROM orders WHERE OrderDate < '2023-01-01'
        )
    )) AS new_customers
FROM orders o;
""""""

# Execute the returning customers query
returning_df = execute_sql_query(sql_query_returning)

# Execute the new customers query
new_df = execute_sql_query(sql_query_new)

# Calculate the returning customers count
returning_customers = returning_df['returning_percentage'].iloc[0] * new_df['new_customers'].iloc[0] / (1 - returning_df['returning_percentage'].iloc[0])

# Prepare data for visualization
data = {
    'Customer Type': ['Returning Customers', 'New Customers'],
    'Count': [returning_customers, new_df['new_customers'].iloc[0]]
}

# Create a DataFrame for visualization
viz_df = pd.DataFrame(data)

# Create a pie chart using Plotly
fig = px.pie(viz_df, names='Customer Type', values='Count', title='Customer Distribution in Q1 2023')

# Display the pie chart to the user
show_to_user(fig)
```","The input code incorrectly calculates returning customers. It uses a separate query to get the percentage of returning customers and then estimates the count of returning customers using data from the new customers query, which could lead to inaccuracies. The reference code correctly counts both total and returning customers directly, ensuring accurate percentages before visualization.",Base
How many products have a reorder level higher than current stock? Include a bar chart showing these products and their stock differences.,"```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT ProductID, ReorderLevel, UnitsInStock, (ReorderLevel - UnitsInStock) AS StockDifference
FROM products
WHERE ReorderLevel > UnitsInStock;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Count of products with reorder level higher than current stock
product_count = len(products_df)

# Display product count for analysis
product_count_df = pd.DataFrame({'ProductCount': [product_count]})
show_to_user(product_count_df)

# Bar chart visualization using Plotly
fig = px.bar(
    products_df,
    x='ProductID',
    y='StockDifference',
    labels={'StockDifference': 'Stock Difference'},
    title='Products with Reorder Level Higher than Current Stock'
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ProductName, 
    UnitsInStock, 
    ReorderLevel 
FROM 
    products 
WHERE 
    ReorderLevel > UnitsInStock
""""""

products_below_reorder = execute_sql_query(sql_query)

products_below_reorder['Stock Difference'] = products_below_reorder['ReorderLevel'] - products_below_reorder['UnitsInStock']

fig = px.bar(products_below_reorder, 
             x='ProductName', 
             y='Stock Difference', 
             title='Products with Reorder Level Higher than Current Stock',
             labels={'Stock Difference': 'Stock Difference'})
show_to_user(fig)

product_count = len(products_below_reorder)
show_to_user(pd.DataFrame({'Count': [product_count]}))
```","The input code performs the same logic as the reference code. It retrieves products where the reorder level is higher than the current stock, calculates the stock difference, and creates a bar chart showing the products and their stock differences. It also counts the number of such products and displays this count. The main differences are using 'ProductName' instead of 'ProductID' for the bar chart and slight differences in naming (e.g., 'Stock Difference' vs. 'StockDifference'), which do not affect the correctness of the output regarding the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Mock function to execute the SQL query, assuming it returns a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain the actual implementation to query the database
    # Returning a mock dataframe for demonstration purposes
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'ReorderLevel': [20, 15, 10],
        'UnitsInStock': [30, 25, 12]
    }
    return pd.DataFrame(data)

# SQL query to fetch products with reorder level greater than units in stock
sql_query = ""SELECT ProductName, ReorderLevel, UnitsInStock FROM products WHERE ReorderLevel < UnitsInStock;""

# Executing the SQL query
data_df = execute_sql_query(sql_query)

# Analyze data to find products with higher reorder level than current stock
data_df['StockDifference'] = data_df['UnitsInStock'] - data_df['ReorderLevel']
filtered_df = data_df[data_df['StockDifference'] < 0]

# Generate the bar chart using Plotly
fig = px.bar(
    filtered_df,
    x='ProductName',
    y='StockDifference',
    title='Products with Reorder Level Higher Than Current Stock',
    labels={'StockDifference': 'Stock Difference'}
)

# Display the bar chart
show_to_user(fig)
```","The input code is incorrect because it uses the condition `ReorderLevel < UnitsInStock` in the SQL query, which retrieves products with current stock higher than the reorder level, opposite to the business requirement. Furthermore, the calculation and filtering logic handles StockDifference incorrectly as it should check `ReorderLevel > UnitsInStock` and `StockDifference > 0`.",Base
Find the total number of orders shipped by each method and create a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the data
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS TotalShippedOrders 
FROM orders 
WHERE ShippedDate IS NOT NULL 
GROUP BY ShipVia;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is a placeholder for the actual execution and should be implemented.
    pass

def show_to_user(data):
    # This function is a placeholder for displaying output and should be implemented.
    pass

# Execute the SQL query to get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipVia', y='TotalShippedOrders', title='Total Orders Shipped by Method')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the total number of orders shipped by each method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY ShipVia
""""""

# Execute the SQL query and retrieve the results in a DataFrame
order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total number of orders shipped by each method
fig = px.bar(order_data, x='ShipVia', y='TotalOrders', 
             title='Total Orders Shipped by Each Method',
             labels={'ShipVia': 'Shipping Method', 'TotalOrders': 'Total Orders'})
             
show_to_user(fig)
```","The input Python code does not include a condition to filter out orders with 'ShippedDate IS NOT NULL'. This condition is necessary to count only shipped orders, as per the business request. Without this filter, the query includes orders that have not yet been shipped.","```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user are predefined utility functions

# SQL query to get the number of orders shipped by each method
sql_query = """"""
SELECT o.ShipVia, COUNT(o.OrderID) AS OrderCount 
FROM orders o 
GROUP BY o.ShipVia;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
order_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of orders per shipping method
fig = px.bar(order_data, x='ShipVia', y='OrderCount', title='Number of Orders Shipped by Each Method', 
             labels={'OrderCount': 'Order Count', 'ShipVia': 'Shipping Method'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code does not filter out orders with a NULL 'ShippedDate', whereas the reference implementation only considers shipped orders (i.e., those with a non-NULL 'ShippedDate'). This discrepancy means the logic differs, as the input code potentially counts unshipped orders.",None
"Which products were never ordered, and can this be visualized in a bar chart to highlight the products that have zero orders?","```python
import pandas as pd
import plotly.express as px

# Assuming the utility function execute_sql_query is already defined
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation
    pass

def show_to_user(data):
    # Mock implementation to display result (DataFrame or Plotly Figure)
    pass

# SQL query to find products never ordered
sql_query = """"""
SELECT ProductID 
FROM products 
WHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM [Order Details])
""""""

# Execute the SQL query and get results into a DataFrame
products_never_ordered_df = execute_sql_query(sql_query)

# Visualizing the result using Plotly
if not products_never_ordered_df.empty:
    # Create a bar chart
    fig = px.bar(products_never_ordered_df, x='ProductID', y=[0]*len(products_never_ordered_df),
                 title='Products Never Ordered',
                 labels={'y': 'Order Count'},
                 height=400)
    show_to_user(fig)
else:
    # If no products are found, display message
    show_to_user(pd.DataFrame({'Message': ['All products have been ordered at least once.']}))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       COALESCE(SUM(od.Quantity), 0) AS TotalOrdered
FROM Products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
HAVING COALESCE(SUM(od.Quantity), 0) = 0
""""""

never_ordered_products = execute_sql_query(sql_query)

fig = px.bar(never_ordered_products, 
             x='ProductName', 
             y='TotalOrdered', 
             title='Products Never Ordered',
             labels={'TotalOrdered': 'Number of Orders', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The provided code correctly identifies products that have never been ordered and visualizes them in a bar chart. It uses a LEFT JOIN to match products with order details and filters to include only those with a total order quantity of zero. This aligns with the reference code logic, which checks for products not present in order details via a NOT IN subquery. Both approaches effectively find products with zero orders.","```python
import plotly.express as px
import pandas as pd

# SQL query to find products that were never ordered
sql_query = """"""
SELECT ProductID 
FROM products 
WHERE ProductID NOT IN (SELECT ProductID FROM [Order Details])
""""""

# Function to execute the SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str):
    # Example implementation; replace with actual database connection and query execution
    # This is a placeholder resulting in mock data
    return pd.DataFrame({'ProductID': [1, 2, 3]})

# Execute the SQL query
unordered_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize products with zero orders
fig = px.bar(unordered_products_df, x='ProductID', y=[0] * len(unordered_products_df), 
             labels={'y': 'Orders'}, title='Products with Zero Orders')

# Display the bar chart using show_to_user utility function
def show_to_user(data):
    # This is a placeholder for displaying data or plot
    pass

read_data_to_df = execute_sql_query(sql_query)
show_to_user(fig)
```","The evaluated code correctly addresses the business request by querying products that were never ordered using a SQL query similar to the reference implementation. It also visualizes this data as a bar chart. Despite slight differences, such as using 'FROM [Order Details]' and static mock data, these deviations do not impact logical equivalence. Thus, the evaluated code accomplishes the task requirements accurately.",both
"Which city had the highest number of orders shipped to it in the last year, and can you provide a bar chart to visualize the top five cities?","
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation to represent the function's purpose
    pass

def show_to_user(data):
    # Dummy implementation to represent the function's purpose
    pass

# SQL query to find the number of orders per city in the last year
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
WHERE OrderDate >= (CURRENT_DATE - INTERVAL '1 year') 
GROUP BY ShipCity 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Check if dataframe is not empty before accessing
top_city = df_orders.iloc[0] if not df_orders.empty else ""No Orders""

# Print the top city with the highest number of orders
if isinstance(top_city, str):
    print(""No orders in the last year."")
else:
    print(f""City with the highest number of orders: {top_city['ShipCity']} with {top_city['NumberOfOrders']} orders."")

# Create a bar chart for the top five cities
if not df_orders.empty:
    fig = px.bar(df_orders.head(5), x='ShipCity', y='NumberOfOrders', title='Top 5 Cities by Number of Orders in the Last Year')
    # Display the bar chart
    show_to_user(fig)
else:
    print(""No data available for visualization."")
","```python
import pandas as pd
import plotly.express as px

last_year_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount
FROM orders
WHERE ShippedDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY ShipCity
ORDER BY OrderCount DESC
LIMIT 5;
""""""

top_cities_df = execute_sql_query(last_year_query)

fig = px.bar(top_cities_df, x='ShipCity', y='OrderCount', title='Top 5 Cities with Highest Number of Orders Shipped in the Last Year')
show_to_user(fig)
```","The input Python code and the reference code differ in their approach and output. The input code directly limits the result to the top 5 cities using SQL with 'LIMIT 5', whereas the reference intends to retrieve all cities first, determine the top city, and then visualize the top 5. Furthermore, the input code does not handle cases where no data is returned (e.g., no orders in the last year), which the reference code does.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the number of orders shipped to each city in the last year
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount FROM orders 
WHERE YEAR(OrderDate) = YEAR(CURDATE()) - 1 
GROUP BY ShipCity ORDER BY OrderCount DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Get the top five cities by order count
top_five_cities = df.head(5)

# Create a bar chart to visualize the top five cities
fig = px.bar(top_five_cities, x='ShipCity', y='OrderCount', 
             title='Top 5 Cities by Number of Orders in the Last Year',
             labels={'OrderCount': 'Number of Orders', 'ShipCity': 'City'},
             template='plotly')

# Display the bar chart
show_to_user(fig)
```","The input code uses `YEAR(OrderDate) = YEAR(CURDATE()) - 1`, which selects orders from the previous calendar year, whereas the reference uses `OrderDate >= (CURRENT_DATE - INTERVAL '1 year')`, which looks at the last 365 days from today. This results in a different data range. Additionally, the input code does not explicitly find or print the city with the highest order count before plotting, whereas the reference code does.",None
"What is the average discount applied for each product, and can we visualize it in a bar chart for better comparison?","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to represent SQL execution
    # Implement actual SQL query execution logic here
    pass

# Utility function to display results
def show_to_user(data):
    # Placeholder function to show results
    # If data is a pandas DataFrame, it prints the data
    # If the data is a Plotly figure, it shows the plot
    pass

# SQL query to get the average discount for each product
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AvgDiscount 
FROM [Order Details] 
GROUP BY ProductID;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Check if df is not empty or None before plotting
df = df if df is not None else pd.DataFrame({'ProductID': [], 'AvgDiscount': []})

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='AvgDiscount', title='Average Discount per Product')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID, 
    AVG(od.Discount) as AverageDiscount
FROM 
    [Order Details] od
GROUP BY 
    od.ProductID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='ProductID', y='AverageDiscount', 
             title='Average Discount per Product', 
             labels={'AverageDiscount': 'Average Discount', 'ProductID': 'Product ID'})
show_to_user(fig)
```",The input Python code is correct. It adheres to the same logic as the reference implementation. Both execute a SQL query to calculate the average discount per product and subsequently visualize it using a bar chart with Plotly. The difference in variable names and slight changes in the Plotly function are nominal and do not affect the overall functionality or logic related to the business request.,"```python
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str):
    # Dummy implementation of the utility function
    pass

def show_to_user(data):
    # Dummy implementation of the utility function
    pass

# SQL query to fetch average discount for each product
sql_query = """"""
SELECT ProductID, AVG(Discount) AS AvgDiscount 
FROM [Order Details] 
GROUP BY ProductID;
""""""

# Execute the SQL query to get the average discount data
discount_data = execute_sql_query(sql_query)

# Create a bar chart for better comparison of average discounts
fig = px.bar(discount_data, x='ProductID', y='AvgDiscount',
             title='Average Discount Applied per Product',
             labels={'ProductID': 'Product ID', 'AvgDiscount': 'Average Discount'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It executes the same SQL query to get the average discount for each product and uses Plotly to create a bar chart for visualization. Both implementations have the same logical flow, including executing the query, checking the DataFrame, and plotting the results.",both
Find the average discount per customer and visualize the distribution of discounts with a bar chart or histogram.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the required data
sql_query = """"""
SELECT customers.CustomerID, AVG([Order Details].Discount) AS AverageDiscount
FROM customers
JOIN orders ON customers.CustomerID = orders.CustomerID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY customers.CustomerID
""""""

# Execute the SQL query using the provided utility function
customer_discounts_df = execute_sql_query(sql_query)

# Visualize the distribution of discounts using a histogram
fig = px.histogram(customer_discounts_df, x='AverageDiscount', title='Distribution of Average Discounts Per Customer')

# Display the visualization using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.CustomerID, 
    SUM(od.Discount) AS TotalDiscount,
    COUNT(DISTINCT o.OrderID) AS NumberOfOrders
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.CustomerID
""""""

discount_data = execute_sql_query(sql_query)
discount_data['AverageDiscount'] = discount_data['TotalDiscount'] / discount_data['NumberOfOrders']

fig = px.histogram(discount_data, x='AverageDiscount', title='Distribution of Average Discounts per Customer')
show_to_user(fig)
```","The input code calculates the average discount per customer by summing the total discount and dividing by the count of distinct orders, which is logically equivalent to the reference implementation that directly calculates the average using SQL's AVG function. Both approaches result in the same analysis outcome: computing the average discounts per customer. The visualization part using Plotly to create a histogram is also consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    customers.CustomerID, 
    AVG([Order Details].Discount) AS avg_discount 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.CustomerID
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the distribution of average discounts
fig = px.histogram(df, x='avg_discount', nbins=20, title='Distribution of Average Discounts per Customer')
show_to_user(fig)
```","The input Python code correctly executes a SQL query to calculate the average discount per customer and visualizes the distribution using a histogram. It follows the logic of the reference implementation, with minor differences in variable names and histogram parameters, which do not affect the correctness of the analysis or visualization.",both
Determine the total sales generated for each product category and visualize the results with a bar chart.,"```python
import plotly.express as px

def determine_total_sales_by_category(execute_sql_query, show_to_user):
    # SQL query to retrieve total sales for each product category
    sql_query = """"""
    SELECT CategoryID, SUM([Order Details].UnitPrice * Quantity * (1 - Discount)) AS TotalSales
    FROM [Order Details]
    JOIN products ON [Order Details].ProductID = products.ProductID
    GROUP BY CategoryID;
    """"""
    
    # Execute the SQL query and get the result as a DataFrame
    df_sales = execute_sql_query(sql_query)
    
    # Create a bar chart using Plotly
    fig = px.bar(df_sales, x='CategoryID', y='TotalSales', 
                 title='Total Sales by Product Category',
                 labels={'TotalSales': 'Total Sales', 'CategoryID': 'Product Category'})
    
    # Show the bar chart to the user
    show_to_user(fig)

# Example usage with execute_sql_query and show_to_user functions implemented elsewhere
# determine_total_sales_by_category(execute_sql_query, show_to_user)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='CategoryID', y='TotalSales', title='Total Sales by Product Category', 
             labels={'CategoryID': 'Product Category', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The provided input code follows the same logic as the reference code: it executes a SQL query to compute the total sales for each product category by joining the 'Order Details' and 'products' tables. Both implementations use Plotly to create a bar chart displaying the total sales per category and utilize similar SQL queries and visualization parameters. Hence, the input code correctly meets the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query is a pre-defined function
def total_sales_per_category():
    # Define the SQL query
    sql_query = """"""
    SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalSales 
    FROM products p 
    JOIN [Order Details] od ON p.ProductID = od.ProductID 
    GROUP BY p.CategoryID;
    """"""

    # Execute the query and get the DataFrame
    df = execute_sql_query(sql_query)

    # Create a bar chart using Plotly
    fig = px.bar(df, x='CategoryID', y='TotalSales', title='Total Sales by Product Category')

    # Display the figure using the show_to_user utility function
    show_to_user(fig)

# Call the function to execute
total_sales_per_category()
```","The input code does not account for discounts when calculating total sales, while the reference code includes the discount calculation. The input code should use 'SUM(od.UnitPrice * od.Quantity * (1 - od.Discount))' as the result of the SQL query, aligning with the logic in the reference code.",Base
"How have shipping times changed over the years, and can this be visualized with a line graph to show trends?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT YEAR(OrderDate) AS Year, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageShippingTime
FROM orders
GROUP BY Year
ORDER BY Year;
""""""

# Execute the SQL query and store results in a DataFrame
shipping_data = execute_sql_query(sql_query)

# Create a line graph to visualize shipping time trends over the years
fig = px.line(
    shipping_data, 
    x='Year', 
    y='AverageShippingTime',
    title='Average Shipping Time Trends Over the Years',
    labels={'AverageShippingTime': 'Average Shipping Time (days)', 'Year': 'Year'}
)

# Show the visualized line graph to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    YEAR(ShippedDate) AS Year,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS Average_Fulfillment_Time
FROM 
    orders
GROUP BY 
    YEAR(ShippedDate)
ORDER BY 
    Year;
""""""

shipping_times_df = execute_sql_query(sql_query)

fig = px.line(shipping_times_df, x='Year', y='Average_Fulfillment_Time', 
              title='Average Order Fulfillment Time Over the Years',
              labels={'Average_Fulfillment_Time': 'Average Fulfillment Time (days)', 'Year': 'Year'})

show_to_user(fig)
```","Both implementations aim to calculate and visualize the average shipping times over the years using a line graph. The key difference is the year extraction: the reference code extracts the year from 'OrderDate', while the input code extracts it from 'ShippedDate'. However, this can be acceptable if the analysis of shipping times over the years is still accurately represented based on business logic. Both codes group by year, calculate the average difference in days between 'OrderDate' and 'ShippedDate', and visualize the data using a line graph. Given that these steps align with the business analytics request, the implementation can be considered correct.","```python
import pandas as pd
import plotly.express as px

# Define the utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to your database, execute the SQL query, and return a DataFrame
    # Placeholder implementation for the sake of this example
    pass

def show_to_user(data):
    # This function should display the data or visualization to the user
    # Placeholder implementation for the sake of this example
    pass

# SQL query to fetch the average shipping time per year
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y') AS Year, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgShippingTime 
FROM 
    orders 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y')
ORDER BY 
    Year;
""""""

# Execute the SQL query and fetch the data
df = execute_sql_query(sql_query)

# Visualize the trend using Plotly
fig = px.line(df, x='Year', y='AvgShippingTime', title='Average Shipping Time Over the Years',
              labels={'AvgShippingTime': 'Average Shipping Time (days)', 'Year': 'Year'})

# Show the visualization to the user
show_to_user(fig)
```","The input Python code correctly answers the business analytics request and adheres to the same logic as the reference implementation. Both codes execute a SQL query to calculate the average shipping time per year and visualize the trend using Plotly's line graph. The variations in the column naming (e.g., 'AvgShippingTime' vs. 'AverageShippingTime') do not affect the correctness as they are handled consistently in data selection and plotting. The core logic remains intact: fetching data by year and plotting it on a line graph.",both
"Which city has the highest number of orders, who handles them, and can this be represented with a bar chart showing the number of orders for each city?","```python
import pandas as pd
import plotly.express as px

# Placeholder function for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for SQL execution; in practice, this would connect to a database.
    # Example implementation: with connection.cursor() as cursor: cursor.execute(sql_query)
    # Replace with actual database interaction logic.
    pass

# Placeholder function for displaying data or figures
def show_to_user(data):
    # This is a placeholder function. In practice, this could display a dataframe as a table
    # or use Plotly to render a visual chart.
    pass

# SQL query to get data
sql_query = """"""
SELECT orders.ShipCity, orders.EmployeeID, COUNT(orders.OrderID) AS OrderCount 
FROM orders 
GROUP BY orders.ShipCity, orders.EmployeeID 
ORDER BY OrderCount DESC
LIMIT 1
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Identify the city with the highest number of orders
top_city = df.iloc[0]

# Print the results - City with highest orders and handling employee
print(f""The city with the highest number of orders is {top_city['ShipCity']}, handled by employee ID {top_city['EmployeeID']}."")

# Request a DataFrame for a bar chart for each city
city_order_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCity 
ORDER BY OrderCount DESC
""""""

city_orders_df = execute_sql_query(city_order_query)

# Generate a bar chart
fig = px.bar(city_orders_df, x='ShipCity', y='OrderCount', title='Number of Orders per City')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.City, e.EmployeeID, COUNT(o.OrderID) AS NumberOfOrders
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.City, e.EmployeeID
ORDER BY NumberOfOrders DESC
""""""

result_df = execute_sql_query(sql_query)

highest_orders_city = result_df.loc[result_df['NumberOfOrders'].idxmax()]

bar_chart_df = result_df.groupby('City')['NumberOfOrders'].sum().reset_index()

fig = px.bar(bar_chart_df, x='City', y='NumberOfOrders', title='Number of Orders per City')
show_to_user(fig)

highest_orders_city
```","The evaluated code uses a different SQL query structure, which may not yield the same results as the reference code. The evaluated code joins 'employees' to 'orders' and groups by 'employees.City', whereas the reference only considers 'orders.ShipCity'. This could lead to different results if the 'City' in the 'employees' table differs from 'ShipCity'. Additionally, the evaluated code assumes the city with the most orders is the one with the single highest employee's orders, whereas the reference aggregates orders by city. Hence, logic and execution are not identical to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assume the utility functions are defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for the sake of this code block
    pass

def show_to_user(data):
    # Dummy implementation for the sake of this code block
    pass

# SQL query to get the count of orders by city and employee
sql_query = """"""
SELECT e.City, e.EmployeeID, COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.City, e.EmployeeID 
ORDER BY OrderCount DESC;
""""""

# Execute query to get the data
df = execute_sql_query(sql_query)

# Get the city with the highest number of orders
city_with_most_orders = df.groupby('City')['OrderCount'].sum().idxmax()

# Filter employees handling orders in that city
df_filtered = df[df['City'] == city_with_most_orders]

# Generate bar chart for number of orders by city
df_city_orders = df.groupby('City')['OrderCount'].sum().reset_index()
fig = px.bar(df_city_orders, x='City', y='OrderCount', title='Number of Orders by City')

# Show results
show_to_user(fig)

# Optionally display the city with the highest number of orders and the employees handling them
show_to_user(df_filtered)
```","The input code does not correctly identify the city with the highest number of orders by employee based on the business request and reference code. The input code groups by 'City' and sums 'OrderCount', whereas the reference code directly uses a query to obtain the top city-employee combination by order count. Additionally, the input code joins 'employees' and 'orders' which is not necessary, potentially altering the context of the highest order city as per the reference logic.",None
Which product category generated the most revenue in 2023? Visualize the revenue distribution across all product categories.,"```python
import pandas as pd
import plotly.express as px

# Sample execute_sql_query function (needs actual implementation based on your database connection)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Example: replace with actual database querying logic
    return pd.DataFrame([
        {""CategoryName"": ""Electronics"", ""total_revenue"": 12500},
        {""CategoryName"": ""Furniture"", ""total_revenue"": 10900},
        {""CategoryName"": ""Clothing"", ""total_revenue"": 9800},
        {""CategoryName"": ""Books"", ""total_revenue"": 7200}
    ])

# Sample show_to_user function (will just print data or plot using Plotly)
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get total revenue per category in 2023
sql_query = """"""
SELECT 
    categories.CategoryName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM 
    [Order Details] 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    categories ON products.CategoryID = categories.CategoryID 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY 
    categories.CategoryName 
ORDER BY 
    total_revenue DESC
""""""

# Execute the SQL query to get data
df = execute_sql_query(sql_query)

# Find the product category with the most revenue in 2023
max_revenue_category = df.nlargest(1, 'total_revenue')
print(""Category with most revenue in 2023:"")
show_to_user(max_revenue_category)

# Visualize revenue distribution across all product categories
fig = px.bar(df, x=""CategoryName"", y=""total_revenue"", title=""Revenue Distribution Across Product Categories in 2023"")
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT categories.CategoryName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_revenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY categories.CategoryName 
ORDER BY total_revenue DESC
""""""

revenue_data = execute_sql_query(sql_query)

top_category = revenue_data.iloc[0]
fig = px.bar(revenue_data, x='CategoryName', y='total_revenue', title=""Revenue Distribution Across Product Categories in 2023"")

show_to_user(fig)

top_category
```","The input code correctly executes the SQL query to retrieve the total revenue for each product category in 2023, identifies the top category by selecting the first row (due to the order by descending revenue), and visualizes the revenue distribution using a bar chart. This process matches the logic and intent of the reference code, satisfying the business analytics request. Despite minor differences in how the top category is extracted (using 'iloc[0]' instead of 'nlargest(1, ...)'), the outcome remains the same.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query is a provided utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation for demonstration
    # This should be replaced with actual implementation to execute the query
    pass

def show_to_user(data):
    # Placeholder function to output the result
    # This should appropriately display the dataframe or plot
    pass

# SQL query to fetch revenue data for 2023
sql_query = """"""
SELECT 
    categories.CategoryName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS revenue 
FROM 
    [Order Details] 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    categories ON products.CategoryID = categories.CategoryID 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    YEAR(orders.OrderDate) = 2023 
GROUP BY 
    categories.CategoryName 
ORDER BY 
    revenue DESC;
""""""

# Execute the SQL query and get the data
revenue_df = execute_sql_query(sql_query)

if not revenue_df.empty:
    # Extract the category with the highest revenue
    top_category = revenue_df.iloc[0]

    # Display the top category by revenue
    show_to_user(pd.DataFrame([top_category]))

    # Visualize the revenue distribution across all product categories
    fig = px.bar(revenue_df, x='CategoryName', y='revenue', title='Revenue Distribution by Product Category in 2023')
    show_to_user(fig)
else:
    print(""No data available for 2023."")
```","The provided implementation addresses the business analytics request correctly. It executes an SQL query to calculate the total revenue per product category in 2023 and identifies the category with the highest revenue. The main difference is the use of `YEAR(orders.OrderDate) = 2023` instead of specifying the date range, which achieves the same result. The visualization of revenue distribution is performed correctly using Plotly Express, similar to the reference implementation. Therefore, the logic and outcome align with the reference code.",both
Identify products with decreasing sales trends over months and create a line chart to visualize these trends.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be defined to execute the SQL and return a DataFrame
    pass

def show_to_user(data):
    # This function should be defined to handle display of DataFrame or Plotly plots
    pass

# SQL Query provided
sql_query = """"""
SELECT ProductName FROM (
    SELECT ProductName, DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Quantity) AS QuantitySold
    FROM products
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    GROUP BY ProductName, Month
) sub
WHERE QuantitySold < LAG(QuantitySold) OVER (PARTITION BY ProductName ORDER BY Month);
""""""

# Execute the SQL query and get the result as a DataFrame
trending_down_products = execute_sql_query(sql_query)

# If there are any products with decreasing trends, visualize them
if not trending_down_products.empty:
    # Extract unique product names with decreasing sales trends
    product_names = trending_down_products['ProductName'].unique()
    
    # Create a query to get full sales data for only those products
    sales_query = f""""""
    SELECT ProductName, DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(Quantity) AS QuantitySold
    FROM products
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    WHERE ProductName IN ({', '.join([f""'{name}'"" for name in product_names])})
    GROUP BY ProductName, Month
    """"""
    sales_data = execute_sql_query(sales_query)

    # Create a line chart to visualize the sales trends
    fig = px.line(sales_data, x=""Month"", y=""QuantitySold"", color=""ProductName"", title=""Decreasing Sales Trends"")
    
    # Show the figure to the user
    show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Query to get monthly sales data for each product
sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, Month
ORDER BY 
    p.ProductID, Month
""""""
monthly_sales_df = execute_sql_query(sql_query)

# Step 2: Calculate decreasing trends
monthly_sales_df['TotalSales'] = monthly_sales_df['TotalSales'].astype(float)
decreasing_trends_df = monthly_sales_df.groupby('ProductID').apply(lambda x: x['TotalSales'].is_monotonic_decreasing).reset_index()
decreasing_products = decreasing_trends_df[decreasing_trends_df[0] == True]['ProductID']

# Step 3: Filter for only decreasing products and merge with sales data
decreasing_sales_df = monthly_sales_df[monthly_sales_df['ProductID'].isin(decreasing_products)]

# Step 4: Create line chart
fig = px.line(decreasing_sales_df, x='Month', y='TotalSales', color='ProductName', 
              title='Decreasing Sales Trends Over Months', 
              labels={'TotalSales': 'Total Sales', 'Month': 'Month'})
show_to_user(fig)
```","The provided code identifies products whose sales are entirely monotonically decreasing over the entire period using `is_monotonic_decreasing`, while the reference code identifies products with a decreasing trend between consecutive months using a SQL query with the `LAG` function. The logic in the two codes is different.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    products.ProductID, 
    EXTRACT(MONTH FROM orders.OrderDate) AS Month, 
    SUM([Order Details].Quantity) AS MonthlySales 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    orders.OrderDate >= DATEADD(MONTH, -6, CURRENT_DATE) 
GROUP BY 
    products.ProductID, EXTRACT(MONTH FROM orders.OrderDate) 
ORDER BY 
    products.ProductID, EXTRACT(MONTH FROM orders.OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Pivot the DataFrame for analysis
pivot_df = df.pivot(index='Month', columns='ProductID', values='MonthlySales').fillna(0)

# Calculate the trend for each product
decreasing_trends = []
for product_id in pivot_df.columns:
    sales = pivot_df[product_id].tolist()
    if all(x > y for x, y in zip(sales, sales[1:])):
        decreasing_trends.append(product_id)

# Filter the DataFrame for products with decreasing trends
decreasing_trends_df = pivot_df[decreasing_trends]

# Create a line chart to visualize these trends
fig = px.line(decreasing_trends_df, title='Products with Decreasing Sales Trends Over Months')

# Display the figure
show_to_user(fig)
```","The input code does not correctly identify products with decreasing sales trends over months. The reference code uses a SQL window function (LAG) to detect decreases month over month for each product. The input code calculates a decrease by checking if all sales for the last 6 months are strictly decreasing using `all(x > y for x, y in zip(sales, sales[1:]))`, which is a different logic and may miss products that have occasional increases but still show a net decreasing trend over specific months. Additionally, the input code doesn't handle trends over month-year but only over months extracted from dates, which can produce incorrect analysis across years.",None
"What is the average order size in terms of quantity, and can you provide a histogram of order sizes to visualize the distribution?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch average order size
sql_query_avg = ""SELECT AVG([Order Details].Quantity) AS AvgOrderSize FROM [Order Details];""

# Execute SQL query and store the result in a DataFrame
avg_order_size_df = execute_sql_query(sql_query_avg)

# Extract the average order size value
avg_order_size = avg_order_size_df['AvgOrderSize'].iloc[0]

# Display the average order size to the user
show_to_user(avg_order_size_df)

# SQL query to fetch all order quantities
sql_query_all = ""SELECT [Order Details].Quantity FROM [Order Details];""

# Execute SQL query and store the result in a DataFrame
order_sizes_df = execute_sql_query(sql_query_all)

# Create a histogram of order sizes
fig = px.histogram(order_sizes_df, x='Quantity', nbins=20, title='Distribution of Order Sizes')

# Show the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT [Order Details].Quantity
FROM [Order Details]
""""""
order_details_df = execute_sql_query(sql_query)

average_order_size = order_details_df['Quantity'].mean()

histogram_fig = px.histogram(order_details_df, x='Quantity', title='Distribution of Order Sizes')
show_to_user(histogram_fig)

average_order_size
```","The input code correctly calculates the average order size by using the mean on the 'Quantity' field of the DataFrame. It also generates a histogram to visualize the distribution of order sizes. The logic aligns with the reference implementation, which separately fetches values and calculates the average, and then creates a histogram. The execution of both SQL queries (for average calculation and fetching all quantities) is effectively combined in the input code, serving the same purpose.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are pre-defined utility functions.

# SQL query to retrieve average order size
sql_query_avg_order = """"""
SELECT SUM(od.Quantity) / COUNT(DISTINCT o.OrderID) AS AvgOrderSize
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID;
""""""

# SQL query to retrieve all order sizes
sql_query_all_orders = """"""
SELECT SUM(od.Quantity) AS OrderSize
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY o.OrderID;
""""""

# Execute the SQL query to get the average order size
avg_order_df = execute_sql_query(sql_query_avg_order)

# Display the average order size
show_to_user(avg_order_df)

# Execute the SQL query to get all order sizes for histogram
order_sizes_df = execute_sql_query(sql_query_all_orders)

# Create a histogram of order sizes using Plotly
fig = px.histogram(order_sizes_df, x='OrderSize', title='Distribution of Order Sizes', labels={'OrderSize': 'Order Size'})

# Show the histogram to the user
show_to_user(fig)
```","The input code calculates the average order size by dividing the total quantity by the number of distinct orders, which aligns with obtaining an average per order. It differs from the reference code which calculates a simple average of quantities, but both aim to find an average reflecting order sizes. The histogram in both codes represents the distribution of order sizes. The logic, though approached differently, satisfies the business analytics request.",both
Calculate the total revenue generated by each customer and create a bar chart to visualize the revenue distribution among customers.,"
```python
import plotly.express as px
import pandas as pd

# Define SQL query to fetch customer revenue data
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query and store the result in a DataFrame
df_revenue = execute_sql_query(sql_query)

# Visualize the revenue distribution among customers using a bar chart
fig = px.bar(df_revenue, x='CustomerID', y='TotalRevenue', 
             title='Total Revenue Generated by Each Customer',
             labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='CompanyName', y='TotalRevenue',
             title='Total Revenue by Customer',
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Customer'},
             text='TotalRevenue')
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
show_to_user(fig)
```","The input Python code correctly calculates the total revenue generated by each customer and visualizes it using a bar chart. The SQL query aggregates revenue by CustomerID and uses an additional field 'CompanyName', which doesn't affect the aggregation logic. The plotted chart displays 'TotalRevenue' per 'CompanyName', which aligns with the request. The visual enhancement with text labels also matches the reference implementation logic.","```python
import pandas as pd
import plotly.express as px

# Assume the following utility functions are predefined:
# execute_sql_query(sql_query: str) -> pd.DataFrame
# show_to_user(data)

# Define the SQL query based on the business analytic request
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
customer_revenue_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the revenue distribution among customers
fig = px.bar(customer_revenue_df, 
             x='CustomerID', 
             y='TotalRevenue', 
             title='Revenue Distribution Among Customers',
             labels={'TotalRevenue': 'Total Revenue ($)', 'CustomerID': 'Customer ID'})

# Display the bar chart using the show_to_user utility function
show_to_user(fig)
```","The input Python code correctly executes the same SQL query as the reference code to fetch the total revenue per customer. It then uses Plotly Express to create a bar chart similar to the reference implementation, ensuring the visualization of revenue distribution among customers. Although the title and label formatting differ slightly, the logic and outcome align with the business analytics request and reference code. Therefore, the input code is correct.",both
"What is the total quantity of products sold each month, and can this be visualized in a line graph for better insight?","```python
import pandas as pd
import plotly.express as px

# SQL query to extract the required data
sql_query = """"""
SELECT EXTRACT(MONTH FROM o.OrderDate) AS Month, 
       SUM(od.Quantity) AS TotalQuantity 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY EXTRACT(YEAR FROM o.OrderDate), EXTRACT(MONTH FROM o.OrderDate);
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a line graph for the monthly total quantity of products sold
fig = px.line(df, x='Month', y='TotalQuantity', title='Total Quantity of Products Sold Each Month')

# Display the line graph to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', o.OrderDate) AS month,
    SUM(od.Quantity) AS total_quantity_sold
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    month
ORDER BY 
    month;
""""""

total_quantity_df = execute_sql_query(sql_query)

fig = px.line(total_quantity_df, x='month', y='total_quantity_sold', title='Total Quantity of Products Sold Each Month')
show_to_user(fig)
```","The input code correctly calculates the total quantity of products sold each month and visualizes it with a line graph. Both codes use a SQL query to aggregate sales by month and visualize it using Plotly. The main difference is the SQL functions used: `EXTRACT` vs `DATE_TRUNC`, which both effectively achieve monthly aggregation. The logic and the outcome of the query are equivalent, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM OrderDate) AS Year, 
    EXTRACT(MONTH FROM OrderDate) AS Month, 
    SUM(od.Quantity) AS TotalQuantitySold 
FROM 
    [Order Details] od 
GROUP BY 
    EXTRACT(YEAR FROM OrderDate), 
    EXTRACT(MONTH FROM OrderDate)
ORDER BY 
    Year, Month;
""""""

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assuming the function connects to a database and executes the query,
    # returning the result as a pandas DataFrame.
    # This is a placeholder; implementation depends on specifics of your SQL connection.
    pass

# Executing the SQL query
df_sales = execute_sql_query(sql_query)

# Creating a line graph to visualize the total quantities sold per month
df_sales['Date'] = pd.to_datetime(df_sales[['Year', 'Month']].assign(DAY=1))
fig = px.line(
    df_sales.sort_values('Date'),
    x='Date',
    y='TotalQuantitySold',
    title='Total Quantity of Products Sold Each Month',
    labels={'TotalQuantitySold': 'Total Quantity Sold', 'Date': 'Month'},
    markers=True
)

# Utility function to display the plot
def show_to_user(data):
    # This function would display data or a Plotly figure
    pass

# Show the plot
show_to_user(fig)
```","The input code does not perform a join with the 'orders' table to retrieve and group data by both year and month as the reference code does. Instead, it only extracts the year and month from the 'Order Details', which may lead to incorrect aggregation since the orders table seems necessary for mapping OrderID with OrderDate. Without this join, the data may not be grouped correctly by the actual order dates.",Base
List all products that have stock levels below their reorder level and create a bar chart comparing current stock levels to reorder levels for these products.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find products with stock levels below reorder level
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the query and get the result as a pandas DataFrame
products_below_reorder_level = execute_sql_query(sql_query)

# Create a bar chart to compare current stock levels to reorder levels
fig = px.bar(
    products_below_reorder_level, 
    x='ProductName', 
    y=['UnitsInStock', 'ReorderLevel'], 
    title='Stock vs Reorder Levels for Products',
    labels={'value':'Stock Levels', 'ProductName':'Product Name'},
    barmode='group'
)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""

products_below_reorder_level = execute_sql_query(sql_query)

fig = px.bar(products_below_reorder_level, 
              x='ProductName', 
              y=['UnitsInStock', 'ReorderLevel'],
              title='Current Stock Levels vs Reorder Levels',
              labels={'value': 'Stock Level', 'variable': 'Level'},
              barmode='group')

show_to_user(fig)
```","The evaluated code adds an extra condition `Discontinued = 0` to the SQL query, which is not present in the reference implementation. While it correctly lists products with stock levels below reorder level and creates a similar bar chart, the additional condition changes which products are selected, thus not adhering to the same logic as the reference implementation.","```python
import plotly.express as px
import pandas as pd

# SQL query to get products with stock levels below their reorder level
sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;
""""""

# Execute the SQL query and get results in a DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart comparing current stock levels to reorder levels for these products
fig = px.bar(
    products_df,
    x='ProductName',
    y=['UnitsInStock', 'ReorderLevel'],
    labels={'value': 'Units', 'variable': 'Type'},
    title='Comparison of Current Stock Levels to Reorder Levels'
)

# Display the chart to the user
show_to_user(fig)
```","The provided input Python code correctly achieves the task described in the business analytics request. It executes an SQL query to list products with stock levels below their reorder level and creates a bar chart to compare current stock levels to reorder levels for these products. The implementation adheres to the logic of the reference code, using Plotly Express to create a grouped bar chart, even though there are slight differences in labels and title phrasing.",Finetuned
What is the average order quantity for each product? Please include a bar chart to illustrate the average quantities by product.,"
import pandas as pd
import plotly.express as px

# SQL query to get average quantity per product
sql_query = """"""
SELECT ProductID, AVG(Quantity) AS AverageQuantity 
FROM [Order Details] 
GROUP BY ProductID
""""""

# Execute the SQL query and get a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for average quantities by product
fig = px.bar(df, x='ProductID', y='AverageQuantity', 
             title='Average Order Quantity by Product',
             labels={'ProductID': 'Product ID', 'AverageQuantity': 'Average Quantity'})

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, AVG(od.Quantity) AS AverageQuantity
FROM [Order Details] od
GROUP BY od.ProductID
""""""

average_order_quantity = execute_sql_query(sql_query)

fig = px.bar(average_order_quantity, x='ProductID', y='AverageQuantity', 
             title='Average Order Quantity by Product', 
             labels={'ProductID': 'Product ID', 'AverageQuantity': 'Average Quantity'})

show_to_user(fig)
```","The input code accurately replicates the reference implementation's logic. Both codes calculate the average order quantity per product using a SQL query on the 'Order Details' table. They also create a bar chart using Plotly Express to visualize this data. The differences in the input code, such as the optional alias 'od', are syntactically correct and do not alter the logic of the query or the visualization process.","```python
import plotly.express as px
import pandas as pd

# The provided SQL query
sql_query = """"""
SELECT products.ProductID, AVG([Order Details].Quantity) AS AvgOrderQty 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductID
""""""

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mocked SQL execution returning a pandas DataFrame
    return pd.DataFrame({
        'ProductID': [1, 2, 3],
        'AvgOrderQty': [10, 15, 20]
    })

# Execute the SQL query to get the data
data_frame = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(data_frame, x='ProductID', y='AvgOrderQty', title='Average Order Quantity by Product')

# Show the chart to the user
show_to_user(fig)
```","The input code correctly calculates the average order quantity for each product, similar to the reference implementation. It uses a SQL query to join tables and compute the average, then generates a bar chart with the appropriate labels. Both implementations perform the same logical operations concerning the business request, meeting the specified criteria.",both
"Which employees have the highest number of orders processed, and can this be represented with a bar chart to visualize the distribution?","```python
import plotly.express as px

# SQL query to find the number of orders processed by each employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the data with a bar chart
fig = px.bar(df, x='EmployeeID', y='NumberOfOrders', 
             title='Number of Orders Processed by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'NumberOfOrders': 'Number of Orders'},
             text='NumberOfOrders')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""
df = execute_sql_query(sql_query)

fig = px.bar(df, x='EmployeeID', y='OrderCount', title='Number of Orders Processed by Employees',
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The input code correctly implements the task as specified. It executes a SQL query that calculates the number of orders processed by each employee, grouping by EmployeeID and ordering by the order count in descending order. It then visualizes this data using a bar chart with Plotly Express, similar to the reference implementation. Naming variations like 'OrderCount' instead of 'NumberOfOrders' do not affect the correctness of the implementation in terms of logic and functionality.","```python
import pandas as pd
import plotly.express as px

# Mock function to simulate executing SQL query and returning data as DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder. Replace it with actual database access code.
    data = {
        'EmployeeID': [1, 2, 3],
        'TotalOrders': [150, 145, 135]
    }
    return pd.DataFrame(data)

# Mock function to simulate showing data to user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get employees and their order counts
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS TotalOrders
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
GROUP BY employees.EmployeeID
ORDER BY TotalOrders DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='TotalOrders', title='Total Orders Processed by Employees')

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the required functionality. Both the reference and input code aim to determine which employees have processed the highest number of orders and visualize this data using a bar chart. The input code does this through a SQL query that performs the necessary JOIN and aggregation, followed by a Plotly bar chart visualization. The SQL query logic and the visualization output are consistent with the reference implementation.",both
List employees who have handled orders with total discounts over 10% and include a bar chart showing the number of orders per employee.,"
import plotly.express as px

# SQL query to retrieve employees with total discounts over 10%
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].Discount) AS TotalDiscount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
HAVING SUM([Order Details].Discount) > 0.1;
""""""

# Execute the SQL query and return the result as a pandas DataFrame
employee_discounts_df = execute_sql_query(sql_query)

# Generate the bar chart using Plotly
fig = px.bar(employee_discounts_df, x='EmployeeID', y='TotalDiscount', 
             title='Total Discounts Over 10% by Employee', 
             labels={'EmployeeID': 'Employee ID', 'TotalDiscount': 'Total Discount'})

# Display the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE od.Discount > 0.1
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

employee_data = execute_sql_query(sql_query)

fig = px.bar(employee_data, x='FirstName', y='OrderCount', 
              title='Number of Orders per Employee with Discounts over 10%',
              labels={'FirstName': 'Employee', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The input code retrieves employees with orders that have individual order discounts over 10%, rather than the total discount per employee exceeding 10%. It then counts the number of such orders per employee, whereas the business request is to identify employees whose total discount amount across all orders exceeds 10%. Additionally, the reference code calculates total discounts and groups by EmployeeID, which ensures the correct logic corresponding to the business analytics request.","import pandas as pd
import plotly.express as px

# Assume the required utility functions are already defined:
# execute_sql_query(sql_query: str) -> pd.DataFrame
# show_to_user(data): None

# SQL query to select employees who have handled orders with total discounts over 10%
sql_query = """"""
SELECT e.EmployeeID, SUM(od.Discount) AS TotalDiscount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
HAVING SUM(od.Discount) > 0.10;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart showing the number of orders per employee
order_counts = df['EmployeeID'].value_counts().reset_index()
order_counts.columns = ['EmployeeID', 'NumberOfOrders']

# Use Plotly to generate a bar chart
fig = px.bar(order_counts, x='EmployeeID', y='NumberOfOrders', 
             title='Number of Orders per Employee',
             labels={'NumberOfOrders': 'Number of Orders'})

# Show the figure to the user
show_to_user(fig)","The input code creates a bar chart showing the number of orders per employee, based on how often each employee appears in the result DataFrame, rather than the total discount each employee has achieved. This does not match the reference implementation, which displays the total discount aggregated per employee for those with discounts over 10%. The logical focus of the chart is different from the business request.",None
What is the total number of products sold by each employee? Include a bar chart to visualize the results by employee.,"```python
# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to get the total number of products sold by each employee
sql_query = """"""
SELECT employees.EmployeeID, 
    SUM([Order Details].Quantity) AS TotalProducts 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the results by employee
fig = px.bar(df, x='EmployeeID', y='TotalProducts', title='Total Products Sold by Each Employee')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.Quantity) AS TotalProductsSold
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, EmployeeName
ORDER BY TotalProductsSold DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='EmployeeName', y='TotalProductsSold',
             title='Total Products Sold by Each Employee', 
             labels={'TotalProductsSold': 'Total Products Sold', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The evaluated code correctly retrieves the total number of products sold by each employee and visualizes it in a bar chart. While the reference code uses only EmployeeID, the evaluated code additionally includes EmployeeName for better context. This does not alter the core objective of the request, which is to sum the quantities by employee and display them. Additionally, the code uses the same logic of grouping by EmployeeID and summing the quantities, thus adhering to the business analytics requirement.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are already defined

# SQL query to be executed
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, SUM([Order Details].Quantity) AS TotalProductsSold
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
""""""

# Execute the query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Plotting the bar chart using Plotly
fig = px.bar(df, x='FirstName', y='TotalProductsSold', 
             title='Total Products Sold by Each Employee', 
             labels={'TotalProductsSold': 'Total Products Sold', 'FirstName': 'Employee'},
             hover_data=['LastName'])

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates the total number of products sold by each employee using an SQL query and visualizes it with a bar chart. The query groups by 'EmployeeID', similar to the reference code, and adds 'FirstName' and 'LastName' for additional identification. The logic of calculating total products sold is identical to the reference implementation. The plot includes employee names in the x-axis and total sales as the y-axis effectively.",both
List the top 3 products in terms of units sold and provide a bar chart to illustrate the results.,"```python
import pandas as pd
import plotly.express as px

# SQL query string
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS UnitsSold 
FROM products p 
JOIN [Order Details] od 
ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY UnitsSold DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the result in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductName', y='UnitsSold', title='Top 3 Products by Units Sold')

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalUnitsSold
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalUnitsSold DESC
LIMIT 3
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='TotalUnitsSold', title='Top 3 Products by Units Sold')
show_to_user(fig)
```","The input code correctly implements the request to list the top 3 products by units sold and visualize the results as a bar chart. It matches the logic of the reference implementation. Both codes query the necessary data using SQL, aggregate quantities, sort them in descending order, and limit the results to the top 3 products. The bar chart creation using Plotly is also consistent across both implementations.","```python
import plotly.express as px
import pandas as pd

# Utility function to execute SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented to fetch data from your business database.
    pass

# Utility function to display data to user
def show_to_user(data):
    # This function is assumed to be implemented to display the DataFrame or plot to the user.
    pass

# SQL query to fetch top 3 products by total units sold from the specified Vendor and Year
sql_query = """"""
SELECT [Order Details].ProductID, 
SUM([Order Details].Quantity) AS TotalUnitsSold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE products.SupplierID = 1234 
AND YEAR([Order Details].OrderDate) = 2023 
GROUP BY [Order Details].ProductID 
ORDER BY TotalUnitsSold DESC 
LIMIT 3;
""""""

# Execute SQL query and obtain result as a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductID', y='TotalUnitsSold',
             title='Top 3 Products by Units Sold',
             labels={'ProductID': 'Product ID', 'TotalUnitsSold': 'Total Units Sold'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code includes additional filtering criteria (SupplierID = 1234 and OrderDate = 2023), which are not present in the reference code. This alters the logic by limiting the scope to certain suppliers and a specific year, thereby failing to fulfill the request as stated.",Base
"What is the average discount given per product, and can you provide a bar chart illustrating the average discount for each product?","
```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT ProductName, AVG(Discount) AS AvgDiscount 
FROM [Order Details] OD 
JOIN products P ON OD.ProductID = P.ProductID 
GROUP BY ProductName;
""""""

# Function to execute SQL query and get data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function is implemented
    pass

# Function to display data or visualization
def show_to_user(data):
    # Assume this function is implemented
    pass

# Execute the query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart for average discount per product
fig = px.bar(df, x='ProductName', y='AvgDiscount', title=""Average Discount per Product"")

# Show the visualization
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='ProductName', y='AverageDiscount', title='Average Discount per Product')
show_to_user(fig)
```","The input code correctly calculates the average discount per product using the same SQL logic as the reference implementation. It groups discounts by product name and computes the average. The function then creates and displays a bar chart using Plotly, aligning with the business analytics request.","
```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = ""SELECT products.ProductName, AVG([Order Details].Discount) AS AverageDiscount FROM products INNER JOIN [Order Details] ON products.ProductID = [Order Details].ProductID GROUP BY products.ProductName;""

# Execute the SQL query and get the result as a DataFrame
average_discount_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to show the average discount per product
fig = px.bar(average_discount_df, x='ProductName', y='AverageDiscount', title='Average Discount per Product', labels={'AverageDiscount':'Average Discount', 'ProductName':'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It computes the average discount per product by joining the products and order details tables on ProductID and groups by ProductName. The subsequent bar chart accurately visualizes the average discount for each product. The logic aligns with the reference implementation. Differences, such as naming and SQL formatting, do not impact correctness.",both
What is the total revenue generated by each customer over their lifetime? Please include a bar chart to visualize the revenue distribution by customer.,"
import pandas as pd
import plotly.express as px

# Function definitions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # For the purpose of this example, it returns an empty DataFrame
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query
sql_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID;
""""""

# Executing SQL query and getting data
customer_lifetime_value_df = execute_sql_query(sql_query)

# Checking if DataFrame is empty
if not customer_lifetime_value_df.empty:
    # Plotting the data using Plotly
    fig = px.bar(customer_lifetime_value_df, x='CustomerID', y='LifetimeValue',
                 title='Customer Lifetime Revenue',
                 labels={'CustomerID': 'Customer ID', 'LifetimeValue': 'Revenue'},
                 template='plotly')

    # Display the figure
    show_to_user(fig)
else:
    print(""No data available to visualize."")
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID
""""""

customer_revenue_df = execute_sql_query(sql_query)

fig = px.bar(customer_revenue_df, x='CustomerID', y='TotalRevenue', 
              title='Total Revenue Generated by Each Customer',
              labels={'TotalRevenue': 'Lifetime Revenue', 'CustomerID': 'Customer ID'})
show_to_user(fig)
```","The input Python code correctly executes the same logic as the reference implementation. Both codes execute an SQL query to calculate the total revenue generated by each customer by summing the product of unit price, quantity, and discount. The query results are visualized using a bar chart with Plotly, displaying customer IDs and their corresponding total revenue. Variable names differ slightly, but the functionality and logic remain consistent with the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query for fetching total revenue by customer
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query
# Assuming execute_sql_query is a predefined utility function in the environment
df = execute_sql_query(sql_query)

# Create a bar chart to show the revenue distribution by customer
fig = px.bar(df, x='CustomerID', y='TotalRevenue', 
             title='Total Revenue by Customer',
             labels={'TotalRevenue': 'Total Revenue', 'CustomerID': 'Customer ID'},
             template='plotly')

# Display the bar chart to the user
show_to_user(fig)
```","The input code follows the same logic as the reference implementation. Both execute an SQL query that calculates the total lifetime revenue for each customer using similar joins and aggregations. The output DataFrame is visualized using a bar chart via Plotly, displaying each customer's revenue. The main differences are variable names and the order of JOINs in the query, which do not affect the logic or output.",both
Identify the products that have been discontinued and create a bar chart showing the number of discontinued products by category.,"```python
import pandas as pd
import plotly.express as px

# Query to identify discontinued products
sql_query = ""SELECT ProductName, CategoryName FROM products WHERE Discontinued = 1;""

# Execute the SQL query and retrieve the DataFrame
df = execute_sql_query(sql_query)

# Group by category and count discontinued products
category_counts = df.groupby('CategoryName').size().reset_index(name='DiscontinuedCount')

# Create a bar chart using Plotly
fig = px.bar(category_counts, x='CategoryName', y='DiscontinuedCount', 
             title='Number of Discontinued Products by Category')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, COUNT(p.ProductID) AS DiscontinuedCount
FROM products p
WHERE p.Discontinued = 1
GROUP BY p.CategoryID
""""""

discontinued_products = execute_sql_query(sql_query)

fig = px.bar(discontinued_products, x='CategoryID', y='DiscontinuedCount',
             title='Number of Discontinued Products by Category',
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Number of Discontinued Products'})
show_to_user(fig)
```","The input code correctly identifies and counts the number of discontinued products but uses CategoryID instead of CategoryName. Since both implementations essentially serve the same purpose (grouping by category and counting discontinued products), and the chart displays the required information, the input code follows the same logic as the reference implementation. It correctly groups the discontinued products by category and creates a bar chart to visualize the data, satisfying the business request.","```python
import pandas as pd
import plotly.express as px

# Step 1: Identify discontinued products
discontinued_query = ""SELECT ProductID, Category FROM products WHERE Discontinued = 1;""
discontinued_df = execute_sql_query(discontinued_query)

# Step 2: Count the number of discontinued products by category
discontinued_count_by_category = discontinued_df.groupby('Category').size().reset_index(name='Count')

# Step 3: Create a bar chart
fig = px.bar(discontinued_count_by_category, x='Category', y='Count',
             title='Number of Discontinued Products by Category',
             labels={'Count': 'Number of Discontinued Products', 'Category': 'Category'})

# Step 4: Display the bar chart
show_to_user(fig)
```","Both the reference and input implementations correctly query for discontinued products from a database, group the results by category, and create a bar chart to display the counts. The differences in column names ('CategoryName' vs 'Category') do not affect the correctness as they serve the same logical purpose. The input code uses 'ProductID' instead of 'ProductName', which does not impact the requested analysis, as the focus is on counting by category. Therefore, the input code adheres to the business analytics request and follows the same logical structure as the reference implementation.",both
"Which products need to be reordered, and can we visualize this through a bar chart showing each product's stock level compared to the reorder threshold?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would interact with a database to execute the query.
    # Replace this with actual database interaction code if needed.
    pass

# Function to display data or plot
def show_to_user(data):
    # Display the DataFrame or Plotly figure.
    pass

# SQL query to find products that need to be reordered
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock <= ReorderLevel;""

# Execute the SQL query and get the result as a pandas DataFrame
products_to_reorder_df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not products_to_reorder_df.empty:
    # Prepare data for plotting by adding a new column for difference or shortfall
    products_to_reorder_df['Shortfall'] = products_to_reorder_df['ReorderLevel'] - products_to_reorder_df['UnitsInStock']

    # Create a bar chart using Plotly
    fig = px.bar(
        products_to_reorder_df, 
        x='ProductName', 
        y=['UnitsInStock', 'ReorderLevel'], 
        barmode='group', 
        title='Stock Level vs Reorder Threshold',
        labels={'value': 'Stock Level', 'ProductName': 'Product Name'},
        text='Shortfall'
    )

    # Display the bar chart to the user
    show_to_user(fig)
else:
    print(""No products need reordering."")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ProductName, 
    UnitsInStock, 
    ReorderLevel 
FROM 
    products 
WHERE 
    UnitsInStock < ReorderLevel AND 
    Discontinued = 0
""""""

products_to_reorder = execute_sql_query(sql_query)

fig = px.bar(products_to_reorder, 
              x='ProductName', 
              y='UnitsInStock', 
              title='Products Stock Level vs Reorder Threshold',
              labels={'UnitsInStock': 'Stock Level'})
fig.add_scatter(x=products_to_reorder['ProductName'], 
                 y=products_to_reorder['ReorderLevel'], 
                 mode='lines+markers', 
                 name='Reorder Level', 
                 line=dict(color='red'))

show_to_user(fig)
```","The input code includes a condition for 'Discontinued = 0', which is not present in the reference code. Additionally, the input code uses a Scatter plot for 'ReorderLevel' in the bar chart, which is a different visualization approach compared to the grouped bar chart in the reference. These differences imply the logic is not identical to the reference implementation.","```python
import pandas as pd
import plotly.express as px

def get_products_needing_reorder():
    # SQL query to find products that need to be reordered
    sql_query = """"""
    SELECT ProductName, UnitsInStock, ReorderLevel 
    FROM products 
    WHERE UnitsInStock < ReorderLevel;
    """"""
    
    # Execute the SQL query and store the result in a DataFrame
    products_df = execute_sql_query(sql_query)
    
    # Add a column to calculate the difference between UnitsInStock and ReorderLevel
    products_df['StockDifference'] = products_df['ReorderLevel'] - products_df['UnitsInStock']
    
    return products_df

def plot_reorder_products(products_df):
    # Create a bar chart using Plotly
    fig = px.bar(
        products_df,
        x='ProductName',
        y=['UnitsInStock', 'ReorderLevel'],
        title='Products Reorder Levels',
        labels={'value': 'Units'},
        barmode='group'
    )
    # Display the plot using the utility function
    show_to_user(fig)

# Step 1: Get products that need reordering
products_to_reorder = get_products_needing_reorder()

# Step 2: Visualize the reorder information
plot_reorder_products(products_to_reorder)
```","The provided Python code satisfies the business analytics request of identifying products that need to be reordered and visualizing stock levels compared to reorder thresholds. The code executes a SQL query to fetch products needing reorder, calculates the difference between stock levels and reorder thresholds, and generates a bar chart using Plotly. The logic aligns with the reference implementation, as both identify products to reorder by comparing stock levels to reorder levels and visualize this data, despite a minor difference in SQL query comparison ('<=' vs '<'), labels, and text annotations in the plot.",Finetuned
Identify the cities with the highest number of suppliers and create a bar chart to visualize the top cities.,"```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch data
sql_query = """"""
SELECT City, COUNT(SupplierID) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC;
""""""

# Execute the SQL query and get a DataFrame
data = execute_sql_query(sql_query)

# Limit to top cities by number of suppliers
top_cities_df = data.head(10)

# Create a bar chart using Plotly
fig = px.bar(top_cities_df, x='City', y='SupplierCount', title='Top Cities by Number of Suppliers')

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT City, COUNT(SupplierID) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
LIMIT 10;
""""""

top_cities_df = execute_sql_query(sql_query)

fig = px.bar(top_cities_df, x='City', y='SupplierCount', title='Top Cities by Number of Suppliers')
show_to_user(fig)
```","The input code correctly identifies the top cities with the highest number of suppliers by using a SQL query to group by city, count suppliers, and order by the count in descending order, just as the reference code does. It includes the LIMIT clause in the SQL query to fetch the top 10 cities directly, which optimizes processing. This logic is equivalent to the reference implementation, which fetches all data and uses head(10) to limit it. Both implementations then create a bar chart using Plotly with the same parameters and display the chart using show_to_user. Therefore, the input code meets the business analytics request correctly.","```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT City, COUNT(SupplierID) AS NumberOfSuppliers
FROM suppliers
GROUP BY City
ORDER BY NumberOfSuppliers DESC;
""""""

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the top cities
fig = px.bar(data, x='City', y='NumberOfSuppliers', title='Top Cities by Number of Suppliers')

# Display the bar chart to the user
show_to_user(fig)
```","The input code does not limit the bar chart to the top cities by the number of suppliers, while the reference code limits it to the top 10. This results in potentially displaying more cities than intended, which diverges from the logic of the reference implementation.",Base
“Determine the average unit price of products sold in the last quarter and provide a bar chart of unit prices by product category.”,"```python
import pandas as pd
import plotly.express as px

# Sample utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate SQL query execution and returning a DataFrame
    # In real implementation, replace with actual SQL execution logic
    pass

def show_to_user(data):
    # Display the provided data or visualization
    pass

# SQL query to get average unit price by product category for last quarter
query = """"""
SELECT 
    AVG(od.UnitPrice) AS AvgUnitPrice, 
    p.CategoryName 
FROM [Order Details] od
JOIN Products p ON od.ProductID = p.ProductID
JOIN Orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 3 MONTH) AND CURDATE()
GROUP BY p.CategoryName;
""""""

# Execute SQL query to get the data
df = execute_sql_query(query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryName', y='AvgUnitPrice', title='Average Unit Price by Product Category')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Determine the start and end dates for the last quarter
today = datetime.today()
first_quarter_start = datetime(today.year, 1, 1)
first_quarter_end = datetime(today.year, 3, 31)
second_quarter_start = datetime(today.year, 4, 1)
second_quarter_end = datetime(today.year, 6, 30)
third_quarter_start = datetime(today.year, 7, 1)
third_quarter_end = datetime(today.year, 9, 30)
fourth_quarter_start = datetime(today.year, 10, 1)
fourth_quarter_end = datetime(today.year, 12, 31)

if today.month in [1, 2, 3]:
    last_quarter_start = fourth_quarter_start.replace(year=today.year - 1)
    last_quarter_end = fourth_quarter_end.replace(year=today.year - 1)
else:
    last_quarter_start = (today.replace(month=1) - timedelta(days=1)).replace(day=1)
    last_quarter_end = (last_quarter_start + pd.offsets.QuarterEnd(1))

# SQL query to get average unit price of products sold in the last quarter by product category
sql_query = f""""""
SELECT p.CategoryID, AVG(od.UnitPrice) AS AverageUnitPrice 
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE od.OrderID IN (
    SELECT OrderID 
    FROM Orders 
    WHERE OrderDate >= '{last_quarter_start.strftime('%Y-%m-%d')}' 
    AND OrderDate <= '{last_quarter_end.strftime('%Y-%m-%d')}'
)
GROUP BY p.CategoryID
""""""

# Execute the query
average_prices_df = execute_sql_query(sql_query)

# Create a bar chart for average unit prices by product category
fig = px.bar(average_prices_df, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Product Category', labels={'CategoryID': 'Product Category', 'AverageUnitPrice': 'Average Unit Price'})

# Show the chart to the user
show_to_user(fig)
```","The input code incorrectly identifies the last quarter. It handles quarter determination manually, which can be error-prone, instead of using the 'DATE_SUB(CURDATE(), INTERVAL 3 MONTH)' logic from the reference. Additionally, the input code groups by 'CategoryID' instead of 'CategoryName,' which might lead to incorrect visualization labels. Finally, the query in the reference directly includes the date logic, ensuring accuracy and simplicity.","```python
import pandas as pd
import plotly.express as px

# Mock function for executing SQL query and returning a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the function that would execute the SQL and return a DataFrame
    pass

# Mock function for displaying analysis results
def show_to_user(data):
    # This function would handle displaying the data or figure to the user
    pass

# SQL query to determine the average unit price of products sold in the last quarter
avg_unit_price_sql = """"""
SELECT AVG(UnitPrice) AS AveragePrice 
FROM [Order Details] 
WHERE OrderID IN (
    SELECT OrderID FROM orders 
    WHERE QUARTER(OrderDate) = QUARTER(CURDATE()) - 1 
    AND YEAR(OrderDate) = YEAR(CURDATE()) 
);
""""""

# Fetching average unit price
avg_df = execute_sql_query(avg_unit_price_sql)

# Display the average unit price to the user
show_to_user(avg_df)

# SQL query to get unit prices by product category for the last quarter
unit_price_by_category_sql = """"""
SELECT Category, AVG(UnitPrice) AS AveragePrice 
FROM [Order Details] 
JOIN Products ON [Order Details].ProductID = Products.ProductID
JOIN Categories ON Products.CategoryID = Categories.CategoryID
WHERE OrderID IN (
    SELECT OrderID FROM orders 
    WHERE QUARTER(OrderDate) = QUARTER(CURDATE()) - 1 
    AND YEAR(OrderDate) = YEAR(CURDATE()) 
)
GROUP BY Category;
""""""

# Fetching unit prices by product category
unit_price_by_category_df = execute_sql_query(unit_price_by_category_sql)

# Create a bar chart using Plotly
fig = px.bar(unit_price_by_category_df, 
             x='Category', 
             y='AveragePrice', 
             title='Average Unit Prices by Product Category in Last Quarter', 
             labels={'AveragePrice': 'Average Price', 'Category': 'Product Category'})

# Show the plot to the user
show_to_user(fig)
```","The input code determines the average unit price for all products sold in the last quarter separately from category-level aggregation. The business request and reference implementation require calculating and displaying only the average unit price by product category for the last quarter. The additional calculation of overall average unit price in the input code was not requested, making it inconsistent with the specified analytics request.",None
List products with a reorder level higher than units in stock and provide a bar chart to visualize the differences between reorder levels and units in stock.,"import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to get the necessary data
sql_query = ""SELECT ProductName, ReorderLevel, UnitsInStock FROM products WHERE ReorderLevel > UnitsInStock;""

# Step 2: Execute the SQL query using the provided utility function
data_df = execute_sql_query(sql_query)

# Step 3: Prepare the visualization using Plotly
fig = px.bar(data_df, 
             x='ProductName', 
             y=['ReorderLevel', 'UnitsInStock'], 
             barmode='group', 
             title='Products with Reorder Level Higher than Units in Stock',
             labels={'value': 'Quantity', 'ProductName': 'Product Name'},
             text_auto=True)

# Step 4: Display the visualization to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve products with a reorder level higher than units in stock
sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE ReorderLevel > UnitsInStock
""""""
products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the reorder levels and units in stock
products_df_melted = products_df.melt(id_vars=[""ProductID"", ""ProductName""], 
                                        value_vars=[""UnitsInStock"", ""ReorderLevel""], 
                                        var_name=""Inventory_Type"", 
                                        value_name=""Quantity"")

fig = px.bar(products_df_melted, 
              x='ProductName', 
              y='Quantity', 
              color='Inventory_Type', 
              barmode='group', 
              title='Reorder Levels vs Units in Stock')

show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It selects products with a reorder level higher than units in stock using an SQL query and visualizes the differences using a bar chart. The input code includes ProductID, which doesn't affect the correctness as ProductName and quantitative columns are used for visualization. Both codes group the data for comparative visibility and appropriately label the chart. The input code uses `melt` to reshape the data, which is valid and effective for visualization in Plotly.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve products with a higher reorder level than units in stock
sql_query = ""SELECT ProductID, ProductName, ReorderLevel, UnitsInStock FROM products WHERE ReorderLevel > UnitsInStock;""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Generate a bar chart for visualization
fig = px.bar(
    products_df,
    x='ProductName',
    y=['ReorderLevel', 'UnitsInStock'],
    title='Reorder Levels vs Units In Stock',
    labels={'value': 'Count', 'ProductName': 'Product Name'},
    barmode='group'
)

# Display the bar chart
show_to_user(fig)
```",The input Python code adheres to the specified business analytics request and follows the same logic as the reference implementation. Both codes execute an SQL query to retrieve products where the reorder level is higher than the units in stock and generate a bar chart to compare these quantities. Differences such as the inclusion of 'ProductID' in the SQL query and the chart title/label wording do not affect the correctness as per the request.,both
How much freight cost has been incurred by each employee's orders? Include a bar chart to visualize the total freight cost per employee.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT e.EmployeeID, SUM(o.Freight) AS TotalFreight 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID;
""""""

# Utility function to execute SQL and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function: should execute the SQL query and return a DataFrame
    # Replace with actual database connection and query execution
    data = {
        'EmployeeID': [1, 2, 3],
        'TotalFreight': [120.5, 250.0, 180.75]
    }
    return pd.DataFrame(data)

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(df, x='EmployeeID', y='TotalFreight', 
             title='Total Freight Cost per Employee',
             labels={'TotalFreight': 'Total Freight Cost', 'EmployeeID': 'Employee ID'})

# Utility function to show data or visualization
def show_to_user(data):
    # Mock function: should display DataFrame or Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, SUM(o.Freight) AS TotalFreight
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, EmployeeName
""""""

freight_costs_df = execute_sql_query(sql_query)
fig = px.bar(freight_costs_df, x='EmployeeName', y='TotalFreight', title='Total Freight Cost per Employee', labels={'TotalFreight': 'Total Freight Cost', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code meets the business analytics request by calculating the total freight cost per employee and providing a bar chart to visualize it. The primary difference is the addition of employee names, which does not affect the core computation logic. Both calculate total freight costs using an SQL query that sums the 'Freight' grouped by 'EmployeeID', and display results in a bar chart. Therefore, the input code adheres to the same logic as the reference implementation, addressing the business question correctly.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total freight cost per employee
sql_query = """"""
SELECT employees.EmployeeID, SUM(orders.Freight) AS TotalFreightCost
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
GROUP BY employees.EmployeeID;
""""""

# Fetch data using the utility function
freight_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the total freight cost per employee
fig = px.bar(freight_data, x='EmployeeID', y='TotalFreightCost',
             title='Total Freight Cost per Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalFreightCost': 'Total Freight Cost'},
             text_auto=True)

# Display the figure
show_to_user(fig)
```","The input Python code correctly mirrors the logic and outcome of the reference implementation. Both codes execute a SQL query to calculate the total freight cost incurred by each employee by summing up the freight costs from orders linked to employees via their EmployeeID. The input code uses correct table and column references and groups by EmployeeID, matching the reference. For visualization, the input code utilizes Plotly to create a bar chart, labeling the axes appropriately, and includes an automated text display for bars, which is an added feature but does not affect correctness. Overall, the input code meets the business analytics request and adheres to the reference implementation's logic.",both
"How many orders were processed by employees in each city, and can this be visualized in a bar chart to compare the number of orders across different cities?","import plotly.express as px
import pandas as pd

# SQL query to get the number of orders processed by employees in each city
sql_query = """"""
SELECT employees.City, COUNT(orders.OrderID) AS OrderCount
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
GROUP BY employees.City;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders across different cities
fig = px.bar(df, x='City', y='OrderCount', title='Number of Orders Processed in Each City')

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.City, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.City
""""""

order_counts = execute_sql_query(sql_query)

fig = px.bar(order_counts, x='City', y='OrderCount', title='Number of Orders Processed by Employees in Each City')
show_to_user(fig)
```","The input code correctly executes a SQL query that joins the employees and orders tables, counts the number of orders per city, and groups by city. It uses the same logic as the reference implementation. The visualization step with Plotly Express to create a bar chart is also correctly implemented, matching the reference code.","```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user are predefined utility functions.

# SQL query to fetch the data
sql_query = """"""
SELECT employees.City, COUNT(DISTINCT orders.OrderID) AS OrderCount
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
GROUP BY employees.City;
""""""

# Execute the SQL query and get the data in a DataFrame
orders_by_city_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    orders_by_city_df,
    x='City',
    y='OrderCount',
    title='Number of Orders Processed by Employees in Each City',
    labels={'OrderCount': 'Number of Orders', 'City': 'City'},
    text='OrderCount'
)

# Show the bar chart to the user
show_to_user(fig)
```","The provided code differs from the reference code because it uses COUNT(DISTINCT orders.OrderID). If there are duplicate OrderIDs for an Employee, this will result in a different count compared to the reference code which uses COUNT(orders.OrderID). This changes the logic and could lead to different results.",Base
"What is the average unit price of products per supplier, and can we visualize this data using a bar chart to compare suppliers?","```python
import pandas as pd
import plotly.express as px

# Placeholder function for executing SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulate executing the SQL query and returning a DataFrame
    # In practice, this function would connect to a database and execute the query
    pass

# Placeholder function for displaying data or visualizations to the user
def show_to_user(data):
    # Code to display data or visualization, e.g., with Plotly
    pass

# The SQL query to find the average unit price of products per supplier
sql_query = """"""
SELECT suppliers.CompanyName, AVG(products.UnitPrice) AS AvgUnitPrice
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
GROUP BY suppliers.CompanyName;
""""""

# Execute the SQL query and retrieve the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average unit price per supplier
fig = px.bar(df, x='CompanyName', y='AvgUnitPrice', title='Average Unit Price per Supplier', labels={'CompanyName': 'Supplier', 'AvgUnitPrice': 'Average Unit Price'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(p.UnitPrice) AS AverageUnitPrice
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
""""""

average_prices_df = execute_sql_query(sql_query)

fig = px.bar(average_prices_df, x='CompanyName', y='AverageUnitPrice', title='Average Unit Price of Products per Supplier', labels={'AverageUnitPrice': 'Average Unit Price', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input Python code is correct. It successfully executes a SQL query to retrieve the average unit price of products per supplier with the correct join and aggregation logic. It then creates a bar chart using Plotly to visualize the data, following the same logic as the reference implementation. Although some variable names differ, the essential operations and outcome align with the business analytics request.","
```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT s.SupplierID, AVG(p.UnitPrice) AS AverageUnitPrice FROM suppliers s JOIN products p ON s.SupplierID = p.SupplierID GROUP BY s.SupplierID;""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(df, x='SupplierID', y='AverageUnitPrice', title='Average Unit Price of Products per Supplier')

# Display the visualization
show_to_user(fig)
```","The input code calculates the average unit price grouped by SupplierID instead of CompanyName. This means it might not directly match the business request unless the SupplierID and CompanyName can be mapped equivalently. Additionally, the visualization should use the CompanyName for x-axis to match the reference, which uses CompanyName for a clearer supplier comparison.",Base
"“What are the total sales for each month in 2023, and can you provide a line graph to visualize the trends?”","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query and retrieve the data as a pandas DataFrame
query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = 2023 
GROUP BY month
""""""
sales_data = execute_sql_query(query)

# Create a line graph to visualize the total sales trends for each month
fig = px.line(sales_data, x='month', y='total_sales', title='Total Sales per Month in 2023', labels={'total_sales': 'Total Sales'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY 
    month
ORDER BY 
    month
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='month', y='total_sales', title='Total Sales per Month in 2023', labels={'total_sales': 'Total Sales', 'month': 'Month'})
show_to_user(fig)
```","The input code is correct. It calculates the total sales for each month in 2023 using SQL and visualizes the trend with a line graph. The logic and approach are similar to the reference code. The differences are cosmetic and do not affect the outcome: a date range is used instead of YEAR function, the SQL query is formatted slightly differently, and an additional label for 'month' has been added in the graph.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get total sales for each month in 2023
sql_query = """"""
SELECT 
    CONCAT(YEAR(orders.OrderDate), '-', LPAD(MONTH(orders.OrderDate), 2, '0')) AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE YEAR(orders.OrderDate) = 2023
GROUP BY YEAR(orders.OrderDate), MONTH(orders.OrderDate);
""""""
sales_data = execute_sql_query(sql_query)

# Create a line graph to visualize the sales trends
sales_data['month'] = pd.to_datetime(sales_data['month'], format='%Y-%m')
fig = px.line(sales_data, x='month', y='total_sales', title='Monthly Sales Trends in 2023')

# Show the line graph to the user
show_to_user(fig)
```","The provided input Python code correctly implements the logic described in the business analytics request. It calculates total sales for each month in 2023 using SQL, aggregates the data in a similar manner as the reference code, and makes use of Python's Pandas and Plotly libraries to visualize the data as a line graph. The main difference is in how the month is formatted (using CONCAT and LPAD), but it effectively achieves the same result as DATE_FORMAT. The conversion of 'month' to a datetime object ensures proper chronological plotting, which is good practice in time-series data visualization.",both
"How does employee efficiency vary based on the shipping regions they handle, and can this be visualized using a comparative chart or heatmap?","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT EmployeeID, ShipRegion, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY EmployeeID, ShipRegion 
ORDER BY EmployeeID, AvgFulfillmentTime ASC;
""""""

# Execute the SQL query and get a DataFrame
df = execute_sql_query(sql_query)

# Create a heatmap for visualizing employee efficiency based on shipping regions
fig = px.density_heatmap(
    df,
    x='EmployeeID',
    y='ShipRegion',
    z='AvgFulfillmentTime',
    color_continuous_scale='Viridis',
    title='Employee Efficiency by Shipping Region',
    labels={'AvgFulfillmentTime': 'Avg Fulfillment Time'}
)

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipRegion, 
    AVG(Freight) AS AvgShippingCost,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID) AS OnTimeDeliveryRate,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
GROUP BY 
    ShipRegion
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, 
             x='ShipRegion', 
             y=['AvgShippingCost', 'OnTimeDeliveryRate', 'AvgFulfillmentTime'], 
             title='Employee Efficiency by Shipping Region',
             labels={'value': 'Metrics', 'ShipRegion': 'Shipping Region'},
             barmode='group')

show_to_user(fig)
```","The input code computes different metrics (AvgShippingCost, OnTimeDeliveryRate, AvgFulfillmentTime) by ShipRegion instead of EmployeeID and ShipRegion. The reference code computes AvgFulfillmentTime specifically by EmployeeID and ShipRegion, which aligns with the request to analyze employee efficiency across regions. Additionally, the reference uses a heatmap for comparative visualization, whereas the input uses a grouped bar chart. Thus, the input code does not follow the same logic or fully answer the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch efficiency data based on shipping regions
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, o.ShipRegion, 
       (COUNT(o.OrderID) / DATEDIFF(MAX(o.ShippedDate), MIN(o.OrderDate))) AS Efficiency 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, o.ShipRegion 
ORDER BY Efficiency DESC;
""""""

# Function to execute the SQL query and return data as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual implementation
    pass

# Function to display data analysis results
def show_to_user(data):
    # Placeholder for actual implementation
    pass

# Execute the SQL query to get the efficiency data
df = execute_sql_query(sql_query)

# Generate a comparative chart using Plotly
fig = px.scatter(df, x='ShipRegion', y='Efficiency', color='FirstName', 
                 hover_name='LastName', title='Employee Efficiency by Shipping Region')

# Display the chart using the utility function
show_to_user(fig)
```","The input code calculates 'Efficiency' differently. It uses 'COUNT(o.OrderID) / DATEDIFF(MAX(o.ShippedDate), MIN(o.OrderDate))' while the reference code uses 'AVG(DATEDIFF(ShippedDate, OrderDate))'. The visualization type also differs: the reference uses a heatmap and the input uses a scatter plot. Hence, it doesn't adhere to the request as specified in the reference code.",None
Which city has the highest number of unique customers? Provide a bar chart to visualize the number of unique customers across all cities.,"
import pandas as pd
import plotly.express as px

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a stub for executing SQL, in practice, this would connect to a database
    # For demonstration purposes, this returns a sample DataFrame directly
    sample_data = {'City': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'],
                   'unique_customers': [300, 250, 200, 150, 100]}
    return pd.DataFrame(sample_data)

# Function to show data to the user
def show_to_user(data):
    # A stub for demonstrating the visualization
    print(data)

# Main logic
sql_query = """"""
SELECT customers.City, COUNT(DISTINCT customers.CustomerID) AS unique_customers 
FROM customers 
GROUP BY customers.City 
ORDER BY unique_customers DESC;
""""""

# Execute the SQL query and receive a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='City', y='unique_customers', title='Unique Customers by City')

# Show the bar chart using the utility function
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of unique customers by city
sql_query = """"""
SELECT c.City, COUNT(DISTINCT o.CustomerID) AS unique_customers
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.City
ORDER BY unique_customers DESC
""""""

# Execute the SQL query and retrieve the data
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of unique customers across all cities
fig = px.bar(data, x='City', y='unique_customers', title='Number of Unique Customers by City')
show_to_user(fig)
```","The input code introduces a difference in logic compared to the reference implementation. The input code uses a JOIN between 'customers' and 'orders' tables, which implies that a customer must have an order to be counted. The reference code assumes counting unique customers purely based on the 'customers' table, without considering orders. This affects the count of unique customers, leading to potentially different results.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT City, COUNT(DISTINCT CustomerID) AS UniqueCustomers 
FROM customers 
GROUP BY City 
ORDER BY UniqueCustomers DESC;
""""""

# Execute the SQL query and retrieve the data
customer_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(customer_data, x='City', y='UniqueCustomers', 
             title='Number of Unique Customers by City', 
             labels={'UniqueCustomers': 'Number of Unique Customers', 'City': 'City'})

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request. It executes a SQL query to count unique customers per city, orders them, and visualizes this data in a bar chart using Plotly. While there are some differences in variable naming and syntax, the logic is consistent with the reference implementation. Both codes define a query for unique customers, execute it, and visualize the results correctly.",Finetuned
"What is the average time taken to fulfill orders each month, and can you provide a line graph to visualize the monthly trends?","```python
import plotly.express as px
import pandas as pd

# SQL query to get monthly average fulfillment times
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       AVG(DATE_PART('day', ShippedDate - OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
monthly_fulfillment_df = execute_sql_query(sql_query)

# Ensure that the 'Month' column is in datetime format for Plotly
monthly_fulfillment_df['Month'] = pd.to_datetime(monthly_fulfillment_df['Month'])

# Create a line graph using Plotly to visualize the monthly trends
fig = px.line(monthly_fulfillment_df, 
              x='Month', 
              y='AvgFulfillmentTime', 
              title='Average Order Fulfillment Time by Month',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'Month': 'Month'})

# Display the line graph to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS avg_fulfillment_time
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    month
ORDER BY 
    month;
""""""

avg_fulfillment_time_df = execute_sql_query(sql_query)

fig = px.line(avg_fulfillment_time_df, x='month', y='avg_fulfillment_time', 
              title='Average Order Fulfillment Time by Month',
              labels={'avg_fulfillment_time': 'Average Fulfillment Time (days)', 'month': 'Month'})

show_to_user(fig)
```","Both implementations aim to calculate the average fulfillment time of orders each month and visualize the trend using a line graph. The input code takes into account only shipped orders by using 'WHERE ShippedDate IS NOT NULL'. It uses DATE_FORMAT function for MySQL, which aligns with DATE_TRUNC in the reference code (likely for PostgreSQL). The logic of computing the difference in days and aggregating by month is preserved. Thus, the input code fulfills the request properly.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', ShippedDate) AS OrderMonth, 
       AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY OrderMonth;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Change the type of OrderMonth to datetime for better plotting
data['OrderMonth'] = pd.to_datetime(data['OrderMonth'])

# Generate a line graph to visualize the monthly trends
fig = px.line(data, x='OrderMonth', y='AvgFulfillmentTime', 
              title='Average Fulfillment Time per Month',
              labels={'AvgFulfillmentTime': 'Avg Fulfillment Time (days)', 'OrderMonth': 'Month'})

# Show the line graph
show_to_user(fig)
```","The primary issue is in the SQL query. In the input code, the month is calculated based on 'ShippedDate', but it should be based on 'OrderDate' as in the reference. This changes how orders are grouped, leading to different results. The calculation of AvgFulfillmentTime uses DATEDIFF in the input code instead of DATE_PART('day', ShippedDate - OrderDate), which could behave differently depending on the SQL dialect but serves a similar purpose. The rest of the code for visualization is effectively the same in both implementations.",Base
"How many employees were hired in 2023, and can you provide a monthly breakdown using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Placeholder function to simulate SQL query execution
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating the return of monthly hire data from an SQL database
    data = {
        'month': ['2023-01', '2023-02', '2023-03', '2023-04', '2023-05', '2023-06',
                  '2023-07', '2023-08', '2023-09', '2023-10', '2023-11', '2023-12'],
        'hires_count': [5, 8, 10, 12, 6, 15, 20, 18, 22, 10, 5, 7]
    }
    return pd.DataFrame(data)

# Placeholder function to simulate displaying data to user
def show_to_user(data):
    # In the actual environment, implement how data or figure is shown to the user
    pass

# SQL Query to count hires - provided as input
sql_query = """"""
SELECT COUNT(*) AS hires_count 
FROM employees 
WHERE employees.HireDate BETWEEN '2023-01-01' AND '2023-12-31'
""""""

# Execute the SQL query
hires_df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(hires_df, x='month', y='hires_count', title='Monthly Breakdown of Hires in 2023')

# Use the utility function to show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT MONTH(HireDate) AS month, COUNT(*) AS num_hired
FROM employees
WHERE YEAR(HireDate) = 2023
GROUP BY MONTH(HireDate)
ORDER BY MONTH(HireDate);
""""""

hired_data = execute_sql_query(sql_query)

fig = px.bar(hired_data, x='month', y='num_hired', labels={'month': 'Month', 'num_hired': 'Number of Employees Hired'}, title='Employees Hired in 2023 by Month')
show_to_user(fig)
```","Both implementations achieve the same goal: counting the number of employees hired each month in 2023 and visualizing the data in a bar chart. They both group records by month, calculate the count, and use Plotly to generate a bar chart, following the same logic despite differences in SQL syntax and variable naming.","```python
import pandas as pd
import plotly.express as px

# SQL query for fetching monthly hire data for 2023
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM HireDate) AS month, 
    COUNT(*) AS NumberHired 
FROM employees 
WHERE EXTRACT(YEAR FROM HireDate) = 2023 
GROUP BY month 
ORDER BY month;
""""""

# Execute SQL query and get results in a DataFrame
monthly_hires_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly for monthly hires in 2023
fig = px.bar(monthly_hires_df, 
             x='month', 
             y='NumberHired', 
             title='Monthly Employee Hires in 2023', 
             labels={'month': 'Month', 'NumberHired': 'Number of Employees Hired'})

# Display the chart to the user
show_to_user(fig)
```","The input code calculates the monthly breakdown of hires in 2023 by executing a SQL query that groups hires by month within the year 2023. The result is stored in a DataFrame and visualized using a bar chart, similar to the logic in the reference implementation. Both implementations achieve the task of visualizing the monthly hires with a bar chart, showing the correct data retrieval and visualization steps.",both
"Which customers have placed the highest number of orders, and can this be visualized in a bar chart?","
import pandas as pd
import plotly.express as px

# SQL query provided in the business request
sql_query = """"""
SELECT c.CustomerID, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID
ORDER BY OrderCount DESC;
""""""

# Function to execute the SQL query and get the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function is implemented elsewhere to return query results as a DataFrame
    pass

# Function to display the data or visualization
def show_to_user(data):
    # Assume this function is implemented elsewhere to handle displaying data
    pass

# Execute the SQL query and get the results
customers_order_count_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(customers_order_count_df, x='CustomerID', y='OrderCount', title='Customers with Highest Number of Orders')

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS OrderCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY OrderCount DESC
LIMIT 10;
""""""

customer_orders = execute_sql_query(sql_query)

fig = px.bar(customer_orders, x='CompanyName', y='OrderCount', title='Top Customers by Number of Orders', labels={'OrderCount': 'Number of Orders', 'CompanyName': 'Customer'}, text='OrderCount')
show_to_user(fig)
```","The input code includes CompanyName in the grouping, which deviates from the reference implementation that only uses CustomerID. This may lead to different results depending on the uniqueness of CompanyName for each CustomerID. Additionally, the input code limits the results to the top 10 customers, which is not part of the reference code specification. These differences indicate that the input code does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are defined as per the environment constraints

# Business logic: Fetching the customers with the highest number of orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY OrderCount DESC;
""""""

# Execute the query and retrieve the data
customers_with_most_orders_df = execute_sql_query(sql_query)

# Visualize the results in a bar chart using Plotly
fig = px.bar(customers_with_most_orders_df, x='CustomerID', y='OrderCount',
             title='Customers with Highest Number of Orders',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'},
             template='plotly')

# Show the figure to the user
show_to_user(fig)
```","The input code is correct as it effectively implements the same logic as the reference code. Both pieces of code execute a SQL query to count the number of orders per customer, order the customers by the order count in descending order, and visualize the results using a bar chart. The primary difference lies in the SQL query—which omits the 'join' with customers in the input code—but it aligns with the logic required to answer the business question. The visualization details, such as labels and templates, are also correctly handled.",Finetuned
"  
""Which month experienced the highest number of late shipments? Please include a bar chart to represent the monthly late shipment counts for better understanding.""  ","import pandas as pd
import plotly.express as px

# SQL query to get monthly late shipments
sql_query = """"""
SELECT EXTRACT(MONTH FROM ShippedDate) AS Month, COUNT(*) AS LateShipments 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY EXTRACT(MONTH FROM ShippedDate) 
ORDER BY Month ASC;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation; replace with actual database connection and query execution
    data = {
        ""Month"": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
        ""LateShipments"": [5, 8, 3, 6, 7, 10, 12, 9, 4, 11, 13, 2]
    }
    return pd.DataFrame(data)

# Function to display data or visualization
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        # Plotly visualization will automatically be shown with this command in appropriate environments
        data.show()

# Get the data from SQL query
df_late_shipments = execute_sql_query(sql_query)

# Find the month with the highest number of late shipments
max_late_shipments = df_late_shipments['LateShipments'].max()
month_with_max_late_shipments = df_late_shipments[
    df_late_shipments['LateShipments'] == max_late_shipments
]

# Display the month with the highest late shipments
show_to_user(month_with_max_late_shipments)

# Create a bar chart for monthly late shipments
fig = px.bar(df_late_shipments, x='Month', y='LateShipments', title='Monthly Late Shipments')
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly late shipment counts
sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS LateShipments
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
late_shipments_df = execute_sql_query(sql_query)

# Identify the month with the highest late shipments
max_late_shipments_month = late_shipments_df.loc[late_shipments_df['LateShipments'].idxmax()]

# Create a bar chart for monthly late shipment counts
fig = px.bar(late_shipments_df, x='Month', y='LateShipments', title='Monthly Late Shipment Counts')
show_to_user(fig)
```","The input code extracts 'Month' as year-month format ('%Y-%m'), whereas the reference extracts just the month number. This causes the code to group by year-month instead of just month. Additionally, the input code directly indexes the month with the highest late shipments without displaying this information, unlike the reference code which shows the month separately before plotting. The logic for ordering and visualizing the data should match to ensure consistency in business reporting.","```python
import pandas as pd
import plotly.express as px

# Execute SQL query
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month, 
       COUNT(CASE WHEN ShipDate > RequiredDate THEN 1 END) AS num_late_shipments 
FROM orders 
GROUP BY Year, Month 
ORDER BY Year, Month;
""""""
data = execute_sql_query(sql_query)

# Aggregate data by Month
data['Month'] = data['Month'].astype(int)  # Ensure Month is int for correct plotting

# Find month with highest number of late shipments
highest_late_shipments = data.loc[data['num_late_shipments'].idxmax()]

# Create a bar chart using Plotly
fig = px.bar(
    data, 
    x='Month', 
    y='num_late_shipments', 
    title=f""Monthly Late Shipments (Max: {highest_late_shipments['Month']} {highest_late_shipments['Year']})"",
    labels={'num_late_shipments': 'Number of Late Shipments'},
    text='num_late_shipments'
)

# Show the bar chart to the user
show_to_user(fig)
```","The input code differs in logic from the reference implementation. The SQL query in the input code extracts years and orders by Year and Month, whereas the business request and reference code focus on Month only. The input code attempts to use 'OrderDate' instead of 'ShippedDate' for month extraction, which changes the intent substantially. Additionally, the bar chart title and logic do not align correctly with finding the highest month overall—it incorrectly references Year and Month. The logic needs revision to match the business request and the reference logic.",None
"What is the total revenue generated by each product category, and can it be visualized to compare differences effectively?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the total revenue by product category
sql_query = '''
SELECT c.CategoryID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID;
'''

# Execute the SQL query and store the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total revenue by category
fig = px.bar(df, x='CategoryID', y='TotalRevenue', title='Total Revenue by Product Category', 
             labels={'TotalRevenue':'Total Revenue', 'CategoryID':'Category ID'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.CategoryID
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='CategoryID', y='TotalRevenue', title='Total Revenue by Product Category',
             labels={'CategoryID': 'Product Category', 'TotalRevenue': 'Total Revenue'},
             color='TotalRevenue')
show_to_user(fig)
```","The input code calculates total revenue with a consideration for discounts using the expression 'SUM(od.Quantity * od.UnitPrice * (1 - od.Discount))', which differs from the reference code that does not consider discounts. Also, the input code does not join with the 'categories' table, resulting in potentially different groupings and missing the category names that might lead to incorrect aggregations.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total revenue generated by each product category
sql_query = """"""
SELECT CategoryID, 
       SUM(UnitPrice * Quantity * (1 - Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY CategoryID;
""""""

# Execute the SQL query and retrieve data as a DataFrame
df = execute_sql_query(sql_query)

# Visualize the total revenue by product category using a bar chart
fig = px.bar(df, x='CategoryID', y='TotalRevenue', title='Total Revenue by Product Category')

# Display the visualization to the user
show_to_user(fig)
```","The input code includes a discount factor in the revenue calculation (SUM(UnitPrice * Quantity * (1 - Discount))), while the reference implementation does not apply any discounts. Also, the input code aggregates by CategoryID from the 'Order Details' table directly, whereas the reference code joins with the 'categories' table to ensure the aggregation is tied to existing categories.",None
How many orders were shipped each month? Visualize the results with a line chart showing monthly order counts.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation, replace with actual SQL execution logic
    import sqlite3
    conn = sqlite3.connect('your_database.db')  # Example using SQLite
    df = pd.read_sql_query(sql_query, conn)
    conn.close()
    return df

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to get the monthly order count
sql_query = """"""
SELECT strftime('%Y-%m', ShippedDate) AS Month,
       COUNT(OrderID) AS OrderCount
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY Month;
""""""

# Execute the SQL query
monthly_orders_df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(monthly_orders_df, x='Month', y='OrderCount', title='Monthly Shipped Orders')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', ShippedDate) AS shipping_month,
    COUNT(OrderID) AS order_count
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    shipping_month
ORDER BY 
    shipping_month;
""""""

monthly_orders = execute_sql_query(sql_query)

fig = px.line(monthly_orders, x='shipping_month', y='order_count',
              title='Monthly Orders Shipped',
              labels={'shipping_month': 'Month', 'order_count': 'Number of Orders Shipped'})

show_to_user(fig)
```","The input code successfully extracts the monthly order count using SQL and performs the same operations as the reference code. It groups orders by month with non-null 'ShippedDate', counts them, orders the results, and visualizes them with a line chart in Plotly. The key logical steps are preserved: querying the monthly data and producing a line graph. The differences, such as the SQL syntax for date truncation and chart label customization, do not affect the functional correctness regarding the task description.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime

# Function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing SQL query
    # In practice, this would connect to a database and return the data
    pass

# Function to display data analysis or visualization result
def show_to_user(data):
    # Placeholder for displaying data or visualization
    pass

# SQL Query to fetch orders shipped each month
sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month, 
    COUNT(OrderID) AS OrdersShipped 
FROM orders 
GROUP BY DATE_FORMAT(ShippedDate, '%Y-%m')
""""""

# Execute the query and fetch the data
orders_data = execute_sql_query(sql_query)

# Ensure 'Month' is in datetime format for proper sorting
orders_data['Month'] = pd.to_datetime(orders_data['Month'])

# Sort data by Month
orders_data = orders_data.sort_values('Month')

# Create a line chart using Plotly
fig = px.line(orders_data, x='Month', y='OrdersShipped', title='Monthly Order Shipments')

# Display the line chart
show_to_user(fig)
```","The input code does not match the reference implementation logic exactly. The input code does not explicitly exclude NULL 'ShippedDate' values from the counting, while the reference code does. In the reference code, this is achieved with the WHERE ShippedDate IS NOT NULL condition, ensuring only non-null dates are considered. Additionally, the SQL string in the input uses DATE_FORMAT, which is not standard SQL and may only work in certain databases like MySQL, whereas the reference uses SQLite's strftime function.",Base
"What is the total freight cost for each shipping country, and can you provide a bar chart to illustrate the costs by country?","```python
import pandas as pd
import plotly.express as px

# Define the utilities
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be implemented to return a DataFrame
    pass

def show_to_user(data):
    # This function is assumed to be implemented to display a DataFrame or Plotly figure
    pass

# SQL query to retrieve the total freight cost for each shipping country
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreightCost 
FROM orders 
GROUP BY ShipCountry;
""""""

# Execute the SQL query to retrieve the data
data = execute_sql_query(sql_query)

# Create a bar chart to visualize total freight cost by shipping country
fig = px.bar(data, x='ShipCountry', y='TotalFreightCost', 
             title='Total Freight Cost by Shipping Country',
             labels={'TotalFreightCost': 'Total Freight Cost', 'ShipCountry': 'Shipping Country'},
             height=400)

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipCountry
""""""

freight_costs_df = execute_sql_query(sql_query)

fig = px.bar(freight_costs_df, x='ShipCountry', y='TotalFreight', title='Total Freight Costs by Country')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It queries the total freight cost for each shipping country using an appropriate SQL statement, aggregates the data correctly with SUM and GROUP BY, and visualizes the result in a bar chart using Plotly Express. Although the column name 'TotalFreight' differs from 'TotalFreightCost' in the reference code, it does not affect the correctness of the logic or the outcome. Therefore, the solution matches the functionality of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total freight cost by shipping country
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight 
FROM orders 
GROUP BY ShipCountry;
""""""

# Execute the query using the utility function
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ShipCountry', y='TotalFreight', title='Total Freight Cost by Shipping Country')

# Show the bar chart using the utility function
show_to_user(fig)
```","The input code correctly executes an SQL query to retrieve the total freight cost for each shipping country and visualizes the result using a bar chart. Although the alias for the 'Freight' sum is 'TotalFreight' instead of 'TotalFreightCost', it does not affect the correctness as both codes follow the same logic and purpose for the visualization. The functionality and business request are both accurately addressed.",both
"Identify suppliers with orders that have not been shipped yet, and visualize the number of unshipped orders per supplier using a bar chart.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function for demonstration. This should be replaced with actual database interaction.
    # Returns a pandas DataFrame representing the query result.
    pass

def show_to_user(data):
    # Mock function for demonstration. This should display the data or visualization.
    # In a real scenario, this function would render dataframes or plotly figures.
    pass

# SQL query to identify suppliers with unshipped orders
sql_query = """"""
SELECT suppliers.CompanyName, COUNT(orders.OrderID) AS UnshippedOrdersCount 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.ShippedDate IS NULL 
GROUP BY suppliers.CompanyName;
""""""

# Execute SQL query and fetch results into a dataframe
unshipped_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of unshipped orders per supplier
fig = px.bar(unshipped_orders_df, x='CompanyName', y='UnshippedOrdersCount',
             title='Number of Unshipped Orders per Supplier',
             labels={'CompanyName': 'Supplier', 'UnshippedOrdersCount': 'Unshipped Orders'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(o.OrderID) AS UnshippedOrders
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN orders o ON p.ProductID = o.OrderID
WHERE o.ShippedDate IS NULL
GROUP BY s.SupplierID, s.CompanyName
ORDER BY UnshippedOrders DESC;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CompanyName', y='UnshippedOrders', title='Number of Unshipped Orders per Supplier', labels={'UnshippedOrders': 'Unshipped Orders', 'CompanyName': 'Supplier Name'})
show_to_user(fig)
```","The provided code contains an error in the SQL query. It uses 'JOIN orders o ON p.ProductID = o.OrderID' instead of joining correctly through '[Order Details]'. Therefore, it does not align with the logic of the reference implementation that combines multiple tables through '[Order Details]' to count unshipped orders.","import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT suppliers.SupplierID, COUNT(orders.OrderID) AS UnshippedOrders
FROM suppliers
JOIN products ON suppliers.SupplierID = products.SupplierID
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.ShippedDate IS NULL
GROUP BY suppliers.SupplierID
""""""

# Execute the SQL query
unshipped_orders_df = execute_sql_query(sql_query)

# Create a bar chart visualizing the number of unshipped orders per supplier
fig = px.bar(
    unshipped_orders_df,
    x='SupplierID',
    y='UnshippedOrders',
    title='Number of Unshipped Orders per Supplier',
    labels={'SupplierID': 'Supplier ID', 'UnshippedOrders': 'Unshipped Orders'}
)

# Display the visualization
show_to_user(fig)","The input code groups results by 'SupplierID' instead of 'CompanyName', which, although it might be a valid alternative for displaying suppliers, deviates from the reference implementation that specifies grouping by 'CompanyName'. The visualization labels and the field names in the grouping also differ from the reference implementation.",None
"Which products have been ordered more than 100 times, and can this be visually represented using a bar chart to show the quantities ordered for each product?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve products ordered more than 100 times
sql_query = """"""
SELECT ProductID, COUNT(OrderID) AS OrderCount 
FROM [Order Details] 
GROUP BY ProductID 
HAVING COUNT(OrderID) > 100;
""""""

# Function to execute the SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assume this function is implemented to execute the provided SQL query
    # and return the results as a DataFrame
    pass

# Execute the query
order_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the quantities ordered
fig = px.bar(order_data, x='ProductID', y='OrderCount', 
             title='Products Ordered More Than 100 Times',
             labels={'ProductID': 'Product ID', 'OrderCount': 'Order Count'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductName, 
    SUM(od.Quantity) AS TotalOrdered 
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID 
GROUP BY 
    p.ProductID, p.ProductName 
HAVING 
    SUM(od.Quantity) > 100
""""""

result_df = execute_sql_query(sql_query)

fig = px.bar(result_df, x='ProductName', y='TotalOrdered', title='Products Ordered More Than 100 Times')
show_to_user(fig)
```","The input code computes the sum of quantities (`SUM(od.Quantity)`) instead of counting orders (`COUNT(OrderID)`) like the reference. It also uses `ProductName` rather than `ProductID` in the bar chart. Hence, the logic does not match the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Define the function to execute the query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the SQL execution logic
    # In reality, this would connect to the database and execute the SQL
    pass

# Define the function to display the results
def show_to_user(data):
    # This is a placeholder for displaying data
    # Can be adjusted based on how the environment handles it
    pass

# SQL query to fetch products ordered more than 100 times
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalOrdered
FROM [Order Details]
GROUP BY ProductID
HAVING SUM(Quantity) > 100;
""""""

# Execute the SQL query and get results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalOrdered', 
             title='Products Ordered More Than 100 Times',
             labels={'ProductID': 'Product ID', 'TotalOrdered': 'Total Quantity Ordered'})

# Show the bar chart to the user
show_to_user(fig)
```","The reference implementation counts the number of orders for each product using 'COUNT(OrderID)', while the input code sums the quantities ordered using 'SUM(Quantity)'. This results in different calculations: the reference checks the number of orders exceeding 100, whereas the input checks if the total quantity ordered exceeds 100. They do not adhere to the same logic.",None
"What is the percentage of orders requiring delivery within one week, and can this be visualized using a pie chart?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT COUNT(OrderID) * 100.0 / (SELECT COUNT(*) FROM orders) AS Percentage 
FROM orders 
WHERE DATEDIFF(RequiredDate, OrderDate) <= 7;
""""""

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Extract the percentage value
percentage = df.iloc[0]['Percentage']

# Prepare the data for visualization
data = {'Category': ['Within One Week', 'More Than One Week'], 'Percentage': [percentage, 100 - percentage]}
df_visual = pd.DataFrame(data)

# Create a pie chart using Plotly
fig = px.pie(df_visual, names='Category', values='Percentage', title='Orders Delivery Time Distribution')

# Display the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN DATEDIFF(RequiredDate, OrderDate) <= 7 THEN 1 ELSE 0 END) AS UrgentOrders
FROM 
    orders
""""""

orders_data = execute_sql_query(sql_query)

total_orders = orders_data['TotalOrders'][0]
urgent_orders = orders_data['UrgentOrders'][0]

percentage_urgent = (urgent_orders / total_orders) * 100

labels = ['Urgent Orders', 'Other Orders']
values = [urgent_orders, total_orders - urgent_orders]

fig = px.pie(names=labels, values=values, title=f'Percentage of Orders Requiring Delivery Within One Week: {percentage_urgent:.2f}%')
show_to_user(fig)
```","The input code correctly evaluates the percentage of orders requiring delivery within one week and visualizes it using a pie chart. Although the SQL and visualization logic are structured differently, they achieve the same result as the reference implementation. Both calculate the percentage of urgent orders and display it in a pie chart, fulfilling the request.","```python
import pandas as pd
import plotly.express as px

# Assume the utility function to execute SQL query exists
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function definition
    pass

def show_to_user(data):
    # Placeholder function definition
    pass

# SQL query to obtain data required for the analysis
sql_query = """"""
SELECT 
    (COUNT(CASE WHEN ShippedDate <= DATE_ADD(OrderDate, INTERVAL 7 DAY) THEN 1 END) / COUNT(*)) * 100.0 AS OrderedWithinAWeek 
FROM orders;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Extracting the percentage value from the DataFrame
percentage = df['OrderedWithinAWeek'].iloc[0]

# Create data for the pie chart
data = {
    'Category': ['Delivered within a week', 'Not delivered within a week'],
    'Percentage': [percentage, 100 - percentage]
}
pie_df = pd.DataFrame(data)

# Create a pie chart using Plotly
fig = px.pie(pie_df, names='Category', values='Percentage', title='Delivery Within One Week')

# Show the pie chart to the user
show_to_user(fig)
```","The input code calculates the percentage of orders shipped within one week of the order date, which is different from the reference code that calculates the percentage of orders requiring delivery within one week from the order date. The conditions checked in the SQL queries are not equivalent: the reference checks the 'RequiredDate' against 'OrderDate', while the input checks 'ShippedDate' against an adjusted 'OrderDate'.",Base
"How does sales distribution vary across different regions? Please include a data visualization, such as a map or bar chart, to enhance understanding of the distribution.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database connection and query execution
    # In practice, this function would connect to the database, execute the query,
    # and return the results as a pandas DataFrame.
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data.head())
    else:
        data.show()

# SQL query to get sales distribution across regions
sql_query = """"""
SELECT region.RegionDescription, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
JOIN employeeTerritories ON employees.EmployeeID = employeeTerritories.EmployeeID 
JOIN territories ON employeeTerritories.TerritoryID = territories.TerritoryID 
JOIN region ON territories.RegionID = region.RegionID 
GROUP BY region.RegionDescription
""""""

# Execute SQL query and get results
sales_data = execute_sql_query(sql_query)

# Check if sales_data is not None
if sales_data is not None:
    # Create bar chart to visualize sales distribution across different regions
    fig = px.bar(sales_data, x='RegionDescription', y='total_sales', 
                 title='Sales Distribution Across Regions', 
                 labels={'RegionDescription': 'Region', 'total_sales': 'Total Sales'})
    
    # Show the visualization
    show_to_user(fig)
else:
    print(""No data available from the query."")
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    r.RegionDescription, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
JOIN 
    customers c ON o.CustomerID = c.CustomerID
JOIN 
    territories t ON c.CustomerID = t.TerritoryID
JOIN 
    region r ON t.RegionID = r.RegionID
GROUP BY 
    r.RegionDescription
ORDER BY 
    total_sales DESC
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='RegionDescription', y='total_sales', title='Sales Distribution by Region')
show_to_user(fig)
```","The evaluated code uses a different join logic by joining `territories` with `customers` instead of `employeeTerritories`, leading to potentially incorrect sales distribution data per region. It also orders the results, which is unnecessary for the visualization task.","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT Region, SUM(Sales) AS TotalSales 
FROM (
    SELECT customers.Region, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Sales
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    JOIN customers ON orders.CustomerID = customers.CustomerID
    GROUP BY customers.Region
) AS RegionalSales
GROUP BY Region;
""""""

# Execute the SQL query and store the result in a DataFrame
df_sales_distribution = execute_sql_query(sql_query)

# Generate a bar chart to visualize the sales distribution across regions
fig = px.bar(df_sales_distribution, x='Region', y='TotalSales', 
             title='Sales Distribution Across Regions',
             labels={'TotalSales': 'Total Sales', 'Region': 'Region'},
             template='plotly')

# Display the figure using the utility function
show_to_user(fig)
```","The reference code calculates sales distribution using the region information from employees and territories, while the input code uses customer regions. This could lead to different results if employee and customer regions differ. Therefore, the input code doesn't adhere to the same logic as the reference implementation.",None
"What is the average value of orders placed in the month of January 2023, and can this be represented with a bar chart showing the daily average values?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the daily total and count of orders
sql_query = """"""
SELECT 
    DATE(orders.OrderDate) AS OrderDate,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_order_value,
    COUNT(DISTINCT orders.OrderID) AS order_count
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    MONTH(orders.OrderDate) = 1 AND YEAR(orders.OrderDate) = 2023 
GROUP BY 
    DATE(orders.OrderDate)
""""""

# Execute the SQL query using provided utility function
order_data = execute_sql_query(sql_query)

# Calculate the daily average order value
order_data['avg_order_value'] = order_data['total_order_value'] / order_data['order_count']

# Create a bar chart showing the daily average order values
fig = px.bar(order_data, x='OrderDate', y='avg_order_value', title='Daily Average Order Values for January 2023')

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get daily average order values for January 2023
sql_query = """"""
SELECT DATE(orders.OrderDate) AS order_date,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / COUNT(DISTINCT orders.OrderID) AS avg_order_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY DATE(orders.OrderDate)
ORDER BY DATE(orders.OrderDate)
""""""

# Execute SQL query
daily_avg_values = execute_sql_query(sql_query)

# Calculate overall average for January 2023
overall_avg = daily_avg_values['avg_order_value'].mean()

# Create bar chart for daily average values
fig = px.bar(daily_avg_values, x='order_date', y='avg_order_value', title='Daily Average Order Value - January 2023', labels={'order_date': 'Date', 'avg_order_value': 'Average Order Value'})

# Show results to user
show_to_user(fig)
```","The input Python code correctly computes the average value of orders for each day in January 2023, using a SQL query that aggregates order values and counts based on order dates. The query retrieves the daily average by dividing the total order values by the count of orders, matching the logic of the reference implementation. The result is then used to create a bar chart of daily average values, as requested. Although the code includes an additional computation of overall average, it does not violate the primary task requirements.","```python
import pandas as pd
import plotly.express as px

# Define SQL query to fetch daily averages for January 2023
sql_query_january_daily_avg = """"""
SELECT 
    ORDERS.OrderDate, 
    AVG(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS DailyAverageOrderValue 
FROM ORDERS 
JOIN [Order Details] OD ON ORDERS.OrderID = OD.OrderID 
WHERE YEAR(ORDERS.OrderDate) = 2023 AND MONTH(ORDERS.OrderDate) = 1 
GROUP BY ORDERS.OrderDate;
""""""

# Execute SQL query to get the daily average order values
january_daily_avg_df = execute_sql_query(sql_query_january_daily_avg)

# Calculate the overall average value of orders in January 2023
january_avg_value = january_daily_avg_df['DailyAverageOrderValue'].mean()

# Display the average value
average_value_message = f""The average value of orders in January 2023 is: {january_avg_value:.2f}""
show_to_user(pd.DataFrame([average_value_message], columns=[""January 2023 Average Order Value""]))

# Create a bar chart using Plotly to show daily average values
fig = px.bar(january_daily_avg_df, 
             x='OrderDate', 
             y='DailyAverageOrderValue', 
             labels={'OrderDate': 'Date', 'DailyAverageOrderValue': 'Average Order Value'},
             title='Daily Average Order Values for January 2023')

# Display the bar chart
show_to_user(fig)
```","The input code calculates 'DailyAverageOrderValue' as an average of each order's contribution (unit price * quantity * (1 - discount)) and averages it per day. This is incorrect as different from computing the 'Daily Total' divided by 'Order Count'. The logic of computing the average by dividing the total order value by count is different from averaging individual order values, as performed in the input code.",Base
"What is the total sales generated by each employee in the last month, and can this be shown using a bar chart for better visualization?","import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # In practice, this function would connect to a database,
    # execute the provided SQL query, and return the results as a DataFrame.
    pass

def show_to_user(data):
    # In practice, this function would take the given data, which could be a DataFrame or Plotly figure,
    # and display it to the user.
    pass

# SQL query to find the total sales generated by each employee in the last month
sql_query = """"""
SELECT e.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE) 
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and get the results as a DataFrame
df_sales = execute_sql_query(sql_query)

# Create a bar chart to visualize the total sales by each employee
fig = px.bar(df_sales, x='EmployeeID', y='TotalSales', title='Total Sales by Employee in Last Month')

# Display the chart to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

last_month_start = (datetime.now() - timedelta(days=30)).date()
last_month_end = datetime.now().date()

sql_query = f""""""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE o.OrderDate BETWEEN '{last_month_start}' AND '{last_month_end}'
GROUP BY e.EmployeeID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, 
             x='EmployeeName', 
             y='TotalSales', 
             title='Total Sales Generated by Each Employee in the Last Month',
             labels={'EmployeeName': 'Employee', 'TotalSales': 'Total Sales'})

show_to_user(fig)
```","The input code calculates sales for a specific 30-day range from today (current date minus 30 days) rather than the last calendar month. Additionally, it uses employee names instead of IDs, which deviates from the specified reference logic. The reference code uses 'DATEADD(MONTH, -1, CURRENT_DATE)' guaranteeing the last month data, not a rolling 30 days.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales by each employee for the last month
sql_query = """"""
SELECT 
    e.EmployeeID, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE MONTH(o.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(o.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) 
GROUP BY e.EmployeeID;
""""""

# Function to execute the SQL query and get the data as a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart for total sales by each employee
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Total Sales by Employee in Last Month')

# Use the provided utility function to display the figure
show_to_user(fig)
```","Both codes calculate the total sales generated by each employee for the last month and create a bar chart for visualization. The input code uses a different method to filter dates using 'MONTH' and 'YEAR' functions instead of 'DATEADD', but it achieves the same result. Thus, the logic is consistent with the reference implementation.",Finetuned
Determine the Customer Retention Rate for the past quarter and visualize the trends using a line chart.,"
```python
import pandas as pd
import plotly.express as px


def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function executes the given SQL query and returns a DataFrame.
    # Implementation depends on database connection specifics.
    pass  # Replace with actual implementation


def show_to_user(data):
    # This function displays DataFrame or Plotly figures.
    pass  # Replace with actual implementation

# SQL query to calculate Customer Retention Rate for the past quarter
sql_query = """"""
SELECT 100.0 * (
    SELECT COUNT(DISTINCT CustomerID) 
    FROM orders 
    WHERE OrderDate BETWEEN '2023-07-01' AND '2023-09-30'
) / (
    SELECT COUNT(DISTINCT CustomerID) 
    FROM orders 
    WHERE OrderDate < '2023-07-01'
) AS RetentionRate;
""""""

# Execute the SQL query
retention_rate_df = execute_sql_query(sql_query)

# Extract retention rate value for plotting
retention_rate = retention_rate_df['RetentionRate'].iloc[0]

# Create a DataFrame for the line plot
# Corrected frequency to 'MS' for month start to include each month point
date_range = pd.date_range(start='2023-07-01', end='2023-09-30', freq='MS')
trend_data = pd.DataFrame({'Date': date_range, 'RetentionRate': [retention_rate] * len(date_range)})

# Create a line chart using Plotly
fig = px.line(trend_data, x='Date', y='RetentionRate', title='Customer Retention Rate Trend')

# Display the plot
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the start and end dates for the past quarter
end_date = datetime.now() - timedelta(days=datetime.now().day)
start_date = end_date - timedelta(days=90)

# SQL query to calculate the Customer Retention Rate
sql_query = f""""""
SELECT
    COUNT(DISTINCT CASE WHEN OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}' THEN CustomerID END) AS returning_customers,
    COUNT(DISTINCT CustomerID) AS total_customers
FROM
    orders
WHERE
    OrderDate < '{start_date.date()}';
""""""

# Execute the SQL query
retention_data = execute_sql_query(sql_query)

# Calculate retention rate
retention_rate = (retention_data['returning_customers'].values[0] / retention_data['total_customers'].values[0]) * 100

# Prepare data for visualization
trend_data = {
    'Period': ['Before Quarter', 'During Quarter'],
    'Customers': [retention_data['total_customers'].values[0], retention_data['returning_customers'].values[0]]
}

trend_df = pd.DataFrame(trend_data)

# Create a line chart for Customer Retention Rate
fig = px.line(trend_df, x='Period', y='Customers', title='Customer Retention Rate Trend', markers=True)

# Show the chart to the user
show_to_user(fig)
```","The input code calculates retention rate using two periods: 'Before Quarter' and 'During Quarter', whereas the reference implementation calculates the retention rate for the past quarter compared to all customers before the quarter. The input incorrectly treats 'Before Quarter' and 'During Quarter' as separate segments in the trend chart instead of showing a time-based trend over the past quarter. Furthermore, the visualization in the input uses 'Period' as x-axis with categorical data, which differs from the reference line chart with a time-based x-axis.","```python
import pandas as pd
import plotly.express as px

# Utility function that executes SQL query and returns a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function to simulate SQL execution
    # Replace with actual database call in a real environment
    pass

# Utility function to show data to the user
def show_to_user(data):
    # Dummy function to simulate showing data to the user
    pass

# SQL query to retrieve customer data
sql_query = """"""
SELECT OrderDate, 
       COUNT(DISTINCT CustomerID) AS active_customers
FROM orders
WHERE OrderDate BETWEEN '2023-07-01' AND '2023-09-30'
GROUP BY OrderDate;
""""""

# Execute SQL query and get the results
orders_df = execute_sql_query(sql_query)

# Calculate Customer Retention Rate
orders_df = orders_df.sort_values('OrderDate')
orders_df['customer_retention_rate'] = orders_df['active_customers'] / orders_df['active_customers'].iloc[0] * 100

# Plot the Customer Retention Rate
fig = px.line(orders_df, x='OrderDate', y='customer_retention_rate', title='Customer Retention Rate Over Past Quarter')

# Display the chart
show_to_user(fig)
```","The evaluated code is incorrect because it computes the retention rate on a daily basis rather than for the whole past quarter as a single value. The reference code calculates retention rate by dividing the number of unique customers in the quarter by the number of unique customers before it, resulting in a single RetentionRate value. The evaluated code instead creates a customer retention rate trend over time, normalizing daily counts against the first day's number of customers, leading to incorrect quarterly retention rate.",None
Calculate the average reorder level across all products and create a visualization to show the distribution of reorder levels.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get reorder levels
sql_query = ""SELECT ReorderLevel FROM products;""

# Execute the SQL query to retrieve the data
reorder_level_data = execute_sql_query(sql_query)

# Calculate the average reorder level
average_reorder_level = reorder_level_data['ReorderLevel'].mean()

# Print the average reorder level to the user
print(f""Average Reorder Level: {average_reorder_level}"")

# Create a visualization to show the distribution of reorder levels
fig = px.histogram(reorder_level_data, x='ReorderLevel', title='Distribution of Reorder Levels')

# Use the utility function to display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT ReorderLevel FROM products""
reorder_levels_df = execute_sql_query(sql_query)

average_reorder_level = reorder_levels_df['ReorderLevel'].mean()

fig = px.histogram(reorder_levels_df, x='ReorderLevel', title='Distribution of Reorder Levels')
show_to_user(fig)

average_reorder_level
```","The input code correctly calculates the average reorder level by executing a SQL query and computing the mean of the 'ReorderLevel' values. It then creates a histogram using Plotly Express to visualize the distribution of reorder levels. While it doesn't explicitly print the average as in the reference, returning the value fulfills the requirement. Both codes execute similar SQL queries and perform the necessary data operations and visualizations accurately.","
import pandas as pd
import plotly.express as px

# Given utility functions, assumed to be predefined.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would contain the logic to execute the SQL query.
    pass

def show_to_user(data):
    # This function would contain the logic to display the data or visualization.
    pass

# SQL query to get reorder levels for all products
sql_query = ""SELECT ReorderLevel FROM products;""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Calculate the average reorder level
avg_reorder_level = products_df['ReorderLevel'].mean()

# Display average reorder level
avg_reorder_df = pd.DataFrame({'AverageReorderLevel': [avg_reorder_level]})
show_to_user(avg_reorder_df)

# Visualize the distribution of reorder levels
fig = px.histogram(products_df, x='ReorderLevel', title='Distribution of Reorder Levels')
show_to_user(fig)
","The provided code correctly follows the logic of the reference implementation. It calculates the average reorder level from a SQL query result and displays it using a utility function, similar to printing it directly. It also visualizes the distribution of reorder levels using a histogram, which aligns with the reference. Despite minor differences such as output presentation (using a DataFrame), the overall logic matches the reference implementation's intent and functionality.",both
"How many units on order exist for each supplier, and can you provide a bar chart to visualize the distribution?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = ""SELECT SupplierID, SUM(UnitsOnOrder) as TotalUnitsOnOrder FROM products GROUP BY SupplierID;""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='SupplierID', y='TotalUnitsOnOrder', title='Units On Order for Each Supplier')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, SUM(p.UnitsOnOrder) AS TotalUnitsOnOrder
FROM products p
GROUP BY p.SupplierID
""""""

supplier_units_on_order = execute_sql_query(sql_query)

fig = px.bar(supplier_units_on_order, x='SupplierID', y='TotalUnitsOnOrder', 
             title='Units on Order by Supplier', 
             labels={'SupplierID': 'Supplier ID', 'TotalUnitsOnOrder': 'Total Units on Order'})

show_to_user(fig)
```","Both implementations execute an SQL query that groups products by SupplierID and calculates the sum of UnitsOnOrder. They then use Plotly to create a bar chart visualizing the total units on order for each supplier. The query logic and visualization process align with the business analytics request. Despite minor differences, such as SQL string formatting and additional labels in the visualization, the code achieves the same result as the reference.","```python
import plotly.express as px
import pandas as pd

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be predefined within the environment
    # Returns a pandas DataFrame after executing the SQL query
    pass

# Function to display data or visualization
def show_to_user(data):
    # This function should be predefined within the environment
    # Accepts a pandas DataFrame or a Plotly figure for visualization
    pass

# SQL query to fetch units on order for each supplier
sql_query = """"""
SELECT s.CompanyName, SUM(p.UnitsOnOrder) AS TotalUnitsOnOrder
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution
fig = px.bar(df, x='CompanyName', y='TotalUnitsOnOrder',
             title='Units on Order by Supplier',
             labels={'CompanyName': 'Supplier', 'TotalUnitsOnOrder': 'Total Units On Order'})

# Display the bar chart
show_to_user(fig)
```","The provided code uses 'CompanyName' instead of 'SupplierID' to group and sum the 'UnitsOnOrder'. The reference implementation groups by 'SupplierID', which aligns with the request to list 'units on order' by supplier. The structure and logic required are altered in the input code, deviating from the expected result based on the reference code.",Base
Which supplier provides the most number of different products? Include a bar chart to compare the number of different products offered by each supplier.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the required data
sql_query = '''
SELECT SupplierID, COUNT(DISTINCT ProductID) AS NumberOfProducts
FROM products
GROUP BY SupplierID
ORDER BY NumberOfProducts DESC;
'''

# Assuming execute_sql_query and show_to_user are defined elsewhere as per the environment constraints
data = execute_sql_query(sql_query)

# Generate a bar chart to visualize the number of different products offered by each supplier
fig = px.bar(data, x='SupplierID', y='NumberOfProducts', title='Number of Different Products by Supplier', labels={'NumberOfProducts': 'Number of Different Products', 'SupplierID': 'Supplier ID'}, text='NumberOfProducts')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT SupplierID, COUNT(DISTINCT ProductID) AS ProductCount
FROM products
GROUP BY SupplierID
ORDER BY ProductCount DESC;
""""""

supplier_products_df = execute_sql_query(sql_query)

fig = px.bar(supplier_products_df, 
             x='SupplierID', 
             y='ProductCount', 
             title='Number of Different Products Offered by Each Supplier',
             labels={'ProductCount': 'Number of Different Products', 'SupplierID': 'Supplier ID'})

show_to_user(fig)
```","The provided Python code correctly answers the business analytics request and follows the logic of the reference implementation. Both codes execute a SQL query that selects SupplierID and counts distinct ProductIDs, group by SupplierID, and order by the count in descending order. The columns 'NumberOfProducts' and 'ProductCount' are interchangeable as they serve the same purpose. Both create and display a bar chart with appropriate labels. The functionality and outcome remain aligned with the reference.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of different products offered by each supplier
sql_query = """"""
SELECT s.SupplierID, COUNT(DISTINCT p.ProductID) AS ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID ORDER BY ProductCount DESC;
""""""

# Execute the SQL query using the utility function
df_suppliers = execute_sql_query(sql_query)

# Create a bar chart to compare the number of different products offered by each supplier
fig = px.bar(df_suppliers, x='SupplierID', y='ProductCount', title='Number of Different Products by Supplier')

# Show the bar chart to the user
show_to_user(fig)
```",Both the input and reference implementations correctly count and order the number of distinct products offered by each supplier using SQL. The resulting dataset is then visualized using a bar chart with Plotly. The difference in variable naming ('NumberOfProducts' vs 'ProductCount') and the inclusion of text labels in the bar chart do not affect the correctness of the code in terms of meeting the business analytics request.,both
What is the average discount offered on products that have been discontinued? Please include a bar chart to illustrate the distribution of discounts.,"```python
import pandas as pd
import plotly.express as px

# Assuming the utility functions have already been implemented:
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is to be implemented elsewhere
    pass

def show_to_user(data):
    # This function is to be implemented elsewhere
    pass

# SQL query to get average discount for discontinued products
sql_query = """"""
SELECT [Order Details].Discount
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
WHERE products.Discontinued = 1;
""""""

# Execute the SQL query and store the result in a DataFrame
discount_data = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = discount_data['Discount'].mean()

# Create a bar chart to illustrate the distribution of discounts
fig = px.histogram(discount_data, x='Discount', title='Distribution of Discounts on Discontinued Products', 
                   labels={'Discount': 'Discount Value'}, nbins=10)

# Show the bar chart to the user
show_to_user(fig)

# Since the business request asked for the average as well, printing it out
average_info = pd.DataFrame({'Average Discount': [average_discount]})
show_to_user(average_info)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, od.Discount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 1
""""""

discount_data = execute_sql_query(sql_query)

average_discount = discount_data['Discount'].mean()
discount_distribution = discount_data['Discount'].value_counts().reset_index()
discount_distribution.columns = ['Discount', 'Count']

fig = px.bar(discount_distribution, x='Discount', y='Count', title='Distribution of Discounts on Discontinued Products')
show_to_user(fig)

average_discount
```","The input code correctly calculates the average discount for discontinued products and visualizes the distribution using a bar chart. The SQL query appropriately joins the necessary tables and selects from discontinued products. Although it uses `value_counts` and a bar chart instead of a histogram, both approaches effectively show the distribution, fulfilling the business request requirements.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT Discount FROM [Order Details] 
WHERE ProductID IN (
    SELECT ProductID FROM products 
    WHERE Discontinued = 1
);
""""""

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = discount_data['Discount'].mean()
average_discount_df = pd.DataFrame({'AverageDiscount': [average_discount]})

# Display the average discount
show_to_user(average_discount_df)

# Create a distribution plot of the discounts using a bar chart
discount_counts = discount_data['Discount'].value_counts().reset_index()
discount_counts.columns = ['Discount', 'Count']

# Plotting the bar chart using Plotly
fig = px.bar(discount_counts, x='Discount', y='Count', title='Distribution of Discounts on Discontinued Products')

# Show the bar chart
show_to_user(fig)
```","The input code correctly fulfills the request by executing an SQL query to retrieve discounts on discontinued products, calculating the average discount, and visualizing the distribution using a bar chart. The SQL logic matches the reference code, where it filters discontinued products and retrieves discounts. The difference in implementation, such as the use of value counts instead of a histogram, still effectively portrays the distribution of discounts.",both
"Which cities have the highest number of sales from employees, and can this be represented in a bar chart for better comparison?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.City, COUNT(*) AS SalesCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.City 
ORDER BY SalesCount DESC;
""""""

# Execute the SQL query and retrieve the data as a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='City', y='SalesCount', 
             title='Sales Count by City',
             labels={'SalesCount': 'Number of Sales', 'City': 'City'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.City, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.City
ORDER BY TotalSales DESC
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='City', y='TotalSales', title='Total Sales by City', labels={'TotalSales': 'Total Sales', 'City': 'City'})
show_to_user(fig)
```","The input code sums total sales by city, while the reference code counts sales transactions by city. They measure different metrics. The input does not fulfill the request for the number of sales.","
```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT employees.City, SUM([Order Details].Quantity) AS num_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
GROUP BY employees.City
ORDER BY num_sales DESC
""""""

# Execute the SQL query and get the results in a DataFrame
sales_data_df = execute_sql_query(sql_query)

# Create a bar chart for better comparison of sales by city
fig = px.bar(sales_data_df, x='City', y='num_sales', title='Number of Sales by City')

# Show the figure to the user
show_to_user(fig)
```","The input code differs from the reference implementation in how sales are counted. The reference implementation counts the number of sales (using COUNT(*)), while the input code sums the quantities of items sold (SUM([Order Details].Quantity)). Thus, they are providing different insights.",None
"Which products have the highest turnover rates, and can you provide a visualization to compare these rates effectively?","```python
import pandas as pd
import plotly.express as px


def analyze_and_visualize_turnover():
    # Define the SQL query
    sql_query = '''
    SELECT ProductID, 
           SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS TurnoverRatio 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    GROUP BY ProductID 
    ORDER BY TurnoverRatio DESC;
    '''

    # Execute the query and get the result as a DataFrame
    df = execute_sql_query(sql_query)

    # Create a bar chart to visualize turnover rates
    fig = px.bar(df, x='ProductID', y='TurnoverRatio', title='Product Turnover Rates',
                 labels={'TurnoverRatio': 'Turnover Rate', 'ProductID': 'Product ID'},
                 height=400)

    # Display the figure to the user
    show_to_user(fig)

# Call the function to perform the analysis and visualization
analyze_and_visualize_turnover()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity * od.UnitPrice) AS TotalSales,
    AVG(p.UnitsInStock) AS AverageInventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    InventoryTurnoverRatio DESC
LIMIT 10;
""""""

turnover_data = execute_sql_query(sql_query)

fig = px.bar(turnover_data, 
             x='ProductName', 
             y='InventoryTurnoverRatio', 
             title='Top 10 Products by Inventory Turnover Ratio',
             labels={'InventoryTurnoverRatio':'Turnover Ratio'})
show_to_user(fig)
```","The input code correctly calculates the turnover rate using the same logic as the reference code. Both implementations use the sum of sales divided by the average units in stock to determine the turnover rate. The input code improves upon this by handling divisions by zero safely using `NULLIF` and includes product names for more informative visualization. Additionally, it limits the result to the top 10 products. The visualization part is consistent in using a bar chart to display turnover rates. Thus, the input code adheres to the business request and logic of the reference implementation.","
```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are already defined

# SQL query to get product turnover rates
sql_query = """"""
SELECT ProductID, 
       (SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock)) AS TurnoverRate 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
GROUP BY ProductID;
""""""

# Execute the query to retrieve data
turnover_data = execute_sql_query(sql_query)

# Sort data by TurnoverRate in descending order
turnover_data_sorted = turnover_data.sort_values(by=""TurnoverRate"", ascending=False)

# Create a visualization using Plotly to compare turnover rates
fig = px.bar(turnover_data_sorted, 
             x='ProductID', 
             y='TurnoverRate', 
             title='Product Turnover Rates',
             labels={'TurnoverRate': 'Turnover Rate', 'ProductID': 'Product ID'},
             color='TurnoverRate')

# Display the visualization to the user
show_to_user(fig)
```
","The input code correctly performs the required analysis and visualization. It computes the turnover rate for each product by dividing the total sales amount by the average units in stock, similar to the reference implementation. The results are sorted in descending order of turnover rates before creating a bar chart visualization with Plotly, matching the reference code's logic and intent, even though specific ordering of data happens after SQL execution.",both
"Who are the top 5 customers by revenue, and can a bar chart be created to visualize their revenue contributions?","
import pandas as pd
import plotly.express as px

# SQL query to extract top 5 customers by revenue
sql_query = '''
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY TotalRevenue DESC 
LIMIT 5;
'''

# Fetch the data using the execute_sql_query function
# Assuming the function is correctly implemented elsewhere
# to connect to the database and fetch results

top_customers_df = execute_sql_query(sql_query)

# Visualize the top 5 customers by revenue using a bar chart
fig = px.bar(top_customers_df, x='CustomerID', y='TotalRevenue',
             title='Top 5 Customers by Revenue',
             labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue'})

# Use the show_to_user function to display the figure
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 5 customers by revenue
sql_query = """"""
SELECT c.CustomerID, c.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY TotalRevenue DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

# Creating a bar chart to visualize their revenue contributions
fig = px.bar(top_customers, x='CompanyName', y='TotalRevenue', 
             title='Top 5 Customers by Revenue', 
             labels={'TotalRevenue': 'Revenue', 'CompanyName': 'Customer Name'})

show_to_user(fig)
```","The input code correctly retrieves the top 5 customers by revenue and creates a bar chart to visualize their revenue contributions. While it slightly extends the reference logic by including the 'CompanyName' in the SQL query, this does not affect the correctness of the implementation. Both codes calculate the total revenue appropriately and use Plotly to generate a bar chart. The visual aspect and the primary computation align with the business request and reference logic.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the top 5 customers by revenue
sql_query = """"""
SELECT c.CustomerID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM customers AS c 
JOIN orders AS o ON c.CustomerID = o.CustomerID 
JOIN [Order Details] AS od ON o.OrderID = od.OrderID 
GROUP BY c.CustomerID 
ORDER BY TotalRevenue DESC 
LIMIT 5;
""""""

# Execute the SQL query to get the data
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top 5 customers by revenue
fig = px.bar(top_customers_df, 
             x='CustomerID', 
             y='TotalRevenue', 
             title='Top 5 Customers by Revenue',
             labels={'CustomerID': 'Customer ID', 'TotalRevenue': 'Total Revenue'},
             text='TotalRevenue')

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code produces the expected result of identifying the top 5 customers by revenue and visualizing this data through a bar chart. The SQL query and logic for data fetching and visualization directly align with the reference implementation. Though the input code includes 'text' in the bar chart for displaying revenue values, this does not alter the correctness of the intended output according to the business analytics request.",both
"How many customers placed more than 3 orders in 2023? Additionally, provide a bar chart to visualize the distribution of the number of customers with varying order frequencies.","```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT customers.CustomerID, COUNT(DISTINCT orders.OrderID) as order_count
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY customers.CustomerID 
HAVING COUNT(DISTINCT orders.OrderID) > 3
""""""

# Fetch the data using the utility function
customer_data = execute_sql_query(sql_query)

# Count the number of customers who placed more than 3 orders
customer_count = len(customer_data)

# Display the count result
print(""Number of customers who placed more than 3 orders in 2023:"", customer_count)

# Preparing the data for visualization
order_frequency_data = customer_data['order_count'].value_counts().reset_index()
order_frequency_data.columns = ['order_count', 'customer_count']

# Bar chart visualization using Plotly
fig = px.bar(
    order_frequency_data,
    x='order_count',
    y='customer_count',
    title='Distribution of Customers with Order Frequencies',
    labels={'order_count': 'Number of Orders', 'customer_count': 'Number of Customers'}
)

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders placed by each customer in 2023
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY CustomerID
HAVING COUNT(OrderID) > 3
""""""

# Execute the SQL query and retrieve the data
customers_with_more_than_three_orders = execute_sql_query(sql_query)

# Count of customers with more than 3 orders
number_of_customers = customers_with_more_than_three_orders.shape[0]

# SQL query to get the order frequency distribution
order_frequency_query = """"""
SELECT COUNT(CustomerID) AS CustomerCount, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY CustomerID
""""""

# Execute the SQL query to retrieve the order frequency data
order_frequency_data = execute_sql_query(order_frequency_query)

# Create a bar chart to visualize the distribution of customers with varying order frequencies
fig = px.bar(order_frequency_data, x='OrderCount', y='CustomerCount', title='Customer Order Frequency Distribution in 2023',
             labels={'OrderCount': 'Number of Orders', 'CustomerCount': 'Number of Customers'})

# Show the number of customers who placed more than 3 orders and the visualization
print(f'Number of customers who placed more than 3 orders in 2023: {number_of_customers}')
show_to_user(fig)
```","The input code does not correctly replicate the logic of the reference code. In the input code, the query for the order frequency distribution mistakenly aggregates `CustomerCount` as `COUNT(CustomerID)` and matches it with `OrderCount` as `COUNT(OrderID)`, which could misrepresent the labeling based on `GROUP BY`. In contrast, the reference code correctly calculates this using value counts on `order_count` retrieved from the first query. Additionally, the visualization labels might not truly reflect the data due to this error.","```python
import pandas as pd
from utility_functions import execute_sql_query, show_to_user
import plotly.express as px

# SQL query to get all customers with more than 3 orders in 2023
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) as OrderCount
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY CustomerID
HAVING COUNT(OrderID) > 3;
""""""

# Execute the SQL query and get the DataFrame
customers_with_orders_2023 = execute_sql_query(sql_query)

# Count the number of customers with order frequencies
order_frequency_distribution = customers_with_orders_2023['OrderCount'].value_counts().reset_index()
order_frequency_distribution.columns = ['OrderCount', 'NumberOfCustomers']

# Create a bar chart using Plotly
fig = px.bar(order_frequency_distribution, x='OrderCount', y='NumberOfCustomers',
             title='Distribution of Customers by Order Frequency in 2023',
             labels={'OrderCount': 'Number of Orders', 'NumberOfCustomers': 'Number of Customers'})

# Display the bar chart
show_to_user(fig)
```","The provided Python code correctly implements the solution as per the business analytics request. It selects customers with more than 3 orders in 2023, counts them, and visualizes the distribution using a bar chart. The logic aligns with the reference code, as it effectively counts orders per customer and filters those with more than 3 orders, although it slightly differs in column naming and selection query format.",Finetuned
Find the product with the highest current stock level and visualize the top five products by stock level.,"```python
import plotly.express as px

# SQL Queries
query_highest_stock = ""SELECT ProductName, UnitsInStock FROM products ORDER BY UnitsInStock DESC LIMIT 1;""
query_top_five_stock = ""SELECT ProductName, UnitsInStock FROM products ORDER BY UnitsInStock DESC LIMIT 5;""

# Execute the SQL query to find the product with the highest stock level
highest_stock_df = execute_sql_query(query_highest_stock)

# Execute the SQL query to find the top five products by stock level
top_five_stock_df = execute_sql_query(query_top_five_stock)

# Display the product with the highest stock level to the user
show_to_user(highest_stock_df)

# Visualize the top five products by stock level using Plotly
fig = px.bar(top_five_stock_df, x='ProductName', y='UnitsInStock', title='Top Five Products by Stock Level')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock 
FROM products 
WHERE Discontinued = 0
ORDER BY UnitsInStock DESC
LIMIT 5
""""""

top_products_df = execute_sql_query(sql_query)

highest_stock_product = top_products_df.loc[top_products_df['UnitsInStock'].idxmax()]

fig = px.bar(top_products_df, 
             x='ProductName', 
             y='UnitsInStock', 
             title='Top 5 Products by Stock Level', 
             labels={'UnitsInStock': 'Stock Level', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code evaluates products also based on the 'Discontinued = 0' condition, which isn't present in the reference code. While it tries to find the product with the highest stock within the selected top five after applying this condition, it does not correctly identify and display the product with the highest stock level as the reference code does. The visualization of the top five products is performed correctly, but the business analytics request included finding and displaying the product with the highest stock separately.","```python
import plotly.express as px

# SQL query to find the top five products by stock level
sql_query = """"""
SELECT p.ProductName, p.UnitsInStock FROM products p 
ORDER BY p.UnitsInStock DESC
FETCH FIRST 5 ROWS ONLY;
""""""

# Execute the SQL query and retrieve the data
df_top_products = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(df_top_products, x='ProductName', y='UnitsInStock', 
             title='Top 5 Products by Stock Level', 
             labels={'ProductName': 'Product Name', 'UnitsInStock': 'Units In Stock'})

# Display the plot
show_to_user(fig)
```",The input code only retrieves and visualizes the top five products by stock level. It doesn't identify and display the single product with the highest stock level as required by the business analytics request and demonstrated in the reference code.,None
"Which category has the highest number of discontinued products, and can you provide a bar chart to illustrate the count of discontinued products in each category?","```python
import plotly.express as px

# SQL query provided
sql_query = """"""
SELECT CategoryID, COUNT(*) AS DiscontinuedProducts 
FROM products 
WHERE Discontinued = 1 
GROUP BY CategoryID 
ORDER BY DiscontinuedProducts DESC;
""""""

# Execute SQL query and fetch results in a DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='DiscontinuedProducts', 
             title='Count of Discontinued Products by Category',
             labels={'CategoryID': 'Category ID', 'DiscontinuedProducts': 'Discontinued Products Count'})

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CategoryID, COUNT(*) AS DiscontinuedCount
FROM products
WHERE Discontinued = 1
GROUP BY CategoryID
ORDER BY DiscontinuedCount DESC
""""""

discontinued_counts = execute_sql_query(sql_query)

highest_discontinued_category = discontinued_counts.iloc[0]

fig = px.bar(discontinued_counts, x='CategoryID', y='DiscontinuedCount', 
             title='Count of Discontinued Products by Category',
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Count of Discontinued Products'})

show_to_user(fig)
```","The provided input code uses a similar SQL query to count discontinued products grouped by CategoryID, then orders them in descending order similar to the reference code. It fetches results into a DataFrame and uses Plotly to create a bar chart labeled correctly. Furthermore, it identifies the category with the highest number of discontinued products by accessing the first row of the sorted DataFrame, which is a common method to obtain this information. Overall, the logic and functionality match the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the categories with the count of discontinued products
sql_query = """"""
SELECT CategoryID, COUNT(ProductID) AS DiscontinuedCount 
FROM products 
WHERE Discontinued = 1 
GROUP BY CategoryID 
ORDER BY DiscontinuedCount DESC;
""""""

# Execute the SQL query and get the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Identify the category with the highest number of discontinued products
highest_discontinued_category = df.iloc[0:1]

# Display the result to the user
show_to_user(highest_discontinued_category)

# Create a bar chart using Plotly to illustrate the count of discontinued products in each category
fig = px.bar(df, x='CategoryID', y='DiscontinuedCount', 
             title='Count of Discontinued Products in Each Category', 
             labels={'CategoryID': 'Category ID', 'DiscontinuedCount': 'Discontinued Count'})

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code performs the same logical operations as the reference implementation. It executes a SQL query to fetch the categories and their count of discontinued products, ensuring results are sorted in descending order. The code identifies the category with the highest number of discontinued products and displays this information. It also generates a bar chart using Plotly, just as the reference does, albeit with slightly different parameter labels. Therefore, it adheres to the same logic and fulfills the business analytics request.",both
"What is the total revenue contributed by employees in each region, and can this be represented using a bar chart?","
import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation, replace with actual database interaction
    # Example: Return a DataFrame from SQL query execution
    data = {
        'Region': ['North', 'South', 'East', 'West'],
        'TotalRevenue': [100000, 150000, 120000, 130000]
    }
    return pd.DataFrame(data)

# Function to display data or visualization
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        # Assuming data is a Plotly figure
        data.show()

# SQL query as provided
sql_query = """"""
SELECT Region, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY Region;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='Region', y='TotalRevenue', title='Total Revenue by Region')

# Display the chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.Region, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.Region
""""""

revenue_by_region = execute_sql_query(sql_query)

fig = px.bar(revenue_by_region, x='Region', y='TotalRevenue', title='Total Revenue by Region')
show_to_user(fig)
```","The provided code correctly queries the total revenue per region by summing the product of UnitPrice, Quantity, and discount for each order. It uses the same logic as the reference code by joining employees, orders, and order details tables and grouping the results by region. The revenue is visualized using a Plotly bar chart, which matches the business analytics request and the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total revenue by region
sql_query = """"""
SELECT Region, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN employees ON customers.EmployeeID = employees.EmployeeID 
GROUP BY Region;
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Check if the DataFrame is not empty
if not df.empty:
    # Create a bar chart to visualize the total revenue by region
    fig = px.bar(df, x='Region', y='TotalRevenue', 
                 title='Total Revenue by Region',
                 labels={'TotalRevenue': 'Total Revenue', 'Region': 'Region'})

    # Display the bar chart to the user
    show_to_user(fig)
else:
    # In case of empty DataFrame, display a message
    show_to_user(""No data available to display."")
```","The input code and the reference implementation differ in how they JOIN tables. In the reference code, the revenue calculation is grouped by the 'employees' table, while in the input code, it is grouped by the 'customers' table. This affects which employees contribute to the revenue per region. Therefore, the logic does not align with the reference implementation.",Base
What is the total revenue generated from orders last month? Provide a bar chart showing daily revenue trends.,"```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# SQL query to fetch daily revenue details for the last month
sql_query = """"""
    SELECT 
        DATE(orders.OrderDate) AS OrderDate, 
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Daily_Revenue 
    FROM 
        orders 
    JOIN 
        [Order Details] ON orders.OrderID = [Order Details].OrderID 
    WHERE 
        MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH)
        AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH)
    GROUP BY 
        DATE(orders.OrderDate)
""""""

# Execute the SQL query
df_revenue = execute_sql_query(sql_query)

# Calculate the total revenue
total_revenue = df_revenue['Daily_Revenue'].sum()
print(f""Total Revenue for Last Month: {total_revenue}"")

# Create a bar chart to show daily revenue trends
fig = px.bar(df_revenue, x='OrderDate', y='Daily_Revenue', title='Daily Revenue Trends for Last Month', labels={'OrderDate': 'Date', 'Daily_Revenue': 'Revenue ($)'})

# Use the utility function to display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the first and last day of last month
today = datetime.today()
first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
last_day_last_month = today.replace(day=1) - timedelta(days=1)

# SQL query to get daily revenue for last month
sql_query = f""""""
SELECT 
    OrderDate, 
    SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)) AS DailyRevenue
FROM 
    orders AS O
JOIN 
    [Order Details] AS OD ON O.OrderID = OD.OrderID
WHERE 
    O.OrderDate >= '{first_day_last_month.strftime('%Y-%m-%d')}'
    AND O.OrderDate <= '{last_day_last_month.strftime('%Y-%m-%d')}'
GROUP BY 
    O.OrderDate
ORDER BY 
    O.OrderDate;
""""""

# Execute the query
daily_revenue_df = execute_sql_query(sql_query)

# Calculate total revenue
total_revenue = daily_revenue_df['DailyRevenue'].sum()

# Create a bar chart for daily revenue trends
fig = px.bar(daily_revenue_df, x='OrderDate', y='DailyRevenue', title='Daily Revenue Trends for Last Month')
show_to_user(fig)
```","Both the reference and input code aim to calculate the total revenue for the last month and generate a bar chart to show daily revenue trends. The input code correctly computes the start and end dates of the previous month using Python's datetime module, constructs an SQL query to retrieve daily revenue, and produces a bar chart using Plotly. The logical steps and overall approach align with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT 
    OrderDate, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS DailyRevenue
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    DATE_FORMAT(OrderDate, '%Y-%m') = DATE_FORMAT(CURRENT_DATE - INTERVAL 1 MONTH, '%Y-%m')
GROUP BY 
    OrderDate
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate a bar chart for daily revenue trends
fig = px.bar(df, x='OrderDate', y='DailyRevenue', 
             title='Daily Revenue Trends for Last Month',
             labels={'OrderDate': 'Date', 'DailyRevenue': 'Revenue'})

# Display the bar chart
show_to_user(fig)
```","Both implementations capture the same logic and achieve the same result: calculating total daily revenue for the last month and creating a bar chart for daily trends. Key elements such as the SQL query for summing the revenue, grouping by date, and using a bar chart for visualization are consistent. The variations in date formatting and variable naming are minor and do not impact the correctness.",both
"What is the average order fulfillment time for each product category, and can it be visualized with a bar chart?","import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT 
    categories.CategoryName, 
    AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
JOIN 
    categories ON products.CategoryID = categories.CategoryID 
GROUP BY 
    categories.CategoryName
""""""

# Execute the SQL query and fetch results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryName', y='avg_fulfillment_time',
             title='Average Order Fulfillment Time by Product Category',
             labels={'avg_fulfillment_time': 'Avg Fulfillment Time (Days)', 'CategoryName': 'Product Category'})

# Display the bar chart
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT categories.CategoryName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS average_fulfillment_time
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
GROUP BY categories.CategoryName
""""""

fulfillment_times = execute_sql_query(sql_query)

fig = px.bar(fulfillment_times, x='CategoryName', y='average_fulfillment_time',
             title='Average Order Fulfillment Time by Product Category',
             labels={'average_fulfillment_time': 'Average Fulfillment Time (Days)'})

show_to_user(fig)
```","The input code correctly mirrors the logic and purpose of the reference implementation. It constructs an SQL query to compute the average order fulfillment time per product category, executes the query, and uses Plotly Express to create a bar chart. The differences in variable names (like 'average_fulfillment_time' vs. 'avg_fulfillment_time') and label wording are functionally equivalent and do not affect the outcome or purpose of the analytics request.","```python
import pandas as pd
import plotly.express as px

# Assume this function runs the given SQL query and returns a pandas DataFrame
def run_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation is assumed to be provided.
    pass

def show_to_user(data):
    # Implementation is assumed to be provided.
    pass

# Define the SQL query
sql_query = """"""
    SELECT c.CategoryID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgFulfillmentTime
    FROM products p
    JOIN categories c ON p.CategoryID = c.CategoryID
    JOIN [Order Details] od ON p.ProductID = od.ProductID
    JOIN orders o ON o.OrderID = od.OrderID
    GROUP BY c.CategoryID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = run_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CategoryID', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Product Category',
             labels={'CategoryID': 'Category ID', 'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'})

# Display the bar chart
show_to_user(fig)
```","The input code calculates 'AvgFulfillmentTime' grouped by 'CategoryID', while the reference implementation groups by 'CategoryName'. The input code does not match the business request, which specifies average fulfillment time by product category. Additionally, the labels in the visualization should match 'CategoryName' rather than 'CategoryID' for clarity.",Base
"Which shipping method is used the most frequently, and can a bar chart illustrate the frequency of each method?","
import pandas as pd
import plotly.express as px

# SQL query to get frequency of each shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS UsageCount 
FROM orders 
GROUP BY ShipVia 
ORDER BY UsageCount DESC;
""""""

# Execute the SQL query and get the result as a DataFrame
shipping_data = execute_sql_query(sql_query)

# Determine the most frequently used shipping method
most_frequent_method = shipping_data.iloc[0]

# Create a bar chart to illustrate the frequency of each shipping method
fig = px.bar(
    shipping_data,
    x='ShipVia',
    y='UsageCount',
    title='Frequency of Each Shipping Method',
    labels={'ShipVia': 'Shipping Method', 'UsageCount': 'Usage Count'}
)

# Display the results
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(*) as Frequency
FROM orders
GROUP BY ShipVia
ORDER BY Frequency DESC
""""""

shipping_data = execute_sql_query(sql_query)

most_frequent_shipping = shipping_data.iloc[0]
fig = px.bar(shipping_data, x='ShipVia', y='Frequency', title='Frequency of Shipping Methods', labels={'ShipVia': 'Shipping Method', 'Frequency': 'Number of Orders'})
show_to_user(fig)

most_frequent_shipping
```","The input Python code is functionally equivalent to the reference implementation. Both codes execute an SQL query to count the number of orders for each shipping method, group by 'ShipVia', and order by frequency in descending order. They both determine the most frequently used shipping method using 'iloc[0]'. Additionally, each code creates a bar chart using Plotly with similar parameters to illustrate the frequency of each shipping method and display the results using 'show_to_user'. The minor differences, such as column naming ('Frequency' vs. 'UsageCount'), do not affect the correctness of the solution.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the shipping methods and their count
sql_query = """"""
SELECT o.ShipVia, COUNT(*) AS Frequency 
FROM orders o 
GROUP BY o.ShipVia;
""""""

# Execute the SQL query and get the result in a DataFrame
df_shipping_methods = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the frequency of each shipping method
fig = px.bar(df_shipping_methods, x='ShipVia', y='Frequency', title='Frequency of Shipping Methods')

# Display the bar chart to the user
show_to_user(fig)
```",The input code does not determine the most frequently used shipping method before creating the bar chart. It executes a SQL query and creates a chart but omits ordering by usage count or identifying the most frequent method as specified in the business analytics request and reference implementation.,Base
"What is the monthly inventory turnover ratio, and can we visualize it with a line chart over time for trend analysis?","```python
import pandas as pd
import plotly.express as px

# Function to calculate and visualize monthly inventory turnover ratio
def calculate_inventory_turnover():
    # SQL query to fetch required data
    sql_query = """"""
    SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
           SUM([Order Details].Quantity * [Order Details].UnitPrice) / AVG(products.UnitsInStock) AS InventoryTurnoverRatio 
    FROM [Order Details] 
    JOIN products ON [Order Details].ProductID = products.ProductID 
    GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
    """"""
    
    # Execute the query and get the result as a pandas DataFrame
    df_inventory_turnover = execute_sql_query(sql_query)
    
    # Ensure the result DataFrame is sorted by Month for a proper line chart
    df_inventory_turnover.sort_values(by='Month', inplace=True)
    
    # Create a line chart using Plotly for trend analysis
    fig = px.line(df_inventory_turnover, x='Month', y='InventoryTurnoverRatio', 
                  title='Monthly Inventory Turnover Ratio Over Time', 
                  labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'Month': 'Month'})
    
    # Show the plot to the user
    show_to_user(fig)

# Execute the function
calculate_inventory_turnover()
```","```python
import pandas as pd
import plotly.express as px

# SQL Query to calculate monthly inventory turnover ratio
sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS Month,
    SUM(od.Quantity * od.UnitPrice) AS COGS,
    AVG(p.UnitsInStock) AS AverageInventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS InventoryTurnoverRatio
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    orders ON od.OrderID = orders.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a line chart for inventory turnover ratio over time
fig = px.line(data, x='Month', y='InventoryTurnoverRatio', 
              title='Monthly Inventory Turnover Ratio',
              labels={'InventoryTurnoverRatio': 'Inventory Turnover Ratio', 'Month': 'Month'})

# Show the visualization to the user
show_to_user(fig)
```","The provided code calculates the monthly inventory turnover ratio correctly and visualizes it using a line chart. It uses DATE_TRUNC to format the dates and products JOIN to compute the turnover ratio, which aligns with the logic of the reference code. The calculations for the cost of goods sold (COGS) and average inventory, along with the grouping and ordering by month, are consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str):
    # Placeholder implementation for SQL execution
    # Replace with actual database connection and query execution
    data = {
        ""year_month"": [""2023-01"", ""2023-02"", ""2023-03""],
        ""inventory_turnover_ratio"": [2.5, 2.7, 2.8]
    }
    return pd.DataFrame(data)

# Define the function to show data or visualization
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query provided
sql_query = """"""
SELECT EXTRACT(YEAR_MONTH FROM orders.OrderDate) AS year_month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) /
    AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY EXTRACT(YEAR_MONTH FROM orders.OrderDate);
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the inventory turnover ratio with a line chart
fig = px.line(df, x='year_month', y='inventory_turnover_ratio',
              title='Monthly Inventory Turnover Ratio',
              labels={'year_month': 'Year-Month', 'inventory_turnover_ratio': 'Inventory Turnover Ratio'})

# Show the figure to the user
show_to_user(fig)
```","The input code correctly calculates the monthly inventory turnover ratio using a SQL query, similar to the reference implementation. It performs a JOIN on the necessary tables and groups by month-year for the calculation. The visualization is also created using Plotly to display the turnover ratio over time, matching the concept of the reference code. The minor difference in SQL syntax for date extraction (EXTRACT vs DATE_FORMAT) does not affect the correctness of the logic.",both
"What is the average fulfillment time for orders each month, and can it be visualized in a line graph to show trends over time?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       AVG(DATE_PART('day', ShippedDate - OrderDate)) AS AverageFulfillmentTime 
FROM orders 
GROUP BY DATE_TRUNC('month', OrderDate);
""""""

# Execute the SQL query and load the results into a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for database interaction logic
    pass

# Function to display data or visual results
def show_to_user(data):
    pass

# Execute the query and get the results
df = execute_sql_query(sql_query)

# Plot the results using Plotly
fig = px.line(df, x='Month', y='AverageFulfillmentTime', title='Average Fulfillment Time per Month')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

fulfillment_time_df = execute_sql_query(sql_query)

fig = px.line(fulfillment_time_df, x='Month', y='AverageFulfillmentTime', 
              title='Average Fulfillment Time for Orders Each Month',
              labels={'AverageFulfillmentTime': 'Average Fulfillment Time (Days)', 
                      'Month': 'Month'})
show_to_user(fig)
```","Both the input and reference codes compute the average fulfillment time per month. The main difference lies in the SQL syntax: the reference uses DATE_TRUNC and DATE_PART, while the input uses DATE_FORMAT and DATEDIFF, which are equivalent functions in different SQL dialects. Furthermore, both codes create line graphs to visualize the average fulfillment time each month. Therefore, the input code is consistent with the reference code in terms of logic and outcome.","```python
import pandas as pd
import plotly.express as px

# Function to execute the SQL query and return the results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate SQL query execution
    # The actual implementation would involve database connection and execution
    pass

# Function to display data in a structured format
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# SQL query to get the average fulfillment time for orders
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY DATE_TRUNC('month', OrderDate);
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Ensure the 'Month' column is in datetime format
df['Month'] = pd.to_datetime(df['Month'])

# Create a line graph to visualize average fulfillment time over months
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Average Fulfillment Time per Month')

# Display the line graph to the user
show_to_user(fig)
```","The input code uses `DATEDIFF(ShippedDate, OrderDate)` which may not behave the same as `DATE_PART('day', ShippedDate - OrderDate)` in terms of handling time differences. The logic related to date difference might differ slightly across SQL dialects, specifically the units returned might vary (e.g., days vs. fractional days). Additionally, the input code correctly converts the 'Month' column to a datetime format for plotting, which is a good addition but doesn't affect correctness of the data logic per se. Overall, ensure compatibility in date functions across SQL dialects used.",Base
"Which orders have the highest discount applied, and can we visualize this with a bar chart showing the discount amounts per order?","```python
import plotly.express as px

# Define SQL query
sql_query = ""SELECT OrderID, Discount FROM [Order Details] ORDER BY Discount DESC LIMIT 10;""

# Execute the SQL query and store the result in a pandas DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_df, x='OrderID', y='Discount', title='Top 10 Orders by Discount')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.OrderID, SUM(od.Discount) as TotalDiscount
FROM [Order Details] od
GROUP BY od.OrderID
ORDER BY TotalDiscount DESC
LIMIT 10
""""""

discount_orders = execute_sql_query(sql_query)

fig = px.bar(discount_orders, x='OrderID', y='TotalDiscount', title='Highest Discount Applied per Order', labels={'TotalDiscount': 'Discount Amount'})
show_to_user(fig)
```","The input code calculates the total discount per order by summing the discounts for each OrderID. In contrast, the reference code retrieves orders with the highest individual discount without aggregation. The logic differs as the input code could potentially change the order of the top results due to the summation.","```python
import pandas as pd
import plotly.express as px

# Given SQL Query
sql_query = """"""
SELECT o.OrderID, od.Discount FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
ORDER BY od.Discount DESC;
""""""

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for executing SQL; implementation would connect to database and execute the query
    pass

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Check if the DataFrame is empty or not
if orders_df.empty:
    show_to_user(""No data found for the given query."")
else:
    # Visualization function for creating a bar chart
    def visualize_orders_with_highest_discount(df: pd.DataFrame):
        fig = px.bar(df, x='OrderID', y='Discount', title='Discount Amount per Order', labels={'Discount': 'Discount'})
        show_to_user(fig)

    # Call the visualization function with the query result
    visualize_orders_with_highest_discount(orders_df)
```","The input code does not limit the result to the top 10 highest discounts as the reference code does. It retrieves all orders sorted by discount, which may result in a different dataset and visualization if there are more than 10 orders with discount values.",None
"Which products have a stock level below their reorder level, and can this be visualized in a chart to show product names and stock deficits?","```python
import pandas as pd
import plotly.express as px

# SQL query to find products with stock levels below their reorder level
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query to get the data in a DataFrame
product_data = execute_sql_query(sql_query)

# Calculate stock deficit for visualization
product_data['StockDeficit'] = product_data['ReorderLevel'] - product_data['UnitsInStock']

# Create a bar chart using Plotly to show product names and stock deficits
fig = px.bar(
    product_data,
    x='ProductName',
    y='StockDeficit',
    title='Products with Stock Deficit',
    labels={'StockDeficit': 'Stock Deficit', 'ProductName': 'Product Name'},
    text='StockDeficit'
)

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel
""""""

products_below_reorder = execute_sql_query(sql_query)

products_below_reorder['StockDeficit'] = products_below_reorder['ReorderLevel'] - products_below_reorder['UnitsInStock']

fig = px.bar(products_below_reorder, x='ProductName', y='StockDeficit', title='Products with Stock Levels Below Reorder Level',
             labels={'StockDeficit':'Stock Deficit', 'ProductName':'Product Name'})

show_to_user(fig)
```","The provided code correctly implements the logic specified in the business analytics request and follows the same approach as the reference implementation. It executes a SQL query to retrieve products with stock levels below their reorder levels, calculates the stock deficit, and generates a bar chart using Plotly to visualize the product names and stock deficits. The differences in the code, such as variable naming and slightly different chart title, do not affect the correctness of the solution.","```python
import pandas as pd
import plotly.express as px

# Step 1: SQL Query to fetch products with stock levels below reorder levels
sql_query = ""SELECT ProductName, (ReorderLevel - UnitsInStock) AS StockDeficit "" \
            ""FROM products WHERE UnitsInStock < ReorderLevel;""

# Step 2: Execute the query and fetch the result into a DataFrame
products_df = execute_sql_query(sql_query)

# Step 3: Create a bar chart to visualize product names and their stock deficits
fig = px.bar(products_df, x='ProductName', y='StockDeficit',
             title='Products with Stock Levels Below Reorder Level',
             labels={'ProductName': 'Product Name', 'StockDeficit': 'Stock Deficit'})

# Step 4: Display the chart to the user
show_to_user(fig)
```","The input Python code successfully evaluates which products have stock levels below their reorder level and visualizes this information in a chart. It effectively computes the stock deficit directly in the SQL query, which is a valid approach. The visualization is created using Plotly in both implementations, displaying product names and their stock deficits. The overall logic aligns with the reference implementation.",both
Find products with unusually high discounts applied to them and visualize the results using a bar chart to highlight the extent of the discounts.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find products with unusually high discounts
sql_query = """"""
SELECT p.ProductName, od.Discount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE od.Discount > 0.25;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock data for demonstration purposes
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'Discount': [0.3, 0.4, 0.35]
    }
    df = pd.DataFrame(data)
    return df

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query to get products with high discounts
df_discounts = execute_sql_query(sql_query)

# Visualizing the results using a bar chart
fig = px.bar(df_discounts, x='ProductName', y='Discount', title='Products with High Discounts')

# Show the result using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductName, AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
HAVING AVG(od.Discount) > 0.5
ORDER BY AverageDiscount DESC
""""""

discounted_products_df = execute_sql_query(sql_query)

fig = px.bar(discounted_products_df, 
             x='ProductName', 
             y='AverageDiscount', 
             title='Products with Unusually High Discounts',
             labels={'AverageDiscount': 'Average Discount'})
show_to_user(fig)
```","The input code calculates the average discount using 'AVG(od.Discount) > 0.5' and groups by ProductID and ProductName. The reference code directly filters products with discounts greater than 0.25 without averaging. The input criteria for high discounts (average > 0.5) and approach differ from the reference, which lacks averaging and uses a discount threshold of 0.25.","
```python
import pandas as pd
import plotly.express as px

def perform_analysis():
    # Execute the given SQL query to fetch data
    sql_query = """"""
    SELECT od.ProductID, od.Discount 
    FROM [Order Details] od 
    JOIN (
        SELECT ProductID, AVG(Discount) as AvgDiscount 
        FROM [Order Details] 
        GROUP BY ProductID
    ) avg_od 
    ON od.ProductID = avg_od.ProductID 
    WHERE od.Discount > 2 * avg_od.AvgDiscount;
    """"""
    
    # Fetch the data using a utility function
    df = execute_sql_query(sql_query)
    
    # Check if the DataFrame is not empty
    if df.empty:
        show_to_user(""No products with unusually high discounts were found."")
        return

    # Visualize the results using a bar chart
    fig = px.bar(df, x='ProductID', y='Discount', title='Products with Unusually High Discounts')
    
    # Display the figure using the show_to_user utility function
    show_to_user(fig)

# Call the perform_analysis function
perform_analysis()
```","The input code uses a different logic for identifying high discounts, comparing each discount with double the average discount for that product, as opposed to a fixed threshold of 0.25 in the reference code. Additionally, the input code uses 'ProductID' instead of 'ProductName' for visualization, which may not align with business requirements.",None
Find the supplier that offers the most products at a unit price above $20 and visualize the distribution of products offered per supplier.,"```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = """"""
SELECT suppliers.SupplierID, CompanyName, COUNT(products.ProductID) AS ProductCount 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.UnitPrice > 20 
GROUP BY suppliers.SupplierID, suppliers.CompanyName 
ORDER BY ProductCount DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
result_df = execute_sql_query(sql_query)

# Find the supplier that offers the most products at a unit price above $20
top_supplier = result_df.iloc[0]

# Print the top supplier information
show_to_user(pd.DataFrame([top_supplier]))

# Visualize the distribution of products offered per supplier
fig = px.bar(result_df, x='CompanyName', y='ProductCount', title='Product Distribution per Supplier')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find suppliers and their product counts with unit price above $20
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(p.ProductID) as ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.UnitPrice > 20
GROUP BY s.SupplierID, s.CompanyName
ORDER BY ProductCount DESC
LIMIT 1
""""""

# Execute SQL query
supplier_data = execute_sql_query(sql_query)

# SQL query to get distribution of products offered per supplier
distribution_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) as ProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
""""""

# Execute SQL query
distribution_data = execute_sql_query(distribution_query)

# Visualization of product distribution
fig = px.bar(distribution_data, x='CompanyName', y='ProductCount', title='Product Distribution per Supplier')
show_to_user(fig)
```","The input code uses a SQL query with a LIMIT of 1 to find the supplier by ProductCount, which is correct. However, it runs a separate query for the product distribution that doesn't filter for products with a unit price greater than $20, as required by the business request. The reference code uses one query to sort and then visualizes, ensuring consistency. Therefore, the input code does not adhere to the full request requirements.","```python
import pandas as pd
import plotly.express as px

# Sample utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the SQL query and return a pandas DataFrame.
    pass

def show_to_user(data):
    # This function displays data or visualization results to the user.
    pass

# SQL query to find the supplier with the most products priced above $20
sql_query = """"""
SELECT s.CompanyName, COUNT(p.ProductID) as Above20Count
FROM products p
JOIN suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitPrice > 20
GROUP BY s.CompanyName
ORDER BY Above20Count DESC;
""""""

# Execute the query and get the DataFrame
df_suppliers = execute_sql_query(sql_query)

# Visualizing the distribution of products offered per supplier
fig = px.bar(df_suppliers, x='CompanyName', y='Above20Count',
             title='Number of Products Above $20 per Supplier',
             labels={'CompanyName': 'Supplier', 'Above20Count': 'Number of Products'},
             template='plotly')

# Display the plot
show_to_user(fig)
```","The input Python code does not include logic to identify and display the specific supplier that offers the most products at a unit price above $20. It only visualizes the distribution of products across all suppliers, whereas the reference implementation also identifies and shows the top supplier with the maximum product count.",None
"What is the overall discount given for each product, and can it be visualized in a bar chart for better understanding?","
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulation of SQL execution. This should be replaced with actual implementation.
    # For example using a database connection with pandas.read_sql_query(sql_query, conn)
    pass

# Function to display data to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()
    else:
        raise TypeError(""Data must be a pandas DataFrame or Plotly figure."")

# SQL query to extract overall discount given for each product
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscount 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Execute the SQL query
discount_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the discounts
fig = px.bar(discount_df, x='ProductName', y='TotalDiscount', title='Overall Discount for Each Product')

# Show the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Discount) AS TotalDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY p.ProductID;
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='ProductName', y='TotalDiscount', 
             title='Overall Discount Given for Each Product', 
             labels={'TotalDiscount': 'Total Discount', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The provided code calculates the 'TotalDiscount' as the sum of discounts, which does not reflect the overall discount given across price and quantity. The reference implementation correctly considers 'Discount * Quantity * UnitPrice' for a more accurate discount calculation. Therefore, the provided code does not adhere to the logic of the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the product names and the overall discount for each product
sql_query = """"""
SELECT ProductName, 
       SUM(Discount * Quantity * UnitPrice) AS OverallDiscount 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY ProductName;
""""""

# Function to execute the SQL query and return the results as a pandas DataFrame
def execute_sql_query(sql_query: str):
    # Placeholder implementation: replace with actual database connection code
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'OverallDiscount': [100.5, 200.75, 150.0]
    }
    return pd.DataFrame(data)

# Retrieve the data
discount_data = execute_sql_query(sql_query)

# Visualize the data in a bar chart using Plotly
fig = px.bar(discount_data, x='ProductName', y='OverallDiscount', 
             title='Overall Discount Given for Each Product')

# Show the figure to the user
show_to_user(fig)
```","The input code follows the same logic as the reference code to calculate the overall discount for each product: it executes a SQL query to aggregate discounts multiplied by quantities and unit prices, grouped by product name. The discount data is then visualized using Plotly in a bar chart, which matches the reference implementation's goal of visualizing overall discounts. The placeholder for executing the SQL query is similarly used, and the logic for chart creation and display matches the reference code, achieving the same business objective.",Finetuned
"What is the median fulfillment time for all orders, and can it be visualized in a histogram or box plot to show distribution?","```python
import pandas as pd
import plotly.express as px
from some_module import execute_sql_query, show_to_user

# SQL query to extract order fulfillment times
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime FROM orders;
""""""

# Execute the SQL query and load results into a DataFrame
fulfillment_data = execute_sql_query(sql_query)

# Calculate the median fulfillment time
median_fulfillment_time = fulfillment_data['FulfillmentTime'].median()

# Create a box plot to visualize the distribution of fulfillment times
fig = px.box(fulfillment_data, y='FulfillmentTime', title='Distribution of Fulfillment Times')

# Display the median fulfillment time and visualization
print(f""Median Fulfillment Time: {median_fulfillment_time} days"")
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve fulfillment times
sql_query = """"""
SELECT DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL AND OrderDate IS NOT NULL
""""""
fulfillment_data = execute_sql_query(sql_query)

# Calculate the median fulfillment time
median_fulfillment_time = fulfillment_data['FulfillmentTime'].median()

# Create a histogram to visualize the distribution of fulfillment times
fig = px.histogram(fulfillment_data, x='FulfillmentTime', title='Distribution of Fulfillment Times',
                   labels={'FulfillmentTime': 'Fulfillment Time (days)'}, nbins=30)

show_to_user(fig)
```","The evaluated code correctly calculates the median fulfillment time in a similar manner to the reference implementation. Although it uses a histogram instead of a box plot for visualization, both fulfill the requirement to show the distribution of fulfillment times. The WHERE clause to filter out NULL dates adds robustness without changing the core functionality.","
```python
import pandas as pd
import plotly.express as px

# SQL query to get the fulfillment time data
sql_query = """"""
SELECT 
    DATEDIFF(orders.ShippedDate, orders.OrderDate) AS FulfillmentTime 
FROM orders 
WHERE orders.ShippedDate IS NOT NULL
""""""

# Function to fetch data using the utility function
def fetch_data(sql_query: str) -> pd.DataFrame:
    # Simulate data fetching using the provided SQL query;
    # in reality, this function would execute the SQL and return the DataFrame
    # placeholder implementation
    df = pd.DataFrame({'FulfillmentTime': [10, 15, 20, 25, 30, 5, 35, 40, 12, 19]})
    return df

# Function to display data or visualization
def show_to_user(data):
    # In a real environment, this would handle visualization display
    # Here, we print the data for mockup purposes
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Main function to execute the median fulfillment time and visualization
def analyze_fulfillment_time():
    # Fetch the data
    orders_df = fetch_data(sql_query)

    # Calculate the median fulfillment time
    median_fulfillment_time = orders_df['FulfillmentTime'].median()
    
    # Output the median fulfillment time
    print(f""Median Fulfillment Time: {median_fulfillment_time}"")
    
    # Create a box plot to visualize the distribution of fulfillment times
    fig = px.box(orders_df, y='FulfillmentTime', title='Box Plot of Fulfillment Times')
    
    # Show the box plot to the user
    show_to_user(fig)

# Run the analysis
analyze_fulfillment_time()
```
","The provided code correctly calculates the median fulfillment time using similar logic to the reference code. Both implementations calculate the fulfillment time by finding the date difference between 'ShippedDate' and 'OrderDate'. The code also generates a box plot to visualize the distribution of fulfillment times, adhering to the business analytics request. Although methods for data fetching and visualization differ due to placeholders and utility functions, the core logic and output remain consistent with the reference implementation.",both
Who are the top three employees in terms of sales? Please include a bar chart to illustrate their sales performance.,"```python
import pandas as pd
import plotly.express as px

# Assuming the utility functions are defined elsewhere and available here
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to imitate SQL query execution
    pass

def show_to_user(data):
    # Placeholder function for displaying data
    pass

# SQL Query
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
""""""

# Execute SQL query and obtain results in a DataFrame
top_employees_sales_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    top_employees_sales_df, 
    x='EmployeeID', 
    y='TotalSales', 
    title='Top 3 Employees by Sales',
    labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales'},
    text='TotalSales'
)

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID
ORDER BY TotalSales DESC
LIMIT 3
""""""

top_employees = execute_sql_query(sql_query)

fig = px.bar(top_employees, x='EmployeeName', y='TotalSales', 
             title='Top 3 Employees in Terms of Sales', 
             labels={'TotalSales': 'Sales Amount', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input code adheres to the business analytics request and follows similar logic to the reference implementation. The differences include: incorporating employee names in the SELECT clause for more descriptive labels in the bar chart and slight variations in how plotly express functions are called. However, these do not affect the correctness of the logic or outcome, which is to identify and display the top three employees based on total sales.","
```python
import pandas as pd
import plotly.express as px

# SQL query to get top three employees by sales
sql_query = '''
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID 
ORDER BY TotalSales DESC 
LIMIT 3;
'''

# Execute the SQL query and get the results as a DataFrame
top_employees_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the sales performance of the top three employees
fig = px.bar(
    top_employees_df,
    x='EmployeeID',
    y='TotalSales',
    title='Top 3 Employees by Sales Performance',
    labels={'TotalSales': 'Total Sales', 'EmployeeID': 'Employee ID'}
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly replicates the logic of the reference code. Both execute an SQL query to retrieve the top three employees by sales and create a bar chart with Plotly. The essential components such as the SQL query, DataFrame creation, bar chart plotting, and data presentation meet the requirements of the business analytics request. The minor differences in variable names and string values do not affect the overall correctness or functionality of the code.",both
"What are the total sales generated by country, and can you provide a visualization to compare them?","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by country
sql_query = """"""
SELECT ShipCountry, SUM([Order Details].UnitPrice * [Order Details].Quantity * 
    (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY ShipCountry;
""""""

# Execute the SQL query and get the result as a DataFrame
sales_data_df = execute_sql_query(sql_query)

# Create a bar chart to compare total sales by country
fig = px.bar(sales_data_df, x='ShipCountry', y='TotalSales', title='Total Sales by Country')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.ShipCountry, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.ShipCountry
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ShipCountry', y='TotalSales', 
             title='Total Sales by Country', 
             labels={'ShipCountry': 'Country', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input Python code correctly follows the same logic as the reference implementation. Both query total sales by country using similar SQL queries and group the results by `ShipCountry`. They both use Plotly Express to create and display a bar chart of total sales by country. The input code includes additional labeling for axes, but this does not affect the correctness as per the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales by country
sql_query = """"""
SELECT ShipCountry, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY ShipCountry;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Display the DataFrame
show_to_user(sales_data)

# Create a bar chart to visualize total sales by country
fig = px.bar(sales_data, x='ShipCountry', y='TotalSales', title='Total Sales by Country')

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly implements the business analytics request and aligns with the reference implementation's logic. The SQL query calculates total sales by country by joining the 'orders' and 'Order Details' tables and summing the computed sales figures. Both codes generate a bar chart using Plotly to compare total sales by country, achieving the same analytical goal.",both
"Which products have the highest sales performance this year, and can we include a bar chart to visualize the top-performing products?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch top-performing products based on sales quantity
sql_query = """"""
SELECT p.ProductID, SUM(od.Quantity) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
WHERE YEAR(od.OrderDate) = YEAR(CURDATE()) 
GROUP BY p.ProductID 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the query and store the result in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Visualize the top-performing products with a bar chart using Plotly
fig = px.bar(top_products_df, x='ProductID', y='TotalSales', 
             title='Top 5 Products by Sales for the Current Year', 
             labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales Quantity'},
             text='TotalSales')

# Display the figure using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve sales performance data for this year
sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE YEAR(CURRENT_DATE) = YEAR(od.OrderID)
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC
LIMIT 10;
""""""

# Execute the SQL query
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top-performing products
fig = px.bar(top_products_df, x='ProductName', y='TotalSales', 
             title='Top Performing Products of the Year',
             labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'})

# Show the visual to the user
show_to_user(fig)
```","There are discrepancies in the SQL query logic and result visualization. The input code retrieves the top 10 products versus the reference's top 5. The input also includes 'ProductName' which is not present in the reference implementation and would affect the grouping logic. Additionally, the WHERE clause is incorrect because it checks YEAR(CURRENT_DATE) against YEAR(od.OrderID), while it should check YEAR(od.OrderDate).","```python
import plotly.express as px
import pandas as pd

# Assuming execute_sql_query and show_to_user are already defined

# SQL query to fetch sales performance data for this year
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON o.OrderID = od.OrderID 
WHERE YEAR(o.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY p.ProductName 
ORDER BY TotalSales DESC;
""""""

# Execute the SQL query and get the data
sales_data_df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(
    sales_data_df, 
    x='ProductName', 
    y='TotalSales', 
    title='Top Performing Products This Year',
    labels={'ProductName': 'Product Name', 'TotalSales': 'Total Sales'},
    text='TotalSales'
)

# Improve the layout of the bar chart
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
fig.update_layout(xaxis_tickangle=-45)

# Display the bar chart
show_to_user(fig)
```","The input code calculates total sales by multiplying `UnitPrice`, `Quantity`, and `(1 - Discount)` to derive `TotalSales`, which is not aligned with the reference implementation that simply aggregates sales based on `Quantity`. The reference focuses on quantity sold, whereas the input computes total revenue, which alters the logic and results. Additionally, the input code does not limit the number of top-performing products to display, which diverges from the reference's constraint to show only the top 5 products.",None
"Which employees are responsible for the top 10 largest orders, and can you provide a chart showing the order sizes alongside employee names?","```python
import pandas as pd
import plotly.express as px

# Utility functions as specified
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the actual SQL execution code
    # For now, this function would return a pandas DataFrame after executing the SQL query
    pass

def show_to_user(data):
    # Placeholder for display function
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# SQL query to get the top 10 largest orders
sql_query = """"""
SELECT e.EmployeeID, o.OrderID, 
SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderValue
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, o.OrderID
ORDER BY OrderValue DESC
LIMIT 10;
""""""

# Execute the query and get the results as a DataFrame
top_orders_df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(
    top_orders_df,
    x='EmployeeID',
    y='OrderValue',
    text='OrderID',
    title='Top 10 Largest Orders by Employee',
    labels={'EmployeeID': 'Employee ID', 'OrderValue': 'Order Value', 'OrderID': 'Order ID'},
    hover_data={'OrderID': True}
)

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS OrderSize
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, EmployeeName
ORDER BY 
    OrderSize DESC
LIMIT 10;
""""""

top_orders_df = execute_sql_query(sql_query)

fig = px.bar(top_orders_df, x='EmployeeName', y='OrderSize', title='Top 10 Largest Orders by Employee')
show_to_user(fig)
```","The input code is not correct according to the specified business analytics request and reference implementation. The reference implementation involves listing employees responsible for the top 10 largest orders including their specific OrderID and OrderValue, whereas the provided input code only aggregates the order sizes by employee without specifying individual orders. The bar chart in the input code also does not include OrderID in the hover data, omitting important details required by the request.","import pandas as pd
import plotly.express as px

# Function to execute the SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated data fetching from the database
    # In a real-world scenario, this function would have the necessary logic to connect and execute the query
    # Here, we'll use sample data that reflects the expected structure
    data = {
        'EmployeeID': [101, 102, 103, 104, 105, 106, 107, 108, 109, 110],
        'OrderValue': [3000, 2900, 2800, 2700, 2600, 2500, 2400, 2300, 2200, 2100]
    }
    return pd.DataFrame(data)

# Function to show data or visualization to user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)  # For demonstration purposes only
    else:
        data.show()

# SQL query to retrieve the top 10 largest orders along with the responsible employee
sql_query = """"""
SELECT EmployeeID, OrderValue
FROM orders
ORDER BY OrderValue DESC
LIMIT 10;
""""""

# Fetching data using the SQL query
df = execute_sql_query(sql_query)

# Creating a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='OrderValue', 
             title='Top 10 Largest Orders by Employee',
             labels={'OrderValue': 'Order Size', 'EmployeeID': 'Employee ID'},
             template='plotly')

# Display the chart to the user
show_to_user(fig)","The input code doesn't follow the same logic as the reference implementation. The reference implementation calculates the OrderValue by joining employees, orders, and order details tables and computing the sum of UnitPrice times Quantity times (1 - Discount). However, the input code simply selects EmployeeID and OrderValue from the orders table, without considering the complex calculation involving UnitPrice, Quantity, and Discount. Moreover, the reference implementation retrieves OrderID and includes it in the visualization, which the input code does not do.",None
Find products with a discount greater than 10% and quantity ordered over 100 units. Include a bar chart to visualize the products meeting these criteria.,"
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # Simulated function to execute an SQL query and return a DataFrame
    # Actual implementation would connect to a database and execute the query
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'Discount': [0.15, 0.12, 0.05],
        'Quantity': [150, 200, 90]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# Define the SQL query based on the provided conditions
sql_query = """"""
SELECT p.ProductName 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.Discount > 0.10 AND od.Quantity > 100;
""""""

# Execute query and fetch data
product_data = execute_sql_query(sql_query)

# Filter data based on criteria (though mock data already satisfies it)
filtered_data = product_data[(product_data['Discount'] > 0.10) & (product_data['Quantity'] > 100)]

# Visualizing the results
fig = px.bar(filtered_data, x='ProductName', y='Quantity', title='Products with >10% Discount & >100 Units Ordered')

# Show the bar chart to users
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantityOrdered, 
       AVG(od.Discount) AS AverageDiscount
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
HAVING AVG(od.Discount) > 0.1 AND SUM(od.Quantity) > 100
""""""

products_df = execute_sql_query(sql_query)

fig = px.bar(products_df, x='ProductName', y='TotalQuantityOrdered',
             title='Products with Discount Greater than 10% and Quantity Ordered Over 100',
             labels={'TotalQuantityOrdered': 'Total Quantity Ordered', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code aggregates data by 'ProductID' and 'ProductName', calculating 'TotalQuantityOrdered' and 'AverageDiscount', then applies filtering criteria using HAVING clause on grouped data. The reference code applies filters directly to individual rows without aggregation. The logic differs, as the input code uses averages and sums across orders, which could lead to different results than simply filtering for each order.","
import pandas as pd
import plotly.express as px

def business_analysis():
    # Step 1: Define the SQL query
    sql_query = """"""
    SELECT p.ProductName 
    FROM [Order Details] od 
    JOIN products p ON od.ProductID = p.ProductID 
    WHERE od.Discount > 0.1 AND od.Quantity > 100
    """"""
    
    # Step 2: Execute the SQL query using the utility function to get a pandas DataFrame
    df = execute_sql_query(sql_query)
    
    # Step 3: Count the occurrences of each product for visualization
    product_counts = df['ProductName'].value_counts().reset_index()
    product_counts.columns = ['ProductName', 'Count']
    
    # Step 4: Create a bar chart using Plotly
    fig = px.bar(
        product_counts, 
        x='ProductName', 
        y='Count', 
        title='Products with Discount > 10% and Quantity > 100',
        labels={'ProductName': 'Product Name', 'Count': 'Number of Orders'}
    )
    
    # Step 5: Use the utility function to display the figure
    show_to_user(fig)

# Call the function
business_analysis()
","The input code uses 'value_counts' to count the occurrences of each product, which deviates from the requested analysis focusing on filtering by discount and quantity. The reference code filters directly and visualizes the products based on their quantities, whereas the input counts product occurrences after the SQL result, which may not represent quantities ordered.",None
How many units of each product are currently in stock? Please provide a bar chart to visualize the quantities.,"
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT ProductID, UnitsInStock FROM products;""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities of each product in stock
fig = px.bar(df, x='ProductID', y='UnitsInStock', title='Units in Stock per Product', labels={'ProductID':'Product ID', 'UnitsInStock':'Units in Stock'})

# Display the bar chart using the utility function
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

# SQL query to get units in stock for each product
sql_query = """"""
SELECT ProductName, UnitsInStock 
FROM products
WHERE Discontinued = 0
""""""

# Execute the SQL query
product_stock_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities in stock
fig = px.bar(product_stock_df, x='ProductName', y='UnitsInStock', 
             title='Units of Each Product in Stock', 
             labels={'UnitsInStock': 'Units In Stock', 'ProductName': 'Product Name'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code filters using 'WHERE Discontinued = 0', which is not present in the reference implementation. This inconsistent condition affects whether all products are counted. Additionally, the input uses 'ProductName' instead of 'ProductID' for the x-axis, which changes the label and could lead to duplicate product names being merged, misrepresenting the data.","```python
import plotly.express as px

# SQL query to fetch ProductID and UnitsInStock data
sql_query = ""SELECT ProductID, UnitsInStock FROM products;""

# Execute the SQL query and fetch the result into a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the units in stock for each product
fig = px.bar(products_df, x='ProductID', y='UnitsInStock', title='Units in Stock for Each Product')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly executes the SQL query to fetch 'ProductID' and 'UnitsInStock', uses a similar logic to create a bar chart with Plotly, and displays the chart using the same function. Despite minor differences, such as variable names and title wording, it adheres to the required logic and satisfies the business analytics request.",Finetuned
"What is the total revenue difference between employees with different titles, and can this be visualized using a bar chart for clarity?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.Title, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.Title;
""""""

# Execute the SQL query to get results in a DataFrame
df = execute_sql_query(sql_query)

# Check the DataFrame content
print(df)

# Create a bar chart using Plotly for visualizing revenue differences
fig = px.bar(df, x='Title', y='TotalSales', title='Total Revenue by Employee Title', labels={'TotalSales': 'Total Revenue'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.Title, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.Title
""""""

revenue_by_title = execute_sql_query(sql_query)

fig = px.bar(revenue_by_title, x='Title', y='TotalRevenue', title='Total Revenue by Employee Title', labels={'TotalRevenue': 'Total Revenue', 'Title': 'Employee Title'})
show_to_user(fig)
```","The input code is functionally equivalent to the reference implementation. Both codes execute an SQL query that calculates the total revenue per employee title by joining the 'employees', 'orders', and 'Order Details' tables, summing the calculated revenue. The input code uses aliases for tables, which is a valid syntax change, and the column name 'TotalRevenue' is used instead of 'TotalSales'. The visualization logic using Plotly's bar chart is the same, and the final output displayed to the user is equivalent. Therefore, the input code is correct.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve revenue grouped by employee title
sql_query = """"""
SELECT 
    e.Title, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TitleRevenue 
FROM 
    employees e 
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY 
    e.Title 
ORDER BY 
    TitleRevenue DESC
""""""

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implement the SQL execution logic here
    # Returning an example DataFrame for demonstration purposes
    data = {
        'Title': ['Manager', 'Sales Associate', 'Sales Representative'],
        'TitleRevenue': [100000.0, 80000.0, 60000.0]
    }
    return pd.DataFrame(data)

# Retrieve data using the provided utility function
df_revenue_by_title = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df_revenue_by_title, 
    x='Title', 
    y='TitleRevenue', 
    title='Total Revenue by Employee Title',
    labels={'Title': 'Employee Title', 'TitleRevenue': 'Total Revenue'},
    template='plotly'
)

# Show the plot using the provided utility function
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

show_to_user(fig)
```","The input code correctly implements the SQL query logic to calculate total revenue grouped by employee titles, similarly to the reference code. The use of 'TitleRevenue' instead of 'TotalSales' is semantically equivalent. The use of Plotly to create and display the bar chart aligns with the visual requirement. Ordering by 'TitleRevenue DESC' does not affect correctness but adds sorting feature. Therefore, the input code adheres to the business analytics request and logic of reference implementation.",both
"“Identify orders that were shipped after the required date, and visualize the data using a timeline chart to show the delays.”","```python
import plotly.express as px
import pandas as pd

# Assuming the utility functions are defined elsewhere in the environment
# def execute_sql_query(sql_query: str) -> pd.DataFrame:
#     ...
# 
# def show_to_user(data):
#     ...

# SQL Query to get the relevant data
sql_query = """"""
SELECT OrderID, OrderDate, RequiredDate, ShippedDate
FROM orders
WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query to get the DataFrame
orders_df = execute_sql_query(sql_query)

# Creating a new column to calculate delay in shipment
orders_df['DelayDays'] = (orders_df['ShippedDate'] - orders_df['RequiredDate']).dt.days

# Visualize the delays using a timeline chart
fig = px.timeline(
    orders_df,
    x_start=""RequiredDate"",
    x_end=""ShippedDate"",
    y=""OrderID"",
    title=""Order Shipment Delays"",
    labels={""OrderID"": ""Order ID"", ""RequiredDate"": ""Required Date"", ""ShippedDate"": ""Shipped Date""},
)

# Show the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderID, RequiredDate, ShippedDate
FROM orders
WHERE ShippedDate > RequiredDate
""""""

delayed_orders = execute_sql_query(sql_query)

delayed_orders['Delay'] = (delayed_orders['ShippedDate'] - delayed_orders['RequiredDate']).dt.days
fig = px.scatter(delayed_orders, x='RequiredDate', y='Delay', title='Order Delays', labels={'Delay': 'Days Delayed', 'RequiredDate': 'Required Date'})
show_to_user(fig)
```","The input code uses a scatter plot to visualize delays instead of a timeline chart, as specified in the request and shown in the reference implementation. The business analytics request explicitly requires a timeline chart to visualize shipment delays. Additionally, the reference code includes 'OrderDate' in the SQL query and its plot, which is missing in the input implementation.","```python
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str):
    # Dummy implementation for the purpose of this example
    import pandas as pd
    return pd.DataFrame({
        'OrderID': [1, 2, 3],
        'ShippedDate': ['2021-12-02', '2021-12-03', '2021-12-04'],
        'RequiredDate': ['2021-12-01', '2021-11-30', '2021-12-02']
    })

# Function to display data to the user
def show_to_user(data):
    print(data)  # Replace with actual implementation to show data

# SQL query to find late shipped orders
sql_query = """"""
SELECT OrderID, ShippedDate, RequiredDate 
FROM orders 
WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query
late_orders_df = execute_sql_query(sql_query)

# Convert columns to datetime format
late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])
late_orders_df['RequiredDate'] = pd.to_datetime(late_orders_df['RequiredDate'])

# Calculate delay in days
late_orders_df['DelayDays'] = (late_orders_df['ShippedDate'] - late_orders_df['RequiredDate']).dt.days

# Create a timeline chart using Plotly
fig = px.timeline(
    late_orders_df,
    x_start='RequiredDate',
    x_end='ShippedDate',
    y='OrderID',
    title='Order Shipment Delays',
    labels={'OrderID': 'Order ID', 'ShippedDate': 'Shipped Date'},
    hover_name='OrderID',
    hover_data={'DelayDays': True}
)

# Show the visualization
show_to_user(fig)
```","The provided code correctly follows the business analytics request and aligns with the reference implementation. Both implementations identify orders where the 'ShippedDate' is later than the 'RequiredDate'. The delay is calculated in days using the timedelta between 'ShippedDate' and 'RequiredDate'. The timeline chart is generated using Plotly's 'px.timeline' with orders on the y-axis and time on the x-axis. Additionally, both codes display the plot with a utility function. Minor differences, like handling hover data, do not impact the core logic or output correctness.",Finetuned
How many unique products have been ordered in total? Please include a bar chart showing the count of unique products ordered over time.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get unique products ordered
sql_query = """"""
SELECT DISTINCT [Order Details].ProductID, Orders.OrderDate 
FROM [Order Details]
JOIN Orders ON [Order Details].OrderID = Orders.OrderID;
""""""

# Execute SQL query to get DataFrame
df_unique_products = execute_sql_query(sql_query)

# Parsing OrderDate to datetime and getting the count of unique products by month
df_unique_products['OrderDate'] = pd.to_datetime(df_unique_products['OrderDate'])
df_unique_products['YearMonth'] = df_unique_products['OrderDate'].dt.to_period('M')
df_unique_product_monthly = df_unique_products.groupby('YearMonth').nunique()['ProductID'].reset_index()

# Create bar chart using Plotly
fig = px.bar(df_unique_product_monthly, x='YearMonth', y='ProductID', 
             labels={'ProductID': 'Unique Products Count', 'YearMonth': 'Month'},
             title='Count of Unique Products Ordered Over Time')

# Show bar chart to user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderDate, 
    COUNT(DISTINCT ProductID) AS unique_products_ordered
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
GROUP BY 
    OrderDate
ORDER BY 
    OrderDate
""""""

df = execute_sql_query(sql_query)

total_unique_products = df['unique_products_ordered'].sum()
print(f""Total unique products ordered: {total_unique_products}"")

fig = px.bar(df, x='OrderDate', y='unique_products_ordered', title='Count of Unique Products Ordered Over Time')
show_to_user(fig)
```","The input code computes the sum of unique products per day and displays it as a total, which is not equivalent to counting distinct products over the entire period. The reference implementation counts unique products over all months and uses `nunique()` for aggregation, whereas the input code gets daily counts and aggregates them, leading to potentially duplicated counts in the sum.","```python
import pandas as pd
import plotly.express as px

# SQL query to get unique product count over time
sql_query = '''
SELECT OrderDate, COUNT(DISTINCT ProductID) AS UniqueProductsOrdered
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY OrderDate
ORDER BY OrderDate;
'''

# Execute the SQL query
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='OrderDate', y='UniqueProductsOrdered',
             title='Count of Unique Products Ordered Over Time',
             labels={'OrderDate': 'Order Date', 'UniqueProductsOrdered': 'Unique Products Ordered'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code's SQL aggregates by 'OrderDate', counting unique products per day. The reference code calculates unique products by month, aggregating after filtering. Thus, their logic differs.",None
Determine the total value of discounts applied over all orders and create a chart to visualize the distribution of discounts across different product categories.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the total value of discounts applied over all orders
total_discount_sql = '''
SELECT SUM([Order Details].Quantity * 
           [Order Details].UnitPrice * 
           [Order Details].Discount) AS TotalDiscountValue 
FROM [Order Details];
'''

# SQL query to get the discount distribution by product categories
discount_by_category_sql = '''
SELECT [Products].CategoryID, 
       SUM([Order Details].Quantity * 
           [Order Details].UnitPrice * 
           [Order Details].Discount) AS DiscountValue
FROM [Order Details]
JOIN [Products] ON [Order Details].ProductID = [Products].ProductID
GROUP BY [Products].CategoryID;
'''

# Execute SQL queries
total_discount_value_df = execute_sql_query(total_discount_sql)
discount_by_category_df = execute_sql_query(discount_by_category_sql)

# Show total discount value
show_to_user(total_discount_value_df)

# Create a bar chart for discounts by product categories
fig = px.bar(discount_by_category_df, 
             x='CategoryID', 
             y='DiscountValue', 
             title='Discount Distribution Across Product Categories', 
             labels={'CategoryID': 'Product Category', 'DiscountValue': 'Discount Value'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve order details and products data using SQL
sql_query = """"""
SELECT od.Discount, p.CategoryID 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID
""""""
order_details = execute_sql_query(sql_query)

# Step 2: Calculate total discount value
total_discount_value = order_details['Discount'].sum()

# Step 3: Group by CategoryID to visualize discount distribution
discount_distribution = order_details.groupby('CategoryID', as_index=False)['Discount'].sum()

# Step 4: Create a bar chart to visualize discounts across categories
fig = px.bar(discount_distribution, x='CategoryID', y='Discount', 
             title='Distribution of Discounts Across Product Categories',
             labels={'CategoryID': 'Product Category ID', 'Discount': 'Total Discount Value'})

# Step 5: Show results to user
show_to_user(fig)

# Display total discount value
print(f'Total value of discounts applied over all orders: {total_discount_value}')
```","The input code incorrectly sums up the 'Discount' column directly, but the discount value should be calculated using the formula: Quantity * UnitPrice * Discount. The reference implementation applies this formula to compute the discount value, while the input code only sums the discount percentages from the joined table, leading to an incorrect total discount calculation.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the total discount value
total_discount_sql = ""SELECT SUM(UnitPrice * Quantity * Discount) AS TotalDiscount FROM [Order Details];""

# SQL query to fetch discount and product category data
discount_by_category_sql = """"""
SELECT ProductCategory, (UnitPrice * Quantity * Discount) AS DiscountValue
FROM [Order Details]
JOIN Products ON [Order Details].ProductID = Products.ProductID;
""""""

# Execute SQL query to get the total discount
total_discount_df = execute_sql_query(total_discount_sql)

# Execute SQL query to get discount by product category
discount_by_category_df = execute_sql_query(discount_by_category_sql)

# Display the total discount
show_to_user(total_discount_df)

# Create a chart to visualize the distribution of discounts across product categories
fig = px.bar(discount_by_category_df, 
             x='ProductCategory', 
             y='DiscountValue', 
             title='Distribution of Discounts Across Product Categories')

# Display the chart to the user
show_to_user(fig)
```","The provided code does not correctly aggregate the discount values by product category. In the input code, the `discount_by_category_sql` query calculates the `DiscountValue` per row and does not sum these values by category, leading to incorrect values in the final visualization. Additionally, the input code uses `ProductCategory` which is not present in the reference query; it should use `CategoryID` or consistent naming. The reference code correctly groups by category and sums the discount values.",None
Calculate the average number of orders for each month in 2021 and visualize the results using a line chart.,"```python
import plotly.express as px
import pandas as pd

# SQL query to fetch the required data
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, 
       COUNT(OrderID) AS TotalOrders 
FROM orders 
WHERE OrderDate BETWEEN '2021-01-01' AND '2021-12-31' 
GROUP BY EXTRACT(MONTH FROM OrderDate)
""""""

# Function to execute SQL query, defined elsewhere
data = execute_sql_query(sql_query)

data['AverageOrders'] = data['TotalOrders'] / 12

# Ensure the data is sorted by Month for correct visualization
data.sort_values(by='Month', inplace=True)

# Plot the data using Plotly
fig = px.line(data, x='Month', y='AverageOrders', title='Average Number of Orders Per Month in 2021')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT
    EXTRACT(MONTH FROM OrderDate) AS month,
    COUNT(OrderID) AS total_orders
FROM
    orders
WHERE
    EXTRACT(YEAR FROM OrderDate) = 2021
GROUP BY
    month
ORDER BY
    month;
""""""

orders_per_month = execute_sql_query(sql_query)
orders_per_month['average_orders'] = orders_per_month['total_orders'].mean()
fig = px.line(orders_per_month, x='month', y='total_orders', title='Average Number of Orders per Month in 2021')
show_to_user(fig)
```","The input code calculates the line chart using the total number of orders per month as 'y', rather than the average. The reference code divides 'TotalOrders' by 12 to get the average per month. The 'average_orders' in the input code is calculated incorrectly as a single mean value across all months.","```python
import pandas as pd
import plotly.express as px

# Placeholder function for executing SQL queries and returning a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implement your SQL connection and execution logic here
    # Returning an empty DataFrame for illustrative purposes
    return pd.DataFrame()

# Placeholder function for displaying data to user
def show_to_user(data):
    pass  # Implement your display logic here

# SQL query to get the average number of orders for each month in 2021
sql_query = """"""
SELECT 
    MONTH(orders.OrderDate) AS order_month, 
    COUNT(orders.OrderID) / COUNT(DISTINCT MONTH(orders.OrderDate)) AS avg_orders
FROM 
    orders
WHERE 
    YEAR(orders.OrderDate) = 2021
GROUP BY 
    order_month
""""""

# Execute the SQL query
average_orders_df = execute_sql_query(sql_query)

# Ensure the DataFrame is not empty
if not average_orders_df.empty:
    # Convert order_month to integer for proper handling
    average_orders_df['order_month'] = average_orders_df['order_month'].astype(int)

    # Create a line chart using Plotly
    fig = px.line(
        average_orders_df,
        x='order_month',
        y='avg_orders',
        title='Average Number of Orders per Month in 2021',
        labels={'order_month': 'Month', 'avg_orders': 'Average Number of Orders'}
    )

    # Show the plot to the user
    show_to_user(fig)
else:
    print(""No data fetched from the SQL query."")
```","The input Python code calculates the average number of orders incorrectly. It divides the count of orders by the count of distinct months where orders were present, instead of dividing by 12, which is the number of months in a year. This results in a different logic compared to the reference implementation. The reference code correctly accounts for all months by dividing by 12 to get the monthly average orders.",None
Which customer received the most orders in the last month? Include a bar chart to visualize the top 5 customers by order volume.,"```python
import pandas as pd
import plotly.express as px


def get_top_customers_last_month():
    # SQL query to get all customers and their order counts from the last month
    sql_query = """"""
    SELECT CustomerID, COUNT(OrderID) AS OrderCount 
    FROM orders 
    WHERE YEAR(OrderDate) = YEAR(CURRENT_DATE) 
    AND MONTH(OrderDate) = MONTH(CURRENT_DATE) - 1 
    GROUP BY CustomerID 
    ORDER BY OrderCount DESC 
    LIMIT 5;
    """"""
    
    # Execute the SQL query
    result_df = execute_sql_query(sql_query)

    # Display the data for the customer with the most orders
    most_orders_customer_df = result_df.head(1)
    show_to_user(most_orders_customer_df)

    # Create a bar chart to visualize the top 5 customers by order volume
    fig = px.bar(result_df, x='CustomerID', y='OrderCount', 
                 title='Top 5 Customers by Order Volume Last Month')
    show_to_user(fig)

# Execute the function to get the result
get_top_customers_last_month()
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last month
end_date = datetime.now() - timedelta(days=datetime.now().day)
start_date = end_date.replace(day=1)

# SQL query to get the top 5 customers by order volume in the last month
sql_query = f""""""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE OrderDate >= '{start_date.strftime('%Y-%m-%d')}' AND OrderDate <='{end_date.strftime('%Y-%m-%d')}'
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 5
""""""

# Execute the SQL query
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart for the top customers
fig = px.bar(top_customers_df, x='CustomerID', y='OrderCount', title='Top 5 Customers by Order Volume in Last Month')
show_to_user(fig)
```","The input code does not display the data for the customer with the most orders as required. The reference implementation includes this step with `most_orders_customer_df = result_df.head(1)` and `show_to_user(most_orders_customer_df)`, whereas the input code omits it. Therefore, the input code does not fully adhere to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# assumed utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to execute the given SQL query
    # and return the results as a pandas DataFrame.
    pass

def show_to_user(data):
    # A placeholder for a function that displays data or visualization results
    # This might include print statements for DataFrame or show the plot for figures.
    pass

# SQL query to fetch the top customers by order volume for the last month
sql_query = """"""
SELECT 
    o.CustomerID, 
    COUNT(*) as NumberOfOrders 
FROM 
    orders o 
WHERE 
    o.OrderDate >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' 
    AND o.OrderDate < DATE_TRUNC('month', CURRENT_DATE) 
GROUP BY 
    o.CustomerID 
ORDER BY 
    NumberOfOrders DESC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Show the top 1 customer for confirmation
top_customer_df = df.nlargest(1, 'NumberOfOrders')
show_to_user(top_customer_df)

# Visualize the top 5 customers with a bar chart
top_5_customers_df = df.nlargest(5, 'NumberOfOrders')
fig = px.bar(top_5_customers_df, x='CustomerID', y='NumberOfOrders', 
             title='Top 5 Customers by Order Volume in Last Month',
             labels={'CustomerID': 'Customer ID', 'NumberOfOrders': 'Number of Orders'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly answers the business analytics request by identifying the customer with the most orders in the last month and visualizes the top 5 customers by order volume. The input code matches the logic of the reference implementation by executing a SQL query to retrieve order data for the previous month. It sorts and limits the data similarly, uses Pandas to handle and sort the DataFrame, and visualizes this data using Plotly for a bar chart. The input code, while not identical, adheres to the same logic as the reference code.",Finetuned
"What is the average discount given on products, and how can it be represented visually through a histogram?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT Discount FROM [Order Details];""

# Execute the SQL query using the utility function
data_frame = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = data_frame['Discount'].mean()

# Print the average discount
average_discount_df = pd.DataFrame({'AverageDiscount': [average_discount]})
show_to_user(average_discount_df)

# Create a histogram to visually represent discount distribution
fig = px.histogram(data_frame, x='Discount', title='Histogram of Discounts')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Discount 
FROM [Order Details]
""""""
discount_data = execute_sql_query(sql_query)

average_discount = discount_data['Discount'].mean()

histogram = px.histogram(discount_data, x='Discount', title=f'Histogram of Discounts (Average: {average_discount:.2f})')
show_to_user(histogram)
```","The input Python code successfully calculates the average discount by executing the SQL query to select the 'Discount' column and computes the mean using the 'mean()' function. It also creates a histogram of discounts using 'plotly.express', similar to the reference implementation. The key functionalities of calculating and displaying the average discount and the histogram are preserved, although the histogram title includes the average discount value, which is an enhancement but not a deviation from the requested functionality.","```python
import pandas as pd
import plotly.express as px

# Business Analytic function: Calculate average discount and visualize it

# SQL query to fetch discount data
sql_query = ""SELECT Discount FROM [Order Details];""

# Execute the SQL query using the provided utility function
discount_data_df = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = discount_data_df['Discount'].mean()

# Visualize the discount data using a histogram
fig = px.histogram(discount_data_df, x='Discount', title='Distribution of Discounts')

# Display the average discount and histogram to the user
show_to_user(pd.DataFrame({'Average Discount': [average_discount]}))
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. Both codes execute a SQL query to fetch discount data, calculate the average discount, and then use Plotly to create a histogram. They display the average discount and the histogram to the user. The naming differences in variables and function calls do not affect the core functionality and purpose of the code.",both
"What is the most common shipment method used for orders processed by each employee, and can you provide a bar chart to illustrate the frequency of each method by employee?","```python
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing the SQL query and returning a DataFrame
    # You will implement this according to your SQL connection and execution context
    pass

def show_to_user(data):
    # Placeholder to display data or plotly figure
    # You will implement this with your environment's functionality to display data
    pass

# SQL query to fetch shipment method data by employee
sql_query = """"""
SELECT employees.EmployeeID, ShipVia, COUNT(orders.OrderID) AS NumShipments
FROM employees
JOIN orders ON employees.EmployeeID = orders.EmployeeID
GROUP BY employees.EmployeeID, ShipVia
ORDER BY NumShipments DESC;
""""""

# Execute SQL query and obtain data
df = execute_sql_query(sql_query)

# Determine the most common shipment method per employee
most_common_shipments = df.loc[df.groupby('EmployeeID')['NumShipments'].idxmax()]

# Create a bar chart for frequency of each shipment method by employee
fig = px.bar(
    df,
    x='EmployeeID',
    y='NumShipments',
    color='ShipVia',
    title='Frequency of Shipment Methods by Employee',
    labels={'NumShipments': 'Number of Shipments', 'EmployeeID': 'Employee ID', 'ShipVia': 'Shipment Method'}
)

# Display the results
show_to_user(most_common_shipments)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
       o.ShipVia, 
       COUNT(o.ShipVia) AS MethodCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, o.ShipVia
ORDER BY e.EmployeeID, MethodCount DESC
""""""

df = execute_sql_query(sql_query)

most_common_method = df.loc[df.groupby('EmployeeID')['MethodCount'].idxmax()]

fig = px.bar(most_common_method, 
             x='EmployeeName', 
             y='MethodCount', 
             color='ShipVia', 
             title='Most Common Shipment Method by Employee',
             labels={'ShipVia': 'Shipping Method'},
             text='MethodCount')

show_to_user(fig)
```","The input code produces a bar chart displaying the most common shipment method per employee rather than the frequency of each shipment method by employee. The reference code visualizes all shipment methods, showing frequencies for each by employee. The input also focuses on maximum counts, not overall distributions, and changes ordering, which reduces information fidelity.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the most common shipment method by employee
sql_query = """"""
SELECT employees.EmployeeID, 
       orders.ShipVia, 
       COUNT(orders.OrderID) AS MethodCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID, orders.ShipVia 
ORDER BY employees.EmployeeID, MethodCount DESC;
""""""

# Execute the SQL query to retrieve the data
df = execute_sql_query(sql_query)

# Find the most common shipment method for each employee
most_common_methods = df.loc[df.groupby('EmployeeID')['MethodCount'].idxmax()]

# Create a bar chart to illustrate the frequency of each method by employee
fig = px.bar(
    most_common_methods, 
    x='EmployeeID', 
    y='MethodCount', 
    color='ShipVia', 
    title='Most Common Shipment Method by Employee',
    labels={'EmployeeID': 'Employee ID', 'MethodCount': 'Frequency'}
)

# Display the result using show_to_user utility
show_to_user(fig)
```","The input code does not correctly implement the bar chart as requested in the task description. It generates a bar chart using `most_common_methods`, which only contains the most frequent shipment method for each employee, rather than showing the frequency of each method by employee. It should create the bar chart using the full `df` dataset to visualize all shipment methods, similar to the reference code.",None
Calculate the revenue lost due to discounts for each product and visualize it with a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Utility function stubs (to be provided, as per the environment)
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Executes an SQL query and returns a pandas DataFrame
    # Implementation not shown, as it's assumed to be provided
    pass

def show_to_user(data):
    # Displays data analysis or visualization results
    # Implementation not shown, as it's assumed to be provided
    pass

# SQL query provided in the request
sql_query = """"""
SELECT ProductID, SUM(UnitPrice * Quantity * Discount) AS RevenueLost 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY RevenueLost DESC;
""""""

# Execute SQL query and get the results in a DataFrame
try:
    df = execute_sql_query(sql_query)
except Exception as e:
    raise RuntimeError(f""Error executing SQL query: {e}"")

# Check if DataFrame is empty
if df.empty:
    raise ValueError(""The query returned no results."")

# Validate expected columns
expected_columns = {'ProductID', 'RevenueLost'}
if not expected_columns.issubset(df.columns):
    raise ValueError(f""Missing expected columns in DataFrame. Found columns: {df.columns}"")

# Generate the bar chart using Plotly
fig = px.bar(df, x='ProductID', y='RevenueLost',
             title='Revenue Lost Due to Discounts per Product',
             labels={'ProductID': 'Product ID', 'RevenueLost': 'Revenue Lost'},
             template='plotly_dark')

# Show the resulting bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS RevenueLost
FROM 
    [Order Details] od
GROUP BY 
    od.ProductID
""""""

revenue_lost_df = execute_sql_query(sql_query)

fig = px.bar(revenue_lost_df, x='ProductID', y='RevenueLost', title='Revenue Lost Due to Discounts per Product')
show_to_user(fig)
```",The provided code lacks error handling for potential exceptions when executing the SQL query and missing results or columns validation that are present in the reference implementation. This can lead to runtime issues if the query execution fails or if the query returns unexpected results.,"
```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are pre-defined utility functions

# SQL Query to get product revenue lost due to discounts
sql_query = """"""
SELECT 
    products.ProductName, 
    SUM([Order Details].Quantity * [Order Details].UnitPrice * [Order Details].Discount) AS RevenueLost 
FROM 
    products 
JOIN 
    [Order Details] 
ON 
    products.ProductID = [Order Details].ProductID 
GROUP BY 
    products.ProductName;
""""""

# Execute SQL query to get a DataFrame
df_revenue_lost = execute_sql_query(sql_query)

# Visualize the revenue lost with a bar chart
fig = px.bar(df_revenue_lost, x='ProductName', y='RevenueLost', 
             title='Revenue Lost Due to Discounts per Product', labels={'ProductName': 'Product', 'RevenueLost': 'Revenue Lost'})

# Show the plot to the user
show_to_user(fig)
```
","The input code correctly calculates the revenue lost due to discounts for each product by utilizing a similar SQL query approach. It joins the Products table to get product names instead of using ProductID, which is a valid variation based on available columns. It then groups by ProductName and creates a bar chart to visualize the results, maintaining the same business logic as the reference implementation.",Finetuned
What percentage of orders received a discount? Include a pie chart to illustrate the proportion of discounted versus non-discounted orders.,"```python
import pandas as pd
import plotly.express as px

# Assuming the function execute_sql_query is already defined
# Assuming the function show_to_user is already defined

# SQL query to get the count of discounted orders
discounted_orders_query = """"""
SELECT COUNT(DISTINCT [Order Details].OrderID) as discounted_orders_count
FROM [Order Details]
WHERE Discount > 0
""""""

# SQL query to get the total count of orders
total_orders_query = """"""
SELECT COUNT(DISTINCT OrderID) as total_orders_count
FROM orders
""""""

# Execute SQL queries
discounted_orders_df = execute_sql_query(discounted_orders_query)
total_orders_df = execute_sql_query(total_orders_query)

# Calculate percentage of discounted orders
discounted_orders_count = discounted_orders_df['discounted_orders_count'][0]
total_orders_count = total_orders_df['total_orders_count'][0]
percentage_discounted_orders = (discounted_orders_count / total_orders_count) * 100

# Create a DataFrame for visualization
order_counts = {
    'Order Type': ['Discounted', 'Non-Discounted'],
    'Count': [discounted_orders_count, total_orders_count - discounted_orders_count]
}

order_counts_df = pd.DataFrame(order_counts)

# Create a pie chart
fig = px.pie(order_counts_df, values='Count', names='Order Type',
             title=f'Orders Discounted: {percentage_discounted_orders:.2f}%')

# Show the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(CASE WHEN Discount > 0 THEN 1 END) AS discounted_orders,
    COUNT(*) AS total_orders
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
""""""

data = execute_sql_query(sql_query)
percentage_discounted = (data['discounted_orders'][0] / data['total_orders'][0]) * 100

labels = ['Discounted', 'Non-discounted']
values = [data['discounted_orders'][0], data['total_orders'][0] - data['discounted_orders'][0]]

fig = px.pie(values=values, names=labels, title='Proportion of Discounted vs Non-discounted Orders', 
             labels={'values':'Count', 'names':'Order Type'})
show_to_user(fig)

percentage_discounted
```","The input code correctly computes the percentage of discounted orders and generates a pie chart illustrating the proportion of discounted versus non-discounted orders. The logic aligns with the reference implementation. It counts orders with discounts and total orders, calculates the percentage, and uses Plotly to create the pie chart. Although SQL logic is slightly different due to the JOIN, both implementations achieve the same outcome.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the data
sql_query = """"""
SELECT COUNT(DISTINCT OrderID) * 100.0 / (SELECT COUNT(*) FROM orders) AS PercentageWithDiscount 
FROM [Order Details]
WHERE Discount > 0;
""""""

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Calculate the percentage of orders with no discount
orders_with_discount_percentage = discount_data.iloc[0]['PercentageWithDiscount']
orders_without_discount_percentage = 100 - orders_with_discount_percentage

# Prepare data for the pie chart
pie_data = pd.DataFrame({
    'Category': ['With Discount', 'Without Discount'],
    'Percentage': [orders_with_discount_percentage, orders_without_discount_percentage]
})

# Create a pie chart using Plotly
fig = px.pie(
    pie_data, 
    names='Category', 
    values='Percentage', 
    title='Percentage of Orders with and without Discount'
)

# Display the pie chart
show_to_user(fig)
```","Both implementations correctly calculate the percentage of orders that received a discount. The reference code uses two separate SQL queries to count discounted and total orders, calculates the percentage, and creates a pie chart to display discounted versus non-discounted orders. The input code performs a single SQL query to directly calculate the percentage of orders with a discount and derives the complimentary percentage for non-discounted orders. The input code then visualizes this with a pie chart. Both approaches align logically with the request.",both
What are the top-selling products by each category? Include a bar chart to visualize the top products in each category.,"import pandas as pd
import plotly.express as px

# SQL query as provided
sql_query = '''
SELECT CategoryID, P.ProductName, SUM(OD.Quantity) AS TotalSales 
FROM products P 
JOIN [Order Details] OD ON P.ProductID = OD.ProductID 
GROUP BY CategoryID, P.ProductName 
ORDER BY CategoryID, TotalSales DESC;
'''

# Execute the SQL query and store the result in a DataFrame
data = execute_sql_query(sql_query)

# Extract top-selling products by each category
top_products = data.groupby('CategoryID').apply(
    lambda x: x.nlargest(1, 'TotalSales')
).reset_index(drop=True)

# Create a bar chart visualization for top products in each category
fig = px.bar(
    top_products, 
    x='ProductName', 
    y='TotalSales', 
    color='CategoryID', 
    title='Top-Selling Products by Category', 
    labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'},
    barmode='group'
)

# Display the bar chart
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve top-selling products by category
sql_query = """"""
SELECT 
    p.CategoryID, 
    p.ProductName, 
    SUM(od.Quantity) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.CategoryID, p.ProductName
ORDER BY 
    p.CategoryID, TotalSales DESC
""""""

# Execute the SQL query and store the result in a DataFrame
data = execute_sql_query(sql_query)

# Get the top sales product for each category
top_selling = data.loc[data.groupby('CategoryID')['TotalSales'].idxmax()]

# Create a bar chart to visualize the top products in each category
fig = px.bar(top_selling, x='ProductName', y='TotalSales', color='CategoryID', 
             title='Top-Selling Products by Category', 
             labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'})

# Display the visualization to the user
show_to_user(fig)
```","Both the input and reference implementations execute identical SQL queries to retrieve product sales data. They then process this data to identify the top-selling product within each category using equivalent logic. While one uses `nlargest` and the other uses `idxmax()`, both effectively achieve the same outcome. The visualization details are also consistent between both implementations.","import pandas as pd
import plotly.express as px

# SQL Query as provided
sql_query = """"""
SELECT p.CategoryID, p.ProductName, SUM(od.Quantity) AS TotalSold 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.CategoryID, p.ProductName 
ORDER BY p.CategoryID ASC, TotalSold DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
data = execute_sql_query(sql_query)

# Find the top-selling product in each category
top_products_by_category = data.loc[data.groupby('CategoryID')['TotalSold'].idxmax()]

# Create a bar chart to visualize the top products in each category
fig = px.bar(
    top_products_by_category,
    x='ProductName',
    y='TotalSold',
    color='CategoryID',
    title='Top-Selling Products by Category',
    labels={'ProductName': 'Product Name', 'TotalSold': 'Total Sold'},
    text='TotalSold'
)

# Improve the readability of the chart
fig.update_layout(xaxis_title='Product', yaxis_title='Total Sold', barmode='group')
fig.update_traces(textposition='outside')

# Display the chart to the user
show_to_user(fig)
","The input code correctly fulfills the business analytics request by identifying the top-selling products by each category. The use of 'groupby' and 'idxmax()' achieves the same result as the reference implementation's 'nlargest(1, TotalSales)'. Both methods ensure only the top product per category is selected. The bar chart visualizes the data similarly with appropriate labels and presentation improvements.",both
What is the average unit price of products for each category? Please include a bar chart to visualize the average prices by category.,"```python
import pandas as pd
import plotly.express as px

# Utility functions are assumed to be provided and work as expected.

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be implemented to execute the given SQL query
    # and return a pandas DataFrame based on the results.
    pass

def show_to_user(data):
    # This function should be implemented to display data or visualizations
    # to the user. It should handle both pandas DataFrames and Plotly figures.
    pass

# SQL query to get the average unit price for each category
sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AveragePrice
FROM products p
GROUP BY p.CategoryID;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average prices by category
fig = px.bar(df, x='CategoryID', y='AveragePrice', title='Average Unit Price by Category')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_prices_df = execute_sql_query(sql_query)

fig = px.bar(average_prices_df, x='CategoryID', y='AverageUnitPrice', 
             title='Average Unit Price by Category', 
             labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})
show_to_user(fig)
```","The input Python code is correct as it answers the business analytics request by calculating the average unit price for each product category. Both the reference and input implementations execute a SQL query to compute the average unit price grouped by CategoryID and visualize the result using a Plotly bar chart. While there are minor differences, such as the alias name 'AverageUnitPrice' instead of 'AveragePrice', the code logic aligns with the reference implementation and fulfills the business requirement.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch average unit price by category.
sql_query = """"""
SELECT products.CategoryID, AVG(products.UnitPrice) AS AveragePrice
FROM products
GROUP BY products.CategoryID
ORDER BY AveragePrice ASC;
""""""

# Execute the SQL query and get the result in a DataFrame.
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average prices by category.
fig = px.bar(data, x='CategoryID', y='AveragePrice', 
             title='Average Unit Price by Category',
             labels={'CategoryID': 'Category ID', 'AveragePrice': 'Average Price'},
             template='plotly_bgcolor')

# Display the visualization to the user.
show_to_user(fig)
```","The provided Python code correctly executes the SQL query to calculate the average unit price for each product category and visualizes it using a bar chart. Although it includes additional options such as sorting order and label changes, these do not affect the correctness or requested output functionality. The logic aligns with the reference implementation, as it retrieves the necessary data and creates a bar chart visualization without altering the key requirements.",both
"Which employee has handled the most orders, and can you provide a bar chart to visualize the top employees by the number of orders handled?","```python
import pandas as pd
import plotly.express as px

# Assumed utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation of function that executes the given SQL query 
    # and returns the result as a pandas DataFrame
    pass

def show_to_user(data):
    # Implementation of function to display data analysis or visualization
    pass

# SQL query to find the number of orders per employee
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query and get the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Display the top employee with the most orders handled
if not orders_df.empty:
    top_employee = orders_df.iloc[0]
else:
    top_employee = None

# Create a bar chart for the top employees by number of orders
fig = px.bar(orders_df, 
             x='EmployeeID', 
             y='NumberOfOrders',
             title='Top Employees by Number of Orders Handled',
             labels={'NumberOfOrders': 'Number of Orders', 'EmployeeID': 'Employee ID'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 10;
""""""

top_employees_df = execute_sql_query(sql_query)

fig = px.bar(top_employees_df, x='EmployeeID', y='OrderCount', 
              title='Top Employees by Number of Orders Handled',
              labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'},
              color='OrderCount')

show_to_user(fig)
```","The input code limits the selection to the top 10 employees using 'LIMIT 10;', which is not mentioned in the business analytics request or the reference implementation. The request is to identify the single employee who handled the most orders and provide a bar chart visualizing all top employees, without a specified limit.","```python
import pandas as pd
import plotly.express as px

# Business Analytic Query to fetch employee order counts
business_analytic_sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EmployeeID 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get data
employee_orders_df = execute_sql_query(business_analytic_sql_query)

# Find the employee with the most orders
top_employee = employee_orders_df.head(1)

# Display the top employee
show_to_user(top_employee)

# Create a bar chart for top employees by the number of orders handled
fig = px.bar(employee_orders_df, 
             x='EmployeeID', 
             y='OrderCount', 
             title='Top Employees by Number of Orders Handled',
             labels={'EmployeeID': 'Employee ID', 'OrderCount': 'Number of Orders'},
             template='plotly')

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the logic of counting the number of orders for each employee and sorting the results in descending order. It then identifies the top employee by selecting the first row after sorting, similar to the reference implementation. Additionally, both implementations generate a bar chart visualizing the number of orders handled by each employee using Plotly, and both display the top employee to the user. The differences in variable names and slight changes in detail (such as using `head(1)` versus `iloc[0]`) do not affect the overall correctness in terms of logic and output requirement satisfaction.",Finetuned
Determine monthly trends in inventory turnover ratios and provide a line chart to visualize these trends.,"import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(o.OrderDate, '%Y-%m') as OrderMonth, 
       SUM(od.Quantity * od.UnitPrice) / AVG(p.UnitsInStock) as InventoryTurnover 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY OrderMonth 
ORDER BY OrderMonth;
""""""

# Execute the SQL query and retrieve the results into a DataFrame
df = execute_sql_query(sql_query)

# Convert 'OrderMonth' to datetime for better plotting
df['OrderMonth'] = pd.to_datetime(df['OrderMonth'])

# Create the line chart using Plotly
fig = px.line(df, x='OrderMonth', y='InventoryTurnover', title='Monthly Inventory Turnover Trends', 
              labels={'OrderMonth': 'Order Month', 'InventoryTurnover': 'Inventory Turnover Ratio'})

# Show the resulting plot
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(od.OrderDate, '%Y-%m') AS month,
    SUM(od.Quantity * od.UnitPrice) AS total_sales,
    AVG(p.UnitsInStock) AS avg_inventory,
    SUM(od.Quantity * od.UnitPrice) / NULLIF(AVG(p.UnitsInStock), 0) AS inventory_turnover_ratio
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    month
ORDER BY 
    month
""""""

data = execute_sql_query(sql_query)

fig = px.line(data, x='month', y='inventory_turnover_ratio', title='Monthly Inventory Turnover Ratio')
show_to_user(fig)
```","The input code incorrectly uses 'OrderDate' from the 'Order Details' table instead of from the 'orders' table. As a result, it deviates from the reference implementation, which gets the months from the 'orders' table. Moreover, the input code adds a NULLIF function for division protection, but the business requirement does not specify this necessity. These differences affect the adherence to the business analytics request and the reference logic.","```python
import pandas as pd
import plotly.express as px

# Utility function: Executes SQL query and returns a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function: In actual implementation, this will execute the query
    # and return the result as a pandas DataFrame
    pass

# Utility function: Displays data for analysis
def show_to_user(data):
    # Placeholder function: Would display data or plot a visualization
    pass

# SQL query to fetch monthly inventory turnover values
sql_query = """"""
SELECT
    EXTRACT(YEAR FROM Order_Dates.OrderDate) AS year,
    EXTRACT(MONTH FROM Order_Dates.OrderDate) AS month,
    SUM([Order Details].Quantity * [Order Details].UnitPrice) / 
    AVG(products.UnitsInStock) AS inventory_turnover_ratio
FROM
    [Order Details]
JOIN
    products ON [Order Details].ProductID = products.ProductID
JOIN
    orders ON orders.OrderID = [Order Details].OrderID
JOIN
    dates AS Order_Dates ON orders.OrderDate = Order_Dates.Date
GROUP BY
    year, month
ORDER BY
    year, month;
""""""

# Execute the SQL query
inventory_turnover_df = execute_sql_query(sql_query)

# Convert year and month to a datetime format for proper plotting
inventory_turnover_df['date'] = inventory_turnover_df.apply(
    lambda x: pd.to_datetime(f""{int(x['year'])}-{int(x['month'])}-01""), axis=1
)

# Create a line chart to visualize the inventory turnover ratio
fig = px.line(inventory_turnover_df, x='date', y='inventory_turnover_ratio',
              title='Monthly Inventory Turnover Ratio Trends',
              labels={'inventory_turnover_ratio': 'Inventory Turnover Ratio',
                      'date': 'Month'})

# Display the line chart
show_to_user(fig)
```","Both the input and reference implementations correctly compute the monthly inventory turnover ratios using similar SQL logic, group by year and month, and produce a line chart to visualize trends. Differences in column aliases and SQL functions like DATE_FORMAT versus EXTRACT do not affect the correctness of the solution since they achieve the same outcome.",Finetuned
Calculate the total freight cost for shipments to each country and provide a bar chart to visualize the results.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get the total freight cost per country
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreightCost
FROM orders
GROUP BY ShipCountry;
""""""

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mockup: Replace with actual implementation for executing SQL query
    # For example, using a database connector to fetch results as a DataFrame
    pass

def show_to_user(data):
    # Show data using Plotly for figures or printing DataFrames
    pass

# Execute the SQL query to obtain the results
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipCountry', y='TotalFreightCost',
             title='Total Freight Cost by Country',
             labels={'ShipCountry': 'Country', 'TotalFreightCost': 'Total Freight Cost'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipCountry
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipCountry', y='TotalFreight', 
             title='Total Freight Cost by Country', 
             labels={'TotalFreight': 'Total Freight Cost', 'ShipCountry': 'Country'})

show_to_user(fig)
```","The input code correctly calculates the total freight cost for each country using a SQL query similar to the reference implementation. Both implementations create a bar chart with Plotly using the DataFrame obtained from executing the SQL query. The variable names for total freight cost are slightly different ('TotalFreight' vs. 'TotalFreightCost'), but this does not affect the correctness, as the logic and output are consistent with the business analytics request.","
```
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCountry, SUM(Freight) AS TotalFreight FROM orders GROUP BY ShipCountry;
""""""

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipCountry', y='TotalFreight',
             title='Total Freight Cost by Country',
             labels={'TotalFreight': 'Total Freight Cost', 'ShipCountry': 'Country'},
             template='plotly')

# Display the bar chart to the user
show_to_user(fig)
```","The input code accomplishes the same task as the reference code by executing a SQL query to fetch total freight costs grouped by country. The minor differences, such as column naming ('TotalFreight' vs. 'TotalFreightCost') and the use of a template in the bar chart, do not affect the correctness of the task. Both codes provide a plotly bar chart to visualize the results, adhering to the business analytics request.",both
Which products are sold below their reorder level and need to be prioritized for restocking? Include a bar chart to visualize the products and their current stock levels.,"```python
import pandas as pd
import plotly.express as px

# Sample utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    """"""
    Executes an SQL query and returns a pandas DataFrame.
    This is a placeholder for the function.
    """"""
    # Placeholder function for the purpose of this task
    # In practice, this would connect to the database and return query results
    # Example return format:
    return pd.DataFrame({
        'ProductName': ['Product A', 'Product B', 'Product C'],
        'UnitsInStock': [5, 3, 8],
        'ReorderLevel': [10, 15, 12]
    })

def show_to_user(data):
    """"""
    Displays data or visualizations.
    This is a placeholder for the function.
    """"""
    # In practice, this would handle displaying data or figures to the user
    print(data)

# SQL query from the Business Analytic Request
sql_query = """"""
SELECT ProductName, UnitsInStock, ReorderLevel 
FROM products 
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0 
ORDER BY UnitsInStock, UnitsOnOrder ASC;
""""""

# Perform the SQL query and get the result into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for products that need restocking
fig = px.bar(df, x='ProductName', y='UnitsInStock', 
             title='Products Below Reorder Level',
             labels={'UnitsInStock': 'Current Stock Level'},
             text='UnitsInStock')

# Enhance chart for readability
fig.update_traces(textposition='outside')
fig.update_layout(yaxis_title='Units in Stock',
                  xaxis_title='Product Name')

# Visualize the result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, ReorderLevel
FROM products
WHERE UnitsInStock < ReorderLevel AND Discontinued = 0
""""""

products_below_reorder_level = execute_sql_query(sql_query)

fig = px.bar(products_below_reorder_level, 
              x='ProductName', 
              y='UnitsInStock', 
              title='Products Below Reorder Level',
              labels={'UnitsInStock': 'Current Stock Level', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The evaluated code performs the same logical steps as the reference code. It retrieves the products where UnitsInStock is less than ReorderLevel and not discontinued, making it correct given the business analytics request. The bar chart visualizes the products and their current stock levels, achieving the task's objective.","```python
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would connect to the database, execute the SQL query
    # and return the results as a pandas DataFrame.
    # Placeholder implementation:
    return pd.DataFrame()  # Replace with actual implementation

def show_to_user(data):
    # This function is meant to display data analysis or visualization results.
    # Placeholder implementation: it will just print the type of data.
    print(type(data))  # Replace with actual implementation

# SQL query to find products below their reorder level
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE UnitsInStock < ReorderLevel;""

# Execute the SQL query
products_below_reorder = execute_sql_query(sql_query)

# Check if returned DataFrame is not empty
if not products_below_reorder.empty:
    # Create a bar chart using Plotly
    fig = px.bar(
        products_below_reorder,
        x='ProductName',
        y='UnitsInStock',
        title='Products Below Reorder Level',
        labels={'UnitsInStock': 'Current Stock Level'}
    )

    # Display the bar chart
    show_to_user(fig)
else:
    print(""No products below reorder level."")
```","The input code does not fully adhere to the logic of the reference implementation. Key differences include the omission of filtering out discontinued products (WHERE Discontinued = 0) and missing ordering criteria (ORDER BY UnitsInStock, UnitsOnOrder ASC), which can affect whether the correct products are identified. The input code also doesn't ensure type consistency or enhanced readability features (like text on the bars) present in the reference code.",Base
Which product had the highest increase in sales compared to the previous month? Include a chart to visualize the sales trends.,"
```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch product sales data
sql_query = """"""
SELECT products.ProductName, 
       product_sales.current_month_sales - COALESCE(previous_month_sales.previous_month_sales, 0) AS sales_increase 
FROM (
    SELECT [Order Details].ProductID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS current_month_sales 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE()) 
    AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE()) 
    GROUP BY [Order Details].ProductID
) AS product_sales 
LEFT JOIN (
    SELECT [Order Details].ProductID, 
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS previous_month_sales 
    FROM [Order Details] 
    JOIN orders ON [Order Details].OrderID = orders.OrderID 
    WHERE MONTH(orders.OrderDate) = MONTH(CURRENT_DATE()) - 1 
    AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE()) 
    GROUP BY [Order Details].ProductID
) AS previous_month_sales 
ON product_sales.ProductID = previous_month_sales.ProductID 
JOIN products ON product_sales.ProductID = products.ProductID 
ORDER BY sales_increase DESC 
LIMIT 1
""""""

# Execute the SQL query and retrieve the sales data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy function to simulate database execution
    # This should contain logic to connect to a database and execute the provided SQL query
    return pd.DataFrame({
        ""ProductName"": [""Product A""],
        ""sales_increase"": [1500]
    })

# Fetch the result from the SQL query
result_df = execute_sql_query(sql_query)

# Plot the sales trends with Plotly
def plot_sales_trends(data: pd.DataFrame):
    fig = px.bar(data, x='ProductName', y='sales_increase', title='Product Sales Increase')
    return fig

# Visualize the result
def show_to_user(data):
    # Dummy function to display data or visualization
    # In reality, this would call appropriate Plotly display methods in a Jupyter environment
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Generate the chart
fig = plot_sales_trends(result_df)

# Display the result and visualization
show_to_user(result_df)
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

# Step 1: Retrieve sales data for the last two months
sql_query = """"""
SELECT 
    products.ProductID,
    products.ProductName,
    DATE_TRUNC('month', orders.OrderDate) AS month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID
WHERE 
    orders.OrderDate >= DATEADD(month, -2, GETDATE())
GROUP BY 
    products.ProductID, products.ProductName, DATE_TRUNC('month', orders.OrderDate)
ORDER BY 
    month DESC;
""""""

sales_data = execute_sql_query(sql_query)

# Step 2: Pivot the data to get the current and previous month's sales
sales_pivot = sales_data.pivot(index='ProductID', columns='month', values='total_sales').fillna(0)

# Step 3: Calculate the month-over-month increase for each product
sales_pivot['increase'] = sales_pivot.iloc[:, -1] - sales_pivot.iloc[:, -2]

# Step 4: Find the product with the highest increase in sales
max_increase_product = sales_pivot.loc[sales_pivot['increase'].idxmax()]

# Step 5: Prepare data for visualization
sales_trends = sales_data.groupby(['ProductName', 'month']).sum().reset_index()

# Step 6: Create the sales trend line chart
fig = px.line(sales_trends, x='month', y='total_sales', color='ProductName', 
              title=f'Sales Trend for {max_increase_product[""ProductName""]} (Highest Increase: {max_increase_product[""increase""]})')

show_to_user(fig)
```","The provided code differs from the reference in several ways: 

1. **SQL Query Differences:** The SQL syntax in the provided code is incorrect for the environment. It uses `DATE_TRUNC` and `DATEADD` in a way that may not be compatible with the expected SQL dialect from the original code, which uses `MONTH` and `CURRENT_DATE()`. 

2. **Data Processing:** The reference code calculates sales increase directly within the SQL query, while the provided code fetches raw data for two months and processes it in Python using a pivot table. 

3. **Charting Logic:** The reference code plots a bar chart for the product with the highest increase, whereas the provided code plots a line chart that includes sales trends for all products, using only the identified product's name in the title. 

Overall, the logic for identifying the product with the highest increase is similar but not fully equivalent, and the visualization approach differs from the reference.","```python
import pandas as pd
import plotly.express as px

# SQL query to find the product with the highest increase in sales
sql_query = """"""
SELECT p.ProductID, 
       p.ProductName, 
       (SUM(CASE WHEN EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE) 
                THEN od.Quantity * od.UnitPrice 
                ELSE 0 END) - 
        SUM(CASE WHEN EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE) - 1 
                THEN od.Quantity * od.UnitPrice 
                ELSE 0 END)) AS SalesIncrease 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY p.ProductID, p.ProductName 
ORDER BY SalesIncrease DESC  
LIMIT 1;
""""""

# Executing the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function, replace with actual implementation
    pass

# Visualization function to display sales trends
def plot_sales_trends(df: pd.DataFrame, product_name: str):
    fig = px.line(df, x='Month', y='Sales', title=f'Sales Trend for {product_name}')
    show_to_user(fig)

# Fetching data using the utility function
sales_data = execute_sql_query(sql_query)

# Visualization of sales trends
if not sales_data.empty:
    plot_sales_trends(sales_data, sales_data['ProductName'].iloc[0])
else:
    print(""No sales data found."")

# Display the result
show_to_user(sales_data)
```","The input code differs from the reference code in both the SQL logic and the visualization approach. The SQL query in the input code uses CASE statements instead of separate subqueries to calculate sales increase and lacks logic to handle year transitions, which could lead to incorrect results. Additionally, the visualization logic in the input code attempts to plot a line chart using monthly data which is not prepared or fetched in the SQL query. Unlike the reference code which fetches the maximum 'sales_increase', the input code does not implement cohesive logic to check for sales increase comparison nor execute a fallback for missing data from previous months.",None
List products that have the highest margin by comparing unit price with discounted price and provide a bar chart to visualize the margins across products.,"
```python
import pandas as pd
import plotly.express as px

# Define SQL query to fetch the required data
sql_query = """"""
SELECT 
    ProductName, 
    UnitPrice - MIN(od.UnitPrice * (1 - od.Discount)) AS Margin 
FROM 
    products p 
JOIN 
    [Order Details] od 
ON 
    p.ProductID = od.ProductID 
GROUP BY 
    ProductName 
ORDER BY 
    Margin DESC 
LIMIT 5;
""""""

# Execute the query and obtain the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the margins across products
fig = px.bar(df, x='ProductName', y='Margin', title='Top 5 Products by Margin',
             labels={'ProductName': 'Product Name', 'Margin': 'Margin'})

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    od.UnitPrice AS OriginalPrice,
    od.Discount,
    (od.UnitPrice - od.Discount) AS DiscountedPrice,
    (od.UnitPrice - od.Discount) / od.UnitPrice AS Margin
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
WHERE 
    od.Discount > 0
""""""

data = execute_sql_query(sql_query)
top_margin_products = data.groupby(['ProductID', 'ProductName']).agg({
    'Margin': 'mean'
}).reset_index().sort_values(by='Margin', ascending=False)

fig = px.bar(top_margin_products, 
             x='ProductName', 
             y='Margin', 
             title='Products with Highest Margin', 
             labels={'Margin': 'Average Margin', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code does not adhere to the logic used in the reference implementation. The reference code calculates the margin as the difference between UnitPrice and the minimum discounted price per product. In contrast, the input code calculates the margin as a ratio (per transaction) using (UnitPrice - Discount) / UnitPrice, then averages this ratio across transactions for each product. This changes the logic from subtracting minimal discounted prices to averaging ratios, leading to different results.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the function implementation
    # Replace with actual database query execution code
    pass

# Function to show data analysis or visualization results
def show_to_user(data):
    # This is a placeholder for the function implementation
    # Replace with actual implementation for displaying dataframes or figures
    pass

# Define the SQL query
sql_query = """"""
SELECT 
    od.ProductID, 
    (p.UnitPrice - od.Discount) AS Margin 
FROM 
    [Order Details] od 
JOIN 
    products p ON od.ProductID = p.ProductID 
WHERE 
    od.Discount > 0 
ORDER BY 
    Margin DESC;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the product margins
fig = px.bar(df, x='ProductID', y='Margin', title='Product Margins',
             labels={'ProductID': 'Product ID', 'Margin': 'Margin'})

# Display the bar chart
show_to_user(fig)
```","The provided code and the reference implementation do not match in logic. The reference handles discounts as percentages and calculates the minimum price per product, while the input directly subtracts the discount value from the unit price, which is incorrect. Additionally, the reference groups and limits the result to the top 5 products by margin, which is missing in the input code.",None
"What is the average discount percentage given on orders, and can we visualize the distribution of discount percentages across different orders?","```python
import pandas as pd
import plotly.express as px

# Assuming the utility functions are provided in the environment
def analyze_discount_distribution():
    # SQL query to get average discount percentage
    sql_query_avg = """"""
    SELECT AVG(Discount * 100) AS AverageDiscountPercentage FROM [Order Details];
    """"""

    # SQL query to get individual discounts
    sql_query_dist = """"""
    SELECT Discount * 100 AS DiscountPercentage FROM [Order Details];
    """"""

    # Execute the SQL queries
    avg_discount_df = execute_sql_query(sql_query_avg)
    discount_distribution_df = execute_sql_query(sql_query_dist)

    # Display the average discount percentage
    show_to_user(avg_discount_df)

    # Visualize the distribution of discount percentages
    fig = px.histogram(discount_distribution_df, x='DiscountPercentage',
                       title='Distribution of Discount Percentages',
                       labels={'DiscountPercentage': 'Discount Percentage (%)'},
                       nbins=30)
    
    show_to_user(fig)

# Run the analysis function
analyze_discount_distribution()
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve discount data
sql_query = """"""
SELECT Discount
FROM [Order Details]
""""""

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Calculate the average discount percentage
average_discount = discount_data['Discount'].mean()

# Visualize the distribution of discount percentages
fig = px.histogram(discount_data, x='Discount', title='Distribution of Discount Percentages', 
                   labels={'Discount': 'Discount Percentage'})
show_to_user(fig)

average_discount
```","The input code does not correctly calculate the average discount percentage. The discount value needs to be multiplied by 100 to convert it into a percentage, as done in the reference code. Furthermore, the resulting average should also be formatted clearly and shown to the user. The visualization does not handle the conversion either, as it uses the 'Discount' column directly without multiplying by 100.","
import pandas as pd
import plotly.express as px

# Given SQL query to fetch the data
sql_query = 'SELECT Discount FROM [Order Details];'

# Execute the SQL query to get the DataFrame
discount_df = execute_sql_query(sql_query)

# Calculate the average discount percentage
avg_discount = discount_df['Discount'].mean()

# Prepare the response for the average discount
avg_discount_response = pd.DataFrame({'AverageDiscountPercentage': [avg_discount]})

# Display the average discount percentage
show_to_user(avg_discount_response)

# Visualize the distribution of discount percentages using a histogram
fig = px.histogram(discount_df, x='Discount', title='Distribution of Discount Percentages')
show_to_user(fig)
","The provided code does not multiply the discount values by 100 to convert them into percentages, which is necessary for both calculating the average discount percentage and visualizing the distribution as percentages. This differs from the reference code's logic.",None
"Identify orders with a shipping delay, calculate the average delay days, and create a histogram to visualize the distribution of delay days.","```python
import pandas as pd  
import plotly.express as px  

def execute_sql_query(sql_query: str) -> pd.DataFrame:  
    # This would be the actual implementation to connect and execute SQL.
    # For this example, we'll simulate with a dummy DataFrame.
    return pd.DataFrame({
        'OrderID': [1, 2, 3, 4, 5],
        'DelayDays': [2, 3, 5, 0, 1]
    })

def show_to_user(data):  
    if isinstance(data, pd.DataFrame) or isinstance(data, px.Figure):
        # This would implement the actual visualization code
        print(data)
    else:
        raise ValueError(""Invalid data type. Must be a DataFrame or Plotly figure."")
  
# SQL Query to fetch delay days  
sql_query = """"""  
SELECT o.OrderID, DATEDIFF(o.ShippedDate, o.RequiredDate) AS DelayDays  
FROM orders o  
WHERE o.ShippedDate > o.RequiredDate;  
""""""  

# Execute the SQL query and get the results in a DataFrame  
delays_df = execute_sql_query(sql_query)  

# Calculate the average delay  
average_delay = delays_df['DelayDays'].mean()  
print(f""The average shipping delay is {average_delay:.2f} days."")  

# Create and show a histogram of delay days using Plotly  
fig = px.histogram(delays_df, x='DelayDays', title='Distribution of Shipping Delay Days',  
                   labels={'DelayDays':'Delay Days'}, nbins=10)  

show_to_user(fig)  
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderID, 
    DATEDIFF(ShippedDate, OrderDate) AS DelayDays 
FROM 
    orders 
WHERE 
    ShippedDate > RequiredDate
""""""

delay_data = execute_sql_query(sql_query)

average_delay = delay_data['DelayDays'].mean()

fig = px.histogram(delay_data, x='DelayDays', title='Distribution of Shipping Delay Days')
show_to_user(fig)
```","The input Python code calculates 'DelayDays' using 'OrderDate' instead of 'RequiredDate', differing from the reference Python code, which impacts the logic and correctness of determining shipping delays.","```python
import pandas as pd
import plotly.express as px

# Function to execute an SQL query and return the result as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # This function is assumed to be implemented already
    pass

# Function to display data or visualization results
def show_to_user(data):
    # Placeholder for display logic
    # This function is assumed to handle displaying Pandas DataFrame or Plotly figure
    pass

# SQL query to identify orders with shipping delay and calculate average delay
sql_query = """"""
SELECT
    OrderID,
    DATEDIFF(ShippedDate, RequiredDate) AS DelayDays
FROM
    orders
WHERE
    ShippedDate > RequiredDate;
""""""

# Execute the SQL query to fetch data
orders_with_delay = execute_sql_query(sql_query)

# Calculate the average delay in days
average_delay = orders_with_delay['DelayDays'].mean()

# Show the average delay to the user
show_to_user(pd.DataFrame({'AvgDelayDays': [average_delay]}))

# Create a histogram using Plotly to visualize the distribution of delay days
fig = px.histogram(
    orders_with_delay, 
    x='DelayDays', 
    title='Distribution of Order Delay Days',
    labels={'DelayDays': 'Delay (Days)'},
    nbins=20
)

# Show the histogram to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to identify orders with shipping delays using similar logic to the reference implementation. It calculates the average delay days and displays it. Additionally, it creates a histogram using Plotly to visualize the distribution of delay days, adhering to the business request. The differences, such as using a different number of bins in the histogram and displaying average delay as a DataFrame, do not affect the correctness of the logic as per the request.",Finetuned
"What is the total value of all orders placed by customers in the USA, and can you provide a bar chart showing the monthly totals?","```python
import pandas as pd
import plotly.express as px

# Function to calculate the total value of all orders placed by customers in the USA
def calculate_total_order_value():
    sql_query = """"""
    SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_value,
           DATE_FORMAT(orders.OrderDate, '%Y-%m') AS order_month
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    JOIN customers ON orders.CustomerID = customers.CustomerID
    WHERE customers.Country = 'USA'
    GROUP BY order_month
    ORDER BY order_month
    """"""
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Create a bar chart showing the monthly total order values
    fig = px.bar(df, x=""order_month"", y=""total_value"", title=""Monthly Total Order Value by Customers in the USA"")
    
    # Display the figure
    show_to_user(fig)

# Execute the function
calculate_total_order_value()
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get monthly order totals for customers in the USA
sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS order_month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN 
    customers ON orders.CustomerID = customers.CustomerID 
WHERE 
    customers.Country = 'USA' 
GROUP BY 
    order_month 
ORDER BY 
    order_month;
""""""

monthly_totals_df = execute_sql_query(sql_query)

total_sales_us = monthly_totals_df['total_sales'].sum()

# Create a bar chart for monthly totals
fig = px.bar(monthly_totals_df, x='order_month', y='total_sales', 
             title='Monthly Total Sales for Customers in the USA', 
             labels={'order_month': 'Order Month', 'total_sales': 'Total Sales'})

show_to_user(fig)

total_sales_us
```","The input code correctly implements the business analytics request. Both the reference and input code calculate the total sales from orders by customers in the USA and generate a bar chart showing monthly totals. The logic for calculating total sales and grouping by month is equivalent in both implementations, despite minor differences such as using 'DATE_TRUNC' instead of 'DATE_FORMAT'. Additionally, the input code computes the overall total sales, which is an added step not specified as incorrect. Overall, both codes fulfill the requirements of the request.","
import pandas as pd
import plotly.express as px

# Define the SQL query to get monthly order totals for the USA
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalValue
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
WHERE 
    customers.Country = 'USA'
GROUP BY 
    DATE_TRUNC('month', OrderDate)
""""""

# Execute the SQL query and get the result as a DataFrame
monthly_totals_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(monthly_totals_df, x='Month', y='TotalValue', title='Monthly Order Value for Customers in the USA')

# Show the bar chart to the user
show_to_user(fig)
","The input code generates the total value of all orders placed by customers in the USA, grouped by month, using a SQL query similar to the reference implementation. It uses 'DATE_TRUNC' instead of 'DATE_FORMAT', which is appropriate for different SQL dialects, but functionally equivalent. Both codes calculate monthly order totals and generate a bar chart with Plotly, satisfying the business analytics request.",both
Calculate the reorder frequency for each product and create a bar chart to visually compare the frequencies.,"```python
# Import necessary libraries
import plotly.express as px
import pandas as pd

# SQL query
sql_query = """"""
SELECT p.ProductID, p.ProductName, COUNT(*) AS ReorderCount 
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
WHERE od.Quantity >= p.ReorderLevel
GROUP BY p.ProductID, p.ProductName
ORDER BY ReorderCount DESC;
""""""

# Execute SQL query and get data as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for example; Replace with actual SQL execution
    # This function is supposed to interact with your database
    return pd.DataFrame({
        ""ProductID"": [1, 2, 3],
        ""ProductName"": [""Product A"", ""Product B"", ""Product C""],
        ""ReorderCount"": [10, 15, 5]
    })

def show_to_user(data):
    # Dummy implementation for displaying; Replace with actual show code
    print(data)

# Fetch data using the utility function
reorder_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    reorder_data,
    x='ProductName',
    y='ReorderCount',
    title='Reorder Frequency of Products',
    labels={'ReorderCount': 'Reorder Frequency', 'ProductName': 'Product Name'}
)

# Show the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    COUNT(o.OrderID) AS ReorderFrequency
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    ReorderFrequency DESC
""""""

reorder_frequencies = execute_sql_query(sql_query)

fig = px.bar(reorder_frequencies, x='ProductName', y='ReorderFrequency', 
             title='Reorder Frequency of Products', 
             labels={'ReorderFrequency': 'Frequency', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code does not correctly calculate reorder frequency. It lacks a filter for orders where the quantity is greater than or equal to the reorder level, which is present in the reference code. Therefore, it doesn't correctly implement the logic of determining when a reorder should happen.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the reorder frequency
sql_query = """"""
SELECT ProductID, COUNT(OrderID) AS ReorderFrequency 
FROM [Order Details] 
WHERE Quantity < ReorderLevel 
GROUP BY ProductID;
""""""

# Execute the SQL query and get the results in a DataFrame
reorder_data = execute_sql_query(sql_query)

# Create a bar chart to compare the reorder frequencies for each product
fig = px.bar(reorder_data, x='ProductID', y='ReorderFrequency', 
             title='Reorder Frequency for Each Product',
             labels={'ProductID': 'Product ID', 'ReorderFrequency': 'Reorder Frequency'})

# Display the bar chart
show_to_user(fig)
```","The input code calculates 'ReorderFrequency' as the count of orders where 'Quantity' is less than 'ReorderLevel', which is not the same logic as the reference code. The reference code calculates 'ReorderCount' for instances where 'Quantity' is greater than or equal to the 'ReorderLevel'. Additionally, the input code does not join with the 'products' table to get 'ProductName', which is necessary for creating a comparable product-based bar chart as in the reference implementation.",None
"Which employees are handling the most territories, and can this be visualized in a bar chart for clarity?","
import pandas as pd
import plotly.express as px

# Define SQL Query
sql_query = """"""
SELECT employees.EmployeeID, COUNT(employeeTerritories.TerritoryID) AS territory_count
FROM employeeTerritories
JOIN employees ON employeeTerritories.EmployeeID = employees.EmployeeID
GROUP BY employees.EmployeeID
ORDER BY territory_count DESC
""""""

# Execute the SQL query to retrieve data
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize employees handling territories
fig = px.bar(df, x='EmployeeID', y='territory_count',
             title='Number of Territories Handled by Each Employee',
             labels={'EmployeeID': 'Employee ID', 'territory_count': 'Territory Count'})

# Display the result to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       COUNT(et.TerritoryID) AS TerritoryCount
FROM employees e
JOIN employeeTerritories et ON e.EmployeeID = et.EmployeeID
GROUP BY e.EmployeeID
ORDER BY TerritoryCount DESC
""""""

territories_data = execute_sql_query(sql_query)

fig = px.bar(territories_data, 
             x='EmployeeName', 
             y='TerritoryCount', 
             title='Employees Handling Territories', 
             labels={'TerritoryCount': 'Number of Territories', 'EmployeeName': 'Employees'},
             color='TerritoryCount', 
             text='TerritoryCount')

show_to_user(fig)
```","The input Python code correctly implements the business analytics request by retrieving employees with the count of territories they handle and visualizing it in a bar chart. It uses SQL to count the territories for each employee, sorts the employees by the count in descending order, and visualizes it using Plotly. Additionally, the input code includes the employee names for better clarity in the visualization, which enhances the presentation. The logic aligns with the reference implementation, which also groups, counts, and orders employees by territories, although with minor differences such as SQL column selection and display in the chart. Therefore, the input code is considered correct.","
```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get employees handling multiple territories
sql_query = """"""
SELECT e.EmployeeID, COUNT(DISTINCT e.TerritoryID) AS TerritoriesCount 
FROM employees e 
GROUP BY e.EmployeeID 
ORDER BY TerritoriesCount DESC;
""""""

# Execute the SQL query using the utility function provided
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of territories each employee handles
fig = px.bar(
    df, 
    x='EmployeeID', 
    y='TerritoriesCount', 
    title='Number of Territories Handled by Employees',
    labels={'TerritoriesCount': 'Number of Territories', 'EmployeeID': 'Employee ID'},
    template='plotly'
)

# Display the bar chart to the user
show_to_user(fig)
```
","The input code is not correct because it fails to join the 'employees' and 'employeeTerritories' tables, which is necessary for counting territories for each employee. The reference implementation joins these tables to get the correct territory count per employee, while the input code attempts to count territories directly from the 'employees' table with a DISTINCT clause, which is incorrect as it doesn't reference a 'TerritoryID' field within the 'employees' table.",Base
Which products have a reorder level that is less than the average reorder level? Please include a bar chart to display the products and their reorder levels compared to the average.,"```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution code
    # Simulating the return of a products DataFrame
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C', 'Product D'],
        'ReorderLevel': [10, 20, 5, 15]
    }
    return pd.DataFrame(data)

# SQL query to fetch product names and reorder levels
query_avg_reorder = """"""
SELECT ProductName, ReorderLevel 
FROM products 
WHERE ReorderLevel < (SELECT AVG(ReorderLevel) FROM products);
""""""

# Execute the SQL query
df_products_below_avg = execute_sql_query(query_avg_reorder)

# Calculate average reorder level from the entire dataset
query_all = ""SELECT ProductName, ReorderLevel FROM products""
df_all_products = execute_sql_query(query_all)
average_reorder_level = df_all_products['ReorderLevel'].mean()

# Plotting the bar chart using Plotly
fig = px.bar(
    df_products_below_avg,
    x='ProductName',
    y='ReorderLevel',
    title='Products with Reorder Level Below Average',
    labels={'ReorderLevel': 'Reorder Level'},
    text='ReorderLevel'
)

# Add a line for the average reorder level
fig.add_hline(y=average_reorder_level, line_dash=""dash"", 
              annotation_text=""Average Reorder Level"", 
              annotation_position=""top left"")

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, ReorderLevel 
FROM products
""""""

products_df = execute_sql_query(sql_query)

average_reorder_level = products_df['ReorderLevel'].mean()

filtered_products = products_df[products_df['ReorderLevel'] < average_reorder_level]

fig = px.bar(filtered_products, x='ProductName', y='ReorderLevel', 
             title='Products with Reorder Level Less Than Average',
             labels={'ReorderLevel': 'Reorder Level', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code calculates which products have reorder levels below the average correctly but fails to include the average reorder level as a line in the bar chart. This aspect does not fully adhere to the request and deviates from the reference implementation, which visualizes products with reorder levels below average and includes a horizontal line for the average reorder level. The lack of this visual component makes the input code incorrect based on the given criteria.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to execute
sql_query = """"""
SELECT p.ProductName, p.ReorderLevel 
FROM products p 
WHERE p.ReorderLevel < (SELECT AVG(ReorderLevel) FROM products);
""""""

# Utility function to execute SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str):
    # This is a placeholder function, assuming real implementation exists
    return pd.read_sql_query(sql_query, con='your_database_connection')

# Retrieve the products with reorder level less than average
products_df = execute_sql_query(sql_query)

# Calculate the average reorder level for additional information
avg_reorder_level_query = ""SELECT AVG(ReorderLevel) AS AvgReorderLevel FROM products;""
avg_reorder_level_df = execute_sql_query(avg_reorder_level_query)
average_reorder_level = avg_reorder_level_df['AvgReorderLevel'].iloc[0]

# Create a bar chart to visualize products and their reorder levels
fig = px.bar(products_df, x='ProductName', y='ReorderLevel',
             title='Products with Reorder Level Less Than Average',
             labels={'ProductName': 'Product Name', 'ReorderLevel': 'Reorder Level'},
             text='ReorderLevel')  # Adding text for better visualization
             
# Display the bar chart to the user
show_to_user(fig)
```",The input code creates a bar chart of products with reorder levels below the average but does not include the horizontal line for the average reorder level as in the reference implementation. This omission means it does not fully meet the business analytics request as per the reference logic.,None
"Which product has the highest sales quantity in the last month, and can you provide a bar chart to visualize the comparison among products?","
```python
import pandas as pd
import plotly.express as px

# Given utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would connect to a database and execute the SQL query.
    # Here we assume it returns a pandas DataFrame with the result set.
    pass

def show_to_user(data):
    # This function takes either a DataFrame or a Plotly figure.
    # It displays or prints the result to the user.
    pass

# SQL query to get product sales quantity for the last month
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS total_quantity 
FROM [Order Details] od 
JOIN orders o ON od.OrderID = o.OrderID 
JOIN products p ON od.ProductID = p.ProductID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 
AND o.OrderDate < CURDATE() 
GROUP BY p.ProductName 
ORDER BY total_quantity DESC
""""""

# Execute SQL query
product_sales_df = execute_sql_query(sql_query)

# Create a bar chart to compare sales quantity among products
fig = px.bar(product_sales_df, x='ProductName', y='total_quantity',
             title='Product Sales Quantity in the Last Month',
             labels={'total_quantity': 'Total Quantity Sold'},
             text='total_quantity')

# Show the figure to the user
show_to_user(fig)

# Find the product with the highest sales quantity
if not product_sales_df.empty:
    top_product = product_sales_df.iloc[0]
    show_to_user(pd.DataFrame([top_product]))
```
","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

last_month_start = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1)
last_month_end = last_month_start.replace(day=1) + timedelta(days=31)

sql_query = f""""""
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= '{last_month_start.date()}' 
AND orders.OrderDate < '{last_month_end.date()}'
GROUP BY products.ProductName
""""""

product_sales = execute_sql_query(sql_query)
highest_sales_product = product_sales.loc[product_sales['total_quantity'].idxmax()]

fig = px.bar(product_sales, x='ProductName', y='total_quantity', title='Product Sales Quantity Comparison')
show_to_user(fig)

highest_sales_product
```","The input code calculates the start and end of the last month incorrectly. It currently adds 31 days to get the end of the month, which may not work correctly for months with less than 31 days. This deviates from the logic in the reference implementation, which uses interval-based date calculations to correctly capture the last month. Additionally, there is no handling for the case when 'product_sales' might be empty before finding 'highest_sales_product'.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
WHERE OrderDate BETWEEN DATEADD(MONTH, -1, CURRENT_DATE) AND CURRENT_DATE 
GROUP BY ProductID 
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query
product_sales_df = execute_sql_query(sql_query)

# Determine the product with the highest sales quantity
highest_sales_product = product_sales_df.iloc[0]

# Create a bar chart to visualize the sales quantities among products
fig = px.bar(product_sales_df, x='ProductID', y='TotalQuantity', 
             title='Sales Quantity by Product for the Last Month',
             labels={'TotalQuantity': 'Total Quantity', 'ProductID': 'Product ID'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code is not correct for several reasons: 1) It uses 'ProductID' instead of 'ProductName' in both the query and the visualization, while the reference implementation requires 'ProductName' for clarity in presentation. 2) The SQL date calculation differs; the input code uses 'DATEADD' and 'CURRENT_DATE', which may not work if the database doesn't support this syntax; whereas the reference uses 'DATE_SUB' and 'CURDATE()'. 3) The SQL query in the input code doesn't join with the 'products' table to get the 'ProductName', which is essential for identifying the products in the visualization and output. The reference code correctly includes a JOIN to get the needed product details.",None
"Which product has the highest reorder level, and can the data be represented in a bar chart to compare reorder levels across products?","
import plotly.express as px

# Define the SQL queries
sql_query_highest_reorder = ""SELECT ProductName, ReorderLevel FROM products ORDER BY ReorderLevel DESC LIMIT 1;""
sql_query_all_reorders = ""SELECT ProductName, ReorderLevel FROM products ORDER BY ReorderLevel DESC;""

# Execute the SQL queries
highest_reorder_df = execute_sql_query(sql_query_highest_reorder)
all_reorders_df = execute_sql_query(sql_query_all_reorders)

# Display the product with the highest reorder level
show_to_user(highest_reorder_df)

# Generate a bar chart for reorder levels across all products
fig = px.bar(all_reorders_df, x='ProductName', y='ReorderLevel', title='Reorder Levels Across Products')

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, ReorderLevel
FROM products
WHERE Discontinued = 0
ORDER BY ReorderLevel DESC
""""""

products_df = execute_sql_query(sql_query)

highest_reorder_product = products_df.iloc[0]

fig = px.bar(products_df, x='ProductName', y='ReorderLevel', title='Reorder Levels Across Products')
show_to_user(fig)

highest_reorder_product
```","The input code differs from the reference code as it includes a WHERE clause filtering out discontinued products, which alters the logic of determining the highest reorder level. The reference code uses a broader query to find the product with the highest reorder level and does not filter out any products. Additionally, the input code presents the highest reorder level product as a raw output instead of displaying it appropriately, as evidenced in the reference.","```python
import plotly.express as px

# SQL query to find the product with the highest reorder level
sql_query = """"""
SELECT ProductName, ReorderLevel FROM products ORDER BY ReorderLevel DESC LIMIT 1;
""""""

# Execute the SQL query
product_df = execute_sql_query(sql_query)

# Display the product with the highest reorder level
show_to_user(product_df)

# SQL query to get all products and their reorder levels
all_products_query = """"""
SELECT ProductName, ReorderLevel FROM products;
""""""

# Execute the SQL query to get all products and their reorder levels
products_df = execute_sql_query(all_products_query)

# Create a bar chart to compare reorder levels across products
fig = px.bar(products_df, x='ProductName', y='ReorderLevel', 
             title='Reorder Levels Across Products', 
             labels={'ProductName': 'Product Name', 'ReorderLevel': 'Reorder Level'})

# Display the bar chart
show_to_user(fig)
```","The input code fetches and displays the product with the highest reorder level correctly, as per the request. However, for the bar chart, it retrieves all products' reorder levels without ordering them by `ReorderLevel`. The reference code orders products by their reorder levels before visualization, which wasn't done in the input code. Thus, it doesn't fully adhere to the logic of the reference implementation.",None
"What are the top 5 products with the highest discount given, and can this be represented in a bar chart for clarity?","```python
import plotly.express as px
import pandas as pd

# SQL Query provided
sql_query = ""SELECT ProductID, Discount FROM [Order Details] ORDER BY Discount DESC LIMIT 5;""

# Execute the SQL query and obtain results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='Discount', title='Top 5 Products with Highest Discounts')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    [Order Details].ProductID,
    SUM([Order Details].Discount) AS TotalDiscount
FROM 
    [Order Details]
GROUP BY 
    [Order Details].ProductID
ORDER BY 
    TotalDiscount DESC
LIMIT 5;
""""""

top_discount_products = execute_sql_query(sql_query)

fig = px.bar(top_discount_products, 
             x='ProductID', 
             y='TotalDiscount', 
             title='Top 5 Products with the Highest Discount',
             labels={'ProductID': 'Product ID', 'TotalDiscount': 'Total Discount'})

show_to_user(fig)
```","The input code calculates the total discount per product by summing the discounts and groups them, which is different from the reference code. The reference code directly fetches individual discount values ordered by discount descending and limits to the top 5. The logic is not equivalent since it uses aggregation in the input code.","import pandas as pd
import plotly.express as px

# Assuming the placeholder functions perform as described
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should interface with the database engine to execute the query
    # and return the results as a Pandas DataFrame.
    pass

def show_to_user(data):
    # This function is responsible for displaying data to the user.
    pass

# SQL query to retrieve the top 5 products with the highest average discount
sql_query = """"""
SELECT products.ProductName, AVG([Order Details].Discount) AS AverageDiscount
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductName
ORDER BY AverageDiscount DESC
LIMIT 5
""""""

# Execute the SQL query and get the results in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to represent the top 5 products with the highest discount
fig = px.bar(top_products_df, x='ProductName', y='AverageDiscount',
             title='Top 5 Products with Highest Average Discount',
             labels={'ProductName': 'Product Name', 'AverageDiscount': 'Average Discount'})

# Show the bar chart to the user
show_to_user(fig)
","The input code calculates the top 5 products based on the highest average discount by joining the 'Order Details' with 'products' and using aggregation, while the reference code selects the top 5 products based solely on the maximum discount from 'Order Details' without grouping. Thus, the logic of the input code does not match the reference implementation.",None
What is the average unit price of products by category? Please provide a bar chart to visualize the results.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get average unit price by category
sql_query = """"""
SELECT CategoryID, AVG(UnitPrice) AS AveragePrice FROM products GROUP BY CategoryID;
""""""

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average unit price by category
fig = px.bar(data, x='CategoryID', y='AveragePrice', 
             title='Average Unit Price by Category',
             labels={'CategoryID': 'Category ID', 'AveragePrice': 'Average Price'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, AVG(p.UnitPrice) AS AverageUnitPrice
FROM products p
GROUP BY p.CategoryID
""""""

average_prices = execute_sql_query(sql_query)

fig = px.bar(average_prices, x='CategoryID', y='AverageUnitPrice', title='Average Unit Price by Category', labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'})
show_to_user(fig)
```","The input code is correct because it follows the same logic as the reference implementation. Both codes execute a SQL query to calculate the average unit price by category and create a bar chart to visualize the results. The only differences are minor, such as the variable names used for the average price, but they do not affect the correctness of the implementation according to the business analytics request.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query to get average unit price by category
sql_query = """"""
SELECT products.CategoryID, AVG(products.UnitPrice) AS AverageUnitPrice 
FROM products 
GROUP BY products.CategoryID;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to visualize average unit price by category
fig = px.bar(
    df, 
    x='CategoryID', 
    y='AverageUnitPrice', 
    title='Average Unit Price by Category',
    labels={'CategoryID': 'Category ID', 'AverageUnitPrice': 'Average Unit Price'},
    template='plotly'
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly implements the business analytics request to calculate the average unit price by category and visualize the result as a bar chart. The SQL query in the input code correctly aggregates the `UnitPrice` by `CategoryID` matching the logic of the reference implementation. It then uses Plotly Express to create a bar chart similar to the reference code. The function `show_to_user` is used correctly to display the chart. The differences in variable names and additional styling (e.g., the `template` argument) do not affect the correctness of the logic.",both
"What is the average discount given on orders, and can you provide a bar chart or histogram showing the distribution of discounts across all orders?","```python
import plotly.express as px

# Execute the SQL query to get the average discount
avg_discount_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details];""
average_discount_df = execute_sql_query(avg_discount_query)

# Display the average discount result
show_to_user(average_discount_df)

# Execute the SQL query to get all discounts for visualization purposes
discounts_query = ""SELECT Discount FROM [Order Details];""
discounts_df = execute_sql_query(discounts_query)

# Create a histogram to show the distribution of discounts
fig = px.histogram(discounts_df, x=""Discount"", title=""Distribution of Discounts Across All Orders"", 
                   labels={""Discount"": ""Discount Value""}, nbins=20)

# Display the histogram to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve discounts from the Order Details table
sql_query = """"""
SELECT Discount
FROM [Order Details]
""""""
discounts_df = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = discounts_df['Discount'].mean()

# Generate a histogram for the distribution of discounts
fig = px.histogram(discounts_df, x='Discount', title='Distribution of Discounts', labels={'Discount': 'Discount'})
show_to_user(fig)

average_discount
```","The input code correctly calculates the average discount using the Pandas `mean` function and generates a histogram with Plotly. It matches the overall logic of the reference implementation, which includes calculating the average and displaying a distribution of discounts. Both versions use SQL to query discount data and visualize the distribution, fulfilling the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = ""SELECT Discount FROM [Order Details];""

# Execute the SQL query
discount_data = execute_sql_query(sql_query)

# Calculate the average discount
average_discount = discount_data['Discount'].mean()

# Display the average discount
show_to_user(pd.DataFrame({'AverageDiscount': [average_discount]}))

# Create a histogram for the distribution of discounts
fig = px.histogram(discount_data, x='Discount', title='Distribution of Discounts Across All Orders')

# Display the histogram
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. It executes a SQL query to retrieve the 'Discount' data, computes the average discount using pandas, and displays it in a DataFrame. It also plots a histogram with Plotly to show the distribution of discounts and displays it. Both functionalities mirror the reference code, fulfilling the business analytics request accurately.",both
"What's the total value of the current stock for each product, and can you provide a bar chart to visualize these values?","```python
import pandas as pd
import plotly.express as px

# SQL query to execute
sql_query = ""SELECT ProductName, UnitsInStock * UnitPrice AS StockValue FROM products;""

# Execute the query and get results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='StockValue', title='Total Stock Value per Product')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve product details including stock value
sql_query = """"""
SELECT 
    ProductID, 
    ProductName, 
    UnitPrice, 
    UnitsInStock, 
    (UnitPrice * UnitsInStock) AS TotalStockValue
FROM 
    products
WHERE 
    Discontinued = 0
""""""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Visualize the total stock value for each product
fig = px.bar(products_df, x='ProductName', y='TotalStockValue', 
             title='Total Stock Value for Each Product', 
             labels={'TotalStockValue': 'Total Stock Value', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code correctly calculates the total stock value for each product by multiplying 'UnitPrice' and 'UnitsInStock', similar to the reference code. It uses a SQL query to retrieve relevant data, including a check for non-discontinued products, which is acceptable for calculating current stock. The input code visualizes these values in a bar chart using Plotly, just like the reference implementation. Minor differences, such as additional fields in the SQL query and a different bar chart title or label, do not affect the correctness of the core logic as per the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT products.ProductID, SUM(products.UnitPrice * products.UnitsInStock) AS StockValue 
FROM products 
GROUP BY products.ProductID;
""""""

# Execute the SQL query to get the results in a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the stock values
fig = px.bar(products_df, x='ProductID', y='StockValue', title='Total Stock Value per Product')

# Display the bar chart
show_to_user(fig)
```","The evaluated code uses 'ProductID' instead of 'ProductName' for the x-axis in the bar chart and SQL grouping, which does not align with the reference implementation. The business request specifies providing the stock value per product using 'ProductName', not 'ProductID'.",Base
List products that have never been ordered and visualize this information using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM [Order Details]);
""""""

# Execute the SQL query
products_never_ordered_df = execute_sql_query(sql_query)

# Generate a bar chart for visualization
# Ensure the y-axis values are correctly set as 'Count', with a constant value of 1 for each product
fig = px.bar(products_never_ordered_df, x='ProductName', y=['Count']*len(products_never_ordered_df),
             labels={'y': 'Count'}, title='Products Never Ordered')

# Display the visualization result
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT p.ProductID, p.ProductName
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL
""""""

# Execute the SQL query
no_orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the products that have never been ordered
fig = px.bar(no_orders_df, x='ProductName', y='ProductID', title='Products That Have Never Been Ordered', labels={'ProductID': 'Not Ordered'})
show_to_user(fig)
```","The logic for finding products that have never been ordered is correct as it uses a LEFT JOIN and checks for NULLs, but the visualization is incorrect. The reference code visualizes using a constant 'Count' for the y-axis to represent the number of products, each being 1, whereas the input code uses 'ProductID' as the y-axis, which is not meaningful for a bar chart. Additionally, the label for the y-axis should be 'Count' not 'Not Ordered'.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assuming this function is already implemented to fetch data
    # from the database
    pass

# Utility function to show a visualization
def show_to_user(data):
    # Assuming this function is already implemented to display data
    pass

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT P.ProductName FROM products P
LEFT JOIN [Order Details] OD ON P.ProductID = OD.ProductID
WHERE OD.ProductID IS NULL
""""""

# Execute the query and get the results in a DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize products that have never been ordered
fig = px.bar(products_df, x='ProductName', title='Products That Have Never Been Ordered')
show_to_user(fig)
```","The input Python code correctly identifies products that have never been ordered using a LEFT JOIN and checking for NULL in the joined table for non-existent orders, which is logically equivalent to the reference implementation's NOT IN clause. Both implementations create a bar chart showing the 'ProductName'. Although the input code does not explicitly set the y-axis to a constant 'Count' value, the Plotly bar chart effectively defaults to counting occurrences when no specific y-axis is provided, achieving the same visualization intent.",Finetuned
"Which employees have the highest order fulfillment speed, and can this be visualized with a bar chart indicating individual performance?","import pandas as pd
import plotly.express as px

# SQL query to fetch data on employees and their average order fulfillment time
sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY EmployeeID 
ORDER BY AvgFulfillmentTime ASC;
""""""

# Execute SQL query to retrieve the data in a pandas DataFrame
df = execute_sql_query(sql_query)

# Display the DataFrame to ensure data retrieval was successful
show_to_user(df)

# Create a bar chart using Plotly to visualize the average fulfillment time for each employee
fig = px.bar(
    df,
    x='EmployeeID',
    y='AvgFulfillmentTime',
    title='Employee Order Fulfillment Speed',
    labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)', 'EmployeeID': 'Employee ID'},
    text='AvgFulfillmentTime'
)

# Show the chart using the custom utility function
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    EmployeeID, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM 
    orders
GROUP BY 
    EmployeeID
ORDER BY 
    AvgFulfillmentTime ASC
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.bar(fulfillment_data, 
             x='EmployeeID', 
             y='AvgFulfillmentTime',
             title='Order Fulfillment Speed by Employee',
             labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'EmployeeID': 'Employee ID'})

show_to_user(fig)
```","The input code performs the same operations as the reference implementation. It executes an identical SQL query to calculate the average order fulfillment time per employee, orders the results, and visualizes it using a Plotly bar chart. Despite minor differences like the omission of a data display before plotting, the code satisfies the business request and mirrors the reference logic in generating a visualization of employee fulfillment speeds.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch employees with highest order fulfillment speed
sql_query = """"""
SELECT e.EmployeeID, 
       e.FirstName, e.LastName, 
       AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgFulfillmentTime 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName 
ORDER BY AvgFulfillmentTime ASC
""""""

# Fetch data using the execute_sql_query utility function
employee_data = execute_sql_query(sql_query)

# Visualization using Plotly
fig = px.bar(
    employee_data,
    x='FirstName',
    y='AvgFulfillmentTime',
    hover_data=['LastName'],
    title=""Employee Order Fulfillment Speed"",
    labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)'},
    text='AvgFulfillmentTime'
)

# Display the bar chart using the show_to_user utility function
show_to_user(fig)
```","The provided code accurately reflects the logic of the reference implementation. It retrieves employees' average order fulfillment time, adding employee names for additional context. The grouping and sorting are consistent with identifying the highest order fulfillment speed. Visualization aligns with the business request by using a bar chart to indicate individual performance. Differences in column selections are for enhanced detail without altering core functionality.",both
Which city has the highest number of orders shipped in 2023? Include a bar chart to visualize the number of orders per city.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per city for 2023
sql_query = """"""
SELECT orders.ShipCity, COUNT(orders.OrderID) AS total_orders 
FROM orders 
WHERE YEAR(orders.ShippedDate) = 2023 
GROUP BY orders.ShipCity 
ORDER BY total_orders DESC
""""""

# Execute the SQL query and get the result as a pandas DataFrame
orders_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per city
fig = px.bar(orders_df, x='ShipCity', y='total_orders',
             title='Number of Orders per City in 2023',
             labels={'total_orders': 'Total Orders', 'ShipCity': 'City'},
             text='total_orders')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS order_count
FROM orders
WHERE ShippedDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY ShipCity
ORDER BY order_count DESC
""""""

result_df = execute_sql_query(sql_query)

highest_city = result_df.iloc[0]

fig = px.bar(result_df, x='ShipCity', y='order_count', title='Number of Orders Shipped per City in 2023')
show_to_user(fig)

highest_city
```","The input Python code correctly implements the task of finding the city with the highest number of orders shipped in 2023. It uses a SQL query to filter orders shipped within the specified date range (Jan 1, 2023, to Dec 31, 2023), groups by 'ShipCity', and orders the results by 'order_count' in descending order. It retrieves the city with the highest number of orders ('highest_city') by accessing the first row of the sorted DataFrame. Moreover, it uses Plotly to create a bar chart similar to the reference implementation, fulfilling the visualization requirement. Although the SQL syntax slightly varies, the logic and outcome are consistent with the reference code.","```python
import plotly.express as px
import pandas as pd

# Assume execute_sql_query and show_to_user are predefined utility functions

# SQL query to get the number of orders per city for 2023
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY ShipCity 
ORDER BY OrderCount DESC;
""""""

# Execute the query to get the data
orders_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_data, x='ShipCity', y='OrderCount', title='Number of Orders per City in 2023')

# Display the plot
show_to_user(fig)

# Optionally show the DataFrame for additional context
show_to_user(orders_data)
```","The input code uses 'OrderDate' instead of 'ShippedDate' when filtering orders for 2023. The business request specifies the highest number of orders shipped, so the use of 'ShippedDate' is crucial to align with the reference implementation.",Base
Determine the difference in shipment duration for each order (RequiredDate vs ShippedDate) and visualize the distribution of these differences.,"```python
import plotly.express as px

# SQL query to determine shipment duration
sql_query = """"""
SELECT OrderID, DATEDIFF(ShippedDate, RequiredDate) AS ShipmentDuration 
FROM orders 
WHERE ShippedDate IS NOT NULL;
""""""

def analyze_shipment_duration():
    # Execute the SQL query and get the result as a DataFrame
    df = execute_sql_query(sql_query)

    # Visualize the distribution of shipment duration using a histogram
    fig = px.histogram(df, x='ShipmentDuration', title='Distribution of Shipment Durations')
    
    # Display the plot
    show_to_user(fig)

# Execute the function to perform analysis and visualization
analyze_shipment_duration()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    RequiredDate, 
    ShippedDate, 
    DATEDIFF(ShippedDate, RequiredDate) AS ShipmentDuration 
FROM 
    orders 
WHERE 
    ShippedDate IS NOT NULL
""""""

shipment_data = execute_sql_query(sql_query)

fig = px.histogram(shipment_data, x='ShipmentDuration', title='Distribution of Shipment Durations', 
                   labels={'ShipmentDuration': 'Shipment Duration (Days)'})
show_to_user(fig)
```","The input Python code correctly calculates the shipment duration as the difference between ShippedDate and RequiredDate using the DATEDIFF function, similar to the reference code. It then retrieves this information via an SQL query while excluding records with NULL ShippedDate, which aligns with the reference code's WHERE clause. Finally, it visualizes the shipment duration distribution with a histogram using Plotly, maintaining equivalent logic and functionality to the reference implementation. The differences in the inclusion of additional columns in the SQL query do not affect the outcome or visualization logic.","
import pandas as pd
import plotly.express as px

# SQL query to fetch data
sql_query = """"""
SELECT OrderID, DATEDIFF(ShippedDate, RequiredDate) AS ShipmentDuration FROM orders;
""""""

# Execute the SQL query and return a DataFrame
orders_df = execute_sql_query(sql_query)

# Ensure ShipmentDuration is numeric, though DATEDIFF should return a numeric type
orders_df['ShipmentDuration'] = pd.to_numeric(orders_df['ShipmentDuration'], errors='coerce')

# Visualize the distribution of shipment duration differences using Plotly
fig = px.histogram(orders_df, x='ShipmentDuration', title='Distribution of Shipment Duration Differences')

# Display the plot
show_to_user(fig)
","The input code includes orders where 'ShippedDate' is NULL. According to the reference implementation, only orders with a non-null 'ShippedDate' should be considered. The condition WHERE ShippedDate IS NOT NULL is missing in the input code's SQL query.",Base
"What is the total revenue generated from each supplier's products, and can a bar chart be provided to compare these revenues visually?","import pandas as pd
import plotly.express as px

# Assuming the SQL query is correctly formatted and connected to the database
sql_query = """"""
SELECT s.SupplierID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID;
""""""

# Function to execute the SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should connect to the database, execute the query,
    # and return the results as a pandas DataFrame.
    pass

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(revenue_data, x='SupplierID', y='TotalRevenue', title='Total Revenue by Supplier')

# Display the figure
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='CompanyName', y='TotalRevenue', 
             title='Total Revenue Generated from Each Supplier\'s Products',
             labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The evaluated code answers the business request correctly by calculating the total revenue for each supplier using a slightly extended SQL query. It includes 'CompanyName' for better labeling, but the core calculation logic matches the reference implementation. A bar chart is created to visually compare the revenues using Plotly, satisfying the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch supplier revenue data
sql_query = """"""
SELECT su.CompanyName,
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS SupplierRevenue
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN suppliers su ON p.SupplierID = su.SupplierID
GROUP BY su.CompanyName
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Sample implementation for executing SQL and returning DataFrame
    # This should connect to the database and fetch the query result
    # For now, we assume the function is properly implemented elsewhere
    pass

# Function to display data analysis
def show_to_user(data):
    # Sample implementation for displaying data or Plotly visualization
    pass

# Execute the SQL query
df_supplier_revenue = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(df_supplier_revenue, x='CompanyName', y='SupplierRevenue', title='Supplier Revenue Comparison', labels={'CompanyName': 'Supplier', 'SupplierRevenue': 'Revenue'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code correctly implements the business analytics request by calculating the total revenue per supplier using a similar SQL query, grouping by supplier. The only difference is that it uses 'CompanyName' instead of 'SupplierID', which doesn't affect the correctness with respect to the request. It also properly generates and displays a bar chart using Plotly, similar to the reference code.",both
"Which employee has the highest sales in a given year, and can we visualize this comparison with a bar chart?","```python
import pandas as pd
import plotly.express as px

# Assume the utility functions are defined as per the environment constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Execute the SQL query and fetch results as a DataFrame
    # This is a placeholder implementation for the actual function
    data = {
        'EmployeeID': [1, 2],
        'FirstName': ['John', 'Jane'],
        'LastName': ['Doe', 'Smith'],
        'TotalSales': [15000, 10000]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Show the data or graph to the user
    # This is a placeholder implementation for the actual function
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query string
sql_query = """"""
SELECT 
    e.EmployeeID, e.FirstName, e.LastName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) as TotalSales 
FROM 
    employees e 
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
WHERE 
    YEAR(o.OrderDate) = 2022 
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName 
ORDER BY 
    TotalSales DESC 
LIMIT 1;
""""""

# Execute the query
result_df = execute_sql_query(sql_query)

# Create a bar chart with Plotly
fig = px.bar(result_df, x='EmployeeID', y='TotalSales',
             hover_data=['FirstName', 'LastName'],
             title='Employee with Highest Sales in 2022')

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

year = 2023  # Specify the year for analysis
sql_query = f""""""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
WHERE YEAR(o.OrderDate) = {year}
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY TotalSales DESC
LIMIT 1;
""""""

highest_sales_employee = execute_sql_query(sql_query)

fig = px.bar(highest_sales_employee, 
             x='LastName', 
             y='TotalSales', 
             title=f""Highest Sales Employee in {year}"",
             labels={'LastName': 'Employee', 'TotalSales': 'Total Sales'})
show_to_user(fig)
```","The input code answers the business analytics request by identifying the employee with the highest sales in the specified year, just like the reference code. The SQL query correctly calculates total sales per employee for the given year, and orders them to find the top performer. It also visualizes the result with a bar chart using Plotly, displaying 'TotalSales' against 'LastName', which is a valid approach for the requested task.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the data
sql_query = """"""
SELECT employees.EmployeeID, employees.FirstName, employees.LastName, 
SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
WHERE YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName 
ORDER BY total_sales DESC 
LIMIT 1
""""""

# Assuming execute_sql_query function is defined in the workspace
employee_data = execute_sql_query(sql_query)

# Display the employee with the highest sales
show_to_user(employee_data)

# For visualization, let's create the bar chart for the highest earning employee
fig = px.bar(employee_data, x='FirstName', y='total_sales', 
             text='total_sales', 
             title='Highest Sales Employee for the Current Year',
             labels={'total_sales': 'Total Sales'},
             hover_data={'LastName': True})
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(yaxis=dict(title='Total Sales'), xaxis=dict(title='Employee'))

# Show the bar chart
show_to_user(fig)

```","The input Python code effectively meets the business requirement of identifying the employee with the highest sales for a given year and visualizing the result. It follows a similar logic as the reference code, using SQL to fetch the highest total sales per employee, although it uses YEAR(CURRENT_DATE) to dynamically take the current year instead of a hardcoded year like 2022. The bar chart visualization correctly displays the needed information and includes similar details as the reference code. Both implementations achieve the intended result, albeit with minor differences in SQL formatting and visualization details.",both
How many unique products are ordered by each customer? Please include a bar chart to visualize the number of unique products per customer.,"```python
import pandas as pd
import plotly.express as px

# SQL query to find unique products ordered by each customer
sql_query = """"""
SELECT o.CustomerID, COUNT(DISTINCT od.ProductID) AS UniqueProductsOrdered 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.CustomerID;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Generate a bar chart to visualize the number of unique products per customer
fig = px.bar(df, x='CustomerID', y='UniqueProductsOrdered', 
             title='Unique Products Ordered by Each Customer',
             labels={'CustomerID': 'Customer ID', 'UniqueProductsOrdered': 'Unique Products Ordered'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.CustomerID, COUNT(DISTINCT od.ProductID) as UniqueProducts
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.CustomerID
""""""

unique_products_df = execute_sql_query(sql_query)

fig = px.bar(unique_products_df, x='CustomerID', y='UniqueProducts', 
              title='Number of Unique Products Ordered by Each Customer')
show_to_user(fig)
```","The input code performs the same operations as the reference code: it executes a SQL query to count the distinct products ordered by each customer, stores the results in a DataFrame, and creates a bar chart with Plotly to visualize this data. The difference in column alias (UniqueProducts vs. UniqueProductsOrdered) does not affect the correctness of the solution. Thus, the input code adheres to the logic of the business request and the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT customers.CustomerID, COUNT(DISTINCT [Order Details].ProductID) AS UniqueProductsOrdered 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID;
""""""

# Execute the SQL query to get the DataFrame
df_unique_products = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df_unique_products, 
    x='CustomerID', 
    y='UniqueProductsOrdered', 
    title='Unique Products Ordered per Customer',
    labels={'UniqueProductsOrdered': 'Number of Unique Products', 'CustomerID': 'Customer ID'}
)

# Display the bar chart
show_to_user(fig)
```","The input code correctly executes an SQL query to find and count unique products ordered by each customer. It includes necessary joins between the 'customers', 'orders', and 'Order Details' tables to get the desired data, similar to the reference. It also generates a bar chart using the same plotting library and conveys the same information, meeting the business analytics request.",both
"Which products have the highest discount on average, and can this be illustrated with a bar chart for better comparison?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductName, AVG([Order Details].Discount) AS AvgDiscount 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName 
ORDER BY AvgDiscount DESC
""""""

# Execute the SQL query and load the result into a DataFrame
products_discount_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average discount of products
fig = px.bar(products_discount_df, 
             x='ProductName', 
             y='AvgDiscount', 
             title='Average Discount by Product',
             labels={'AvgDiscount': 'Average Discount', 'ProductName': 'Product Name'},
             template='plotly_dark')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, AVG(od.Discount) AS AverageDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY AverageDiscount DESC
""""""

discount_data = execute_sql_query(sql_query)
fig = px.bar(discount_data, x='ProductName', y='AverageDiscount', title='Average Discount by Product')
show_to_user(fig)
```","Both implementations execute a SQL query to find the average discount per product, sorting them by the discount in descending order. The reference code groups by `ProductName`, while the input code groups by both `ProductID` and `ProductName`, which is logically consistent as `ProductID` is unique per product. Both codes use Plotly to create a bar chart of average discounts by product and display the chart with `show_to_user`, satisfying the business analytics request.","
import plotly.express as px

# SQL query to fetch product names with the highest average discounts
sql_query = """"""
SELECT products.ProductName, AVG([Order Details].Discount) AS AvgDiscount
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductName
ORDER BY AvgDiscount DESC;
""""""

# Analyze the SQL query to get a DataFrame
product_discounts_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average discount per product
fig = px.bar(
    product_discounts_df,
    x='ProductName',
    y='AvgDiscount',
    title='Average Discount per Product',
    labels={'ProductName': 'Product Name', 'AvgDiscount': 'Average Discount'},
    template='plotly'
)

# Display the bar chart to the user
show_to_user(fig)
","The provided Python code correctly matches the business analytics request and reference implementation in terms of logic and output. It executes a SQL query to calculate the average discount for each product, orders them by the average discount in descending order, and visualizes the results with a bar chart using Plotly. The differences, such as the order of the JOIN clause and the Plotly template, do not affect the correctness or logic of the implementation.",both
Calculate the average discount provided by each employee and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing SQL and returning a DataFrame
    # Replace this with actual database connection and query execution logic
    pass

# Utility function to display data or visualization
def show_to_user(data):
    # Placeholder for displaying a Plotly figure or DataFrame
    print(data)

# SQL query to get average discount by employee
sql_query = """"""
SELECT employees.EmployeeID, AVG([Order Details].Discount) AS AverageDiscount
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Generate a bar chart to visualize average discount by employee
fig = px.bar(df, x='EmployeeID', y='AverageDiscount', title='Average Discount by Employee')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    e.FirstName, 
    e.LastName,
    AVG(od.Discount) AS AverageDiscount
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, e.FirstName, e.LastName
ORDER BY 
    AverageDiscount DESC
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, 
             x='FirstName', 
             y='AverageDiscount', 
             title='Average Discount Provided by Each Employee',
             labels={'FirstName': 'Employee', 'AverageDiscount': 'Average Discount'})
             
show_to_user(fig)
```","The input code correctly computes the average discount provided by employees and visualizes this using a bar chart. Although it includes employee first and last names in the SELECT and GROUP BY clauses, these additions are merely for enhanced visualization, not affecting the calculation of the average discount. The use of 'FirstName' for the x-axis and an order for average discount does not conflict with the primary task of computing and visualizing average discounts.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG([Order Details].Discount) AS AvgDiscount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='EmployeeID', y='AvgDiscount', title='Average Discount by Employee')

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the business analytics request by calculating the average discount for each employee. The SQL query selects the average discount and groups it by employee ID, which matches the reference implementation. The visualization is correctly created using Plotly to display a bar chart with the specified attributes. The differences in column alias ('AvgDiscount' vs 'AverageDiscount') are inconsequential to the functionality.",both
Calculate the total sales for each product and provide a bar chart to visualize the results.,"
```python
import plotly.express as px
import pandas as pd

# SQL query to get total sales for each product
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSales
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.ProductName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalSales', title='Total Sales per Product')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Total Sales per Product', labels={'TotalSales': 'Total Sales', 'ProductName': 'Product'})
show_to_user(fig)
```","The input code includes a calculation for TotalSales that factors in a discount with (1 - od.Discount), which was not present in the reference implementation. This changes the logic and the outcome of the query compared to the reference code, which only multiplies by Quantity and UnitPrice. Additionally, the input groups by ProductID and ProductName, while the reference only groups by ProductName; however, this does not affect the correctness in this context.","
import plotly.express as px
import pandas as pd

def calculate_total_sales():
    # SQL query to get TotalSales for each product
    sql_query = """"""
    SELECT od.ProductID, SUM(od.UnitPrice * od.Quantity) AS TotalSales
    FROM [Order Details] od
    GROUP BY od.ProductID;
    """"""
    
    # Execute the SQL query using the utility function to get a DataFrame
    sales_data = execute_sql_query(sql_query)

    # Create a bar chart using Plotly
    fig = px.bar(sales_data, x='ProductID', y='TotalSales', title='Total Sales per Product', labels={'ProductID': 'Product ID', 'TotalSales': 'Total Sales'})

    # Show the bar chart to the user
    show_to_user(fig)

# Call the function to execute the analysis and visualization
calculate_total_sales()
","The input code calculates total sales per ProductID, but it doesn't join with the products table to get ProductName as required in the business analytics request. Instead, it groups sales by ProductID, which does not adhere to the logic in the reference implementation that groups by ProductName using a JOIN.",None
How many orders were shipped later than the required date? Include a bar chart showing the count of late shipments by month.,"import pandas as pd
import plotly.express as px

# SQL Query to fetch the count of late shipments by month
sql_query = '''
SELECT YEAR(orders.ShippedDate) AS Year, 
       MONTH(orders.ShippedDate) AS Month, 
       COUNT(orders.OrderID) AS LateShipments
FROM orders
WHERE orders.ShippedDate > orders.RequiredDate
GROUP BY YEAR(orders.ShippedDate), MONTH(orders.ShippedDate)
ORDER BY YEAR(orders.ShippedDate), MONTH(orders.ShippedDate)
'''

# Execute the SQL query
late_shipments_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(late_shipments_df, 
             x='Month', 
             y='LateShipments', 
             color='Year', 
             title='Count of Late Shipments by Month',
             labels={'LateShipments': 'Number of Late Shipments'},
             barmode='group')

# Show the visualization
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS shipment_month,
    COUNT(OrderID) AS late_shipment_count
FROM orders
WHERE ShippedDate > RequiredDate
GROUP BY shipment_month
ORDER BY shipment_month;
""""""

late_shipments_df = execute_sql_query(sql_query)

total_late_shipments = late_shipments_df['late_shipment_count'].sum()

fig = px.bar(late_shipments_df, x='shipment_month', y='late_shipment_count', 
             title='Count of Late Shipments by Month',
             labels={'shipment_month': 'Shipment Month', 'late_shipment_count': 'Late Shipment Count'})

show_to_user(fig)
```","The input Python code correctly addresses the business analytics request. It calculates the number of orders shipped later than the required date and generates a bar chart sorted by shipment month. Though the SQL query uses a different method to group by year and month (DATE_FORMAT for concatenation), the logical operation is equivalent to the reference implementation. The visualization uses Plotly Express to create the bar chart displaying late shipments per month, fulfilling the request.","```python
import plotly.express as px
import pandas as pd

# SQL query to count late orders and extract required fields for visualization
sql_query = """"""
SELECT OrderID, ShippedDate, RequiredDate 
FROM orders 
WHERE ShippedDate > RequiredDate;
""""""

# Execute the SQL query to get a DataFrame
late_orders_df = execute_sql_query(sql_query)

# Convert ShippedDate to datetime format for better handling
late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])

# Add a column for the month and year of the ShippedDate
late_orders_df['LateMonth'] = late_orders_df['ShippedDate'].dt.to_period('M')

# Count the number of late orders by month
late_orders_count_by_month = late_orders_df.groupby('LateMonth').size().reset_index(name='LateOrdersCount')

# Convert the Period column back to a string for better plotting
late_orders_count_by_month['LateMonth'] = late_orders_count_by_month['LateMonth'].astype(str)

# Create a bar chart using Plotly
fig = px.bar(
    late_orders_count_by_month, 
    x='LateMonth', 
    y='LateOrdersCount', 
    title='Count of Late Shipments by Month',
    labels={'LateMonth': 'Month', 'LateOrdersCount': 'Number of Late Orders'}
)

# Display the figure
show_to_user(fig)
```","The input code correctly executes the business analytics request by counting late orders and generating a bar chart displaying the count by month. It uses SQL to filter orders with shipped dates later than required dates, and then processes the data in a similar manner to the reference code. Although it uses different steps like converting dates to periods and grouping by these periods, the end result—showing the count of late shipments by month—is achieved accurately. The aggregation logic and visualization effectively mirror the reference implementation's intent and output.",both
"What is the average shipping cost to each country, and can we visualize these costs on a world map?","```python
import plotly.express as px

# SQL Query to extract average shipping cost by country
sql_query = """"""
SELECT ShipCountry, AVG(Freight) AS AverageShippingCost 
FROM orders 
GROUP BY ShipCountry;
""""""

# Execute the SQL query using the provided utility function
shipping_cost_df = execute_sql_query(sql_query)

# Create a choropleth map to visualize average shipping costs by country
fig = px.choropleth(
    shipping_cost_df,
    locations=""ShipCountry"",
    locationmode='country names',
    color=""AverageShippingCost"",
    hover_name=""ShipCountry"",
    color_continuous_scale=px.colors.sequential.Plasma,
    title=""Average Shipping Cost by Country""
)

# Display the map visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, AVG(Freight) AS AverageShippingCost
FROM orders
GROUP BY ShipCountry
""""""

shipping_costs_df = execute_sql_query(sql_query)

fig = px.choropleth(shipping_costs_df, 
                     locations='ShipCountry', 
                     locationmode='country names', 
                     color='AverageShippingCost',
                     title='Average Shipping Cost to Each Country',
                     color_continuous_scale=px.colors.sequential.Plasma)

show_to_user(fig)
```","Both the input code and the reference code execute the same SQL query to calculate the average shipping cost by country. They use Plotly Express to create a choropleth map, using the same key parameters and color schemes. The visualization is displayed to the user in the same way, adhering to the specified business analytics request. Thus, the input code is correct in terms of logic and objective.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT ShipCountry, AVG(Freight) AS AvgShippingCost
FROM orders
GROUP BY ShipCountry;
""""""

# Execute the SQL query to get the data
shipping_data = execute_sql_query(sql_query)

# Visualize average shipping costs on a world map using Plotly
fig = px.choropleth(
    shipping_data,
    locations='ShipCountry',
    locationmode='country names',
    color='AvgShippingCost',
    hover_name='ShipCountry',
    title='Average Shipping Cost by Country',
    color_continuous_scale='Viridis'
)

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request. It uses an SQL query to calculate the average shipping cost per country and then visualizes these costs on a world map using Plotly. While the color scale differs ('Plasma' vs 'Viridis'), this does not affect the correctness of the code as per the request and logic of the reference implementation.",both
"What is the average order value for the current year, and can it be represented with a line chart showing the trend by month?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation for example
    pass

# Function to display data/results
def show_to_user(data):
    # Placeholder implementation for example
    pass

# SQL query for the average order value by month for the current year
sql_query = """"""
SELECT
    DATE_TRUNC('month', o.OrderDate) AS OrderMonth,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM
    orders o
JOIN
    [Order Details] od ON o.OrderID = od.OrderID
WHERE
    o.OrderDate BETWEEN DATE_TRUNC('year', CURRENT_DATE) AND CURRENT_DATE
GROUP BY
    OrderMonth
ORDER BY
    OrderMonth
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure 'OrderMonth' is parsed as a date for proper plotting
df['OrderMonth'] = pd.to_datetime(df['OrderMonth'])

# Create line chart using Plotly
fig = px.line(df, x='OrderMonth', y='AverageOrderValue', title='Average Order Value by Month for Current Year', labels={'OrderMonth':'Month', 'AverageOrderValue':'Average Order Value'})

# Display the line chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

current_year = pd.to_datetime(""today"").year

sql_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    YEAR(OrderDate) = {current_year}
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

average_order_value_df = execute_sql_query(sql_query)

fig = px.line(average_order_value_df, x='Month', y='AverageOrderValue', title='Average Order Value Trend by Month for Current Year')
show_to_user(fig)
```","Both code implementations aim to calculate the average order value for the current year and visualize the trend by month using a line chart. The key differences are in the date handling: the reference uses DATE_TRUNC while the input uses DATE_FORMAT and YEAR, which are functionally equivalent for the purpose. The result groupings and calculations are consistent. Therefore, the input code adheres to the same logic as the reference code.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    MONTH(orders.OrderDate) AS order_month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) 
        / NULLIF(COUNT(DISTINCT orders.OrderID), 0) AS avg_order_value 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    YEAR(orders.OrderDate) = YEAR(CURRENT_DATE) 
GROUP BY 
    order_month
ORDER BY 
    order_month;
""""""

# Execute the SQL query and get results into a DataFrame
current_year_data = execute_sql_query(sql_query)

# Ensure that the DataFrame is sorted by month
current_year_data = current_year_data.sort_values(by='order_month')

# Create a line chart using Plotly
fig = px.line(
    current_year_data,
    x='order_month',
    y='avg_order_value',
    title='Average Order Value Trend by Month for Current Year',
    labels={'order_month': 'Month', 'avg_order_value': 'Average Order Value'}
)

# Display the line chart
show_to_user(fig)
```","The input Python code correctly calculates the average order value by month for the current year and represents it with a line chart. Both codes group the data by month and compute the average by dividing the total order value by the distinct count of order IDs. The SQL syntax differences (e.g., DATE_TRUNC vs. MONTH and YEAR functions) still lead to equivalent results. The code sorts the DataFrame by month and creates a line chart, fulfilling the business analytics request.",both
How many discontinued products are still in stock? Could you provide a bar chart to visualize the quantities of each product?,"# Define the SQL query based on the business request
sql_query = """"""
SELECT ProductID, UnitsInStock 
FROM products 
WHERE Discontinued = 1 AND UnitsInStock > 0;
""""""

# Execute the SQL query and get the results in a pandas DataFrame
discontinued_products_in_stock = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the quantities of each discontinued product
fig = px.bar(
    discontinued_products_in_stock,
    x='ProductID',
    y='UnitsInStock',
    title='Quantities of Discontinued Products in Stock',
    labels={'ProductID': 'Product ID', 'UnitsInStock': 'Units In Stock'}
)

# Display the bar chart using the specified utility function
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitsInStock 
FROM products 
WHERE Discontinued = 1 
AND UnitsInStock > 0
""""""

discontinued_products = execute_sql_query(sql_query)

bar_chart = px.bar(discontinued_products, x='ProductName', y='UnitsInStock', 
                   title='Quantities of Discontinued Products in Stock',
                   labels={'UnitsInStock': 'Units In Stock', 'ProductName': 'Product Name'})

show_to_user(bar_chart)
```","The input code correctly executes the SQL query to select discontinued products still in stock, but it retrieves 'ProductName' instead of 'ProductID'. It then uses Plotly to create a bar chart showing the 'UnitsInStock' for each product. The main difference is the use of 'ProductName' for the x-axis instead of 'ProductID', which doesn't affect meeting the business request.","```python
import pandas as pd
import plotly.express as px

def run_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution
    # In a real environment, this function would connect to the database
    # and execute the provided SQL query to return a pandas DataFrame.
    pass

def show_to_user(data):
    # Placeholder for real visualization or output display
    pass

# SQL query to fetch discontinued products that are still in stock
sql_query = ""SELECT ProductName, UnitsInStock FROM products WHERE Discontinued = 1 AND UnitsInStock > 0;""

# Execute the SQL query and get the data as a DataFrame
discontinued_products_df = run_sql_query(sql_query)

# Generate a bar chart to visualize the quantities of each discontinued product in stock
fig = px.bar(discontinued_products_df, x='ProductName', y='UnitsInStock', title='Quantities of Discontinued Products Still in Stock')

# Display the visualization
show_to_user(fig)
```","The input Python code correctly fulfills the business analytics request. It queries the 'products' database table to find discontinued products that are still in stock and creates a bar chart to visualize the quantities of these products. Although it uses 'ProductName' instead of 'ProductID' for visualization, this does not alter the logic concerning the business request.",both
"List products with no units on order but have sales in the last month, and create a bar chart to visualize the product sales.","
import pandas as pd
import plotly.express as px

# Define the given SQL query
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE UnitsOnOrder = 0 
AND ProductID IN (
    SELECT DISTINCT od.ProductID 
    FROM [Order Details] od 
    JOIN orders o ON od.OrderID = o.OrderID 
    WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
);
""""""

# Execute the SQL query using the provided utility function
products_df = execute_sql_query(sql_query)

# Visualize the product sales with a bar chart
fig = px.bar(products_df, x='ProductName', text='ProductName', title='Products with Sales in the Last Month and No Units on Order')

# Show the visualization
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the start date for the last month
end_date = datetime.now() - timedelta(days=datetime.now().day)
start_date = (end_date.replace(day=1) - timedelta(days=1)).replace(day=1)

# SQL query to get products with no units on order but have sales in the last month
sql_query = f""""""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN (
    SELECT DISTINCT ProductID FROM [Order Details]
    WHERE OrderID IN (
        SELECT OrderID FROM Orders WHERE OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}'
    )
) recent_sales ON p.ProductID = recent_sales.ProductID
WHERE p.UnitsOnOrder = 0
GROUP BY p.ProductID, p.ProductName
HAVING SUM(od.Quantity) > 0
""""""

# Execute the SQL query and retrieve the data
results_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the product sales
fig = px.bar(results_df, x='ProductName', y='TotalSales', title='Product Sales with No Units on Order', labels={'TotalSales': 'Total Sales', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input Python code correctly filters products with no units on order and calculates their sales in the last month. It uses a SQL query to find products with zero units on order and also ensures that they had sales in the specified period by joining with recent sales. The end date is set to the last day of the previous month, and the start date is the first day of the month before that, which matches the reference logic of checking the last month's sales. A bar chart is also properly created to visualize the results, aligning with the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get products with no units on order but have sales in the last month
sql_query = """"""
SELECT p.ProductName, SUM(od.Quantity) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON o.OrderID = od.OrderID 
WHERE p.UnitsOnOrder = 0 
AND o.OrderDate >= DATEADD(month, -1, CURRENT_DATE) 
GROUP BY p.ProductName;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ProductName', y='TotalSales', 
             title='Product Sales with No Units on Order',
             labels={'ProductName': 'Product Name', 'TotalSales': 'Total Sales'},
             template='plotly')

# Display the bar chart
show_to_user(fig)
```","The input code calculates 'TotalSales' by summing the order quantities, while the reference only lists product names. Additionally, the date functions differ; the input uses DATEADD whereas the reference uses DATE_SUB, which could vary depending on the SQL dialect (T-SQL vs. MySQL). Both codes attempt to address the same query criterion: products with sales in the last month and zero units on order.",Base
What products have been ordered most frequently? Please include a bar chart to visualize the frequency of orders for each product.,"```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function simulates the execution of a SQL query and returns a DataFrame.
    # Assume this function is implemented elsewhere and returns the correct results for the given query.
    pass

def show_to_user(data):
    # This function displays the data analysis or visualization results.
    # Assume this function is implemented elsewhere.
    pass

# SQL query to determine the most frequently ordered products
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity 
FROM [Order Details] 
GROUP BY ProductID 
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query and store the result in a DataFrame
order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the frequency of orders for each product
fig = px.bar(order_data, x='ProductID', y='TotalQuantity', title='Most Frequently Ordered Products', labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity Ordered'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.ProductID, COUNT(od.ProductID) AS Frequency
FROM [Order Details] od
GROUP BY od.ProductID
ORDER BY Frequency DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductID', y='Frequency', title='Frequency of Products Ordered', labels={'ProductID': 'Product ID', 'Frequency': 'Number of Orders'})
show_to_user(fig)
```","The input Python code calculates the frequency of how often each product is ordered (using COUNT on ProductID), while the reference implementation calculates the total quantity of each product ordered (using SUM on Quantity). These are different metrics: one counts the number of orders, while the other sums the quantities ordered, leading to potentially different orderings and visualizations.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, COUNT* FROM [Order Details] GROUP BY ProductID ORDER BY COUNT(*) DESC;
""""""

# Execute the SQL query to get the data
order_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize product order frequency
fig = px.bar(order_data, x='ProductID', y='Count', title='Frequency of Orders per Product')

# Display the chart to the user
show_to_user(fig)
```","The input code is incorrect because it uses COUNT* instead of SUM(Quantity) to calculate the total quantity ordered for each product, and the y-axis label should be 'TotalQuantity' instead of 'Count'. The reference code correctly sums the 'Quantity' of products to determine the total quantity ordered.",None
"What is the average shipping cost per order in the last year, and can it be visualized using a monthly trend line chart?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query for monthly average shipping cost
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS order_month,
    AVG(Freight) AS avg_shipping_cost
FROM 
    orders 
WHERE 
    OrderDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE()
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m')
""""""

# Execute the SQL query and get the data
orders_df = execute_sql_query(sql_query)

# Create a line chart for monthly average shipping cost
fig = px.line(
    orders_df, 
    x='order_month', 
    y='avg_shipping_cost', 
    title='Monthly Average Shipping Cost in the Last Year',
    labels={'order_month': 'Order Month', 'avg_shipping_cost': 'Average Shipping Cost ($)'},
    markers=True
)

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Get the current date and calculate the start date for the last year
end_date = pd.Timestamp.now().normalize()
start_date = end_date - pd.DateOffset(years=1)

# SQL query to get average shipping cost per month for the last year
sql_query = f""""""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS month, AVG(Freight) AS avg_shipping_cost
FROM orders
WHERE OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}'
GROUP BY month
ORDER BY month
""""""

# Execute the SQL query and get the results in a DataFrame
shipping_cost_df = execute_sql_query(sql_query)

# Create a line chart for the average shipping cost per order
fig = px.line(shipping_cost_df, x='month', y='avg_shipping_cost', title='Average Shipping Cost per Order (Last Year)')
show_to_user(fig)
```","The input code correctly calculates the average shipping cost per order for each month in the last year using SQL. The logic of selecting orders from the past year and grouping by month to compute the average shipping cost is consistent with the reference implementation. Additionally, the code visualizes this data using Plotly with a monthly trend line chart. The only differences are variable names and minor query syntax variations, which do not affect the correctness of the solution.","```python
import pandas as pd
import plotly.express as px

# Define the query to fetch average shipping costs per month for the last year
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    AVG(Freight) AS AvgShippingCost 
FROM 
    orders 
WHERE 
    OrderDate >= CURDATE() - INTERVAL 1 YEAR 
GROUP BY 
    DATE_FORMAT(OrderDate, '%Y-%m')
ORDER BY 
    Month;
""""""

# Execute the SQL query and store results in a DataFrame
order_data = execute_sql_query(sql_query)

# Ensure 'Month' is treated as a datetime for proper ordering and plotting
order_data['Month'] = pd.to_datetime(order_data['Month'])

# Create a trend line chart using Plotly
fig = px.line(order_data, x='Month', y='AvgShippingCost', 
              title='Monthly Average Shipping Cost in the Last Year', 
              labels={'AvgShippingCost': 'Average Shipping Cost', 'Month': 'Month'})

# Display the trend line chart
show_to_user(fig)
```","The input Python code correctly calculates the average shipping cost per month for the last year and visualizes it with a monthly trend line chart, consistent with the reference implementation. The SQL query structures are equivalent, where both filter for the last year and group by month. The use of the `execute_sql_query` function and Plotly for visualization matches the logic of the reference code. The slight variation in column naming does not affect functionality.",both
"What is the average shipping cost per order over the last month, and can you provide a chart to visualize the distribution of these costs?","```python
import pandas as pd
import plotly.express as px

# SQL Query to get the average shipping cost per order over the last month
sql_query = """"""
SELECT Freight FROM orders WHERE OrderDate >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month');
""""""

# Execute the query and get the DataFrame
orders_df = execute_sql_query(sql_query)

# Calculate the average shipping cost
average_shipping_cost = orders_df['Freight'].mean()

# Display the average shipping cost
average_df = pd.DataFrame({'Average Shipping Cost': [average_shipping_cost]})
show_to_user(average_df)

# Create a histogram to visualize the distribution of shipping costs
fig = px.histogram(orders_df, x='Freight', nbins=20, title='Distribution of Shipping Costs')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for last month
end_date = datetime.now().date().replace(day=1) - timedelta(days=1)
start_date = end_date.replace(day=1)

# SQL query to get shipping costs for the last month
sql_query = f""""""
SELECT Freight
FROM orders
WHERE OrderDate >= '{start_date}' AND OrderDate <= '{end_date}'
""""""

# Execute the SQL query
shipping_costs_df = execute_sql_query(sql_query)

# Calculate the average shipping cost
average_shipping_cost = shipping_costs_df['Freight'].mean()

# Create a distribution chart for shipping costs
fig = px.histogram(shipping_costs_df, x='Freight', title='Distribution of Shipping Costs', nbins=30)
fig.add_annotation(x=average_shipping_cost, y=0, 
                   text=f'Average: {average_shipping_cost:.2f}', 
                   showarrow=True, arrowhead=1)

# Show average shipping cost
show_to_user(f'Average Shipping Cost per Order: {average_shipping_cost:.2f}')

# Show the distribution chart
show_to_user(fig)
```","The input code correctly computes the average shipping cost for the previous month using a SQL query that matches the date range logic of the reference implementation. It calculates the average using the 'Freight' column and produces a histogram to visualize the distribution of shipping costs, which meets the requirements. The differences in SQL date handling and visualization details do not impact the correctness relative to the specified task.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT orders.ShipCountry, orders.ShipperID, AVG(orders.Freight) AS AvgShippingCost
FROM orders
WHERE orders.OrderDate BETWEEN '2023-09-01' AND '2023-09-30'
GROUP BY orders.ShipCountry, orders.ShipperID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a histogram to visualize the distribution of average shipping costs
fig = px.histogram(df, x='AvgShippingCost', title='Distribution of Average Shipping Costs per Order',
                   labels={'AvgShippingCost': 'Average Shipping Cost'}, nbins=10)

# Display the chart to the user
show_to_user(fig)
```","The input code does not correctly address the business analytics request. The request asks for the average shipping cost per order over the last month, while the input code calculates the average shipping cost grouped by ShipCountry and ShipperID for a specific date range. Furthermore, the visualization requested should illustrate the distribution of individual shipping costs, not grouped averages.",Base
List the top 5 employees with the highest sales growth over the last year and provide a bar chart to visualize their growth.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
(SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END) 
- SUM(CASE WHEN YEAR(o.OrderDate) = YEAR(CURRENT_DATE) - 1 THEN od.UnitPrice * od.Quantity * (1 - od.Discount) ELSE 0 END)) AS SalesGrowth 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName 
ORDER BY SalesGrowth DESC 
LIMIT 5;
""""""

# Execute the SQL query
df_sales_growth = execute_sql_query(sql_query)

# Create a bar chart to visualize sales growth
fig = px.bar(df_sales_growth, x='FirstName', y='SalesGrowth', color='SalesGrowth',
             title='Top 5 Employees by Sales Growth',
             labels={'SalesGrowth': 'Sales Growth', 'FirstName': 'Employee Name'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get sales data for the last year grouped by employee
sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    e.EmployeeID, OrderMonth
ORDER BY 
    e.EmployeeID, OrderMonth
""""""

sales_data = execute_sql_query(sql_query)

# Calculate sales growth for each employee
sales_growth = sales_data.pivot(index='EmployeeID', columns='OrderMonth', values='TotalSales').fillna(0)
sales_growth['Growth'] = sales_growth.iloc[:, -1] - sales_growth.iloc[:, 0]  # Last month - First month
top_growth_employees = sales_growth.nlargest(5, 'Growth').reset_index()

# Visualization of the top 5 employees with the highest sales growth
fig = px.bar(top_growth_employees, 
             x='EmployeeID', 
             y='Growth', 
             title='Top 5 Employees with Highest Sales Growth Over the Last Year',
             labels={'EmployeeID': 'Employee ID', 'Growth': 'Sales Growth'},
             text='Growth')

show_to_user(fig)
```","The input code calculates sales growth based on monthly sales data over the last year, while the reference implementation calculates sales growth comparing the total sales of the current year with last year. The logic of calculating growth is different in both codes; therefore, the solution does not adhere to the same logic as the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve top 5 employees with highest sales growth
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
    ((SUM(CASE WHEN EXTRACT(YEAR FROM orders.OrderDate) = 2023 THEN [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) ELSE 0 END) - 
    SUM(CASE WHEN EXTRACT(YEAR FROM orders.OrderDate) = 2022 THEN [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) ELSE 0 END)) / 
    NULLIF(SUM(CASE WHEN EXTRACT(YEAR FROM orders.OrderDate) = 2022 THEN [Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount) ELSE 0 END), 0)) * 100 AS SalesGrowth 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE 
    orders.OrderDate BETWEEN '2022-01-01' AND '2023-12-31' 
GROUP BY 
    employees.EmployeeID, EmployeeName 
ORDER BY 
    SalesGrowth DESC 
LIMIT 5;
""""""

# Execute the query and get results
top_employees_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    top_employees_df,
    x='EmployeeName',
    y='SalesGrowth',
    title='Top 5 Employees by Sales Growth (2022-2023)',
    labels={'SalesGrowth': 'Sales Growth (%)'},
)

# Display the chart
show_to_user(fig)
```","The input code calculates sales growth as a percentage by comparing the sales of 2022 and 2023, which differs from the reference code that calculates absolute sales growth. Additionally, the input code filters on orders within 2022-2023, potentially excluding needed data for growth calculation.",None
"What is the total inventory value for each category, and can you visualize this data using a bar chart?","```python
import pandas as pd
import plotly.express as px

# Assume this function is provided
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would interact with the database and return a DataFrame.
    pass

def show_to_user(data):
    # This function would display the data or figure to the user.
    pass

# SQL query to get the total inventory value for each category
sql_query = """"""
SELECT CategoryID, SUM(UnitPrice * UnitsInStock) AS InventoryValue 
FROM products 
GROUP BY CategoryID;
""""""

# Execute the SQL query and get a DataFrame
df_inventory = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df_inventory,
    x='CategoryID',
    y='InventoryValue',
    title='Total Inventory Value by Category',
    labels={'InventoryValue': 'Inventory Value', 'CategoryID': 'Category ID'}
)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.CategoryID, 
       SUM(p.UnitsInStock * p.UnitPrice) AS TotalInventoryValue
FROM products p
GROUP BY p.CategoryID;
""""""

inventory_value_df = execute_sql_query(sql_query)

fig = px.bar(inventory_value_df, 
             x='CategoryID', 
             y='TotalInventoryValue', 
             title='Total Inventory Value by Category',
             labels={'CategoryID': 'Category ID', 'TotalInventoryValue': 'Total Inventory Value'})

show_to_user(fig)
```","The input Python code follows the same logic as the reference implementation. Both codes execute an SQL query to calculate the total inventory value for each product category by multiplying the UnitPrice and UnitsInStock, grouping the results by CategoryID. Subsequently, both create a bar chart with Plotly to visualize the inventory values by category, labeling appropriately, and display the chart using a function. The small differences in SQL aliasing and column names do not affect the correctness of the logic or outcome.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL query execution
    pass

def show_to_user(data):
    # Placeholder for displaying data
    pass

# SQL query to fetch category and total inventory value
sql_query = '''
SELECT c.CategoryID, SUM(p.UnitPrice * p.UnitsInStock) AS InventoryValue
FROM products p
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID;
'''

# Execute the SQL query and get the result in a DataFrame
inventory_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(inventory_df, x='CategoryID', y='InventoryValue', 
             title='Total Inventory Value by Category', 
             labels={'InventoryValue': 'Inventory Value', 'CategoryID': 'Category ID'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly answers the business analytics request of calculating total inventory value by category and visualizing it using a bar chart. It uses an SQL query to retrieve the necessary data, albeit with an additional JOIN on the 'categories' table, which doesn't affect the result if the 'CategoryID' is present in both tables with a one-to-one relationship. The implementation adheres to the same logical steps as the reference.",both
"What are the total sales by supplier and month, and can you provide a bar chart visualizing these sales?","
```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the data
sql_query = """"""
SELECT 
    SupplierID, 
    EXTRACT(MONTH FROM o.OrderDate) AS Month, 
    SUM(od.Quantity * od.UnitPrice) AS MonthlySales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY SupplierID, Month;
""""""

# Retrieve the data as a pandas DataFrame
data = execute_sql_query(sql_query)

# No need for extra grouping since SQL already aggregates

# Create a bar chart using Plotly
fig = px.bar(
    data, 
    x='Month', 
    y='MonthlySales', 
    color='SupplierID', 
    title='Total Sales by Supplier and Month',
    labels={'MonthlySales': 'Total Sales', 'Month': 'Month'},
    barmode='group'
)

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.SupplierID,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.SupplierID, Month
ORDER BY 
    Month, p.SupplierID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='Month', y='TotalSales', color='SupplierID', 
             title='Total Sales by Supplier and Month', 
             labels={'TotalSales': 'Total Sales', 'Month': 'Month', 'SupplierID': 'Supplier ID'})

show_to_user(fig)
```","The input code uses DATE_FORMAT which aggregates by year-month, while the reference code uses EXTRACT(MONTH) without year consideration, resulting in potential aggregation across different years. Additionally, the input code includes a discount calculation within the SUM, which the reference implementation doesn't account for.","
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, 
       DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY suppliers.SupplierID, Month;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    sales_data, 
    x='Month', 
    y='TotalSales', 
    color='CompanyName', 
    title='Total Sales by Supplier and Month',
    labels={'TotalSales': 'Total Sales', 'Month': 'Month'},
    barmode='group'
)

# Display the bar chart to the user
show_to_user(fig)
",The evaluated code calculates TotalSales using a different formula compared to the reference code and uses a different grouping column ('Month' formatted with '%Y-%m' instead of extracting just the month). The inclusion of discounts in TotalSales calculations and the use of 'CompanyName' instead of 'SupplierID' also deviates from the reference logic.,None
Determine the average discount offered on the products from each supplier and create a bar chart to visualize these discounts by supplier.,"```python
import plotly.express as px
import pandas as pd

# SQL query to fetch the average discount offered by each supplier
sql_query = """"""
SELECT p.SupplierID, AVG(od.Discount) AS AvgDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
GROUP BY p.SupplierID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize average discounts by supplier
fig = px.bar(df, x='SupplierID', y='AvgDiscount', title='Average Discount by Supplier', labels={'AvgDiscount': 'Average Discount', 'SupplierID': 'Supplier ID'})

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, AVG(od.Discount) AS AverageDiscount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.CompanyName
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='CompanyName', y='AverageDiscount', title='Average Discount by Supplier')
show_to_user(fig)
```","The provided code answers the business analytics request by calculating the average discount for products from each supplier and creating a bar chart. Though it uses 'CompanyName' instead of 'SupplierID', it follows the same logic as the reference implementation, joining the necessary tables and grouping by the supplier. Both implementations return the same insights relevant for visualization and analysis of discounts by supplier.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT s.SupplierID, AVG(od.Discount) AS AvgDiscount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN ""Order Details"" od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID;
""""""

# Execute the SQL query and get the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize average discounts by supplier
fig = px.bar(df, x='SupplierID', y='AvgDiscount',
             title='Average Discount by Supplier',
             labels={'AvgDiscount': 'Average Discount', 'SupplierID': 'Supplier ID'},
             template='plotly')

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly calculates the average discount offered by suppliers using a SQL query. It joins the 'suppliers', 'products', and 'Order Details' tables to compute the average discount for each supplier, which is consistent with the reference logic. Both the input and reference code use `plotly.express` to create a bar chart for visualization, with appropriate labels and titles. Hence, the implementation adheres to the same logic as the reference code.",both
"What is the average order fulfillment time per month, and can you provide a line chart showing trends over the months?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, 
       AVG(DATEDIFF(day, OrderDate, ShippedDate)) AS AverageFulfillmentTime 
FROM orders 
WHERE ShippedDate IS NOT NULL 
GROUP BY Month;
""""""

# Execute the query
data = execute_sql_query(sql_query)

# Ensure 'Month' column is in datetime format for proper plotting
data['Month'] = pd.to_datetime(data['Month'])

# Create a line chart to show average fulfillment time per month
fig = px.line(data, x='Month', y='AverageFulfillmentTime', title='Average Order Fulfillment Time Per Month')

# Display the line chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS Avg_Fulfillment_Time
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='Month', y='Avg_Fulfillment_Time', title='Average Order Fulfillment Time per Month')
show_to_user(fig)
```","The input code differs in key areas: it uses DATE_FORMAT instead of DATE_TRUNC, which might not group months the same in SQL; it doesn't check for ShippedDate IS NOT NULL, potentially including incomplete orders in the average.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # This should connect to a database, execute the query, and return the result as a DataFrame
    pass

# Utility function to display data analysis or visualization results
def show_to_user(data):
    # Placeholder for displaying data or figures
    # This should handle both DataFrame display and Plotly figure rendering
    pass

# SQL query to get average order fulfillment time per month
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS FulfillmentTime 
FROM orders 
GROUP BY Month;
""""""

# Execute the SQL query and get the result as a DataFrame
df_fulfillment_time = execute_sql_query(sql_query)

# Convert the 'Month' column to datetime format for proper plotting
df_fulfillment_time['Month'] = pd.to_datetime(df_fulfillment_time['Month'])

# Create a line chart using Plotly
fig = px.line(
    df_fulfillment_time, 
    x='Month', 
    y='FulfillmentTime',
    title='Average Order Fulfillment Time Per Month',
    labels={'FulfillmentTime': 'Avg Fulfillment Time (Days)'},
    markers=True
)

# Display the line chart
show_to_user(fig)
```","The input code has a couple of key differences from the reference implementation. Firstly, it uses `DATE_FORMAT` instead of `DATE_TRUNC`, which may affect the date grouping depending on the SQL dialect. Secondly, it does not include a check for `ShippedDate IS NOT NULL` in the SQL query, which means it might include orders that haven't been shipped when calculating the average fulfillment time. This diverges from the logic of the reference, potentially skewing results.",None
Analyze the sales trend for products over the last quarter and include a line chart to visualize the trend.,"```python
# Import necessary libraries
import pandas as pd
import plotly.express as px

# SQL query to get sales data
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, 
       SUM(Quantity * UnitPrice) AS TotalSales 
FROM [Order Details] 
WHERE OrderDate >= DATEADD(MONTH, -3, CURRENT_DATE) 
GROUP BY EXTRACT(MONTH FROM OrderDate);
""""""

# Execute the SQL query and store the result into a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a line chart to visualize the sales trend
fig = px.line(sales_data, x='Month', y='TotalSales', title='Sales Trend Over Last Quarter')

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the date range for the last quarter
end_date = datetime.now()
start_date = end_date - timedelta(days=90)

# SQL query to retrieve sales data for the last quarter
sql_query = f""""""
SELECT 
    DATE(OrderDate) AS SaleDate,
    SUM(od.Quantity * od.UnitPrice) AS TotalSales
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate BETWEEN '{start_date.strftime(""%Y-%m-%d"")}' AND '{end_date.strftime(""%Y-%m-%d"")}' 
GROUP BY 
    DATE(OrderDate)
ORDER BY 
    SaleDate;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a line chart to visualize the sales trend
fig = px.line(sales_data, x='SaleDate', y='TotalSales', title='Sales Trend Over Last Quarter', labels={'TotalSales': 'Total Sales ($)', 'SaleDate': 'Date'})
show_to_user(fig)
```","The provided code uses a date range of 90 days for the last quarter, whereas the reference implementation uses the EXTRACT(MONTH) function to correctly summarize by month over the last three months. The date aggregation differs from the reference, which groups by month. Additionally, the SQL queries differ in their approach to extracting data; the provided code uses DATE(OrderDate) for daily aggregation, not monthly as required by the business request.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT p.ProductID,
    SUM(od.Quantity) AS total_quantity,
    EXTRACT(MONTH FROM o.OrderDate) AS sales_month
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE o.OrderDate >= DATEADD(QUARTER, -1, CURRENT_DATE)
GROUP BY p.ProductID, sales_month
ORDER BY sales_month
""""""

# Execute the SQL query to get the data

df_sales_trend = execute_sql_query(sql_query)

# Create a line chart to visualize the trend
fig = px.line(
    df_sales_trend,
    x='sales_month',
    y='total_quantity',
    color='ProductID',
    title='Sales Trend for Products Over the Last Quarter',
    labels={
        'sales_month': 'Month',
        'total_quantity': 'Total Quantity Sold',
        'ProductID': 'Product ID'
    }
)

# Display the line chart to the user
show_to_user(fig)
```","The reference code analyzes the total sales amount (Quantity * UnitPrice) by month over the last quarter. It focuses on aggregated sales data without considering individual products. The provided input code, however, calculates the total quantity sold per product per month, adding a dimension of product detail and using total quantity instead of sales amount. Additionally, the input code uses DATEADD with QUARTER, which might not align with a 3-month period as intended in the reference implementation.",None
Calculate the total number of orders for each shipping country and create a bar chart to visualize the results.,"
import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT ShipCountry, COUNT(*) AS NumberOfOrders 
FROM orders 
GROUP BY ShipCountry;
""""""

# Utility function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query):
    # This function needs to be implemented. Assuming it connects to a database and returns a DataFrame.
    # Example implementation could use a connection string and pandas read_sql_query.
    pass

# Fetch the data
orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(orders_df, x='ShipCountry', y='NumberOfOrders', 
             title='Total Number of Orders by Shipping Country',
             labels={'ShipCountry': 'Shipping Country', 'NumberOfOrders': 'Total Number of Orders'})

# Display the result to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, COUNT(OrderID) AS TotalOrders
FROM orders
GROUP BY ShipCountry
""""""

order_counts = execute_sql_query(sql_query)

fig = px.bar(order_counts, x='ShipCountry', y='TotalOrders', title='Total Number of Orders by Shipping Country')
show_to_user(fig)
```","The input Python code accurately retrieves the total number of orders for each shipping country using a SQL query, by counting the 'OrderID'. It then correctly creates a bar chart using Plotly, similar to the reference implementation which counts orders using COUNT(*). Both achieve the same result logically, displaying the total number of orders per shipping country.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total number of orders for each shipping country
sql_query = ""SELECT ShipCountry, COUNT(OrderID) AS TotalOrders FROM orders GROUP BY ShipCountry;""

# Execute the SQL query using the provided utility function to get the results
orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total number of orders for each shipping country
fig = px.bar(orders_df, x='ShipCountry', y='TotalOrders', title='Total Orders by Shipping Country', labels={'TotalOrders': 'Total Orders', 'ShipCountry': 'Shipping Country'})

# Display the bar chart
show_to_user(fig)
```","The input code correctly implements the business analytics request. It executes an SQL query to calculate the total number of orders for each shipping country, similar to the reference code. The key difference, selecting 'COUNT(OrderID) AS TotalOrders' instead of 'COUNT(*) AS NumberOfOrders', does not affect the logic as both will yield the count of orders. Furthermore, it correctly uses Plotly to create and display a bar chart with the desired labels and title, matching the functionality of the reference code.",both
Identify customers who have placed more than 10 orders and visualize the distribution of these customers by location.,"```python
import pandas as pd
import plotly.express as px

# Assume these utility functions are provided
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulation of SQL execution, actual implementation not provided
    pass

def show_to_user(data):
    # Simulation of data display, actual implementation not provided
    pass

# SQL query to select customers with more than 10 orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS order_count
FROM orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 10;
""""""

# Execute the query and get a DataFrame
customers_df = execute_sql_query(sql_query)

# SQL query to get customer location info
sql_query_location = """"""
SELECT CustomerID, Location
FROM customers
""""""

# Execute the query and get a DataFrame
locations_df = execute_sql_query(sql_query_location)

# Merge the two DataFrames to associate locations with the customer data
merged_df = pd.merge(customers_df, locations_df, on='CustomerID')

# Visualize the distribution of customers by location using a bar chart
fig = px.bar(merged_df, x='Location', y='order_count',
             title='Distribution of Customers with More Than 10 Orders by Location',
             labels={'order_count': 'Number of Customers', 'Location': 'Location'})

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.CustomerID,
    o.ShipCity,
    o.ShipCountry,
    COUNT(o.OrderID) AS OrderCount
FROM 
    orders o
GROUP BY 
    o.CustomerID, o.ShipCity, o.ShipCountry
HAVING 
    COUNT(o.OrderID) > 10
""""""

customers_with_orders = execute_sql_query(sql_query)

if not customers_with_orders.empty:
    fig = px.histogram(customers_with_orders, 
                       x='ShipCity', 
                       color='ShipCountry', 
                       title='Distribution of Customers with More than 10 Orders by Location')
    show_to_user(fig)
```","The provided code does not correctly follow the logic of the reference implementation. The reference implementation merges customer order counts with location data using a separate location query, ensuring a direct link between CustomerID and location. In contrast, the input code tries to gather location data (ShipCity, ShipCountry) within the initial query, grouping by these fields, which could lead to incorrect aggregation and doesn't ensure merging with explicit location details. Additionally, the reference code visualizes the data with a bar chart showing order counts, while the input code uses a histogram with color differentiation by country, leading to a different representation of the data.","```python
import pandas as pd
import plotly.express as px

# Function to get customers with more than 10 orders
def get_customers_with_many_orders():
    # SQL query to find customers with more than 10 orders
    sql_query = """"""
    SELECT c.CustomerID, c.City, c.Country
    FROM customers c
    JOIN orders o ON c.CustomerID = o.CustomerID
    GROUP BY c.CustomerID
    HAVING COUNT(o.OrderID) > 10;
    """"""
    # Execute the SQL query and get a DataFrame
    df_customers = execute_sql_query(sql_query)
    return df_customers

# Function to visualize the distribution of these customers by location
def visualize_customer_distribution(df_customers):
    # Group by City, Country and count the number of customers
    df_distribution = df_customers.groupby(['City', 'Country']).size().reset_index(name='NumCustomers')
    # Create a bar plot using Plotly
    fig = px.bar(df_distribution, x='City', y='NumCustomers', color='Country',
                 title='Distribution of Customers with More than 10 Orders by Location')
    # Show the plot
    show_to_user(fig)

# Main flow of execution
customers_df = get_customers_with_many_orders()
visualize_customer_distribution(customers_df)
```","The input Python code correctly identifies customers with more than 10 orders by using a SQL query that joins the 'customers' and 'orders' tables, groups by 'CustomerID', and applies a having clause. It then visualizes the distribution by grouping customers by 'City' and 'Country', similar to how the reference implementation merges customers and orders information and groups by location. Both implementations produce a bar chart showing the distribution of these customers by location, fulfilling the business analytics request successfully.",Finetuned
"What is the distribution of employee hire dates by year, and can you provide a bar chart to visualize this distribution?","```python
import plotly.express as px

def execute_sql_query(sql_query: str):
    # This is a mock-up function that simulates the execution of an SQL query
    # In practice, this function should connect to the database and execute the query
    import pandas as pd
    data = {'HireYear': [2015, 2016, 2017, 2018, 2019, 2020],
            'HireCount': [50, 60, 75, 85, 90, 95]}
    return pd.DataFrame(data)

def show_to_user(data):
    # This function should properly display the data or visualization to the user
    # In practice, ensure that the environment supports Plotly visualization display
    if isinstance(data, px.Figure):
        data.show()
    else:
        print(data)

# SQL query to get the hire date distribution by year
sql_query = """"""
SELECT YEAR(HireDate) AS HireYear, COUNT(EmployeeID) AS HireCount 
FROM employees 
GROUP BY YEAR(HireDate);
""""""

# Execute the SQL query to get the data as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of hire dates by year
fig = px.bar(df, x='HireYear', y='HireCount', title='Distribution of Employee Hire Dates by Year')

# Show the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to extract hire dates from the employees table
sql_query = """"""
SELECT YEAR(HireDate) AS HireYear, COUNT(*) AS EmployeeCount
FROM employees
GROUP BY YEAR(HireDate)
ORDER BY HireYear
""""""

# Execute the SQL query and get the data
hire_date_distribution = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of hire dates by year
fig = px.bar(hire_date_distribution, x='HireYear', y='EmployeeCount', 
             labels={'HireYear': 'Year of Hire', 'EmployeeCount': 'Number of Employees'},
             title='Distribution of Employee Hire Dates by Year')

# Show the chart to the user
show_to_user(fig)
```","The provided code accurately fulfills the business request by executing an SQL query to obtain the number of employee hires per year, grouping them, and visualizing the data with a bar chart using Plotly. The logic matches the reference implementation, where the chart creation process and data querying are functionally equivalent. Both approaches correctly aggregate and visualize the distribution of hire dates by year.","```python
import plotly.express as px

# SQL Query to get the distribution of hire dates by year
sql_query = """"""
SELECT YEAR(hire_date) AS year, COUNT(employee_id) AS num_hired 
FROM employees 
GROUP BY YEAR(hire_date);
""""""

# Execute the SQL query using the utility function to obtain a DataFrame
hire_date_distribution_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the distribution
fig = px.bar(
    hire_date_distribution_df,
    x='year',
    y='num_hired',
    title='Distribution of Employee Hire Dates by Year',
    labels={'year': 'Year', 'num_hired': 'Number Hired'},
    text='num_hired'
).update_traces(textposition='outside')

# Show the bar chart to the user using the specified utility function
show_to_user(fig)
```","The input Python code correctly executes an SQL query to retrieve the distribution of employee hire dates by year and creates a bar chart using Plotly, similar to the reference implementation. Differences in variable names (e.g., 'year' vs 'HireYear') and additional Plotly options (e.g., 'labels', 'text', 'textposition') don't affect the correctness as they adhere to equivalent logic and enhance visualization.",both
"Which products have more units on order than units currently in stock, and can this be visualized in a bar chart to compare the quantities?","```python
import pandas as pd
import plotly.express as px

# Business Analytic Request Function
def analyze_and_visualize_products():
    # SQL query to find products with more units on order than units in stock
    sql_query = ""SELECT ProductName, UnitsOnOrder, UnitsInStock FROM products WHERE UnitsOnOrder > UnitsInStock;""
    
    # Execute the SQL query and store the result in a pandas DataFrame
    df = execute_sql_query(sql_query)
    
    # Ensure our DataFrame is not empty
    if not df.empty:
        # Create a bar chart using Plotly
        fig = px.bar(
            df,
            x='ProductName',
            y=['UnitsOnOrder', 'UnitsInStock'],
            title='Comparison of Units On Order and Units In Stock',
            labels={'value': 'Units', 'variable': 'Category'},
            barmode='group'
        )
        
        # Display the visualization
        show_to_user(fig)
    else:
        # If the DataFrame is empty, display a message
        show_to_user(pd.DataFrame({""Message"": [""No products have more units on order than units in stock.""]}))

# Execute the analysis and visualization
analyze_and_visualize_products()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, UnitsOnOrder
FROM products
WHERE UnitsOnOrder > UnitsInStock
""""""

products_on_order = execute_sql_query(sql_query)

fig = px.bar(products_on_order, x='ProductName', y=['UnitsInStock', 'UnitsOnOrder'],
             title='Products with Units on Order Greater than Units in Stock',
             labels={'value': 'Quantity', 'variable': 'Category'},
             barmode='group')

show_to_user(fig)
```","Both implementations perform the same task of querying products where 'UnitsOnOrder' are greater than 'UnitsInStock' and display a bar chart for comparison. The input code retrieves necessary columns, executes the SQL query, and displays the comparison in a grouped bar chart using Plotly, adhering to the logic outlined in the reference implementation. The differences in variable names and chart labels are stylistic and do not affect the correctness of the analysis.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductName, UnitsInStock, UnitsOnOrder
FROM products
WHERE UnitsOnOrder > UnitsInStock;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the quantities
fig = px.bar(products_df, 
             x='ProductName', 
             y=['UnitsInStock', 'UnitsOnOrder'],
             labels={'value': 'Quantity', 'variable': 'Type'},
             title='Products with More Units on Order than Units in Stock')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code correctly answers the business analytics request. It follows the same logic as the reference implementation: both retrieve products with more units on order than in stock using a similar SQL query, execute the query to get a DataFrame, and create a bar chart using Plotly to visualize the comparison of units on order vs units in stock. The differences in column order and label naming do not affect the correctness.",both
Identify the most common shipping method used by each employee and visualize the distribution of methods across employees with a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user utilities are already implemented

# Define the SQL query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, o.ShipVia, COUNT(o.OrderID) as ShipMethodCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, o.ShipVia
ORDER BY ShipMethodCount DESC;
""""""

# Execute the SQL query to get the DataFrame
df = execute_sql_query(sql_query)

# Find the most common shipping method used by each employee
most_common_shipping = df.loc[df.groupby('EmployeeID')['ShipMethodCount'].idxmax()].reset_index(drop=True)

# Create a bar chart to visualize the distribution of shipping methods across employees
fig = px.bar(df, x='EmployeeID', y='ShipMethodCount', color='ShipVia',
             title='Distribution of Shipping Methods Across Employees',
             labels={'ShipMethodCount': 'Number of Orders', 'EmployeeID': 'Employee ID', 'ShipVia': 'Shipping Method'})

# Display the plot using show_to_user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the shipping method for each employee
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, o.ShipVia
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, o.ShipVia
""""""

# Execute the SQL query
employee_shipping = execute_sql_query(sql_query)

# Identify the most common shipping method per employee
most_common_shipping = employee_shipping.groupby(['EmployeeID', 'FirstName', 'LastName']).agg(
    MostCommonShippingMethod=('ShipVia', lambda x: x.mode()[0])
).reset_index()

# Count the distribution of shipping methods across all employees
shipping_distribution = most_common_shipping['MostCommonShippingMethod'].value_counts().reset_index()
shipping_distribution.columns = ['ShippingMethod', 'Count']

# Visualize the distribution with a bar chart
fig = px.bar(shipping_distribution, x='ShippingMethod', y='Count', title='Distribution of Most Common Shipping Method by Employees', labels={'ShippingMethod': 'Shipping Method', 'Count': 'Number of Employees'})
show_to_user(fig)
```","The input code does not correctly implement the business request. The reference code computes the most common shipping method per employee based on the count of orders and visualizes the distribution of shipping methods across employees. However, the input code incorrectly calculates the most common shipping method using only the mode of 'ShipVia' without considering the count of orders. Additionally, the visualization in the input code aggregates by 'MostCommonShippingMethod' across employees rather than showing the distribution per employee as in the reference code.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Sample placeholder function for executing SQL queries.
    # In practice, this function would interact with a database to return results as a DataFrame.
    pass

def show_to_user(data):
    # Sample placeholder function to display data or figures.
    # In practice, this would display a DataFrame or Plotly figure to the user.
    pass

# SQL Query to fetch employee shipping method data
sql_query = '''
SELECT e.EmployeeID,
       o.ShipVia,
       COUNT(o.OrderID) AS MethodCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, o.ShipVia;
'''

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Identify the most common shipping method for each employee
common_methods = df.loc[df.groupby('EmployeeID')['MethodCount'].idxmax()]

# Correctly plot a bar chart showing the distribution of the shipping methods
fig = px.bar(common_methods, x='EmployeeID', y='MethodCount', color='ShipVia',
             title=""Most Common Shipping Method by Employee"",
             labels={'MethodCount': 'Count', 'EmployeeID': 'Employee ID', 'ShipVia': 'Shipping Method'})

# Display the visualization using the utility function
show_to_user(fig)
```","The evaluated code mistakenly visualizes only the most common shipping method for each employee, instead of the distribution of all shipping methods across employees, as required by the business request. It filters the DataFrame to the most common method before creating the bar chart, while the request specifies a chart that includes all methods for comparison.",None
Identify the top 5 best-selling products last quarter and provide a bar chart for better visualization.,"```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT 
    products.ProductName, 
    SUM([Order Details].Quantity) AS total_quantity_sold 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
JOIN 
    products ON [Order Details].ProductID = products.ProductID 
WHERE 
    orders.OrderDate BETWEEN DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH) AND CURRENT_DATE 
GROUP BY 
    products.ProductID 
ORDER BY 
    total_quantity_sold DESC 
LIMIT 5
""""""

# Execute the SQL query and load the results into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df, 
    x='ProductName', 
    y='total_quantity_sold', 
    title='Top 5 Best-Selling Products Last Quarter',
    labels={'ProductName':'Product Name', 'total_quantity_sold':'Total Quantity Sold'},
    text='total_quantity_sold',
)

# Update layout for better appearance
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS total_sold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN DATEADD(QUARTER, -1, GETDATE()) AND GETDATE()
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sold DESC
LIMIT 5
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='total_sold', title='Top 5 Best-Selling Products Last Quarter')
show_to_user(fig)
```","The input code uses 'DATEADD(QUARTER, -1, GETDATE())' which is not the same as 'DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)' from the reference code. The date calculation should use the last 3 months, but depending on the database system used, 'DATEADD(QUARTER, -1, GETDATE())' might not align with this. Moreover, 'DATEADD' and 'GETDATE()' are SQL Server specific functions, while 'DATE_SUB' and 'CURRENT_DATE' are more commonly used in MySQL. The SQL query's logic needs to be adjusted to align date calculations correctly. Despite these differences, the rest of the code for plotting and displaying the bar chart is consistent.","```python
import plotly.express as px

# Assuming execute_sql_query and show_to_user are implemented
sql_query = """"""
SELECT OrderDetails.ProductID, SUM(OrderDetails.Quantity) AS TotalSold 
FROM OrderDetails 
JOIN orders ON OrderDetails.OrderID = orders.OrderID 
WHERE QUARTER(orders.OrderDate) = QUARTER(CURDATE()) - 1 
AND YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY OrderDetails.ProductID 
ORDER BY TotalSold DESC 
LIMIT 5
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='TotalSold', title='Top 5 Best-Selling Products Last Quarter')

# Display the figure
show_to_user(fig)
```","The input code lacks the join with the 'products' table to retrieve and display the product name instead of the product ID. It also incorrectly calculates the last quarter sales by checking if the current quarter minus one matches the order date's quarter, which does not handle the year transition correctly. The reference code uses a date range to accurately capture the last three months.",None
"What is the breakdown of total sales by shipment countries, and can you provide a bar chart to visualize the distribution?","import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT orders.ShipCountry, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity *
           (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY orders.ShipCountry
""""""

# Execute the SQL query to get the data
data_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data_df, x='ShipCountry', y='total_sales', title='Total Sales by Shipment Countries')

# Display the bar chart
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY ShipCountry
""""""

sales_by_country = execute_sql_query(sql_query)

fig = px.bar(sales_by_country, x='ShipCountry', y='total_sales', title='Total Sales by Shipment Countries', labels={'total_sales':'Total Sales', 'ShipCountry':'Shipment Country'})
show_to_user(fig)
```","The input Python code correctly answers the business analytics request and follows the same logic as the reference implementation. The SQL query executed is the same, aggregating sales by ShipCountry. A bar chart is created with Plotly using the aggregated data, and the chart is displayed with the same title as the reference implementation.","```python
import plotly.express as px

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str):
    # Placeholder function body, to be implemented accordingly
    pass

# Function to display the bar chart
def show_to_user(data):
    # Placeholder function body, to be implemented accordingly
    pass
    
# SQL query from the business analytic request
sql_query = ""SELECT ShipCountry, "" \
            ""SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS CountrySales "" \
            ""FROM orders "" \
            ""JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID "" \
            ""GROUP BY ShipCountry "" \
            ""ORDER BY CountrySales DESC;""

# Execute the SQL query to get the data
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(sales_data, x='ShipCountry', y='CountrySales', title='Breakdown of Total Sales by Shipment Countries')

# Display the bar chart
show_to_user(fig)
```","The provided code achieves the same outcome as the reference implementation. It executes an SQL query to calculate total sales by ShipCountry and creates a bar chart using Plotly to visualize the sales distribution. The SQL logic is consistent with the reference, using a join between orders and Order Details tables, summing sales, and grouping by ShipCountry. Although there are minor differences, such as ordering by sales, these do not affect the correctness regarding the overall request and logic.",both
How many orders were placed by customers in the United States? Please include a bar chart showing the number of orders per state.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the number of orders per state in the United States
sql_query = """"""
SELECT c.State, COUNT(o.OrderID) AS OrdersPerState
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
WHERE c.Country = 'USA'
GROUP BY c.State;
""""""

# Execute the SQL query
orders_per_state_df = execute_sql_query(sql_query)

# Display the number of orders per state using a bar chart
fig = px.bar(
    orders_per_state_df,
    x='State',
    y='OrdersPerState',
    title='Number of Orders per State in the USA',
    labels={'OrdersPerState': 'Number of Orders', 'State': 'State'}
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to count orders placed by customers in the US and group by state
sql_query = """"""
SELECT c.Region, COUNT(o.OrderID) as OrderCount
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
WHERE c.Country = 'USA'
GROUP BY c.Region
""""""

# Execute the SQL query
orders_per_state = execute_sql_query(sql_query)

# Display the number of orders placed by customers in the United States
total_orders = orders_per_state['OrderCount'].sum()

# Create a bar chart for the number of orders per state
fig = px.bar(orders_per_state, x='Region', y='OrderCount', title='Number of Orders per State in the USA')
show_to_user(fig)

# Output the total number of orders
print(f""Total number of orders placed by customers in the United States: {total_orders}"")
```","The input code correctly counts and displays the number of orders placed by customers in the US, grouped by state (using 'Region' as equivalent to 'State'). The steps match the reference: executing a SQL query, grouping by state, and visualizing the data in a bar chart. The additional output of total orders is not contradictory to the requirement.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve order data for the United States
sql_query = """"""
SELECT 
    ShipRegion, 
    COUNT(OrderID) AS OrderCount 
FROM 
    orders 
WHERE 
    ShipCountry = 'United States'
GROUP BY 
    ShipRegion
""""""

# Execute the SQL query to get the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder function. The actual implementation should
    # connect to a database and execute the given query, returning a DataFrame.
    pass

order_data = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(order_data, x='ShipRegion', y='OrderCount', title='Number of Orders per State in the United States')

# Display the bar chart
def show_to_user(data):
    # This is a placeholder function. Ideally, it would check the type of data 
    # and display a DataFrame or Plotly fig accordingly.
    pass

show_to_user(fig)
```","The input code is correct in terms of functionality, as it retrieves the number of orders per state (ShipRegion) for customers in the United States (ShipCountry = 'United States') and generates a bar chart. Although the input code uses different column names and simplified database logic, it adheres to the same purpose and logic as the reference implementation.",both
"What is the total sales revenue by country, and can it be visualized using a bar chart for better comparison?","```python
import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT 
    orders.ShipCountry, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM 
    orders 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    orders.ShipCountry;
""""""

# Execute the SQL query to get the data
df_sales = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_sales, x='ShipCountry', y='TotalSales',
             title='Total Sales Revenue by Country',
             labels={'ShipCountry': 'Country', 'TotalSales': 'Total Sales Revenue'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM orders
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY ShipCountry
""""""

total_sales_by_country = execute_sql_query(sql_query)

fig = px.bar(total_sales_by_country, x='ShipCountry', y='TotalRevenue', title='Total Sales Revenue by Country', labels={'TotalRevenue': 'Total Sales Revenue', 'ShipCountry': 'Country'})
show_to_user(fig)
```","The input Python code correctly follows the logic and intention of the reference implementation. It accurately calculates the total sales revenue by country with the same SQL query, using SUM with correct multiplications to factor in unit price, quantity, and discount. Both implementations use Plotly to create a bar chart with appropriate labels and a title, fulfilling the business requirement of visualizing sales revenue by country. The output methods and variable names differ slightly but do not affect the correctness in terms of achieving the requested analysis.","```python
import pandas as pd
import plotly.express as px

# Given utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # This function should return a DataFrame containing the result of the SQL query
    pass

# Given utility function to show to the user
def show_to_user(data):
    # Placeholder for displaying data
    # This function might print or visualize the data
    pass

# SQL query to fetch total sales revenue by country
sql_query = """"""
SELECT customers.Country, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.Country;
""""""

# Execute the SQL query and get the results in a DataFrame
sales_data = execute_sql_query(sql_query)

# Visualize total sales revenue by country using a bar chart
fig = px.bar(sales_data, x='Country', y='TotalSales',
             title='Total Sales Revenue by Country',
             labels={'TotalSales': 'Total Sales', 'Country': 'Country'},
             template='plotly')

# Display the bar chart
show_to_user(fig)
```","The input code is not correct because it queries sales data using the 'customers.Country' as opposed to 'orders.ShipCountry' used in the reference implementation. This results in potentially different groupings. While both implementations join on the 'Order Details', the difference in grouping by 'Country' vs. 'ShipCountry' does not adhere to the same logic.",Base
"What is the total number of orders that have not been shipped, and can you visualize this with a bar chart showing the number of unshipped orders by order date?","
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are already defined

# SQL Query to get unshipped order counts by order date
sql_query = """"""
SELECT o.OrderDate, COUNT(o.OrderID) AS UnshippedOrders 
FROM orders o 
WHERE o.ShippedDate IS NULL 
GROUP BY o.OrderDate;
""""""

# Execute the SQL query and get the result in a DataFrame
unshipped_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(unshipped_orders_df, x='OrderDate', y='UnshippedOrders', 
             title='Unshipped Orders by Order Date',
             labels={'OrderDate': 'Order Date', 'UnshippedOrders': 'Number of Unshipped Orders'})

# Display the bar chart to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT OrderDate, COUNT(OrderID) AS UnshippedCount
FROM orders
WHERE ShippedDate IS NULL
GROUP BY OrderDate
ORDER BY OrderDate;
""""""

unshipped_orders_df = execute_sql_query(sql_query)

total_unshipped_orders = unshipped_orders_df['UnshippedCount'].sum()
print(""Total number of unshipped orders:"", total_unshipped_orders)

fig = px.bar(unshipped_orders_df, x='OrderDate', y='UnshippedCount', title='Number of Unshipped Orders by Order Date')
show_to_user(fig)
```","The provided input code correctly calculates the total number of unshipped orders by summing the 'UnshippedCount' column, which aligns with the business analytics request. It then visualizes the unshipped orders by order date using a bar chart, just like the reference implementation. The differences in column naming and output printing do not affect the correctness of the logic and output.","import pandas as pd
import plotly.express as px

# SQL query to get unshipped orders by order date
sql_query = """"""
SELECT OrderDate, COUNT(OrderID) AS UnshippedOrders
FROM orders
WHERE ShippedDate IS NULL
GROUP BY OrderDate
""""""

# Execute SQL query and get result in a DataFrame
unshipped_orders_df = execute_sql_query(sql_query)

# Create a bar chart showing unshipped orders by order date
fig = px.bar(unshipped_orders_df, x='OrderDate', y='UnshippedOrders',
             title='Number of Unshipped Orders by Order Date',
             labels={'OrderDate': 'Order Date', 'UnshippedOrders': 'Unshipped Orders'})

# Display the bar chart to the user
show_to_user(fig)
","The provided Python code accurately follows the logic and goals of the reference implementation. Both codes execute the same SQL query to count unshipped orders grouped by the order date, utilize Plotly to create a bar chart, and display that chart to the user. The differences in exact text for titles and labels do not alter the logic or outcome, which aligns with the business analytics request.",both
"What is the product with the highest unit price currently in stock, and can you provide a bar chart to compare unit prices of the top 5 products in stock?","import pandas as pd
import plotly.express as px

# SQL query to fetch product details with unit price
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice 
FROM products 
WHERE UnitsInStock > 0 
ORDER BY UnitPrice DESC 
LIMIT 5;
""""""

# Execute the SQL query using the utility function
result_df = execute_sql_query(sql_query)

# Find the product with the highest unit price
highest_unit_price_product = result_df.iloc[0]

# Prepare data for visualization (Top 5 products by UnitPrice)
fig = px.bar(result_df, 
             x='ProductName', 
             y='UnitPrice', 
             title='Top 5 Products by Unit Price in Stock',
             labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price'})

# Display the visualization
show_to_user(fig)

# Print details of the highest unit price product
show_to_user(pd.DataFrame([highest_unit_price_product]))","```python
import pandas as pd
import plotly.express as px

sql_highest_price = """"""
SELECT ProductID, ProductName, UnitPrice, UnitsInStock 
FROM products 
WHERE UnitsInStock > 0 
ORDER BY UnitPrice DESC 
LIMIT 1;
""""""

highest_price_product = execute_sql_query(sql_highest_price)

sql_top_5_prices = """"""
SELECT ProductID, ProductName, UnitPrice, UnitsInStock 
FROM products 
WHERE UnitsInStock > 0 
ORDER BY UnitPrice DESC 
LIMIT 5;
""""""

top_5_products = execute_sql_query(sql_top_5_prices)

fig = px.bar(top_5_products, x='ProductName', y='UnitPrice', title='Top 5 Products by Unit Price in Stock')
show_to_user(fig)

highest_price_product
```","The provided code correctly identifies the product with the highest unit price currently in stock by executing a SQL query with LIMIT 1. Then, it follows up with a correct query to fetch top 5 products in stock by unit price, and uses Plotly to create a bar chart for comparison, as requested. Despite minor differences, such as separate SQL queries for the highest product and top 5, the logic and output are consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assuming the utility function execute_sql_query is available
def execute_sql_query(sql_query):
    # Placeholder for actual SQL execution logic
    # For demonstration purposes, this function will return a dummy DataFrame
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C', 'Product D', 'Product E'],
        'UnitPrice': [50, 45, 30, 25, 10],
        'UnitsInStock': [10, 20, 30, 40, 50]
    }
    return pd.DataFrame(data)

# SQL query to find the product with the highest unit price
sql_query_highest_price = """"""
SELECT ProductName, UnitPrice 
FROM products 
ORDER BY UnitPrice DESC 
LIMIT 1;
""""""

# Get the product with the highest unit price
highest_price_product_df = execute_sql_query(sql_query_highest_price)

# Display the product with the highest unit price to the user
show_to_user(highest_price_product_df)

# SQL query to retrieve the top 5 products by unit price
sql_query_top_5_products = """"""
SELECT ProductName, UnitPrice 
FROM products 
ORDER BY UnitPrice DESC 
LIMIT 5;
""""""

# Get the top 5 products by unit price
top_5_products_df = execute_sql_query(sql_query_top_5_products)

# Plot a bar chart of the top 5 products by unit price
fig = px.bar(top_5_products_df, x='ProductName', y='UnitPrice', title='Top 5 Products by Unit Price')

# Display the bar chart to the user
show_to_user(fig)
```","The provided code does not filter products currently in stock, as required by the business analytics request. It retrieves products without considering the 'UnitsInStock > 0' condition specified in the reference implementation. Additionally, the code for getting the highest unit price only retrieves one product, while it should be within the context of products that are in stock.",Base
Identify the top 3 employees with the fastest average fulfillment time and create a bar chart to visualize their performance.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM orders 
WHERE ShippedDate IS NOT NULL 
GROUP BY EmployeeID 
ORDER BY AvgFulfillmentTime ASC 
LIMIT 3;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 3 employees with the fastest average fulfillment time
fig = px.bar(
    result_df,
    x='EmployeeID',
    y='AvgFulfillmentTime',
    title='Top 3 Employees with Fastest Average Fulfillment Time',
    labels={'EmployeeID': 'Employee ID', 'AvgFulfillmentTime': 'Average Fulfillment Time (days)'}
)

# Display the figure using the show_to_user utility
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, AVG(DATEDIFF(ShippedDate, OrderDate)) AS Avg_Fulfillment_Time
FROM orders
GROUP BY EmployeeID
ORDER BY Avg_Fulfillment_Time ASC
LIMIT 3;
""""""

top_employees = execute_sql_query(sql_query)

fig = px.bar(top_employees, x='EmployeeID', y='Avg_Fulfillment_Time',
             title='Top 3 Employees with Fastest Average Fulfillment Time',
             labels={'EmployeeID': 'Employee ID', 'Avg_Fulfillment_Time': 'Average Fulfillment Time (Days)'})

show_to_user(fig)
```","The provided Python code does not include a condition to check for non-null 'ShippedDate' values, which is present in the reference implementation. This condition is necessary to ensure that only completed orders are considered in the average fulfillment time calculation. Without this condition, orders that have not been shipped will be included, potentially skewing the results.","```python
import pandas as pd
import plotly.express as px

# Assume the execute_sql_query and show_to_user utility functions are already defined

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_fulfillment_time 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID 
ORDER BY avg_fulfillment_time ASC 
LIMIT 3;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Prepare the bar chart using Plotly
fig = px.bar(df, 
             x='EmployeeID', 
             y='avg_fulfillment_time', 
             title='Top 3 Employees by Fastest Average Fulfillment Time',
             labels={'avg_fulfillment_time': 'Avg Fulfillment Time (Days)'})

# Display the chart
show_to_user(fig)
```",Both the reference and input code calculate the top 3 employees with the fastest average fulfillment time. The input code uses a JOIN between employees and orders tables but otherwise adheres to the same logic by grouping by EmployeeID and ordering by average fulfillment time in ascending order. The visualization step also matches with an appropriate Plotly bar chart.,Finetuned
"What is the percentage of orders delivered on or before the required date each month, and can you provide a monthly trend visualization of these percentages?","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', orders.OrderDate) AS Month, 
       (COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 100.0 / COUNT(orders.OrderID)) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY Month
""""""

# Execute the query and retrieve the data as a pandas DataFrame
df = execute_sql_query(sql_query)

# Ensure the Month column is of datetime type for accurate plotting
df['Month'] = pd.to_datetime(df['Month'])

# Create a monthly trend visualization of on-time delivery percentages
fig = px.line(df, x='Month', y='OnTimeDeliveryRate', title='Monthly On-Time Delivery Rate',
              labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'Month': 'Month'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeDeliveries
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

df = execute_sql_query(sql_query)

df['OnTimeDeliveryPercentage'] = (df['OnTimeDeliveries'] / df['TotalOrders']) * 100

fig = px.line(df, x='Month', y='OnTimeDeliveryPercentage', title='Monthly On-time Delivery Rate Percentage', labels={'OnTimeDeliveryPercentage': 'On-time Delivery Percentage'})
show_to_user(fig)
```","The input code calculates the percentage of orders delivered on or before the required date each month and plots this data, which matches the business analytics request and follows the same logic as the reference code. Both codes group orders by month, calculate the on-time delivery percentage, and visualize the trend. The difference in SQL syntax (DATE_FORMAT vs DATE_TRUNC) is due to potential differences in SQL dialects, but the logic remains consistent.","Sure! To fulfill the business analytic request, we need to perform the following steps:

1. Execute the SQL query to get the percentage of orders delivered on or before the required date each month.
2. Process the result to create a time series dataset.
3. Generate a visualization of the monthly trend.
4. Display the visualization to the user.

Here is the Python code that performs these steps. Please ensure that the `execute_sql_query` and `show_to_user` functions are predefined, as this example assumes they are available in the Python environment.

```python
import pandas as pd
import plotly.express as px

# Execute the SQL query
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth, 
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) / COUNT(OrderID) * 100 AS OnTimeDeliveryRate 
FROM 
    orders 
GROUP BY 
    OrderMonth
""""""
orders_df = execute_sql_query(sql_query)

# Convert OrderMonth to datetime for proper plotting
orders_df['OrderMonth'] = pd.to_datetime(orders_df['OrderMonth'])

# Create a line plot for the monthly trend of on-time delivery rate
fig = px.line(
    orders_df, 
    x='OrderMonth', 
    y='OnTimeDeliveryRate',
    title='Monthly On-Time Delivery Rate Trend',
    labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)', 'OrderMonth': 'Order Month'},
    markers=True
)

# Show the plot to the user
show_to_user(fig)
```

### Explanation:
1. **SQL Query Execution**: The given SQL query is executed using the utility function `execute_sql_query()`, and the result is stored in a pandas DataFrame (`orders_df`).
  
2. **Processing Data**: The date format is converted to ensure proper time series plotting.

3. **Visualization**: We use Plotly to create an interactive line plot that illustrates the trend of the on-time delivery rate over the months.

4. **Displaying**: Finally, the visualization is displayed to the user using `show_to_user()`.","The input code correctly addresses the business analytics request by executing an appropriate SQL query to calculate the percentage of on-time deliveries each month. It processes the data to ensure date formatting suitable for time series plotting and uses Plotly to visualize the trend. The inclusion of markers in the plot is a minor difference from the reference code but does not deviate from the core logic or intent. Overall, the input code effectively answers the question and adheres to the specified logic.",both
Which region has the highest average order value? Include a bar chart to visualize the average order values by region.,"```python
import pandas as pd
import plotly.express as px

# Provided SQL query
sql_query = """"""
SELECT Region, 
       AVG([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS AverageOrderValue 
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY Region 
ORDER BY AverageOrderValue DESC;
""""""

# Utility function to execute the SQL query and return the result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for SQL execution logic
    # Return a mocked DataFrame for example purposes
    data = {
        'Region': ['East', 'West', 'North', 'South'],
        'AverageOrderValue': [250.0, 300.0, 200.0, 280.0]
    }
    return pd.DataFrame(data)

# Utility function to display data or visualization results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Main data analysis and visualization process
def analyze_average_order_value():
    # Execute the SQL query
    df = execute_sql_query(sql_query)

    # Create a bar chart for average order values by region
    fig = px.bar(df, x='Region', y='AverageOrderValue', title='Average Order Value by Region')

    # Display the bar chart
    show_to_user(fig)

# Run the analysis
analyze_average_order_value()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AvgOrderValue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Region
""""""

average_order_values = execute_sql_query(sql_query)

fig = px.bar(average_order_values, x='Region', y='AvgOrderValue', title='Average Order Value by Region')
show_to_user(fig)

highest_avg_order_value_region = average_order_values.loc[average_order_values['AvgOrderValue'].idxmax()]
show_to_user(pd.DataFrame([highest_avg_order_value_region]))
```","The input Python code correctly calculates the average order value by region and creates a bar chart to visualize these values. It uses similar SQL logic as the reference code for calculating average order values, groups by region, and utilizes Plotly for visualization. Additionally, it identifies the region with the highest average order value and displays this information. The code maintains intended functionality and visualization requirements, adhering to the business analytics request.","```python
import pandas as pd
import plotly.express as px

# The SQL query to execute
sql_query = """"""
SELECT 
    Shippers.Region, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM 
    orders o 
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID 
JOIN 
    customers c ON o.CustomerID = c.CustomerID 
JOIN 
    shippers s ON o.ShipVia = s.ShipperID 
GROUP BY 
    Shippers.Region 
ORDER BY 
    AvgOrderValue DESC
""""""

# Function to fetch data from the database
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # [Implementation of this function is assumed]
    pass

# Function to display data or visualization to the user
def show_to_user(data):
    # [Implementation of this function is assumed]
    pass

# Execute the SQL query and get the result into a DataFrame
results_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average order values by region
fig = px.bar(results_df, x='Region', y='AvgOrderValue', 
             title='Average Order Value by Region',
             labels={'AvgOrderValue': 'Average Order Value', 'Region': 'Region'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code calculates the average order value by dividing the total order value by the count of distinct `OrderID`, which is different from the reference code's approach. The reference code uses the average of each order detail per region. Additionally, the input code groups by `Shippers.Region`, which implies it uses a different data model, as the reference implementation uses `Region` from `customers`. These differences likely result in different calculations and could lead to different regional order value rankings.",Base
"List all products that have never been included in any order, and visualize the number of such products by category.","```python
import pandas as pd
import plotly.express as px

# SQL Queries
query_products_not_in_order = """"""
SELECT ProductID, ProductName, CategoryID
FROM products
WHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM [Order Details]);
""""""
query_categories = """"""
SELECT CategoryID, CategoryName
FROM categories;
""""""

# Execute SQL Queries
products_not_in_order_df = execute_sql_query(query_products_not_in_order)
categories_df = execute_sql_query(query_categories)

# Merge DataFrames to get Category Names
merged_df = pd.merge(products_not_in_order_df, categories_df, on='CategoryID', how='left')

# Count Number of Products by Category
product_counts_by_category = merged_df['CategoryName'].value_counts().reset_index()
product_counts_by_category.columns = ['CategoryName', 'ProductCount']

# Visualize
fig = px.bar(product_counts_by_category, x='CategoryName', y='ProductCount',
             title='Number of Products Never Included in Any Order by Category')

# Show the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Step 1: Write SQL query to find products that have never been included in any order
sql_query = """"""
SELECT p.ProductID, p.ProductName, p.CategoryID
FROM products p
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.ProductID IS NULL
""""""

# Step 2: Execute the SQL query
products_never_ordered = execute_sql_query(sql_query)

# Step 3: Count the number of such products by category
products_count_by_category = products_never_ordered['CategoryID'].value_counts().reset_index()
products_count_by_category.columns = ['CategoryID', 'Count']

# Step 4: Visualize the number of products by category
fig = px.bar(products_count_by_category, x='CategoryID', y='Count', title='Number of Products Never Ordered by Category')
show_to_user(fig)
```","The input code does not join with the 'categories' table to include 'CategoryName' in the output, which means it fails to match the reference implementation's requirement of categorizing by name rather than ID. Also, it doesn't explicitly drop IDs in the result visualization.","Certainly! To achieve the task, we'll write a Python code that:

1. Executes the SQL query to get all products that have never been included in any order.
2. Categorizes these products and counts the number of such products by category.
3. Visualizes the count by category using a bar chart.

Here's how you can implement this requirement:

```python
import pandas as pd
import plotly.express as px

# Utility function placeholder for executing SQL and getting a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating execution and returning sample DataFrame
    # Replace this with actual database query execution
    return pd.DataFrame({
        'ProductID': range(1, 101),
        'Category': ['Electronics'] * 25 + ['Clothing'] * 25 + ['Food'] * 25 + ['Books'] * 25
    })

# Fetch products that have never been included in any order
sql_query = ""SELECT ProductID, Category FROM products WHERE ProductID NOT IN (SELECT ProductID FROM [Order Details])""
products_df = execute_sql_query(sql_query)

# Count the number of such products by category
category_counts = products_df.groupby('Category').size().reset_index(name='Count')

# Visualize the count of products by category using Plotly
fig = px.bar(category_counts, x='Category', y='Count', title='Products Never Included in Any Order by Category')

# Use the utility function to display the visualization
show_to_user(fig)
```

### Explanation of the Code:
- **Utility Functions**: `execute_sql_query` is a placeholder for executing SQL queries that would fetch data from a database. It would ideally connect to a database and fetch results into a DataFrame. `show_to_user` displays the DataFrame or Plotly figure to the user.
- **SQL Execution**: The SQL query provided in the business request is executed to retrieve products that have never been included in an order.
- **Aggregation**: The products are grouped by category, counting how many products belong to each category.
- **Visualization**: A bar chart is generated using Plotly, showing the number of products that have never been ordered, broken down by category.

### Note:
You would need to replace the placeholder `execute_sql_query` with an actual implementation that interacts with your database (using a library like `sqlite3`, `sqlalchemy`, etc.) and configure your environment to use Plotly correctly.","The input code does not properly implement the logic to identify products that have never been included in any order. It assumes a predefined DataFrame is returned by the function `execute_sql_query`. Also, it does not merge with a categories table to get the category names as in the reference code, leading to potential discrepancies in results.",None
"How does the product performance vary month by month, and can you provide a monthly performance trend chart?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    DATE_TRUNC('month', OrderDate) AS Month, 
    ProductID, 
    SUM(Quantity) AS TotalPerformance 
FROM 
    [Order Details] 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY 
    Month, ProductID;
""""""

# Function to execute SQL query and get the dataframe
def execute_sql_query(sql_query: str):
    # Assuming the function implementation is provided which returns a pandas DataFrame
    pass  # Replace with actual implementation

# Function to display data or visualization
def show_to_user(data):
    # Assuming the function implementation is provided to display the data
    pass  # Replace with actual implementation

# Execute the SQL query
df = execute_sql_query(sql_query)

# Ensure the Month column is in datetime format
df['Month'] = pd.to_datetime(df['Month'])

# Create a line chart using Plotly
fig = px.line(df, x='Month', y='TotalPerformance', color='ProductID', 
              title='Monthly Product Performance Trend',
              labels={'TotalPerformance': 'Total Performance', 'Month': 'Month'})

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve monthly product performance data
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].Quantity) AS TotalSales
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
JOIN 
    products ON [Order Details].ProductID = products.ProductID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query and get the result in a DataFrame
monthly_performance_df = execute_sql_query(sql_query)

# Create a line chart for monthly product performance trend
fig = px.line(monthly_performance_df, x='Month', y='TotalSales', title='Monthly Product Performance Trend', labels={'TotalSales': 'Total Sales', 'Month': 'Month'})

# Show the figure to the user
show_to_user(fig)
```","The input code deviates from the reference implementation in key areas. Firstly, it does not group by 'ProductID', which is crucial as it asks for performance by product month over month. Secondly, it uses 'DATE_FORMAT' instead of 'DATE_TRUNC', which may or may not produce the same results depending on the SQL engine, but typically both are for truncating dates to a specific granularity. Furthermore, 'TotalSales' in the input code only aggregates 'Quantity' without differentiating between products. This aggregation doesn't satisfy the requirement of showing product performance by month individually.","```python
import pandas as pd
import plotly.express as px

# Fetch data using utility function
data = execute_sql_query(""""""
    SELECT MONTH(orders.OrderDate) AS Month, products.ProductName,
           SUM([Order Details].Quantity) AS MonthlyPerformance
    FROM products
    JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    GROUP BY MONTH(orders.OrderDate), products.ProductName;
"""""")

# Sort data by Month for better visualization
data = data.sort_values(by='Month')

# Pivot the data for better plotting
pivoted_data = data.pivot(index='Month', columns='ProductName', values='MonthlyPerformance').fillna(0)

# Create a plotly line chart
fig = px.line(
    pivoted_data,
    x=pivoted_data.index,
    y=pivoted_data.columns,
    title='Monthly Product Performance Trend',
    labels={'value': 'Performance', 'index': 'Month'}
)

# Display the trend chart
show_to_user(fig)
```","The input code uses a different SQL query which aggregates by ProductName instead of ProductID and uses MONTH() which returns an integer, potentially missing different years. The reference code uses DATE_TRUNC to ensure grouping by year and month together, retaining datetime format. The pivoting in the input code alters the structure compared to the reference implementation. Additionally, the labels in the plotting function are not consistent with the reference code. These differences indicate that the input does not adhere to the logic of the reference implementation.",None
"What is the total sales revenue generated for each month, and can you provide a line chart to visualize the trends over time?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY Month;
""""""

# Execute the SQL query and retrieve the data into a DataFrame
sales_data = execute_sql_query(sql_query)

# Convert 'Month' to datetime to ensure proper plotting
sales_data['Month'] = pd.to_datetime(sales_data['Month'])

# Create a line chart to visualize the total sales revenue trends over time
fig = px.line(sales_data, x='Month', y='TotalSales', title='Total Sales Revenue per Month')

# Display the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

sales_data = execute_sql_query(sql_query)

fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Sales Revenue')
show_to_user(fig)
```","The input code correctly computes total sales revenue per month and visualizes it with a line chart. It uses the SQL query to aggregate sales data by month, taking account of discounts, and uses Plotly for plotting. The difference in date formatting (DATE_FORMAT vs. DATE_TRUNC) and slight variations in plot titles are not significant logic changes affecting the outcome.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT TO_CHAR(orders.OrderDate, 'YYYY-MM') AS Month, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
GROUP BY TO_CHAR(orders.OrderDate, 'YYYY-MM');
""""""

# Execute the SQL query and get the result in a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a line chart to visualize the sales trends over time
fig = px.line(sales_data, x='Month', y='TotalSales', title='Monthly Sales Revenue Trends')

# Display the line chart to the user
show_to_user(fig)
```","Both implementations correctly compute the total sales revenue per month and visualize this using a line chart. The minor differences in SQL syntax do not affect the correctness of the results. The first implementation uses DATE_TRUNC for grouping by month, while the second uses TO_CHAR with a 'YYYY-MM' format. Both approaches effectively group data by month. Additionally, both scripts use Plotly to generate and display a line chart of the trends over time.",both
"What is the most popular product in terms of quantity sold in 2023, and can this be illustrated with a bar chart showing quantities of each product sold?","```python
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function representing SQL query execution
    pass

def show_to_user(data):
    # Placeholder function for displaying results
    pass

# SQL query to retrieve product sales data for 2023
sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS total_sold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY products.ProductName 
ORDER BY total_sold DESC
""""""

# Execute the SQL query
sales_data_2023 = execute_sql_query(sql_query)

# Visualize the data with a bar chart
fig = px.bar(sales_data_2023, x='ProductName', y='total_sold',
             title='Quantities of Each Product Sold in 2023',
             labels={'total_sold': 'Quantity Sold', 'ProductName': 'Product Name'},
             template='plotly_dark')

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS quantity_sold 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY products.ProductID, products.ProductName 
ORDER BY quantity_sold DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductName', y='quantity_sold', title='Quantity of Each Product Sold in 2023', labels={'quantity_sold': 'Quantity Sold', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code is correct and matches the logic of the reference implementation. Both codes query and aggregate the total quantity sold for each product in 2023. They use similar SQL queries to group by ProductName and compute the sum of quantities sold, while ordering the results by quantity sold in descending order. Additionally, both implement a bar chart to visualize the data with `plotly.express`, and they display the chart using a placeholder function. Minor differences, like including `products.ProductID` in the grouping, do not affect the correctness as they align with the intention of fetching unique products and their total quantities sold.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the product quantities sold in 2023
sql_query = """"""
SELECT ProductName, SUM(od.Quantity) AS TotalQuantity 
FROM products 
JOIN [Order Details] od 
ON products.ProductID = od.ProductID 
JOIN orders o 
ON od.OrderID = o.OrderID 
WHERE o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY ProductName 
ORDER BY TotalQuantity DESC
""""""

# Execute the SQL query and get the result as a pandas DataFrame
product_data = execute_sql_query(sql_query)

# Visualize with a bar chart using Plotly
fig = px.bar(product_data, x='ProductName', y='TotalQuantity', 
             title='Quantities of Each Product Sold in 2023', 
             labels={'ProductName': 'Product', 'TotalQuantity': 'Quantity Sold'},
             text='TotalQuantity')

# Display the bar chart
show_to_user(fig)
```","The input Python code fulfills the business analytics request by correctly querying the products sold in 2023 and creating a bar chart illustrating the quantities sold. The SQL query logic in the input matches that of the reference implementation, retrieving the sum of quantities for each product within the specified date range. The use of Plotly to create the bar chart is consistent in both implementations, ensuring that the visualization requirement is met. The differences in SQL aliases and some variable names do not affect the correctness of the logic or the result.",both
"Which shipping method is most frequently used for orders in 2023, and can we visualize this using a bar chart?","```python
import pandas as pd
import plotly.express as px

# The given SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS shipping_count 
FROM orders 
WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31' 
GROUP BY ShipVia 
ORDER BY shipping_count DESC
""""""

# Execute the SQL query and fetch results as a pandas DataFrame
shipping_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the most frequently used shipping method
fig = px.bar(shipping_data, x='ShipVia', y='shipping_count',
             title='Most Frequently Used Shipping Methods in 2023',
             labels={'ShipVia': 'Shipping Method', 'shipping_count': 'Number of Orders'},
             text='shipping_count')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS order_count
FROM orders
WHERE YEAR(OrderDate) = 2023
GROUP BY ShipVia
ORDER BY order_count DESC
""""""
shipping_method_data = execute_sql_query(sql_query)

fig = px.bar(shipping_method_data, x='ShipVia', y='order_count', title='Shipping Method Frequencies in 2023', labels={'ShipVia': 'Shipping Method', 'order_count': 'Order Count'})
show_to_user(fig)
```","The input code correctly queries the database to count the number of orders per shipping method for the year 2023. It uses 'YEAR(OrderDate) = 2023', which is logically equivalent to the reference code's 'OrderDate BETWEEN '2023-01-01' AND '2023-12-31'. Both codes group by 'ShipVia' and order the results by the count in descending order. Additionally, the input code creates a bar chart similar to the reference implementation, fulfilling the requirement to visualize the data.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get the shipping count for 2023
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS order_count 
FROM orders 
WHERE YEAR(OrderDate) = 2023 
GROUP BY ShipVia 
ORDER BY order_count DESC
""""""
data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(data, x='ShipVia', y='order_count', 
             title='Most Frequently Used Shipping Methods in 2023',
             labels={'ShipVia': 'Shipping Method', 'order_count': 'Number of Orders'},
             text='order_count')

# Display the figure using the custom utility function
show_to_user(fig)
```","Both implementations correctly query for the most frequently used shipping methods for orders in 2023 and create a bar chart visualization. The main difference is the SQL query: the input code uses `YEAR(OrderDate) = 2023`, which is logically equivalent to the reference code's date range of `BETWEEN '2023-01-01' AND '2023-12-31'`. Both approaches achieve the same result, making the provided code correct.",both
Determine the number of orders processed by each employee by year and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT employees.EmployeeID, 
       YEAR(orders.OrderDate) AS OrderYear, 
       COUNT(orders.OrderID) AS OrderCount 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID, YEAR(orders.OrderDate);
""""""

# Execute the SQL query and get the results as a pandas DataFrame
orders_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    orders_data, 
    x='OrderYear', 
    y='OrderCount', 
    color='EmployeeID', 
    title='Number of Orders Processed by Each Employee by Year',
    labels={'OrderYear': 'Year', 'OrderCount': 'Order Count', 'EmployeeID': 'Employee ID'}
)

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    YEAR(o.OrderDate) AS OrderYear, 
    COUNT(o.OrderID) AS OrderCount
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
GROUP BY 
    e.EmployeeID, YEAR(o.OrderDate)
ORDER BY 
    e.EmployeeID, OrderYear;
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, 
             x='OrderYear', 
             y='OrderCount', 
             color='EmployeeID', 
             title='Number of Orders Processed by Each Employee by Year',
             labels={'OrderYear': 'Year', 'OrderCount': 'Number of Orders'})
show_to_user(fig)
```","The provided code successfully meets the business analytics requirement by determining the number of orders processed by each employee each year and visualizing it using a bar chart. The logic aligns with the reference implementation: both execute a SQL query that aggregates order counts per employee per year, then use Plotly to create a bar chart, distinguishing colors by EmployeeID. The addition of an ORDER BY clause in the input code does not affect its correctness for the given task.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user utility functions are defined elsewhere:
# def execute_sql_query(sql_query: str) -> pd.DataFrame: ...
# def show_to_user(data): ...

# SQL query to fetch the required data
sql_query = """"""
SELECT EXTRACT(YEAR FROM o.OrderDate) AS Year, 
       e.EmployeeID, 
       COUNT(o.OrderID) AS OrderCount 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY Year, e.EmployeeID;
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Convert 'Year' to integer for proper sorting in visualization
orders_df['Year'] = orders_df['Year'].astype(int)

# Generate a bar chart using Plotly
fig = px.bar(
    orders_df,
    x='Year',
    y='OrderCount',
    color='EmployeeID',
    barmode='group',
    title='Number of Orders Processed by Each Employee by Year',
    labels={'OrderCount': 'Number of Orders', 'EmployeeID': 'Employee ID'}
)

# Display the results to the user
show_to_user(fig)
```","The input code correctly calculates the number of orders processed by each employee by year and visualizes it using a bar chart. It extracts the year from the order date, groups by year and employee, counts the orders, and produces a bar chart similar to the reference implementation. The differences in SQL syntax and plotting details do not affect the correctness regarding the business logic required.",both
Identify the employee responsible for orders with the highest freight costs and provide a visualization of freight costs per employee.,"```python
import pandas as pd
import plotly.express as px

# SQL query to identify highest freight order
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, o.OrderID 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.Freight = (SELECT MAX(Freight) FROM orders)
""""""

# Execute the SQL query
highest_freight_df = execute_sql_query(sql_query)

# Display the employee responsible for the order with the highest freight
show_to_user(highest_freight_df)

# SQL query to get freight costs for all employees
sql_query_freight = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(o.Freight) AS TotalFreight
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

# Execute the SQL query
freight_costs_df = execute_sql_query(sql_query_freight)

# Create a visualization of freight costs per employee using Plotly
fig = px.bar(freight_costs_df, x='FirstName', y='TotalFreight', 
             hover_data=['LastName'], title='Freight Costs per Employee')

# Show the plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Query to get total freight cost per employee
freight_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, SUM(o.Freight) as TotalFreight
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY TotalFreight DESC
""""""

freight_data = execute_sql_query(freight_query)

# Identify the employee responsible for the highest freight costs
top_employee = freight_data.iloc[0]

# Visualization of freight costs per employee
fig = px.bar(freight_data, x='EmployeeID', y='TotalFreight', 
             title='Freight Costs per Employee',
             labels={'EmployeeID': 'Employee ID', 'TotalFreight': 'Total Freight Cost'},
             text='TotalFreight')

show_to_user(fig)

top_employee
```","The input code does not properly identify the employee responsible for the order with the highest freight cost. It finds the employee with the highest total freight across all orders instead. The reference implementation correctly queries for the specific order with the maximum freight. Additionally, the input code uses 'EmployeeID' for the x-axis in the visualization rather than employee names.","```python
import pandas as pd
import plotly.express as px

# SQL Query to identify the employee with the highest freight costs
sql_query_highest_freight = """"""
SELECT 
    employees.EmployeeID, 
    SUM(orders.Freight) AS TotalFreight 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY 
    employees.EmployeeID 
ORDER BY 
    TotalFreight DESC 
LIMIT 1
""""""

# SQL Query to get all freight costs per employee
sql_query_freight_per_employee = """"""
SELECT 
    employees.EmployeeID, 
    SUM(orders.Freight) AS TotalFreight 
FROM 
    employees 
JOIN 
    orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY 
    employees.EmployeeID
""""""

# Execute SQL query to find the employee with the highest freight costs
highest_freight_df = execute_sql_query(sql_query_highest_freight)

# Execute SQL query to get freight costs per employee
freight_per_employee_df = execute_sql_query(sql_query_freight_per_employee)

# Visualization of freight costs per employee
fig = px.bar(
    freight_per_employee_df, 
    x='EmployeeID', 
    y='TotalFreight',
    title='Freight Costs Per Employee',
    labels={'TotalFreight': 'Total Freight Cost', 'EmployeeID': 'Employee ID'}
)

# Show the figure to the user
show_to_user(fig)

# Show the employee with the highest freight cost to the user
show_to_user(highest_freight_df)
```","The input code does not correctly address the business analytics request. It identifies the employee with the highest total freight costs over all their orders, rather than the employee responsible for the single order with the highest freight cost. The reference code finds the employee connected to the order with the maximum freight cost, while the input code aggregates freight per employee and selects the one with the highest total.",None
"Which product had the best performance in terms of quantity sold for the month of June 2023, and can this be visualized with a bar chart showing the quantities sold for each product?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to fetch data
sql_query = """"""
SELECT products.ProductID, 
       SUM([Order Details].Quantity) AS product_performance
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE MONTH(orders.OrderDate) = 6 AND YEAR(orders.OrderDate) = 2023
GROUP BY products.ProductID
ORDER BY product_performance DESC
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='product_performance', 
             title=""Product Performance for June 2023"",
             labels={'ProductID': 'Product ID', 'product_performance': 'Quantity Sold'})

# Display the bar chart to the user
show_to_user(fig)

# Additionally, display the product with the highest quantity sold
best_performing_product = df.iloc[0]
show_to_user(pd.DataFrame([best_performing_product]))
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS QuantitySold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
GROUP BY products.ProductID, products.ProductName
ORDER BY QuantitySold DESC
LIMIT 1
""""""

best_product_df = execute_sql_query(sql_query)

quantities_query = """"""
SELECT products.ProductID, products.ProductName, SUM([Order Details].Quantity) AS QuantitySold
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
WHERE orders.OrderDate BETWEEN '2023-06-01' AND '2023-06-30'
GROUP BY products.ProductID, products.ProductName
""""""

quantities_df = execute_sql_query(quantities_query)

fig = px.bar(quantities_df, x='ProductName', y='QuantitySold',
             title='Quantities Sold for Each Product in June 2023',
             labels={'QuantitySold': 'Quantity Sold', 'ProductName': 'Product Name'})

show_to_user(fig)
```","The input code correctly answers the business request. It identifies the product with the highest quantity sold in June 2023 and visualizes the quantities sold for each product using a bar chart. Although the structure differs slightly from the reference code, it achieves the same outcome.","```python
import pandas as pd
import plotly.express as px

# Sample utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should contain logic to execute SQL and return data as DataFrame
    # Placeholder for demonstration purposes
    return pd.DataFrame({
        'ProductID': [101, 102, 103],
        'TotalQuantity': [300, 150, 450]
    })

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif isinstance(data, px.Figure):
        data.show()

# SQL query to retrieve data
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantity
FROM [Order Details]
WHERE OrderID IN (
    SELECT OrderID FROM orders 
    WHERE MONTH(OrderDate) = 6 AND YEAR(OrderDate) = 2023
)
GROUP BY ProductID
ORDER BY TotalQuantity DESC;
""""""

# Execute the SQL query and get the DataFrame
df = execute_sql_query(sql_query)

# Identifying the product with the best performance
best_product = df.iloc[0]
print(f""Product with best performance: {best_product['ProductID']} with {best_product['TotalQuantity']} units sold"")

# Visualizing data with a bar chart
fig = px.bar(df, x='ProductID', y='TotalQuantity', title='Product Performance - June 2023')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request. It retrieves the product data for June 2023, calculates the total quantity sold per product, and identifies the best-performing product. Additionally, it employs a bar chart for visualization using Plotly, similar to the reference implementation. Both codes aim to find and display the best-performing product and visualize the performance of all products, adhering to the same logic and fulfilling the requirements.",both
"What is the average shipping cost per country, and can we visualize this using a bar chart for better comparison?","```python
import pandas as pd
import plotly.express as px

# SQL query to get average shipping cost per country
sql_query = """"""
SELECT ShipCountry, AVG(Freight) AS AverageCost 
FROM orders 
GROUP BY ShipCountry;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average shipping cost per country
fig = px.bar(df, x='ShipCountry', y='AverageCost', 
             title='Average Shipping Cost per Country',
             labels={'ShipCountry': 'Country', 'AverageCost': 'Average Shipping Cost'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCountry, AVG(Freight) AS AverageShippingCost
FROM orders
GROUP BY ShipCountry
""""""

shipping_costs_df = execute_sql_query(sql_query)

fig = px.bar(shipping_costs_df, x='ShipCountry', y='AverageShippingCost', 
             title='Average Shipping Cost per Country', 
             labels={'AverageShippingCost': 'Average Shipping Cost', 'ShipCountry': 'Country'})
show_to_user(fig)
```",The input code performs the same operations as the reference implementation. It executes the SQL query to calculate the average shipping cost per country and generates a bar chart to visualize the results using Plotly. The column names and labels in the visualization are consistent with the reference implementation.,"```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve average shipping cost per country
sql_query = ""SELECT ShipCountry, AVG(Freight) AS AvgShippingCost FROM orders GROUP BY ShipCountry;""

# Execute the SQL query and load the data into a pandas DataFrame
shipping_data = execute_sql_query(sql_query)

# Generate a bar chart using Plotly to visualize the average shipping cost per country
fig = px.bar(
    shipping_data, 
    x='ShipCountry', 
    y='AvgShippingCost', 
    title='Average Shipping Cost per Country',
    labels={'ShipCountry': 'Country', 'AvgShippingCost': 'Average Shipping Cost'},
    text_auto=True
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request by querying average shipping costs per country and visualizing it using a bar chart. It follows the same logic as the reference implementation: executing the SQL query to compute the average freight by 'ShipCountry' and using Plotly to generate a bar chart with equivalent parameters, such as the title and labels. Additionally, it includes 'text_auto=True' to display values on bars, which is an enhancement but not a deviation from the logic.",both
"What is the total number of products shipped in the last month, and can you provide a bar chart to visualize the daily shipment trends over the month?","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# This is a utility function as per the defined Python environment constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating SQL execution and returning a DataFrame (sample data)
    # In a real scenario, this would execute the SQL query against a database
    # Here's a dummy DataFrame for illustration purposes
    data = {'ShippedDate': pd.date_range(end=datetime.today(), periods=30),
            'Quantity': [5, 7, 8, 6, 10, 12, 15, 9, 11, 8, 
                         7, 9, 6, 10, 15, 7, 5, 6, 8, 12,
                         8, 11, 13, 7, 10, 14, 6, 9, 11, 13]}
    return pd.DataFrame(data)

# This is a function to show results to the user
def show_to_user(data):
    # If it's a dataframe, print simple summary
    if isinstance(data, pd.DataFrame):
        print(data)
    elif hasattr(data, 'show'):
        data.show()

sql_query = """"""
    SELECT ShippedDate, Quantity 
    FROM (
        SELECT orders.ShippedDate, [Order Details].Quantity 
        FROM orders 
        JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
        WHERE orders.ShippedDate BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 MONTH) AND CURDATE()
    ) subquery;
""""""

# Execute the SQL query to obtain data
df = execute_sql_query(sql_query)

# Calculate the total number of products shipped
total_shipped = df['Quantity'].sum()
print(f""Total number of products shipped in the last month: {total_shipped}"")

# Create a bar chart to visualize daily shipment trends
fig = px.bar(df, x='ShippedDate', y='Quantity', title=""Daily Shipment Trends in the Last Month"")

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Calculate the date range for the last month
end_date = datetime.now().date() - timedelta(days=datetime.now().date().day)
start_date = end_date.replace(day=1)

# SQL query to get the shipments data for the last month
sql_query = f""""""
SELECT 
    ShippedDate, 
    SUM([Order Details].Quantity) AS TotalShipped
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    ShippedDate >= '{start_date}' AND ShippedDate < '{end_date}'
GROUP BY 
    ShippedDate
ORDER BY 
    ShippedDate;
""""""

# Execute the SQL query
shipment_data = execute_sql_query(sql_query)

# Total number of products shipped
total_shipped = shipment_data['TotalShipped'].sum()

# Create a bar chart for daily shipment trends
fig = px.bar(shipment_data, x='ShippedDate', y='TotalShipped', 
             title='Daily Shipment Trends Over the Last Month', 
             labels={'ShippedDate': 'Date', 'TotalShipped': 'Total Products Shipped'})

# Show the results
show_to_user(fig)

total_shipped
```","The input code calculates the date range incorrectly. The `end_date` should be the last day of the previous month, not the last day of the current month minus the day of the month. Additionally, the reference code sums up quantities without grouping by date, reflecting daily totals inherently in the data, whereas the input code explicitly groups by 'ShippedDate', which may not match the reference's logic based on how `execute_sql_query` is defined. These differences may affect the correctness and comparability of results.","```python
import pandas as pd
import plotly.express as px

# Function to execute the given SQL query and return results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database execution logic
    # This function should connect to the database, execute the query, and return the result as a DataFrame
    pass

# Function to display the data or visualization to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch daily shipment data
sql_query = """"""
SELECT 
    DATE(ShippedDate) AS Date,
    COUNT(DISTINCT od.ProductID) AS ProductsShipped 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE MONTH(ShippedDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
AND YEAR(ShippedDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) 
GROUP BY DATE(ShippedDate)
""""""

# Execute the SQL query
shipment_data_df = execute_sql_query(sql_query)

# Create a bar chart to visualize daily shipment trends
fig = px.bar(
    shipment_data_df, 
    x='Date', 
    y='ProductsShipped', 
    title='Daily Shipment Trends for Last Month',
    labels={'ProductsShipped': 'Number of Products Shipped'}
)

# Display the resulting bar chart
show_to_user(fig)
```","The input code uses COUNT(DISTINCT od.ProductID) to calculate ProductsShipped, which differs from the reference implementation's sum of quantities. Therefore, the logic doesn't match regarding calculating total products shipped, and the results will differ.",None
"What is the busiest shipping month based on total orders shipped, and can you provide a bar chart to visualize the monthly shipment totals?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', ShippedDate) AS Month, COUNT(OrderID) AS TotalOrders
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY Month
ORDER BY Month
""""""

# Execute the SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Identify the busiest shipping month
busiest_month_df = orders_df.sort_values(by='TotalOrders', ascending=False).head(1)

# Visualize the monthly shipment totals using a bar chart
fig = px.bar(orders_df, x='Month', y='TotalOrders', title='Monthly Shipment Totals')

# Show the bar chart to the user
show_to_user(fig)

# Display the busiest shipping month
show_to_user(busiest_month_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(ShippedDate, '%Y-%m') AS ShippingMonth,
       COUNT(OrderID) AS TotalOrders
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY ShippingMonth
ORDER BY TotalOrders DESC;
""""""

monthly_shipments = execute_sql_query(sql_query)

busiest_month = monthly_shipments.iloc[0]
busiest_month_name = busiest_month['ShippingMonth']
busiest_month_orders = busiest_month['TotalOrders']

fig = px.bar(monthly_shipments, x='ShippingMonth', y='TotalOrders',
             title='Monthly Shipment Totals',
             labels={'ShippingMonth': 'Shipping Month', 'TotalOrders': 'Total Orders Shipped'})

show_to_user(fig)

busiest_month_name, busiest_month_orders
```","The input code is logically correct and adheres to the business analytics request. It calculates the total orders shipped per month and identifies the busiest month based on total orders, similarly to the reference implementation. The difference in SQL syntax (DATE_FORMAT vs. DATE_TRUNC) is due to different SQL dialects but does not affect the logic. The input code also uses Plotly to visualize the monthly shipment totals and correctly displays the busiest month.","
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is assumed to be provided and executes the SQL query, returning a DataFrame
    pass

def show_to_user(data):
    # This function is assumed to display data analysis or visualization results
    pass

# SQL Query
sql_query = """"""
   SELECT EXTRACT(YEAR FROM OrderDate) AS Year,
          EXTRACT(MONTH FROM OrderDate) AS Month,
          COUNT(OrderID) AS orders_shipped
     FROM orders
    WHERE ShippedDate IS NOT NULL
    GROUP BY Year, Month
    ORDER BY Year, Month;
""""""

# Execute the SQL query
monthly_orders_df = execute_sql_query(sql_query)

# Create a bar chart for visualization
fig = px.bar(
    monthly_orders_df,
    x='Month',
    y='orders_shipped',
    color='orders_shipped',
    title='Monthly Shipment Totals',
    labels={'orders_shipped': 'Total Orders Shipped', 'Month': 'Month'},
    color_continuous_scale='Viridis'
)

# Show the plot
show_to_user(fig)
","The input code executes a query that extracts separate Year and Month using the 'OrderDate' column instead of 'ShippedDate' for aggregation. The logic differs from the reference code, which aggregates based on the truncated 'ShippedDate' to month. Additionally, the input code considers color coding in the bar chart, which is not included in the reference implementation.",Base
Which employees have shipped orders late and by how many days on average? Include a bar chart showing the average days late for each employee.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
    AVG(DATEDIFF(o.ShippedDate, o.RequiredDate)) AS AvgLateDays 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
WHERE o.ShippedDate > o.RequiredDate 
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute SQL query and get result as a DataFrame
df_late_shipments = execute_sql_query(sql_query)

# Prepare the DataFrame for visualization, ensuring appropriate data types
df_late_shipments['AvgLateDays'] = df_late_shipments['AvgLateDays'].astype(float)

df_late_shipments['FullName'] = df_late_shipments['FirstName'] + ' ' + df_late_shipments['LastName']

# Create a bar chart to show average days late for each employee
fig = px.bar(
    df_late_shipments,
    x='FullName',
    y='AvgLateDays',
    title='Average Days Late for Each Employee',
    labels={'AvgLateDays': 'Average Days Late', 'FullName': 'Employee'}
)

# Display the bar chart using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       e.FirstName, 
       e.LastName, 
       AVG(DATEDIFF(o.ShippedDate, o.RequiredDate)) AS AverageDaysLate
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.ShippedDate > o.RequiredDate
GROUP BY e.EmployeeID, e.FirstName, e.LastName
ORDER BY AverageDaysLate DESC
""""""

employees_late_orders = execute_sql_query(sql_query)

fig = px.bar(employees_late_orders, 
             x=['FirstName', 'LastName'], 
             y='AverageDaysLate', 
             title='Average Days Late by Employee',
             labels={'AverageDaysLate': 'Average Days Late', 
                     'FirstName': 'Employee Name'},
             text='AverageDaysLate')

show_to_user(fig)
```","The input code does not align with the reference implementation in the aspect of visualization. In the input code, the bar chart uses separate x-axis values for 'FirstName' and 'LastName', which results in an incorrect plot. However, the reference code combines 'FirstName' and 'LastName' into a single 'FullName' field, which is the correct method to display each employee on the x-axis. Also, 'AverageDaysLate' is displayed as text on the bars in the input code, which is not done in the reference code.","Let's proceed with the solution to extract and analyze the data as described in the business request.

### Step 1: Define the SQL Query
We'll define the SQL query based on the provided SQL syntax that identifies employees who have shipped orders late and calculates the average number of days these orders are late.

### Step 2: Write the Python Code
Using the defined SQL query, we'll then execute it using the provided utility function and create a bar chart to visualize the data.

Here is the complete solution using Python:

```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be defined elsewhere in your environment to execute SQL and return a DataFrame
    pass

def show_to_user(data):
    # This function should be defined elsewhere in your environment to display data or figures
    pass

# SQL query to retrieve the late shipment details for employees
sql_query = """"""
SELECT employees.EmployeeID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.RequiredDate)) AS AvgDaysLate 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
WHERE orders.ShippedDate > orders.RequiredDate 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query
late_shipments_df = execute_sql_query(sql_query)

# Generate bar chart visualization
fig = px.bar(
    late_shipments_df,
    x='EmployeeID',
    y='AvgDaysLate',
    title='Average Days Late by Employee',
    labels={'AvgDaysLate': 'Average Days Late', 'EmployeeID': 'Employee ID'}
)

# Display the bar chart using the utility function
show_to_user(fig)
```

### Notes
1. `execute_sql_query`: This is a placeholder utility function to be implemented elsewhere in your environment.
2. `show_to_user`: This function will display either the DataFrame or Plotly visualization based on the data passed to it.
3. The SQL query is designed to group employees by their IDs and calculate the average number of days their orders were late.

This process efficiently retrieves, analyzes, and visualizes the data as per the business request.","The input code does not include the employee names in the SQL query, which is required to meet the business analytics request for identifying employees. The reference implementation includes employee names in both the SQL query and the visualization, ensuring clarity about which employee is responsible for late shipments, while the input code only uses EmployeeID. The output visualization in the input code therefore lacks the detailed identification of employees as specified.",None
Find suppliers with a homepage listed in the suppliers table and create a visualization to display the percentage of suppliers with and without a homepage.,"```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to get suppliers with a homepage
sql_query = ""SELECT CompanyName FROM suppliers WHERE HomePage IS NOT NULL;""
suppliers_with_homepage = execute_sql_query(sql_query)

# Total number of suppliers
total_suppliers_query = ""SELECT COUNT(*) as TotalSuppliers FROM suppliers;""
total_suppliers_df = execute_sql_query(total_suppliers_query)
total_suppliers = total_suppliers_df['TotalSuppliers'].iloc[0]

# Calculate number without homepage
suppliers_with_homepage_count = len(suppliers_with_homepage)
suppliers_without_homepage_count = total_suppliers - suppliers_with_homepage_count

# Create a DataFrame with the counts
homepage_data = pd.DataFrame({
    'Category': ['With Homepage', 'Without Homepage'],
    'Count': [suppliers_with_homepage_count, suppliers_without_homepage_count]
})

# Create a pie chart using Plotly
fig = px.pie(homepage_data, names='Category', values='Count', 
             title='Percentage of Suppliers With and Without Homepage')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    CASE 
        WHEN HomePage IS NOT NULL AND HomePage != '' THEN 'With Homepage' 
        ELSE 'Without Homepage' 
    END AS Homepage_Status, 
    COUNT(*) AS Supplier_Count
FROM suppliers
GROUP BY Homepage_Status
""""""

supplier_data = execute_sql_query(sql_query)

fig = px.pie(supplier_data, names='Homepage_Status', values='Supplier_Count', title='Percentage of Suppliers with and without Homepage')
show_to_user(fig)
```","The input Python code achieves the same objective as the reference code by calculating the count of suppliers with and without a homepage. It uses SQL to categorize and group suppliers based on their homepage status in one query, which is an acceptable and efficient variation. The visualization steps with Plotly are similar, and the pie chart accurately represents the requested data. Therefore, the logic aligns with the business requirement.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch data
sql_query = """"""
SELECT 
    COUNT(*) AS total_suppliers, 
    SUM(CASE WHEN Homepage IS NOT NULL AND Homepage != '' THEN 1 ELSE 0 END) AS suppliers_with_homepage 
FROM suppliers 
WHERE isnull(Homepage) OR Homepage != '';
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Calculate the percentage with and without homepage
total_suppliers = df['total_suppliers'].iloc[0]
suppliers_with_homepage = df['suppliers_with_homepage'].iloc[0]

# Create a DataFrame for percentage
homepage_data = pd.DataFrame({
    'Type': ['With Homepage', 'Without Homepage'],
    'Percentage': [
        (suppliers_with_homepage / total_suppliers) * 100,
        ((total_suppliers - suppliers_with_homepage) / total_suppliers) * 100
    ]
})

# Create a visualization using Plotly
fig = px.pie(homepage_data, values='Percentage', names='Type', title='Percentage of Suppliers with and Without Homepage')

# Display the visualization
show_to_user(fig)
```","The input code correctly addresses the business analytics request. It fetches the total number of suppliers and the count of suppliers with a homepage using a SQL query. It then calculates the percentage of suppliers with and without a homepage, similar to the reference code. The visualization using Plotly is created accurately to display these percentages. The logic aligns with the reference implementation, as both methods result in the required pie chart visualization without deviation in key steps.",both
"Which customers have generated the most revenue lifetime, and can you provide a visualization to showcase the top customers by total revenue?","```python
import plotly.express as px
import pandas as pd

# Assuming these utility functions are pre-defined elsewhere in the environment
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation
    pass

def show_to_user(data):
    # Placeholder implementation
    pass

# SQL query
sql_query = """"""
SELECT customers.CustomerID,
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN customers ON orders.CustomerID = customers.CustomerID
GROUP BY customers.CustomerID
ORDER BY customer_lifetime_value DESC
""""""

# Execute the SQL query
customer_revenue_df = execute_sql_query(sql_query)

# Plot the top customers by total revenue
fig = px.bar(customer_revenue_df.head(10), x='CustomerID', y='customer_lifetime_value',
             title='Top Customers by Lifetime Revenue', labels={'customer_lifetime_value': 'Lifetime Value'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT customers.CustomerID, customers.CompanyName, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS customer_lifetime_value 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID, customers.CompanyName 
ORDER BY customer_lifetime_value DESC 
LIMIT 10
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, 
              x='CompanyName', 
              y='customer_lifetime_value', 
              title='Top Customers by Total Revenue Lifetime',
              labels={'customer_lifetime_value': 'Total Revenue Lifetime', 'CompanyName': 'Customer Name'})

show_to_user(fig)
```","The input Python code correctly addresses the business analytics request by executing a SQL query to retrieve the top customers based on their lifetime revenue. It calculates customer lifetime value in the same way as the reference code. Although it includes 'CompanyName' in the grouping and limits the result to the top 10 records within the SQL query, the visualization still serves the purpose by displaying the required information. Therefore, the input code adheres to the same logic and correctly represents the top customers by total revenue.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT CustomerID,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY CustomerID
ORDER BY TotalRevenue DESC
LIMIT 10;
""""""

# Execute the query using the provided utility function
top_customers_df = execute_sql_query(sql_query)

# Create a visualization using Plotly
fig = px.bar(top_customers_df,
             x='CustomerID',
             y='TotalRevenue',
             title='Top Customers by Total Revenue',
             labels={'TotalRevenue': 'Total Revenue', 'CustomerID': 'Customer ID'})

# Display the visualization using the provided show_to_user function
show_to_user(fig)
```","The input code correctly computes the top customers by total revenue. It follows a similar logic to the reference implementation, where it performs the SQL query to aggregate and sum the order values based on the product of UnitPrice, Quantity, and Discount. The minor differences such as alias names and ordering syntax do not affect the correctness of the logic or the intended outcome. Both implementations also correctly visualize the results using Plotly and display them to the user.",both
What is the most popular shipping destination city? Please include a bar chart to visualize the distribution of shipments across the top destination cities.,"```python
import pandas as pd
import plotly.express as px

# Define SQL query for fetching shipment data
sql_query = """"""
SELECT o.ShipCity, COUNT(o.OrderID) AS OrderCount
FROM orders o
GROUP BY o.ShipCity
ORDER BY OrderCount DESC
""""""

# Execute the SQL query and get the result into a pandas DataFrame
shipments_df = execute_sql_query(sql_query)

# Visualize the distribution of shipments across the top destination cities
fig = px.bar(shipments_df, x='ShipCity', y='OrderCount', 
             title='Distribution of Shipments Across Top Destination Cities',
             labels={'ShipCity': 'Destination City', 'OrderCount': 'Number of Shipments'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS ShipmentCount
FROM orders
GROUP BY ShipCity
ORDER BY ShipmentCount DESC
LIMIT 10
""""""

top_cities_df = execute_sql_query(sql_query)

most_popular_city = top_cities_df.iloc[0]

fig = px.bar(top_cities_df, x='ShipCity', y='ShipmentCount', title='Top Shipping Destination Cities')
show_to_user(fig)
```","The input Python code answers the business request correctly and aligns with the reference implementation. Both codes execute a SQL query to count shipments by destination city and order the results by the number of shipments. The input code optionally limits the display to the top 10 destinations, which is a reasonable enhancement. A bar chart is then created using Plotly to visualize the data, similar to the reference code. Thus, the input code logically fulfills the analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top destination cities
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY ShipCity 
ORDER BY TotalOrders DESC 
LIMIT 5
""""""

# Execute the SQL query and retrieve the data into a DataFrame
destination_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of shipments across the top destination cities
fig = px.bar(
    destination_df,
    x='ShipCity',
    y='TotalOrders',
    title='Top Shipping Destination Cities',
    labels={'TotalOrders': 'Total Orders', 'ShipCity': 'Shipping City'}
)

# Display the bar chart
show_to_user(fig)
```","The input code limits the results to the top 5 shipping destination cities using 'LIMIT 5', while the reference implementation does not impose such a limit. This difference means the input code does not fully adhere to the logic of the reference, which analyzes all destination cities without restriction.",Base
"Which employee handled the most orders, and can this be represented with a bar chart?","```python
import plotly.express as px
import pandas as pd

# SQL query to find the employee who handled the most orders
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY NumberOfOrders DESC 
LIMIT 1;
""""""

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is expected to connect to a database, execute the query,
    # and return the result as a pandas DataFrame.
    # Here we mock the result for demonstration purposes.
    data = {'EmployeeID': [3], 'NumberOfOrders': [50]}  # Example data
    return pd.DataFrame(data)

# Mocked utility function to show the result to user
def show_to_user(data):
    # Ideally, this would display data or visualization to the user,
    # likely in a Jupyter Notebook or web application context.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the SQL query and get the result
df_result = execute_sql_query(sql_query)

# Display the result DataFrame
show_to_user(df_result)

# Plotting a bar chart if the DataFrame is not empty
if not df_result.empty:
    fig = px.bar(df_result, 
                 x='EmployeeID', 
                 y='NumberOfOrders',
                 title='Employee Handling the Most Orders',
                 labels={'NumberOfOrders': 'Number of Orders', 'EmployeeID': 'Employee ID'})
    show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
LIMIT 1
""""""

top_employee = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""

order_counts = execute_sql_query(sql_query_all)

fig = px.bar(order_counts, x='EmployeeID', y='OrderCount', title='Employee Order Count', labels={'OrderCount': 'Number of Orders', 'EmployeeID': 'Employee ID'})
show_to_user(fig)
```","The input code correctly implements the required functionality. It executes an SQL query to identify the employee who handled the most orders. Then it generates a bar chart using a broader dataset, allowing for representation of the number of orders by each employee. While it includes additional steps beyond the reference, such as fetching all order counts, it still adheres to the business analytics requirement to identify and represent the employee with the most orders graphically.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT employees.EmployeeID, CONCAT(employees.FirstName, ' ', employees.LastName) AS EmployeeName, 
       COUNT(orders.OrderID) AS NumberHandled 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
GROUP BY employees.EmployeeID, EmployeeName 
ORDER BY NumberHandled DESC 
LIMIT 1
""""""

# Execute SQL query
df = execute_sql_query(sql_query)

# Check if there's a result to display
if not df.empty:
    # Generate a bar chart using Plotly
    fig = px.bar(df, x='EmployeeName', y='NumberHandled', 
                 title='Employee with Most Orders Handled', 
                 labels={'NumberHandled': 'Number of Orders'})
    
    # Display the figure
    show_to_user(fig)
else:
    # Display a message if no data is returned
    show_to_user('No data available to display.')
```","The input code correctly defines and executes a SQL query to find the employee who handled the most orders. It groups by EmployeeID and orders by the number handled, similar to the reference. It also generates a bar chart with the employee's name and their number of handled orders, which is a logical extension to the task. Both codes aim to identify and visualize the top employee by order handling, fulfilling the business request.",both
Calculate the total freight cost for orders shipped by each method and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Sample utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for database connection and query execution
    # Replace with actual database querying logic
    data = {
        'ShipVia': [1, 2, 3],
        'TotalFreightCost': [300.25, 450.50, 220.75]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # Placeholder for displaying results
    print(data)

# Executing the SQL query to get the data
sql_query = ""SELECT o.ShipVia, SUM(o.Freight) AS TotalFreightCost FROM orders o GROUP BY o.ShipVia;""
orders_df = execute_sql_query(sql_query)

# Creating a bar chart using Plotly
fig = px.bar(orders_df, x='ShipVia', y='TotalFreightCost',
             title=""Total Freight Cost by Shipping Method"",
             labels={'ShipVia': 'Shipping Method', 'TotalFreightCost': 'Total Freight Cost ($)'})

# Displaying the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, SUM(Freight) AS TotalFreight
FROM orders
GROUP BY ShipVia
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='ShipVia', y='TotalFreight', title='Total Freight Cost by Shipping Method')
show_to_user(fig)
```","The input Python code correctly implements the business analytics request using the same logic as the reference code. It calculates the total freight cost by shipping method and visualizes the data using a bar chart. The SQL query, data processing, and Plotly visualization accurately reflect the intended analysis, despite minor differences in variable names.","```python
import pandas as pd
import plotly.express as px

# SQL query to get total freight cost by shipping method
sql_query = ""SELECT ShipVia, SUM(Freight) AS TotalFreight FROM orders GROUP BY ShipVia;""

# Execute the SQL query and fetch the results into a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize total freight cost by shipping method
fig = px.bar(df, x='ShipVia', y='TotalFreight', title='Total Freight Cost by Shipping Method')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code adheres to the business analytics request and follows the same logic as the reference implementation. Both codes execute a SQL query to calculate the total freight costs for orders grouped by shipping method ('ShipVia'). Additionally, both codes use Plotly to create a bar chart to visualize the results. The difference in variable names ('TotalFreightCost' vs. 'TotalFreight') does not affect the logic or correctness of the code.",both
"Which customers have the highest retention rate over the past six months, and how can this be illustrated through a bar chart?","```python
import plotly.express as px
import pandas as pd

# Assuming utility functions are defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is a placeholder for the actual SQL execution logic
    pass

def show_to_user(data):
    # This function is a placeholder for displaying the data or visualization
    pass

# SQL query to fetch customer retention rates
sql_query = """"""
SELECT 
    c.CustomerID, 
    COUNT(DISTINCT o.OrderID) * 100.0 / (
        SELECT 
            COUNT(DISTINCT o2.OrderID) 
        FROM orders o2 
        WHERE o2.CustomerID = c.CustomerID AND o2.OrderDate >= DATEADD(month, -6, CURRENT_DATE)
    ) AS RetentionRate 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderDate >= DATEADD(month, -6, CURRENT_DATE) 
GROUP BY c.CustomerID 
ORDER BY RetentionRate DESC
""""""

# Execute the SQL query and get the result as a DataFrame
retention_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(retention_data, x='CustomerID', y='RetentionRate',
             title='Customer Retention Rate Over the Past Six Months',
             labels={'CustomerID': 'Customer ID', 'RetentionRate': 'Retention Rate (%)'},
             text='RetentionRate')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

end_date = datetime.now()
start_date = end_date - timedelta(days=180)

sql_query = f""""""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    COUNT(DISTINCT o1.OrderID) AS ReturningOrders,
    COUNT(DISTINCT o2.OrderID) AS TotalOrders,
    COUNT(DISTINCT o1.OrderID) * 1.0 / NULLIF(COUNT(DISTINCT o2.OrderID), 0) AS RetentionRate
FROM 
    customers c
LEFT JOIN orders o1 ON c.CustomerID = o1.CustomerID AND o1.OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}'
LEFT JOIN orders o2 ON c.CustomerID = o2.CustomerID AND o2.OrderDate < '{start_date.date()}'
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    RetentionRate DESC
LIMIT 10
""""""

retention_data = execute_sql_query(sql_query)

fig = px.bar(retention_data, 
             x='CompanyName', 
             y='RetentionRate', 
             title='Top 10 Customers by Retention Rate Over the Past Six Months',
             labels={'RetentionRate': 'Retention Rate', 'CompanyName': 'Company Name'})

show_to_user(fig)
```","The input Python code does not accurately calculate the retention rate over the past six months per the business analytics request. It computes retention rate using orders compared to orders before six months (o2). The logic used in joining orders is incorrect, and it limits results to the top 10 by retention rate. Furthermore, the retention rate in the input code is based on the formula involving orders before six months. Additionally, the visualization uses 'CompanyName' instead of 'CustomerID', deviating from the reference.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and fetch results
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for executing the query and returning a DataFrame
    # You would implement the actual logic to connect and execute the query.
    pass

# Function to display data or visualization
def show_to_user(data):
    # Placeholder function to display data or plot
    # In practice, this would show the data or render the plot.
    pass

# SQL query to fetch customer retention rate over the past six months
sql_query = """"""
SELECT c.CustomerID, 
       (COUNT(DISTINCT o.OrderID) / 
        (SELECT COUNT(DISTINCT o2.OrderID) 
         FROM orders o2 
         WHERE o2.CustomerID = c.CustomerID AND 
               o2.OrderDate BETWEEN '2023-03-01' AND '2023-08-31')) AS RetentionRate 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
WHERE o.OrderDate BETWEEN '2023-03-01' AND '2023-08-31' 
GROUP BY c.CustomerID 
ORDER BY RetentionRate DESC
""""""

# Execute the SQL query and get the DataFrame
retention_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(retention_df, x='CustomerID', y='RetentionRate', 
             title='Customer Retention Rate Over the Past Six Months',
             labels={'CustomerID': 'Customer ID', 'RetentionRate': 'Retention Rate'})

# Show the bar chart
show_to_user(fig)
```","The input code calculates the retention rate as a fraction (not percentage) and uses hardcoded date values ('2023-03-01' to '2023-08-31') instead of dynamically calculating the past six months using CURRENT_DATE and DATEADD. This could lead to inaccuracies if the current date changes. Also, it assumes specific date extraction is needed, rather than providing a more flexible range calculation.",None
"How many products have more units on order than in stock, and can this be visualized with a bar chart?","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query is a predefined function that executes SQL and returns a DataFrame
# Assume show_to_user is a predefined function to display results

# Define the SQL query
sql_query = """"""
SELECT COUNT(*) AS NumberOfProducts 
FROM products 
WHERE UnitsOnOrder > UnitsInStock;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualization: Create a bar chart if needed
fig = px.bar(df, x='NumberOfProducts', y='NumberOfProducts',
             title='Number of Products with More Units On Order Than In Stock',
             labels={'NumberOfProducts': 'Number of Products'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductID, ProductName, UnitsInStock, UnitsOnOrder
FROM products
WHERE UnitsOnOrder > UnitsInStock
""""""

df = execute_sql_query(sql_query)

product_count = df.shape[0]

fig = px.bar(df, x='ProductName', y='UnitsOnOrder', title='Products with Units on Order Greater than In Stock')
show_to_user(fig)

product_count
```","The input code does not adhere to the same logic as the reference implementation. The reference code calculates the count of products with more units on order than in stock and visualizes this count using a bar chart. The input code, however, retrieves each product's details that have more units on order than in stock, counts these products, and then visualizes each product by its name and units on order. This deviates from the reference logic of summarizing the data into a singular count for visualization.","```python
import plotly.express as px
import pandas as pd

# Assuming the existence of SQL execution utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should interface with the database to execute the query
    # and return the result as a pandas DataFrame
    pass

def show_to_user(data):
    # This function should display the data as required
    # Either print for DataFrame or show for Plotly figure
    pass

# SQL query to get the count of products having more units on order than in stock
sql_query = ""SELECT COUNT(*) AS ProductsWithMoreOrderThanStock FROM products WHERE UnitsOnOrder > UnitsInStock;""

# Execute the SQL query
df_result = execute_sql_query(sql_query)

# Extract the count of such products
products_count = df_result['ProductsWithMoreOrderThanStock'].iloc[0]

# Convert the count to a DataFrame for visualization
df_count = pd.DataFrame({'Condition': ['More Order than Stock'], 'Count': [products_count]})

# Create a bar chart using Plotly
fig = px.bar(df_count, x='Condition', y='Count', title='Products with More Units on Order than in Stock')

# Display the result
show_to_user(fig)
```","The input Python code correctly implements the logic of counting products with more units on order than in stock, using a SQL query similar to the reference implementation. Both codes make use of SQL queries to retrieve the count and then create a bar chart visualization using Plotly. The input code handles the conversion of the count to a DataFrame for consistent visualization and uses meaningful labels. Although the naming and slight implementation details differ, the business logic and requirements are met as per the reference.",Finetuned
What is the average freight cost for orders shipped to 'USA'? Please include a visualization to show the distribution of freight costs for better insights.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch freight costs for orders shipped to the USA
sql_query = ""SELECT Freight FROM orders WHERE ShipCountry = 'USA';""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Calculate the average freight cost
average_freight_cost = df['Freight'].mean()

# Print the average freight cost
average_cost_df = pd.DataFrame({'Average Freight Cost': [average_freight_cost]})
show_to_user(average_cost_df)

# Visualize the distribution of freight costs
fig = px.histogram(df, x='Freight', nbins=20, title='Distribution of Freight Costs for Orders Shipped to USA')
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT Freight
FROM orders
WHERE ShipCountry = 'USA'
""""""

freight_data = execute_sql_query(sql_query)
average_freight = freight_data['Freight'].mean()

fig = px.histogram(freight_data, x='Freight', title='Distribution of Freight Costs for Orders Shipped to USA')
show_to_user(fig)

average_freight
```","The provided code correctly computes the average freight cost for orders shipped to the USA using a SQL query and calculates the mean of the 'Freight' column. It also visualizes the distribution of freight costs using a histogram. Despite minor differences in formatting (e.g., multiline SQL query and not storing the average in a DataFrame), the logic and output are consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Assume execute_sql_query and show_to_user are predefined elsewhere as per the environment constraints

# SQL query to retrieve freight cost data for orders shipped to 'USA'
sql_query = ""SELECT Freight FROM orders WHERE ShipCountry = 'USA';""

# Execute the SQL query and obtain the data as a Pandas DataFrame
freight_data_df = execute_sql_query(sql_query)

# Calculate the average freight cost for orders shipped to 'USA'
average_freight_cost = freight_data_df['Freight'].mean()

# Display the average freight cost to the user
show_to_user(pd.DataFrame({'AverageFreightCost': [average_freight_cost]}))

# Create a histogram to visualize the distribution of freight costs
fig = px.histogram(freight_data_df, x='Freight', title='Distribution of Freight Costs for Orders Shipped to USA')

# Show the histogram to the user
show_to_user(fig)
```","The input Python code performs the same operations as the reference implementation. It retrieves the freight cost data for orders shipped to 'USA', calculates the average freight cost, displays it, and creates a histogram to show the distribution of freight costs. The logic and operations match those in the reference code, albeit with slight differences in variable names, which do not affect the correctness.",both
"What is the total sales revenue generated by each employee, and can it be visualized using a bar chart to compare performance?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total sales revenue by each employee
sql_query = """"""
SELECT o.EmployeeID, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.EmployeeID;
""""""

# Execute the SQL query to get the data into a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Visualize the total sales by employee using a bar chart
fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', 
             title='Total Sales Revenue by Employee',
             labels={'TotalSales': 'Total Sales Revenue', 'EmployeeID': 'Employee ID'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.EmployeeID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.EmployeeID
""""""

sales_data = execute_sql_query(sql_query)

fig = px.bar(sales_data, x='EmployeeID', y='TotalSales', title='Total Sales Revenue per Employee', 
             labels={'EmployeeID': 'Employee ID', 'TotalSales': 'Total Sales Revenue'})
show_to_user(fig)
```","The input Python code correctly implements the business analytics request as specified. It executes an SQL query to calculate total sales revenue for each employee, storing the result in a DataFrame called 'sales_data'. Subsequently, it uses Plotly to create a bar chart visualizing total sales by 'EmployeeID'. Both implementations follow the same logic and generate the desired visual output, albeit with a slight difference in the bar chart title wording, which does not affect the correctness.","```python
import plotly.express as px


def execute_sql_query(sql_query: str):
    # Placeholder for actual SQL execution code
    # This function should return a DataFrame with the query result
    pass


def show_to_user(data):
    # Placeholder for showing data, either a DataFrame or Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to retrieve total sales revenue by each employee
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
GROUP BY employees.EmployeeID
""""""

# Execute the SQL query and retrieve the result as a pandas DataFrame
df_sales_by_employee = execute_sql_query(sql_query)

# Create a bar chart using Plotly to compare the total sales revenue by each employee
fig = px.bar(df_sales_by_employee, 
             x='EmployeeID', 
             y='TotalSales',
             title='Total Sales Revenue by Employee',
             labels={'TotalSales': 'Total Sales ($)', 'EmployeeID': 'Employee ID'})

# Show the bar chart to the user
show_to_user(fig)
```","The input code provides the same functionality as the reference implementation. It correctly retrieves total sales revenue by each employee using a SQL query, executed through a placeholder function 'execute_sql_query'. It then visualizes the results using Plotly to create a bar chart, which aligns with the business analytics request. Differences in table join order within the SQL statement do not affect the correctness as it achieves the same result. The bar chart creation and display logic are similar, thus adhering to the specified business requirement.",both
"What is the total number of products sold this quarter, and can this be represented in a bar chart comparing each month?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total number of products sold per month this quarter
sql_query = """"""
SELECT 
    DATE_TRUNC('month', orders.OrderDate) AS month,
    SUM([Order Details].Quantity) AS total_quantity
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
WHERE 
    OrderDate >= DATE_TRUNC('quarter', CURRENT_DATE)
GROUP BY 
    month
ORDER BY 
    month;
""""""

# Function call to execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to compare the total number of products sold each month
fig = px.bar(sales_data, x='month', y='total_quantity', title='Total Products Sold This Quarter by Month')

# Display the resulting bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the total products sold each month for this quarter
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    SUM(Quantity) AS TotalProductsSold
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
WHERE 
    OrderDate >= DATE_FORMAT(CURRENT_DATE - INTERVAL (MONTH(CURRENT_DATE) - 1) MONTH, '%Y-%m-01') 
    AND OrderDate < DATE_FORMAT(CURRENT_DATE + INTERVAL 1 MONTH, '%Y-%m-01')
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute SQL query and get results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart for the total products sold each month
fig = px.bar(df, x='Month', y='TotalProductsSold', title='Total Products Sold This Quarter', labels={'TotalProductsSold': 'Products Sold', 'Month': 'Month'})
show_to_user(fig)

# Calculate total number of products sold this quarter
total_products_sold = df['TotalProductsSold'].sum()
total_products_sold
```","The input code calculates the total number of products sold per month for the current quarter and creates a bar chart, similar to the reference implementation. Both use SQL to query sales data, ensuring logic consistency. The difference in date handling (SQLite's DATE_FORMAT vs. PostgreSQL's DATE_TRUNC) aligns with different SQL dialects but results in the same quarter-based monthly grouping. Additionally, the input code correctly sums total quantities to report the quarter's overall sales, fulfilling the request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get monthly product counts for the current quarter
sql_query = """"""
SELECT 
    DATEPART(MONTH, ShippedDate) AS Month, 
    SUM(od.Quantity) AS TotalSold 
FROM [Order Details] od 
JOIN orders ON od.OrderID = orders.OrderID 
WHERE DATEPART(QUARTER, ShippedDate) = DATEPART(QUARTER, CURRENT_DATE) 
AND DATEPART(YEAR, ShippedDate) = DATEPART(YEAR, CURRENT_DATE) 
GROUP BY DATEPART(MONTH, ShippedDate)
ORDER BY DATEPART(MONTH, ShippedDate);
""""""

# Execute the SQL query and store the result in a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Plot the data using Plotly
fig = px.bar(
    sales_data,
    x='Month',
    y='TotalSold',
    title='Total Products Sold This Quarter',
    labels={'Month': 'Month', 'TotalSold': 'Total Sold'},
    text='TotalSold'
)

# Display the bar chart
show_to_user(fig)
```","The input code correctly calculates the total number of products sold each month for the current quarter and displays the result in a bar chart, similar to the reference implementation. The difference in date functions (DATEPART vs DATE_TRUNC) accommodates different databases (possibly SQL Server vs PostgreSQL), yet the logic remains consistent. The main operations—filtering the current quarter, grouping by month, and summing the quantities—are present in both implementations. Therefore, the input code adheres to the same business logic as the reference.",both
Which products are ordered more after being marked as 'discontinued'? Include a bar chart comparing the order quantities before and after discontinuation.,"```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for function that executes SQL queries
    # Returns a pandas DataFrame
    pass

def show_to_user(data):
    # Placeholder for function to display DataFrame or Plotly figure
    pass

# SQL queries to retrieve order quantities before and after discontinuation
sql_query_before = """"""
SELECT p.ProductName, SUM(od.Quantity) as TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 0
GROUP BY p.ProductName
ORDER BY p.ProductID;
""""""

sql_query_after = """"""
SELECT p.ProductName, SUM(od.Quantity) as TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE p.Discontinued = 1
GROUP BY p.ProductName
ORDER BY p.ProductID;
""""""

# Execute SQL queries and get results
before_discontinuation = execute_sql_query(sql_query_before)
after_discontinuation = execute_sql_query(sql_query_after)

# Merging the data for comparison
comparison_df = before_discontinuation.merge(after_discontinuation, on='ProductName', suffixes=('_before', '_after'))

# Plotting the data
fig = px.bar(comparison_df, x='ProductName', y=['TotalQuantity_before', 'TotalQuantity_after'],
             title='Order Quantities Before and After Discontinuation',
             labels={'value': 'Order Quantity', 'variable': 'Status'})

# Display the plot to user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

# Fetch order details and product information
sql_query = """"""
WITH ProductOrders AS (
    SELECT 
        p.ProductID,
        p.ProductName,
        SUM(CASE WHEN o.OrderID IS NOT NULL THEN od.Quantity ELSE 0 END) AS TotalOrdered,
        p.Discontinued
    FROM products p
    LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID
    LEFT JOIN (SELECT DISTINCT OrderID FROM [Order Details]) o ON od.OrderID = o.OrderID
    GROUP BY p.ProductID, p.ProductName, p.Discontinued
)
SELECT 
    ProductID,
    ProductName,
    SUM(CASE WHEN Discontinued = 1 THEN TotalOrdered ELSE 0 END) AS AfterDiscontinued,
    SUM(CASE WHEN Discontinued = 0 THEN TotalOrdered ELSE 0 END) AS BeforeDiscontinued
FROM ProductOrders
GROUP BY ProductID, ProductName
HAVING SUM(CASE WHEN Discontinued = 1 THEN TotalOrdered ELSE 0 END) > 0
ORDER BY ProductName;
""""""

product_orders_df = execute_sql_query(sql_query)

# Plotting
fig = px.bar(product_orders_df, 
              x='ProductName', 
              y=['BeforeDiscontinued', 'AfterDiscontinued'], 
              barmode='group', 
              title='Order Quantities Before and After Discontinuation')

show_to_user(fig)
```","The input code incorrectly calculates order quantities. It uses a joined query to calculate both 'BeforeDiscontinued' and 'AfterDiscontinued' quantities simultaneously, and then incorrectly sums these using a case statement. The reference implementation uses separate queries to accurately capture quantities before and after discontinuation. The input code's logic does not match the reference implementation's logic.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT p.ProductName, SUM(CASE WHEN o.OrderDate <= d.DiscontinuedDate THEN od.Quantity ELSE 0 END) AS OrdersBefore,
SUM(CASE WHEN o.OrderDate > d.DiscontinuedDate THEN od.Quantity ELSE 0 END) AS OrdersAfter
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
JOIN (
    SELECT ProductName, MAX(OrderDate) AS DiscontinuedDate 
    FROM products 
    WHERE Discontinued = 1 
    GROUP BY ProductName
) d
ON p.ProductName = d.ProductName
GROUP BY p.ProductName
""""""

# Execute the SQL query
df_orders = execute_sql_query(sql_query)

# Filter products where orders increased after discontinuation
df_filtered = df_orders[df_filtered['OrdersAfter'] > df_filtered['OrdersBefore']]

# Create the bar chart
fig = px.bar(df_filtered, x='ProductName', y=['OrdersBefore', 'OrdersAfter'],
             labels={'value': 'Order Quantities', 'variable': 'Timing'},
             title='Order Quantities Before and After Discontinuation')

# Show the bar chart
show_to_user(fig)
```","The evaluated code uses a different logic by considering the last order date as the discontinuation cut-off for each product, while the reference code uses a simpler distinction based on the 'Discontinued' status. The evaluated code also filters products where orders increased, which is not depicted in the reference implementation. Therefore, they are not equivalent in logic.",None
"Which ship cities have the longest average order fulfillment times, and can this be visualized using a bar chart to enhance understanding?","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user functions are already implemented

def analyze_fulfillment_times():
    # SQL query to get the average fulfillment time by ShipCity
    sql_query = """"""
    SELECT ShipCity, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
    FROM orders 
    GROUP BY ShipCity 
    ORDER BY AvgFulfillmentTime DESC;
    """"""
    
    # Execute the SQL query and get the result as a DataFrame
    df = execute_sql_query(sql_query)

    # Create a bar chart using Plotly
    fig = px.bar(df, x='ShipCity', y='AvgFulfillmentTime', 
                 title='Average Order Fulfillment Time by Ship City', 
                 labels={'AvgFulfillmentTime': 'Avg Fulfillment Time (days)', 'ShipCity': 'Ship City'})
    
    # Display the bar chart
    show_to_user(fig)

# Call the function to perform the analysis
analyze_fulfillment_times()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipCity, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipCity
ORDER BY AvgFulfillmentTime DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ShipCity', y='AvgFulfillmentTime', 
              title='Average Order Fulfillment Time by Ship City',
              labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)', 'ShipCity': 'Ship City'})

show_to_user(fig)
```","The input Python code performs the same logical operations as the reference implementation. It executes the same SQL query to compute the average fulfillment time by ship city, sorts the results, and uses Plotly to create a bar chart with appropriate labels and titles. Both codes display the visualization using a function, making them equivalent in functionality and logic.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCity, AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
GROUP BY ShipCity
ORDER BY AvgFulfillmentTime DESC;
""""""

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize average fulfillment times
fig = px.bar(df, x='ShipCity', y='AvgFulfillmentTime',
             title='Average Order Fulfillment Time by Ship City',
             labels={'AvgFulfillmentTime': 'Average Fulfillment Time (Days)'},
             text='AvgFulfillmentTime')

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code achieves the same outcome as the reference code. It executes the same SQL query to calculate the average fulfillment time by ship city, sorts the results, and uses Plotly to create and display a bar chart. The addition of `text='AvgFulfillmentTime'` in the bar chart enhances the visualization by adding labels without affecting the correctness of the analysis.",both
"List all suppliers who have never had a discontinuation in their products, and include a bar chart showing the count of active products per supplier.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to find all suppliers with no discontinued products
query = """"""
SELECT SupplierID, CompanyName 
FROM suppliers 
WHERE SupplierID NOT IN (
    SELECT DISTINCT SupplierID 
    FROM products 
    WHERE Discontinued = 1
);
""""""
suppliers_df = execute_sql_query(query)

# Execute the SQL query to count active products for each supplier
active_products_query = """"""
SELECT SupplierID, COUNT(ProductID) as ActiveProductCount 
FROM products 
WHERE Discontinued = 0 
GROUP BY SupplierID;
""""""
active_products_df = execute_sql_query(active_products_query)

# Merge the dataframes to get count of active products for suppliers without discontinued products
merged_df = pd.merge(suppliers_df, active_products_df, on='SupplierID', how='left')
merged_df['ActiveProductCount'] = merged_df['ActiveProductCount'].fillna(0)

# Generate a bar chart showing count of active products per supplier
fig = px.bar(merged_df, 
             x='CompanyName', 
             y='ActiveProductCount', 
             title='Active Products per Supplier (No Discontinued Products)',
             labels={'ActiveProductCount': 'Count of Active Products', 'CompanyName': 'Supplier Name'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, COUNT(p.ProductID) AS ActiveProductCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.Discontinued = 0
GROUP BY s.SupplierID, s.CompanyName
HAVING s.SupplierID NOT IN (
    SELECT DISTINCT p.SupplierID
    FROM products p
    WHERE p.Discontinued = 1
)
""""""

suppliers_df = execute_sql_query(sql_query)

fig = px.bar(suppliers_df, x='CompanyName', y='ActiveProductCount', 
             title='Count of Active Products per Supplier', 
             labels={'CompanyName': 'Supplier', 'ActiveProductCount': 'Active Products'})

show_to_user(fig)
```","The input Python code correctly identifies suppliers who have never had a discontinued product by checking suppliers against a subquery that selects suppliers with discontinued products. It then generates a bar chart with the count of active products per supplier. While it uses a different structure from the reference code, it adheres to the same logic and fulfills the business analytics request.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get suppliers who have never had a discontinuation
sql_discontinuations = """"""
SELECT SupplierID 
FROM products 
WHERE Discontinued = 1 
GROUP BY SupplierID;
""""""

# Execute the SQL query and get the suppliers with products that have been discontinued
discontinued_suppliers_df = execute_sql_query(sql_discontinuations)

# Convert to a set for faster lookup
discontinued_suppliers = set(discontinued_suppliers_df['SupplierID'])

# SQL Query to get all suppliers and their active product counts
sql_suppliers_with_active_products = """"""
SELECT SupplierID, COUNT(*) AS ActiveProductsCount 
FROM products 
WHERE Discontinued = 0 
GROUP BY SupplierID;
""""""

# Execute the SQL query
suppliers_df = execute_sql_query(sql_suppliers_with_active_products)

# Filter out suppliers who have ever had a discontinuation
suppliers_without_discontinuations = suppliers_df[~suppliers_df['SupplierID'].isin(discontinued_suppliers)]

# Create a bar chart using Plotly
fig = px.bar(suppliers_without_discontinuations, 
             x='SupplierID', 
             y='ActiveProductsCount', 
             title='Active Products Count Per Supplier (No Discontinuation)',
             labels={'ActiveProductsCount': 'Number of Active Products'})

# Show the results using the utility function
show_to_user(fig)
show_to_user(suppliers_without_discontinuations)
```","The input code and the reference code follow different logic. The reference code first queries for suppliers without discontinued products and then merges this list with the active product counts. The input code first finds suppliers with discontinued products, converts this to a set, and then filters out these suppliers from the suppliers with active products. Additionally, the input code does not fetch supplier names, which is an important part of the output as specified in the request.",Base
"What is the total discount amount for each customer, and can you provide a bar chart to illustrate these amounts?","```python
import pandas as pd
import plotly.express as px

# Provided utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for the purpose of this code
    # In practice, this function would execute the SQL query and return the result as a pandas DataFrame.
    pass

def show_to_user(data):
    # Dummy implementation for the purpose of this code
    # This function would display a DataFrame or Plotly figure.
    pass

# SQL query to retrieve data
sql_query = """"""
SELECT c.CustomerID, SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Check if the DataFrame is not None or empty
if df is not None and not df.empty:
    # Generate a bar chart
    fig = px.bar(df, x='CustomerID', y='TotalDiscount', title='Total Discount Amount for Each Customer')

    # Display the bar chart
    show_to_user(fig)
else:
    print('No data available to display')
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.CustomerID, c.CompanyName
""""""

discount_df = execute_sql_query(sql_query)

fig = px.bar(discount_df, x='CompanyName', y='TotalDiscount', title='Total Discount Amount per Customer', labels={'TotalDiscount': 'Total Discount', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The input code includes 'CompanyName' in the SQL query's SELECT and GROUP BY clauses, while the reference code only selects and groups by 'CustomerID'. Additionally, the input code omits the 'UnitPrice' component in the discount calculation, impacting the logic and results compared to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate total discount amount for each customer
sql_query = """"""
SELECT 
    o.CustomerID, 
    SUM(od.UnitPrice * od.Quantity * od.Discount) AS TotalDiscount 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.CustomerID;
""""""

# Execute the SQL query and retrieve results in a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Here you would typically have code that executes the SQL query
    # and returns a pandas DataFrame. For illustration, we will
    # pretend this function is implemented correctly.
    pass

# Execute the query and get the DataFrame
discount_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(discount_df, x='CustomerID', y='TotalDiscount', 
             title='Total Discount Amount per Customer',
             labels={'CustomerID': 'Customer ID', 'TotalDiscount': 'Total Discount Amount'})

# Display the bar chart to the user
def show_to_user(data):
    # Here you would typically show the data to the user,
    # either as a DataFrame or as a Plotly figure.
    pass

# Show the bar chart
show_to_user(fig)
```","The input code calculates the total discount per customer but uses the 'orders' table to retrieve the 'CustomerID' instead of the 'customers' table as in the reference implementation. This difference in the SQL query means the code logic is not identical. The grouping and calculations are otherwise the same, but there is a deviation in table joins and data retrieval logic.",None
Which customer has made the most purchases? Please include a bar chart to visualize the top 10 customers by the number of purchases.,"```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str):
    # Placeholder for database query execution
    # This function should return a pandas DataFrame
    pass

def show_to_user(data):
    # Placeholder for displaying data or visualization
    pass

# SQL query to retrieve purchase counts for each customer
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS PurchaseCount 
FROM orders 
GROUP BY CustomerID 
ORDER BY PurchaseCount DESC;
""""""

# Execute the query and store the result in a DataFrame
df = execute_sql_query(sql_query)

# Select the top 10 customers by number of purchases
top_customers = df.head(10)

# Create a bar chart
fig = px.bar(top_customers, x='CustomerID', y='PurchaseCount',
             title='Top 10 Customers by Number of Purchases',
             labels={'CustomerID': 'Customer ID', 'PurchaseCount': 'Number of Purchases'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CustomerID, c.CompanyName, COUNT(o.OrderID) AS PurchaseCount
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CompanyName
ORDER BY PurchaseCount DESC
LIMIT 10;
""""""

top_customers_df = execute_sql_query(sql_query)

fig = px.bar(top_customers_df, x='CompanyName', y='PurchaseCount', 
              title='Top 10 Customers by Number of Purchases', 
              labels={'CompanyName': 'Customer Name', 'PurchaseCount': 'Number of Purchases'})

show_to_user(fig)
```","The input code uses a slightly different SQL query that joins customers with orders and includes the CompanyName in the result, which is not used in the reference code. Additionally, the input code uses a LIMIT clause to directly retrieve the top 10 customers, while the reference implementation retrieves all customers and then uses `head(10)` to select the top 10. The logic of data retrieval is similar, but the approach differs, and the addition of CompanyName may lead to differences in customer identification.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 10 customers by number of purchases
sql_query = """"""
SELECT c.CustomerID, COUNT(*) AS TotalPurchases 
FROM orders o 
JOIN customers c ON o.CustomerID = c.CustomerID 
GROUP BY c.CustomerID 
ORDER BY TotalPurchases DESC 
LIMIT 10;
""""""

# Execute the SQL query
top_customers_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top 10 customers
fig = px.bar(top_customers_df, x='CustomerID', y='TotalPurchases', title='Top 10 Customers by Purchases')

# Show the visualization to the user
show_to_user(fig)
```","The input Python code is functionally correct and fulfills the business analytics request. It retrieves the top 10 customers with the most purchases and visualizes them with a bar chart. The SQL query correctly counts the purchases, groups by CustomerID, sorts in descending order, and limits the result to 10. Although the query joins with the 'customers' table, it doesn't affect the intended purchase count logic. The use of Plotly to create a bar chart follows the reference code's logic for visualization. Overall, the input code achieves the same outcome as the reference code.",Finetuned
"Which supplier's products have the lowest average rating based on discounts given, and can this be illustrated through a scatter plot showing the relationship between discounts and ratings?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL queries and return data as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Assuming this function is implemented to connect to a database, execute a query, and return a DataFrame
    pass

# Function to display data or visualization
def show_to_user(data):
    # Assuming this function is implemented to display the results
    pass

# SQL query to get the supplier with the lowest average discount
sql_query_supplier_with_lowest_discount = """"""
SELECT products.SupplierID, AVG([Order Details].Discount) AS AverageDiscount 
FROM products 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
GROUP BY products.SupplierID 
ORDER BY AverageDiscount ASC 
LIMIT 1;
""""""

# SQL query to get the relationship between discounts and ratings
sql_query_discounts_and_ratings = """"""
SELECT products.SupplierID, [Order Details].Discount, ratings.Rating
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN ratings ON products.ProductID = ratings.ProductID;
""""""

# Execute queries
supplier_df = execute_sql_query(sql_query_supplier_with_lowest_discount)
discounts_ratings_df = execute_sql_query(sql_query_discounts_and_ratings)

# Determine the supplier with the lowest average discount
lowest_discount_supplier = supplier_df.iloc[0]['SupplierID']

# Filter data for the supplier with the lowest average discount
filtered_data = discounts_ratings_df[discounts_ratings_df['SupplierID'] == lowest_discount_supplier]

# Create a scatter plot to illustrate the relationship between discounts and ratings for the supplier
fig = px.scatter(
    filtered_data,
    x='Discount',
    y='Rating',
    title=f'Relationship between Discounts and Ratings for Supplier {lowest_discount_supplier}',
    labels={'Discount': 'Discount Given', 'Rating': 'Product Rating'},
    trendline='ols'  # Adding a trendline for better understanding
)

# Display the scatter plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    s.SupplierID, 
    s.CompanyName, 
    AVG(od.Discount) AS AvgDiscount, 
    AVG(od.DiscountedRating) AS AvgRating
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    (SELECT 
         ProductID, 
         (UnitPrice * Quantity) * (1 - Discount) AS DiscountedRating
     FROM 
         [Order Details]) AS dr ON p.ProductID = dr.ProductID
GROUP BY 
    s.SupplierID, s.CompanyName
ORDER BY 
    AvgRating ASC
LIMIT 1;
""""""

supplier_data = execute_sql_query(sql_query)

scatter_plot = px.scatter(supplier_data, 
                           x='AvgDiscount', 
                           y='AvgRating', 
                           title='Relationship between Discounts and Ratings',
                           labels={'AvgDiscount': 'Average Discount', 'AvgRating': 'Average Rating'})

show_to_user(scatter_plot)
```","The input code does not correctly implement the business request as specified. The reference code identifies the supplier with the lowest average discount, whereas the input code incorrectly attempts to determine a supplier based on 'AvgRating' using a different method ('DiscountedRating'). The input code also does not calculate the correct relationship between discounts and ratings for the supplier with the lowest average discount but tries to create an average rating instead.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user functions are pre-defined

# SQL query to retrieve necessary data
sql_query = """"""
SELECT s.CompanyName, 
       AVG(r.Rating) AS AverageRating, 
       AVG(od.Discount) AS AverageDiscount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
JOIN CustomerRatings r ON p.ProductID = r.ProductID
GROUP BY s.CompanyName
ORDER BY AverageRating ASC;
""""""

# Execute the SQL query and retrieve the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a scatter plot to show the relationship between AverageDiscount and AverageRating
fig = px.scatter(df, x='AverageDiscount', y='AverageRating', 
                 hover_data=['CompanyName'], 
                 labels={'AverageDiscount':'Average Discount', 'AverageRating':'Average Rating'},
                 title='Relationship between Discount and Product Rating for Suppliers')

# Show the plot to the user
show_to_user(fig)
```","The input code evaluates the average rating and discount across all suppliers, rather than finding the supplier with the lowest average discount and then analyzing the relationship between discounts and ratings for that specific supplier. The reference code focuses on identifying one supplier based on discount and visualizing their discount-rating relationship, while the input code generalizes to all suppliers.",None
"Which employee handled the highest number of orders, and can this be represented with a bar chart to compare all employees?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per employee
sql_query = '''
SELECT EmployeeID, COUNT(OrderID) AS NumOrders 
FROM orders 
GROUP BY EmployeeID 
ORDER BY NumOrders DESC;
'''

# Execute SQL query and store results in a DataFrame
df_orders = execute_sql_query(sql_query)

# Identify the employee with the highest number of orders
top_employee = df_orders.iloc[0]

# Create a bar chart to compare the number of orders handled by each employee
fig = px.bar(df_orders, x='EmployeeID', y='NumOrders', 
             title='Number of Orders Handled by Each Employee',
             labels={'NumOrders': 'Number of Orders', 'EmployeeID': 'Employee ID'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY EmployeeID
ORDER BY OrderCount DESC
""""""
order_counts = execute_sql_query(sql_query)

highest_employee = order_counts.iloc[0]
highest_employee_id = highest_employee['EmployeeID']
highest_order_count = highest_employee['OrderCount']

fig = px.bar(order_counts, x='EmployeeID', y='OrderCount', title='Orders Handled by Each Employee')
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. Both the input and reference codes execute an SQL query to count orders per employee, identify the employee with the highest order count, and create a bar chart using Plotly Express. The differences in variable names and label text do not affect the core functionality or outcome. Thus, the input code meets the business request appropriately.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the count of orders for each employee
sql_query = ""SELECT EmployeeID, COUNT(OrderID) AS OrderCount FROM orders GROUP BY EmployeeID ORDER BY OrderCount DESC;""

# Execute the SQL query using the predefined utility function
employees_orders_df = execute_sql_query(sql_query)

# Find the employee with the highest number of orders
top_employee_df = employees_orders_df.head(1)

# Display the employee with the highest number of orders
show_to_user(top_employee_df)

# Create a bar chart to visualize the number of orders handled by each employee
fig = px.bar(employees_orders_df, x='EmployeeID', y='OrderCount', title='Number of Orders by Employee')

# Display the bar chart
show_to_user(fig)
```","The input Python code correctly answers the business analytics request and adheres to the logic of the reference implementation. Both implementations query the database to get the count of orders per employee, identify the employee with the highest number of orders, and display a bar chart comparing orders handled by all employees. The only differences are variable names and code structuring, which do not affect the logic or correctness.",both
"Get the top 3 cities with the highest number of suppliers, and visualize the results using a bar chart.","import plotly.express as px

# The SQL query to execute
sql_query = """"""
SELECT City, COUNT(SupplierID) AS NumSuppliers 
FROM suppliers 
GROUP BY City 
ORDER BY NumSuppliers DESC 
LIMIT 3;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
top_cities_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    top_cities_df, 
    x='City', 
    y='NumSuppliers', 
    title='Top 3 Cities with the Highest Number of Suppliers',
    labels={'NumSuppliers': 'Number of Suppliers'}
)

# Show the chart to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT City, COUNT(SupplierID) AS SupplierCount 
FROM suppliers 
GROUP BY City 
ORDER BY SupplierCount DESC 
LIMIT 3
""""""

top_cities = execute_sql_query(sql_query)

fig = px.bar(top_cities, x='City', y='SupplierCount', title='Top 3 Cities with Highest Number of Suppliers')
show_to_user(fig)
```","The input code correctly implements the business analytics request by querying the top 3 cities with the highest number of suppliers and visualizing the results using a bar chart with Plotly. The logic, SQL query structure, and data visualization are consistent with the reference implementation.","```python
import plotly.express as px

# Execute SQL query to get the top 3 cities with the highest number of suppliers.
sql_query = """"""
SELECT City, COUNT(DISTINCT SupplierID) AS SupplierCount
FROM suppliers
GROUP BY City
ORDER BY SupplierCount DESC
LIMIT 3;
""""""
data_frame = execute_sql_query(sql_query)

# Create a bar chart to visualize the data.
fig = px.bar(data_frame, x='City', y='SupplierCount', 
             title='Top 3 Cities with Highest Number of Suppliers',
             labels={'SupplierCount': 'Number of Suppliers'},
             template='plotly_dark')

# Display the bar chart to the user.
show_to_user(fig)
```","The input code answers the business analytics request and adheres to the logic of the reference implementation. The main difference is the use of COUNT(DISTINCT SupplierID) in the input code, which is stricter than COUNT(SupplierID) but still serves the same purpose here. Both codes retrieve the top 3 cities by the number of suppliers and visualize the result using a bar chart with Plotly, displaying it with 'show_to_user'. The chart aesthetics (template) do not affect the correctness.",both
"What is the retention rate of customers over the past year, and can you provide a line graph to visualize retention trends over each month?","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query and return DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function to execute SQL query and return results as DataFrame
    # This needs to be connected to an actual database in a real scenario
    pass

# Utility function to display the results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)  # Display DataFrame to user
    else:
        data.show()  # Display Plotly figure

# SQL query to fetch retention data for each month
sql_query = """"""
WITH monthly_customers AS (
    SELECT
        DATE_TRUNC('month', OrderDate) AS Month,
        COUNT(DISTINCT CustomerID) AS MonthlyCustomerCount
    FROM orders
    GROUP BY DATE_TRUNC('month', OrderDate)
),
initial_customers AS (
    SELECT
        COUNT(DISTINCT CustomerID) AS InitialCustomerCount
    FROM orders
    WHERE OrderDate < '2022-01-01'
)

SELECT
    mc.Month,
    (mc.MonthlyCustomerCount / NULLIF(ic.InitialCustomerCount, 0) * 100) AS RetentionRate
FROM monthly_customers mc
CROSS JOIN initial_customers ic
WHERE mc.Month BETWEEN '2022-01-01' AND '2022-12-31'
ORDER BY mc.Month
""""""

# Execute the SQL query
retention_df = execute_sql_query(sql_query)

# Ensure we have data returned from the query
if retention_df is not None and not retention_df.empty:
    # Create a line graph to visualize the retention trends over each month
    fig = px.line(retention_df, x='Month', y='RetentionRate', title='Customer Retention Trends Over Each Month')

    # Display the line graph to the user
    show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Define the current date to calculate the last year's data
current_date = pd.to_datetime(""today"")
start_date = (current_date - pd.DateOffset(years=1)).date()

# Query to get the retention data
retention_query = f""""""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month,
    COUNT(DISTINCT CASE WHEN OrderDate >= '{start_date}' THEN CustomerID END) AS returning_customers,
    COUNT(DISTINCT CustomerID) AS total_customers
FROM 
    orders
WHERE 
    OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    month
ORDER BY 
    month;
""""""

# Execute the query and get the data
retention_data = execute_sql_query(retention_query)

# Calculate the retention rate
retention_data['retention_rate'] = retention_data['returning_customers'] / retention_data['total_customers']

# Create line graph for retention trends
fig = px.line(retention_data, x='month', y='retention_rate', title='Customer Retention Rate Over the Past Year', labels={'retention_rate': 'Retention Rate', 'month': 'Month'})
show_to_user(fig)
```","The evaluated code queries customer retention for customers who returned in the past year, dividing by total customers each month, not against initial customers as in the reference code. Additionally, it formats dates differently and lacks the cross join used to calculate consistent retention against initial values.","```python
import pandas as pd
import plotly.express as px

# Assume utility functions for executing SQL and displaying results are defined
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation
    # Replace with actual logic to execute SQL query
    raise NotImplementedError(""This function should execute the SQL and return a DataFrame."")

def show_to_user(data):
    # Placeholder function to display data
    # Replace with actual logic to show data
    raise NotImplementedError(""This function should display the provided data."")

# SQL Query to fetch the retention data
sql_query = """"""
SELECT
    TO_CHAR(o.OrderDate, 'YYYY-MM') AS month,
    COUNT(DISTINCT o.CustomerID) AS retained_customers
FROM
    orders o
WHERE
    o.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY
    TO_CHAR(o.OrderDate, 'YYYY-MM')
ORDER BY
    TO_CHAR(o.OrderDate, 'YYYY-MM')
""""""

# Execute the SQL query and retrieve the data
retention_data = execute_sql_query(sql_query)

# Generate a line graph to visualize the retention trends over each month
fig = px.line(
    retention_data,
    x='month',
    y='retained_customers',
    title='Monthly Customer Retention (2022)',
    labels={'month': 'Month', 'retained_customers': 'Number of Retained Customers'}
)

# Display the graph to the user
show_to_user(fig)
```","The input code calculates the number of distinct customers per month for 2022, whereas the reference code calculates a retention rate based on the number of customers from an earlier period. It does not include retention calculation logic, which involves dividing the monthly customer count by an initial customer base.",None
"In which month did the highest average freight cost occur? Additionally, provide a line chart to visualize the average freight costs across all months.","```python
import plotly.express as px
import pandas as pd

# SQL query to find the month with the highest average freight cost
sql_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month, 
       AVG(Freight) AS AvgFreight 
FROM orders 
GROUP BY Year, Month 
ORDER BY AvgFreight DESC 
LIMIT 1;
""""""

# Execute the SQL query and store the result in a DataFrame
highest_avg_freight_month_df = execute_sql_query(sql_query)

# Display the month with the highest average freight cost
show_to_user(highest_avg_freight_month_df)

# SQL query to get average freight costs for all months
all_months_freight_query = """"""
SELECT EXTRACT(YEAR FROM OrderDate) AS Year, 
       EXTRACT(MONTH FROM OrderDate) AS Month, 
       AVG(Freight) AS AvgFreight 
FROM orders 
GROUP BY Year, Month 
ORDER BY Year, Month;
""""""

# Execute the query to retrieve average freight costs data
all_months_avg_freight_df = execute_sql_query(all_months_freight_query)

# Create a line chart to visualize the average freight costs across all months
fig = px.line(all_months_avg_freight_df, x='Month', y='AvgFreight', title='Average Freight Costs Across Months',
              labels={'Month': 'Month', 'AvgFreight': 'Average Freight Cost'}, markers=True)

# Show the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month, 
    AVG(Freight) AS AverageFreight
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    AverageFreight DESC
""""""

average_freight_df = execute_sql_query(sql_query)

highest_avg_freight_month = average_freight_df.iloc[0]

line_chart = px.line(average_freight_df, x='Month', y='AverageFreight', title='Average Freight Cost per Month')
show_to_user(line_chart)

highest_avg_freight_month
```","The input code lacks functionality to identify the specific month with the highest average freight cost in terms of separate year and month. It uses a combined 'Month' field while the reference code explicitly separates by year and month. The difference could lead to incorrect interpretation if data spans multiple years. Additionally, the visualization approach is slightly different in terms of markers, which are present in the reference but not in the input.","```python
import pandas as pd
import plotly.express as px

# SQL query to find the month with the highest average freight cost
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS OrderMonth, AVG(Freight) AS AvgFreight 
FROM orders 
GROUP BY OrderMonth 
ORDER BY AvgFreight DESC;
""""""

# Execute the SQL query and fetch results
df = execute_sql_query(sql_query)

# Find the month with the highest average freight cost
highest_cost_month = df.iloc[0]
show_to_user(highest_cost_month)

# Create a line chart to visualize average freight costs across all months
fig = px.line(df, x='OrderMonth', y='AvgFreight', title='Average Freight Costs by Month')
show_to_user(fig)
```","The input Python code does not align with the logic of the reference implementation. The reference code extracts both year and month, grouping by them to capture changes over different years. The input code only extracts the month, disregarding the year, which could lead to incorrect results if the dataset spans multiple years. Additionally, the reference code sorts by both year and month for the line chart, while the input code only sorts by month, which might disrupt the chronological order of data if multiple years are involved.",None
Calculate the total revenue for each supplier and create a bar chart to visualize the results.,"
```python
import pandas as pd
import plotly.express as px

# Define utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function is a placeholder and should be replaced with actual database query execution code
    raise NotImplementedError(""This function should execute the provided SQL query and return the results as a pandas DataFrame."")

def show_to_user(data):
    # This function is a placeholder for showing data to the user
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Given SQL query to calculate total revenue for each supplier
sql_query = """"""
SELECT 
    products.SupplierID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.SupplierID;
""""""

# Execute the SQL query and store the result in a DataFrame
df_revenue = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the total revenue for each supplier
fig = px.bar(df_revenue, x='SupplierID', y='TotalRevenue', title='Total Revenue by Supplier', labels={'TotalRevenue': 'Total Revenue', 'SupplierID': 'Supplier ID'})

# Display the bar chart to the user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
JOIN suppliers s ON p.SupplierID = s.SupplierID
GROUP BY s.SupplierID, s.CompanyName
""""""

df_revenue = execute_sql_query(sql_query)

fig = px.bar(df_revenue, x='CompanyName', y='TotalRevenue', title='Total Revenue by Supplier', labels={'TotalRevenue': 'Total Revenue', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly calculates the total revenue for each supplier and creates a bar chart. It includes 'CompanyName' in the SELECT and GROUP BY clauses to show supplier names in the visualization, which doesn't change the core logic of calculating total revenue. The logic is consistent with the reference implementation's objective.","```python
import plotly.express as px

# SQL query to retrieve supplier revenue data
sql_query = """"""
SELECT s.SupplierID, SUM(od.Quantity * od.UnitPrice) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN suppliers s ON p.SupplierID = s.SupplierID 
GROUP BY s.SupplierID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the total revenue for each supplier
fig = px.bar(df, x='SupplierID', y='TotalRevenue', title='Total Revenue per Supplier')

# Display the bar chart
show_to_user(fig)
```","The input Python code lacks the calculation of the discount factor present in the reference implementation. The reference code calculates total revenue as `UnitPrice * Quantity * (1 - Discount)`, while the input code only does `UnitPrice * Quantity`. This discrepancy means the input code doesn't accurately calculate total revenue considering discounts, making it incorrect.",Base
What is the average order value per employee? Please include a bar chart to visualize the results per employee.,"```python
import plotly.express as px
import pandas as pd

# SQL query to get the average order value per employee
sql_query = """"""
SELECT e.EmployeeID, 
       AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AvgOrderValue
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID;
""""""

# Execute the SQL query and store the results in a DataFrame
data = execute_sql_query(sql_query)

# Create a bar chart to visualize the average order value per employee
fig = px.bar(data, x='EmployeeID', y='AvgOrderValue', title='Average Order Value per Employee')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, 
       e.FirstName, 
       e.LastName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY e.EmployeeID, e.FirstName, e.LastName
""""""

data = execute_sql_query(sql_query)

data['AverageOrderValue'] = data['TotalSales'] / data['TotalSales'].count()
fig = px.bar(data_frame=data, 
             x='EmployeeID', 
             y='AverageOrderValue', 
             color='EmployeeID', 
             title='Average Order Value per Employee', 
             labels={'EmployeeID': 'Employee ID', 'AverageOrderValue': 'Average Order Value'})

show_to_user(fig)
```","The input code incorrectly calculates the 'AverageOrderValue'. It uses 'data['TotalSales'].count()' instead of the number of orders per employee. The reference code correctly uses 'AVG(od.UnitPrice * od.Quantity * (1 - od.Discount))'. Furthermore, the input code unnecessarily includes 'FirstName' and 'LastName', which are not required for the analysis.","```python
import plotly.express as px
import pandas as pd

# Assuming the function execute_sql_query exists in the provided environment
def execute_sql_query(sql_query: str):
    # Placeholder function to execute SQL query
    # Implement connectivity to the database and fetching logic here
    pass

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    elif hasattr(data, 'show'):
        data.show()

# SQL query from the business analytic request
sql_query = """"""
SELECT 
    employees.EmployeeID, 
    AVG(TotalAmount) AS AvgOrderValue 
FROM (
    SELECT 
        employees.EmployeeID, 
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalAmount 
    FROM 
        employees 
    JOIN 
        orders ON employees.EmployeeID = orders.EmployeeID 
    JOIN 
        [Order Details] ON orders.OrderID = [Order Details].OrderID 
    GROUP BY 
        employees.EmployeeID
) AS EmployeeOrderTotals
GROUP BY 
    employees.EmployeeID;
""""""

# Execute the SQL query and get the result in a pandas DataFrame
df = execute_sql_query(sql_query)

# Display the DataFrame to check the output
show_to_user(df)

# Create a bar chart using Plotly to visualize the average order value per employee
fig = px.bar(df, x='EmployeeID', y='AvgOrderValue', title='Average Order Value per Employee',
             labels={'AvgOrderValue': 'Average Order Value', 'EmployeeID': 'Employee ID'})

# Show the figure to the user
show_to_user(fig)
```","The input code correctly calculates the average order value per employee by aggregating the total amount per order and then averaging it. It matches the logic of the reference implementation, including joining employees, orders, and order details, and uses plotly to display a bar chart of the results.",Finetuned
Calculate the total revenue per country and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Assume the utility functions are defined as per the environment constraints
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should execute the SQL query and return a DataFrame
    # For demonstration purposes, we will assume a connection is established and pandas is used to read SQL
    # Example: return pd.read_sql_query(sql_query, connection)
    pass

def show_to_user(data):
    # This function is used to display output to the user
    # It either takes a DataFrame and outputs it or a Plotly figure and displays it
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to calculate total revenue per country
sql_query = """"""
SELECT o.ShipCountry, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY o.ShipCountry;
""""""

# Execute SQL query and fetch results into a DataFrame
revenue_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(revenue_df, x='ShipCountry', y='TotalRevenue', 
             title='Total Revenue per Country', 
             labels={'TotalRevenue': 'Total Revenue', 'ShipCountry': 'Country'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Country, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM customers c
JOIN orders o ON c.CustomerID = o.CustomerID
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY c.Country
""""""

revenue_data = execute_sql_query(sql_query)
fig = px.bar(revenue_data, x='Country', y='TotalRevenue', title='Total Revenue per Country', labels={'TotalRevenue': 'Total Revenue', 'Country': 'Country'})
show_to_user(fig)
```","The input code calculates the total revenue per country using a different SQL query, leveraging a JOIN on the 'customers' and 'orders' tables instead of directly using the 'orders' table for the country information. Both implementations aim to compute the total revenue per country and visualize the result using a bar chart. The logic is consistent, given that the 'Country' information is correctly joined and aggregated from the 'customers' table, and the final visualization is correctly displayed using Plotly.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    countries.CountryName, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalRevenue
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
JOIN 
    customers ON orders.CustomerID = customers.CustomerID
JOIN 
    countries ON customers.Country = countries.CountryCode
GROUP BY 
    countries.CountryName;
""""""

# Execute the SQL query and get the results in a DataFrame
df_total_revenue = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(df_total_revenue, x='CountryName', y='TotalRevenue', title='Total Revenue per Country')

# Display the visualization
show_to_user(fig)
```","The input code uses a different set of joins compared to the reference implementation, specifically including joins with a 'countries' table that is not present in the reference code. Additionally, it extracts 'CountryName' instead of 'ShipCountry', suggesting a different data structure or entity relationship assumption. These differences in logic and potential table structures mean the output may not align with the intended result of the reference implementation.",Base
"Which month had the highest total sales, and which employee contributed the most to it? Include a bar chart comparing monthly sales and a pie chart showing employee contributions for that month.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the highest total sales month and the top contributing employee
sql_query = """"""
SELECT SalesMonth, EmployeeID, TotalSales FROM (
    SELECT MONTH(o.OrderDate) AS SalesMonth, e.EmployeeID, 
           SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
    FROM employees e 
    JOIN orders o ON e.EmployeeID = o.EmployeeID 
    JOIN [Order Details] od ON o.OrderID = od.OrderID 
    GROUP BY SalesMonth, e.EmployeeID
) AS MonthlySales 
ORDER BY TotalSales DESC 
LIMIT 1;
""""""

# Executing SQL query and fetching results
monthly_sales_df = execute_sql_query(sql_query)

# Extracting the highest sales month and the top contributing employee details
highest_sales_month = monthly_sales_df['SalesMonth'].iloc[0]
top_employee_id = monthly_sales_df['EmployeeID'].iloc[0]

# SQL query to fetch sales data for the entire year to plot the bar chart
monthly_sales_bar_chart_query = """"""
SELECT MONTH(o.OrderDate) AS SalesMonth, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlyTotalSales 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY SalesMonth
""""""

# Executing SQL query for bar chart
monthly_sales_bar_df = execute_sql_query(monthly_sales_bar_chart_query)

# Creating a bar chart for monthly sales
bar_fig = px.bar(monthly_sales_bar_df, x='SalesMonth', y='MonthlyTotalSales', 
                 title='Monthly Sales', labels={'SalesMonth': 'Month', 'MonthlyTotalSales': 'Total Sales'})
show_to_user(bar_fig)

# SQL query to fetch employee contributions for the highest sales month
employee_contribution_query = f""""""
SELECT e.EmployeeID, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS EmployeeSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE MONTH(o.OrderDate) = {highest_sales_month} 
GROUP BY e.EmployeeID
""""""

# Executing SQL query for pie chart
employee_sales_df = execute_sql_query(employee_contribution_query)

# Creating a pie chart for employee contributions
pie_fig = px.pie(employee_sales_df, values='EmployeeSales', names='EmployeeID', 
                 title=f'Employee Contributions for Month {highest_sales_month}')
show_to_user(pie_fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS month,
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
JOIN 
    employees e ON o.EmployeeID = e.EmployeeID
GROUP BY 
    month, e.EmployeeID
ORDER BY 
    month, total_sales DESC
""""""

monthly_sales = execute_sql_query(sql_query)

highest_sales_month = monthly_sales.groupby('month').agg({'total_sales': 'sum'}).idxmax()[0]
highest_sales_data = monthly_sales[monthly_sales['month'] == highest_sales_month]

top_employee = highest_sales_data.loc[highest_sales_data['total_sales'].idxmax()]

monthly_sales_fig = px.bar(monthly_sales.groupby('month').agg({'total_sales': 'sum'}).reset_index(),
                             x='month', y='total_sales',
                             title='Monthly Sales Comparison')

employee_contributions_fig = px.pie(top_employee,
                                     names=['Employee', 'Sales'],
                                     values=['total_sales'],
                                     title=f'Employee Contributions for {highest_sales_month}')

show_to_user(monthly_sales_fig)
show_to_user(employee_contributions_fig)
```","The input code has multiple issues: 1) It uses DATE_FORMAT for month extraction, potentially different from MONTH in reference. 2) The grouping by 'month' and ordering by 'total_sales' without limiting to sum of sales for a specific period can lead to incorrect logic. 3) The pie chart construction is incorrect; it attempts to plot using 'top_employee' as data, which will cause errors since it's just a single DataFrame row and doesn't contain the required 'Employee' and 'Sales' columns. This deviates from the provided reference logic.","```python
import pandas as pd
import plotly.express as px

# Business Analytic function to fetch the monthly sales data
def fetch_monthly_sales():
    sql_query = """"""
    SELECT DATE_TRUNC('month', orders.OrderDate) AS month,
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    GROUP BY month
    ORDER BY month
    """"""
    return execute_sql_query(sql_query)

# Function to find the top employee for the month with the highest sales
def fetch_top_employee(month):
    sql_query = f""""""
    SELECT employees.EmployeeID, employees.FirstName, employees.LastName,
           SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS employee_sales
    FROM [Order Details]
    JOIN orders ON [Order Details].OrderID = orders.OrderID
    JOIN employees ON orders.EmployeeID = employees.EmployeeID
    WHERE DATE_TRUNC('month', orders.OrderDate) = '{month.strftime('%Y-%m')}'
    GROUP BY employees.EmployeeID, employees.FirstName, employees.LastName
    ORDER BY employee_sales DESC
    LIMIT 1
    """"""
    return execute_sql_query(sql_query)

# Function to visualize monthly sales and employee contributions
def visualize_data(monthly_sales_df, top_employee_df):
    # Bar chart for monthly sales
    fig_sales = px.bar(
        monthly_sales_df,
        x='month',
        y='total_sales',
        title='Monthly Sales',
        labels={'total_sales': 'Total Sales', 'month': 'Month'}
    )
    show_to_user(fig_sales)

    # Pie chart for employee contributions
    fig_employee = px.pie(
        top_employee_df,
        names='FirstName',
        values='employee_sales',
        title='Top Employee Contribution for the Month'
    )
    show_to_user(fig_employee)

# Main execution
monthly_sales_df = fetch_monthly_sales()
top_month_row = monthly_sales_df.loc[monthly_sales_df['total_sales'].idxmax()]
top_month = top_month_row['month']

# Find the top employee for that month
top_employee_df = fetch_top_employee(top_month)

# Visualize the data
visualize_data(monthly_sales_df, top_employee_df)
```","The input code correctly fetches monthly sales data and identifies the top employee for the month with the highest sales, similar to the reference code. It uses SQL queries to aggregate sales data and determine the top employee by monthly total, which aligns with the logic of the reference implementation. Additionally, it provides visualization through bar and pie charts, addressing the business request requirements.",Finetuned
"What is the total freight cost assigned to each employee, and can you provide a bar chart to visualize this data?","```python
import pandas as pd
import plotly.express as px

# The SQL query which gets total freight costs per employee
sql_query = """"""
SELECT e.FirstName, e.LastName, SUM(o.Freight) AS TotalFreight
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID, e.FirstName, e.LastName;
""""""

# Execute the SQL query and get the result as a DataFrame
employees_freight_df = execute_sql_query(sql_query)

# Create a bar chart to visualize total freight cost assigned to each employee
fig = px.bar(
    employees_freight_df, 
    x='FirstName', 
    y='TotalFreight', 
    color='LastName', 
    title='Total Freight Cost per Employee',
    labels={'TotalFreight': 'Total Freight Cost ($)', 'FirstName': 'Employee First Name'}
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       SUM(o.Freight) AS TotalFreight
FROM employees e
LEFT JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.EmployeeID
ORDER BY TotalFreight DESC
""""""

freight_data = execute_sql_query(sql_query)

fig = px.bar(freight_data, x='EmployeeName', y='TotalFreight', 
             title='Total Freight Cost Assigned to Each Employee', 
             labels={'TotalFreight': 'Total Freight Cost', 'EmployeeName': 'Employee'})
show_to_user(fig)
```","The input Python code answers the business analytics request and adheres to the same logic as the reference implementation, despite some differences in execution. Both codes calculate the total freight cost for each employee and visualize this data using a bar chart. The differences in SQL query (LEFT JOIN instead of JOIN) and visualization labels do not affect the correctness of the overall logic or outcome.","```python
import plotly.express as px

# SQL query for fetching data
sql_query = """"""
SELECT employees.EmployeeID, 
       SUM(orders.Freight) AS TotalFreightCost 
FROM orders 
JOIN employees ON orders.EmployeeID = employees.EmployeeID 
GROUP BY employees.EmployeeID;
""""""

# Execute the SQL query and get the data in a DataFrame
data_df = execute_sql_query(sql_query)

# Create a bar chart to visualize total freight cost by employee
fig = px.bar(data_df, x='EmployeeID', y='TotalFreightCost',
             title='Total Freight Cost by Employee',
             labels={'TotalFreightCost': 'Total Freight Cost ($)', 'EmployeeID': 'Employee ID'},
             template='plotly')

# Show the bar chart to the user
show_to_user(fig)
```","The evaluated code computes the total freight cost per employee but only by employee ID, not by first and last name, which means it lacks more detailed employee identification. In contrast, the reference code groups by employee first and last name for clarity. Additionally, the evaluated code does not use more descriptive names on the bar chart, unlike the reference implementation.",Base
"Which regions have the highest average order value, and can this be represented through a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT ShipRegion, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipRegion
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Sort the DataFrame by AvgOrderValue in descending order
df_sorted = df.sort_values(by='AvgOrderValue', ascending=False)

# Create a bar chart using Plotly
fig = px.bar(df_sorted, x='ShipRegion', y='AvgOrderValue', 
             title='Highest Average Order Value by Region',
             labels={'AvgOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.ShipRegion, 
    AVG(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS AverageOrderValue
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.ShipRegion
ORDER BY 
    AverageOrderValue DESC
""""""

average_order_value_df = execute_sql_query(sql_query)

fig = px.bar(average_order_value_df, 
             x='ShipRegion', 
             y='AverageOrderValue', 
             title='Average Order Value by Region',
             labels={'AverageOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})

show_to_user(fig)
```","The input code calculates the average order value by averaging the extended price for each line item, which isn't equivalent to the reference implementation. The reference calculates the sum of order values divided by the count of distinct orders per region, which accounts for multiple line items per order differently.","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT ShipRegion, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) / COUNT(DISTINCT o.OrderID) AS AvgOrderValue 
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
GROUP BY ShipRegion 
ORDER BY AvgOrderValue DESC;
""""""

# Execute the SQL query to get the data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should be defined in the environment
    pass

# This function should display the visualization
def show_to_user(data):
    pass

# Get the data from the database
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ShipRegion', y='AvgOrderValue', 
             title='Average Order Value by Region', 
             labels={'AvgOrderValue': 'Average Order Value', 'ShipRegion': 'Region'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code effectively answers the business analytics request and adheres closely to the reference implementation's logic. Both implementations use SQL to calculate the average order value for each region, joining the orders and order details tables and grouping by ShipRegion. The input code includes an ORDER BY clause in the SQL query instead of sorting the DataFrame afterward, but this does not alter the outcome. Additionally, both codes use Plotly to create a bar chart displaying average order values by region. The input code meets the requirement to evaluate and visualize the highest average order values by region.",Finetuned
"Which supplier has the highest total sales for discontinued products, and can this be represented with a bar chart comparing the suppliers?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS total_sales 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE products.Discontinued = TRUE 
GROUP BY suppliers.CompanyName 
ORDER BY total_sales DESC
""""""

# Execute the SQL query to get the data as a DataFrame
df = execute_sql_query(sql_query)

# Identify the supplier with the highest total sales
top_supplier = df.iloc[0]

# Create a bar chart to compare suppliers
fig = px.bar(df, x='CompanyName', y='total_sales', 
             title='Total Sales for Discontinued Products by Supplier',
             labels={'total_sales': 'Total Sales', 'CompanyName': 'Supplier'})

# Show the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.CompanyName, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS total_sales 
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
WHERE p.Discontinued = 1
GROUP BY s.CompanyName
ORDER BY total_sales DESC
LIMIT 10
""""""

supplier_sales_df = execute_sql_query(sql_query)

fig = px.bar(supplier_sales_df, 
             x='CompanyName', 
             y='total_sales', 
             title='Total Sales for Discontinued Products by Supplier',
             labels={'CompanyName': 'Supplier', 'total_sales': 'Total Sales'})
show_to_user(fig)
```","The input code correctly adheres to the business request and employs the same logic as the reference code, despite minor differences. It calculates total sales for discontinued products by summing the unit prices, quantities, and applying discounts, grouped by supplier names. Both implementations use SQL queries to retrieve the necessary data, ensuring products are discontinued. They sort the results by total sales in descending order and visualize the data using a bar chart. The input code also includes a 'LIMIT 10' clause, which doesn't impact correctness since the question isn't affected by visualizing fewer suppliers.","```python
import pandas as pd
import plotly.express as px

# SQL Query to extract data
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM suppliers 
JOIN products ON suppliers.SupplierID = products.SupplierID 
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE products.Discontinued = 1 
GROUP BY suppliers.CompanyName 
ORDER BY total_sales DESC
""""""

# Execute the SQL query using the utility function
discontinued_sales_df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(discontinued_sales_df, x='CompanyName', y='total_sales',
             title='Total Sales for Discontinued Products by Supplier',
             labels={'CompanyName': 'Supplier', 'total_sales': 'Total Sales'},
             text_auto=True)

# Show the chart to the user
show_to_user(fig)
```","The input code accurately reflects the logic in the reference implementation. Both implementations execute a SQL query to calculate total sales of discontinued products per supplier. The SQL queries are equivalent, differing only in how the Boolean for discontinued products is represented (TRUE vs 1), which are functionally identical. Both solutions sort the results by total sales, and create a comparable bar chart using plotly express. Therefore, the input implementation is correct.",both
"Which customers have the highest lifetime value, and can you provide a visualization ranking these customers by lifetime value?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve customer lifetime value
sql_query = """"""
SELECT 
    customers.CustomerID, 
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS LifetimeValue 
FROM 
    customers 
JOIN 
    orders ON customers.CustomerID = orders.CustomerID 
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY 
    customers.CustomerID 
ORDER BY 
    LifetimeValue DESC;
""""""

# Fetch data using the utility function
customer_lifetime_value_df = execute_sql_query(sql_query)

# Create a bar plot for customer lifetime values
fig = px.bar(
    customer_lifetime_value_df,
    x='CustomerID',
    y='LifetimeValue',
    title='Customer Lifetime Value Ranking',
    labels={'CustomerID': 'Customer ID', 'LifetimeValue': 'Lifetime Value'},
    template='plotly'
)

# Display the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS LifetimeValue
FROM 
    customers c
JOIN 
    orders o ON c.CustomerID = o.CustomerID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    LifetimeValue DESC
""""""

lifetime_value_df = execute_sql_query(sql_query)

fig = px.bar(lifetime_value_df, x='CompanyName', y='LifetimeValue',
             title='Customers Ranked by Lifetime Value',
             labels={'LifetimeValue': 'Lifetime Value', 'CompanyName': 'Customer'},
             text='LifetimeValue')

show_to_user(fig)
```","The input code fetches and visualizes customer lifetime value but includes the 'CompanyName' in the query and visualization. This changes the group by logic from the reference code, which only uses 'CustomerID'. Therefore, the logic does not strictly adhere to the reference implementation's focus solely on 'CustomerID'.","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve customer lifetime value data
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * 
           (1 - [Order Details].Discount)) AS LifetimeValue 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
JOIN customers ON orders.CustomerID = customers.CustomerID 
GROUP BY customers.CustomerID 
ORDER BY LifetimeValue DESC;
""""""

# Execute the SQL query using the utility function and retrieve the data
customer_lifetime_value_df = execute_sql_query(sql_query)

# Check the DataFrame to ensure it has the correct data
print(customer_lifetime_value_df.head())

# Visualizing the customers by lifetime value
fig = px.bar(customer_lifetime_value_df, 
             x='CustomerID', 
             y='LifetimeValue', 
             title='Customer Lifetime Value Ranking',
             labels={'CustomerID': 'Customer ID', 'LifetimeValue': 'Lifetime Value'},
             template='plotly')

# Display the visualization
show_to_user(fig)
```","The input Python code correctly addresses the business analytics request by determining the customer lifetime value and ranking the customers. It follows the same logic as the reference implementation by performing an SQL query that joins the 'customers', 'orders', and 'Order Details' tables to calculate lifetime value and then visualizes the data using a bar plot. Both implementations use plotly to visualize the results and ensure that customer lifetime values are ranked. The difference in join sequence (order of joins) does not affect the correctness of the results, thus the input code is consistent with the reference logic.",Finetuned
"What is the average discount given on products in the last month, and can this be visualized through a bar chart showing the distribution of discounts across different product categories?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation: In practice, this function would connect to a database and execute the query
    # Returning a sample DataFrame for demonstration purposes
    data = {
        'ProductCategory': ['Electronics', 'Clothing', 'Home', 'Toys'],
        'AverageDiscount': [0.15, 0.10, 0.08, 0.12]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    # This function should display the data or figure
    # For this example, assume it outputs the figure using Plotly
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to get average discounts for the last month
sql_query = '''
SELECT 
    P.ProductCategory, 
    AVG(OD.Discount) AS AverageDiscount 
FROM 
    products P 
JOIN 
    [Order Details] OD 
ON 
    P.ProductID = OD.ProductID 
WHERE 
    MONTH(OD.OrderDate) = MONTH(CURDATE() - INTERVAL 1 MONTH) 
    AND YEAR(OD.OrderDate) = YEAR(CURDATE() - INTERVAL 1 MONTH) 
GROUP BY 
    P.ProductCategory;
'''

# Execute the SQL query and retrieve the data
df = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(df, x='ProductCategory', y='AverageDiscount', 
             title='Average Discount by Product Category for Last Month',
             labels={'AverageDiscount': 'Average Discount', 'ProductCategory': 'Product Category'})

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

last_month_start = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-01')
last_month_end = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')

sql_query = f""""""
SELECT p.CategoryID, AVG(od.Discount) AS AverageDiscount
FROM [Order Details] od
JOIN products p ON od.ProductID = p.ProductID
WHERE od.Discount > 0 AND od.OrderID IN (
    SELECT OrderID FROM [Order Details]
    WHERE OrderDate BETWEEN '{last_month_start}' AND '{last_month_end}'
)
GROUP BY p.CategoryID
""""""

average_discount_df = execute_sql_query(sql_query)

fig = px.bar(average_discount_df, x='CategoryID', y='AverageDiscount', 
             title='Average Discount Across Product Categories in Last Month',
             labels={'CategoryID': 'Product Category', 'AverageDiscount': 'Average Discount'})
show_to_user(fig)
```","The input code differs from the reference implementation in how it calculates the date range for the last month. It improperly sets the start of the last month as 30 days ago instead of determining the first and last day of the previous month. Also, it uses 'CategoryID' instead of 'ProductCategory', which may refer to different fields, and checks for any discount > 0, which is not in the reference. Lastly, it assumes 'OrderID' is determined through a subquery, which may affect performance, whereas the reference uses 'OrderDate' directly.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get the average discount and the distribution of discounts across product categories
sql_query = """"""
SELECT 
    categories.CategoryName,
    AVG([Order Details].Discount) AS avg_discount,
    [Order Details].Discount
FROM 
    [Order Details]
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID
JOIN
    products ON [Order Details].ProductID = products.ProductID
JOIN
    categories ON products.CategoryID = categories.CategoryID
WHERE 
    MONTH(orders.OrderDate) = MONTH(CURDATE() - INTERVAL 1 MONTH)
    AND YEAR(orders.OrderDate) = YEAR(CURDATE() - INTERVAL 1 MONTH)
GROUP BY
    categories.CategoryName
""""""

# Execute the query
df = execute_sql_query(sql_query)

# Ensure 'CategoryName' and 'Discount' are available
if 'CategoryName' in df.columns and 'Discount' in df.columns:
    # Create a bar chart visualization
    fig = px.bar(df, x='CategoryName', y='avg_discount', color='CategoryName',
                 title='Average Discount by Product Category - Last Month',
                 labels={'avg_discount': 'Average Discount', 'CategoryName': 'Product Category'})

    # Show the bar chart using the utility function
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({""Error"": [""Required data is missing from the SQL query.""]}))
```","The input code retrieves both 'avg_discount' and 'Discount' but incorrectly attempts to visualize 'avg_discount' grouped by 'CategoryName'. The logic slightly deviates from the reference, which aims to visualize 'AverageDiscount' without requiring raw 'Discount' values. Additionally, checking for 'Discount' in columns is unnecessary, hence the condition for visualizing might mislead the purpose. Thus, the input doesn't align perfectly with the intended request and reference logic.",None
"Identify customers with the longest time since their last order, and visualize the data using a bar chart.","```python
import pandas as pd
import plotly.express as px

# SQL query to select customers with the longest time since their last order
sql_query = """"""
SELECT
    o.CustomerID,
    DATEDIFF(CURRENT_DATE, MAX(o.OrderDate)) AS DaysSinceLastOrder
FROM
    orders o
GROUP BY
    o.CustomerID
ORDER BY
    DaysSinceLastOrder DESC
LIMIT 1
""""""

# Execute the SQL query and retrieve the result as a pandas DataFrame
customer_data = execute_sql_query(sql_query)

# Visualize the data using a bar chart
fig = px.bar(customer_data, x='CustomerID', y='DaysSinceLastOrder', title='Customers with Longest Time Since Last Order')

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    c.CustomerID, 
    c.CompanyName, 
    MAX(o.OrderDate) AS LastOrderDate,
    DATEDIFF(CURRENT_DATE, MAX(o.OrderDate)) AS DaysSinceLastOrder
FROM 
    customers c
LEFT JOIN 
    orders o ON c.CustomerID = o.CustomerID
GROUP BY 
    c.CustomerID, c.CompanyName
ORDER BY 
    DaysSinceLastOrder DESC
LIMIT 10;
""""""

last_order_df = execute_sql_query(sql_query)

fig = px.bar(last_order_df, x='CompanyName', y='DaysSinceLastOrder', 
             title='Customers with the Longest Time Since Last Order',
             labels={'DaysSinceLastOrder': 'Days Since Last Order', 'CompanyName': 'Customer'})
show_to_user(fig)
```","The input code retrieves the top 10 customers with the longest time since their last order, whereas the reference code retrieves only one customer with the maximum time since the last order. Additionally, the input code includes 'CompanyName', which is not in the reference. It uses a LEFT JOIN with customers and includes the company name in the visualization, unlike the reference code which uses the CustomerID.","```python
import pandas as pd
import plotly.express as px

# Placeholder function definitions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should interact with your SQL database to execute the provided query.
    # The implementation details depend on your database connection setup.
    pass

def show_to_user(data):
    # Displays the data analysis or visualization results
    # Accepts a pandas DataFrame or a Plotly figure
    pass

# SQL Query from the business analytic request
sql_query = """"""
SELECT customers.CustomerID, MAX(orders.OrderDate) AS LastOrderDate
FROM customers
LEFT JOIN orders ON customers.CustomerID = orders.CustomerID
GROUP BY customers.CustomerID
ORDER BY LastOrderDate ASC;
""""""

# Execute the query and retrieve the result as a pandas DataFrame
df = execute_sql_query(sql_query)

# Calculate the time since the last order
df['LastOrderDate'] = pd.to_datetime(df['LastOrderDate'])
current_date = pd.to_datetime('today')
df['DaysSinceLastOrder'] = (current_date - df['LastOrderDate']).dt.days

# Sort the DataFrame by 'DaysSinceLastOrder' in descending order
df_sorted = df.sort_values(by='DaysSinceLastOrder', ascending=False)

# Visualize the data using a bar chart with Plotly
fig = px.bar(df_sorted, x='CustomerID', y='DaysSinceLastOrder',
             title='Customers with Longest Time Since Last Order',
             labels={'DaysSinceLastOrder': 'Days Since Last Order'})

# Use the show_to_user method to display the figure
show_to_user(fig)
```","The input code retrieves all customers, including those who have not placed any orders, due to the LEFT JOIN. This is different from the reference implementation, which focuses only on customers with orders and retrieves those with the longest time since their last order using MAX(OrderDate). The order of sorting is in descending order by DaysSinceLastOrder in both codes. Due to these differences, the input code does not adhere to the same logic as the reference implementation.",None
"What is the total number of products sold in the last quarter, and can you provide a bar chart to visualize the sales by month?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the monthly sales data
sql_query = """"""
SELECT 
    EXTRACT(MONTH FROM o.OrderDate) AS Month,
    SUM(od.Quantity) AS TotalProductsSold 
FROM 
    [Order Details] od 
JOIN 
    orders o 
ON 
    od.OrderID = o.OrderID 
WHERE 
    o.OrderDate >= DATEADD(quarter, -1, CURRENT_DATE)
GROUP BY 
    EXTRACT(MONTH FROM o.OrderDate)
ORDER BY 
    Month;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the sales by month
fig = px.bar(
    sales_data, 
    x='Month', 
    y='TotalProductsSold', 
    title='Total Products Sold by Month in the Last Quarter',
    labels={'TotalProductsSold': 'Total Products Sold', 'Month': 'Month'}
)

# Show the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Get the last quarter dates
last_quarter_start = pd.to_datetime(pd.Timestamp.now().replace(day=1) - pd.DateOffset(months=3)).strftime('%Y-%m-%d')
last_quarter_end = pd.to_datetime(pd.Timestamp.now().replace(day=1) - pd.DateOffset(days=1)).strftime('%Y-%m-%d')

# SQL query to get total products sold in the last quarter and sales by month
sql_query = f""""""
SELECT 
    MONTH(o.OrderDate) AS Month, 
    SUM(od.Quantity) AS TotalProductsSold
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate BETWEEN '{last_quarter_start}' AND '{last_quarter_end}'
GROUP BY 
    MONTH(o.OrderDate)
ORDER BY 
    Month;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Calculate total number of products sold
total_products_sold = sales_data['TotalProductsSold'].sum()

# Create a bar chart
fig = px.bar(sales_data, 
             x='Month', 
             y='TotalProductsSold', 
             title='Total Products Sold by Month in Last Quarter', 
             labels={'TotalProductsSold': 'Number of Products Sold', 'Month': 'Month'})

show_to_user(fig)

total_products_sold
```","The input code correctly calculates the total number of products sold in the last quarter and visualizes the sales by month. It determines the start and end dates for the last quarter accurately, executes an SQL query to retrieve monthly sales data, sums up the total product sales, and creates a bar chart using Plotly Express. The logic aligns with the reference implementation, achieving the task requirements effectively.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get monthly sales for the last quarter
sql_query = """"""
SELECT DATE_FORMAT(orders.OrderDate, '%Y-%m') AS SalesMonth, 
       SUM([Order Details].Quantity) AS TotalProductsSold 
FROM [Order Details] 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE orders.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) 
GROUP BY SalesMonth
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Visualize the sales by month using a bar chart
fig = px.bar(df, x='SalesMonth', y='TotalProductsSold', 
             title='Total Products Sold by Month in Last Quarter', 
             labels={'SalesMonth': 'Month', 'TotalProductsSold': 'Products Sold'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code uses `DATE_FORMAT` to group by months instead of extracting the month as in the reference code. The interval in the WHERE clause of the input code uses `INTERVAL 3 MONTH`, which may not correctly define 'last quarter' compared to the reference. Additionally, grouping by year-month is not equivalent to extracting just the month when orders span over multiple years.",Base
How many orders were placed using each shipping method? Include a bar chart to visualize the distribution of orders by shipping method.,"```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = ""SELECT ShipVia, COUNT(OrderID) AS OrderCount FROM orders GROUP BY ShipVia;""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function for demonstration purposes
    # You should replace this with actual SQL query execution logic
    data = {'ShipVia': ['Air', 'Ground', 'Sea'],
            'OrderCount': [150, 300, 200]}
    return pd.DataFrame(data)

# Function to display data or visualization to the user
def show_to_user(data):
    # Mock function for demonstration purposes
    # In a real implementation, this would render a Plotly figure or display a DataFrame
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Main analysis and visualization logic
def analyze_orders_by_shipping_method():
    # Execute the SQL query to get data
    orders_data = execute_sql_query(sql_query)

    # Create a bar chart using Plotly
    fig = px.bar(orders_data, x='ShipVia', y='OrderCount',
                 title='Number of Orders by Shipping Method',
                 labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Order Count'})

    # Show the bar chart to the user
    show_to_user(fig)

# Run the analysis
analyze_orders_by_shipping_method()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipVia
""""""
order_counts = execute_sql_query(sql_query)

fig = px.bar(order_counts, x='ShipVia', y='OrderCount', 
             labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'},
             title='Number of Orders by Shipping Method')
show_to_user(fig)
```","The provided code correctly executes a SQL query to count orders by shipping method and visualizes the results using a Plotly bar chart. It follows the logic of the reference implementation, specifically counting `OrderID` by `ShipVia` and displaying a bar chart with appropriate labels. While the functions are used differently, the core analytical and visualization tasks are equivalent.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per shipping method
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query and return a DataFrame
df_orders_by_shipping = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the distribution of orders by shipping method
fig = px.bar(
    df_orders_by_shipping,
    x='ShipVia',
    y='NumberOfOrders',
    title='Distribution of Orders by Shipping Method',
    labels={'ShipVia': 'Shipping Method', 'NumberOfOrders': 'Number of Orders'}
)

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly executes a SQL query to count the number of orders by shipping method, similar to the reference code. It uses Plotly to create a bar chart visualizing the distribution of orders by shipping method. The logic mirrors the reference implementation, despite differences in variable names and minor differences in the code structure, achieving the same business analytics request.",both
Determine which employee has the most shipments via the highest-cost freight method and visualize the comparison of shipment counts for each employee using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Step 1: Define the SQL query to get the shipment counts of each employee using the highest-cost freight method
sql_query = """"""
SELECT o.EmployeeID, COUNT(o.OrderID) AS ShipmentCount
FROM orders o
WHERE o.Freight = (SELECT MAX(Freight) FROM orders)
GROUP BY o.EmployeeID
ORDER BY ShipmentCount DESC;
""""""

# Step 2: Execute the SQL query
def execute_sql_query(sql_query: str):
    # Assuming the existence of this function, which executes the query
    # and returns a pandas DataFrame
    pass

# Get the DataFrame from the SQL query
df = execute_sql_query(sql_query)

# Step 3: Visualize the shipment counts for each employee using a bar chart
def show_to_user(data):
    # Assuming the existence of this function to show results
    pass

# Create a bar plot
fig = px.bar(df, x='EmployeeID', y='ShipmentCount', title='Shipment Counts by Employee for Highest-Cost Freight Method')

# Display the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find the highest cost freight method and employee with most shipments using it
sql_query = """"""
SELECT e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
       COUNT(o.OrderID) AS ShipmentCount, o.Freight
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
WHERE o.Freight = (SELECT MAX(Freight) FROM orders)
GROUP BY e.EmployeeID, EmployeeName
ORDER BY ShipmentCount DESC
""""""

# Execute the SQL query
shipment_data = execute_sql_query(sql_query)

# Get the employee with the most shipments via the highest-cost freight method
top_employee = shipment_data.iloc[0]

# Prepare bar chart for visualization
fig = px.bar(shipment_data, x='EmployeeName', y='ShipmentCount', 
             title='Shipment Counts by Employee using Highest-Cost Freight Method',
             labels={'ShipmentCount': 'Shipment Count', 'EmployeeName': 'Employee'},
             text='ShipmentCount')

show_to_user(fig)
```","The input Python code includes additional fields (EmployeeName) and uses a JOIN with the employees table, which the reference does not. This introduces differences in logic irrelevant to the specific task, which is to identify the employee solely based on the order data. The core request was to count shipments for each employee using the highest-cost freight; the input code's distinct approach to joining tables deviates from the reference's logic. Moreover, the extraction of the 'top_employee' isn't aligned with the business request, which focuses on visualization, not determination beyond SQL.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT EmployeeID, COUNT(OrderID) AS ShipmentCount 
FROM orders 
WHERE Freight = (SELECT MAX(Freight) FROM orders) 
GROUP BY EmployeeID 
ORDER BY ShipmentCount DESC;
""""""

# Execute the SQL query and get the data into a pandas DataFrame
df = execute_sql_query(sql_query)

# Visualize the comparison of shipment counts for each employee
fig = px.bar(df, x='EmployeeID', y='ShipmentCount', 
             title='Shipment Counts for Each Employee (Highest Cost Freight)',
             labels={'EmployeeID': 'Employee ID', 'ShipmentCount': 'Shipment Count'})

# Display the bar chart to the user
show_to_user(fig)
```","The input Python code performs the same operations as the reference implementation. It executes a SQL query to count shipments per employee for the highest-cost freight and visualizes the results using a bar chart. Both snippets use similar logic, and discrepancies in variable naming or plot labeling do not affect the overall correctness of the solution.",Finetuned
"What is the most sold product in terms of quantity, and can this information be represented in a bar chart?","```python
import plotly.express as px
import pandas as pd

# Assuming these utility functions are defined elsewhere
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Implementation for executing SQL query and returning DataFrame
    pass

def show_to_user(data):
    # Implementation for displaying data or figure
    pass

# SQL query derived from request
sql_query = '''
SELECT ProductName, SUM([Order Details].Quantity) AS TotalQuantity
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
GROUP BY ProductName
ORDER BY TotalQuantity DESC
LIMIT 1;
'''

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalQuantity', title='Most Sold Product')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT products.ProductName, SUM([Order Details].Quantity) AS TotalQuantity
FROM [Order Details]
JOIN products ON [Order Details].ProductID = products.ProductID
GROUP BY products.ProductName
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

most_sold_product = execute_sql_query(sql_query)

bar_chart = px.bar(most_sold_product, x='ProductName', y='TotalQuantity', title='Most Sold Product by Quantity')
show_to_user(bar_chart)
```","The input code correctly replicates the logic of the reference implementation. It executes a SQL query to find the most sold product by summing up quantities, groups by product name, orders by total quantity in descending order, and limits to the top result. The data is then visualized using a bar chart with Plotly, similar to the reference code. Key details such as the SQL query structure, the join condition, and visualization logic match the reference, fulfilling the business request.","```python
import pandas as pd
import plotly.express as px

# Existing function definitions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a mock function. The actual implementation will interact with a database.
    pass 

def show_to_user(data):
    # Mock function to display data or visualization
    pass 

# SQL Query to fetch the most sold product in terms of quantity
sql_query = """"""
SELECT od.ProductID, SUM(od.Quantity) AS TotalQuantity
FROM [Order Details] od
GROUP BY od.ProductID
ORDER BY TotalQuantity DESC
LIMIT 1
""""""

# Execute the SQL query to get the data
most_sold_product_df = execute_sql_query(sql_query)

# Check for no results scenario
if not most_sold_product_df.empty:
    # Extract most sold product details
    most_sold_product_id = most_sold_product_df.iloc[0]['ProductID']
    total_quantity = most_sold_product_df.iloc[0]['TotalQuantity']

    # Display DataFrame
    show_to_user(most_sold_product_df)

    # Create a bar chart using Plotly
    fig = px.bar(
        most_sold_product_df,
        x='ProductID',
        y='TotalQuantity',
        title=f'Most Sold Product: Product ID {most_sold_product_id} with {total_quantity} sold',
        labels={'ProductID': 'Product ID', 'TotalQuantity': 'Total Quantity Sold'}
    )

    # Show the bar chart with the show_to_user function
    show_to_user(fig)
else:
    print(""No data found."")
```","The input code fetches product data using only ProductID without joining with the products table to get the ProductName, which is required according to the business request. The reference code uses ProductName and correctly joins the tables to answer the question. Therefore, the input code does not fully adhere to the business request, although it is logically similar in terms of fetching the most sold product.",Base
"What is the product performance ranking for the last month, represented in a bar chart?","```python
import pandas as pd
import plotly.express as px


def product_performance_ranking():
    # SQL Query
    sql_query = """"""
    SELECT p.ProductName, SUM(od.Quantity) AS TotalSales 
    FROM products p
    JOIN [Order Details] od ON p.ProductID = od.ProductID
    WHERE MONTH(od.OrderDate) = MONTH(CURRENT_DATE) - 1
    AND YEAR(od.OrderDate) = YEAR(CURRENT_DATE)
    GROUP BY p.ProductID, p.ProductName
    ORDER BY TotalSales DESC;
    """"""

    # Execute SQL query and get the result as a DataFrame
    sales_data = execute_sql_query(sql_query)

    # Create a bar chart using Plotly
    fig = px.bar(sales_data, x='ProductName', y='TotalSales', title='Product Performance Ranking for Last Month')

    # Display the plot to the user
    show_to_user(fig)


# Call the function
product_performance_ranking()
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Define the date range for the last month
end_date = datetime.now().replace(day=1) - timedelta(days=1)
start_date = end_date.replace(day=1)

# SQL query to retrieve product performance data
sql_query = f""""""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalSales
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
WHERE od.OrderID IN (SELECT OrderID FROM orders WHERE OrderDate BETWEEN '{start_date.strftime('%Y-%m-%d')}' AND '{end_date.strftime('%Y-%m-%d')}')
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalSales DESC;
""""""

# Execute SQL query and retrieve the data
product_performance_df = execute_sql_query(sql_query)

# Create a bar chart for product performance
fig = px.bar(product_performance_df, x='ProductName', y='TotalSales', title='Product Performance Ranking for Last Month')
show_to_user(fig)
```","Both the reference and input Python codes aim to calculate product performance for the last month and visualize it as a bar chart. The reference implementation uses SQL functions to determine the last month's date, while the input code manually calculates start and end dates for the previous month. Both methods achieve the same goal of filtering the data for last month's sales, grouping by product, summing the quantities sold, and ordering the products by total sales. The visualization part is identical in logic, using Plotly Express to generate a bar chart. Therefore, the provided code is correct according to the given business analytics request and reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the product performance data
sql_query = """"""
SELECT 
    products.ProductName, 
    SUM([Order Details].Quantity) AS total_quantity 
FROM 
    products 
JOIN 
    [Order Details] 
ON 
    products.ProductID = [Order Details].ProductID 
JOIN 
    orders 
ON 
    [Order Details].OrderID = orders.OrderID 
WHERE 
    MONTH(orders.OrderDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH) 
    AND YEAR(orders.OrderDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH) 
GROUP BY 
    products.ProductName 
ORDER BY 
    total_quantity DESC;
""""""

# Use execute_sql_query utility function to retrieve data
product_performance_df = execute_sql_query(sql_query)

# Visualize product performance using a bar chart
fig = px.bar(product_performance_df, x='ProductName', y='total_quantity', title='Product Performance Ranking for Last Month')

# Show the resulting bar chart
show_to_user(fig)
```","The input code evaluates the product performance for the last month and creates a bar chart, similar to the reference code. Both use SQL queries to fetch product names and total sales/quantities, considering the last month. The difference in date calculation (CURRENT_DATE - INTERVAL 1 MONTH vs. explicit month/year subtraction) achieves the same outcome. The SQL logic and presentation aim match the reference example; hence, the code is correct.",both
What is the total value of the inventory currently in stock? Provide a bar chart breaking down the value by inventory category.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the inventory value breakdown by category
sql_query = """"""
SELECT CategoryName, SUM(UnitPrice * UnitsInStock) AS CategoryInventoryValue
FROM products
JOIN categories ON products.CategoryID = categories.CategoryID
GROUP BY CategoryName;
""""""

# Execute the SQL query to get the data
inventory_data = execute_sql_query(sql_query)

# Create a bar chart with Plotly
fig = px.bar(inventory_data, x='CategoryName', y='CategoryInventoryValue',
             title='Inventory Value by Category',
             labels={'CategoryName': 'Category', 'CategoryInventoryValue': 'Inventory Value'})

# Display the chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.CategoryID, 
    SUM(p.UnitPrice * p.UnitsInStock) AS TotalValue
FROM 
    products p
WHERE 
    p.Discontinued = 0
GROUP BY 
    p.CategoryID
""""""

inventory_data = execute_sql_query(sql_query)
fig = px.bar(inventory_data, x='CategoryID', y='TotalValue', title='Total Inventory Value by Category')
show_to_user(fig)
```","The input code does not join the products and categories tables to obtain the CategoryName, which is necessary to break down the inventory value by category name as in the reference code. It also uses 'CategoryID' instead of 'CategoryName' for the x-axis in the bar chart, which does not adhere to the requested business analytics requirement.","
import pandas as pd
import plotly.express as px

# SQL query to get the inventory breakdown by category
sql_query = """"""
SELECT 
    CategoryID, 
    SUM(UnitPrice * UnitsInStock) AS InventoryValue 
FROM 
    products 
GROUP BY 
    CategoryID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
inventory_df = execute_sql_query(sql_query)

# Create a bar chart to show the inventory value by category
fig = px.bar(inventory_df, x='CategoryID', y='InventoryValue', 
             title='Inventory Value by Category',
             labels={'CategoryID': 'Category ID', 'InventoryValue': 'Inventory Value'})

# Show the bar chart to the user
show_to_user(fig)
","The input code calculates the total inventory value grouped by 'CategoryID', but does not join with the 'categories' table to get 'CategoryName', unlike the reference code. The generated bar chart uses 'CategoryID' instead of 'CategoryName', which does not align with the business analytics request and reference implementation.",None
Identify the orders that had a discount greater than 20% and visualize the distribution of these discounts using a histogram.,"```python
import plotly.express as px
import pandas as pd

# Define and execute the SQL query
sql_query = '''
SELECT DISTINCT orders.OrderID, [Order Details].Discount 
FROM [Order Details] 
INNER JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE [Order Details].Discount > 0.2;
'''

# Execute the query and get the result as a DataFrame
orders_with_high_discount = execute_sql_query(sql_query)

# Create a histogram to visualize the distribution of discounts greater than 20%
fig = px.histogram(orders_with_high_discount, x='Discount', 
                   title='Distribution of Discounts Greater than 20%')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT od.Discount
FROM [Order Details] od
JOIN orders o ON od.OrderID = o.OrderID
WHERE od.Discount > 0.20
""""""
discount_data = execute_sql_query(sql_query)

fig = px.histogram(discount_data, x='Discount', title='Distribution of Discounts Greater than 20%')
show_to_user(fig)
```","The input Python code correctly mirrors the logic of the reference implementation. It selects orders with discounts greater than 20% and visualizes the discount distribution using a histogram. Both implementations use similar SQL queries to retrieve the discount data and utilize Plotly's histogram functionality to visualize it. The input code omits selecting distinct order IDs, but it achieves the business goal of visualizing the discount distribution effectively, which was the central request.",,"The input Python code is missing for evaluation. Without the actual input code, it's impossible to determine if it matches the business analytics request and adheres to the logic of the reference implementation provided.",Base
"What is the revenue growth compared to the previous month, and can you provide a line chart to visualize the trend?","```python
import pandas as pd
import plotly.express as px

# Assuming the function execute_sql_query is already defined as per the environment constraints
# Also assuming that the dataframe returned has columns ['OrderDate', 'Month', 'Revenue']

# Query to get detailed monthly revenue data
sql_query = """"""
SELECT 
    EXTRACT(YEAR FROM od.OrderDate) AS Year,
    EXTRACT(MONTH FROM od.OrderDate) AS Month,
    SUM(od.Quantity * od.UnitPrice) AS Revenue
FROM [Order Details] od
WHERE YEAR(od.OrderDate) = YEAR(CURRENT_DATE)
GROUP BY Year, Month
ORDER BY Year, Month;
""""""

# Execute the query and get data as a DataFrame
df = execute_sql_query(sql_query)

# Calculate revenue growth compared to the previous month
df['RevenueGrowth'] = df['Revenue'].pct_change() * 100

# Line chart for revenue growth trend
fig = px.line(df, x='Month', y='RevenueGrowth', title='Monthly Revenue Growth Trend', markers=True)
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get revenue by month
sql_query = """"""
SELECT 
    DATE_FORMAT(O.OrderDate, '%Y-%m') AS Month,
    SUM(OD.Quantity * OD.UnitPrice * (1 - OD.Discount)) AS Revenue
FROM 
    [Order Details] OD
JOIN 
    Orders O ON OD.OrderID = O.OrderID
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

# Execute the SQL query
revenue_data = execute_sql_query(sql_query)

# Calculate the revenue growth compared to the previous month
revenue_data['Revenue Growth'] = revenue_data['Revenue'].pct_change() * 100

# Create a line chart to visualize the revenue trend
fig = px.line(revenue_data, x='Month', y='Revenue', title='Revenue Trend', 
              labels={'Revenue': 'Monthly Revenue', 'Month': 'Month'},
              markers=True)

# Show the chart to the user
show_to_user(fig)

# Show the revenue growth data to the user
show_to_user(revenue_data[['Month', 'Revenue', 'Revenue Growth']])
```","The input code calculates the revenue growth but does not plot it. Instead, it plots the revenue trend, which is not the requirement. The reference code plots the 'RevenueGrowth', which is the correct action per the analytic request. Additionally, it uses DATE_FORMAT for month extraction, which is acceptable but different from the reference's EXTRACT method.","import plotly.express as px
import pandas as pd

# This utility function simulates executing an SQL query and returning a pandas DataFrame.
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock implementation: Ideally, it would interact with a database.
    # This would return a DataFrame similar to the one obtained by executing the given SQL query.
    data = {
        'Month': ['2023-08-01', '2023-09-01'],
        'Revenue': [50000, 60000]
    }
    return pd.DataFrame(data)

# SQL query to calculate revenue growth
sql_query = '''
SELECT
    DATE_FORMAT(OrderDate, '%Y-%m-01') AS Month,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Revenue
FROM orders o
JOIN `Order Details` od ON o.OrderID = od.OrderID
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m-01')
ORDER BY Month;
'''

# Execute the SQL query to get revenue data
df = execute_sql_query(sql_query)

# Calculate the month-over-month growth
df['Previous Revenue'] = df['Revenue'].shift(1)
df['Growth'] = (df['Revenue'] - df['Previous Revenue']) / df['Previous Revenue'] * 100

# Visualize the revenue trend using a line chart
fig = px.line(df, x='Month', y='Revenue', title='Revenue Growth Trend', labels={'Revenue': 'Revenue ($)'})

# Display the plot
show_to_user(fig)
",The input code calculates and visualizes total revenue instead of revenue growth compared to the previous month. It creates a line chart for 'Revenue' rather than using 'RevenueGrowth'. The calculation uses absolute differences instead of percentage changes. The reference implementation focuses on visualizing the growth trend while the input visualizes raw revenue.,None
Calculate the percentage of customers who made more than one purchase and visualize the distribution of multiple purchases with a bar chart.,"```python
import pandas as pd
import plotly.express as px

def analyze_customer_purchases():
    # SQL query to get the percentage of returning customers
    sql_query_percentage = """"""
    SELECT (CAST(COUNT(DISTINCT CustomerID) AS FLOAT) / (SELECT COUNT(DISTINCT CustomerID) FROM orders)) * 100 AS ReturningCustomers 
    FROM orders 
    WHERE CustomerID IN (SELECT CustomerID FROM orders GROUP BY CustomerID HAVING COUNT(OrderID) > 1);
    """"""
    
    # SQL query to get the count of multiple purchases for each customer
    sql_query_distribution = """"""
    SELECT CustomerID, COUNT(OrderID) as OrderCount 
    FROM orders 
    GROUP BY CustomerID 
    HAVING COUNT(OrderID) > 1;
    """"""
    
    # Execute SQL queries
    returning_customers_df = execute_sql_query(sql_query_percentage)
    purchase_distribution_df = execute_sql_query(sql_query_distribution)

    # Display percentage of customers with multiple purchases
    show_to_user(returning_customers_df)

    # Visualization: Distribution of multiple purchases
    fig = px.bar(purchase_distribution_df, x='CustomerID', y='OrderCount',
                 title='Distribution of Multiple Purchases',
                 labels={'OrderCount': 'Number of Purchases', 'CustomerID': 'Customer ID'})
    
    show_to_user(fig)

# Run the analysis
analyze_customer_purchases()
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the number of customers and those with more than one purchase
sql_query = """"""
SELECT
    COUNT(DISTINCT CustomerID) AS total_customers,
    COUNT(DISTINCT CASE WHEN purchase_count > 1 THEN CustomerID END) AS customers_multiple_purchases
FROM (
    SELECT
        CustomerID,
        COUNT(OrderID) AS purchase_count
    FROM
        orders
    GROUP BY
        CustomerID
) AS purchase_counts;
""""""

# Execute the SQL query
result_df = execute_sql_query(sql_query)

# Calculate the percentage of customers who made more than one purchase
result_df['percentage_multiple_purchases'] = (result_df['customers_multiple_purchases'] / result_df['total_customers']) * 100

# Prepare data for visualization
purchase_distribution_df = execute_sql_query(""""""
SELECT
    COUNT(OrderID) AS order_count
FROM
    orders
GROUP BY
    CustomerID
"""""")

# Plot the distribution of multiple purchases
fig = px.bar(purchase_distribution_df, x='order_count', title='Distribution of Customer Purchases', 
             labels={'order_count':'Number of Purchases', 'value':'Number of Customers'})

show_to_user(fig)
```","The input code does not correctly implement the requested analytics. Although it calculates the percentage of customers with multiple purchases, it lacks the necessary filtering in the visualization step to only show customers with multiple purchases. The SQL query used for visualization aggregates all orders without filtering to customers with more than one purchase, while the reference implements this filtering using a 'HAVING COUNT(OrderID) > 1' clause. This results in a mismatch with the reference implementation's requirements.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function body
    # In real usage, implement the function to run the query and return a DataFrame
    pass

# Utility function to show the results (placeholder)
def show_to_user(data):
    # This would typically display a DataFrame or Plotly figure to the user
    pass

# SQL Query to get the total number of customers with more than one purchase
sql_query_multiple_purchases = """"""
SELECT COUNT(DISTINCT CustomerID) AS multiple_purchase_customers
FROM (
    SELECT CustomerID
    FROM orders
    GROUP BY CustomerID
    HAVING COUNT(OrderID) > 1
) AS subquery;
""""""

# Execute the SQL query
multiple_purchase_df = execute_sql_query(sql_query_multiple_purchases)

# SQL Query to get the total number of customers
sql_query_total_customers = ""SELECT COUNT(DISTINCT CustomerID) AS total_customers FROM orders;""

# Execute the SQL query
total_customers_df = execute_sql_query(sql_query_total_customers)

# Calculate the percentage
percentage_multiple_purchases = (multiple_purchase_df['multiple_purchase_customers'][0] /
                                 total_customers_df['total_customers'][0]) * 100

# Display the percentage to the user
percentage_df = pd.DataFrame({
    'Field': ['Percentage of Customers with Multiple Purchases'],
    'Value': [percentage_multiple_purchases]
})
show_to_user(percentage_df)

# Visualizing distribution of multiple purchases using a bar chart
sql_query_purchase_distribution = """"""
SELECT CustomerID, COUNT(OrderID) AS number_of_orders
FROM orders
GROUP BY CustomerID
ORDER BY number_of_orders DESC;
""""""

# Execute the SQL query to get purchase distribution
purchase_distribution_df = execute_sql_query(sql_query_purchase_distribution)

# Filter to only show customers with more than one purchase
multiple_purchases_distribution_df = purchase_distribution_df[purchase_distribution_df['number_of_orders'] > 1]

# Plot the bar chart using Plotly
fig = px.bar(
    multiple_purchases_distribution_df,
    x='CustomerID',
    y='number_of_orders',
    title='Distribution of Multiple Purchases',
    labels={'number_of_orders': 'Number of Orders', 'CustomerID': 'Customer ID'}
)

# Show the bar chart
show_to_user(fig)
```","The provided implementation correctly calculates the percentage of customers with multiple purchases and visualizes the distribution using a bar chart. It adheres to the logic of the reference implementation. Both approaches compute the number of customers with more than one purchase and the total customers, calculate the percentage, and use Plotly for visualization. Minor differences, such as subquery arrangement and the explicit filtering step, do not affect the correctness of logic.",Finetuned
"Which supplier contributed the most to total sales this year, and can you provide a bar chart showing the contribution of each supplier?","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get total sales by supplier for the current year
sql_query = """"""
SELECT suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE YEAR(orders.OrderDate) = YEAR(CURDATE()) 
GROUP BY suppliers.SupplierID, suppliers.CompanyName 
ORDER BY total_sales DESC
""""""

# Execute the sql_query using the provided utility function and get a DataFrame
suppliers_sales_df = execute_sql_query(sql_query)

# Find the supplier with the maximum contribution to total sales
top_supplier = suppliers_sales_df.iloc[0]

# Output the top supplier
show_to_user(pd.DataFrame([top_supplier]))

# Create a bar chart to visualize the contribution of each supplier to the total sales
fig = px.bar(
    suppliers_sales_df, 
    x='CompanyName', 
    y='total_sales', 
    title='Contribution of Each Supplier to Total Sales This Year',
    labels={'total_sales': 'Total Sales', 'CompanyName': 'Supplier'},
    text_auto=True
)

# Show the bar chart using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get total sales per supplier for the current year
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN suppliers ON products.SupplierID = suppliers.SupplierID
WHERE orders.OrderDate BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY suppliers.SupplierID, suppliers.CompanyName
ORDER BY total_sales DESC
""""""

# Execute the SQL query
supplier_sales_df = execute_sql_query(sql_query)

# Identify the supplier that contributed the most
top_supplier = supplier_sales_df.iloc[0]

# Create a bar chart for the contributions of each supplier
fig = px.bar(supplier_sales_df, x='CompanyName', y='total_sales',
             title='Total Sales Contribution by Supplier in 2023',
             labels={'total_sales':'Total Sales', 'CompanyName':'Supplier Name'})

# Show the user the figure and the top supplier details
show_to_user(fig)
show_to_user(top_supplier)
```","The input code correctly calculates the total sales contribution by each supplier for the current year 2023, using a SQL query similar to the reference code. Both implementations identify the supplier with the highest sales and generate a bar chart for visualization. The main difference is the method of filtering the date range; the input code uses explicit date boundaries, while the reference code uses a dynamic current year calculation, which may alter behavior in a different year but is functionally correct for 2023. Both successfully display the top supplier and the bar chart using similar approaches.","```python
import pandas as pd
import plotly.express as px

# Assume these utility functions are predefined
def execute_sql_query(sql_query: str):
    # Placeholder function to simulate query execution
    pass

def show_to_user(data):
    # Placeholder function to simulate display of data
    pass

# SQL query to get total sales by supplier for the current year
sql_query = """"""
SELECT 
    suppliers.CompanyName,  
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales 
FROM 
    suppliers 
JOIN 
    products ON suppliers.SupplierID = products.SupplierID 
JOIN 
    [Order Details] ON products.ProductID = [Order Details].ProductID 
JOIN 
    orders ON [Order Details].OrderID = orders.OrderID 
WHERE 
    orders.OrderDate >= DATE_TRUNC('YEAR', CURRENT_DATE) 
GROUP BY 
    suppliers.CompanyName 
ORDER BY 
    total_sales DESC;
""""""

# Execute the SQL query
supplier_sales_df = execute_sql_query(sql_query)

# Generate bar chart
fig = px.bar(supplier_sales_df, x='CompanyName', y='total_sales', 
             title='Supplier Contribution to Total Sales This Year', 
             labels={'total_sales': 'Total Sales', 'CompanyName': 'Supplier'})

# Show the chart to the user
show_to_user(fig)
```","The input code correctly performs the task of calculating the total sales per supplier for the current year, using almost the same SQL logic as the reference implementation. It executes the query, retrieves the data, and generates a bar chart showing each supplier's contribution to total sales. While there is a slight difference in query syntax, the logic remains equivalent due to the use of DATE_TRUNC in the input code replacing the YEAR function, achieving the same result.",both
"Which products are responsible for the majority of sales revenue this month, and can a bar chart be provided to illustrate the top-performing products?","```python
import pandas as pd
import plotly.express as px

# SQL query to get sales revenue per product for the current month
sql_query = """"""
SELECT p.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS sales_revenue 
FROM [Order Details] 
JOIN products p ON [Order Details].ProductID = p.ProductID 
JOIN orders o ON [Order Details].OrderID = o.OrderID 
WHERE EXTRACT(MONTH FROM o.OrderDate) = EXTRACT(MONTH FROM CURRENT_DATE) 
  AND EXTRACT(YEAR FROM o.OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
GROUP BY p.ProductName 
ORDER BY sales_revenue DESC
""""""

# Execute the SQL query to get the data as a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Select the top 10 performing products (assuming 10 for better insight)
top_products = sales_data.head(10)

# Create a bar chart using Plotly to visualize the top products by sales revenue
fig = px.bar(top_products, x='ProductName', y='sales_revenue', title='Top Performing Products by Sales Revenue This Month')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# Get current month
current_month = pd.Timestamp.now().month
current_year = pd.Timestamp.now().year

# SQL query to retrieve total sales for each product this month
sql_query = f""""""
SELECT products.ProductID, products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS total_sales
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN orders ON [Order Details].OrderID = orders.OrderID 
WHERE MONTH(orders.OrderDate) = {current_month} AND YEAR(orders.OrderDate) = {current_year}
GROUP BY products.ProductID, products.ProductName
ORDER BY total_sales DESC
LIMIT 10
""""""

# Execute the query and retrieve the data
top_products = execute_sql_query(sql_query)

# Create a bar chart for top-performing products
fig = px.bar(top_products, x='ProductName', y='total_sales', 
             title='Top Performing Products This Month',
             labels={'ProductName': 'Product Name', 'total_sales': 'Total Sales'},
             text='total_sales')

# Display the result
show_to_user(fig)
```","The input code correctly calculates the total sales revenue for each product for the current month by joining the necessary tables and grouping by product. It extracts the current month and year similarly to the reference code. It uses SQL to order the results by sales revenue and limits to the top 10 products, which is equivalent to using 'head(10)' in the reference code. The bar chart correctly visualizes the top products by sales revenue with appropriate labels and the chart is displayed correctly. Therefore, the input code meets the business requirement and logic of the reference implementation.","```python
import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT ProductName, SUM(od.UnitPrice * od.Quantity) AS ProductRevenue 
FROM [Order Details] od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
WHERE DATE_TRUNC('month', o.OrderDate) = DATE_TRUNC('month', CURRENT_DATE) 
GROUP BY ProductName 
ORDER BY ProductRevenue DESC;
""""""

# Step 1: Execute the SQL query
df = execute_sql_query(sql_query)

# Step 2: Visualize the top-performing products
fig = px.bar(df, x='ProductName', y='ProductRevenue', 
             title='Top Products by Revenue This Month',
             labels={'ProductName': 'Product Name', 'ProductRevenue': 'Revenue'},
             text='ProductRevenue')

# Step 3: Show the visualization to the user
show_to_user(fig)
```","The input code does not account for discounts, which are included in the reference implementation to calculate the sales revenue. Therefore, the calculation of ProductRevenue in the input code is incomplete and may lead to higher revenue figures being reported, as it does not use (1 - Discount). Additionally, the input code does not specifically limit the results to the top 10 high-performing products, which the reference does imply by using head(10). Both of these factors would cause the output to deviate from the intended results of the reference implementation.",Base
"  
""Which month has the highest number of orders, and can this be represented with a bar chart for clarity?""  ","import plotly.express as px

# Assume execute_sql_query and show_to_user are already defined utility functions

# SQL query to find the month with the highest number of orders
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY Month 
ORDER BY TotalOrders DESC;
""""""

# Execute the SQL query
orders_data = execute_sql_query(sql_query)

# Visualize the data with a bar chart using Plotly
fig = px.bar(
    orders_data,
    x='Month',
    y='TotalOrders',
    title='Total Orders by Month',
    labels={'TotalOrders': 'Number of Orders', 'Month': 'Month'},
    template='plotly'
)

# Display the figure
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY OrderCount DESC
LIMIT 1
""""""

highest_month = execute_sql_query(sql_query)

sql_query_all = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
""""""

all_orders = execute_sql_query(sql_query_all)

fig = px.bar(all_orders, x='Month', y='OrderCount', title='Number of Orders per Month')
show_to_user(fig)
```","The provided code correctly answers the business analytics request. It first determines the month with the highest number of orders using an SQL query with 'LIMIT 1'. Then, it executes another SQL query to retrieve the total number of orders per month for visualization. Despite the slightly different SQL syntax (using 'DATE_FORMAT' vs. 'DATE_TRUNC'), both achieve the same grouping by month. Finally, it uses Plotly to create a bar chart to display the number of orders per month, fulfilling the requirement for a visual representation.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the monthly order data
sql_query = """"""
SELECT MONTH(OrderDate) AS OrderMonth, COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY OrderMonth 
ORDER BY NumberOfOrders DESC;
""""""

# Execute the SQL query and fetch the data
monthly_orders_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the number of orders per month
fig = px.bar(monthly_orders_df, x='OrderMonth', y='NumberOfOrders', 
             title='Monthly Number of Orders',
             labels={'OrderMonth': 'Month', 'NumberOfOrders': 'Number of Orders'})

# Display the figure to the user
show_to_user(fig)
```","The input code calculates the 'OrderMonth' using the MONTH() function, which returns an integer representation (1-12) of the month, rather than truncating the date to the start of the month as 'DATE_TRUNC('month', OrderDate)' does. This results in different representations and potential grouping of months. Additionally, the input code does not implicitly handle year differences, which might lead to inaccurate results if data spans multiple years.",Base
What is the most frequently ordered product? Include a bar chart to illustrate the top products.,"
import pandas as pd
import plotly.express as px

# SQL query to retrieve product order frequency
sql_query = """"""
SELECT products.ProductName, COUNT(*) AS OrderFrequency 
FROM [Order Details] 
INNER JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY OrderFrequency DESC;
""""""

# Execute SQL query and store the result in a pandas DataFrame
order_frequency_df = execute_sql_query(sql_query)

# Plot a bar chart to illustrate the top products by order frequency
fig = px.bar(order_frequency_df, 
             x='ProductName', 
             y='OrderFrequency', 
             title='Top Products by Order Frequency',
             labels={'OrderFrequency': 'Number of Orders', 'ProductName': 'Product Name'})

# Display the chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalOrdered
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalOrdered DESC
LIMIT 10;
""""""

top_products_df = execute_sql_query(sql_query)

fig = px.bar(top_products_df, x='ProductName', y='TotalOrdered', title='Top Ordered Products',
             labels={'TotalOrdered': 'Quantity Ordered', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code calculates the top products by the total quantity ordered rather than the frequency of orders. The business request and reference implementation focus on order frequency (i.e., the number of orders for each product), whereas the input code sums up the quantities. These are not equivalent, so the input code does not adhere to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch the order details
sql_query = """"""
SELECT od.ProductID, COUNT(*) AS OrderCount 
FROM [Order Details] od 
GROUP BY od.ProductID 
ORDER BY OrderCount DESC;
""""""

# Use the provided execute_sql_query utility function to obtain data
products_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the top products
fig = px.bar(products_df, x='ProductID', y='OrderCount', 
             title='Most Frequently Ordered Products', 
             labels={'ProductID': 'Product ID', 'OrderCount': 'Number of Orders'})

# Display the bar chart using the provided show_to_user utility function
show_to_user(fig)
```","The input code does not correctly answer the business analytics request. It groups the order data by ProductID without joining with the products table to get ProductName. Thus, it lacks the necessary ProductName information to determine the most frequently ordered product by name. The visualization in the input code differs from the reference as it uses ProductID instead of ProductName.",None
What is the total discount given on all products sold? Can you include a bar chart to show the discounts by product category?,"```python
import pandas as pd
import plotly.express as px

# SQL Queries
total_discount_query = """"""
SELECT SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount
FROM [Order Details];
""""""

discount_by_category_query = """"""
SELECT Products.CategoryID, Categories.CategoryName, SUM([Order Details].UnitPrice * [Order Details].Quantity * [Order Details].Discount) AS TotalDiscount
FROM [Order Details]
JOIN Products ON [Order Details].ProductID = Products.ProductID
JOIN Categories ON Products.CategoryID = Categories.CategoryID
GROUP BY Products.CategoryID, Categories.CategoryName;
""""""

# Execute SQL queries and get data
total_discount_df = execute_sql_query(total_discount_query)
discount_by_category_df = execute_sql_query(discount_by_category_query)

# Display total discount
show_to_user(total_discount_df)

# Create a bar chart for discounts by product category
fig = px.bar(discount_by_category_df, x='CategoryName', y='TotalDiscount', title='Discounts by Product Category', labels={'TotalDiscount': 'Total Discount', 'CategoryName': 'Product Category'})
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.Category AS ProductCategory,
    SUM(od.Discount * od.Quantity) AS TotalDiscount
FROM 
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
GROUP BY 
    p.Category
""""""

discount_data = execute_sql_query(sql_query)

total_discount = discount_data['TotalDiscount'].sum()

fig = px.bar(discount_data, x='ProductCategory', y='TotalDiscount', title='Total Discounts by Product Category')
show_to_user(fig)

total_discount
```","The input code does not fully align with the reference implementation. It computes the total discount using only the 'Discount * Quantity' formula without considering the 'UnitPrice' as in the reference. Additionally, it uses a possibly incorrect field name 'Category' instead of 'CategoryID' and misses the join with the Categories table to retrieve category names. These discrepancies lead to incorrect results.","import pandas as pd
import plotly.express as px

# SQL query to get the total discount given on all products sold
sql_total_discount = """"""
SELECT 
    SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscount 
FROM [Order Details] od;
""""""

# SQL query to get discounts by product category
sql_discount_by_category = """"""
SELECT 
    p.CategoryName AS Category,
    SUM(od.Discount * od.Quantity * od.UnitPrice) AS TotalDiscount 
FROM [Order Details] od
JOIN Products p ON od.ProductID = p.ProductID
GROUP BY p.CategoryName;
""""""

# Execute the SQL query to get the total discount
total_discount_df = execute_sql_query(sql_total_discount)

# Execute the SQL query to get discounts by product category
discount_by_category_df = execute_sql_query(sql_discount_by_category)

# Display the total discount
show_to_user(total_discount_df)

# Create and display a bar chart for discounts by product category
fig = px.bar(discount_by_category_df, x='Category', y='TotalDiscount', title='Discounts by Product Category', labels={'TotalDiscount':'Total Discount'})
show_to_user(fig)","The input code does not include joining with the Categories table to fetch the category name, resulting in potential discrepancies if CategoryName is stored there and not in Products. The reference implementation uses Categories.CategoryName, ensuring correctness. Additionally, the column label identifier 'Category' is different from 'CategoryName' in the bar chart, which needs alignment with the reference code structure.",None
Identify orders that were delivered late compared to the required date and create a bar chart to visualize the number of late deliveries by month.,"```python
import pandas as pd
import plotly.express as px

# SQL query to identify late deliveries
sql_query = ""SELECT OrderID, ShippedDate, RequiredDate FROM orders WHERE ShippedDate > RequiredDate;""

# Execute the SQL query and get the result as a DataFrame
late_orders_df = execute_sql_query(sql_query)

# Convert date columns to datetime objects
late_orders_df['ShippedDate'] = pd.to_datetime(late_orders_df['ShippedDate'])
late_orders_df['RequiredDate'] = pd.to_datetime(late_orders_df['RequiredDate'])

# Add a 'Month' column to group data by month and year of the shipped date
late_orders_df['Month'] = late_orders_df['ShippedDate'].dt.to_period('M')

# Group by 'Month' to count the number of late deliveries per month
late_deliveries_by_month = late_orders_df.groupby('Month').size().reset_index(name='LateDeliveriesCount')

# Convert Period to string for plotting purposes
late_deliveries_by_month['Month'] = late_deliveries_by_month['Month'].astype(str)

# Create a bar chart to visualize the number of late deliveries by month
fig = px.bar(late_deliveries_by_month, x='Month', y='LateDeliveriesCount', title='Late Deliveries by Month')

# Display the visualization using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(*) AS LateDeliveries
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

late_deliveries_df = execute_sql_query(sql_query)

fig = px.bar(
    late_deliveries_df,
    x='Month',
    y='LateDeliveries',
    title='Number of Late Deliveries by Month',
    labels={'LateDeliveries': 'Number of Late Deliveries', 'Month': 'Month'},
)

show_to_user(fig)
```","Both the input and reference implementations meet the business analytics request by identifying late deliveries where the 'ShippedDate' is greater than 'RequiredDate'. The input Python code generates the same result by using an SQL query that counts the late deliveries grouped by month. It organizes 'Month' in 'YYYY-MM' format, similar to the reference code which uses a Pandas period for month extraction. The visualization using Plotly Express is also consistent as it plots a bar chart representing the number of late deliveries by month. Therefore, the logic and result are equivalent to the reference implementation.","
import pandas as pd
import plotly.express as px

# SQL query to identify late delivered orders
sql_query = """"""
SELECT OrderID, ShippedDate 
FROM orders 
WHERE ShippedDate > RequiredDate;
""""""

# Fetching the data using the utility function
late_deliveries_df = execute_sql_query(sql_query)

# Converting ShippedDate to datetime to extract month and year
late_deliveries_df['ShippedDate'] = pd.to_datetime(late_deliveries_df['ShippedDate'])

# Creating a Month-Year column for grouping
late_deliveries_df['Month-Year'] = late_deliveries_df['ShippedDate'].dt.to_period('M')

# Grouping by Month-Year to count late deliveries
late_deliveries_monthly = late_deliveries_df.groupby('Month-Year').size().reset_index(name='Late Deliveries')

# Creating a bar chart using Plotly to visualize the number of late deliveries by month
fig = px.bar(
    late_deliveries_monthly,
    x='Month-Year',
    y='Late Deliveries',
    title='Number of Late Deliveries by Month',
    labels={'Month-Year': 'Month-Year', 'Late Deliveries': 'Number of Late Deliveries'}
)

# Displaying the visualization to the user
show_to_user(fig)
","The input Python code correctly executes the same business task as the reference implementation. It identifies late deliveries by querying orders where the shipped date is later than the required date, converts the shipped date to a month-year period for grouping, and calculates the count of late deliveries per month. It then creates and displays a bar chart visualizing these counts using Plotly. The differences in code structure, such as column naming conventions ('Month' vs. 'Month-Year') and minor variations in labels, do not affect the overall logic or outcome requested in the business analytics task.",both
"How many distinct shipping recipients are there each month, and can you provide a line chart to visualize monthly trends?","```python
import pandas as pd
import plotly.express as px

# SQL Query to get data for distinct shipping recipients per month
sql_query = """"""
SELECT TO_CHAR(OrderDate, 'YYYY-MM') AS Month, 
       COUNT(DISTINCT ShipName) AS DistinctRecipients 
FROM orders 
GROUP BY TO_CHAR(OrderDate, 'YYYY-MM');
""""""

# Execute the SQL query and get the results in a pandas DataFrame
data = execute_sql_query(sql_query)

# Sort the data by Month to ensure correct line chart visualization
data.sort_values(by='Month', inplace=True)

# Create a line chart to visualize the monthly trends of distinct recipients
fig = px.line(data, x='Month', y='DistinctRecipients', title='Monthly Distinct Shipping Recipients Trends')

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(DISTINCT ShipName) AS DistinctRecipients
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

recipients_df = execute_sql_query(sql_query)

fig = px.line(recipients_df, x='Month', y='DistinctRecipients', title='Distinct Shipping Recipients per Month', labels={'DistinctRecipients': 'Number of Distinct Recipients'})
show_to_user(fig)
```","The provided code correctly answers the business question by counting the number of distinct shipping recipients each month. It uses a SQL query with `DATE_FORMAT`, which is equivalent to `TO_CHAR` for formatting dates, and groups by month to count distinct recipients. After retrieving the results, it sorts by month in the SQL query itself, which aligns with the logic in the reference code. Finally, it uses Plotly Express to create a line chart, displaying a similar visualization to the reference code.","
```python
import plotly.express as px
import pandas as pd

# SQL Query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, COUNT(DISTINCT ShipName) AS DistinctShippers
FROM orders
GROUP BY DATE_TRUNC('month', OrderDate);
""""""

# Execute SQL Query
monthly_distinct_shippers_df = execute_sql_query(sql_query)

# Create a line chart to visualize monthly trends
fig = px.line(
    monthly_distinct_shippers_df,
    x='Month',
    y='DistinctShippers',
    title='Monthly Distinct Shipping Recipients',
    labels={'DistinctShippers': 'Distinct Shippers', 'Month': 'Month'}
)

# Display the figure using the utility function
show_to_user(fig)
```
","Both the provided code and the reference code are functionally equivalent in terms of calculating the number of distinct shipping recipients per month. The key difference lies in the method of extracting the month from the OrderDate. The reference code uses TO_CHAR(OrderDate, 'YYYY-MM') to format the date as a month string, whereas the evaluated code uses DATE_TRUNC('month', OrderDate), which preserves the date format but effectively groups by month. Both methods achieve the same group-by-month functionality. The variable names differ, but this does not affect the logic or the correctness of the result. Additionally, both codes create a line chart using Plotly to visualize the trends, satisfying the visualization requirement of the business analytics request.",both
"What is the total number of orders processed per employee, broken down by year, and can this information be displayed in a bar chart for clarity?","```python
import pandas as pd
import plotly.express as px

def get_orders_per_employee_by_year():
    # SQL query to fetch the total number of orders processed per employee, broken down by year
    sql_query = """"""
    SELECT e.EmployeeID, YEAR(o.OrderDate) AS Year, 
    COUNT(o.OrderID) AS OrderCount 
    FROM employees e 
    JOIN orders o ON e.EmployeeID = o.EmployeeID 
    GROUP BY e.EmployeeID, YEAR(o.OrderDate);
    """"""
    
    # Execute the SQL query
    df = execute_sql_query(sql_query)
    
    # Display the data in a bar chart
    fig = px.bar(df, x='Year', y='OrderCount', color='EmployeeID',
                 labels={'OrderCount': 'Total Orders', 'EmployeeID': 'Employee ID'},
                 title='Total Orders Processed per Employee by Year')

    # Show the plot to the user
    show_to_user(fig)

# Run the function to get and display the data
get_orders_per_employee_by_year()
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.EmployeeID, 
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName, 
    YEAR(o.OrderDate) AS OrderYear, 
    COUNT(o.OrderID) AS TotalOrders
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
GROUP BY 
    e.EmployeeID, YEAR(o.OrderDate)
ORDER BY 
    e.EmployeeID, OrderYear
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='OrderYear', y='TotalOrders', color='EmployeeName', 
              title='Total Number of Orders Processed per Employee by Year',
              labels={'TotalOrders': 'Total Orders', 'OrderYear': 'Year'})
show_to_user(fig)
```","The input code correctly answers the business analytics request and adheres to the same logic as the reference code. Both implementations execute a SQL query to count the number of orders processed by each employee per year. The result is then visualized using a bar chart with similar parameters. The input code additionally includes employee names but this does not alter the result concerning total orders per employee per year. Therefore, it is correct.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a mock function. Actual implementation should execute the SQL and return a DataFrame.
    # Example result for demonstration purposes.
    return pd.DataFrame({
        'FirstName': ['John', 'John', 'Jane', 'Jane'],
        'LastName': ['Doe', 'Doe', 'Smith', 'Smith'],
        'Year': [2022, 2023, 2022, 2023],
        'OrderCount': [150, 175, 200, 225]
    })

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to execute
sql_query = """"""
SELECT e.FirstName, e.LastName, YEAR(o.OrderDate) AS Year, COUNT(o.OrderID) AS OrderCount
FROM employees e
JOIN orders o ON e.EmployeeID = o.EmployeeID
GROUP BY e.FirstName, e.LastName, YEAR(o.OrderDate);
""""""

# Execute the query and get the results
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df,
    x=[""FirstName"", ""LastName"", ""Year""],
    y=""OrderCount"",
    title=""Total Number of Orders Processed Per Employee by Year"",
    labels={""OrderCount"": ""Number of Orders"", ""Year"": ""Year""},
    barmode='group'
)

# Display the chart using the utility function
show_to_user(fig)
```","The input code uses 'FirstName' and 'LastName' in the SQL query and the plot, while the reference code uses 'EmployeeID'. This causes a grouping difference, making the input code not adhere to the same logic as the reference implementation.",Base
"What is the average lead time for each supplier to deliver products, and can we visualize these lead times using a bar chart for easy comparison?","```python
import pandas as pd
import plotly.express as px

# SQL Query to get average lead time for each supplier
sql_query = '''
SELECT p.SupplierID, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime
FROM products p
JOIN orders o ON p.ProductID = o.ProductID
GROUP BY p.SupplierID;
'''

# Execute the SQL query and retrieve the data as a pandas DataFrame
supplier_lead_times = execute_sql_query(sql_query)

# Visualize the average lead times using a bar chart
fig = px.bar(supplier_lead_times, x='SupplierID', y='AvgLeadTime', 
             title='Average Lead Time by Supplier',
             labels={'SupplierID': 'Supplier ID', 'AvgLeadTime': 'Average Lead Time (Days)'})

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    s.CompanyName,
    AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AverageLeadTime
FROM 
    suppliers s
JOIN 
    products p ON s.SupplierID = p.SupplierID
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON o.OrderID = od.OrderID
GROUP BY 
    s.CompanyName
""""""

lead_time_data = execute_sql_query(sql_query)

fig = px.bar(lead_time_data, x='CompanyName', y='AverageLeadTime', title='Average Lead Time by Supplier', labels={'AverageLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'})
show_to_user(fig)
```","The input code correctly calculates the average lead time for each supplier and creates a bar chart for visualization. Although the SQL query includes additional joins, it ultimately leverages the correct logic for calculating average lead time per supplier using DATEDIFF between ShippedDate and OrderDate, similar to the reference code. The visualization with plotly.express bar chart is also consistent with the reference implementation.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch average lead time per supplier
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, AVG(DATEDIFF(o.ShippedDate, o.OrderDate)) AS AvgLeadTime 
FROM suppliers s 
JOIN products p ON s.SupplierID = p.SupplierID 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON o.OrderID = od.OrderID 
GROUP BY s.SupplierID, s.CompanyName;
""""""

# Fetch data using the utility function
df = execute_sql_query(sql_query)

# Visualize the average lead times using a bar chart
fig = px.bar(
    df, 
    x='CompanyName', 
    y='AvgLeadTime', 
    title='Average Lead Time per Supplier',
    labels={'AvgLeadTime': 'Average Lead Time (Days)', 'CompanyName': 'Supplier'},
    template='plotly'
)

# Display the figure to the user
show_to_user(fig)
```","Both the reference code and the input code compute the average lead time for each supplier by calculating the difference between the 'ShippedDate' and 'OrderDate'. The input code includes additional joins to retrieve the supplier company name and visualizes the results by 'CompanyName' instead of 'SupplierID', which does not alter the correctness of the answer given the same logic is applied. The visualization also effectively addresses the business request for comparing lead times via a bar chart.",both
What percentage of products are discontinued? Include a pie chart to visualize the proportion of discontinued versus active products.,"```python
import pandas as pd
import plotly.express as px

# SQL query to calculate the percentage of discontinued products
sql_query = """"""
SELECT COUNT(CASE WHEN Discontinued = 1 THEN 1 END) AS DiscontinuedCount,
       COUNT(*) AS TotalCount
FROM products;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Calculate the percentage of discontinued products
df['DiscontinuedPercentage'] = df['DiscontinuedCount'] * 100.0 / df['TotalCount']

# Prepare data for visualization
data = {
    'Status': ['Discontinued', 'Active'],
    'Count': [df['DiscontinuedCount'].iloc[0], df['TotalCount'].iloc[0] - df['DiscontinuedCount'].iloc[0]]
}

visualization_df = pd.DataFrame(data)

# Create a pie chart to visualize the proportion of discontinued versus active products
fig = px.pie(visualization_df, values='Count', names='Status', 
             title='Proportion of Discontinued vs Active Products')

# Show the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Discontinued, COUNT(*) as Count FROM products GROUP BY Discontinued""
data = execute_sql_query(sql_query)

total_products = data['Count'].sum()
discontinued_count = data[data['Discontinued'] == 1]['Count'].values[0] if 1 in data['Discontinued'].values else 0
active_count = data[data['Discontinued'] == 0]['Count'].values[0] if 0 in data['Discontinued'].values else 0

percentage_discontinued = (discontinued_count / total_products) * 100

fig = px.pie(values=[discontinued_count, active_count], names=['Discontinued', 'Active'], title='Product Status Distribution')
show_to_user(fig)

percentage_discontinued
```","Both implementations accomplish the task of calculating the percentage of discontinued products and creating a pie chart to visualize the proportion of discontinued versus active products. The evaluated code computes the discontinued and active product counts based on the 'Discontinued' status, calculates the percentage of discontinued products, and uses Plotly to create a pie chart. The logic aligns with the reference implementation, despite differences in SQL and DataFrame manipulations.","```python
import plotly.express as px
import pandas as pd

# Execute SQL query to get the discontinued product percentage
sql_query = """"""
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM products)) AS DiscontinuedPercentage 
FROM products 
WHERE Discontinued = 1;
""""""
discontinued_df = execute_sql_query(sql_query)

# Create a DataFrame to hold active and discontinued counts
total_products = pd.DataFrame({
    'Type': ['Discontinued', 'Active'],
    'Count': [
        int(discontinued_df.iloc[0]['DiscontinuedPercentage'] / 100 * len(discontinued_df)),
        len(discontinued_df) - int(discontinued_df.iloc[0]['DiscontinuedPercentage'] / 100 * len(discontinued_df))
    ]
})

# Create a pie chart using Plotly
fig = px.pie(total_products, names='Type', values='Count', title='Product Status Distribution')

# Show the pie chart visualization to the user
show_to_user(fig)
```","The evaluated code attempts to calculate the percentage of discontinued products using a subquery to get the total count from the same table and computes the percentage in SQL. However, it improperly constructs the DataFrame to visualize the pie chart. The reference code calculates counts separately and builds a DataFrame for the chart. The evaluated code erroneously calculates 'Active' product counts, as it assumes the length of the 'discontinued_df' corresponds to total products, which isn't true given the SQL query structure. The logic deviates from the reference implementation, which appropriately derives the total count from the complete dataset and performs accurate visualization.",Base
Find the top 5 customers based on total order quantities and provide a bar chart to visualize their order quantities.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the top 5 customers based on total order quantities
sql_query = """"""
SELECT orders.CustomerID, SUM([Order Details].Quantity) AS total_quantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY orders.CustomerID
ORDER BY total_quantity DESC
LIMIT 5;
""""""

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function to execute the query and return a DataFrame
    # In a real scenario, this would connect to a database
    data = {
        'CustomerID': ['C001', 'C002', 'C003', 'C004', 'C005'],
        'total_quantity': [250, 200, 150, 100, 90]
    }
    return pd.DataFrame(data)

# Run the query to get the data
df_top_customers = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_top_customers, x='CustomerID', y='total_quantity',
             title='Top 5 Customers Based on Total Order Quantities',
             labels={'total_quantity': 'Total Order Quantity', 'CustomerID': 'Customer ID'})

# Display the chart using the provided utility function
def show_to_user(data):
    # Simulated function to display data
    # would integrate with Jupyter or another environment
    print(""Displaying data..."")

show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT customers.CustomerID, SUM([Order Details].Quantity) AS total_order_quantity
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN customers ON orders.CustomerID = customers.CustomerID
GROUP BY customers.CustomerID
ORDER BY total_order_quantity DESC
LIMIT 5
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CustomerID', y='total_order_quantity', title='Top 5 Customers by Total Order Quantities')
show_to_user(fig)
```","The input code correctly adheres to the request and the logic of the reference code. Both versions aim to find the top 5 customers based on total order quantities by joining the 'Order Details' and 'orders' tables, grouping by CustomerID, and ordering by total quantities. The input also includes an additional join with a 'customers' table for completeness, which doesn't affect the primary result. A bar chart is generated using Plotly in both codes, and displayed using the show_to_user function, satisfying the visualization requirement.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT customers.CustomerID, 
       SUM([Order Details].Quantity) AS TotalQuantity
FROM customers 
JOIN orders ON customers.CustomerID = orders.CustomerID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY customers.CustomerID 
ORDER BY TotalQuantity DESC 
LIMIT 5;
""""""

# Execute the SQL query
top_customers_df = execute_sql_query(sql_query)

# Check if DataFrame is not empty, then visualize
if not top_customers_df.empty:
    # Create a bar chart using Plotly
    fig = px.bar(top_customers_df, x='CustomerID', y='TotalQuantity', 
                 title='Top 5 Customers by Order Quantity', 
                 labels={'CustomerID': 'Customer ID', 'TotalQuantity': 'Total Quantity Ordered'})
    
    # Display the visualization to the user
    show_to_user(fig)
else:
    # Display a message if no data is retrieved
    df_empty = pd.DataFrame({'Message': ['No data available to display.']})
    show_to_user(df_empty)
```","Both the input and the reference implementations achieve the same objective of finding the top 5 customers based on total order quantities and visualizing the data. The input code uses a slightly different query that includes joining the 'customers' table, but it still correctly calculates the total quantities using 'SUM', groups by 'CustomerID', orders the results in descending order, and limits the output to 5. Both codes successfully create a bar chart visualization using Plotly. The main difference lies in checking if the DataFrame is empty before visualization in the input code, but this does not affect the correctness based on the business request.",both
"Which products are the most frequently ordered per month, and can you provide a monthly trend visualization to display these frequencies?","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are defined elsewhere in the environment

# SQL query to get the data
sql_query = """"""
SELECT p.ProductName, 
       COUNT(od.OrderID) AS OrderFrequency, 
       EXTRACT(MONTH FROM o.OrderDate) AS Month 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY p.ProductName, EXTRACT(MONTH FROM o.OrderDate)
""""""

# Execute the SQL query and get the result as a dataframe
df = execute_sql_query(sql_query)

# Convert month from numerical to month name for better readability
df['Month'] = pd.to_datetime(df['Month'], format='%m').dt.month_name()

# Sort the dataframe by month (since it's currently ordered by numerical month)
df['Month'] = pd.Categorical(df['Month'], categories=[
    ""January"", ""February"", ""March"", ""April"", ""May"", ""June"",
    ""July"", ""August"", ""September"", ""October"", ""November"", ""December""
], ordered=True)

df = df.sort_values('Month')

# Create a line plot using Plotly express
fig = px.line(df, x='Month', y='OrderFrequency', color='ProductName', title='Monthly Product Order Frequencies')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName,
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS OrderMonth,
    SUM(od.Quantity) AS TotalQuantity
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    p.ProductID, 
    p.ProductName, 
    OrderMonth
ORDER BY 
    OrderMonth, 
    SUM(od.Quantity) DESC
""""""

df = execute_sql_query(sql_query)

monthly_trend = df.groupby(['OrderMonth', 'ProductName'])['TotalQuantity'].sum().reset_index()

fig = px.line(monthly_trend, x='OrderMonth', y='TotalQuantity', color='ProductName',
              title='Monthly Product Order Frequency Trend')
show_to_user(fig)
```","The input code differs from the reference in key areas: it aggregates by `TotalQuantity` instead of `OrderFrequency`, and uses 'OrderMonth' formatted as year-month instead of extracting the month only. Moreover, it orders by quantity rather than exhibiting the most frequently ordered products per month.","```python
import plotly.express as px
import pandas as pd

# Function to execute SQL query and return result as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Dummy implementation for illustrative purposes
    # Replace with actual data fetching mechanism
    pass

# Function to display data or visualization to the user
def show_to_user(data):
    # Dummy implementation for illustrative purposes
    # Replace with actual display mechanism
    pass

# Define the SQL query
sql_query = """"""
SELECT p.ProductID, DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month, COUNT(od.ProductID) AS OrderFrequency
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY p.ProductID, Month
ORDER BY Month, OrderFrequency DESC;
""""""

# Execute the query and get data
data = execute_sql_query(sql_query)

# Create a line chart to visualize monthly trend of ordered products
fig = px.line(
    data,
    x='Month',
    y='OrderFrequency',
    color='ProductID',
    title='Monthly Trend of Most Frequently Ordered Products'
)

# Display the figure
show_to_user(fig)
```","The input code calculates `OrderFrequency` grouped by `ProductID` and uses another SQL function (`DATE_FORMAT`) which leads to different grouping and month format compared to the reference. The reference uses `ProductName` and `EXTRACT(MONTH FROM o.OrderDate)`, converting month numbers to names in Python. The input SQLite implementation may not align logically with the reference goal of identifying products by name that are frequently ordered, thus not fully meeting the business analytics request.",None
Calculate the on-time delivery rate for each shipping company in Q2 2023 and visualize the results using a bar chart.,"```python
import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rates
sql_query = """"""
SELECT
    shippers.CompanyName,
    SUM(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 ELSE 0 END) / CAST(COUNT(orders.OrderID) AS DECIMAL) AS on_time_delivery_rate
FROM
    orders
JOIN
    shippers ON orders.ShipVia = shippers.ShipperID
WHERE
    orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY
    shippers.CompanyName
""""""

# Utility function to execute SQL query
def execute_sql_query(sql_query: str):
    # This function should connect to the database, execute the provided SQL query, and return the result as a pandas DataFrame.
    # For demonstration purposes, we'll assume a pre-existing database connection and return a sample DataFrame.
    return pd.DataFrame({
        'CompanyName': ['Shipper A', 'Shipper B', 'Shipper C'],
        'on_time_delivery_rate': [0.85, 0.90, 0.78]
    })

# Execute the SQL query and get the results as a dataframe
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate',
             title='On-Time Delivery Rate by Shipping Company in Q2 2023',
             labels={'on_time_delivery_rate': 'On-Time Delivery Rate'})

# Use the show_to_user utility function to display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate on-time delivery rate for each shipping company in Q2 2023
sql_query = """"""
SELECT 
    shippers.CompanyName,
    COUNT(orders.OrderID) AS total_orders,
    COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) AS on_time_deliveries,
    (COUNT(CASE WHEN orders.ShippedDate <= orders.RequiredDate THEN 1 END) * 1.0 / COUNT(orders.OrderID)) AS on_time_delivery_rate
FROM 
    orders
JOIN 
    shippers ON orders.ShipVia = shippers.ShipperID
WHERE 
    orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY 
    shippers.CompanyName
""""""

# Execute the SQL query
delivery_data = execute_sql_query(sql_query)

# Visualization
fig = px.bar(delivery_data, 
              x='CompanyName', 
              y='on_time_delivery_rate', 
              title='On-time Delivery Rate by Shipping Company (Q2 2023)',
              labels={'on_time_delivery_rate': 'On-time Delivery Rate'},
              text='on_time_delivery_rate')
show_to_user(fig)
```","The input code correctly calculates the on-time delivery rate for each shipping company in Q2 2023 in the same logical manner as the reference code. Both implementations use a SQL query to calculate the on-time delivery rate by comparing the ShippedDate and RequiredDate, and group the results by CompanyName. The visualization step also uses Plotly to generate a bar chart that displays the calculated rates. Although there are some differences in SQL syntax (like using COUNT with CASE WHEN), the effective logic remains consistent with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return the data
def execute_sql_query(sql_query: str):
    # This function should be implemented to execute the query and return a DataFrame
    # For the purpose of this code, we assume the function is implemented
    pass

# Function to show the results to the user
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to calculate on-time delivery rate
sql_query = """"""
SELECT 
    shippers.CompanyName, 
    COUNT(orders.OrderID) / 
    (SELECT COUNT(*) FROM orders WHERE orders.ShipVia = shippers.ShipperID AND orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30') AS on_time_delivery_rate 
FROM 
    orders 
JOIN 
    shippers 
ON 
    orders.ShipVia = shippers.ShipperID 
WHERE 
    orders.RequiredDate >= orders.ShippedDate 
AND 
    orders.OrderDate BETWEEN '2023-04-01' AND '2023-06-30' 
GROUP BY 
    shippers.CompanyName
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(df, x='CompanyName', y='on_time_delivery_rate', title='On-Time Delivery Rate for Shipping Companies in Q2 2023')

# Show the figure to the user
show_to_user(fig)
```","The input code calculates on-time delivery rate differently compared to the reference implementation. In the input code, it calculates a ratio of on-time deliveries to total orders by company, but the method involves using a correlated subquery to count total orders per shipper, which does not divide on-time deliveries by total orders correctly, especially if the shipment is not on time. The logic fails to accurately compute on-time delivery rates as it doesn't replicate the SUM/COUNT logic of the reference. Hence, the logic is incorrect.",Base
"How does the average shipping cost vary by shipper, and can we illustrate this with a bar chart?","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = '''
SELECT shippers.CompanyName, AVG(orders.Freight) AS average_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
'''

# Execute the SQL query and get the result in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CompanyName', y='average_cost', 
             title='Average Shipping Cost by Shipper',
             labels={'CompanyName': 'Shipper', 'average_cost': 'Average Cost'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT shippers.CompanyName AS shipper, AVG(orders.Freight) AS avg_shipping_cost
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName
""""""

shipping_costs = execute_sql_query(sql_query)

fig = px.bar(shipping_costs, x='shipper', y='avg_shipping_cost', 
             title='Average Shipping Cost by Shipper', 
             labels={'avg_shipping_cost': 'Average Shipping Cost', 'shipper': 'Shipper'},
             color='avg_shipping_cost')

show_to_user(fig)
```",The input code correctly mirrors the logic of the reference implementation. Both implementations execute a SQL query that selects the shipper's company name and the average freight cost. They use a GROUP BY clause on the shipper's company name. The input code then generates a bar chart using Plotly with the same title and axes labels. The inclusion of color based on 'avg_shipping_cost' in the input code is an acceptable enhancement and does not deviate from the required logic.,"```python
import pandas as pd
import plotly.express as px

# SQL query to extract average freight cost by shipper
sql_query = """"""
SELECT shippers.CompanyName, AVG(orders.Freight) AS AvgFreight
FROM orders
JOIN shippers ON orders.ShipVia = shippers.ShipperID
GROUP BY shippers.CompanyName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart for average shipping cost by shipper
fig = px.bar(df, x='CompanyName', y='AvgFreight',
             title='Average Shipping Cost by Shipper',
             labels={'CompanyName': 'Shipper', 'AvgFreight': 'Average Freight Cost'})

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly implements the business analytics request as specified. It retrieves the average shipping cost by shipper using an SQL query, similar to the reference implementation. The variable names for the average cost differ ('average_cost' vs. 'AvgFreight'), but the logic remains consistent. It then creates a bar chart using Plotly and displays it. Hence, the code is functionally equivalent and adheres to the same logic as the reference implementation.",both
Determine the customer retention rate for the last year and provide a trend line chart to visualize changes over each month.,"```python
import pandas as pd
import plotly.express as px

# Utility function to execute an SQL query and return a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual SQL execution logic
    # Here we assume the function connects to a database, executes the given SQL query, and returns the result as a DataFrame
    pass

# Utility function to show data analysis or visualization results
def show_to_user(data):
    # Placeholder for visualization logic
    # In a real scenario, this would either display the DataFrame or Plotly figure
    pass

# SQL query for retrieving retention rate data per month for the last year
sql_query = """"""
SELECT 
    DATE_TRUNC('month', o1.OrderDate) AS OrderMonth,
    (COUNT(DISTINCT o1.CustomerID) * 1.0 / COUNT(DISTINCT o2.CustomerID)) AS RetentionRate 
FROM orders o1 
JOIN orders o2 ON o1.CustomerID = o2.CustomerID AND o2.OrderDate BETWEEN '2021-01-01' AND '2021-12-31' 
WHERE o1.OrderDate BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query to obtain the retention rate data
retention_data = execute_sql_query(sql_query)

# Create a trend line chart using Plotly
fig = px.line(retention_data, x='OrderMonth', y='RetentionRate', title='Customer Retention Rate Over 2022')

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

end_date = datetime.now()
start_date = end_date - timedelta(days=365)

sql_query = f""""""
SELECT 
    DATE_TRUNC('month', OrderDate) as Month,
    COUNT(DISTINCT CustomerID) as ReturningCustomers
FROM 
    orders
WHERE 
    OrderDate BETWEEN '{start_date.date()}' AND '{end_date.date()}'
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

retaining_customers_df = execute_sql_query(sql_query)

previous_month_sql_query = f""""""
SELECT 
    COUNT(DISTINCT CustomerID) as TotalCustomers
FROM 
    orders
WHERE 
    OrderDate < '{start_date.date()}';
""""""

total_customers_df = execute_sql_query(previous_month_sql_query)
total_customers = total_customers_df['TotalCustomers'][0]

retaining_customers_df['RetentionRate'] = retaining_customers_df['ReturningCustomers'] / total_customers

fig = px.line(retaining_customers_df, x='Month', y='RetentionRate', title='Customer Retention Rate Over the Last Year', labels={'RetentionRate': 'Retention Rate'})
show_to_user(fig)
```","The input code calculates the retention rate differently from the reference code. The reference code calculates retention by dividing the number of customers who returned this year by those who made purchases last year, ensuring continuity. In contrast, the input code divides returning customers in the current year by all customers from any time before this year, which does not align with the original retention logic for tracking changes from last year.","```python
import pandas as pd
import plotly.express as px
from datetime import datetime
from dateutil.relativedelta import relativedelta

# Predefined utility function placeholders
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function to simulate execution of an SQL query
    # In practice, this would connect to a database and return a DataFrame
    pass

def show_to_user(data):
    # Placeholder function to simulate displaying results to the user
    pass

# SQL Query to get monthly customer counts
sql_query_monthly = """"""
SELECT 
    EXTRACT(MONTH FROM MAX(OrderDate)) AS month, 
    COUNT(DISTINCT CASE WHEN OrderDate >= '2022-01-01' AND OrderDate < '2023-01-01' THEN CustomerID END) AS current_year_customers, 
    COUNT(DISTINCT CASE WHEN OrderDate < '2022-01-01' THEN CustomerID END) AS previous_customers
FROM orders
WHERE OrderDate < '2023-01-01'
GROUP BY EXTRACT(MONTH FROM OrderDate);
""""""

# Execute SQL query to get monthly data
monthly_data = execute_sql_query(sql_query_monthly)

# Calculate customer retention rate per month
monthly_data['retention_rate'] = monthly_data['current_year_customers'] / (
    monthly_data['current_year_customers'] + (monthly_data['previous_customers'] - monthly_data['current_year_customers'])
)

# Create a trend line chart
fig = px.line(
    monthly_data.sort_values(by='month'),
    x='month',
    y='retention_rate',
    title='Customer Retention Rate Trend (2022)',
    labels={'month': 'Month', 'retention_rate': 'Retention Rate'}
)

# Display the trend line chart
show_to_user(fig)
```","The input code calculates retention rates based on a flawed SQL query and logic. It extracts data monthly but checks customer count only based on '2022-01-01' in a cumulative manner without ensuring these are repeated customers from the previous year. The reference implementation uses a correct SQL join across two conditions to find consistent customers, then aggregates them monthly, correctly comparing the two annual windows.",None
"How many products have never been ordered, and display the results using a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch products that have never been ordered
sql_query = """"""
SELECT ProductName 
FROM products 
WHERE ProductID NOT IN (
    SELECT DISTINCT ProductID 
    FROM [Order Details]
);
""""""

# Execute the SQL query and get the results as a pandas DataFrame
unordered_products_df = execute_sql_query(sql_query)

# Calculate the number of unordered products
num_unordered_products = unordered_products_df.shape[0]

# Create a DataFrame for visualization
visualization_df = pd.DataFrame({
    'Status': ['Unordered Products'],
    'Count': [num_unordered_products]
})

# Create a bar chart using Plotly
fig = px.bar(visualization_df, x='Status', y='Count', title='Number of Unordered Products')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find products that have never been ordered
sql_query = """"""
SELECT p.ProductID, p.ProductName 
FROM products p 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.ProductID IS NULL
""""""

# Execute the query and get the result
never_ordered_products = execute_sql_query(sql_query)

# Count the number of products that have never been ordered
count_never_ordered = never_ordered_products.shape[0]

# Create a bar chart to display the count of never ordered products
fig = px.bar(x=['Never Ordered Products'], y=[count_never_ordered],
             labels={'x': 'Products', 'y': 'Count'},
             title='Count of Products That Have Never Been Ordered')

# Show the result to the user
show_to_user(fig)
```","Both implementations correctly answer the analytics request to find how many products have never been ordered and visualize the result using a bar chart. The approaches differ in the SQL query method: the reference uses a subquery with NOT IN, whereas the input code employs a LEFT JOIN with IS NULL. Both methods are valid for identifying products that don't have matching entries in the 'Order Details' table. The resultant count and visualization logic align with each other, fulfilling the business requirement.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT products.ProductName 
FROM products 
LEFT JOIN [Order Details] ON products.ProductID = [Order Details].ProductID 
WHERE [Order Details].OrderID IS NULL
""""""

# Execute the SQL query to get the data
products_df = execute_sql_query(sql_query)

# Count the number of unique products that have never been ordered
number_of_products_never_ordered = products_df['ProductName'].nunique()

# Create a DataFrame for visualization
viz_df = pd.DataFrame({'Status': ['Never Ordered'], 'Count': [number_of_products_never_ordered]})

# Create a bar chart for visualization
fig = px.bar(viz_df, x='Status', y='Count')

# Display the result
show_to_user(fig)
```","Both implementations correctly determine how many products have never been ordered. The input code uses a LEFT JOIN with a WHERE clause to identify products with no orders, while the reference code uses a subquery with NOT IN. Both approaches yield the same result. The visualizations are also equivalent, creating a bar chart that displays the count of unordered products.",both
"Identify the correlation between product price and reorder level, including a scatter plot to visualize the relationship.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the required data
sql_query = """"""
SELECT ProductID, ProductName, 
       (CAST(UnitPrice AS DOUBLE) / ReorderLevel) AS PriceToReorderRatio 
FROM products;
""""""

# Execute the SQL query
data = execute_sql_query(sql_query)

# Check for any missing values in the data
if data.isnull().sum().any():
    # Handle missing values if necessary
    data.dropna(inplace=True)

# Calculate correlation between UnitPrice and ReorderLevel
correlation = data[['PriceToReorderRatio']].corr().iloc[0, 0]

# Display correlation
correlation_df = pd.DataFrame({'Correlation': [correlation]})
show_to_user(correlation_df)

# Create a scatter plot to visualize the relationship
fig = px.scatter(data_frame=data, x='ProductID', y='PriceToReorderRatio', 
                 title='Correlation between Product Price and Reorder Level',
                 labels={'ProductID': 'Product ID', 'PriceToReorderRatio': 'Price to Reorder Ratio'},
                 trendline='ols')

# Show the scatter plot
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    UnitPrice, 
    ReorderLevel 
FROM 
    products 
WHERE 
    Discontinued = 0
""""""

data = execute_sql_query(sql_query)

correlation = data.corr().iloc[0, 1]

fig = px.scatter(data, x='UnitPrice', y='ReorderLevel', 
                 title=f'Correlation between Product Price and Reorder Level: {correlation:.2f}', 
                 labels={'UnitPrice': 'Product Price', 'ReorderLevel': 'Reorder Level'})

show_to_user(fig)
```","The provided code does not adhere to the logic of the reference implementation. The reference implementation calculates a 'PriceToReorderRatio' by dividing UnitPrice by ReorderLevel to measure the correlation. The evaluated code directly finds the correlation between UnitPrice and ReorderLevel, which differs from the computation of 'PriceToReorderRatio'. Furthermore, the input code does not handle missing data as the reference does.","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = '''
SELECT ProductName, UnitPrice, ReorderLevel FROM products;
'''

# Execute the SQL query to get the data
data = execute_sql_query(sql_query)

# Calculate the correlation between UnitPrice and ReorderLevel
correlation = data[['UnitPrice', 'ReorderLevel']].corr().iloc[0, 1]

# Display the correlation
correlation_df = pd.DataFrame({'Correlation': [correlation]})
show_to_user(correlation_df)

# Create a scatter plot to visualize the relationship
fig = px.scatter(data, x='UnitPrice', y='ReorderLevel', title='Scatter Plot of Unit Price vs Reorder Level')
show_to_user(fig)
```","The input code directly calculates the correlation between 'UnitPrice' and 'ReorderLevel', whereas the reference code calculates a derived 'PriceToReorderRatio' and uses it for correlation analysis and visualization. The logic for correlation analysis in both codes is different.",None
"What is the total revenue for each product considering discounts, and can you provide a bar chart to visualize the results?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName;
""""""

# Utilize the utility function to execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductName', y='TotalRevenue', title='Total Revenue by Product')

# Display the bar chart using the show_to_user utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID, 
    p.ProductName, 
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
""""""

revenue_data = execute_sql_query(sql_query)

fig = px.bar(revenue_data, x='ProductName', y='TotalRevenue', title='Total Revenue per Product', labels={'TotalRevenue': 'Revenue (after discounts)', 'ProductName': 'Product Name'})
show_to_user(fig)
```","The input code correctly executes the SQL query to calculate the total revenue for each product considering discounts and generates a bar chart visualization. The SQL query logic matches the reference implementation by grouping results by both ProductID and ProductName, which ensures correct aggregation with unique product identification. Although the input code includes an additional group by column (ProductID) compared to the reference, it still adheres to the same business logic and produces the same outcome. The labels in the plot are enhanced but do not alter the chart's correctness.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Sample function for demonstration purposes.
    # Assume it executes the SQL query and returns a pandas DataFrame.
    pass

def show_to_user(data):
    # Sample function for demonstration purposes.
    # Assume it displays the data.
    pass

# SQL query to fetch data
sql_query = """"""
SELECT od.product_id, 
       SUM(od.unit_price * od.quantity * (1 - od.discount)) AS total_revenue 
FROM [Order Details] od 
GROUP BY od.product_id;
""""""

# Execute the SQL query and retrieve data
df_revenue = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df_revenue, x='product_id', y='total_revenue', title='Total Revenue per Product')

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code calculates total revenue by 'product_id' instead of 'ProductName', whereas the reference code joins the 'products' table to provide revenue by 'ProductName'. The reference query uses 'ProductName' to group results which aligns with the business requirement to display the revenue per product name. Additionally, the input code misses the join with the 'products' table necessary to obtain the product names.",Base
Identify products with the highest unit price that have never been ordered and create a bar chart to visualize these products.,"import pandas as pd
import plotly.express as px

# Define the SQL query to identify products with the highest unit price that have never been ordered
sql_query = """"""
SELECT ProductID, ProductName, UnitPrice 
FROM products 
WHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM [Order Details]) 
ORDER BY UnitPrice DESC;
""""""

# Execute the SQL query and load the data into a pandas DataFrame
df_products = execute_sql_query(sql_query)

# Extract the products with the highest unit price
highest_price_products = df_products[df_products['UnitPrice'] == df_products['UnitPrice'].max()]

# Create a bar chart to visualize the products with the highest unit price that have never been ordered
fig = px.bar(highest_price_products, x='ProductName', y='UnitPrice', title='Highest Priced Products Never Ordered')

# Display the visualization using the provided utility function
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, p.UnitPrice 
FROM products p 
LEFT JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE od.ProductID IS NULL 
ORDER BY p.UnitPrice DESC
""""""

products_not_ordered = execute_sql_query(sql_query)

fig = px.bar(products_not_ordered, x='ProductName', y='UnitPrice', title='Highest Unit Price Products Never Ordered')
show_to_user(fig)
```","The input code does not extract only the products with the highest unit price from those never ordered. It attempts to retrieve all non-ordered products sorted by unit price and visualizes them all, unlike the reference code, which specifically selects products with the maximum unit price among those never ordered.","```python
import pandas as pd
import plotly.express as px

# The provided business SQL query
sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE UnitsOnOrder = 0 
ORDER BY UnitPrice DESC 
LIMIT 5;
""""""

# Execute the SQL query using a utility function
products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the products with the highest unit prices
fig = px.bar(products_df, x='ProductName', y='UnitPrice', 
             title='Top 5 Products with Highest Unit Prices Never Ordered',
             labels={'UnitPrice': 'Unit Price', 'ProductName': 'Product Name'})

# Display the visualization using the utility function
show_to_user(fig)
```","The input code retrieves products with zero units on order and limits the output to the top 5 by unit price, but it does not ensure that these products have never been ordered. The business request specifically requires identifying products that have never been ordered based on order details. The reference implementation correctly checks for products not present in any order details using a subquery, which the input code does not do.",None
What percentage of orders have been delivered on or before the required date for each month? Include a line chart to visualize the monthly delivery performance.,"import pandas as pd
import plotly.express as px

# SQL query
sql_query = """"""
SELECT TO_CHAR(OrderDate, 'YYYY-MM') AS OrderMonth, 
       (CAST(SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS DECIMAL) / COUNT(*)) * 100 AS OnTimeDeliveryRate 
FROM orders 
GROUP BY OrderMonth;
""""""

# Function to execute SQL query
def execute_sql_query(sql_query: str):
    # Placeholder for actual database interaction code
    data = {
        'OrderMonth': ['2022-01', '2022-02', '2022-03'],
        'OnTimeDeliveryRate': [88.5, 92.3, 85.6]
    }
    return pd.DataFrame(data)

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly delivery performance
fig = px.line(df, x='OrderMonth', y='OnTimeDeliveryRate', 
              title='Monthly On-Time Delivery Performance',
              labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'},
              markers=True)

# Function to display to user
def show_to_user(data):
    # Assuming this function can handle either a DataFrame or a Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Show the line chart to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_TRUNC('month', RequiredDate) AS month,
    COUNT(OrderID) AS total_orders,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) AS on_time_deliveries
FROM 
    orders
GROUP BY 
    DATE_TRUNC('month', RequiredDate)
ORDER BY 
    month;
""""""

order_data = execute_sql_query(sql_query)

order_data['on_time_percentage'] = (order_data['on_time_deliveries'] / order_data['total_orders']) * 100

fig = px.line(order_data, x='month', y='on_time_percentage', title='Monthly On-time Delivery Rate', labels={'on_time_percentage': 'On-time Delivery Percentage'})
show_to_user(fig)
```","The input code uses DATE_TRUNC on RequiredDate to group by month which differs from the reference implementation that uses the OrderDate to determine the OrderMonth. This results in a potentially different grouping and logic. Additionally, the input code's ORDER BY clause is redundant because the grouping is already done by month.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
    SELECT TO_CHAR(OrderDate, 'YYYY-MM') AS Month,
           COUNT(CASE WHEN ShippedDate <= RequiredDate THEN OrderID END) * 100.0 / COUNT(OrderID) AS OnTimeDeliveryRate
    FROM orders
    GROUP BY TO_CHAR(OrderDate, 'YYYY-MM');
""""""

# Execute the SQL query using the utility function
orders_df = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly on-time delivery performance
fig = px.line(
    orders_df,
    x='Month',
    y='OnTimeDeliveryRate',
    title='Monthly On-Time Delivery Performance',
    labels={'Month': 'Month', 'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'}
)

# Display the line chart
show_to_user(fig)
```","The input code implementation correctly answers the business analytics request and follows the same logic as the reference code. Both implementations calculate the percentage of on-time deliveries per month, grouping by the month and using the same conditional logic in the SQL query. The slight differences in SQL syntax (COUNT vs. SUM and the use of COUNT(OrderID)) result in the same calculation of the on-time delivery rate. Both codes also create similar line charts to visualize the results. Therefore, the input implementation is consistent with the reference task requirements.",Finetuned
"What is the distribution of orders among different shipping methods, and can this be visualized using a bar chart to enhance understanding?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipVia;
""""""

# Execute the SQL query and retrieve the result in a pandas DataFrame
orders_distribution_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the distribution of orders among different shipping methods
fig = px.bar(
    orders_distribution_df, 
    x='ShipVia', 
    y='OrderCount', 
    title='Distribution of Orders Among Shipping Methods',
    labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Order Count'}
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipVia
""""""
order_distribution = execute_sql_query(sql_query)

fig = px.bar(order_distribution, x='ShipVia', y='OrderCount', title='Distribution of Orders by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'OrderCount': 'Number of Orders'})

show_to_user(fig)
```","The provided Python code accomplishes the same task as the reference implementation. It executes the same SQL query to retrieve the order distribution by shipping method, stores the result in a DataFrame, and uses Plotly to create a bar chart. The chart configuration differences, such as the title and labels, are negligible and don't affect the correctness relative to the business analytics request.","```python
import plotly.express as px

# SQL query to get the order count by shipping method
sql_query = """"""
SELECT o.ShipVia, COUNT(o.OrderID) AS OrderCount
FROM orders o
GROUP BY o.ShipVia;
""""""

# Execute the SQL query and retrieve the data as a pandas DataFrame
order_data_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of orders among shipping methods
fig = px.bar(order_data_df, x='ShipVia', y='OrderCount', title='Distribution of Orders by Shipping Method')

# Display the bar chart to the user
show_to_user(fig)
```","The provided input code fulfills the business analytics request by executing the same SQL query to retrieve the distribution of order counts among different shipping methods. It then uses Plotly to create a bar chart, which is the same approach as the reference code. The minor differences, such as variable names and slightly different chart titles, do not affect the core logic or output of the program.",both
"What is the distribution of orders across different regions, and can you provide a visual representation of this distribution?","```python
import pandas as pd
import plotly.express as px

# Define SQL query
sql_query = """"""
SELECT c.Region, COUNT(o.OrderID) AS OrderCount 
FROM customers c 
JOIN orders o ON c.CustomerID = o.CustomerID 
GROUP BY c.Region;
""""""

# Execute SQL query and retrieve data as a DataFrame
df = execute_sql_query(sql_query)

# Visualize the distribution of orders across different regions using Plotly
fig = px.bar(df, x='Region', y='OrderCount', title='Distribution of Orders Across Regions')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.Region, COUNT(o.OrderID) AS OrderCount
FROM orders o
JOIN customers c ON o.CustomerID = c.CustomerID
GROUP BY c.Region
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='Region', y='OrderCount', title='Distribution of Orders Across Different Regions')
show_to_user(fig)
```","The input code is correct as it satisfies the business analytics request and follows the logic of the reference implementation. Both codes execute a SQL query to count the number of orders by region, and use Plotly for visualization. The order of the JOIN operation in SQL doesn't affect the result as the JOIN condition is the same. Thus, the input code meets the specified requirements.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch order data by region
sql_query = """"""
SELECT ShipRegion, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY ShipRegion;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Create a bar plot using Plotly to visualize the distribution of orders across regions
fig = px.bar(orders_df, x='ShipRegion', y='OrderCount', title='Distribution of Orders Across Regions')

# Display the plot using the provided utility function
show_to_user(fig)
```","The input code groups the orders by 'ShipRegion' from the 'orders' table directly, whereas the reference implementation aggregates orders based on the 'Region' from the 'customers' table joined with the 'orders' table. This results in potential discrepancies in regions if 'Region' and 'ShipRegion' are not equivalent or have different values.",Base
Determine the total sales generated by discontinued products and provide a bar chart showing sales by product category.,"```python
import pandas as pd
import plotly.express as px

# SQL query to fetch total sales by discontinued products
sql_query = """"""
SELECT p.ProductName, p.CategoryID, SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
WHERE p.Discontinued = 1 
GROUP BY p.ProductName, p.CategoryID;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Group the data by CategoryID and sum the TotalSales
category_sales = df.groupby('CategoryID', as_index=False)['TotalSales'].sum()

# Create a bar chart using Plotly
fig = px.bar(category_sales, x='CategoryID', y='TotalSales', title='Sales by Product Category for Discontinued Products')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve total sales from discontinued products and sales by product category
sql_query = """"""
SELECT 
    p.CategoryID,
    SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
WHERE 
    p.Discontinued = 1
GROUP BY 
    p.CategoryID
""""""

# Execute the SQL query
discontinued_sales_df = execute_sql_query(sql_query)

# Bar chart for sales by product category
fig = px.bar(discontinued_sales_df, x='CategoryID', y='TotalSales', title='Total Sales of Discontinued Products by Category')
show_to_user(fig)

# Calculate the total sales generated by discontinued products
total_sales_discontinued = discontinued_sales_df['TotalSales'].sum()
print(total_sales_discontinued)
```","The input Python code correctly addresses the business analytics request. It calculates the total sales of discontinued products, grouping by the product category (CategoryID) via SQL, just like the reference code. The input code also provides the required bar chart showing the total sales per category using Plotly, similar to the reference. Additionally, the input code calculates and prints the total sales of all discontinued products, which goes beyond the reference requirements but adds useful information. Overall, the logic aligns with the reference implementation, ensuring the task is executed correctly.","```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to get the total sales from discontinued products
sql_query_total_sales = """"""
SELECT SUM([Order Details].Quantity * [Order Details].UnitPrice) AS TotalSales 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
WHERE products.Discontinued = 1;
""""""

# Execute and store results in a DataFrame
total_sales_df = execute_sql_query(sql_query_total_sales)

# Step 2: Display total sales
show_to_user(total_sales_df)

# Step 3: Retrieve sales by product category for discontinued products
sql_query_sales_by_category = """"""
SELECT categories.CategoryName, 
       SUM([Order Details].Quantity * [Order Details].UnitPrice) AS SalesByCategory 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN categories ON products.CategoryID = categories.CategoryID
WHERE products.Discontinued = 1
GROUP BY categories.CategoryName;
""""""

# Execute and store results in a DataFrame
sales_by_category_df = execute_sql_query(sql_query_sales_by_category)

# Step 4: Create a bar chart for sales by product category
fig = px.bar(sales_by_category_df, x='CategoryName', y='SalesByCategory', 
             title='Sales by Product Category for Discontinued Products',
             labels={'SalesByCategory': 'Sales Amount', 'CategoryName': 'Product Category'})

# Step 5: Display the bar chart
show_to_user(fig)
```","The input code does not include discounts in the sales calculation, while the reference code considers discounts when calculating TotalSales. The SQL query in the input code multiplies only Quantity and UnitPrice, missing the discount factor, whereas the reference implementation correctly uses Quantity * UnitPrice * (1 - Discount). This leads to incorrect sales figures compared to the reference code.",Base
Which employees have generated the highest sales in the past year? Please provide a bar chart to visualize the top performers.,"```python
import pandas as pd
import plotly.express as px

# Sample implementation of utility functions
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder for actual database query execution
    # Returns a pandas DataFrame
    pass 

def show_to_user(data):
    # Displays the data or Plotly figure
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to fetch the top 5 employees by total sales in the past year
sql_query = """"""
SELECT e.EmployeeID, e.FirstName, e.LastName, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales 
FROM employees e 
JOIN orders o ON e.EmployeeID = o.EmployeeID 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) 
GROUP BY e.EmployeeID, e.FirstName, e.LastName 
ORDER BY TotalSales DESC 
LIMIT 5;
""""""

# Execute the query and obtain the results as a DataFrame
top_employees_df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    top_employees_df,
    x='FirstName',
    y='TotalSales',
    text='TotalSales',
    labels={'TotalSales': 'Total Sales ($)', 'FirstName': 'Employee First Name'},
    title='Top Employees by Sales in the Past Year'
)

# Adjust the text position and layout
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')

# Show the figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve employee sales for the past year
sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY 
    e.EmployeeID
ORDER BY 
    TotalSales DESC
LIMIT 10
""""""

# Execute the SQL query
top_performers = execute_sql_query(sql_query)

# Create a bar chart to visualize the top performers
fig = px.bar(top_performers, x='EmployeeName', y='TotalSales', title='Top Sales Employees in the Past Year', labels={'TotalSales': 'Total Sales ($)', 'EmployeeName': 'Employee Name'})
show_to_user(fig)
```","The input code and reference code differ in several significant areas: 1) The input code fetches the top 10 employees instead of 5, as specified in the reference code. 2) The input code concatenates first and last names into a single 'EmployeeName' field, while the reference code uses 'FirstName' separately. 3) The visualization in the input uses the concatenated name, affecting the x-axis, whereas the reference code uses 'FirstName'. These differences imply the logic diverges from the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to find top sales employees
sql_query = """"""
SELECT employees.EmployeeID, SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS EmployeeSales
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN employees ON orders.EmployeeID = employees.EmployeeID
WHERE orders.OrderDate BETWEEN '2022-07-06' AND '2023-07-06'
GROUP BY employees.EmployeeID
ORDER BY EmployeeSales DESC;
""""""

# Execute the SQL query
df_sales = execute_sql_query(sql_query)

# Create a bar chart with Plotly
fig = px.bar(df_sales, x='EmployeeID', y='EmployeeSales', title='Top Sales Employees in the Past Year')

# Display the bar chart
show_to_user(fig)
```","The input code does not fully adhere to the logic of the reference implementation. It misses filtering by employee names for the bar chart labeling and does not limit the results to the top 5 employees as specified. Additionally, the date filtering uses fixed dates instead of a dynamic one-year interval like in the reference implementation.",None
Which months have the highest on-time delivery rates? Provide a bar chart to visualize the monthly on-time delivery rates.,"
import plotly.express as px
import pandas as pd

# Define SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', ShippedDate) AS Month, 
       (COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(*)) AS OnTimeDeliveryRate 
FROM orders 
GROUP BY DATE_TRUNC('month', ShippedDate)
ORDER BY DATE_TRUNC('month', ShippedDate)
""""""

# Execute the SQL query to get a DataFrame
data = execute_sql_query(sql_query)

# Ensure the Month column is treated like a date for accurate plotting
data['Month'] = pd.to_datetime(data['Month'])

# Create a bar chart using Plotly
fig = px.bar(data, x='Month', y='OnTimeDeliveryRate', title='Monthly On-Time Delivery Rates')

# Display the bar chart
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 1.0 / COUNT(OrderID) AS OnTimeDeliveryRate
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month
""""""

monthly_on_time_delivery = execute_sql_query(sql_query)

fig = px.bar(monthly_on_time_delivery, x='Month', y='OnTimeDeliveryRate', 
             title='Monthly On-time Delivery Rates', 
             labels={'OnTimeDeliveryRate': 'On-time Delivery Rate', 'Month': 'Month'})

show_to_user(fig)
```","The input code correctly calculates the monthly on-time delivery rates using a similar SQL query to the reference implementation. Both queries count the number of on-time deliveries as a percentage of total deliveries grouped by month. Although the date formatting functions differ (DATE_TRUNC vs DATE_FORMAT), they achieve the same result of grouping by month. The transformation of the 'Month' field and the visualization using Plotly are effectively equivalent in both implementations.","
import pandas as pd
import plotly.express as px

# SQL query to fetch monthly on-time delivery rates
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       COUNT(CASE WHEN ShippedDate <= RequiredDate THEN 1 END) * 100.0 / COUNT(OrderID) AS OnTimeDeliveryRate
FROM orders
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m')
ORDER BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the SQL query and get the results as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the monthly on-time delivery rates
fig = px.bar(df, x='Month', y='OnTimeDeliveryRate', title='Monthly On-Time Delivery Rates',
             labels={'OnTimeDeliveryRate': 'On-Time Delivery Rate (%)'})

# Display the bar chart
show_to_user(fig)
","The input code uses DATE_FORMAT on OrderDate instead of DATE_TRUNC on ShippedDate, causing a misalignment in grouping and potential error in computing the on-time delivery rate. This affects the calculated results and does not follow the reference logic.",Base
What is the percentage of products that are discontinued? Please include a pie chart to visualize the proportion of discontinued products versus active products.,"```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT Discontinued, COUNT(*) as count
FROM products
GROUP BY Discontinued;
""""""

# Utility function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would typically execute the query against a database 
    # and return the results as a pandas DataFrame. 
    # Placeholder implementation (to be replaced with actual database connection logic)
    return pd.DataFrame({
        'Discontinued': [0, 1],
        'count': [80, 20]  # Placeholder data
    })

# Execute the SQL query and get the results
df = execute_sql_query(sql_query)

# Calculate the percentage of discontinued products
total_count = df['count'].sum()
df['percentage'] = (df['count'] / total_count) * 100

# Create a pie chart
fig = px.pie(df, names='Discontinued', values='percentage', 
             title='Proportion of Discontinued vs Active Products',
             labels={'0':'Active', '1':'Discontinued'})

# Display the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT Discontinued, COUNT(*) as Count FROM products GROUP BY Discontinued""
data = execute_sql_query(sql_query)

total_products = data['Count'].sum()
data['Percentage'] = (data['Count'] / total_products) * 100

fig = px.pie(data, names='Discontinued', values='Count', 
             title='Percentage of Discontinued Products vs Active Products',
             labels={'Discontinued': 'Discontinued (1) / Active (0)'})

show_to_user(fig)
```","The input code is incorrect because it uses 'values' as 'Count' instead of 'Percentage' for the pie chart, which should represent the actual percentage values for visual accuracy.","```python
import pandas as pd
import plotly.express as px

# Assume the utility functions are already provided in the environment
def main():
    # Define the SQL query to fetch necessary details
    sql_query = """"""
    SELECT 
        ProductID, 
        CASE 
            WHEN Discontinued = 1 THEN 'Discontinued' 
            ELSE 'Active' 
        END AS ProductStatus 
    FROM products
    """"""
    
    # Execute the function to fetch data from the database
    products_df = execute_sql_query(sql_query)

    # Calculate the percentage of discontinued products
    total_products = len(products_df)
    discontinued_count = sum(products_df['ProductStatus'] == 'Discontinued')
    discontinued_percentage = (discontinued_count / total_products) * 100

    # Define the data for the pie chart visualization
    pie_data = (
        products_df['ProductStatus'].value_counts()
        .reset_index()
        .rename(columns={'index': 'ProductStatus', 'ProductStatus': 'count'})
    )
    
    # Create a pie chart using Plotly
    fig = px.pie(
        pie_data, 
        names='ProductStatus',
        values='count',
        title='Proportion of Discontinued vs. Active Products'
    )

    # Display the pie chart using the provided utility function
    show_to_user(fig)

# Run the main function to execute the analysis and visualization
main()
```","The provided input code and the reference code both address the business analytics request by calculating the percentage of discontinued products and visualizing the proportion of discontinued vs. active products using a pie chart. The input implementation differs from the reference in specific details, such as the SQL query's structure and data processing steps, but it adheres to the same logic. The input code correctly calculates the percentage of discontinued products and generates a pie chart, fulfilling the requirements of the task.",Finetuned
"How does the quantity ordered vary by product, and can we visualize this variation using a bar chart?","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch average quantity by product
sql_query = """"""
SELECT ProductID, AVG(Quantity) AS AvgQuantity 
FROM [Order Details] 
GROUP BY ProductID;
""""""

# Execute the SQL query using the provided utility function
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function would interact with the database
    # For the purpose of this example, assume it returns a DataFrame
    # with columns 'ProductID' and 'AvgQuantity'
    return pd.DataFrame({
        'ProductID': [1, 2, 3],  # Example product IDs
        'AvgQuantity': [15.5, 25.3, 10.9]  # Example average quantities
    })

# Function to show data or visualization to the user
def show_to_user(data):
    # This function could display dataframes in a formatted way,
    # or show Plotly figures
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Fetch the data using the execute_sql_query function
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='ProductID', y='AvgQuantity', 
             title='Average Quantity Ordered by Product',
             labels={'ProductID': 'Product ID', 'AvgQuantity': 'Average Quantity'})

# Show the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    od.ProductID,
    SUM(od.Quantity) AS TotalQuantity
FROM 
    [Order Details] od
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    od.ProductID
ORDER BY 
    TotalQuantity DESC
""""""

data = execute_sql_query(sql_query)

fig = px.bar(data, x='ProductID', y='TotalQuantity', title='Quantity Ordered by Product')
show_to_user(fig)
```","The input code calculates the total quantity ordered per product, while the reference implementation calculates the average quantity ordered per product. These calculations answer different business questions. Additionally, the input code includes a join to the 'orders' table, which is unnecessary for this task as per the reference logic.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ProductID, SUM(Quantity) AS TotalQuantityOrdered
FROM [Order Details]
GROUP BY ProductID;
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the variation of quantity ordered by product
fig = px.bar(order_data, x='ProductID', y='TotalQuantityOrdered', 
             title='Total Quantity Ordered by Product', 
             labels={'TotalQuantityOrdered': 'Total Quantity Ordered', 'ProductID': 'Product ID'})

# Show the visualization to the user
show_to_user(fig)
```","The input code calculates the total quantity ordered for each product, while the reference code calculates the average quantity ordered. These are different metrics and do not answer the same business analytics request.",None
What is the average freight cost by shipping method? Include a bar chart comparing the average costs for each method.,"import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to get the average freight cost by shipping method
sql_query = """"""
SELECT ShipVia, AVG(Freight) AS AverageFreightCost 
FROM orders 
GROUP BY ShipVia;
""""""

# Assuming execute_sql_query is a predefined utility function
average_freight_cost_df = execute_sql_query(sql_query)

# Step 2: Create a bar chart comparing the average freight costs for each shipping method
fig = px.bar(
    average_freight_cost_df, 
    x='ShipVia', 
    y='AverageFreightCost', 
    title='Average Freight Cost by Shipping Method',
    labels={'ShipVia': 'Shipping Method', 'AverageFreightCost': 'Average Freight Cost'},
    color='ShipVia'  # Optional: Add color for clarity
)

# Step 3: Show the result to the user
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ShipVia, AVG(Freight) AS AverageFreight
FROM orders
GROUP BY ShipVia
""""""

average_freight_by_method = execute_sql_query(sql_query)

fig = px.bar(average_freight_by_method, x='ShipVia', y='AverageFreight', 
             title='Average Freight Cost by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'AverageFreight': 'Average Freight Cost'})

show_to_user(fig)
```","The input Python code correctly follows the logic and steps of the reference implementation. It executes the SQL query to compute the average freight cost grouped by shipping method and generates a bar chart using Plotly Express. The minor difference in column naming ('AverageFreight' instead of 'AverageFreightCost') does not affect the correctness, as it still aligns with the logic and purpose of the reference code.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the average freight cost by shipping method
sql_query = ""SELECT ShipVia, AVG(Freight) AS avg_freight FROM orders GROUP BY ShipVia;""

# Utility function to execute SQL query and return data as DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function simulates the execution of an SQL query and returns a DataFrame.
    # In a real scenario, this would involve connecting to a database.
    # Here we simulate the returned data.
    data = {
        'ShipVia': [1, 2, 3],
        'avg_freight': [15.25, 20.30, 18.50]
    }
    return pd.DataFrame(data)

# Function to show data to the user
def show_to_user(data):
    # Here we would display the data to the user.
    # This might involve printing or, if it is a DataFrame,
    # displaying it in a more GUI-like environment.
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Execute the query to get the data in a DataFrame
freight_data = execute_sql_query(sql_query)

# Create a bar chart comparing average freight costs for each shipping method
fig = px.bar(freight_data, x='ShipVia', y='avg_freight', title='Average Freight Cost by Shipping Method',
             labels={'ShipVia': 'Shipping Method', 'avg_freight': 'Average Cost'})

# Show the bar chart to the user
show_to_user(fig)
```","The input Python code correctly follows the logic of the reference implementation. It executes a SQL query to retrieve the average freight cost by shipping method, creates a bar chart with similar configurations (labels, title), and displays the result. The difference in variable names (e.g., 'avg_freight' vs. 'AverageFreightCost') does not affect the correctness as the logic remains consistent with the business analytics request and reference code.",both
In which month did we have the highest total sales? Please include a bar chart to visualize the monthly sales data.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve monthly sales
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS OrderMonth,
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM orders o
JOIN `Order Details` od ON o.OrderID = od.OrderID
GROUP BY OrderMonth
ORDER BY OrderMonth;
""""""

# Execute the SQL query and load the results into a pandas DataFrame
sales_data = execute_sql_query(sql_query)

# Generate a bar chart to visualize the monthly sales
fig = px.bar(sales_data, x='OrderMonth', y='TotalSales', 
             title='Monthly Total Sales', labels={'OrderMonth':'Month', 'TotalSales':'Total Sales ($)'})

# Display the chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(orders.OrderDate, '%Y-%m') AS Month,
    SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales
FROM 
    orders
JOIN 
    [Order Details] ON orders.OrderID = [Order Details].OrderID
GROUP BY 
    Month
ORDER BY 
    TotalSales DESC
""""""

monthly_sales = execute_sql_query(sql_query)

highest_sales_month = monthly_sales.iloc[0]

fig = px.bar(monthly_sales, x='Month', y='TotalSales', title='Monthly Sales Data')
show_to_user(fig)

highest_sales_month
```","The input code orders by 'TotalSales DESC', showing the month with the highest sales first, but it disrupts the monthly order view which the reference sorts by 'OrderMonth'. It gives correct total sales for the highest month but doesn't maintain a chronological order view. This will impact the bar chart's x-axis order, which should be chronological as per the reference. The request implies monthly trends should be visible.","```python
import pandas as pd
import plotly.express as px

def get_monthly_sales_data():
    # SQL query to get monthly sales data
    sql_query = """"""
    SELECT 
        EXTRACT(MONTH FROM orders.OrderDate) AS Month, 
        SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS TotalSales 
    FROM 
        orders 
    JOIN 
        [Order Details] 
    ON 
        orders.OrderID = [Order Details].OrderID 
    GROUP BY 
        EXTRACT(MONTH FROM orders.OrderDate) 
    ORDER BY 
        Month
    """"""
    return execute_sql_query(sql_query)

def create_sales_bar_chart(monthly_sales_df):
    # Create a bar chart using Plotly
    fig = px.bar(monthly_sales_df, x='Month', y='TotalSales', title='Monthly Sales Data', labels={'x': 'Month', 'y': 'Total Sales'})
    return fig

def main():
    # Get monthly sales data
    monthly_sales_df = get_monthly_sales_data()
    
    # Create bar chart to visualize the monthly sales data
    sales_bar_chart = create_sales_bar_chart(monthly_sales_df)
    
    # Final visualization - Show the chart
    show_to_user(sales_bar_chart)

main()
```","The input code extracts only the month from the OrderDate, ignoring the year, which can lead to incorrect results if there are multiple years in the data. It should extract the year and month to ensure correct grouping. Additionally, it uses different SQL syntax for accessing table fields. The reference code uses DATE_FORMAT to concatenate year and month, ensuring unique monthly periods across years.",None
Which supplier provides products with the lowest average unit price? Include a bar chart to compare the average unit prices among the top suppliers.,"```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT s.CompanyName, AVG(p.UnitPrice) AS AvgUnitPrice
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.CompanyName
ORDER BY AvgUnitPrice ASC;
""""""

# Execute the SQL query and retrieve a DataFrame
df = execute_sql_query(sql_query)

# Identify the supplier with the lowest average unit price
lowest_avg_price_supplier = df.iloc[0]

# Display the supplier with the lowest average unit price
show_to_user(lowest_avg_price_supplier.to_frame().T)

# Create a bar chart comparing average unit prices among all suppliers
fig = px.bar(df, x='CompanyName', y='AvgUnitPrice', title='Average Unit Price by Supplier')

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to find average unit price per supplier
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, AVG(p.UnitPrice) AS AverageUnitPrice
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY AverageUnitPrice
""""""

# Execute the SQL query
supplier_avg_prices = execute_sql_query(sql_query)

# Identify the supplier with the lowest average unit price
lowest_supplier = supplier_avg_prices.iloc[0]

# Create a bar chart to compare average unit prices among top suppliers
top_suppliers = supplier_avg_prices.head(10)
fig = px.bar(top_suppliers, x='CompanyName', y='AverageUnitPrice', 
             title='Average Unit Prices of Top Suppliers',
             labels={'AverageUnitPrice': 'Average Unit Price', 'CompanyName': 'Supplier'},
             text='AverageUnitPrice')

# Show the results to the user
show_to_user(lowest_supplier)
show_to_user(fig)
```","The input Python code follows the same logic as the reference code. It executes a SQL query to calculate the average unit price per supplier, identifies the supplier with the lowest average unit price, and generates a bar chart. The minor differences, such as selecting the top 10 suppliers for the chart, do not affect the correctness regarding the business request.","```python
import plotly.express as px
import pandas as pd

# SQL query to fetch average unit prices for each supplier
sql_query = '''
    SELECT suppliers.CompanyName, AVG(products.UnitPrice) AS AverageUnitPrice
    FROM suppliers
    JOIN products ON suppliers.SupplierID = products.SupplierID
    GROUP BY suppliers.CompanyName
    ORDER BY AverageUnitPrice ASC
    LIMIT 10;
'''

# Execute the SQL query using the utility function
df = execute_sql_query(sql_query)

# Display the supplier with the lowest average unit price
show_to_user(df)

# Create a bar chart to compare the average unit prices among the top suppliers using Plotly
fig = px.bar(df, x='CompanyName', y='AverageUnitPrice',
             title='Top Suppliers by Average Unit Price',
             labels={'CompanyName': 'Supplier', 'AverageUnitPrice': 'Average Unit Price'})

# Show the bar chart using the utility function
show_to_user(fig)
```","The input code applies a LIMIT 10 clause, which restricts the result to only the top 10 suppliers with the lowest average unit prices. This isn't equivalent to the reference code, which considers all suppliers to determine the lowest average unit price and create a complete comparison bar chart.",Base
"In which month was the average order fulfillment time the shortest, and can you provide a bar chart to visualize the results?","```python
import pandas as pd
import plotly.express as px

# SQL query to find the average order fulfillment time by month
sql_query = """"""
    SELECT Month, AVG(FulfillmentTime) AS AvgFulfillmentTime 
    FROM (
        SELECT DATEDIFF(ShippedDate, OrderDate) AS FulfillmentTime, 
               DATE_FORMAT(OrderDate, '%Y-%m') AS Month 
        FROM orders
    ) AS MonthlyFulfillment 
    GROUP BY Month 
    ORDER BY AvgFulfillmentTime ASC;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Identify the month with the shortest average fulfillment time
shortest_avg_fulfillment_month = df.iloc[0]

# Visualize the results with a bar chart
fig = px.bar(df, x='Month', y='AvgFulfillmentTime', 
             title='Average Order Fulfillment Time by Month',
             labels={'AvgFulfillmentTime': 'Average Fulfillment Time (days)'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS Average_Fulfillment_Time
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Average_Fulfillment_Time;
""""""

fulfillment_data = execute_sql_query(sql_query)

shortest_month = fulfillment_data.loc[fulfillment_data['Average_Fulfillment_Time'].idxmin()]

fig = px.bar(fulfillment_data, x='Month', y='Average_Fulfillment_Time', 
             title='Average Order Fulfillment Time by Month', 
             labels={'Average_Fulfillment_Time': 'Average Fulfillment Time (Days)', 'Month': 'Month'})
show_to_user(fig)

shortest_month
```","The input Python code correctly implements the business analytics request. It retrieves the average order fulfillment times by month, using SQL to calculate the difference between the ShippedDate and OrderDate, and averages these differences. Both the input and reference codes group by and order the results by average fulfillment time, identifying the month with the shortest time. The input code correctly visualizes the results with a bar chart and identifies the shortest average fulfillment month using idxmin. The logic and end results align with the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to get the monthly average order fulfillment time
sql_query = """"""
SELECT 
    TO_CHAR(OrderDate, 'YYYY-MM') AS Month, 
    AVG(CAST(ShippedDate AS DATE) - CAST(OrderDate AS DATE)) AS AvgFulfillmentTime 
FROM orders 
GROUP BY TO_CHAR(OrderDate, 'YYYY-MM') 
ORDER BY Month;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the average fulfillment time per month
fig = px.bar(df, x='Month', y='AvgFulfillmentTime',
             title='Average Order Fulfillment Time per Month',
             labels={'AvgFulfillmentTime': 'Avg Fulfillment Time (Days)', 'Month': 'Month'},
             text='AvgFulfillmentTime')

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly calculates the average fulfillment time per month and visualizes it with a bar chart. However, it does not identify the month with the shortest average fulfillment time; it only creates the bar chart and orders by month, not by AvgFulfillmentTime. The reference code orders by AvgFulfillmentTime and explicitly identifies the month with the shortest time.",Base
"What is the average time taken to fulfill an order each month, and can it be visualized using a line chart to show trends over time?","
```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve average fulfillment time by month
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month,
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY Month
ORDER BY Month;
""""""

# Assuming execute_sql_query is a predefined function
# Execute the query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Convert the 'Month' column to datetime
if df['Month'].dtype == object:  # Checking if conversion is necessary
    df['Month'] = pd.to_datetime(df['Month'])

# Plot a line chart to visualize the average fulfillment time by month
fig = px.line(df, x='Month', y='AvgFulfillmentTime', title='Average Order Fulfillment Time by Month')

# Assuming show_to_user is a predefined function
# Display the plot using show_to_user
show_to_user(fig)
```
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
       AVG(DATEDIFF(ShippedDate, OrderDate)) AS AverageFulfillmentTime
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

fulfillment_data = execute_sql_query(sql_query)

fig = px.line(fulfillment_data, x='Month', y='AverageFulfillmentTime', 
              title='Average Order Fulfillment Time per Month', 
              labels={'AverageFulfillmentTime': 'Average Fulfillment Time (days)', 
                      'Month': 'Month'})
show_to_user(fig)
```","The input Python code does not correctly handle incomplete shipments because it does not filter out rows where ShippedDate is NULL. This can lead to incorrect average calculations. The reference code properly excludes such cases, ensuring correctness. Additionally, the SQL functions for date formatting differ, but this does not impact correctness directly.","```python
import pandas as pd
import plotly.express as px

# SQL query to extract data
sql_query = """"""
SELECT 
    DATE_TRUNC('MONTH', OrderDate) AS Month, 
    AVG(DATEDIFF(ShippedDate, OrderDate)) AS AvgFulfillmentTime 
FROM 
    orders 
GROUP BY 
    Month;
""""""

# Execute the SQL query and retrieve the data
orders_df = execute_sql_query(sql_query)

# Convert Month to datetime for accurate plotting
orders_df['Month'] = pd.to_datetime(orders_df['Month'])

# Create a line chart to visualize average fulfillment time per month
fig = px.line(orders_df, x='Month', y='AvgFulfillmentTime',
              title='Average Order Fulfillment Time by Month',
              labels={'Month': 'Month', 'AvgFulfillmentTime': 'Avg Fulfillment Time (Days)'})

# Show the line chart to the user
show_to_user(fig)
```","The provided code does not include a condition to exclude rows where 'ShippedDate' is NULL. This may cause the average calculation to include incomplete orders, differing from the reference implementation.",None
Identify the top 3 products with the highest sales revenue per unit and present these findings using a bar chart.,"```python
import plotly.express as px

# SQL Query as provided in the task
sql_query = """"""
SELECT p.ProductName, 
       SUM(od.Quantity * od.UnitPrice) / SUM(od.Quantity) AS SalesRevenuePerUnit 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY p.ProductName 
ORDER BY SalesRevenuePerUnit DESC 
LIMIT 3;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Generate a bar chart using Plotly
fig = px.bar(df, 
             x='ProductName', 
             y='SalesRevenuePerUnit', 
             title='Top 3 Products by Sales Revenue per Unit', 
             labels={'SalesRevenuePerUnit':'Sales Revenue Per Unit', 'ProductName':'Product Name'})

# Show the plot using the utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity * od.UnitPrice) AS TotalRevenue,
    SUM(od.Quantity) AS TotalUnitsSold,
    (SUM(od.Quantity * od.UnitPrice) / NULLIF(SUM(od.Quantity), 0)) AS RevenuePerUnit
FROM 
    products p
JOIN 
    [Order Details] od ON p.ProductID = od.ProductID
GROUP BY 
    p.ProductID, p.ProductName
ORDER BY 
    RevenuePerUnit DESC
LIMIT 3
""""""

top_products = execute_sql_query(sql_query)

fig = px.bar(top_products, x='ProductName', y='RevenuePerUnit', 
              title='Top 3 Products by Sales Revenue Per Unit',
              labels={'RevenuePerUnit': 'Revenue Per Unit', 'ProductName': 'Product'})
show_to_user(fig)
```","The input Python code correctly executes a query to find the top 3 products with the highest sales revenue per unit. It uses a similar logic to the reference code by calculating the revenue per unit as the sum of revenue divided by the sum of quantity. The code then creates a bar chart using Plotly to display these products. Despite slight differences in approach, such as handling division by zero with NULLIF, the overall result and logic align with the reference implementation.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder implementation for demonstrative purposes
    pass

def show_to_user(data):
    # Placeholder implementation for demonstrative purposes
    pass

# SQL query to identify the top 3 products with the highest sales revenue per unit
sql_query = """"""
SELECT products.ProductName, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) / SUM([Order Details].Quantity) AS SalesRevenuePerUnit 
FROM [Order Details] 
JOIN products ON [Order Details].ProductID = products.ProductID 
GROUP BY products.ProductName 
ORDER BY SalesRevenuePerUnit DESC 
LIMIT 3;
""""""

# Execute SQL query and retrieve the results in a DataFrame
top_products_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the results
fig = px.bar(top_products_df, x='ProductName', y='SalesRevenuePerUnit', title='Top 3 Products by Sales Revenue per Unit')

# Display the bar chart to the user
show_to_user(fig)
```","The evaluated code correctly follows the logic of the reference implementation. It identifies the top 3 products with the highest sales revenue per unit. Both implementations compute 'SalesRevenuePerUnit' as the total sales divided by quantity, using SQL to perform the aggregation and sorting. Additionally, the evaluated code accommodates a discount, which might be more accurate if it's part of the business logic, but it still adheres to the core requirement. The code then visualizes the data using a bar chart with Plotly, matching the task's expected output.",both
How many orders have been placed by each customer? Include a bar chart to visualize the number of orders per customer.,"```python
import plotly.express as px
import pandas as pd

def analyze_customer_orders():
    # SQL Query as given in the request
    sql_query = ""SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders FROM orders GROUP BY CustomerID;""
    
    # Execute the SQL query to get data
    df = execute_sql_query(sql_query)
    
    # Create a bar chart using Plotly to visualize the number of orders per customer
    fig = px.bar(df, x='CustomerID', y='NumberOfOrders', title='Number of Orders per Customer')
    
    # Show the visualization to the user
    show_to_user(fig)

# Run the analysis function
analyze_customer_orders()
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of orders per customer
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
""""""

# Execute the SQL query
orders_per_customer = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per customer
fig = px.bar(orders_per_customer, x='CustomerID', y='OrderCount', title='Number of Orders per Customer', labels={'OrderCount': 'Number of Orders', 'CustomerID': 'Customer ID'})

# Display the visualization to the user
show_to_user(fig)
```","The input Python code correctly follows the logic of retrieving the number of orders placed by each customer and visualizes the data using a bar chart, just as the reference implementation does. Despite minor differences in naming (such as 'OrderCount' instead of 'NumberOfOrders'), the functionality and output remain consistent with the specified business analytics request.","```python
import plotly.express as px
import pandas as pd

# SQL query to get the number of orders each customer has placed
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY CustomerID;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders per customer
fig = px.bar(order_data, x='CustomerID', y='OrderCount', 
             title='Number of Orders Per Customer',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Order Count'})

# Display the bar chart using the show_to_user function
show_to_user(fig)
```","The input code's logic matches the reference implementation. Both codes execute an SQL query to count orders per customer and use Plotly to generate a bar chart displaying the results. While the column alias in the input is 'OrderCount' as opposed to 'NumberOfOrders', this does not affect the correctness of the solution.",both
"What is the total freight cost for shipped orders last month, and can we visualize the trend using a bar chart over the month?","import pandas as pd
import plotly.express as px

# Define the SQL query to get the total freight cost for shipped orders last month by day
sql_query = """"""
SELECT DAY(ShippedDate) AS Day, SUM(Freight) AS TotalFreight
FROM orders
WHERE MONTH(ShippedDate) = MONTH(CURRENT_DATE - INTERVAL 1 MONTH)
AND YEAR(ShippedDate) = YEAR(CURRENT_DATE - INTERVAL 1 MONTH)
GROUP BY DAY(ShippedDate);
""""""

# Execute the SQL query using the provided utility function
df_freight = execute_sql_query(sql_query)

# Create a bar chart to visualize total freight by day over last month
fig = px.bar(df_freight, x='Day', y='TotalFreight', title='Total Freight Cost by Day for Last Month')

# Show the visualization using the provided utility function
show_to_user(fig)","```python
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# Get the first and last date of last month
first_date_last_month = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1)
last_date_last_month = first_date_last_month + timedelta(days=31)
last_date_last_month = last_date_last_month.replace(day=1) - timedelta(days=1)

# SQL query to retrieve total freight cost and shipment dates
sql_query = f""""""
SELECT 
    DATE(ShippedDate) AS ShipDate, 
    SUM(Freight) AS TotalFreight
FROM 
    orders
WHERE 
    ShippedDate BETWEEN '{first_date_last_month.strftime('%Y-%m-%d')}' 
    AND '{last_date_last_month.strftime('%Y-%m-%d')}'
GROUP BY 
    ShipDate
ORDER BY 
    ShipDate
""""""

# Execute the SQL query and get the data
freight_data = execute_sql_query(sql_query)

# Calculate the total freight cost for shipped orders last month
total_freight_cost = freight_data['TotalFreight'].sum()

# Create a bar chart for the freight trends
fig = px.bar(freight_data, x='ShipDate', y='TotalFreight', title='Freight Cost Trend for Shipped Orders Last Month')
show_to_user(fig)

total_freight_cost
```","The input code correctly calculates the total freight cost for shipped orders last month and visualizes the trend using a bar chart. Both the reference and input codes query the total freight cost, grouping by day (or date), and visualize using a bar chart. The input code also computes the date range for the last month accurately. The approach and output align with the business analytics request and the reference code logic.","```python
import pandas as pd
import plotly.express as px

# Utility function to execute SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the actual SQL execution logic
    # Assuming it returns a pandas DataFrame
    pass

# SQL query to get daily freight costs for orders shipped last month
sql_query = """"""
SELECT DATE(OrderDate) as order_date, SUM(Freight) as total_freight
FROM orders
WHERE OrderDate >= DATE_TRUNC('MONTH', CURRENT_DATE - INTERVAL '1 MONTH') 
AND OrderDate < DATE_TRUNC('MONTH', CURRENT_DATE)
AND ShippedDate IS NOT NULL
GROUP BY order_date
ORDER BY order_date;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the trend using a bar chart
fig = px.bar(df, x='order_date', y='total_freight', 
             title='Daily Freight Cost for Shipped Orders - Last Month',
             labels={'order_date': 'Order Date', 'total_freight': 'Total Freight Cost'},
             template='plotly')

# Display the visualization
show_to_user(fig)
```","The input code is not correct. The SQL query in the input code selects from 'OrderDate' instead of 'ShippedDate', which is necessary to filter shipped orders for the last month. Additionally, the grouping is on 'OrderDate', not on the day of 'ShippedDate'. The logic should match the reference implementation by using 'ShippedDate' for filtering and grouping.",Base
"How many orders were shipped late every month, and can you provide a line chart to visualize the monthly trends?","```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve late orders data
sql_query = """"""
SELECT DATE_FORMAT(ShippedDate, '%Y-%m') AS Month, COUNT(OrderID) AS LateOrders 
FROM orders 
WHERE ShippedDate > RequiredDate 
GROUP BY Month;
""""""

# Execute the SQL query and get the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly trends of late orders
fig = px.line(orders_df, x='Month', y='LateOrders', title='Monthly Late Orders Trend', labels={'LateOrders': 'Number of Late Orders', 'Month': 'Month'})

# Display the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS LateShipments
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

late_shipments_df = execute_sql_query(sql_query)

fig = px.line(late_shipments_df, x='Month', y='LateShipments', title='Monthly Late Shipments', 
              labels={'LateShipments': 'Number of Late Shipments', 'Month': 'Month'})
show_to_user(fig)
```","The input Python code accurately follows the logic of the reference implementation. It selects orders where 'ShippedDate' is later than 'RequiredDate', formats the date to a monthly format, counts the 'OrderID' as 'LateShipments', and groups and orders the data by month. The line chart plotted using Plotly correctly visualizes the monthly trends of late shipments, similar to the reference code. The use of 'OrderDate' instead of 'ShippedDate' in the SQL query's date formatting does not affect the logic related to counting the late shipments.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # Placeholder for function that executes the SQL query and returns a DataFrame
    pass

def show_to_user(data):
    # Placeholder for function to display data or visualization
    pass

# SQL Query
sql_query = """"""
SELECT DATE_FORMAT(ShippedDate, '%Y-%m') AS Month, 
COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) AS LateOrders 
FROM orders 
GROUP BY Month;
""""""

# Execute SQL Query and get the data
orders_df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(orders_df, x='Month', y='LateOrders', title='Monthly Late Orders Trend')

# Display the line chart
show_to_user(fig)
```","The provided code calculates the number of late orders per month and creates a line chart to visualize the trends, consistent with the logic of the reference implementation. It only slightly differs in using COUNT with a CASE WHEN clause, which effectively achieves the same counting of late orders. The visualization and purpose align correctly with the business request.",both
What is the distribution of orders by shipping country? Include a bar chart to visualize the data.,"```python
import plotly.express as px

# SQL query to get the distribution of orders by shipping country
sql_query = """"""
SELECT ShipCountry, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY ShipCountry 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query and get the result as a pandas DataFrame
df_orders_by_country = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(
    df_orders_by_country, 
    x='ShipCountry', 
    y='OrderCount', 
    title='Distribution of Orders by Shipping Country',
    labels={'ShipCountry': 'Shipping Country', 'OrderCount': 'Number of Orders'}
)

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = ""SELECT ShipCountry, COUNT(OrderID) as OrderCount FROM orders GROUP BY ShipCountry""
orders_by_country_df = execute_sql_query(sql_query)

fig = px.bar(orders_by_country_df, x='ShipCountry', y='OrderCount', title='Distribution of Orders by Shipping Country', labels={'OrderCount': 'Number of Orders', 'ShipCountry': 'Shipping Country'})
show_to_user(fig)
```","The input Python code correctly follows the business analytics request by querying the distribution of orders by shipping country and creating a bar chart to visualize it. The logic of the code aligns with the reference implementation, executing a SQL query to count the orders per shipping country, and using Plotly Express to create and display a bar chart. Although the input code does not include an ORDER BY clause, the main requirement of generating the distribution and visualization is fulfilled adequately.","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT ShipCountry, COUNT(*) AS OrderCount
FROM orders
GROUP BY ShipCountry
""""""

# Execute the SQL query
order_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of orders by shipping country
fig = px.bar(order_data, x='ShipCountry', y='OrderCount', title='Distribution of Orders by Shipping Country')

# Display the bar chart
show_to_user(fig)
```","The input code correctly answers the question by executing an SQL query to get the distribution of orders by shipping country and visualizes it using a bar chart with Plotly. Although the input code does not order the results by order count, this does not affect the distribution visualization, which is the primary focus of the request. Therefore, it adheres to the required logic.",both
How many orders were placed each month? Please include a line chart to visualize the monthly order trends.,"```python
import pandas as pd
import plotly.express as px

# Given utility functions
def execute_sql_query(sql_query: str):
    # Placeholder for SQL execution, returns a DataFrame
    pass

def show_to_user(data):
    # Display the data or figure
    pass

# SQL query to retrieve monthly order data
sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY DATE_FORMAT(OrderDate, '%Y-%m');
""""""

# Execute the query and store the result in a DataFrame
orders_df = execute_sql_query(sql_query)

# Create a line chart to visualize the monthly order trends
fig = px.line(orders_df, x='Month', y='OrderCount', title='Monthly Order Trends')

# Display the figure
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY Month
ORDER BY Month;
""""""

monthly_orders = execute_sql_query(sql_query)

fig = px.line(monthly_orders, x='Month', y='OrderCount', title='Monthly Orders Trend', labels={'OrderCount': 'Number of Orders', 'Month': 'Month'})
show_to_user(fig)
```","The input Python code correctly computes the number of orders placed each month by formatting the OrderDate to 'Year-Month', counting the OrderIDs, and grouping by the formatted date. It also creates a line chart using Plotly Express to visualize the monthly trend, similar to the reference implementation. The order of the SQL logic and the chart generation is consistent with the reference.","```python
import plotly.express as px
import pandas as pd

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulated function to execute SQL and return a DataFrame
    pass

def show_to_user(data):
    # Simulated function to display data or figure
    pass

# SQL query to fetch data
sql_query = ""SELECT DATE_TRUNC('month', OrderDate) AS Month, COUNT(OrderID) AS OrderCount FROM orders GROUP BY Month ORDER BY Month;""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Create a line chart using Plotly
fig = px.line(orders_df, x='Month', y='OrderCount', title='Monthly Orders Trend')

# Display the chart to the user
show_to_user(fig)
```","The input code and the reference code both answer the question of counting the number of orders placed each month and visualize it in a line chart. Even though the SQL syntax is slightly different, both queries achieve the same result of aggregating order counts by month. The visualization logic using Plotly is also consistent, plotting the same data fields (Month, OrderCount) to create a line chart. Therefore, the input code aligns with the business analytics request and the reference implementation.",both
"Which products have the highest unit price and are currently discontinued, and can this be illustrated with a bar chart?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = ""SELECT ProductName, UnitPrice FROM products WHERE Discontinued = 1 ORDER BY UnitPrice DESC LIMIT 5;""

# Execute the SQL query and get results in a DataFrame
data = execute_sql_query(sql_query)

# Visualization: Create a bar chart to illustrate the products with the highest unit price
fig = px.bar(data, x='ProductName', y='UnitPrice', title='Top 5 Discontinued Products by Unit Price')

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT ProductName, UnitPrice 
FROM products 
WHERE Discontinued = 1 
ORDER BY UnitPrice DESC
""""""

discontinued_products = execute_sql_query(sql_query)

fig = px.bar(discontinued_products, x='ProductName', y='UnitPrice', title='Discontinued Products with Highest Unit Price')
show_to_user(fig)
```","The input code does not limit the number of products displayed to 5, as the reference implementation does with 'LIMIT 5'. This means the input code could potentially include more products, which would not conform to the business analytics request.","```python
import plotly.express as px

# SQL query to get products with the highest unit price that are discontinued
sql_query = """"""
SELECT ProductName, UnitPrice
FROM products
WHERE Discontinued = 1
ORDER BY UnitPrice DESC;
""""""

# Execute the SQL query
products_df = execute_sql_query(sql_query)

# Visualize the results using a bar chart
fig = px.bar(products_df, x='ProductName', y='UnitPrice', 
             title='Discontinued Products with Highest Unit Price',
             labels={'ProductName': 'Product Name', 'UnitPrice': 'Unit Price'},
             height=400)

# Display the bar chart
show_to_user(fig)
```","The input code does not limit the number of products to 5, unlike the reference implementation which uses 'LIMIT 5' to return only the top 5 products by unit price. This discrepancy means the input code does not fully adhere to the specified business analytics request.",None
What percentage of products are currently on order? Include a pie chart to visualize the distribution.,"```python
import pandas as pd
import plotly.express as px

# SQL query to get the percentage of products on order
sql_query = """"""
SELECT COUNT(DISTINCT ProductID) * 100.0 / (SELECT COUNT(ProductID) FROM products) AS PercentageOnOrder
FROM [Order Details]
WHERE Quantity > 0;
""""""

# Function to execute the SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock execution with example result, replace with actual query execution
    data = {
        ""PercentageOnOrder"": [25.0]  # Example result
    }
    return pd.DataFrame(data)

# Execute the SQL query
df = execute_sql_query(sql_query)

# Data preparation for visualization
percentage_on_order = df['PercentageOnOrder'][0]
percentage_not_on_order = 100 - percentage_on_order

# Create a pie chart
fig = px.pie(
    names=['On Order', 'Not On Order'],
    values=[percentage_on_order, percentage_not_on_order],
    title='Percentage of Products on Order'
)

# Show the pie chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    COUNT(CASE WHEN UnitsOnOrder > 0 THEN 1 END) AS OnOrderCount,
    COUNT(*) AS TotalCount
FROM products
WHERE Discontinued = 0
""""""

data = execute_sql_query(sql_query)
on_order_percentage = (data['OnOrderCount'][0] / data['TotalCount'][0]) * 100

labels = ['On Order', 'Not On Order']
values = [data['OnOrderCount'][0], data['TotalCount'][0] - data['OnOrderCount'][0]]

fig = px.pie(values=values, names=labels, title=f'Products On Order: {on_order_percentage:.2f}%')
show_to_user(fig)
```","The reference implementation calculates the percentage of products on order from the 'Order Details' based on 'Quantity' and excludes discontinued products, while the input code calculates based on 'UnitsOnOrder' directly from the 'products' table. Hence, the logic differs significantly.","```python
import pandas as pd
import plotly.express as px

# Assume the existence of utility function to execute SQL and return a DataFrame
def execute_sql_query(sql_query: str):
    # This is a placeholder for actual SQL execution logic
    # It should return a pandas DataFrame
    pass

def show_to_user(data):
    # This is a placeholder for displaying data
    pass

# SQL Query to find the percentage of products currently on order
sql_query_percentage_on_order = """"""
SELECT (COUNT(Products.ProductID) / (SELECT COUNT(*) FROM Products)) * 100 AS PercentageOnOrder 
FROM Products 
WHERE UnitsOnOrder > 0;
""""""

# SQL Query to find the percentage of products currently not on order
sql_query_percentage_not_on_order = """"""
SELECT (COUNT(Products.ProductID) / (SELECT COUNT(*) FROM Products)) * 100 AS PercentageNotOnOrder 
FROM Products 
WHERE UnitsOnOrder = 0;
""""""

# Execute the SQL queries
percentage_on_order_df = execute_sql_query(sql_query_percentage_on_order)
percentage_not_on_order_df = execute_sql_query(sql_query_percentage_not_on_order)

# Data processing
percentage_on_order_value = percentage_on_order_df.iloc[0, 0]
percentage_not_on_order_value = percentage_not_on_order_df.iloc[0, 0]

# Create a DataFrame for the pie chart
pie_chart_data = pd.DataFrame({
    'Status': ['On Order', 'Not On Order'],
    'Percentage': [percentage_on_order_value, percentage_not_on_order_value]
})

# Create a pie chart using Plotly
fig = px.pie(pie_chart_data, names='Status', values='Percentage', title='Product Order Status Distribution')

# Show the pie chart to the user
show_to_user(fig)
```","The input code uses two separate SQL queries to compute the percentage of products on and not on order, which creates potential inconsistency if the database changes between queries. The reference code computes the percentage on order directly and assumes the remaining percentage is not on order, which is more efficient and logically consistent. Additionally, the reference code explicitly counts distinct ProductIDs, ensuring accuracy, whereas the input code doesn't include this aspect. Both codes produce a pie chart based on percentages, but due to the differences in logic, the input code may not be aligned with the reference implementation.",None
"Which orders have the highest discount applied, and provide a bar chart illustrating these discounts?","```python
import pandas as pd
import plotly.express as px

# SQL query to get the top 5 orders with the highest discounts
sql_query = ""SELECT OrderID, Discount FROM [Order Details] ORDER BY Discount DESC LIMIT 5""

# Execute the SQL query using the utility function and store the result in a DataFrame
discount_data = execute_sql_query(sql_query)

# Create a bar chart using Plotly to visualize the discounts
fig = px.bar(discount_data, x='OrderID', y='Discount', title='Top 5 Orders with Highest Discounts')

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT o.OrderID, SUM(od.Discount) AS TotalDiscount
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
GROUP BY o.OrderID
ORDER BY TotalDiscount DESC
LIMIT 10
""""""

discount_data = execute_sql_query(sql_query)

fig = px.bar(discount_data, x='OrderID', y='TotalDiscount', title='Top 10 Orders with Highest Discounts', labels={'TotalDiscount': 'Total Discount'})
show_to_user(fig)
```","The input code aims to find the top 10 orders with the highest total discounts by summing discounts per OrderID and then selecting the top 10, whereas the reference code just looks for the top 5 orders based on individual discounts. Thus, the logic is different, as one focuses on total discounted amount across potentially multiple items per order, and the other is based on individual discount values.","```python
import pandas as pd
import plotly.express as px

# SQL Query to get the OrderID and Maximum Discount
sql_query = """"""
SELECT OrderID, MAX(Discount) AS MaxDiscount
FROM [Order Details]
GROUP BY OrderID
ORDER BY MaxDiscount DESC;
""""""

# Execute the SQL query to get the data
df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the discounts
fig = px.bar(df, x='OrderID', y='MaxDiscount', title='Orders with Highest Discounts')

# Display the bar chart
show_to_user(fig)
```","The reference code selects the top 5 orders with the highest discounts using 'ORDER BY Discount DESC LIMIT 5', while the input code retrieves the maximum discount per order and orders these without limiting to the top 5. This diverges from the specified logic of extracting the top 5 orders with the highest applied discounts.",None
"Which supplier has the highest total sales revenue, and create a bar chart to visualize each supplier's total sales revenue?","
import plotly.express as px
import pandas as pd

# SQL query to retrieve total sales per supplier
sql_query = """"""
SELECT
    p.SupplierID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM
    products p
JOIN
    [Order Details] od ON p.ProductID = od.ProductID
JOIN
    orders o ON od.OrderID = o.OrderID
GROUP BY
    p.SupplierID
ORDER BY
    TotalSales DESC;
""""""

# Execute the SQL query
sales_data = execute_sql_query(sql_query)

# Check if the sales_data is not empty to avoid index errors
if not sales_data.empty:
    # Find the supplier with the highest total sales revenue
    top_supplier = sales_data.iloc[0]  # the first row after sorting will have the highest total sales
    print(f""Supplier with highest total sales revenue: SupplierID {top_supplier['SupplierID']} with revenue {top_supplier['TotalSales']}"")

# Create a bar chart using Plotly to visualize each supplier's total sales revenue
fig = px.bar(
    sales_data,
    x='SupplierID',
    y='TotalSales',
    title='Total Sales Revenue by Supplier',
    labels={'TotalSales': 'Total Sales Revenue', 'SupplierID': 'Supplier ID'}
)

# Display the figure
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
JOIN orders o ON od.OrderID = o.OrderID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalSales DESC
""""""

supplier_sales = execute_sql_query(sql_query)
highest_supplier = supplier_sales.iloc[0]

fig = px.bar(supplier_sales, x='CompanyName', y='TotalSales', title='Total Sales Revenue by Supplier')
show_to_user(fig)

highest_supplier
```","The provided code correctly identifies the supplier with the highest total sales revenue by executing a SQL query, which groups and orders the suppliers by their total sales. The code also generates a bar chart for visualizing each supplier's total sales revenue using Plotly. While the provided code includes additional company names for clarity in the bar chart, it still adheres to the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

# Given SQL query
sql_query = """"""
SELECT s.SupplierID, s.CompanyName, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalRevenue
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY s.SupplierID, s.CompanyName
ORDER BY TotalRevenue DESC;
""""""

# Utility function to execute SQL query and return a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder to imitate database operation
    # This function should connect to a database, execute the query and return the result as DataFrame
    pass  # Replace with actual implementation

# Execute the SQL query
df_revenue = execute_sql_query(sql_query)

# Find the supplier with the highest total revenue
highest_revenue_supplier = df_revenue.iloc[0:1]
show_to_user(highest_revenue_supplier)

# Create a bar chart for each supplier's total sales revenue
fig = px.bar(df_revenue, x='CompanyName', y='TotalRevenue', title='Total Sales Revenue by Supplier')

# Display the bar chart to the user
show_to_user(fig)
```","The input code adheres to the logic of the reference implementation. It retrieves total sales per supplier and creates a bar chart for visualization. Although it includes 'CompanyName' for better clarity in the bar chart, the core logic of finding and displaying the highest revenue supplier along with the bar chart remains consistent with the reference.",both
"Which suppliers provide the most products that are currently low in stock, and how can this be represented visually to highlight the distribution among suppliers?","```python
import pandas as pd
import plotly.express as px

# Function to execute SQL query and return the results as a pandas DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This is a placeholder for the actual implementation
    pass

# Function to display results
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# Define the SQL query
sql_query = """"""
SELECT suppliers.SupplierID, suppliers.SupplierName, COUNT(products.ProductID) AS LowStockProducts 
FROM suppliers 
INNER JOIN products ON suppliers.SupplierID = products.SupplierID 
WHERE products.UnitsInStock < products.ReorderLevel 
GROUP BY suppliers.SupplierID, suppliers.SupplierName;
""""""

# Execute the SQL query
df = execute_sql_query(sql_query)

# Visualize the distribution of low stock products among suppliers
fig = px.bar(df, x='SupplierName', y='LowStockProducts', 
             title='Distribution of Low Stock Products Among Suppliers',
             labels={'LowStockProducts': 'Number of Low Stock Products', 'SupplierName': 'Supplier'},
             color='LowStockProducts')
             
# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.SupplierID, COUNT(p.ProductID) AS LowStockCount
FROM products p
WHERE p.UnitsInStock < p.ReorderLevel AND p.Discontinued = 0
GROUP BY p.SupplierID
ORDER BY LowStockCount DESC
""""""

low_stock_suppliers = execute_sql_query(sql_query)

fig = px.bar(low_stock_suppliers, 
              x='SupplierID', 
              y='LowStockCount', 
              title='Number of Low Stock Products per Supplier',
              labels={'SupplierID': 'Supplier ID', 'LowStockCount': 'Low Stock Products Count'})

show_to_user(fig)
```","The input code does not fully align with the reference implementation. The SQL query in the input code lacks joining with the suppliers table, missing 'SupplierName' which is included in the reference SQL. This results in the visualization being plotted by 'SupplierID' instead of 'SupplierName', potentially making it less interpretable. Additionally, the input code includes a filter ('AND p.Discontinued = 0') which is not present in the reference, altering the query logic.","```python
import plotly.express as px
import pandas as pd

# Assuming necessary utility functions are already defined
# and imported: execute_sql_query, show_to_user

# Execute the SQL query to get the data
sql_query = """"""
SELECT s.SupplierID, COUNT(p.ProductID) AS LowStockCount
FROM suppliers s
JOIN products p ON s.SupplierID = p.SupplierID
WHERE p.UnitsInStock < p.ReorderLevel
GROUP BY s.SupplierID;
""""""

# Fetch the data into a pandas DataFrame
low_stock_data = execute_sql_query(sql_query)

# Check if data is returned
if not low_stock_data.empty:
    # Create a bar chart using Plotly to visualize distribution among suppliers
    fig = px.bar(low_stock_data, 
                 x='SupplierID', 
                 y='LowStockCount', 
                 title='Distribution of Low Stock Products Among Suppliers',
                 labels={'LowStockCount': 'Number of Low Stock Products', 'SupplierID': 'Supplier ID'},
                 template='plotly')

    # Display the visualization
    show_to_user(fig)
else:
    show_to_user(pd.DataFrame({'Message': ['No suppliers with low stock products found.']}))
```","The input code does not match the reference implementation's capabilities. The reference code retrieves and displays supplier names, whereas the input code only retrieves supplier IDs. This affects the clarity and usability of the resulting visualization since supplier IDs aren't as informative as names. Additionally, the input code includes a conditional check for empty DataFrames, which is a useful enhancement but not logically equivalent to the reference implementation.",None
"What is the total number of orders shipped each month, and can a line chart be provided to show trends over time?","```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to get the data
sql_query = """"""
SELECT DATE_FORMAT(ShippedDate, '%Y-%m') AS ShipMonth, 
       COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE ShippedDate IS NOT NULL 
GROUP BY ShipMonth;
""""""

# Assuming execute_sql_query is available as per the environment constraint
orders_data = execute_sql_query(sql_query)

# Step 2: Create a line chart using Plotly
fig = px.line(
    orders_data, 
    x='ShipMonth', 
    y='OrderCount', 
    title='Total Number of Orders Shipped Each Month',
    labels={'ShipMonth': 'Shipping Month', 'OrderCount': 'Number of Orders'},
    markers=True
)

# Step 3: Display the line chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT DATE_TRUNC('month', ShippedDate) AS month, COUNT(OrderID) AS total_orders
FROM orders
WHERE ShippedDate IS NOT NULL
GROUP BY month
ORDER BY month;
""""""

orders_monthly = execute_sql_query(sql_query)

fig = px.line(orders_monthly, x='month', y='total_orders', title='Total Orders Shipped Each Month', labels={'total_orders':'Total Orders', 'month':'Month'})
show_to_user(fig)
```","The input code correctly implements the requested analytics by selecting the count of orders shipped each month. Both implementations group by month and create a line chart. The input code uses 'DATE_TRUNC' while the reference uses 'DATE_FORMAT', which are equivalent functions in their respective SQL dialects. The use of Plotly for visualization is also consistent with the reference. Both implementations meet the business analytics request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT MONTH(OrderDate) AS Month, COUNT(OrderID) AS TotalOrders 
FROM orders 
GROUP BY MONTH(OrderDate)
""""""

# Execute the SQL query to fetch the data
orders_data = execute_sql_query(sql_query)

# Generate a line chart using Plotly to show trends over time
fig = px.line(
    orders_data, 
    x='Month', 
    y='TotalOrders', 
    title='Total Number of Orders Shipped Each Month',
    labels={'TotalOrders':'Total Orders', 'Month':'Month'}
)

# Display the line chart to the user
show_to_user(fig)
```","The input code is incorrect because it aggregates orders based on the 'OrderDate' column instead of 'ShippedDate'. The business request specifies calculating the total number of orders shipped each month, and the reference code uses 'ShippedDate' to do so. Additionally, the grouping is different: the reference code groups by 'ShipMonth' formatted as '%Y-%m', while the input code groups by 'MONTH(OrderDate)', which does not align with the reference or the request.",Base
Find the top three customers by the number of orders placed and create a bar chart to visualize the results.,"```python
import plotly.express as px
import pandas as pd

# SQL query to find the top three customers by the number of orders placed
sql_query = """"""
SELECT CustomerID, COUNT(*) AS OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 3;
""""""

# Execute the SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart using Plotly
fig = px.bar(df, x='CustomerID', y='OrderCount', title='Top 3 Customers by Order Count')

# Display the result to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 3
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CustomerID', y='OrderCount', title='Top 3 Customers by Number of Orders Placed')
show_to_user(fig)
```","The input Python code correctly follows the business analytics request. It executes an SQL query to find the top three customers by the number of orders placed, groups and orders the results properly, and limits the output to three customers. It then creates a bar chart using Plotly to visualize the results, similar to the reference implementation. The logic and outcome match the requirements, making it correct.","```python
import plotly.express as px
import pandas as pd

# Function to execute the given SQL query
def execute_sql_query(sql_query: str):
    # Simulated database query execution
    # In practice, this would interface with a database
    # For illustration, a mocked dataframe is returned
    data = {
        'CustomerID': ['C001', 'C002', 'C003'],
        'NumberOfOrders': [10, 8, 6]
    }
    return pd.DataFrame(data)

# Visualize the data using a bar chart
def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(""Displaying DataFrame:"")
        print(data)
    elif isinstance(data, px.Figure):
        print(""Displaying Plotly Figure:"")
        print(data)

# SQL query to get the top three customers by the number of orders
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders
FROM orders
GROUP BY CustomerID
ORDER BY NumberOfOrders DESC
LIMIT 3;
""""""

# Execute SQL query and retrieve the results in a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the top three customers and their order counts
fig = px.bar(df, x='CustomerID', y='NumberOfOrders', 
             title='Top 3 Customers by Number of Orders', 
             labels={'CustomerID': 'Customer ID', 'NumberOfOrders': 'Number of Orders'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code correctly executes the SQL query to retrieve the top three customers by the number of orders, similar to the reference code. It calculates the count of orders, groups by 'CustomerID', orders them in descending order, and limits the result to three records. The data is then visualized using a bar chart with Plotly, matching the required logic. The difference in the column name 'NumberOfOrders' vs. 'OrderCount' is only a naming convention and does not affect correctness. The function 'execute_sql_query' also simulates correct database interaction.",both
Determine the monthly product performance based on sales and include a graph to visualize the trends.,"```python
import pandas as pd
import plotly.express as px

# SQL query to retrieve the necessary data for analysis
sql_query = """"""
SELECT products.ProductID, DATE_TRUNC('month', orders.OrderDate) AS Month,
       SUM([Order Details].Quantity) AS TotalQuantity
FROM products
JOIN [Order Details] ON products.ProductID = [Order Details].ProductID
JOIN orders ON [Order Details].OrderID = orders.OrderID
GROUP BY products.ProductID, DATE_TRUNC('month', orders.OrderDate)
ORDER BY Month, products.ProductID;
""""""

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# Ensure the 'Month' column is of datetime type for proper plotting
data['Month'] = pd.to_datetime(data['Month'])

# Create a line plot to visualize monthly product performance
fig = px.line(data, x='Month', y='TotalQuantity', color='ProductID',
              title='Monthly Product Performance',
              labels={'TotalQuantity': 'Total Quantity Sold', 'Month': 'Month'})

# Show the visualization to the user using the provided utility function
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate monthly product sales performance
sql_query = """"""
SELECT 
    DATE_FORMAT(o.OrderDate, '%Y-%m') AS Month,
    p.ProductID,
    p.ProductName,
    SUM(od.Quantity) AS TotalSales,
    SUM(od.Quantity * od.UnitPrice) AS TotalRevenue
FROM
    [Order Details] od
JOIN 
    products p ON od.ProductID = p.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
GROUP BY 
    Month, p.ProductID, p.ProductName
ORDER BY 
    Month, TotalSales DESC
""""""

# Execute the SQL query
monthly_performance_df = execute_sql_query(sql_query)

# Create a line graph for visualizing monthly product performance
fig = px.line(monthly_performance_df, 
              x='Month', 
              y='TotalSales', 
              color='ProductName',
              title='Monthly Product Sales Performance',
              labels={'TotalSales': 'Sales Quantity', 'Month': 'Month'})
              
# Show the result to the user
show_to_user(fig)
```","The input code has a different SQL query structure and output. It calculates both TotalSales and TotalRevenue, ordering results by TotalSales, whereas the reference code groups by ProductID and Month, ordering by Month and ProductID. The input code uses `DATE_FORMAT` instead of `DATE_TRUNC`, and colors the plot by `ProductName` rather than `ProductID`. Also, the input query includes `ProductName` in the grouping which changes the data interpretation.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT p.ProductName, 
       MONTH(o.OrderDate) AS Month, 
       SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS MonthlyPerformance 
FROM `Order Details` od 
JOIN products p ON od.ProductID = p.ProductID 
JOIN orders o ON od.OrderID = o.OrderID 
GROUP BY p.ProductName, MONTH(o.OrderDate) 
ORDER BY p.ProductName, MONTH(o.OrderDate);
""""""

# Execute the SQL query using the provided utility function
data = execute_sql_query(sql_query)

# Convert the 'Month' column to a string for better concatenation in plotting
data['Month'] = data['Month'].astype(str)

# Create a line graph to visualize the trends
fig = px.line(data, x='Month', y='MonthlyPerformance', color='ProductName',
              title='Monthly Product Performance',
              labels={'MonthlyPerformance': 'Performance', 'Month': 'Month'})

# Show the graph to the user
show_to_user(fig)
```","The query in the input code calculates a different metric (sales revenue considering discounts) rather than the requested product quantity. The 'Month' calculation is also different between the codes ('DATE_TRUNC' used in the reference vs 'MONTH' function in input), potentially leading to discrepancies in month formatting. Furthermore, the input plots by 'ProductName' and orders by it, differing from the reference's 'ProductID'. These deviations affect the analysis alignment with the initial request.",None
How many orders have not yet been shipped? Can the orders be represented on a timeline to visualize delays?,"```python
import pandas as pd
import plotly.express as px

# Step 1: Execute the SQL query to get the count of unshipped orders
sql_query_unshipped = ""SELECT COUNT(OrderID) AS UnshippedOrders FROM orders WHERE ShippedDate IS NULL""
unshipped_orders_df = execute_sql_query(sql_query_unshipped)

# Show the unshipped orders count to the user
show_to_user(unshipped_orders_df)

# Step 2: Execute an SQL query to get the orders with their shipping status and order dates
sql_query_timeline = """"""
SELECT OrderID, OrderDate, ShippedDate
FROM orders
WHERE ShippedDate IS NULL
""""""
orders_timeline_df = execute_sql_query(sql_query_timeline)

# Creating a new column for visualization purposes
orders_timeline_df['OrderStatus'] = orders_timeline_df['ShippedDate'].apply(lambda x: 'Unshipped' if pd.isnull(x) else 'Shipped')

# Step 3: Create a timeline visualization using Plotly
fig = px.line(
    orders_timeline_df, 
    x='OrderDate', 
    y='OrderID', 
    color='OrderStatus',
    title='Timeline of Unshipped Orders',
    labels={'OrderDate': 'Order Date', 'OrderID': 'Order ID', 'OrderStatus': 'Order Status'},
    markers=True
)

# Display the timeline to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    OrderID, 
    OrderDate, 
    RequiredDate, 
    ShippedDate 
FROM 
    orders 
WHERE 
    ShippedDate IS NULL
""""""

unshipped_orders = execute_sql_query(sql_query)

unshipped_count = unshipped_orders.shape[0]

timeline_df = unshipped_orders[['OrderDate', 'RequiredDate']]
timeline_df['Status'] = 'Pending'
timeline_df = pd.melt(timeline_df, id_vars=['Status'], value_vars=['OrderDate', 'RequiredDate'], var_name='DateType', value_name='Date')

fig = px.line(timeline_df, x='Date', y='Status', color='DateType', title='Timeline of Unshipped Orders', markers=True)
show_to_user(fig)

print(f""Number of orders that have not yet been shipped: {unshipped_count}"")
```","The input code retrieves all orders with NULL ShippedDate, which aligns with identifying unshipped orders. However, it counts them using `shape[0]` and prints the count, which is technically correct for determining the number of unshipped orders. The main issue lies in the timeline visualization. The input code uses both 'OrderDate' and 'RequiredDate' for plotting, which differs from the reference code that uses 'OrderDate' and creates a distinction based on 'ShippedDate' (by color-coding with 'OrderStatus'). This results in a different visualization logic where the status of the orders is not differentiated in the same manner as the reference code. Thus, the timeline does not reflect delays in the same way, making the approach incorrect in terms of visualization.","```python
import pandas as pd
import plotly.express as px

# SQL Query to fetch orders that are not yet shipped
sql_query = """"""
SELECT OrderID, OrderDate FROM orders WHERE ShippedDate IS NULL;
""""""

# Execute SQL query to get the data
orders_df = execute_sql_query(sql_query)

# Count the number of unshipped orders
unshipped_orders_count = len(orders_df)
show_to_user(pd.DataFrame({'UnshippedOrders': [unshipped_orders_count]}))

# Ensure there's a 'Date' column for plotting
orders_df['OrderDate'] = pd.to_datetime(orders_df['OrderDate'])

# Creating a timeline visualization to show unshipped orders
fig = px.timeline(
    orders_df,
    x_start='OrderDate',
    x_end='OrderDate',
    y='OrderID',
    title='Unshipped Orders Timeline',
    labels={'OrderID': 'Order ID', 'OrderDate': 'Order Date'}
)

# Display the timeline visualization
show_to_user(fig)
```","The input code correctly retrieves and counts the unshipped orders but uses 'px.timeline', which is not a valid Plotly function. Instead, it should be using 'px.line' or another suitable Plotly function to represent the data on a timeline similar to the reference implementation. Additionally, it attempts to create a timeline with 'x_start' and 'x_end' as the same date, which does not properly visualize delays. The missing 'OrderStatus' column also indicates a departure from the expected logic in the reference.",None
"What is the most popular product category based on the number of unique customers, and can you provide a bar chart to visualize the results?","```python
import pandas as pd
import plotly.express as px

# SQL Query
sql_query = """"""
SELECT categories.CategoryName, COUNT(DISTINCT orders.CustomerID) AS unique_customers
FROM [Order Details]
JOIN orders ON [Order Details].OrderID = orders.OrderID
JOIN products ON [Order Details].ProductID = products.ProductID
JOIN categories ON products.CategoryID = categories.CategoryID
GROUP BY categories.CategoryName
""""""

# Executing the SQL query to get the data
df = execute_sql_query(sql_query)

# Sorting the DataFrame to find the most popular category by unique customers
df_sorted = df.sort_values(by='unique_customers', ascending=False)

# Visualization using Plotly
fig = px.bar(df_sorted, x='CategoryName', y='unique_customers', title=""Unique Customers by Product Category"")
show_to_user(fig)

# Display the most popular category information
most_popular_category = df_sorted.iloc[0]['CategoryName']
print(f""The most popular product category by unique customers is: {most_popular_category}"")
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT c.CategoryID, c.CategoryName, COUNT(DISTINCT o.CustomerID) AS unique_customers
FROM orders o
JOIN [Order Details] od ON o.OrderID = od.OrderID
JOIN products p ON od.ProductID = p.ProductID
JOIN categories c ON p.CategoryID = c.CategoryID
GROUP BY c.CategoryID, c.CategoryName
ORDER BY unique_customers DESC
LIMIT 1
""""""

most_popular_category = execute_sql_query(sql_query)

category_name = most_popular_category['CategoryName'].values[0]
unique_customers_count = most_popular_category['unique_customers'].values[0]

bar_chart_data = pd.DataFrame({
    'Category': [category_name],
    'Unique Customers': [unique_customers_count]
})

fig = px.bar(bar_chart_data, x='Category', y='Unique Customers', title='Most Popular Product Category by Unique Customers')
show_to_user(fig)
```","The input code evaluates only the most popular category using SQL's ORDER BY and LIMIT, which differs from the reference implementation's logic that analyzes all categories, sorts them, and visualizes all in a bar chart. The reference code sorts all categories by unique customers to find the most popular one and visualizes all categories. The input code creates a bar chart for only the single most popular category, not the entire dataset.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT 
    categories.CategoryID, 
    COUNT(DISTINCT order_items.OrderID) AS UniqueCustomers 
FROM 
    order_items 
JOIN 
    products ON order_items.ProductID = products.ProductID 
JOIN 
    categories ON products.CategoryID = categories.CategoryID 
GROUP BY 
    categories.CategoryID 
ORDER BY 
    UniqueCustomers DESC 
LIMIT 1;
""""""

# Execute the query using the utility function
result_df = execute_sql_query(sql_query)

# Create a bar chart to visualize the result
fig = px.bar(result_df, x='CategoryID', y='UniqueCustomers', 
             title='Most Popular Product Category by Unique Customers',
             labels={'CategoryID': 'Category ID', 'UniqueCustomers': 'Unique Customers'})

# Display the bar chart to the user
show_to_user(fig)
```","The input code and reference code differ in identifying the most popular product category. The reference counts unique CustomerIDs to determine popularity, while the input counts unique OrderIDs, which may not accurately reflect unique customer counts. Furthermore, the input code queries only the single top category at the database level, whereas the reference sorts all categories in Python, allowing full visualization for all categories. Additionally, the input uses 'CategoryID' instead of 'CategoryName' for visualization and skips printing the most popular category.",None
"What is the average discount given per order, and can we visualize the distribution of these discounts over time using a line chart?","
```python
import pandas as pd
import plotly.express as px

# SQL query to get discounts and order dates
discount_query = """"""
SELECT
    OrderID,
    Discount,
    OrderDate
FROM [Order Details] JOIN Orders ON [Order Details].OrderID = Orders.OrderID
""""""

# Function to execute the SQL query
discount_data = execute_sql_query(discount_query)

# Calculate the average discount per order
average_discount_query = ""SELECT AVG(Discount) AS AverageDiscount FROM [Order Details]""
average_discount_df = execute_sql_query(average_discount_query)

# Print the average discount
average_discount = average_discount_df['AverageDiscount'].iloc[0]
print(f""Average Discount: {average_discount}"")

# Convert OrderDate to datetime
discount_data['OrderDate'] = pd.to_datetime(discount_data['OrderDate'])

# Group data by OrderDate and calculate average discount per day
discount_over_time = discount_data.groupby('OrderDate')['Discount'].mean().reset_index()

# Visualization using Plotly Line chart
fig = px.line(discount_over_time, x='OrderDate', y='Discount', title='Average Discount Over Time')

# Display the visualization
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    o.OrderDate, 
    SUM(od.Discount) / COUNT(od.OrderID) AS AverageDiscount
FROM 
    orders o
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    o.OrderDate
ORDER BY 
    o.OrderDate;
""""""

average_discount_df = execute_sql_query(sql_query)

average_discount_over_time = average_discount_df.groupby('OrderDate').mean().reset_index()

fig = px.line(average_discount_over_time, x='OrderDate', y='AverageDiscount', 
              title='Average Discount Given Per Order Over Time',
              labels={'AverageDiscount': 'Average Discount', 'OrderDate': 'Order Date'})
show_to_user(fig)
```","The evaluated code correctly calculates the average discount per order by dividing the total discount by the count of orders for each order date, similar to the reference implementation's logic. Both implementations then visualize this average over time using a line chart, fulfilling the business request.","```python
import pandas as pd
import plotly.express as px

# Define the SQL query to retrieve average discount per order and order date
sql_query = """"""
SELECT 
    o.OrderDate, 
    AVG(od.Discount) AS AverageDiscount 
FROM 
    orders o 
JOIN 
    ""Order Details"" od 
ON 
    o.OrderID = od.OrderID 
GROUP BY 
    o.OrderDate;
""""""

# Execute the SQL query using the provided utility function
df = execute_sql_query(sql_query)

# Visualize the distribution of average discounts over time using a line chart
fig = px.line(df, x='OrderDate', y='AverageDiscount', 
              title='Average Discount Per Order Over Time',
              labels={'OrderDate': 'Order Date', 'AverageDiscount': 'Average Discount'})

# Show the visualization to the user
show_to_user(fig)
```","The input code correctly answers the business analytics request by calculating the average discount per order, grouped by order date, and then visualizing the result using a line chart. It utilizes a single SQL query with aggregation to calculate the average discount per order date, which is equivalent to the logic of the reference implementation. Both codes use the same plotting library, Plotly, to visualize the data, and they display the averaged discount over time correctly.",both
How many orders were fulfilled on time each month? Include a line chart to visualize the trend over time.,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_TRUNC('month', OrderDate) AS Month, COUNT(*) AS OnTimeOrders 
FROM orders 
WHERE ShippedDate <= RequiredDate 
GROUP BY Month;
""""""

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Simulating the execution of the SQL query
    # In a real scenario, this would connect to the database and return the DataFrame
    pass

# Function to display data or visualization
def show_to_user(data):
    # Simulating the display function
    # In a real scenario, this would display the DataFrame or Plotly figure
    print(data)

# Execute the SQL query and get the result as a DataFrame
orders_df = execute_sql_query(sql_query)

# Ensure 'Month' column is of datetime type before plotting
orders_df['Month'] = pd.to_datetime(orders_df['Month'])

# Create a line chart using Plotly
fig = px.line(orders_df, x='Month', y='OnTimeOrders', title='On-Time Orders per Month')

# Display the line chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS TotalOrders,
    SUM(CASE WHEN ShippedDate <= RequiredDate THEN 1 ELSE 0 END) AS OnTimeOrders
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

df = execute_sql_query(sql_query)
df['OnTimeDeliveryRate'] = df['OnTimeOrders'] / df['TotalOrders']

fig = px.line(df, x='Month', y='OnTimeDeliveryRate', title='On-time Delivery Rate Over Time', 
              labels={'OnTimeDeliveryRate': 'On-time Delivery Rate', 'Month': 'Month'})
show_to_user(fig)
```","The input Python code and the reference implementation are not aligned in terms of the business analytics request. The reference code calculates and visualizes the number of orders fulfilled on time each month, while the input code calculates and visualizes the on-time delivery rate (a percentage). Additionally, the reference uses `DATE_TRUNC` to group by month, but the input code uses `DATE_FORMAT`. Also, the input code includes additional metrics ('TotalOrders' and 'OnTimeDeliveryRate') not specified in the request.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are defined as per the environment constraints
   
# SQL query to fetch on-time orders data
sql_query = """"""
SELECT
    TO_CHAR(orders.OrderDate, 'YYYY-MM') AS Month,
    COUNT(orders.OrderID) AS OnTimeOrders
FROM
    orders
WHERE
    orders.ShippedDate <= orders.RequiredDate
GROUP BY
    Month
ORDER BY
    Month;
""""""

# Execute the SQL query to get the DataFrame
orders_df = execute_sql_query(sql_query)

# Create a line chart using Plotly to visualize on-time orders trend
fig = px.line(
    orders_df,
    x='Month',
    y='OnTimeOrders',
    title='On-Time Orders Fulfilled Each Month',
    labels={'OnTimeOrders': 'Number of On-Time Orders', 'Month': 'Month'},
    markers=True
)

# Display the line chart to the user
show_to_user(fig)
```","The input code effectively answers the business analytics request by counting the number of on-time orders each month and visualizing them with a line chart. It uses `TO_CHAR` to extract the monthly aggregation, whereas the reference code uses `DATE_TRUNC`. Both methods achieve the same purpose by grouping data monthly. The logic and intent align with the reference implementation, fulfilling the criteria despite minor syntactic differences.",Finetuned
Calculate and visualize the Product Performance for each product over the last year.,"import pandas as pd
import plotly.express as px


def calculate_product_performance():
    sql_query = """"""
    SELECT p.ProductID, SUM(od.Quantity) AS TotalPerformance
    FROM [Order Details] od
    JOIN products p ON od.ProductID = p.ProductID
    WHERE od.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY p.ProductID;
    """"""
    
    # Execute SQL query and get result as DataFrame
    product_performance_df = execute_sql_query(sql_query)
    
    # Check if the DataFrame is not empty
    if product_performance_df.empty:
        print(""No data available for the given time period."")
        return
    
    # Visualize the Product Performance using Plotly
    fig = px.bar(product_performance_df, x='ProductID', y='TotalPerformance',
                 title='Product Performance Over the Last Year',
                 labels={'TotalPerformance': 'Total Performance', 'ProductID': 'Product ID'})
    
    # Show the visualization to the user
    show_to_user(fig)

# Call the function to execute the process
calculate_product_performance()","```python
import pandas as pd
import plotly.express as px

# SQL query to calculate Product Performance over the last year
sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    DATE_TRUNC('month', o.OrderDate) AS Month,
    SUM(od.Quantity) AS TotalQuantitySold
FROM 
    products p
JOIN 
    ""[Order Details]"" od ON p.ProductID = od.ProductID
JOIN 
    orders o ON od.OrderID = o.OrderID
WHERE 
    o.OrderDate >= NOW() - INTERVAL '1 year'
GROUP BY 
    p.ProductID, p.ProductName, Month
ORDER BY 
    Month, p.ProductID;
""""""

# Execute the SQL query
product_performance_df = execute_sql_query(sql_query)

# Create a line plot for Product Performance
fig = px.line(
    product_performance_df,
    x='Month',
    y='TotalQuantitySold',
    color='ProductName',
    title='Product Performance Over the Last Year',
    labels={'TotalQuantitySold': 'Total Quantity Sold', 'Month': 'Month'}
)

# Show the visualization to the user
show_to_user(fig)
```","The input code calculates monthly product performance and visualizes it as a line plot, whereas the reference code calculates overall product performance for the last year and visualizes it as a bar chart. The input code also includes additional columns like ProductName, which the reference code does not require. The aggregation and grouping logic differ, leading to a different interpretation and visualization.","```python
import plotly.express as px
import pandas as pd

def sql_query_to_dataframe(sql_query: str) -> pd.DataFrame:
    # Simulating database call with a dummy dataframe for the sake of this example
    # Replace this with the actual database query logic
    data = {
        'Product_ID': [101, 102, 103],
        'Total_Sold': [150, 90, 300]
    }
    return pd.DataFrame(data)

def show_to_user(data):
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL query to fetch product performance data
sql_query = """"""
SELECT Product_ID, COUNT(Product_ID) AS Total_Sold 
FROM [Order Details] 
WHERE OrderDate >= ADD_MONTHS(CURRENT_DATE, -12) 
GROUP BY Product_ID 
ORDER BY Total_Sold DESC;
""""""

# Execute SQL query and get data
df = sql_query_to_dataframe(sql_query)

# Visualize product performance with Plotly
fig = px.bar(df, x='Product_ID', y='Total_Sold', title='Product Performance Over the Last Year')
show_to_user(fig)
```","The input code is incorrect because it doesn't adhere to the reference logic. The reference code uses 'SUM(od.Quantity)' to calculate the total performance, whereas the input code uses 'COUNT(Product_ID)', which is not equivalent. Additionally, the date function used to filter the last year is incorrect; the reference uses 'DATE_SUB(CURDATE(), INTERVAL 1 YEAR)', while the input uses 'ADD_MONTHS(CURRENT_DATE, -12)'.",None
"How does the distribution of sales by region compare? Include a data visualization, such as a bar chart or map, to illustrate the differences.","```python
import plotly.express as px
import pandas as pd

# Define the SQL query
sql_query = """"""
SELECT employees.Region, 
       SUM([Order Details].UnitPrice * [Order Details].Quantity * (1 - [Order Details].Discount)) AS Sales 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
GROUP BY employees.Region
""""""

# Execute the SQL query and get the result as a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize sales distribution by region
fig = px.bar(sales_data, x='Region', y='Sales', title='Sales Distribution by Region')

# Display the visualization to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    e.Region, 
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalSales
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.Region
ORDER BY 
    TotalSales DESC
""""""

sales_by_region = execute_sql_query(sql_query)

fig = px.bar(sales_by_region, x='Region', y='TotalSales', title='Sales Distribution by Region')
show_to_user(fig)
```","The input code correctly follows the logic of the reference implementation. Both codes perform the same SQL aggregation to calculate sales by region and use Plotly Express to visualize the results with a bar chart. The slight differences in variable names and SQL syntax, like aliasing table names or ordering the results, do not affect the correctness or functionality as related to the business analytics request.","```python
import plotly.express as px

# Define SQL query to retrieve sales by region
sql_query = """"""
SELECT ShipCountry, SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS Sales
FROM orders o
JOIN ""Order Details"" od ON o.OrderID = od.OrderID
GROUP BY ShipCountry;
""""""

# Execute the SQL query and get the results as a DataFrame
sales_data = execute_sql_query(sql_query)

# Create a bar chart to visualize the distribution of sales by region
fig = px.bar(sales_data, x='ShipCountry', y='Sales',
             title='Sales Distribution by Region',
             labels={'Sales': 'Total Sales', 'ShipCountry': 'Region'},
             color='Sales')

# Display the bar chart
show_to_user(fig)
```","The input code uses 'ShipCountry' instead of 'Region' for grouping, which doesn't match the business requirement to compare sales by 'Region'. Additionally, it doesn't join with the 'employees' table, which is necessary to get the 'Region'.",Base
"Which products have exceeded the reorder level, and can you provide a bar chart to visualize the quantities exceeding the reorder level for each product?","
import pandas as pd
import plotly.express as px

# Business Analytic Request

# Step 1: Execute SQL query to retrieve relevant products
sql_query = ""SELECT ProductName, UnitsInStock, ReorderLevel FROM products WHERE UnitsInStock < ReorderLevel;""
df = execute_sql_query(sql_query)

# Step 2: Calculate quantities exceeding the reorder level
df['QuantityExceeded'] = df['ReorderLevel'] - df['UnitsInStock']

# Step 3: Create a bar chart to visualize the quantities exceeding the reorder level for each product
fig = px.bar(df, 
             x='ProductName', 
             y='QuantityExceeded', 
             title='Products Exceeding Reorder Level',
             labels={'QuantityExceeded': 'Quantity Exceeding Reorder Level', 'ProductName': 'Product Name'})

# Step 4: Show the plot to the user
show_to_user(fig)
","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    p.ProductID,
    p.ProductName,
    p.UnitsInStock,
    p.ReorderLevel,
    (p.UnitsInStock - p.ReorderLevel) AS ExcessQuantity
FROM 
    products p
WHERE 
    p.UnitsInStock > p.ReorderLevel
""""""

df = execute_sql_query(sql_query)

fig = px.bar(df, x='ProductName', y='ExcessQuantity', title='Products Exceeding Reorder Level',
             labels={'ExcessQuantity': 'Quantity Exceeding Reorder Level'})
show_to_user(fig)
```","The input code calculates 'ExcessQuantity' as 'UnitsInStock - ReorderLevel' and filters for 'UnitsInStock > ReorderLevel', which is contrary to the request. It should calculate the shortfall as 'ReorderLevel - UnitsInStock' and filter 'UnitsInStock < ReorderLevel' as in the reference.","Certainly! To meet the business request, the following Python code will query the database for products exceeding the reorder level and visualize the quantities exceeding the reorder level for each product using a bar chart.

```python
import plotly.express as px
import pandas as pd

# SQL query to fetch products exceeding the reorder level
sql_query = """"""
SELECT ProductName, UnitsInStock - ReorderLevel AS Excess 
FROM products 
WHERE UnitsInStock > ReorderLevel;
""""""

# Execute the query and fetch results into a DataFrame
excess_inventory_df = execute_sql_query(sql_query)

# Visualize the quantities exceeding the reorder level for each product
fig = px.bar(
    excess_inventory_df,
    x='ProductName',
    y='Excess',
    title='Products Exceeding Reorder Level',
    labels={'ProductName': 'Product Name', 'Excess': 'Units Exceeding Reorder Level'}
)

# Display the bar chart
show_to_user(fig)
```

### Breakdown of the Code:
1. **Query Execution**: The `execute_sql_query` function runs an SQL query that identifies products where the current stock exceeds the reorder level.
2. **DataFrame Creation**: The results are stored in a DataFrame called `excess_inventory_df` that includes product names and the amount they exceed the reorder level.
3. **Visualization**: A bar chart is created using Plotly Express to visualize which products are over their reorder levels and by how much.
4. **Result Presentation**: Finally, the bar chart is displayed using the `show_to_user` function, which is tailored for presenting data analysis results.","The input code retrieves products where 'UnitsInStock' is greater than 'ReorderLevel', which is incorrect. It should identify products where 'UnitsInStock' is less than 'ReorderLevel'. Additionally, the calculation of 'Excess' is incorrect; it should subtract 'UnitsInStock' from 'ReorderLevel' to identify the amount needed rather than the excess.",None
Find the employee with the largest number of orders with discounts and create a bar chart to visualize the number of discounted orders per employee.,"
```python
import pandas as pd
import plotly.express as px

# SQL query to find number of discounted orders per employee
sql_query = """"""
SELECT employees.EmployeeID, COUNT(orders.OrderID) AS DiscountedOrders 
FROM employees 
JOIN orders ON employees.EmployeeID = orders.EmployeeID 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
WHERE [Order Details].Discount > 0 
GROUP BY employees.EmployeeID 
""""""

# Execute the SQL query and retrieve the results as a DataFrame
discounted_orders_df = execute_sql_query(sql_query)

# Find the employee with the largest number of discounted orders
# Although the SQL query fetches the top, we'll verify in Python for demonstration
max_discounted_orders = discounted_orders_df['DiscountedOrders'].max()
top_employee = discounted_orders_df[discounted_orders_df['DiscountedOrders'] == max_discounted_orders]

# Create a bar chart using Plotly to visualize the number of discounted orders per employee
fig = px.bar(discounted_orders_df, x='EmployeeID', y='DiscountedOrders', 
             title='Number of Discounted Orders per Employee', labels={'EmployeeID': 'Employee ID', 'DiscountedOrders': 'Discounted Orders'})

# Display the bar chart to the user
show_to_user(fig)

# Optionally, display the employee with the largest number of discounted orders
show_to_user(top_employee)
```
","```python
import pandas as pd
import plotly.express as px

# SQL query to count discounted orders per employee
sql_query = """"""
SELECT 
    e.EmployeeID,
    CONCAT(e.FirstName, ' ', e.LastName) AS EmployeeName,
    COUNT(o.OrderID) AS DiscountedOrderCount
FROM 
    employees e
JOIN 
    orders o ON e.EmployeeID = o.EmployeeID
JOIN 
    [Order Details] od ON o.OrderID = od.OrderID
WHERE 
    od.Discount > 0
GROUP BY 
    e.EmployeeID, EmployeeName
ORDER BY 
    DiscountedOrderCount DESC
""""""

# Execute the SQL query and retrieve the data
employee_discounted_orders = execute_sql_query(sql_query)

# Find the employee with the largest number of discounted orders
top_employee = employee_discounted_orders.iloc[0]

# Create a bar chart to visualize the number of discounted orders per employee
fig = px.bar(employee_discounted_orders, 
             x='EmployeeName', 
             y='DiscountedOrderCount', 
             title='Number of Discounted Orders per Employee',
             labels={'DiscountedOrderCount': 'Discounted Orders', 'EmployeeName': 'Employee'},
             color='DiscountedOrderCount')

show_to_user(fig)
```","The input code correctly executes an SQL query to fetch employees with discounted orders. It groups and counts the orders as specified in the business requirement. The top employee is identified using the max count, aligning with the request. The bar chart visualizes the data correctly, with the additional benefit of showing employee names, which enhances clarity. Despite minor differences in approach, the logic and the output match the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to find discounted orders for each employee
sql_query = """"""
SELECT o.EmployeeID, COUNT(*) AS DiscountedOrders
FROM orders o 
JOIN [Order Details] od ON o.OrderID = od.OrderID 
WHERE od.Discount > 0 
GROUP BY o.EmployeeID;
""""""

# Execute the SQL query to get data
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # This function should implement the mechanism to connect to the database,
    # execute the given SQL query and return the result as a pandas DataFrame.
    pass

# Fetch data
discounted_orders_df = execute_sql_query(sql_query)

# Find the employee with the most discounted orders
top_employee = discounted_orders_df.sort_values(by='DiscountedOrders', ascending=False).head(1)

# Print the result to the user
show_to_user(top_employee)

# Create a bar chart for the number of discounted orders per employee
fig = px.bar(discounted_orders_df, x='EmployeeID', y='DiscountedOrders', title='Discounted Orders per Employee')

# Display the bar chart
show_to_user(fig)
```","The input Python code adheres to the business analytics request and matches the logic of the reference implementation. Both codes perform the SQL query to count discounted orders per employee and find the employee with the most discounted orders. The code creates a bar chart to visualize this data. The slight differences in implementation, such as different methods to determine the top employee, do not impact correctness. These differences still achieve the same outcome: identifying and displaying the employee with the most discounted orders and visualizing the data effectively.",both
Which supplier has the shortest average lead time for deliveries? Please include a bar chart comparing the average lead times of all suppliers.,"```python
import pandas as pd
import plotly.express as px

# Execute SQL query to retrieve average lead times for each supplier
sql_query = """"""
SELECT suppliers.SupplierID, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time 
FROM orders 
JOIN [Order Details] ON orders.OrderID = [Order Details].OrderID 
JOIN products ON [Order Details].ProductID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID 
ORDER BY avg_lead_time ASC
""""""

# Assuming `execute_sql_query` is a predefined utility function
df_lead_times = execute_sql_query(sql_query)

# Create a bar chart for visualizing average lead times per supplier
fig = px.bar(
    df_lead_times, 
    x='SupplierID', 
    y='avg_lead_time', 
    title='Average Lead Time by Supplier',
    labels={'avg_lead_time': 'Average Lead Time (days)', 'SupplierID': 'Supplier ID'}
)

# Display the figure using the predefined utility function
show_to_user(fig)

# Find and display the supplier with the shortest average lead time
shortest_lead_time_supplier = df_lead_times.iloc[0]
result_df = pd.DataFrame([shortest_lead_time_supplier])
show_to_user(result_df)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT suppliers.SupplierID, suppliers.CompanyName, AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS avg_lead_time
FROM orders 
JOIN products ON orders.OrderID = products.ProductID 
JOIN suppliers ON products.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.SupplierID, suppliers.CompanyName
""""""

lead_time_df = execute_sql_query(sql_query)

shortest_lead_time_supplier = lead_time_df.loc[lead_time_df['avg_lead_time'].idxmin()]

fig = px.bar(lead_time_df, x='CompanyName', y='avg_lead_time', title='Average Lead Time by Supplier')
show_to_user(fig)

shortest_lead_time_supplier
```","The input code has a different JOIN condition compared to the reference code. The input code joins `orders` and `products` on `OrderID` and `ProductID` respectively, which seems to be an incorrect relationship since a direct association via `OrderID = ProductID` is unlikely. The reference code correctly joins `orders` with `Order Details` using `OrderID`, and further joins to `products` to relate with `suppliers`. Also, the input code includes `CompanyName` in the SELECT and GROUP BY statements, which doesn't affect correctness, but it's a difference. Overall, the discrepancy in the join logic results in potential inaccuracy in calculating average lead times.","```python
import pandas as pd
import plotly.express as px

# Assuming the existence of the utility functions: execute_sql_query and show_to_user

# SQL query to fetch the average lead time for all suppliers
sql_query = """"""
SELECT suppliers.CompanyName, 
       AVG(DATEDIFF(orders.ShippedDate, orders.OrderDate)) AS AvgLeadTime 
FROM orders 
JOIN orders_suppliers ON orders.OrderID = orders_suppliers.OrderID 
JOIN suppliers ON orders_suppliers.SupplierID = suppliers.SupplierID 
GROUP BY suppliers.CompanyName 
ORDER BY AvgLeadTime ASC;
""""""

# Execute the query to get the data
data = execute_sql_query(sql_query)

# Create a bar chart comparing the average lead times of all suppliers
fig = px.bar(data, 
             x='CompanyName', 
             y='AvgLeadTime', 
             title='Average Lead Time for Deliveries by Supplier',
             labels={'CompanyName': 'Supplier', 'AvgLeadTime': 'Average Lead Time (days)'})

# Display the bar chart
show_to_user(fig)
```","The implementation differs from the reference in the way it calculates lead times. Specifically, the input code uses 'orders_suppliers', which suggests a different join condition, and groups by 'CompanyName' instead of 'SupplierID'. This affects the computation of average lead times if 'orders_suppliers' does not match the structure in the reference. Both implementations aim to calculate average lead times and visualize them, but they differ in SQL logic. Moreover, the input code does not identify the supplier with the shortest lead time.",None
"How many orders were placed in each month of the year, and can you provide a monthly trend line chart to visualize the data?","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str):
    # Mock function for demonstration purposes
    # In a real scenario, this function will connect to a database,
    # execute the given SQL query, and return the results as a pandas DataFrame.
    # Sample data simulating the result of the SQL Query
    data = {'Month': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
            'OrderCount': [20, 25, 30, 22, 27, 33, 45, 40, 43, 38, 29, 31]}
    return pd.DataFrame(data)

def show_to_user(data):
    # Mock function for demonstration purposes
    # In a real scenario, this function will display the data or visualization to the user.
    print(data)

# SQL Query
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, COUNT(OrderID) 
FROM orders 
GROUP BY Month 
ORDER BY Month;
""""""

# Execute SQL query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a monthly trend line chart using Plotly
fig = px.line(df, x='Month', y='OrderCount', title='Monthly Orders Trend',
              labels={'Month': 'Month', 'OrderCount': 'Number of Orders'})

# Show the resulting figure to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

order_counts = execute_sql_query(sql_query)

fig = px.line(order_counts, x='Month', y='OrderCount', title='Monthly Orders Trend')
show_to_user(fig)
```","The input code calculates monthly order counts using 'DATE_FORMAT(OrderDate, '%Y-%m')', which includes the year in the 'Month' column. This deviates from the reference, which uses 'EXTRACT(MONTH FROM OrderDate)', grouping by month only across years. Hence, the input code will produce multiple entries for the same month across different years, resulting in incorrect aggregation compared to the reference implementation.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the data
sql_query = """"""
SELECT EXTRACT(MONTH FROM OrderDate) AS Month, COUNT(OrderID) AS OrderCount 
FROM orders 
GROUP BY EXTRACT(MONTH FROM OrderDate);
""""""

# Execute the SQL query to get the data
data_frame = execute_sql_query(sql_query)

# Display the data to the user
show_to_user(data_frame)

# Generate and display a trend line chart for monthly order counts
fig = px.line(data_frame, x='Month', y='OrderCount', title='Monthly Trend of Order Counts')
show_to_user(fig)
```","The input Python code is logically consistent with the reference implementation. Both implementations perform the same tasks: executing an SQL query to extract the number of orders placed each month and creating a trend line chart using Plotly to visualize the data. The SQL queries in both codes are equivalent, as they both group by the extracted month from order dates. The chart creation and data display processes are similar, fulfilling the business analytics request correctly.",Finetuned
Which customer placed the most orders in 2022? Provide a bar chart to illustrate the number of orders for the top 10 customers.,"```python
import pandas as pd
import plotly.express as px

# Example SQL to fetch the top 10 customers by order count in 2022
sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount 
FROM orders 
WHERE EXTRACT(YEAR FROM OrderDate) = 2022 
GROUP BY CustomerID 
ORDER BY OrderCount DESC 
LIMIT 10;
""""""

# Function to execute the SQL query and obtain the results as a DataFrame
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # The actual database interaction logic would go here.
    # Here we will simulate with a sample DataFrame for the purpose of this example.
    sample_data = {
        'CustomerID': [101, 102, 103, 104, 105, 106, 107, 108, 109, 110],
        'OrderCount': [150, 140, 130, 120, 110, 100, 90, 80, 70, 60]
    }
    return pd.DataFrame(sample_data)

# Function to display the data or visualization
def show_to_user(data):
    # In an actual environment, this function would handle visualization display
    if isinstance(data, pd.DataFrame):
        print(data.to_string(index=False))
    else:
        data.show()

# Execute the SQL query to get top 10 customers by order count
df_top_customers = execute_sql_query(sql_query)

# Create a bar chart to visualize the number of orders for the top 10 customers
fig = px.bar(df_top_customers, 
             x='CustomerID', 
             y='OrderCount', 
             title='Top 10 Customers by Order Count in 2022',
             labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = 2022
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 10
""""""

top_customers = execute_sql_query(sql_query)

fig = px.bar(top_customers, x='CustomerID', y='OrderCount', title='Top 10 Customers by Number of Orders in 2022')
show_to_user(fig)
```","The input Python code correctly implements the specified business analytics request. It uses a nearly identical SQL query to fetch the top 10 customers by order count in 2022. Both implementations group by CustomerID, count the orders, order the results by order count in descending order, and limit the results to the top 10 customers. The data is used to create a bar chart using Plotly Express to visualize the number of orders for these customers, and the chart is displayed using `show_to_user`. Thus, the logic of the input code aligns with the reference implementation.","
import plotly.express as px

def execute_sql_query(sql_query: str):
    # Placeholder function to execute SQL query
    pass

def show_to_user(data):
    # Placeholder function to display results
    pass

# SQL query to fetch the top 10 customers with the most orders in 2022
sql_query_top_10 = """"""
SELECT CustomerID, COUNT(OrderID) AS OrderCount
FROM orders
WHERE YEAR(OrderDate) = 2022
GROUP BY CustomerID
ORDER BY OrderCount DESC
LIMIT 10;
""""""

# Execute the SQL query
top_10_customers = execute_sql_query(sql_query_top_10)

# Create a bar chart using Plotly
fig = px.bar(
    top_10_customers,
    x='CustomerID',
    y='OrderCount',
    title='Top 10 Customers by Number of Orders in 2022',
    labels={'CustomerID': 'Customer ID', 'OrderCount': 'Number of Orders'}
)

# Display the bar chart to the user
show_to_user(fig)
","The provided code meets the requirements of fetching the top 10 customers by order count in 2022 and creating a bar chart to visualize the data. Although database interaction is represented as a placeholder, it logically aligns with the reference implementation by using a similar SQL query and visualization approach. The chart creation and display methods are consistent with the expected functionality.",both
"  
""Which city has received the highest number of shipments year-to-date, and can this information be represented with a bar chart?","```python
import plotly.express as px

def get_top_ship_city():
    # Define the SQL query to execute
    sql_query = """"""
    SELECT ShipCity, COUNT(*) AS Shipments 
    FROM orders 
    WHERE EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
    GROUP BY ShipCity 
    ORDER BY Shipments DESC 
    LIMIT 1;
    """"""
    
    # Execute the SQL query and get a DataFrame
    shipments_df = execute_sql_query(sql_query)
    
    # Extract the city with the highest shipments
    top_city = shipments_df.iloc[0]['ShipCity']
    
    # Data for creating the bar chart
    city_shipments_query = """"""
    SELECT ShipCity, COUNT(*) AS Shipments 
    FROM orders 
    WHERE EXTRACT(YEAR FROM OrderDate) = EXTRACT(YEAR FROM CURRENT_DATE) 
    GROUP BY ShipCity 
    ORDER BY Shipments DESC;
    """"""
    
    # Execute the query to get shipments data for all cities
    city_shipments_df = execute_sql_query(city_shipments_query)
    
    # Create a bar chart using Plotly
    fig = px.bar(city_shipments_df, x='ShipCity', y='Shipments', title='Year-to-Date Shipments by City')
    
    # Display the bar chart
    show_to_user(fig)
    
    return top_city

# Run the function
top_city = get_top_ship_city()

# Optionally display the top city to the user
show_to_user(f""The city with the highest number of shipments year-to-date is: {top_city}"")
```","```python
import pandas as pd
import plotly.express as px

# SQL query to get the number of shipments by city year-to-date
sql_query = """"""
SELECT ShipCity, COUNT(OrderID) AS Shipments
FROM orders
WHERE ShippedDate >= DATE_FORMAT(CURDATE(), '%Y-01-01')
GROUP BY ShipCity
ORDER BY Shipments DESC
LIMIT 1;
""""""

# Execute the SQL query
top_city_df = execute_sql_query(sql_query)

# Get the city with the highest shipments
top_city = top_city_df.iloc[0]

# Prepare data for bar chart
shipments_data = execute_sql_query(""""""
SELECT ShipCity, COUNT(OrderID) AS Shipments
FROM orders
WHERE ShippedDate >= DATE_FORMAT(CURDATE(), '%Y-01-01')
GROUP BY ShipCity;
"""""")

# Create the bar chart
fig = px.bar(shipments_data, x='ShipCity', y='Shipments', title='Number of Shipments by City Year-to-Date')

# Show the bar chart to the user
show_to_user(fig)
```","The input code retrieves the city with the most shipments using the 'ShippedDate' instead of 'OrderDate', which deviates from the criterion set by the reference code. Additionally, it omits displaying the top city to the user and incorrectly converts the year to date using DATE_FORMAT(CURDATE(), '%Y-01-01') instead of EXTRACT(YEAR FROM CURRENT_DATE) to match the year within OrderDate.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are available for use
sql_query = """"""
SELECT o.ShipCity, COUNT(o.OrderID) AS Shipments
FROM orders o
WHERE DATE(o.OrderDate) >= '2023-01-01'
GROUP BY o.ShipCity
ORDER BY Shipments DESC
LIMIT 1;
""""""

# Execute the SQL query and get the result as a DataFrame
shipments_df = execute_sql_query(sql_query)

# Display the DataFrame to the user
show_to_user(shipments_df)

# Create a bar chart to visualize the data
fig = px.bar(shipments_df, x='ShipCity', y='Shipments', title='Shipments by City YTD')

# Display the bar chart to the user
show_to_user(fig)
```","The input code only retrieves the top city with the highest number of shipments and creates a bar chart from this single result, not for all cities as needed for a comprehensive visualization. It's missing the full dataset query for generating the bar chart like in the reference implementation. Additionally, the use of a fixed date '2023-01-01' does not dynamically pull data based on the current year's shipments.",None
"Which month had the highest number of orders shipped, and can you provide a bar chart to visualize the monthly shipping volume?","```python
import plotly.express as px

# Define the SQL query
sql_query = """"""
SELECT DATE_FORMAT(ShippedDate, '%Y-%m') AS Month, COUNT(OrderID) AS OrderCount 
FROM orders
WHERE ShippedDate IS NOT NULL 
GROUP BY Month 
ORDER BY OrderCount DESC;
""""""

# Execute the SQL query to obtain the data
df = execute_sql_query(sql_query)

# Determine which month had the highest number of orders shipped
most_orders_shipped = df.iloc[0]  # Highest in the ordered result
print(f""Month with highest number of orders shipped: {most_orders_shipped['Month']}"")

# Create a bar chart to visualize the monthly shipping volume
fig = px.bar(df, x='Month', y='OrderCount', title='Monthly Shipping Volume', labels={'OrderCount': 'Number of Orders'})

# Display the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS NumberOfOrders
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    Month
ORDER BY 
    NumberOfOrders DESC
LIMIT 1
""""""

top_month = execute_sql_query(sql_query)

highest_month = top_month['Month'].values[0]
highest_orders = top_month['NumberOfOrders'].values[0]

monthly_orders_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS NumberOfOrders
FROM 
    orders
WHERE 
    ShippedDate IS NOT NULL
GROUP BY 
    Month
ORDER BY 
    Month
""""""

monthly_orders = execute_sql_query(monthly_orders_query)

fig = px.bar(monthly_orders, x='Month', y='NumberOfOrders', title='Monthly Shipping Volume',
              labels={'NumberOfOrders': 'Number of Orders Shipped', 'Month': 'Month'})
show_to_user(fig)
```","The input code correctly identifies the month with the highest number of orders shipped by executing a SQL query that finds the month with the maximum 'NumberOfOrders'. It then runs another query to get the monthly order data for creating a bar chart. Although it splits the SQL queries into two, the logic aligns with the reference code's intent: identify the top month and generate a monthly shipping volume visualization.","```python
import pandas as pd
import plotly.express as px

# SQL query to fetch the required data
sql_query = """"""
SELECT EXTRACT(MONTH FROM ShippedDate) AS month, 
       COUNT(OrderID) AS NumberOfOrders 
FROM orders 
GROUP BY month 
ORDER BY month;
""""""

# Execute SQL query to get the DataFrame
monthly_orders_df = execute_sql_query(sql_query)

# Extract the month with the highest number of orders
max_orders_month = monthly_orders_df.loc[monthly_orders_df['NumberOfOrders'].idxmax()]

# Display the month with the highest number of orders
show_to_user(max_orders_month)

# Create a bar chart using Plotly to visualize the monthly shipping volume
fig = px.bar(
    monthly_orders_df, 
    x='month', 
    y='NumberOfOrders', 
    labels={'month': 'Month', 'NumberOfOrders': 'Number of Orders'},
    title='Monthly Shipping Volume'
)

# Display the bar chart
show_to_user(fig)
```","The input code does not include a condition to exclude null ShippedDates, whereas the reference code includes 'WHERE ShippedDate IS NOT NULL'. Additionally, the reference code formats dates as '%Y-%m', but the input code extracts only the month, which may lead to incorrect results if multiple years are involved. The input code also orders by 'month' instead of 'NumberOfOrders' for display.",Base
Identify the peak order day of the week for each month and visualize the results with a bar chart.,"```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are already defined utility functions.

# SQL query to extract required data
sql_query = '''
SELECT EXTRACT(MONTH FROM o.OrderDate) AS OrderMonth, 
       DAYNAME(o.OrderDate) AS OrderDay, 
       COUNT(o.OrderID) AS OrderCount 
FROM orders o 
GROUP BY OrderMonth, OrderDay 
ORDER BY OrderMonth, OrderCount DESC;
'''

# Execute the SQL query and load the result into a DataFrame
data = execute_sql_query(sql_query)

# Find the peak order day of the week for each month
peak_order_days = data.loc[data.groupby('OrderMonth')['OrderCount'].idxmax()].reset_index(drop=True)

# Visualize the results using a bar chart with Plotly
fig = px.bar(peak_order_days, 
             x='OrderMonth', 
             y='OrderCount', 
             color='OrderDay', 
             title='Peak Order Day of the Week for Each Month',
             labels={'OrderMonth': 'Month', 'OrderCount': 'Order Count', 'OrderDay': 'Order Day of the Week'})

# Display the bar chart
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS Month,
    DAYOFWEEK(OrderDate) AS DayOfWeek,
    COUNT(OrderID) AS OrderCount
FROM 
    orders
GROUP BY 
    Month, DayOfWeek
ORDER BY 
    Month, DayOfWeek
""""""
order_data = execute_sql_query(sql_query)

order_data['DayOfWeek'] = order_data['DayOfWeek'].map({1: 'Sunday', 2: 'Monday', 3: 'Tuesday', 4: 'Wednesday', 5: 'Thursday', 6: 'Friday', 7: 'Saturday'})

peak_order_days = order_data.loc[order_data.groupby('Month')['OrderCount'].idxmax()]

fig = px.bar(peak_order_days, x='Month', y='OrderCount', color='DayOfWeek', title='Peak Order Day of the Week for Each Month')
show_to_user(fig)
```","Both the reference and the input code implement the same logic: extracting orders grouped by month and day, identifying the peak order day for each month, and visualizing with a bar chart. The SQL queries, while using different functions (EXTRACT and DAYNAME in the reference vs. DATE_FORMAT and DAYOFWEEK in the input), achieve equivalent results. The transformation of days and the Plotly visualization are consistent in logic, fulfilling the business requirement.","```python
import pandas as pd
import plotly.express as px

# Assuming execute_sql_query and show_to_user are pre-defined utility functions.

# Define the SQL query based on business requirements.
sql_query = """"""
SELECT 
    DATE_FORMAT(OrderDate, '%Y-%m') AS month, 
    DAYNAME(OrderDate) AS day_of_week, 
    COUNT(OrderID) AS order_count 
FROM 
    orders 
GROUP BY 
    month, day_of_week 
ORDER BY 
    month, order_count DESC;
""""""

# Execute the SQL query and get the result as a DataFrame.
df = execute_sql_query(sql_query)

# Identify peak order days for each month.
peak_df = df.loc[df.groupby('month')['order_count'].idxmax()]

# Create a bar chart using Plotly to visualize the peak order days.
fig = px.bar(peak_df, 
             x='month', 
             y='order_count', 
             color='day_of_week', 
             title='Peak Order Day of the Week for Each Month', 
             labels={'order_count': 'Order Count', 'month': 'Month'})

# Display the bar chart to the user.
show_to_user(fig)
```","The input code correctly addresses the business request and aligns with the reference implementation's logic. Both codes identify the peak order day of the week for each month. The SQL queries in both implementations group by month and day, order by month and order count in descending order, and utilize Plotly to create a bar chart. The difference in date format (e.g., EXTRACT vs. DATE_FORMAT) does not affect the intended outcome.",both
How many orders have zero freight cost? Can you provide a pie chart showing the proportion of zero freight cost orders to total orders?,"```python
import pandas as pd
import plotly.express as px

# Define the SQL query to get the count of zero freight cost orders
zero_freight_query = ""SELECT COUNT(OrderID) AS FreeShippingOrders FROM orders WHERE Freight = 0;""

# Execute the query to retrieve the count of zero freight cost orders
free_shipping_df = execute_sql_query(zero_freight_query)

# Extract the count of free shipping orders from the DataFrame
free_shipping_orders = free_shipping_df['FreeShippingOrders'][0]

# Define another SQL query to get the total number of orders
total_orders_query = ""SELECT COUNT(OrderID) AS TotalOrders FROM orders;""

# Execute the query to retrieve the total number of orders
total_orders_df = execute_sql_query(total_orders_query)

# Extract the total number of orders from the DataFrame
total_orders = total_orders_df['TotalOrders'][0]

# Prepare data for the pie chart
data = {
    'Order Type': ['Zero Freight', 'Other'],
    'Count': [free_shipping_orders, total_orders - free_shipping_orders]
}

# Create a DataFrame for the pie chart
df_pie = pd.DataFrame(data)

# Generate the pie chart using Plotly
fig = px.pie(df_pie, names='Order Type', values='Count', title='Proportion of Zero Freight Cost Orders')

# Display the pie chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT COUNT(*) AS TotalOrders, 
       SUM(CASE WHEN Freight = 0 THEN 1 ELSE 0 END) AS ZeroFreightOrders 
FROM orders;
""""""

df = execute_sql_query(sql_query)

total_orders = df['TotalOrders'][0]
zero_freight_orders = df['ZeroFreightOrders'][0]

labels = ['Zero Freight Orders', 'Other Orders']
values = [zero_freight_orders, total_orders - zero_freight_orders]

fig = px.pie(names=labels, values=values, title='Proportion of Zero Freight Cost Orders to Total Orders')
show_to_user(fig)
```","The input code correctly counts the total orders and zero freight cost orders using a single SQL query with aggregation functions. It stores the results and calculates values needed for the pie chart, similar to the reference code. Both implementations achieve the same outcome and display a pie chart showing the proportion of zero freight cost orders to total orders.","```python
import plotly.express as px

# Execute SQL query to get the count of orders with zero freight cost
sql_query_zero_freight = """"""
SELECT COUNT(OrderID) AS ZeroFreightOrders 
FROM orders 
WHERE Freight = 0;
""""""

# Execute SQL query to get the total number of orders
sql_query_total_orders = """"""
SELECT COUNT(OrderID) AS TotalOrders 
FROM orders;
""""""

# Execute the SQL queries
zero_freight_df = execute_sql_query(sql_query_zero_freight)
total_orders_df = execute_sql_query(sql_query_total_orders)

# Calculate the number of zero freight cost orders
zero_freight_orders = zero_freight_df['ZeroFreightOrders'].iloc[0]
total_orders = total_orders_df['TotalOrders'].iloc[0]

# Prepare data for the pie chart
labels = ['Zero Freight Orders', 'Other Orders']
values = [zero_freight_orders, total_orders - zero_freight_orders]

# Create a pie chart using Plotly
fig = px.pie(
    names=labels, 
    values=values, 
    title='Zero Freight Orders vs. Total Orders'
)

# Display the pie chart to the user
show_to_user(fig)
```","The input code correctly executes the SQL queries to get the count of zero freight cost orders and total orders, similar to the reference implementation. It processes the counts the same way and creates a pie chart using Plotly with analogous logic. Even though the labels and variable names differ ('ZeroFreightOrders' vs. 'FreeShippingOrders'), the overall logic aligns with the business request and reference code.",both
"How many orders were shipped late each month, and can this be visualized with a line chart to show trends over time?","```python
import plotly.express as px
import pandas as pd

# SQL Query to get late shipments by month
sql_query = """"""
SELECT 
    TO_CHAR(OrderDate, 'YYYY-MM') AS Month, 
    COUNT(OrderID) AS LateShipments 
FROM 
    orders 
WHERE 
    ShippedDate > RequiredDate 
GROUP BY 
    TO_CHAR(OrderDate, 'YYYY-MM') -- Ensure consistent grouping
ORDER BY 
    Month; -- Order by Month to ensure a chronological line chart
""""""

# Utility function to execute SQL queries
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Placeholder function for executing SQL
    # In practice, this would connect to a database and execute the query
    pass

# Executing the SQL query to get the data
late_shipments_df = execute_sql_query(sql_query)

# Generating a line chart to visualize late shipments over time
fig = px.line(late_shipments_df, x='Month', y='LateShipments', title='Late Shipments Over Time')

# Showing the line chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    DATE_FORMAT(ShippedDate, '%Y-%m') AS Month,
    COUNT(OrderID) AS LateShipments
FROM 
    orders
WHERE 
    ShippedDate > RequiredDate
GROUP BY 
    Month
ORDER BY 
    Month;
""""""

late_shipments_df = execute_sql_query(sql_query)

fig = px.line(late_shipments_df, x='Month', y='LateShipments', title='Late Shipments Per Month')
show_to_user(fig)
```","Both implementations aim to count the number of orders that were shipped late each month and visualize the data using a line chart. The SQL queries in both implementations correctly filter orders where `ShippedDate` is later than `RequiredDate`, calculate the count of these late shipments grouped by month, and order the results chronologically by month. The key difference is in the SQL date formatting where the reference code uses `TO_CHAR(OrderDate, 'YYYY-MM')`, while the evaluated code uses `DATE_FORMAT(ShippedDate, '%Y-%m')`, reflecting slight differences in SQL dialect but achieving the same result. Both use Plotly Express for visualization and correctly specify 'Month' as the x-axis and 'LateShipments' as the y-axis. Therefore, the input code is considered to be correct and follows the same logic as the reference implementation.","```python
import pandas as pd
import plotly.express as px

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Mock function: replace with actual SQL execution code
    pass

def show_to_user(data):
    # Mock function for demonstration purposes
    # Replace with code to display data or figures
    pass

# SQL query provided in the request
sql_query = """"""
SELECT EXTRACT(YEAR FROM ShippedDate) AS Year,
       EXTRACT(MONTH FROM ShippedDate) AS Month,
       COUNT(CASE WHEN ShippedDate > RequiredDate THEN 1 END) AS LateOrders
FROM orders
GROUP BY Year, Month
ORDER BY Year, Month;
""""""

# Execute the SQL query
orders_df = execute_sql_query(sql_query)

# Visualize with a line chart using Plotly
fig = px.line(orders_df, x='Month', y='LateOrders', 
              labels={'LateOrders': 'Number of Late Orders', 'Month': 'Month'},
              title='Monthly Number of Late Shipped Orders',
              line_shape='linear')

# Show the line chart
show_to_user(fig)
```","The input code considers late shipments based on the 'ShippedDate' rather than the 'OrderDate' as in the reference implementation. Additionally, the input code does not ensure consistent string formatting for the month, which is essential for a proper chronological order in the visualization.",Base
Find the products with the highest average order quantity and include a bar chart to illustrate the results.,"```python
import plotly.express as px
import pandas as pd

# Function to execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # For demonstration: simulate execution of an SQL query
    # Replace with actual database execution logic
    data = {
        'ProductName': ['Product A', 'Product B', 'Product C', 'Product D'],
        'AvgOrderQuantity': [15.2, 13.5, 9.8, 7.4]
    }
    return pd.DataFrame(data)

# Execute the given SQL query
sql_query = """"""
SELECT p.ProductName, AVG(od.Quantity) AS AvgOrderQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductName
ORDER BY AvgOrderQuantity DESC;
""""""

products_df = execute_sql_query(sql_query)

# Create a bar chart to illustrate the results using Plotly
fig = px.bar(
    products_df,
    x='ProductName',
    y='AvgOrderQuantity',
    title='Products with Highest Average Order Quantity',
    labels={'AvgOrderQuantity': 'Average Order Quantity'}
)

# Show the bar chart to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT p.ProductID, p.ProductName, SUM(od.Quantity) AS TotalQuantity
FROM products p
JOIN [Order Details] od ON p.ProductID = od.ProductID
GROUP BY p.ProductID, p.ProductName
ORDER BY TotalQuantity DESC
LIMIT 10
""""""

product_data = execute_sql_query(sql_query)

fig = px.bar(product_data, x='ProductName', y='TotalQuantity', title='Top 10 Products by Total Order Quantity')
show_to_user(fig)
```","The input code is not correct because it calculates the total order quantity for products rather than the average order quantity. The SQL query in the input code uses SUM instead of AVG, focusing on total order quantities instead of average. This doesn't align with the business analytics request to find products with the highest average order quantity. Additionally, the input code limits the results to the top 10 products based on total quantity, which differs from the request and reference implementation.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query to retrieve data
sql_query = """"""
SELECT ProductName, AVG(od.Quantity) AS AvgOrderQuantity 
FROM products p 
JOIN [Order Details] od ON p.ProductID = od.ProductID 
GROUP BY ProductName;
""""""

# Fetch data into a pandas DataFrame
df_products = execute_sql_query(sql_query)

# Sort the DataFrame to find products with highest average order quantity
df_products_sorted = df_products.sort_values(by='AvgOrderQuantity', ascending=False)

# Create a bar chart using Plotly
fig = px.bar(df_products_sorted, x='ProductName', y='AvgOrderQuantity', title='Products with Highest Average Order Quantity')

# Display the result to the user
show_to_user(df_products_sorted)
show_to_user(fig)
```","The input code correctly executes a SQL query to fetch product names and their average order quantities, sorts them in descending order, and creates a bar chart to visualize the results. Despite minor differences from the reference implementation, such as sorting separately, the logical flow and outcome are equivalent.",Finetuned
Identify markets (country or region) with the highest average freight cost and create a bar chart to visualize the average freight cost by market.,"```python
import plotly.express as px

# SQL query to get average freight cost by market
sql_query = """"""
SELECT 
    COALESCE(ShipRegion, ShipCountry) AS Market, 
    AVG(Freight) AS AvgFreightCost 
FROM 
    orders 
GROUP BY 
    Market
ORDER BY 
    AvgFreightCost DESC;
""""""

# Execute the SQL query and store the result in a dataframe
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average freight cost by market
fig = px.bar(df, x='Market', y='AvgFreightCost', title='Average Freight Cost by Market')

# Show the plot to the user
show_to_user(fig)
```","```python
import pandas as pd
import plotly.express as px

sql_query = """"""
SELECT 
    ShipCountry AS Market, 
    AVG(Freight) AS AverageFreightCost
FROM 
    orders
GROUP BY 
    ShipCountry
ORDER BY 
    AverageFreightCost DESC
""""""

# Execute SQL query to get average freight costs by market
freight_data = execute_sql_query(sql_query)

# Create bar chart
fig = px.bar(freight_data, x='Market', y='AverageFreightCost', 
             title='Average Freight Cost by Market', 
             labels={'AverageFreightCost': 'Average Freight Cost', 'Market': 'Market'},
             color='AverageFreightCost')

show_to_user(fig)
```","The input code only considers 'ShipCountry' as the market, whereas the reference code uses 'COALESCE(ShipRegion, ShipCountry)' to account for either 'ShipRegion' or 'ShipCountry'. This logic difference affects the definition of 'Market', and thus the analysis does not correctly identify markets as requested.","```python
import pandas as pd
import plotly.express as px

# Execute the SQL query
def execute_sql_query(sql_query: str) -> pd.DataFrame:
    # Stub for SQL execution, to be replaced with actual implementation
    # Example: return pd.read_sql(sql_query, connection)
    data = {'ShipCountry': ['US', 'DE', 'JP'],
            'AverageFreight': [12.34, 56.78, 90.12]}
    return pd.DataFrame(data)

# Display function as a placeholder
def show_to_user(data):
    # Implement display logic
    if isinstance(data, pd.DataFrame):
        print(data)
    else:
        data.show()

# SQL Query to get average freight cost by market
sql_query = """"""
SELECT o.ShipCountry, AVG(o.Freight) AS AverageFreight
FROM orders o
GROUP BY o.ShipCountry
ORDER BY AverageFreight DESC;
""""""

# Execute the query and get the result as a DataFrame
df = execute_sql_query(sql_query)

# Create a bar chart to visualize the average freight cost by market
fig = px.bar(df, x='ShipCountry', y='AverageFreight',
             title='Average Freight Cost by Market',
             labels={'ShipCountry': 'Market (Country)', 'AverageFreight': 'Average Freight Cost'},
             template='plotly')

# Display the bar chart
show_to_user(fig)
```","The input code only averages freight costs by 'ShipCountry', while the reference code combines 'ShipRegion' and 'ShipCountry' as markets using 'COALESCE'. This means the input code overlooks the 'ShipRegion' attribute, deviating from the logic of the reference implementation which groups by either 'ShipRegion' or 'ShipCountry'.",None
